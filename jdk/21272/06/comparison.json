{"files":[{"patch":"@@ -27,0 +27,3 @@\n+# Import common utils\n+. report-utils.sh\n+\n@@ -33,0 +36,4 @@\n+# Collect hs_errs for build-time crashes, e.g. javac, jmod, jlink, CDS.\n+# These usually land in make\/\n+hs_err_files=$(ls make\/hs_err*.log 2> \/dev\/null || true)\n+\n@@ -49,0 +56,12 @@\n+  for hs_err in $hs_err_files; do\n+    echo \"<details><summary><b>View HotSpot error log: \"$hs_err\"<\/b><\/summary>\"\n+    echo ''\n+    echo '```'\n+    echo \"$hs_err:\"\n+    echo ''\n+    cat \"$hs_err\"\n+    echo '```'\n+    echo '<\/details>'\n+    echo ''\n+  done\n+\n@@ -52,0 +71,2 @@\n+\n+truncate_summary\n","filename":".github\/scripts\/gen-build-failure-report.sh","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+# Import common utils\n+. report-utils.sh\n+\n@@ -92,14 +95,0 @@\n-# With many failures, the summary can easily exceed 1024 kB, the limit set by Github\n-# Trim it down if so.\n-summary_size=$(wc -c < $GITHUB_STEP_SUMMARY)\n-if [[ $summary_size -gt 1000000 ]]; then\n-  # Trim to below 1024 kB, and cut off after the last detail group\n-  head -c 1000000 $GITHUB_STEP_SUMMARY | tac | sed -n -e '\/<\\\/details>\/,$ p' | tac > $GITHUB_STEP_SUMMARY.tmp\n-  mv $GITHUB_STEP_SUMMARY.tmp $GITHUB_STEP_SUMMARY\n-  (\n-    echo ''\n-    echo ':x: **WARNING: Summary is too large and has been truncated.**'\n-    echo ''\n-  )  >> $GITHUB_STEP_SUMMARY\n-fi\n-\n@@ -107,0 +96,2 @@\n+\n+truncate_summary\n","filename":".github\/scripts\/gen-test-results.sh","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+function truncate_summary() {\n+  # With large hs_errs, the summary can easily exceed 1024 kB, the limit set by Github\n+  # Trim it down if so.\n+  summary_size=$(wc -c < $GITHUB_STEP_SUMMARY)\n+  if [[ $summary_size -gt 1000000 ]]; then\n+    # Trim to below 1024 kB, and cut off after the last detail group\n+    head -c 1000000 $GITHUB_STEP_SUMMARY | tac | sed -n -e '\/<\\\/details>\/,$ p' | tac > $GITHUB_STEP_SUMMARY.tmp\n+    mv $GITHUB_STEP_SUMMARY.tmp $GITHUB_STEP_SUMMARY\n+    (\n+      echo ''\n+      echo ':x: **WARNING: Summary is too large and has been truncated.**'\n+      echo ''\n+    )  >> $GITHUB_STEP_SUMMARY\n+  fi\n+}\n","filename":".github\/scripts\/report-utils.sh","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -267,0 +267,1 @@\n+docs_JTREG_PROBLEM_LIST += $(TOPDIR)\/test\/docs\/ProblemList.txt\n@@ -871,0 +872,7 @@\n+  ifneq ($$(DOCS_IMAGE_DIR), )\n+    DOCS_PATH := $$(DOCS_IMAGE_DIR)\n+  else\n+    DOCS_PATH := $$(OUTPUTDIR)\/images\/docs\n+  endif\n+  $1_JTREG_BASIC_OPTIONS += -e:DOCS_IMAGE_DIR=$$(DOCS_PATH)\n+\n","filename":"make\/RunTests.gmk","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -361,0 +361,5 @@\n+    # or look like\n+    #     gcc (GCC) 10.2.1 20200825 (Alibaba 10.2.1-3.8 2.32)\n+    #     Copyright (C) 2020 Free Software Foundation, Inc.\n+    #     This is free software; see the source for copying conditions.  There is NO\n+    #     warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n@@ -374,1 +379,2 @@\n-        $SED -e 's\/^.* \\(@<:@1-9@:>@<:@0-9@:>@*\\.@<:@0-9.@:>@*\\)@<:@^0-9.@:>@.*$\/\\1\/'`\n+        $AWK -F ')' '{print [$]2}' | \\\n+        $AWK '{print [$]1}'`\n","filename":"make\/autoconf\/toolchain.m4","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-JTREG_TESTROOTS += $(addprefix $(TOPDIR)\/test\/, hotspot\/jtreg jdk langtools jaxp lib-test)\n+JTREG_TESTROOTS += $(addprefix $(TOPDIR)\/test\/, hotspot\/jtreg jdk langtools jaxp lib-test docs)\n","filename":"make\/common\/FindTests.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22.0.2\/c9ecb94cd31b495da20a27d4581645e8\/9\/GPL\/openjdk-22.0.2_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=41536f115668308ecf4eba92aaf6acaeb0936225828b741efd83b6173ba82963\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk23\/3c5b90190c68498b986a97f276efd28a\/37\/GPL\/openjdk-23_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=08fea92724127c6fa0f2e5ea0b07ff4951ccb1e2f22db3c21eebbd7347152a67\n@@ -36,2 +36,2 @@\n-ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin22-binaries\/releases\/download\/jdk-22.0.2%2B9\/OpenJDK22U-jdk_x64_alpine-linux_hotspot_22.0.2_9.tar.gz\n-ALPINE_LINUX_X64_BOOT_JDK_SHA256=49f73414824b1a7c268a611225fa4d7ce5e25600201e0f1cd59f94d1040b5264\n+ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin23-binaries\/releases\/download\/jdk-23%2B37\/OpenJDK23U-jdk_x64_alpine-linux_hotspot_23_37.tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_SHA256=bff4c78f30d8d173e622bf2f40c36113df47337fc6d1ee5105ed2459841165aa\n@@ -40,2 +40,2 @@\n-MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22.0.2\/c9ecb94cd31b495da20a27d4581645e8\/9\/GPL\/openjdk-22.0.2_macos-aarch64_bin.tar.gz\n-MACOS_AARCH64_BOOT_JDK_SHA256=3dab98730234e1a87aec14bcb8171d2cae101e96ff4eed1dab96abbb08e843fd\n+MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk23\/3c5b90190c68498b986a97f276efd28a\/37\/GPL\/openjdk-23_macos-aarch64_bin.tar.gz\n+MACOS_AARCH64_BOOT_JDK_SHA256=9527bf080a74ae6dca51df413aa826f0c011c6048885e4c8ad112172be8815f3\n@@ -44,2 +44,2 @@\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22.0.2\/c9ecb94cd31b495da20a27d4581645e8\/9\/GPL\/openjdk-22.0.2_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=e8b3ec7a7077711223d31156e771f11723cd7af31c2017f1bd2eda20855940fb\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk23\/3c5b90190c68498b986a97f276efd28a\/37\/GPL\/openjdk-23_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=5c3a909fd2079d0e376dd43c85c4f7d02d08914866f196480bd47784b2a0121e\n@@ -48,2 +48,2 @@\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22.0.2\/c9ecb94cd31b495da20a27d4581645e8\/9\/GPL\/openjdk-22.0.2_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=f2a9b9ab944e71a64637fcdc6b13a1188cf02d4eb9ecf71dc927e98b3e45f5dc\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk23\/3c5b90190c68498b986a97f276efd28a\/37\/GPL\/openjdk-23_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=cba5013874ba50cae543c86fe6423453816c77281e2751a8a9a633d966f1dc04\n","filename":"make\/conf\/github-actions.conf","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -393,2 +393,2 @@\n-    common.boot_jdk_version = \"22\";\n-    common.boot_jdk_build_number = \"36\";\n+    common.boot_jdk_version = \"23\";\n+    common.boot_jdk_build_number = \"37\";\n@@ -960,1 +960,1 @@\n-    if (testedProfile == null) {\n+    if (testedProfile == null || testedProfile == \"docs\") {\n@@ -1002,0 +1002,8 @@\n+    var testOnlyProfilesPrebuiltDocs = {\n+        \"run-test-prebuilt-docs\": clone(testOnlyProfilesPrebuilt[\"run-test-prebuilt\"])\n+    };\n+\n+    testOnlyProfilesPrebuiltDocs[\"run-test-prebuilt-docs\"].dependencies.push(\"docs.doc_api_spec\", \"tidy\");\n+    testOnlyProfilesPrebuiltDocs[\"run-test-prebuilt-docs\"].environment[\"DOCS_IMAGE_DIR\"] = input.get(\"docs.doc_api_spec\", \"install_path\");\n+    testOnlyProfilesPrebuiltDocs[\"run-test-prebuilt-docs\"].labels = \"test-docs\";\n+\n@@ -1005,1 +1013,1 @@\n-    if (input.profile == \"run-test-prebuilt\") {\n+    if (input.profile == \"run-test-prebuilt\" || input.profile == \"run-test-prebuilt-docs\") {\n@@ -1010,10 +1018,7 @@\n-    if (profiles[testedProfile] != null) {\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_os\"]\n-            = profiles[testedProfile][\"target_os\"];\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_cpu\"]\n-            = profiles[testedProfile][\"target_cpu\"];\n-    } else if (profiles[testImageProfile] != null) {\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_os\"]\n-            = profiles[testImageProfile][\"target_os\"];\n-        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"target_cpu\"]\n-            = profiles[testImageProfile][\"target_cpu\"];\n+    function updateProfileTargets(profiles, testedProfile, testImageProfile, targetProfile, runTestProfile) {\n+        var profileToCheck = profiles[testedProfile] || profiles[testImageProfile];\n+\n+        if (profileToCheck != null) {\n+            targetProfile[runTestProfile][\"target_os\"] = profileToCheck[\"target_os\"];\n+            targetProfile[runTestProfile][\"target_cpu\"] = profileToCheck[\"target_cpu\"];\n+        }\n@@ -1021,0 +1026,5 @@\n+\n+    updateProfileTargets(profiles, testedProfile, testImageProfile, testOnlyProfilesPrebuilt, \"run-test-prebuilt\");\n+    updateProfileTargets(profiles, testedProfile, testImageProfile, testOnlyProfilesPrebuiltDocs, \"run-test-prebuilt-docs\");\n+\n+    profiles = concatObjects(profiles, testOnlyProfilesPrebuiltDocs);\n@@ -1070,0 +1080,2 @@\n+        profiles[\"run-test-prebuilt-docs\"] = concatObjects(profiles[\"run-test-prebuilt-docs\"],\n+            runTestPrebuiltSrcFullExtra);\n","filename":"make\/conf\/jib-profiles.js","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"22 23 24\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"23 24\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-    DISABLED_WARNINGS_gcc_LinuxDebuggerLocal.cpp := unused-variable, \\\n@@ -64,1 +63,0 @@\n-    DISABLED_WARNINGS_gcc_symtab.c := unused-but-set-variable, \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,18 @@\n+\n+################################################################################\n+## Build libsleef\n+################################################################################\n+\n+ifeq ($(call isTargetOs, linux)+$(call isTargetCpu, riscv64)+$(INCLUDE_COMPILER2), true+true+true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBSLEEF, \\\n+      NAME := sleef, \\\n+      OPTIMIZATION := HIGH, \\\n+      SRC := libsleef\/lib, \\\n+      EXTRA_SRC := libsleef\/generated, \\\n+      DISABLED_WARNINGS_gcc := unused-function sign-compare tautological-compare ignored-qualifiers, \\\n+      DISABLED_WARNINGS_clang := unused-function sign-compare tautological-compare ignored-qualifiers, \\\n+      CFLAGS := -march=rv64gcv, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBSLEEF)\n+endif\n","filename":"make\/modules\/jdk.incubator.vector\/Lib.gmk","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2310,4 +2310,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -2724,1 +2720,1 @@\n-      \/\/ Fix up any out-of-range offsets.\n+      \/* Fix up any out-of-range offsets. *\/\n@@ -2765,5 +2761,1 @@\n-      \/\/ Fix up any out-of-range offsets.\n-      assert_different_registers(rscratch1, base);\n-      Address addr = Address(base, disp);\n-      addr = __ legitimize_address(addr, (1 << T), rscratch1);\n-      (masm->*insn)(reg, T, addr);\n+      (masm->*insn)(reg, T, Address(base, disp));\n@@ -2824,1 +2816,1 @@\n-  enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{\n@@ -2832,1 +2824,1 @@\n-  enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{\n@@ -2840,1 +2832,1 @@\n-  enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{\n@@ -2848,1 +2840,1 @@\n-  enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{\n@@ -2856,1 +2848,1 @@\n-  enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{\n@@ -2864,1 +2856,1 @@\n-  enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{\n@@ -2872,1 +2864,1 @@\n-  enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{\n@@ -2880,1 +2872,1 @@\n-  enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{\n@@ -2888,1 +2880,1 @@\n-  enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{\n+  enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{\n@@ -2896,1 +2888,1 @@\n-  enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{\n@@ -2904,1 +2896,1 @@\n-  enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{\n@@ -2912,1 +2904,1 @@\n-  enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{\n@@ -2920,1 +2912,1 @@\n-  enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{\n+  enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{\n@@ -2928,1 +2920,1 @@\n-  enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{\n@@ -2936,1 +2928,1 @@\n-  enc_class aarch64_enc_strb(iRegI src, memory mem) %{\n+  enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{\n@@ -2944,1 +2936,1 @@\n-  enc_class aarch64_enc_strb0(memory mem) %{\n+  enc_class aarch64_enc_strb0(memory1 mem) %{\n@@ -2951,1 +2943,1 @@\n-  enc_class aarch64_enc_strh(iRegI src, memory mem) %{\n+  enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{\n@@ -2959,1 +2951,1 @@\n-  enc_class aarch64_enc_strh0(memory mem) %{\n+  enc_class aarch64_enc_strh0(memory2 mem) %{\n@@ -2966,1 +2958,1 @@\n-  enc_class aarch64_enc_strw(iRegI src, memory mem) %{\n+  enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{\n@@ -2974,1 +2966,1 @@\n-  enc_class aarch64_enc_strw0(memory mem) %{\n+  enc_class aarch64_enc_strw0(memory4 mem) %{\n@@ -2981,1 +2973,1 @@\n-  enc_class aarch64_enc_str(iRegL src, memory mem) %{\n+  enc_class aarch64_enc_str(iRegL src, memory8 mem) %{\n@@ -2996,1 +2988,1 @@\n-  enc_class aarch64_enc_str0(memory mem) %{\n+  enc_class aarch64_enc_str0(memory8 mem) %{\n@@ -3003,1 +2995,1 @@\n-  enc_class aarch64_enc_strs(vRegF src, memory mem) %{\n+  enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{\n@@ -3011,1 +3003,1 @@\n-  enc_class aarch64_enc_strd(vRegD src, memory mem) %{\n+  enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{\n@@ -3019,1 +3011,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n@@ -3221,1 +3213,1 @@\n-  enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{\n+  enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{\n@@ -3249,1 +3241,1 @@\n-  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{\n+  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{\n@@ -4177,1 +4169,1 @@\n-\/\/ Offset for immediate loads and stores\n+\/\/ Offset for scaled or unscaled immediate loads and stores\n@@ -4180,1 +4172,51 @@\n-  predicate(n->get_int() >= -256 && n->get_int() <= 65520);\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset1()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset2()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 1));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset4()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 2));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset8()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 3));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immIOffset16()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_int(), 4));\n@@ -4198,0 +4240,50 @@\n+operand immLoffset1()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset2()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 1));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset4()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 2));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset8()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 3));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immLoffset16()\n+%{\n+  predicate(Address::offset_ok_for_immed(n->get_long(), 4));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -5110,1 +5202,85 @@\n-operand indOffI(iRegP reg, immIOffset off)\n+operand indOffI1(iRegP reg, immIOffset1 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffI2(iRegP reg, immIOffset2 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffI4(iRegP reg, immIOffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffI8(iRegP reg, immIOffset8 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffI16(iRegP reg, immIOffset16 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL1(iRegP reg, immLoffset1 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL2(iRegP reg, immLoffset2 off)\n@@ -5124,1 +5300,29 @@\n-operand indOffL(iRegP reg, immLOffset off)\n+operand indOffL4(iRegP reg, immLoffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL8(iRegP reg, immLoffset8 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffL16(iRegP reg, immLoffset16 off)\n@@ -5500,1 +5704,4 @@\n-opclass vmem(indirect, indIndex, indOffI, indOffL, indOffIN, indOffLN);\n+opclass vmem2(indirect, indIndex, indOffI2, indOffL2);\n+opclass vmem4(indirect, indIndex, indOffI4, indOffL4);\n+opclass vmem8(indirect, indIndex, indOffI8, indOffL8);\n+opclass vmem16(indirect, indIndex, indOffI16, indOffL16);\n@@ -5512,3 +5719,17 @@\n-opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN,\n-               indOffLN, indirectX2P, indOffX2P);\n+opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n+\n+opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n+\n+opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n+\n+opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n+\n+\/\/ All of the memory operands. For the pipeline description.\n+opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,\n+               indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n+\n@@ -6216,1 +6437,1 @@\n-instruct loadB(iRegINoSp dst, memory mem)\n+instruct loadB(iRegINoSp dst, memory1 mem)\n@@ -6230,1 +6451,1 @@\n-instruct loadB2L(iRegLNoSp dst, memory mem)\n+instruct loadB2L(iRegLNoSp dst, memory1 mem)\n@@ -6244,1 +6465,1 @@\n-instruct loadUB(iRegINoSp dst, memory mem)\n+instruct loadUB(iRegINoSp dst, memory1 mem)\n@@ -6258,1 +6479,1 @@\n-instruct loadUB2L(iRegLNoSp dst, memory mem)\n+instruct loadUB2L(iRegLNoSp dst, memory1 mem)\n@@ -6272,1 +6493,1 @@\n-instruct loadS(iRegINoSp dst, memory mem)\n+instruct loadS(iRegINoSp dst, memory2 mem)\n@@ -6286,1 +6507,1 @@\n-instruct loadS2L(iRegLNoSp dst, memory mem)\n+instruct loadS2L(iRegLNoSp dst, memory2 mem)\n@@ -6300,1 +6521,1 @@\n-instruct loadUS(iRegINoSp dst, memory mem)\n+instruct loadUS(iRegINoSp dst, memory2 mem)\n@@ -6314,1 +6535,1 @@\n-instruct loadUS2L(iRegLNoSp dst, memory mem)\n+instruct loadUS2L(iRegLNoSp dst, memory2 mem)\n@@ -6328,1 +6549,1 @@\n-instruct loadI(iRegINoSp dst, memory mem)\n+instruct loadI(iRegINoSp dst, memory4 mem)\n@@ -6342,1 +6563,1 @@\n-instruct loadI2L(iRegLNoSp dst, memory mem)\n+instruct loadI2L(iRegLNoSp dst, memory4 mem)\n@@ -6356,1 +6577,1 @@\n-instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)\n+instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)\n@@ -6370,1 +6591,1 @@\n-instruct loadL(iRegLNoSp dst, memory mem)\n+instruct loadL(iRegLNoSp dst, memory8 mem)\n@@ -6384,1 +6605,1 @@\n-instruct loadRange(iRegINoSp dst, memory mem)\n+instruct loadRange(iRegINoSp dst, memory4 mem)\n@@ -6397,1 +6618,1 @@\n-instruct loadP(iRegPNoSp dst, memory mem)\n+instruct loadP(iRegPNoSp dst, memory8 mem)\n@@ -6411,1 +6632,1 @@\n-instruct loadN(iRegNNoSp dst, memory mem)\n+instruct loadN(iRegNNoSp dst, memory4 mem)\n@@ -6425,1 +6646,1 @@\n-instruct loadKlass(iRegPNoSp dst, memory mem)\n+instruct loadKlass(iRegPNoSp dst, memory8 mem)\n@@ -6439,1 +6660,1 @@\n-instruct loadNKlass(iRegNNoSp dst, memory mem)\n+instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n@@ -6453,1 +6674,1 @@\n-instruct loadF(vRegF dst, memory mem)\n+instruct loadF(vRegF dst, memory4 mem)\n@@ -6467,1 +6688,1 @@\n-instruct loadD(vRegD dst, memory mem)\n+instruct loadD(vRegD dst, memory8 mem)\n@@ -6670,30 +6891,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeimmCM0(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST);\n-  format %{ \"storestore (elided)\\n\\t\"\n-            \"strb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n-\/\/ Store CMS card-mark Immediate with intervening StoreStore\n-\/\/ needed when using CMS with no conditional card marking\n-instruct storeimmCM0_ordered(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"storestore\\n\\t\"\n-            \"dmb ishst\"\n-            \"\\n\\tstrb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0_ordered(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n@@ -6701,1 +6892,1 @@\n-instruct storeB(iRegIorL2I src, memory mem)\n+instruct storeB(iRegIorL2I src, memory1 mem)\n@@ -6715,1 +6906,1 @@\n-instruct storeimmB0(immI0 zero, memory mem)\n+instruct storeimmB0(immI0 zero, memory1 mem)\n@@ -6729,1 +6920,1 @@\n-instruct storeC(iRegIorL2I src, memory mem)\n+instruct storeC(iRegIorL2I src, memory2 mem)\n@@ -6742,1 +6933,1 @@\n-instruct storeimmC0(immI0 zero, memory mem)\n+instruct storeimmC0(immI0 zero, memory2 mem)\n@@ -6757,1 +6948,1 @@\n-instruct storeI(iRegIorL2I src, memory mem)\n+instruct storeI(iRegIorL2I src, memory4 mem)\n@@ -6770,1 +6961,1 @@\n-instruct storeimmI0(immI0 zero, memory mem)\n+instruct storeimmI0(immI0 zero, memory4 mem)\n@@ -6784,1 +6975,1 @@\n-instruct storeL(iRegL src, memory mem)\n+instruct storeL(iRegL src, memory8 mem)\n@@ -6798,1 +6989,1 @@\n-instruct storeimmL0(immL0 zero, memory mem)\n+instruct storeimmL0(immL0 zero, memory8 mem)\n@@ -6812,1 +7003,1 @@\n-instruct storeP(iRegP src, memory mem)\n+instruct storeP(iRegP src, memory8 mem)\n@@ -6826,1 +7017,1 @@\n-instruct storeimmP0(immP0 zero, memory mem)\n+instruct storeimmP0(immP0 zero, memory8 mem)\n@@ -6840,1 +7031,1 @@\n-instruct storeN(iRegN src, memory mem)\n+instruct storeN(iRegN src, memory4 mem)\n@@ -6853,1 +7044,1 @@\n-instruct storeImmN0(immN0 zero, memory mem)\n+instruct storeImmN0(immN0 zero, memory4 mem)\n@@ -6867,1 +7058,1 @@\n-instruct storeF(vRegF src, memory mem)\n+instruct storeF(vRegF src, memory4 mem)\n@@ -6884,1 +7075,1 @@\n-instruct storeD(vRegD src, memory mem)\n+instruct storeD(vRegD src, memory8 mem)\n@@ -6898,1 +7089,1 @@\n-instruct storeNKlass(iRegN src, memory mem)\n+instruct storeNKlass(iRegN src, memory4 mem)\n@@ -6917,1 +7108,1 @@\n-instruct prefetchalloc( memory mem ) %{\n+instruct prefetchalloc( memory8 mem ) %{\n@@ -7489,1 +7680,1 @@\n-instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{\n+instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{\n@@ -7530,1 +7721,1 @@\n-instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{\n+instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{\n@@ -16683,1 +16874,1 @@\n-instruct compressBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n+instruct compressBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n@@ -16720,1 +16911,1 @@\n-instruct compressBitsL_memcon(iRegLNoSp dst, memory mem, immL mask,\n+instruct compressBitsL_memcon(iRegLNoSp dst, memory8 mem, immL mask,\n@@ -16757,1 +16948,1 @@\n-instruct expandBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n+instruct expandBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n@@ -16795,1 +16986,1 @@\n-instruct expandBitsL_memcon(iRegINoSp dst, memory mem, immL mask,\n+instruct expandBitsL_memcon(iRegINoSp dst, memory8 mem, immL mask,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":307,"deletions":116,"binary":false,"changes":423,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-instruct loadV2(vReg dst, vmem mem) %{\n+instruct loadV2(vReg dst, vmem2 mem) %{\n@@ -357,1 +357,1 @@\n-instruct storeV2(vReg src, vmem mem) %{\n+instruct storeV2(vReg src, vmem2 mem) %{\n@@ -366,1 +366,1 @@\n-instruct loadV4(vReg dst, vmem mem) %{\n+instruct loadV4(vReg dst, vmem4 mem) %{\n@@ -375,1 +375,1 @@\n-instruct storeV4(vReg src, vmem mem) %{\n+instruct storeV4(vReg src, vmem4 mem) %{\n@@ -384,1 +384,1 @@\n-instruct loadV8(vReg dst, vmem mem) %{\n+instruct loadV8(vReg dst, vmem8 mem) %{\n@@ -393,1 +393,1 @@\n-instruct storeV8(vReg src, vmem mem) %{\n+instruct storeV8(vReg src, vmem8 mem) %{\n@@ -402,1 +402,1 @@\n-instruct loadV16(vReg dst, vmem mem) %{\n+instruct loadV16(vReg dst, vmem16 mem) %{\n@@ -411,1 +411,1 @@\n-instruct storeV16(vReg src, vmem mem) %{\n+instruct storeV16(vReg src, vmem16 mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-instruct $1V$2(vReg $3, vmem mem) %{\n+instruct $1V$2(vReg $3, vmem$2 mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl\n+  enc_class aarch64_enc_$2($1 dst, memory$5 mem) %{dnl\n@@ -56,1 +56,1 @@\n-  enc_class aarch64_enc_$2($1 src, memory mem) %{dnl\n+  enc_class aarch64_enc_$2($1 src, memory$5 mem) %{dnl\n@@ -61,1 +61,1 @@\n-  enc_class aarch64_enc_$2`'0(memory mem) %{\n+  enc_class aarch64_enc_$2`'0(memory$4 mem) %{\n@@ -85,1 +85,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1171,2 +1171,2 @@\n-    __ ldrb(rscratch1, Address(op->klass()->as_register(),\n-                               InstanceKlass::init_state_offset()));\n+    __ lea(rscratch1, Address(op->klass()->as_register(), InstanceKlass::init_state_offset()));\n+    __ ldarb(rscratch1, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-instruct xLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n+instruct xLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-instruct zLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n+instruct zLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1841,1 +1841,2 @@\n-  ldrb(scratch, Address(klass, InstanceKlass::init_state_offset()));\n+  lea(scratch, Address(klass, InstanceKlass::init_state_offset()));\n+  ldarb(scratch, scratch);\n@@ -5013,1 +5014,1 @@\n-    if (CompressedOops::shift() != 0 || d != s) {\n+    if (CompressedOops::shift() != 0) {\n@@ -5015,0 +5016,2 @@\n+    } else if (d != s) {\n+      mov(d, s);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -39,1 +40,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<MacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -70,1 +71,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -2001,7 +2002,15 @@\n-  aep = __ pc();  __ push_ptr();  __ b(L);\n-  fep = __ pc();  __ push_f();    __ b(L);\n-  dep = __ pc();  __ push_d();    __ b(L);\n-  lep = __ pc();  __ push_l();    __ b(L);\n-  bep = cep = sep =\n-  iep = __ pc();  __ push_i();\n-  vep = __ pc();\n+  aep = __ pc();     \/\/ atos entry point\n+      __ push_ptr();\n+      __ b(L);\n+  fep = __ pc();     \/\/ ftos entry point\n+      __ push_f();\n+      __ b(L);\n+  dep = __ pc();     \/\/ dtos entry point\n+      __ push_d();\n+      __ b(L);\n+  lep = __ pc();     \/\/ ltos entry point\n+      __ push_l();\n+      __ b(L);\n+  bep = cep = sep = iep = __ pc();     \/\/ [bcsi]tos entry point\n+      __ push_i();\n+  vep = __ pc();     \/\/ vtos entry point\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -52,1 +53,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1006,4 +1006,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n@@ -4229,12 +4225,0 @@\n-instruct storeCM(memoryB mem, store_RegI src) %{\n-  match(Set mem (StoreCM mem src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  size(4);\n-  format %{ \"STRB    $src,$mem\\t! CMS card-mark byte\" %}\n-  ins_encode %{\n-    __ strb($src$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(istore_mem_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -951,0 +951,1 @@\n+    __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3977,0 +3977,1 @@\n+  __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2277,0 +2277,1 @@\n+    \/\/ acquire barrier included in membar_storestore() which follows the allocation immediately.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2413,1 +2413,1 @@\n-  Label L_fallthrough;\n+  Label L_check_thread, L_fallthrough;\n@@ -2422,0 +2422,1 @@\n+  \/\/ acquire by cmp-branch-isync if fully_initialized\n@@ -2423,1 +2424,3 @@\n-  beq(CCR0, *L_fast_path);\n+  bne(CCR0, L_check_thread);\n+  isync();\n+  b(*L_fast_path);\n@@ -2426,0 +2429,1 @@\n+  bind(L_check_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2157,4 +2157,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n@@ -6485,17 +6481,0 @@\n-\/\/----------Store Instructions With Zeros--------------------------------------\n-\n-instruct storeCM(memory mem, immI_0 zero) %{\n-  match(Set mem (StoreCM mem zero));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"STB     #0, $mem \\t\/\/ CMS card-mark byte store\" %}\n-  size(8);\n-  ins_encode %{\n-    __ li(R0, 0);\n-    \/\/ No release barrier: Oops are allowed to get visible after marking.\n-    guarantee($mem$$base$$Register != R1_SP, \"use frame_slots_bias\");\n-    __ stb(R0, $mem$$disp, $mem$$base$$Register);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -49,2 +49,4 @@\n-    n_int_register_parameters_c   = 8, \/\/ x10, x11, ... x17 (c_rarg0, c_rarg1, ...)\n-    n_float_register_parameters_c = 8, \/\/ f10, f11, ... f17 (c_farg0, c_farg1, ... )\n+    \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n+    n_int_register_parameters_c   = 8,   \/\/ x10, x11, ... x17 (c_rarg0, c_rarg1, ...)\n+    n_float_register_parameters_c = 8,   \/\/ f10, f11, ... f17 (c_farg0, c_farg1, ... )\n+    n_vector_register_parameters_c = 16,  \/\/ v8, v9, ... v23\n@@ -146,0 +148,4 @@\n+constexpr Register t3 = x28;\n+constexpr Register t4 = x29;\n+constexpr Register t5 = x30;\n+constexpr Register t6 = x31;\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+    __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -496,0 +496,1 @@\n+  membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -40,1 +41,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<MacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1969,4 +1969,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -1975,1 +1971,1 @@\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n@@ -1979,2 +1975,6 @@\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n@@ -5038,35 +5038,0 @@\n-\/\/ Store Instructions\n-\/\/ Store CMS card-mark Immediate\n-instruct storeimmCM0(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(STORE_COST);\n-  format %{ \"storestore (elided)\\n\\t\"\n-            \"sb zr, $mem\\t# byte, #@storeimmCM0\" %}\n-\n-  ins_encode %{\n-    __ sb(zr, Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n-\/\/ Store CMS card-mark Immediate with intervening StoreStore\n-\/\/ needed when using CMS with no conditional card marking\n-instruct storeimmCM0_ordered(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(ALU_COST + STORE_COST);\n-  format %{ \"membar(StoreStore)\\n\\t\"\n-            \"sb zr, $mem\\t# byte, #@storeimmCM0_ordered\" %}\n-\n-  ins_encode %{\n-    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    __ sb(zr, Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n@@ -10078,0 +10043,17 @@\n+\/\/ Call Runtime Instruction without safepoint and with vector arguments\n+\n+instruct CallLeafDirectVector(method meth, rFlagsReg cr)\n+%{\n+  match(CallLeafVector);\n+\n+  effect(USE meth, KILL cr);\n+\n+  ins_cost(BRANCH_COST);\n+\n+  format %{ \"CALL, runtime leaf vector $meth\" %}\n+\n+  ins_encode(riscv_enc_java_to_runtime(meth));\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":24,"deletions":42,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -669,1 +669,14 @@\n-  Unimplemented();\n+  assert(total_args_passed <= Argument::n_vector_register_parameters_c, \"unsupported\");\n+  assert(num_bits >= 64 && num_bits <= 2048 && is_power_of_2(num_bits), \"unsupported\");\n+\n+  \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n+  static const VectorRegister VEC_ArgReg[Argument::n_vector_register_parameters_c] = {\n+    v8, v9, v10, v11, v12, v13, v14, v15,\n+    v16, v17, v18, v19, v20, v21, v22, v23\n+  };\n+\n+  const int next_reg_val = 3;\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[i]->as_VMReg();\n+    regs[i].set_pair(vmreg->next(next_reg_val), vmreg);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4485,1 +4485,1 @@\n-    reg_cache_regs += RegSet::of(x28, x29, x30, x31); \/\/ t3, t4, t5, t6\n+    reg_cache_regs += RegSet::of(t3, t4, t5, t6);\n@@ -5465,2 +5465,2 @@\n-    Register dstBackup = x31;\n-    Register length    = x28;     \/\/ t3, total length of src data in bytes\n+    Register dstBackup = t6;\n+    Register length    = t3;     \/\/ total length of src data in bytes\n@@ -5501,1 +5501,1 @@\n-      Register size      = x29;   \/\/ t4\n+      Register size      = t4;\n@@ -5553,1 +5553,1 @@\n-      Register combined32Bits = x29; \/\/ t5\n+      Register combined32Bits = t4;\n@@ -5711,4 +5711,4 @@\n-    Register temp0 = x28; \/\/ t3\n-    Register temp1 = x29; \/\/ t4\n-    Register temp2 = x30; \/\/ t5\n-    Register temp3 = x31; \/\/ t6\n+    Register temp0 = t3;\n+    Register temp1 = t4;\n+    Register temp2 = t5;\n+    Register temp3 = t6;\n@@ -6074,0 +6074,52 @@\n+  void generate_vector_math_stubs() {\n+    if (!UseRVV) {\n+      log_info(library)(\"vector is not supported, skip loading vector math (sleef) library!\");\n+      return;\n+    }\n+\n+    \/\/ Get native vector math stub routine addresses\n+    void* libsleef = nullptr;\n+    char ebuf[1024];\n+    char dll_name[JVM_MAXPATHLEN];\n+    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n+      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n+    }\n+    if (libsleef == nullptr) {\n+      log_info(library)(\"Failed to load native vector math (sleef) library, %s!\", ebuf);\n+      return;\n+    }\n+\n+    \/\/ Method naming convention\n+    \/\/   All the methods are named as <OP><T>_<U><suffix>\n+    \/\/\n+    \/\/   Where:\n+    \/\/     <OP>     is the operation name, e.g. sin, cos\n+    \/\/     <T>      is to indicate float\/double\n+    \/\/              \"fx\/dx\" for vector float\/double operation\n+    \/\/     <U>      is the precision level\n+    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+    \/\/               We use \"u10\" for all operations by default\n+    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n+    \/\/     <suffix> rvv, indicates riscv vector extension\n+    \/\/\n+    \/\/   e.g. sinfx_u10rvv is the method for computing vector float sin using rvv instructions\n+    \/\/\n+    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n+\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+      if (vop == VectorSupport::VECTOR_OP_TANH) { \/\/ skip tanh because of performance regression\n+        continue;\n+      }\n+\n+      \/\/ The native library does not support u10 level of \"hypot\".\n+      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+      snprintf(ebuf, sizeof(ebuf), \"%sfx_%srvv\", VectorSupport::mathname[op], ulf);\n+      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n+\n+      snprintf(ebuf, sizeof(ebuf), \"%sdx_%srvv\", VectorSupport::mathname[op], ulf);\n+      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n+    }\n+  }\n+\n@@ -6105,1 +6157,1 @@\n-                    c_rarg7, t2, x28, x29, x30, x31);   \/\/ misc tmps\n+                    c_rarg7, t2, t3, t4, t5, t6);       \/\/ misc tmps\n@@ -6294,0 +6346,2 @@\n+    generate_vector_math_stubs();\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":64,"deletions":10,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -73,1 +74,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -1751,7 +1752,15 @@\n-  aep = __ pc();  __ push_ptr();  __ j(L);\n-  fep = __ pc();  __ push_f();    __ j(L);\n-  dep = __ pc();  __ push_d();    __ j(L);\n-  lep = __ pc();  __ push_l();    __ j(L);\n-  bep = cep = sep =\n-  iep = __ pc();  __ push_i();\n-  vep = __ pc();\n+  aep = __ pc();     \/\/ atos entry point\n+      __ push_ptr();\n+      __ j(L);\n+  fep = __ pc();     \/\/ ftos entry point\n+      __ push_f();\n+      __ j(L);\n+  dep = __ pc();     \/\/ dtos entry point\n+      __ push_d();\n+      __ j(L);\n+  lep = __ pc();     \/\/ ltos entry point\n+      __ push_l();\n+      __ j(L);\n+  bep = cep = sep = iep = __ pc();     \/\/ [bcsi]tos entry point\n+      __ push_i();\n+  vep = __ pc();     \/\/ vtos entry point\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -52,1 +53,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2353,0 +2353,1 @@\n+    \/\/ init_state needs acquire, but S390 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3462,1 +3462,2 @@\n-  \/\/ Fast path check: class is fully initialized\n+  \/\/ Fast path check: class is fully initialized.\n+  \/\/ init_state needs acquire, but S390 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -66,2 +66,5 @@\n-  \/\/ Suppress CMOVL. Conditional move available on z\/Architecture only from z196 onwards. Not exploited yet.\n-  static int long_cmove_cost() { return ConditionalMoveLimit; }\n+  \/\/ Use conditional move (CMOVL)\n+  static int long_cmove_cost() {\n+    \/\/ z196\/z11 or later hardware support conditional moves\n+    return VM_Version::has_LoadStoreConditional() ? 0 : ConditionalMoveLimit;\n+  }\n@@ -69,2 +72,4 @@\n-  \/\/ Suppress CMOVF. Conditional move available on z\/Architecture only from z196 onwards. Not exploited yet.\n-  static int float_cmove_cost() { return ConditionalMoveLimit; }\n+  static int float_cmove_cost() {\n+    \/\/ z196\/z11 or later hardware support conditional moves\n+    return VM_Version::has_LoadStoreConditional() ? 0 : ConditionalMoveLimit;\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1480,4 +1480,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n@@ -4229,22 +4225,0 @@\n-instruct storeCM(memory mem, immI_0 src) %{\n-  match(Set mem (StoreCM mem src));\n-  ins_cost(MEMORY_REF_COST);\n-  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n-  format %{ \"STC(Y)  $src,$mem\\t # CMS card-mark byte (must be 0!)\" %}\n-  ins_encode %{\n-    guarantee($mem$$index$$Register != Z_R0, \"content will not be used.\");\n-    if ($mem$$index$$Register != noreg) {\n-      \/\/ Can't use clear_mem --> load const zero and store character.\n-      __ load_const_optimized(Z_R0_scratch, (long)0);\n-      if (Immediate::is_uimm12($mem$$disp)) {\n-        __ z_stc(Z_R0_scratch, $mem$$Address);\n-      } else {\n-        __ z_stcy(Z_R0_scratch, $mem$$Address);\n-      }\n-    } else {\n-      __ clear_mem(Address($mem$$Address), 1);\n-    }\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1581,0 +1581,1 @@\n+    \/\/ init_state needs acquire, but x86 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -825,1 +825,1 @@\n-    testl(monitor, monitor);            \/\/ Fast Unlock ZF = 0\n+    orl(t, 1); \/\/ Fast Unlock ZF = 0\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5087,1 +5087,2 @@\n-  \/\/ Fast path check: class is fully initialized\n+  \/\/ Fast path check: class is fully initialized.\n+  \/\/ init_state needs acquire, but x86 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4187,2 +4187,2 @@\n-      for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-        int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4193,1 +4193,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n@@ -4196,1 +4196,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n@@ -4201,2 +4201,2 @@\n-    for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-      int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4206,1 +4206,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4209,1 +4209,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4212,1 +4212,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4215,1 +4215,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4218,1 +4218,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4221,1 +4221,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4051,0 +4051,1 @@\n+  \/\/ init_state needs acquire, but x86 is TSO, and so we are already good.\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -440,0 +440,1 @@\n+#ifndef PRODUCT\n@@ -456,0 +457,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2234,4 +2234,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6325,11 +6325,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM(memory mem, immI8 src) %{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150);\n-  format %{ \"MOV8   $mem,$src\\t! CMS card-mark imm0\" %}\n-  opcode(0xC6);               \/* C6 \/0 *\/\n-  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n-  ins_pipe( ialu_mem_imm );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5301,26 +5301,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM0_reg(memory mem, immI_0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movb    $mem, R12\\t# CMS card-mark byte 0 (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmCM0(memory mem, immI_0 src)\n-%{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movb    $mem, $src\\t# CMS card-mark byte 0\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    const char* subsystem_path() {\n+    const char* subsystem_path() override {\n@@ -73,1 +73,1 @@\n-    void set_subsystem_path(const char* cgroup_path) {\n+    void set_subsystem_path(const char* cgroup_path) override {\n@@ -76,1 +76,1 @@\n-    const char* mount_point() { return reader()->mount_point(); }\n+    const char* mount_point() override { return reader()->mount_point(); }\n@@ -100,1 +100,1 @@\n-    const char* subsystem_path() {\n+    const char* subsystem_path() override {\n@@ -106,1 +106,1 @@\n-    void set_subsystem_path(const char* cgroup_path) {\n+    void set_subsystem_path(const char* cgroup_path) override {\n@@ -109,1 +109,1 @@\n-    const char* mount_point() { return reader()->mount_point(); }\n+    const char* mount_point() override { return reader()->mount_point(); }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -279,1 +279,0 @@\n-  if( strcmp(opType,\"StoreCM\")==0) return Form::idealB;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3657,1 +3657,0 @@\n-    \"StoreCM\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,3 +104,0 @@\n-#ifdef _WINDOWS\n-    \/\/ qsort() on Windows reverse the order of fields with the same size\n-    \/\/ the extension of the comparison function below preserves this order\n@@ -108,0 +105,2 @@\n+    \/\/ qsort() may reverse the order of fields with the same size.\n+    \/\/ The extension is to ensure stable sort.\n@@ -112,3 +111,0 @@\n-#else\n-    return (*y)->size() - (*x)->size();\n-#endif \/\/ _WINDOWS\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -335,1 +335,2 @@\n-      access.set_barrier_data(access.barrier_data() ^ G1C2BarrierPre);\n+      \/\/ Pre-barriers are unnecessary for tightly-coupled initialization stores.\n+      access.set_barrier_data(access.barrier_data() & ~G1C2BarrierPre);\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -349,5 +349,3 @@\n-      time_remaining_ms = _policy->select_candidates_from_marking(&candidates()->marking_regions(),\n-                                                                  time_remaining_ms,\n-                                                                  &initial_old_regions,\n-                                                                  &_optional_old_regions,\n-                                                                  &pinned_marking_regions);\n+      time_remaining_ms = select_candidates_from_marking(time_remaining_ms,\n+                                                         &initial_old_regions,\n+                                                         &pinned_marking_regions);\n@@ -358,5 +356,3 @@\n-    _policy->select_candidates_from_retained(&candidates()->retained_regions(),\n-                                             time_remaining_ms,\n-                                             &initial_old_regions,\n-                                             &_optional_old_regions,\n-                                             &pinned_retained_regions);\n+    select_candidates_from_retained(time_remaining_ms,\n+                                    &initial_old_regions,\n+                                    &pinned_retained_regions);\n@@ -397,0 +393,209 @@\n+static void print_finish_message(const char* reason, bool from_marking) {\n+  log_debug(gc, ergo, cset)(\"Finish adding %s candidates to collection set (%s).\",\n+                            from_marking ? \"marking\" : \"retained\", reason);\n+}\n+\n+double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms,\n+                                                       G1CollectionCandidateRegionList* initial_old_regions,\n+                                                       G1CollectionCandidateRegionList* pinned_old_regions) {\n+  uint num_expensive_regions = 0;\n+\n+  uint num_initial_regions_selected = 0;\n+  uint num_optional_regions_selected = 0;\n+  uint num_pinned_regions = 0;\n+\n+  double predicted_initial_time_ms = 0.0;\n+  double predicted_optional_time_ms = 0.0;\n+\n+  double optional_threshold_ms = time_remaining_ms * _policy->optional_prediction_fraction();\n+\n+  const uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n+  const uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n+  const uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n+  bool check_time_remaining = _policy->use_adaptive_young_list_length();\n+\n+  G1CollectionCandidateList* marking_list = &candidates()->marking_regions();\n+  assert(marking_list != nullptr, \"must be\");\n+\n+  log_debug(gc, ergo, cset)(\"Start adding marking candidates to collection set. \"\n+                            \"Min %u regions, max %u regions, available %u regions\"\n+                            \"time remaining %1.2fms, optional threshold %1.2fms\",\n+                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n+\n+  G1CollectionCandidateListIterator iter = marking_list->begin();\n+  for (; iter != marking_list->end(); ++iter) {\n+    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n+      \/\/ Added maximum number of old regions to the CSet.\n+      print_finish_message(\"Maximum number of regions reached\", true);\n+      break;\n+    }\n+    G1HeapRegion* hr = (*iter)->_r;\n+    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n+    \/\/ space from them (and we expect to get free space from marking candidates).\n+    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n+    \/\/ to not impact the mixed phase too much.\n+    if (hr->has_pinned_objects()) {\n+      num_pinned_regions++;\n+      (*iter)->update_num_unreclaimed();\n+      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n+      pinned_old_regions->append(hr);\n+      continue;\n+    }\n+    double predicted_time_ms = _policy->predict_region_total_time_ms(hr, false);\n+    time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);\n+    \/\/ Add regions to old set until we reach the minimum amount\n+    if (initial_old_regions->length() < min_old_cset_length) {\n+      initial_old_regions->append(hr);\n+      num_initial_regions_selected++;\n+      predicted_initial_time_ms += predicted_time_ms;\n+      \/\/ Record the number of regions added with no time remaining\n+      if (time_remaining_ms == 0.0) {\n+        num_expensive_regions++;\n+      }\n+    } else if (!check_time_remaining) {\n+      \/\/ In the non-auto-tuning case, we'll finish adding regions\n+      \/\/ to the CSet if we reach the minimum.\n+      print_finish_message(\"Region amount reached min\", true);\n+      break;\n+    } else {\n+      \/\/ Keep adding regions to old set until we reach the optional threshold\n+      if (time_remaining_ms > optional_threshold_ms) {\n+        predicted_initial_time_ms += predicted_time_ms;\n+        initial_old_regions->append(hr);\n+        num_initial_regions_selected++;\n+      } else if (time_remaining_ms > 0) {\n+        \/\/ Keep adding optional regions until time is up.\n+        assert(_optional_old_regions.length() < max_optional_regions, \"Should not be possible.\");\n+        predicted_optional_time_ms += predicted_time_ms;\n+        _optional_old_regions.append(hr);\n+        num_optional_regions_selected++;\n+      } else {\n+        print_finish_message(\"Predicted time too high\", true);\n+        break;\n+      }\n+    }\n+  }\n+  if (iter == marking_list->end()) {\n+    log_debug(gc, ergo, cset)(\"Marking candidates exhausted.\");\n+  }\n+\n+  if (num_expensive_regions > 0) {\n+    log_debug(gc, ergo, cset)(\"Added %u marking candidates to collection set although the predicted time was too high.\",\n+                              num_expensive_regions);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2fms\",\n+                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);\n+\n+  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n+  assert(_optional_old_regions.length() == num_optional_regions_selected, \"must be\");\n+  return time_remaining_ms;\n+}\n+\n+void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms,\n+                                                      G1CollectionCandidateRegionList* initial_old_regions,\n+                                                      G1CollectionCandidateRegionList* pinned_old_regions) {\n+  uint num_initial_regions_selected = 0;\n+  uint num_optional_regions_selected = 0;\n+  uint num_expensive_regions_selected = 0;\n+  uint num_pinned_regions = 0;\n+\n+  double predicted_initial_time_ms = 0.0;\n+  double predicted_optional_time_ms = 0.0;\n+\n+  uint const min_regions = _policy->min_retained_old_cset_length();\n+  \/\/ We want to make sure that on the one hand we process the retained regions asap,\n+  \/\/ but on the other hand do not take too many of them as optional regions.\n+  \/\/ So we split the time budget into budget we will unconditionally take into the\n+  \/\/ initial old regions, and budget for taking optional regions from the retained\n+  \/\/ list.\n+  double optional_time_remaining_ms = _policy->max_time_for_retaining();\n+  time_remaining_ms = MIN2(time_remaining_ms, optional_time_remaining_ms);\n+\n+  G1CollectionCandidateList* retained_list = &candidates()->retained_regions();\n+\n+  log_debug(gc, ergo, cset)(\"Start adding retained candidates to collection set. \"\n+                            \"Min %u regions, available %u, \"\n+                            \"time remaining %1.2fms, optional remaining %1.2fms\",\n+                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n+\n+  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n+    G1HeapRegion* r = ci->_r;\n+    double predicted_time_ms = _policy->predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+    bool fits_in_remaining_time = predicted_time_ms <= time_remaining_ms;\n+    \/\/ If we can't reclaim that region ignore it for now.\n+    if (r->has_pinned_objects()) {\n+      num_pinned_regions++;\n+      if (ci->update_num_unreclaimed()) {\n+        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Skipping.\", r->hrm_index());\n+      } else {\n+        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Dropping.\", r->hrm_index());\n+        pinned_old_regions->append(r);\n+      }\n+      continue;\n+    }\n+\n+    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n+      predicted_initial_time_ms += predicted_time_ms;\n+      if (!fits_in_remaining_time) {\n+        num_expensive_regions_selected++;\n+      }\n+      initial_old_regions->append(r);\n+      num_initial_regions_selected++;\n+    } else if (predicted_time_ms <= optional_time_remaining_ms) {\n+      predicted_optional_time_ms += predicted_time_ms;\n+      _optional_old_regions.append(r);\n+      num_optional_regions_selected++;\n+    } else {\n+      \/\/ Fits neither initial nor optional time limit. Exit.\n+      break;\n+    }\n+    time_remaining_ms = MAX2(0.0, time_remaining_ms - predicted_time_ms);\n+    optional_time_remaining_ms = MAX2(0.0, optional_time_remaining_ms - predicted_time_ms);\n+  }\n+\n+  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n+  if (num_regions_selected == retained_list->length()) {\n+    log_debug(gc, ergo, cset)(\"Retained candidates exhausted.\");\n+  }\n+  if (num_expensive_regions_selected > 0) {\n+    log_debug(gc, ergo, cset)(\"Added %u retained candidates to collection set although the predicted time was too high.\",\n+                              num_expensive_regions_selected);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, \"\n+                            \"time remaining: %1.2fms optional time remaining %1.2fms\",\n+                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms, optional_time_remaining_ms);\n+}\n+\n+void G1CollectionSet::select_candidates_from_optional_regions(double time_remaining_ms,\n+                                                              G1CollectionCandidateRegionList* selected_regions) {\n+  assert(optional_region_length() > 0,\n+         \"Should only be called when there are optional regions\");\n+\n+  double total_prediction_ms = 0.0;\n+\n+  for (G1HeapRegion* r : _optional_old_regions) {\n+    double prediction_ms = _policy->predict_region_total_time_ms(r, false);\n+\n+    if (prediction_ms > time_remaining_ms) {\n+      log_debug(gc, ergo, cset)(\"Prediction %.3fms for region %u does not fit remaining time: %.3fms.\",\n+                                prediction_ms, r->hrm_index(), time_remaining_ms);\n+      break;\n+    }\n+    \/\/ This region will be included in the next optional evacuation.\n+\n+    total_prediction_ms += prediction_ms;\n+    time_remaining_ms -= prediction_ms;\n+\n+    selected_regions->append(r);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Prepared %u regions out of %u for optional evacuation. Total predicted time: %.3fms\",\n+                            selected_regions->length(), _optional_old_regions.length(), total_prediction_ms);\n+}\n+\n@@ -444,3 +649,2 @@\n-  _policy->calculate_optional_collection_set_regions(&_optional_old_regions,\n-                                                     remaining_pause_time,\n-                                                     &selected_regions);\n+  select_candidates_from_optional_regions(remaining_pause_time,\n+                                          &selected_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":218,"deletions":14,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -199,0 +199,16 @@\n+  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n+  \/\/ the given candidate list and the remaining time.\n+  \/\/ Returns the remaining time.\n+  double select_candidates_from_marking(double time_remaining_ms,\n+                                        G1CollectionCandidateRegionList* initial_old_regions,\n+                                        G1CollectionCandidateRegionList* pinned_old_regions);\n+\n+  void select_candidates_from_retained(double time_remaining_ms,\n+                                       G1CollectionCandidateRegionList* initial_old_regions,\n+                                       G1CollectionCandidateRegionList* pinned_old_regions);\n+\n+  \/\/ Calculate the number of optional regions from the given collection set candidates,\n+  \/\/ the remaining time and the maximum number of these regions.\n+  void select_candidates_from_optional_regions(double time_remaining_ms,\n+                                               G1CollectionCandidateRegionList* selected);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-    log_trace(gc, region)(\"G1HR %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                          action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n+    log_trace(gc, region)(\"G1HR %4u %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n+                          hr->hrm_index(), action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1470,213 +1470,0 @@\n-static void print_finish_message(const char* reason, bool from_marking) {\n-  log_debug(gc, ergo, cset)(\"Finish adding %s candidates to collection set (%s).\",\n-                            from_marking ? \"marking\" : \"retained\", reason);\n-}\n-\n-double G1Policy::select_candidates_from_marking(G1CollectionCandidateList* marking_list,\n-                                                double time_remaining_ms,\n-                                                G1CollectionCandidateRegionList* initial_old_regions,\n-                                                G1CollectionCandidateRegionList* optional_old_regions,\n-                                                G1CollectionCandidateRegionList* pinned_old_regions) {\n-  assert(marking_list != nullptr, \"must be\");\n-\n-  uint num_expensive_regions = 0;\n-\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_pinned_regions = 0;\n-\n-  double predicted_initial_time_ms = 0.0;\n-  double predicted_optional_time_ms = 0.0;\n-\n-  double optional_threshold_ms = time_remaining_ms * optional_prediction_fraction();\n-\n-  const uint min_old_cset_length = calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n-  const uint max_old_cset_length = MAX2(min_old_cset_length, calc_max_old_cset_length());\n-  const uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n-  bool check_time_remaining = use_adaptive_young_list_length();\n-\n-  log_debug(gc, ergo, cset)(\"Start adding marking candidates to collection set. \"\n-                            \"Min %u regions, max %u regions, available %u regions\"\n-                            \"time remaining %1.2fms, optional threshold %1.2fms\",\n-                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n-\n-  G1CollectionCandidateListIterator iter = marking_list->begin();\n-  for (; iter != marking_list->end(); ++iter) {\n-    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n-      \/\/ Added maximum number of old regions to the CSet.\n-      print_finish_message(\"Maximum number of regions reached\", true);\n-      break;\n-    }\n-    G1HeapRegion* hr = (*iter)->_r;\n-    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n-    \/\/ space from them (and we expect to get free space from marking candidates).\n-    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n-    \/\/ to not impact the mixed phase too much.\n-    if (hr->has_pinned_objects()) {\n-      num_pinned_regions++;\n-      (*iter)->update_num_unreclaimed();\n-      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n-      pinned_old_regions->append(hr);\n-      continue;\n-    }\n-    double predicted_time_ms = predict_region_total_time_ms(hr, false);\n-    time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);\n-    \/\/ Add regions to old set until we reach the minimum amount\n-    if (initial_old_regions->length() < min_old_cset_length) {\n-      initial_old_regions->append(hr);\n-      num_initial_regions_selected++;\n-      predicted_initial_time_ms += predicted_time_ms;\n-      \/\/ Record the number of regions added with no time remaining\n-      if (time_remaining_ms == 0.0) {\n-        num_expensive_regions++;\n-      }\n-    } else if (!check_time_remaining) {\n-      \/\/ In the non-auto-tuning case, we'll finish adding regions\n-      \/\/ to the CSet if we reach the minimum.\n-      print_finish_message(\"Region amount reached min\", true);\n-      break;\n-    } else {\n-      \/\/ Keep adding regions to old set until we reach the optional threshold\n-      if (time_remaining_ms > optional_threshold_ms) {\n-        predicted_initial_time_ms += predicted_time_ms;\n-        initial_old_regions->append(hr);\n-        num_initial_regions_selected++;\n-      } else if (time_remaining_ms > 0) {\n-        \/\/ Keep adding optional regions until time is up.\n-        assert(optional_old_regions->length() < max_optional_regions, \"Should not be possible.\");\n-        predicted_optional_time_ms += predicted_time_ms;\n-        optional_old_regions->append(hr);\n-        num_optional_regions_selected++;\n-      } else {\n-        print_finish_message(\"Predicted time too high\", true);\n-        break;\n-      }\n-    }\n-  }\n-  if (iter == marking_list->end()) {\n-    log_debug(gc, ergo, cset)(\"Marking candidates exhausted.\");\n-  }\n-\n-  if (num_expensive_regions > 0) {\n-    log_debug(gc, ergo, cset)(\"Added %u marking candidates to collection set although the predicted time was too high.\",\n-                              num_expensive_regions);\n-  }\n-\n-  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n-                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2fms\",\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n-                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);\n-\n-  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n-  assert(optional_old_regions->length() == num_optional_regions_selected, \"must be\");\n-  return time_remaining_ms;\n-}\n-\n-void G1Policy::select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n-                                               double time_remaining_ms,\n-                                               G1CollectionCandidateRegionList* initial_old_regions,\n-                                               G1CollectionCandidateRegionList* optional_old_regions,\n-                                               G1CollectionCandidateRegionList* pinned_old_regions) {\n-\n-  uint const min_regions = min_retained_old_cset_length();\n-\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_expensive_regions_selected = 0;\n-  uint num_pinned_regions = 0;\n-\n-  double predicted_initial_time_ms = 0.0;\n-  double predicted_optional_time_ms = 0.0;\n-\n-  \/\/ We want to make sure that on the one hand we process the retained regions asap,\n-  \/\/ but on the other hand do not take too many of them as optional regions.\n-  \/\/ So we split the time budget into budget we will unconditionally take into the\n-  \/\/ initial old regions, and budget for taking optional regions from the retained\n-  \/\/ list.\n-  double optional_time_remaining_ms = max_time_for_retaining();\n-  time_remaining_ms = MIN2(time_remaining_ms, optional_time_remaining_ms);\n-\n-  log_debug(gc, ergo, cset)(\"Start adding retained candidates to collection set. \"\n-                            \"Min %u regions, available %u, \"\n-                            \"time remaining %1.2fms, optional remaining %1.2fms\",\n-                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n-\n-  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n-    G1HeapRegion* r = ci->_r;\n-    double predicted_time_ms = predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n-    bool fits_in_remaining_time = predicted_time_ms <= time_remaining_ms;\n-    \/\/ If we can't reclaim that region ignore it for now.\n-    if (r->has_pinned_objects()) {\n-      num_pinned_regions++;\n-      if (ci->update_num_unreclaimed()) {\n-        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Skipping.\", r->hrm_index());\n-      } else {\n-        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Dropping.\", r->hrm_index());\n-        pinned_old_regions->append(r);\n-      }\n-      continue;\n-    }\n-\n-    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n-      predicted_initial_time_ms += predicted_time_ms;\n-      if (!fits_in_remaining_time) {\n-        num_expensive_regions_selected++;\n-      }\n-      initial_old_regions->append(r);\n-      num_initial_regions_selected++;\n-    } else if (predicted_time_ms <= optional_time_remaining_ms) {\n-      predicted_optional_time_ms += predicted_time_ms;\n-      optional_old_regions->append(r);\n-      num_optional_regions_selected++;\n-    } else {\n-      \/\/ Fits neither initial nor optional time limit. Exit.\n-      break;\n-    }\n-    time_remaining_ms = MAX2(0.0, time_remaining_ms - predicted_time_ms);\n-    optional_time_remaining_ms = MAX2(0.0, optional_time_remaining_ms - predicted_time_ms);\n-  }\n-\n-  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n-  if (num_regions_selected == retained_list->length()) {\n-    log_debug(gc, ergo, cset)(\"Retained candidates exhausted.\");\n-  }\n-  if (num_expensive_regions_selected > 0) {\n-    log_debug(gc, ergo, cset)(\"Added %u retained candidates to collection set although the predicted time was too high.\",\n-                              num_expensive_regions_selected);\n-  }\n-\n-  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n-                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, \"\n-                            \"time remaining: %1.2fms optional time remaining %1.2fms\",\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n-                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms, optional_time_remaining_ms);\n-}\n-\n-void G1Policy::calculate_optional_collection_set_regions(G1CollectionCandidateRegionList* optional_regions,\n-                                                         double time_remaining_ms,\n-                                                         G1CollectionCandidateRegionList* selected_regions) {\n-  assert(_collection_set->optional_region_length() > 0,\n-         \"Should only be called when there are optional regions\");\n-\n-  double total_prediction_ms = 0.0;\n-\n-  for (G1HeapRegion* r : *optional_regions) {\n-    double prediction_ms = predict_region_total_time_ms(r, false);\n-\n-    if (prediction_ms > time_remaining_ms) {\n-      log_debug(gc, ergo, cset)(\"Prediction %.3fms for region %u does not fit remaining time: %.3fms.\",\n-                                prediction_ms, r->hrm_index(), time_remaining_ms);\n-      break;\n-    }\n-    \/\/ This region will be included in the next optional evacuation.\n-\n-    total_prediction_ms += prediction_ms;\n-    time_remaining_ms -= prediction_ms;\n-\n-    selected_regions->append(r);\n-  }\n-\n-  log_debug(gc, ergo, cset)(\"Prepared %u regions out of %u for optional evacuation. Total predicted time: %.3fms\",\n-                            selected_regions->length(), optional_regions->length(), total_prediction_ms);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":0,"deletions":213,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -338,21 +338,1 @@\n-  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n-  \/\/ the given candidate list and the remaining time.\n-  \/\/ Returns the remaining time.\n-  double select_candidates_from_marking(G1CollectionCandidateList* marking_list,\n-                                        double time_remaining_ms,\n-                                        G1CollectionCandidateRegionList* initial_old_regions,\n-                                        G1CollectionCandidateRegionList* optional_old_regions,\n-                                        G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  void select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n-                                       double time_remaining_ms,\n-                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                       G1CollectionCandidateRegionList* optional_old_regions,\n-                                       G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  \/\/ Calculate the number of optional regions from the given collection set candidates,\n-  \/\/ the remaining time and the maximum number of these regions and return the number\n-  \/\/ of actually selected regions in num_optional_regions.\n-  void calculate_optional_collection_set_regions(G1CollectionCandidateRegionList* optional_old_regions,\n-                                                 double time_remaining_ms,\n-                                                 G1CollectionCandidateRegionList* selected);\n+\n@@ -426,0 +406,1 @@\n+public:\n@@ -431,1 +412,0 @@\n-public:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -970,0 +970,4 @@\n+    void dec_remset_cards(size_t decrement) {\n+      _merged[G1GCPhaseTimes::MergeRSCards] -= decrement;\n+    }\n+\n@@ -1094,0 +1098,5 @@\n+      \/\/ Compensation for the dummy cards that were initially pushed into the\n+      \/\/ card cache.\n+      \/\/ We do not need to compensate for the other counters because the dummy\n+      \/\/ card mark will never update another counter because it is initally \"dirty\".\n+      _stats.dec_remset_cards(G1MergeCardSetCache::CacheSize);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  taxable = MAX2<size_t>(1, taxable);\n@@ -91,0 +92,1 @@\n+  taxable = MAX2<size_t>(1, taxable);\n@@ -115,0 +117,1 @@\n+  taxable = MAX2<size_t>(1, taxable);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  static inline uintx tail_mask(uintx bit_number);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-inline uintx tail_mask(uintx bit_number) {\n+inline uintx ShenandoahSimpleBitMap::tail_mask(uintx bit_number) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,1 +244,0 @@\n-  nonstatic_field(JavaThread,                  _poll_data,                                    SafepointMechanism::ThreadData)        \\\n@@ -412,0 +411,1 @@\n+  nonstatic_field(Thread,                   _poll_data,                                       SafepointMechanism::ThreadData)        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4106,1 +4106,1 @@\n-  _init_state = state;\n+  Atomic::release_store(&_init_state, state);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -510,6 +510,6 @@\n-  bool is_loaded() const                   { return _init_state >= loaded; }\n-  bool is_linked() const                   { return _init_state >= linked; }\n-  bool is_initialized() const              { return _init_state == fully_initialized; }\n-  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n-  bool is_being_initialized() const        { return _init_state == being_initialized; }\n-  bool is_in_error_state() const           { return _init_state == initialization_error; }\n+  bool is_loaded() const                   { return init_state() >= loaded; }\n+  bool is_linked() const                   { return init_state() >= linked; }\n+  bool is_initialized() const              { return init_state() == fully_initialized; }\n+  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n+  bool is_being_initialized() const        { return init_state() == being_initialized; }\n+  bool is_in_error_state() const           { return init_state() == initialization_error; }\n@@ -517,1 +517,1 @@\n-  ClassState  init_state() const           { return _init_state; }\n+  ClassState  init_state() const           { return Atomic::load_acquire(&_init_state); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -398,0 +398,6 @@\n+  \/\/ Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n+\n@@ -401,0 +407,144 @@\n+\/\/ Try to convert a serial of additions into a single multiplication. Also convert `(a * CON) + a` to `(CON + 1) * a` as\n+\/\/ a side effect. On success, a new MulNode is returned.\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n+  \/\/ We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  \/\/ power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  \/\/ node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  jlong multiplier;\n+\n+  \/\/ While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  \/\/ (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n+    multiplier++; \/\/ +1 for the in2 term\n+\n+    Node* con = (bt == T_INT)\n+                ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon(multiplier);\n+    return MulNode::make(con, in2, bt);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `a + a`. On success, return `a` and set `2` as `multiplier`.\n+\/\/ The method matches `n` for pattern: AddNode(a, a).\n+Node* AddNode::find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) == n->in(2)) {\n+    *multiplier = 2;\n+    return n->in(1);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `a << CON`. On success, return `a` and set `1 << CON` as `multiplier`.\n+\/\/ Match `n` for pattern: LShiftNode(a, CON).\n+\/\/ Note that the power-of-2 multiplication optimization could potentially convert a MulNode to this pattern.\n+Node* AddNode::find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n+  if (n->Opcode() == Op_LShift(bt) && n->in(2)->is_Con()) {\n+    Node* con = n->in(2);\n+    if (con->is_top()) {\n+      return nullptr;\n+    }\n+\n+    *multiplier = ((jlong) 1 << con->get_int());\n+    return n->in(1);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `CON * a`. On success, return `a` and set `CON` as `multiplier`.\n+\/\/ Match `n` for patterns:\n+\/\/     - MulNode(CON, a)\n+\/\/     - MulNode(a, CON)\n+Node* AddNode::find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ This optimization technically only produces MulNode(CON, a), but we might as match MulNode(a, CON), too.\n+  if (n->Opcode() == Op_Mul(bt) && (n->in(1)->is_Con() || n->in(2)->is_Con())) {\n+    Node* con = n->in(1);\n+    Node* base = n->in(2);\n+\n+    \/\/ swap ConNode to lhs for easier matching\n+    if (!con->is_Con()) {\n+      swap(con, base);\n+    }\n+\n+    if (con->is_top()) {\n+      return nullptr;\n+    }\n+\n+    *multiplier = con->get_integer_as_long(bt);\n+    return base;\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `(a << CON1) + (a << CON2)`. On success, return `a` and set `(1 << CON1) + (1 << CON2)` as `multiplier`.\n+\/\/ Match `n` for patterns:\n+\/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n+\/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+\/\/ given that lhs is different from rhs.\n+\/\/ Note that one of the term of the addition could simply be `a` (i.e., a << 0). Calling this function with `multiplier`\n+\/\/ being null is safe.\n+Node* AddNode::find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) != n->in(2)) {\n+    Node* lhs = n->in(1);\n+    Node* rhs = n->in(2);\n+\n+    \/\/ swap LShiftNode to lhs for easier matching\n+    if (lhs->Opcode() != Op_LShift(bt)) {\n+      swap(lhs, rhs);\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), *)?\n+    if (lhs->Opcode() != Op_LShift(bt) || !lhs->in(2)->is_Con()) {\n+      return nullptr;\n+    }\n+\n+    jlong lhs_multiplier = 0;\n+    if (multiplier != nullptr) {\n+      Node* con = lhs->in(2);\n+      if (con->is_top()) {\n+        return nullptr;\n+      }\n+\n+      lhs_multiplier = (jlong) 1 << con->get_int();\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), a)?\n+    if (lhs->in(1) == rhs) {\n+      if (multiplier != nullptr) {\n+        *multiplier = lhs_multiplier + 1;\n+      }\n+\n+      return rhs;\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n+    if (rhs->Opcode() == Op_LShift(bt) && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n+      if (multiplier != nullptr) {\n+        Node* con = rhs->in(2);\n+        if (con->is_top()) {\n+          return nullptr;\n+        }\n+\n+        *multiplier = lhs_multiplier + ((jlong) 1 << con->get_int());\n+      }\n+\n+      return lhs->in(1);\n+    }\n+    return nullptr;\n+  }\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -45,0 +45,7 @@\n+\n+  Node* convert_serial_additions(PhaseGVN* phase, BasicType bt);\n+  static Node* find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -401,1 +401,4 @@\n-  assert(_goto != nullptr, \"\");\n+  assert(_goto != nullptr || C->failure_is_artificial(), \"\");\n+  if (C->failing()) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,8 @@\n+  develop(bool, StressBailout, false,                                       \\\n+          \"Perform bailouts randomly at C2 failing() checks\")               \\\n+                                                                            \\\n+  develop(uint, StressBailoutMean, 100000,                                  \\\n+          \"The expected number of failing() checks made until \"             \\\n+          \"a random bailout.\")                                              \\\n+          range(1, max_juint)                                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -626,1 +626,4 @@\n-  call->extract_projections(&callprojs, true);\n+  \/\/ Similar to incremental inlining, don't assert that all call\n+  \/\/ projections are still there for post-parse call devirtualization.\n+  bool do_asserts = !is_mh_late_inline() && !is_virtual_late_inline();\n+  call->extract_projections(&callprojs, true, do_asserts);\n@@ -650,1 +653,1 @@\n-    kit.replace_call(call, C->top(), true);\n+    kit.replace_call(call, C->top(), true, do_asserts);\n@@ -732,1 +735,1 @@\n-    kit.replace_call(call, result, true);\n+    kit.replace_call(call, result, true, do_asserts);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-      if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -482,0 +482,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -554,0 +557,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-macro(StoreCM)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -723,1 +723,1 @@\n-      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps) {\n+      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout) {\n@@ -801,1 +801,1 @@\n-      record_method_not_compilable(ss.as_string());\n+      record_method_not_compilable(ss.as_string() DEBUG_ONLY(COMMA true));\n@@ -976,1 +976,1 @@\n-  if (StressLCM || StressGCM) {\n+  if (StressLCM || StressGCM || StressBailout) {\n@@ -1021,0 +1021,1 @@\n+  _phase_verify_ideal_loop = false;\n@@ -1111,1 +1112,1 @@\n-  assert(failing() || s == start(), \"should be StartNode\");\n+  assert(failing_internal() || s == start(), \"should be StartNode\");\n@@ -1121,1 +1122,1 @@\n-  assert (!failing(), \"Must not have pending failure. Reason is: %s\", failure_reason());\n+  assert (!failing_internal() || C->failure_is_artificial(), \"Must not have pending failure. Reason is: %s\", failure_reason());\n@@ -1468,6 +1469,12 @@\n-      if (!ik->equals(canonical_holder) || tj->offset() != offset) {\n-        if( is_known_inst ) {\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, nullptr, offset, to->instance_id());\n-        } else {\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, nullptr, offset);\n-        }\n+      assert(tj->offset() == offset, \"no change to offset expected\");\n+      bool xk = to->klass_is_exact();\n+      int instance_id = to->instance_id();\n+\n+      \/\/ If the input type's class is the holder: if exact, the type only includes interfaces implemented by the holder\n+      \/\/ but if not exact, it may include extra interfaces: build new type from the holder class to make sure only\n+      \/\/ its interfaces are included.\n+      if (xk && ik->equals(canonical_holder)) {\n+        assert(tj == TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, offset, instance_id), \"exact type should be canonical type\");\n+      } else {\n+        assert(xk || !is_known_inst, \"Known instance should be exact type\");\n+        tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, offset, instance_id);\n@@ -2117,1 +2124,1 @@\n-      assert(!failing(), \"inconsistent\");\n+      assert(!failing_internal() || failure_is_artificial(), \"inconsistent\");\n@@ -2160,1 +2167,1 @@\n-      assert(!failing(), \"inconsistent\");\n+      assert(!failing_internal() || failure_is_artificial(), \"inconsistent\");\n@@ -2947,0 +2954,3 @@\n+  if (failing()) {\n+    return;\n+  }\n@@ -3054,46 +3064,0 @@\n-\/\/ Eliminate trivially redundant StoreCMs and accumulate their\n-\/\/ precedence edges.\n-void Compile::eliminate_redundant_card_marks(Node* n) {\n-  assert(n->Opcode() == Op_StoreCM, \"expected StoreCM\");\n-  if (n->in(MemNode::Address)->outcnt() > 1) {\n-    \/\/ There are multiple users of the same address so it might be\n-    \/\/ possible to eliminate some of the StoreCMs\n-    Node* mem = n->in(MemNode::Memory);\n-    Node* adr = n->in(MemNode::Address);\n-    Node* val = n->in(MemNode::ValueIn);\n-    Node* prev = n;\n-    bool done = false;\n-    \/\/ Walk the chain of StoreCMs eliminating ones that match.  As\n-    \/\/ long as it's a chain of single users then the optimization is\n-    \/\/ safe.  Eliminating partially redundant StoreCMs would require\n-    \/\/ cloning copies down the other paths.\n-    while (mem->Opcode() == Op_StoreCM && mem->outcnt() == 1 && !done) {\n-      if (adr == mem->in(MemNode::Address) &&\n-          val == mem->in(MemNode::ValueIn)) {\n-        \/\/ redundant StoreCM\n-        if (mem->req() > MemNode::OopStore) {\n-          \/\/ Hasn't been processed by this code yet.\n-          n->add_prec(mem->in(MemNode::OopStore));\n-        } else {\n-          \/\/ Already converted to precedence edge\n-          for (uint i = mem->req(); i < mem->len(); i++) {\n-            \/\/ Accumulate any precedence edges\n-            if (mem->in(i) != nullptr) {\n-              n->add_prec(mem->in(i));\n-            }\n-          }\n-          \/\/ Everything above this point has been processed.\n-          done = true;\n-        }\n-        \/\/ Eliminate the previous StoreCM\n-        prev->set_req(MemNode::Memory, mem->in(MemNode::Memory));\n-        assert(mem->outcnt() == 0, \"should be dead\");\n-        mem->disconnect_inputs(this);\n-      } else {\n-        prev = mem;\n-      }\n-      mem = prev->in(MemNode::Memory);\n-    }\n-  }\n-}\n-\n@@ -3269,12 +3233,0 @@\n-\n-  case Op_StoreCM:\n-    {\n-      \/\/ Convert OopStore dependence into precedence edge\n-      Node* prec = n->in(MemNode::OopStore);\n-      n->del_req(MemNode::OopStore);\n-      n->add_prec(prec);\n-      eliminate_redundant_card_marks(n);\n-    }\n-\n-    \/\/ fall through\n-\n@@ -4332,1 +4284,1 @@\n-void Compile::record_failure(const char* reason) {\n+void Compile::record_failure(const char* reason DEBUG_ONLY(COMMA bool allow_multiple_failures)) {\n@@ -4342,0 +4294,2 @@\n+  } else {\n+    assert(!StressBailout || allow_multiple_failures, \"should have handled previous failure.\");\n@@ -4369,1 +4323,3 @@\n-  if (_compile->failing()) return;\n+  if (_compile->failing_internal()) {\n+    return; \/\/ timing code, not stressing bailouts.\n+  }\n@@ -5060,0 +5016,16 @@\n+#ifdef ASSERT\n+\/\/ Failures are geometrically distributed with probability 1\/StressBailoutMean.\n+bool Compile::fail_randomly() {\n+  if ((random() % StressBailoutMean) != 0) {\n+    return false;\n+  }\n+  record_failure(\"StressBailout\");\n+  return true;\n+}\n+\n+bool Compile::failure_is_artificial() {\n+  assert(failing_internal(), \"should be failing\");\n+  return C->failure_reason_is(\"StressBailout\");\n+}\n+#endif\n+\n@@ -5147,1 +5119,1 @@\n-  if (failing()) { return; }\n+  if (failing_internal()) { return; } \/\/ failing_internal to not stress bailouts from printing code.\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":46,"deletions":74,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -394,0 +394,2 @@\n+  DEBUG_ONLY(bool       _phase_verify_ideal_loop;) \/\/ Are we in PhaseIdealLoop verification?\n+\n@@ -789,0 +791,6 @@\n+#ifdef ASSERT\n+  bool       phase_verify_ideal_loop() const { return _phase_verify_ideal_loop; }\n+  void   set_phase_verify_ideal_loop() { _phase_verify_ideal_loop = true; }\n+  void reset_phase_verify_ideal_loop() { _phase_verify_ideal_loop = false; }\n+#endif\n+\n@@ -818,1 +826,1 @@\n-  bool        failing() const        {\n+  bool        failing_internal() const {\n@@ -830,0 +838,21 @@\n+  bool failing() {\n+    if (failing_internal()) {\n+      return true;\n+    }\n+#ifdef ASSERT\n+    \/\/ Disable stress code for PhaseIdealLoop verification (would have cascading effects).\n+    if (phase_verify_ideal_loop()) {\n+      return false;\n+    }\n+    if (StressBailout) {\n+      return fail_randomly();\n+    }\n+#endif\n+    return false;\n+  }\n+\n+#ifdef ASSERT\n+  bool fail_randomly();\n+  bool failure_is_artificial();\n+#endif\n+\n@@ -837,2 +866,2 @@\n-  void record_failure(const char* reason);\n-  void record_method_not_compilable(const char* reason) {\n+  void record_failure(const char* reason DEBUG_ONLY(COMMA bool allow_multiple_failures = false));\n+  void record_method_not_compilable(const char* reason DEBUG_ONLY(COMMA bool allow_multiple_failures = false)) {\n@@ -841,1 +870,1 @@\n-    record_failure(reason);\n+    record_failure(reason DEBUG_ONLY(COMMA allow_multiple_failures));\n@@ -1218,1 +1247,0 @@\n-  void eliminate_redundant_card_marks(Node* n);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -4012,4 +4012,0 @@\n-      if (use->Opcode() == Op_StoreCM && use->in(MemNode::OopStore) == n) {\n-        \/\/ Don't move related cardmark.\n-        continue;\n-      }\n@@ -4567,1 +4563,1 @@\n-              op == Op_CastP2X || op == Op_StoreCM ||\n+              op == Op_CastP2X ||\n@@ -4706,3 +4702,0 @@\n-        if (use->Opcode() == Op_StoreCM) { \/\/ Ignore cardmark stores\n-          continue;\n-        }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -219,10 +219,4 @@\n-\n-        \/\/ Only process precedence edges that are CFG nodes. Safepoints and control projections can be in the middle of a block\n-        if (is_CFG(m)) {\n-          node->rm_prec(i);\n-          if (n == nullptr) {\n-            n = m;\n-          } else {\n-            assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n-            n = is_dominator(n, m) ? m : n;\n-          }\n+        assert(is_CFG(m), \"must be a CFG node\");\n+        node->rm_prec(i);\n+        if (n == nullptr) {\n+          n = m;\n@@ -230,2 +224,2 @@\n-          assert(node->is_Mach(), \"sanity\");\n-          assert(node->as_Mach()->ideal_Opcode() == Op_StoreCM, \"must be StoreCM node\");\n+          assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n+          n = is_dominator(n, m) ? m : n;\n@@ -749,0 +743,15 @@\n+\n+  \/\/ We don't optimize the memory graph for pinned loads, so we may need to raise the\n+  \/\/ root of our search tree through the corresponding slices of MergeMem nodes to\n+  \/\/ get to the node that really creates the memory state for this slice.\n+  if (load_alias_idx >= Compile::AliasIdxRaw) {\n+    while (initial_mem->is_MergeMem()) {\n+      MergeMemNode* mm = initial_mem->as_MergeMem();\n+      Node* p = mm->memory_at(load_alias_idx);\n+      if (p != mm->base_memory()) {\n+        initial_mem = p;\n+      } else {\n+        break;\n+      }\n+    }\n+  }\n@@ -1515,2 +1524,2 @@\n-        assert(false, \"graph should be schedulable\");\n-        C->record_method_not_compilable(\"late schedule failed: incorrect graph\");\n+        assert(C->failure_is_artificial(), \"graph should be schedulable\");\n+        C->record_method_not_compilable(\"late schedule failed: incorrect graph\" DEBUG_ONLY(COMMA true));\n@@ -1696,2 +1705,2 @@\n-        assert(false, \"local schedule failed\");\n-        C->record_method_not_compilable(\"local schedule failed\");\n+        assert(C->failure_is_artificial(), \"local schedule failed\");\n+        C->record_method_not_compilable(\"local schedule failed\" DEBUG_ONLY(COMMA true));\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -343,1 +343,3 @@\n-  if (failing())  return;  \/\/ dying anyway...\n+  if (failing_internal()) {\n+    return;  \/\/ dying anyway...\n+  }\n@@ -449,1 +451,1 @@\n-  if (failing()) { stop(); return top(); }\n+  if (failing_internal()) { stop(); return top(); }\n@@ -1559,0 +1561,1 @@\n+  assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n@@ -1588,0 +1591,1 @@\n+  assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n@@ -1929,1 +1933,1 @@\n-void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes) {\n+void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes, bool do_asserts) {\n@@ -1943,1 +1947,1 @@\n-  call->extract_projections(&callprojs, true);\n+  call->extract_projections(&callprojs, true, do_asserts);\n@@ -2059,1 +2063,3 @@\n-  if (failing())  stop();\n+  if (failing_internal()) {\n+    stop();\n+  }\n@@ -3011,1 +3017,1 @@\n-                                    T_BYTE, MemNode::unordered);\n+                                    T_BYTE, MemNode::acquire);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    assert(failing() || !has_exceptions(),\n+    assert(failing_internal() || !has_exceptions(),\n@@ -185,0 +185,1 @@\n+  bool failing_internal() const { return C->failing_internal(); }\n@@ -733,1 +734,1 @@\n-  void replace_call(CallNode* call, Node* result, bool do_replaced_nodes = false);\n+  void replace_call(CallNode* call, Node* result, bool do_replaced_nodes = false, bool do_asserts = true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -381,20 +381,0 @@\n-  return st;\n-}\n-\n-\/\/ Card mark store. Must be ordered so that it will come after the store of\n-\/\/ the oop.\n-Node* IdealKit::storeCM(Node* ctl, Node* adr, Node *val, Node* oop_store, int oop_adr_idx,\n-                        BasicType bt,\n-                        int adr_idx) {\n-  assert(adr_idx != Compile::AliasIdxTop, \"use other store_to_memory factory\" );\n-  const TypePtr* adr_type = nullptr;\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n-  Node *mem = memory(adr_idx);\n-\n-  \/\/ Add required edge to oop_store, optimizer does not support precedence edges.\n-  \/\/ Convert required edge to precedence edge before allocation.\n-  Node* st = new StoreCMNode(ctl, mem, adr, adr_type, val, oop_store, oop_adr_idx);\n-\n-  st = transform(st);\n-  set_memory(st, adr_idx);\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -237,9 +237,0 @@\n-  \/\/ Store a card mark ordered after store_oop\n-  Node* storeCM(Node* ctl,\n-                Node* adr,\n-                Node* val,\n-                Node* oop_store,\n-                int oop_adr_idx,\n-                BasicType bt,\n-                int adr_idx);\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    case Op_StoreCM:\n@@ -726,1 +725,0 @@\n-        case Op_StoreCM:\n@@ -1007,15 +1005,0 @@\n-\n-#ifdef ASSERT\n-      if (UseG1GC) {\n-        if( n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_StoreCM ) {\n-          \/\/ Check the precedence edges\n-          for (uint prec = n->req(); prec < n->len(); prec++) {\n-            Node* oop_store = n->in(prec);\n-            if (oop_store != nullptr) {\n-              assert(get_block_for_node(oop_store)->_dom_depth <= block->_dom_depth, \"oop_store must dominate card-mark\");\n-            }\n-          }\n-        }\n-      }\n-#endif\n-\n@@ -1207,1 +1190,1 @@\n-      assert(false, \"graph should be schedulable\");\n+      assert(C->failure_is_artificial(), \"graph should be schedulable\");\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2907,1 +2907,1 @@\n-    Node* inst = make_load(nullptr, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n+    Node* inst = make_load(nullptr, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::acquire);\n@@ -2962,1 +2962,0 @@\n-    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n@@ -2965,2 +2964,2 @@\n-    access_store_at(nullptr, jt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-    access_store_at(nullptr, vt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n@@ -3328,1 +3327,3 @@\n-  Node* threadObj_epoch_raw = access_load_at(threadObj, threadObj_epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* threadObj_epoch_raw = access_load_at(threadObj, threadObj_epoch_offset,\n+                                             _gvn.type(threadObj_epoch_offset)->isa_ptr(),\n+                                             TypeInt::CHAR, T_CHAR,\n@@ -3347,1 +3348,2 @@\n-  Node* vthread_epoch_raw = access_load_at(vthread, vthread_epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* vthread_epoch_raw = access_load_at(vthread, vthread_epoch_offset, _gvn.type(vthread_epoch_offset)->is_ptr(),\n+                                           TypeInt::CHAR, T_CHAR,\n@@ -3593,1 +3595,1 @@\n-  Node* epoch_raw = access_load_at(thread, epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* epoch_raw = access_load_at(thread, epoch_offset, _gvn.type(epoch_offset)->is_ptr(), TypeInt::CHAR, T_CHAR,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n+  Node* gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1467,1 +1467,2 @@\n-  InitializedAssertionPredicate initialized_assertion_predicate(template_assertion_predicate, new_init, new_stride, this);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(template_assertion_predicate, new_init,\n+                                                                       new_stride, this);\n@@ -3819,1 +3820,1 @@\n-      if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {\n+      if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -695,1 +695,6 @@\n-    \/\/ mm is used for book keeping\n+    \/\/ mm is the memory state at the safepoint (when it's a MergeMem)\n+    \/\/ no_side_effect_since_safepoint() goes over the memory state at the backedge. It resets the mm input for each\n+    \/\/ component of the memory state it encounters so it points to the base memory. Once no_side_effect_since_safepoint()\n+    \/\/ is done, if no side effect after the safepoint was found, mm should transform to the base memory: the states at\n+    \/\/ the backedge and safepoint are the same so all components of the memory state at the safepoint should have been\n+    \/\/ reset.\n@@ -702,1 +707,6 @@\n-        if (mms.alias_idx() != Compile::AliasIdxBot && loop != get_loop(ctrl_or_self(mms.memory()))) {\n+        \/\/ Loop invariant memory state won't be reset by no_side_effect_since_safepoint(). Do it here.\n+        \/\/ Escape Analysis can add state to mm that it doesn't add to the backedge memory Phis, breaking verification\n+        \/\/ code that relies on mm. Clear that extra state here.\n+        if (mms.alias_idx() != Compile::AliasIdxBot &&\n+            (loop != get_loop(ctrl_or_self(mms.memory())) ||\n+             (mms.adr_type()->isa_oop_ptr() && mms.adr_type()->is_known_instance()))) {\n@@ -4342,0 +4352,10 @@\n+\/\/ This visitor marks all visited Parse Predicates useful.\n+class ParsePredicateUsefulMarker : public PredicateVisitor {\n+ public:\n+  using PredicateVisitor::visit;\n+\n+  void visit(const ParsePredicate& parse_predicate) override {\n+    parse_predicate.head()->mark_useful();\n+  }\n+};\n+\n@@ -4344,5 +4364,3 @@\n-  const Predicates predicates(entry);\n-  ParsePredicateIterator iterator(predicates);\n-  while (iterator.has_next()) {\n-    iterator.next()->mark_useful();\n-  }\n+  const PredicateIterator predicate_iterator(entry);\n+  ParsePredicateUsefulMarker useful_marker;\n+  predicate_iterator.for_each(useful_marker);\n@@ -4938,1 +4956,3 @@\n-  if (C->failing()) return;\n+  if (C->failing_internal()) {\n+    return;\n+  }\n@@ -6290,0 +6310,37 @@\n+\/\/ Class to visit all predicates in a predicate chain to find out which are dominated by a given node. Keeps track of\n+\/\/ the entry to the earliest predicate that is still dominated by the given dominator. This class is used when trying to\n+\/\/ legally skip all predicates when figuring out the latest placement such that a node does not interfere with Loop\n+\/\/ Predication or creating a Loop Limit Check Predicate later.\n+class DominatedPredicates : public UnifiedPredicateVisitor {\n+  Node* const _dominator;\n+  Node* _earliest_dominated_predicate_entry;\n+  bool _should_continue;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  DominatedPredicates(Node* dominator, Node* start_node, PhaseIdealLoop* phase)\n+      : _dominator(dominator),\n+        _earliest_dominated_predicate_entry(start_node),\n+        _should_continue(true),\n+        _phase(phase) {}\n+  NONCOPYABLE(DominatedPredicates);\n+\n+  bool should_continue() const override {\n+    return _should_continue;\n+  }\n+\n+  \/\/ Returns the entry to the earliest predicate that is still dominated by the given dominator (all could be dominated).\n+  Node* earliest_dominated_predicate_entry() const {\n+    return _earliest_dominated_predicate_entry;\n+  }\n+\n+  void visit_predicate(const Predicate& predicate) override {\n+    Node* entry = predicate.entry();\n+    if (_phase->is_strict_dominator(entry, _dominator)) {\n+      _should_continue = false;\n+    } else {\n+      _earliest_dominated_predicate_entry = entry;\n+    }\n+  }\n+};\n+\n@@ -6401,8 +6458,4 @@\n-    PredicateEntryIterator predicate_iterator(least);\n-    while (predicate_iterator.has_next()) {\n-      Node* next_predicate_entry = predicate_iterator.next_entry();\n-      if (is_strict_dominator(next_predicate_entry, early)) {\n-        break;\n-      }\n-      least = next_predicate_entry;\n-    }\n+    const PredicateIterator predicate_iterator(least);\n+    DominatedPredicates dominated_predicates(early, least, this);\n+    predicate_iterator.for_each(dominated_predicates);\n+    least = dominated_predicates.earliest_dominated_predicate_entry();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":69,"deletions":16,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1131,0 +1131,1 @@\n+    DEBUG_ONLY(C->set_phase_verify_ideal_loop();)\n@@ -1132,0 +1133,1 @@\n+    DEBUG_ONLY(C->reset_phase_verify_ideal_loop();)\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4551,1 +4551,0 @@\n-    const Type* bt_t      = Type::get_const_basic_type(bt);\n@@ -4631,1 +4630,1 @@\n-    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt_t);\n+    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,0 +197,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -290,0 +293,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -294,0 +300,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -389,1 +398,1 @@\n-      assert(_mach_null != nullptr, \"\");\n+      assert(_mach_null != nullptr || C->failure_is_artificial(), \"\"); \/\/ bailouts are handled below.\n@@ -407,1 +416,1 @@\n-    C->record_method_not_compilable(ss.as_string());\n+    C->record_method_not_compilable(ss.as_string() DEBUG_ONLY(COMMA true));\n@@ -1442,0 +1451,3 @@\n+      if (C->failing()) {\n+        return nullptr;\n+      }\n@@ -1446,0 +1458,3 @@\n+      if (C->failing()) {\n+        return nullptr;\n+      }\n@@ -2682,0 +2697,4 @@\n+  assert(!C->failing_internal() || C->failure_is_artificial(), \"already failing.\");\n+  if (C->failing()) {\n+    return nullptr;\n+  }\n@@ -2712,1 +2731,4 @@\n-  assert(mspill != nullptr, \"matching failed: %d\", ideal_reg);\n+  assert(mspill != nullptr || C->failure_is_artificial(), \"matching failed: %d\", ideal_reg);\n+  if (C->failing()) {\n+    return nullptr;\n+  }\n@@ -2858,1 +2880,1 @@\n-  assert(!C->failing(), \"sanity\");\n+  assert(!C->failing_internal() || C->failure_is_artificial(), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -345,1 +345,0 @@\n-  static const TypeVectMask* predicate_reg_type(const Type* elemTy, int length);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3465,3 +3465,1 @@\n-  \/\/ unsafe if I have intervening uses...  Also disallowed for StoreCM\n-  \/\/ since they must follow each StoreP operation.  Redundant StoreCMs\n-  \/\/ are eliminated just before matching in final_graph_reshape.\n+  \/\/ unsafe if I have intervening uses.\n@@ -3477,1 +3475,1 @@\n-    while (st->is_Store() && st->outcnt() == 1 && st->Opcode() != Op_StoreCM) {\n+    while (st->is_Store() && st->outcnt() == 1) {\n@@ -3784,42 +3782,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* StoreCMNode::Identity(PhaseGVN* phase) {\n-  \/\/ No need to card mark when storing a null ptr\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_Store()) {\n-    const Type *t1 = phase->type( my_store->in(MemNode::ValueIn) );\n-    if( t1 == TypePtr::NULL_PTR ) {\n-      return in(MemNode::Memory);\n-    }\n-  }\n-  return this;\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Ideal---------------------------------------\n-Node *StoreCMNode::Ideal(PhaseGVN *phase, bool can_reshape){\n-  Node* progress = StoreNode::Ideal(phase, can_reshape);\n-  if (progress != nullptr) return progress;\n-\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_MergeMem()) {\n-    Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n-    set_req_X(MemNode::OopStore, mem, phase);\n-    return this;\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/------------------------------Value-----------------------------------------\n-const Type* StoreCMNode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP (checked in StoreNode::Value).\n-  \/\/ If extra input is TOP ==> the result is TOP\n-  const Type* t = phase->type(in(MemNode::OopStore));\n-  if (t == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  return StoreNode::Value(phase);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-         ValueIn,               \/\/ Value to store\n-         OopStore               \/\/ Preceding oop store, only in StoreCM\n+         ValueIn                \/\/ Value to store\n@@ -780,30 +779,0 @@\n-\/\/------------------------------StoreCMNode-----------------------------------\n-\/\/ Store card-mark byte to memory for CM\n-\/\/ The last StoreCM before a SafePoint must be preserved and occur after its \"oop\" store\n-\/\/ Preceding equivalent StoreCMs may be eliminated.\n-class StoreCMNode : public StoreNode {\n- private:\n-  virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }\n-  virtual bool cmp( const Node &n ) const {\n-    return _oop_alias_idx == ((StoreCMNode&)n)._oop_alias_idx\n-      && StoreNode::cmp(n);\n-  }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  int _oop_alias_idx;   \/\/ The alias_idx of OopStore\n-\n-public:\n-  StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :\n-    StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),\n-    _oop_alias_idx(oop_alias_idx) {\n-    assert(_oop_alias_idx >= Compile::AliasIdxRaw ||\n-           (_oop_alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing()),\n-           \"bad oop alias idx\");\n-  }\n-  virtual int Opcode() const;\n-  virtual Node* Identity(PhaseGVN* phase);\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual BasicType memory_type() const { return T_VOID; } \/\/ unspecific\n-  int oop_alias_idx() const { return _oop_alias_idx; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1668,24 +1668,1 @@\n-        }\n-#ifdef ASSERT\n-          \/\/ Check that oop-store precedes the card-mark\n-        else if (mach->ideal_Opcode() == Op_StoreCM) {\n-          uint storeCM_idx = j;\n-          int count = 0;\n-          for (uint prec = mach->req(); prec < mach->len(); prec++) {\n-            Node *oop_store = mach->in(prec);  \/\/ Precedence edge\n-            if (oop_store == nullptr) continue;\n-            count++;\n-            uint i4;\n-            for (i4 = 0; i4 < last_inst; ++i4) {\n-              if (block->get_node(i4) == oop_store) {\n-                break;\n-              }\n-            }\n-            \/\/ Note: This test can provide a false failure if other precedence\n-            \/\/ edges have been added to the storeCMNode.\n-            assert(i4 == last_inst || i4 < storeCM_idx, \"CM card-mark executes before oop-store\");\n-          }\n-          assert(count > 0, \"storeCM expects at least one precedence edge\");\n-        }\n-#endif\n-        else if (!n->is_Proj()) {\n+        } else if (!n->is_Proj()) {\n@@ -1718,1 +1695,1 @@\n-      assert(!C->failing(), \"Should not reach here if failing.\");\n+      assert(!C->failing_internal() || C->failure_is_artificial(), \"Should not reach here if failing.\");\n@@ -3396,1 +3373,1 @@\n-  assert (!C->failing(), \"Must not have pending failure. Reason is: %s\", C->failure_reason());\n+  assert(!C->failing_internal() || C->failure_is_artificial(), \"Must not have pending failure. Reason is: %s\", C->failure_reason());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  bool failing()                { return C->failing(); }\n+  bool failing() const { return C->failing_internal(); } \/\/ might have cascading effects, not stressing bailouts for now.\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,8 +76,0 @@\n-bool ParsePredicate::is_predicate(Node* maybe_success_proj) {\n-  if (!maybe_success_proj->is_IfProj()) {\n-    return false;\n-  }\n-  IfNode* if_node = maybe_success_proj->in(0)->as_If();\n-  return if_node->is_ParsePredicate();\n-}\n-\n@@ -93,6 +85,2 @@\n-  if (may_be_predicate_if(maybe_success_proj)) {\n-    IfProjNode* success_proj = maybe_success_proj->as_IfProj();\n-    const Deoptimization::DeoptReason deopt_reason = uncommon_trap_reason(success_proj);\n-    return (deopt_reason == Deoptimization::Reason_loop_limit_check ||\n-            deopt_reason == Deoptimization::Reason_predicate ||\n-            deopt_reason == Deoptimization::Reason_profile_predicate);\n+  if (RegularPredicate::may_be_predicate_if(maybe_success_proj)) {\n+    return has_valid_uncommon_trap(maybe_success_proj);\n@@ -104,2 +92,10 @@\n-bool RegularPredicateWithUCT::is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason) {\n-  if (may_be_predicate_if(node)) {\n+bool RegularPredicateWithUCT::has_valid_uncommon_trap(const Node* success_proj) {\n+  assert(RegularPredicate::may_be_predicate_if(success_proj), \"must have been checked before\");\n+  const Deoptimization::DeoptReason deopt_reason = uncommon_trap_reason(success_proj->as_IfProj());\n+  return (deopt_reason == Deoptimization::Reason_loop_limit_check ||\n+          deopt_reason == Deoptimization::Reason_predicate ||\n+          deopt_reason == Deoptimization::Reason_profile_predicate);\n+}\n+\n+bool RegularPredicateWithUCT::is_predicate(const Node* node, Deoptimization::DeoptReason deopt_reason) {\n+  if (RegularPredicate::may_be_predicate_if(node)) {\n@@ -112,2 +108,2 @@\n-\/\/ A Runtime Predicate must have an If or a RangeCheck node, while the If should not be a zero trip guard check.\n-bool RegularPredicateWithUCT::may_be_predicate_if(Node* node) {\n+\/\/ A Regular Predicate must have an If or a RangeCheck node, while the If should not be a zero trip guard check.\n+bool RegularPredicate::may_be_predicate_if(const Node* node) {\n@@ -125,1 +121,7 @@\n-bool RuntimePredicate::is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason) {\n+\/\/ Runtime Predicates always have an UCT since they could normally fail at runtime. In this case we execute the trap\n+\/\/ on the failing path.\n+bool RuntimePredicate::is_predicate(Node* node) {\n+  return RegularPredicateWithUCT::is_predicate(node);\n+}\n+\n+bool RuntimePredicate::is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason) {\n@@ -129,10 +131,5 @@\n-ParsePredicateIterator::ParsePredicateIterator(const Predicates& predicates) : _current_index(0) {\n-  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n-  if (loop_limit_check_predicate_block->has_parse_predicate()) {\n-    _parse_predicates.push(loop_limit_check_predicate_block->parse_predicate());\n-  }\n-  if (UseProfiledLoopPredicate) {\n-    const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n-    if (profiled_loop_predicate_block->has_parse_predicate()) {\n-      _parse_predicates.push(profiled_loop_predicate_block->parse_predicate());\n-    }\n+\/\/ A Template Assertion Predicate has an If\/RangeCheckNode and either an UCT or a halt node depending on where it\n+\/\/ was created.\n+bool TemplateAssertionPredicate::is_predicate(Node* node) {\n+  if (!RegularPredicate::may_be_predicate_if(node)) {\n+    return false;\n@@ -140,5 +137,3 @@\n-  if (UseLoopPredicate) {\n-    const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n-    if (loop_predicate_block->has_parse_predicate()) {\n-      _parse_predicates.push(loop_predicate_block->parse_predicate());\n-    }\n+  IfNode* if_node = node->in(0)->as_If();\n+  if (if_node->in(1)->is_Opaque4()) {\n+    return RegularPredicateWithUCT::has_valid_uncommon_trap(node) || AssertionPredicateWithHalt::has_halt(node);\n@@ -146,0 +141,1 @@\n+  return false;\n@@ -148,3 +144,7 @@\n-ParsePredicateNode* ParsePredicateIterator::next() {\n-  assert(has_next(), \"always check has_next() first\");\n-  return _parse_predicates.at(_current_index++);\n+\/\/ Initialized Assertion Predicates always have the dedicated opaque node and a halt node.\n+bool InitializedAssertionPredicate::is_predicate(Node* node) {\n+  if (!AssertionPredicateWithHalt::is_predicate(node)) {\n+    return false;\n+  }\n+  IfNode* if_node = node->in(0)->as_If();\n+  return if_node->in(1)->is_OpaqueInitializedAssertionPredicate();\n@@ -156,2 +156,2 @@\n-void PredicateBlock::verify_block() {\n-  Node* next = _parse_predicate.entry(); \/\/ Skip unique Parse Predicate of this block if present\n+void RegularPredicateBlock::verify_block(Node* tail) {\n+  Node* next = tail;\n@@ -169,11 +169,0 @@\n-\/\/ Walk over all Regular Predicates of this block (if any) and return the first node not belonging to the block\n-\/\/ anymore (i.e. entry to the first Regular Predicate in this block if any or `regular_predicate_proj` otherwise).\n-Node* PredicateBlock::skip_regular_predicates(Node* regular_predicate_proj, Deoptimization::DeoptReason deopt_reason) {\n-  Node* entry = regular_predicate_proj;\n-  while (RuntimePredicate::is_success_proj(entry, deopt_reason)) {\n-    assert(entry->in(0)->as_If(), \"must be If node\");\n-    entry = entry->in(0)->in(0);\n-  }\n-  return entry;\n-}\n-\n@@ -384,2 +373,2 @@\n-InitializedAssertionPredicate::InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                             Node* new_stride, PhaseIdealLoop* phase)\n+InitializedAssertionPredicateCreator::InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init,\n+                                                                           Node* new_stride, PhaseIdealLoop* phase)\n@@ -411,1 +400,1 @@\n-IfTrueNode* InitializedAssertionPredicate::create(Node* control) {\n+IfTrueNode* InitializedAssertionPredicateCreator::create(Node* control) {\n@@ -420,1 +409,1 @@\n-OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicate::create_assertion_expression(Node* control) {\n+OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicateCreator::create_assertion_expression(Node* control) {\n@@ -431,3 +420,3 @@\n-IfNode* InitializedAssertionPredicate::create_if_node(Node* control,\n-                                                      OpaqueInitializedAssertionPredicateNode* assertion_expression,\n-                                                      IdealLoopTree* loop) {\n+IfNode* InitializedAssertionPredicateCreator::create_if_node(Node* control,\n+                                                             OpaqueInitializedAssertionPredicateNode* assertion_expression,\n+                                                             IdealLoopTree* loop) {\n@@ -443,1 +432,1 @@\n-IfTrueNode* InitializedAssertionPredicate::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n+IfTrueNode* InitializedAssertionPredicateCreator::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n@@ -449,1 +438,1 @@\n-void InitializedAssertionPredicate::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n+void InitializedAssertionPredicateCreator::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n@@ -455,1 +444,1 @@\n-void InitializedAssertionPredicate::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n+void InitializedAssertionPredicateCreator::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n@@ -464,5 +453,35 @@\n-\/\/ Is current node pointed to by iterator a predicate?\n-bool PredicateEntryIterator::has_next() const {\n-    return ParsePredicate::is_predicate(_current) ||\n-           RegularPredicateWithUCT::is_predicate(_current) ||\n-           AssertionPredicateWithHalt::is_predicate(_current);\n+#ifndef PRODUCT\n+void PredicateBlock::dump() const {\n+  dump(\"\");\n+}\n+\n+void PredicateBlock::dump(const char* prefix) const {\n+  if (is_non_empty()) {\n+    PredicatePrinter printer(prefix);\n+    PredicateBlockIterator iterator(_tail, _deopt_reason);\n+    iterator.for_each(printer);\n+  } else {\n+    tty->print_cr(\"%s- <empty>\", prefix);\n+  }\n+}\n+\n+\/\/ Dumps all predicates from the loop to the earliest predicate in a pretty format.\n+void Predicates::dump() const {\n+  if (has_any()) {\n+    Node* loop_head = _tail->unique_ctrl_out();\n+    tty->print_cr(\"%d %s:\", loop_head->_idx, loop_head->Name());\n+    tty->print_cr(\"- Loop Limit Check Predicate Block:\");\n+    _loop_limit_check_predicate_block.dump(\"  \");\n+    tty->print_cr(\"- Profiled Loop Predicate Block:\");\n+    _profiled_loop_predicate_block.dump(\"  \");\n+    tty->print_cr(\"- Loop Predicate Block:\");\n+    _loop_predicate_block.dump(\"  \");\n+    tty->cr();\n+  } else {\n+    tty->print_cr(\"<no predicates>\");\n+  }\n+}\n+\n+void Predicates::dump_at(Node* node) {\n+  Predicates predicates(node);\n+  predicates.dump();\n@@ -471,6 +490,3 @@\n-\/\/ Skip the current predicate pointed to by iterator by returning the input into the predicate. This could possibly be\n-\/\/ a non-predicate node.\n-Node* PredicateEntryIterator::next_entry() {\n-  assert(has_next(), \"current must be predicate\");\n-  _current = _current->in(0)->in(0);\n-  return _current;\n+\/\/ Debug method to dump all predicates that are found above 'loop_node'.\n+void Predicates::dump_for_loop(LoopNode* loop_node) {\n+  dump_at(loop_node->skip_strip_mined()->in(LoopNode::EntryControl));\n@@ -478,0 +494,1 @@\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":88,"deletions":71,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -33,0 +33,5 @@\n+class InitializedAssertionPredicate;\n+class ParsePredicate;\n+class PredicateVisitor;\n+class RuntimePredicate;\n+class TemplateAssertionPredicate;\n@@ -155,1 +160,2 @@\n- *\n+ * - Regular Predicate Block: A block that only contains the Regular Predicates of a Predicate Block without the\n+ *                            Parse Predicate.\n@@ -208,0 +214,35 @@\n+\/\/ Interface to represent a C2 predicate. A predicate is always represented by two CFG nodes:\n+\/\/ - An If node (head)\n+\/\/ - An IfProj node representing the success projection of the If node (tail).\n+class Predicate : public StackObj {\n+ public:\n+  \/\/ Return the unique entry CFG node into the predicate.\n+  virtual Node* entry() const = 0;\n+\n+  \/\/ Return the head node of the predicate which is either:\n+  \/\/ - A ParsePredicateNode if the predicate is a Parse Predicate\n+  \/\/ - An IfNode or RangeCheckNode, otherwise.\n+  virtual IfNode* head() const = 0;\n+\n+  \/\/ Return the tail node of the predicate. Runtime Predicates can either have a true of false projection as success\n+  \/\/ projection while Parse Predicates and Assertion Predicates always have a true projection as success projection.\n+  virtual IfProjNode* tail() const = 0;\n+};\n+\n+\/\/ Generic predicate visitor that does nothing. Subclass this visitor to add customized actions for each predicate.\n+\/\/ The visit methods of this visitor are called from the predicate iterator classes which walk the predicate chain.\n+\/\/ Use the UnifiedPredicateVisitor if the type of the predicate does not matter.\n+class PredicateVisitor : StackObj {\n+ public:\n+  virtual void visit(const ParsePredicate& parse_predicate) {}\n+  virtual void visit(const RuntimePredicate& runtime_predicate) {}\n+  virtual void visit(const TemplateAssertionPredicate& template_assertion_predicate) {}\n+  virtual void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) {}\n+\n+  \/\/ This method can be overridden to stop the predicate iterators from visiting more predicates further up in the\n+  \/\/ predicate chain.\n+  virtual bool should_continue() const {\n+    return true;\n+  }\n+};\n+\n@@ -231,1 +272,0 @@\n-  static bool has_halt(const Node* success_proj);\n@@ -234,0 +274,7 @@\n+  static bool has_halt(const Node* success_proj);\n+};\n+\n+\/\/ Utility class representing a Regular Predicate which is either a Runtime Predicate or an Assertion Predicate.\n+class RegularPredicate : public StackObj {\n+ public:\n+  static bool may_be_predicate_if(const Node* node);\n@@ -242,1 +289,0 @@\n-  static bool may_be_predicate_if(Node* node);\n@@ -246,1 +292,2 @@\n-  static bool is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason);\n+  static bool is_predicate(const Node* node, Deoptimization::DeoptReason deopt_reason);\n+  static bool has_valid_uncommon_trap(const Node* success_proj);\n@@ -250,1 +297,1 @@\n-class ParsePredicate : public StackObj {\n+class ParsePredicate : public Predicate {\n@@ -270,1 +317,1 @@\n-  Node* entry() const {\n+  Node* entry() const override {\n@@ -280,1 +327,1 @@\n-  ParsePredicateNode* node() const {\n+  ParsePredicateNode* head() const override {\n@@ -285,1 +332,1 @@\n-  ParsePredicateSuccessProj* success_proj() const {\n+  ParsePredicateSuccessProj* tail() const override {\n@@ -289,0 +336,14 @@\n+};\n+\n+\/\/ Class to represent a Runtime Predicate which always has an associated UCT on the failing path.\n+class RuntimePredicate : public Predicate {\n+  IfProjNode* _success_proj;\n+  IfNode* _if_node;\n+\n+ public:\n+  explicit RuntimePredicate(IfProjNode* success_proj)\n+      : _success_proj(success_proj),\n+        _if_node(success_proj->in(0)->as_If()) {\n+    assert(is_predicate(success_proj), \"must be valid\");\n+  }\n+  NONCOPYABLE(RuntimePredicate);\n@@ -290,0 +351,1 @@\n+ private:\n@@ -291,0 +353,15 @@\n+\n+ public:\n+  Node* entry() const override {\n+    return _if_node->in(0);\n+  }\n+\n+  IfNode* head() const override {\n+    return _if_node;\n+  }\n+\n+  IfProjNode* tail() const override {\n+    return _success_proj;\n+  }\n+\n+  static bool is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason);\n@@ -293,2 +370,5 @@\n-\/\/ Utility class for queries on Runtime Predicates.\n-class RuntimePredicate : public StackObj {\n+\/\/ Class to represent a Template Assertion Predicate.\n+class TemplateAssertionPredicate : public Predicate {\n+  IfTrueNode* _success_proj;\n+  IfNode* _if_node;\n+\n@@ -296,1 +376,47 @@\n-  static bool is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason);\n+  explicit TemplateAssertionPredicate(IfTrueNode* success_proj)\n+      : _success_proj(success_proj),\n+        _if_node(success_proj->in(0)->as_If()) {\n+    assert(is_predicate(success_proj), \"must be valid\");\n+  }\n+\n+  Node* entry() const override {\n+    return _if_node->in(0);\n+  }\n+\n+  IfNode* head() const override {\n+    return _if_node;\n+  }\n+\n+  IfTrueNode* tail() const override {\n+    return _success_proj;\n+  }\n+\n+  static bool is_predicate(Node* node);\n+};\n+\n+\/\/ Class to represent an Initialized Assertion Predicate which always has a halt node on the failing path.\n+\/\/ This predicate should never fail at runtime by design.\n+class InitializedAssertionPredicate : public Predicate {\n+  IfTrueNode* _success_proj;\n+  IfNode* _if_node;\n+\n+ public:\n+  explicit InitializedAssertionPredicate(IfTrueNode* success_proj)\n+      : _success_proj(success_proj),\n+        _if_node(success_proj->in(0)->as_If()) {\n+    assert(is_predicate(success_proj), \"must be valid\");\n+  }\n+\n+  Node* entry() const override {\n+    return _if_node->in(0);\n+  }\n+\n+  IfNode* head() const override {\n+    return _if_node;\n+  }\n+\n+  IfTrueNode* tail() const override {\n+    return _success_proj;\n+  }\n+\n+  static bool is_predicate(Node* node);\n@@ -398,1 +524,1 @@\n-class InitializedAssertionPredicate : public StackObj {\n+class InitializedAssertionPredicateCreator : public StackObj {\n@@ -405,3 +531,3 @@\n-  InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n-                                PhaseIdealLoop* phase);\n-  NONCOPYABLE(InitializedAssertionPredicate);\n+  InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n+                                       PhaseIdealLoop* phase);\n+  NONCOPYABLE(InitializedAssertionPredicateCreator);\n@@ -419,0 +545,177 @@\n+\/\/ This class iterates through all predicates of a Regular Predicate Block and applies the given visitor to each.\n+class RegularPredicateBlockIterator : public StackObj {\n+  Node* const _start_node;\n+  const Deoptimization::DeoptReason _deopt_reason;\n+\n+ public:\n+  RegularPredicateBlockIterator(Node* start_node, Deoptimization::DeoptReason deopt_reason)\n+      : _start_node(start_node),\n+        _deopt_reason(deopt_reason) {}\n+  NONCOPYABLE(RegularPredicateBlockIterator);\n+\n+  \/\/ Skip all predicates by just following the inputs. We do not call any user provided visitor.\n+  Node* skip_all() const {\n+    PredicateVisitor do_nothing; \/\/ No real visits, just do nothing.\n+    return for_each(do_nothing);\n+  }\n+\n+  \/\/ Walk over all predicates of this block (if any) and apply the given 'predicate_visitor' to each predicate.\n+  \/\/ Returns the entry to the earliest predicate.\n+  Node* for_each(PredicateVisitor& predicate_visitor) const {\n+    Node* current = _start_node;\n+    while (predicate_visitor.should_continue()) {\n+      if (TemplateAssertionPredicate::is_predicate(current)) {\n+        TemplateAssertionPredicate template_assertion_predicate(current->as_IfTrue());\n+        predicate_visitor.visit(template_assertion_predicate);\n+        current = template_assertion_predicate.entry();\n+      } else if (RuntimePredicate::is_predicate(current, _deopt_reason)) {\n+        RuntimePredicate runtime_predicate(current->as_IfProj());\n+        predicate_visitor.visit(runtime_predicate);\n+        current = runtime_predicate.entry();\n+      } else if (InitializedAssertionPredicate::is_predicate(current)) {\n+        InitializedAssertionPredicate initialized_assertion_predicate(current->as_IfTrue());\n+        predicate_visitor.visit(initialized_assertion_predicate);\n+        current = initialized_assertion_predicate.entry();\n+      } else {\n+        \/\/ Either a Parse Predicate or not a Regular Predicate. In both cases, the node does not belong to this block.\n+        break;\n+      }\n+    }\n+    return current;\n+  }\n+};\n+\n+\/\/ This class iterates through all predicates of a Predicate Block and applies the given visitor to each.\n+class PredicateBlockIterator : public StackObj {\n+  Node* const _start_node;\n+  const ParsePredicate _parse_predicate; \/\/ Could be missing.\n+  const RegularPredicateBlockIterator _regular_predicate_block_iterator;\n+\n+ public:\n+  PredicateBlockIterator(Node* start_node, Deoptimization::DeoptReason deopt_reason)\n+      : _start_node(start_node),\n+        _parse_predicate(start_node, deopt_reason),\n+        _regular_predicate_block_iterator(_parse_predicate.entry(), deopt_reason) {}\n+\n+  \/\/ Walk over all predicates of this block (if any) and apply the given 'predicate_visitor' to each predicate.\n+  \/\/ Returns the entry to the earliest predicate.\n+  Node* for_each(PredicateVisitor& predicate_visitor) const {\n+    if (!predicate_visitor.should_continue()) {\n+      return _start_node;\n+    }\n+    if (_parse_predicate.is_valid()) {\n+      predicate_visitor.visit(_parse_predicate);\n+    }\n+    return _regular_predicate_block_iterator.for_each(predicate_visitor);\n+  }\n+};\n+\n+\/\/ Class to walk over all predicates starting at a node, which usually is the loop entry node, and following the inputs.\n+\/\/ At each predicate, a PredicateVisitor is applied which the user can implement freely.\n+class PredicateIterator : public StackObj {\n+  Node* _start_node;\n+\n+ public:\n+  explicit PredicateIterator(Node* start_node)\n+      : _start_node(start_node) {}\n+  NONCOPYABLE(PredicateIterator);\n+\n+  \/\/ Apply the 'predicate_visitor' for each predicate found in the predicate chain started at the provided node.\n+  \/\/ Returns the entry to the earliest predicate.\n+  Node* for_each(PredicateVisitor& predicate_visitor) const {\n+    Node* current = _start_node;\n+    PredicateBlockIterator loop_limit_check_predicate_iterator(current, Deoptimization::Reason_loop_limit_check);\n+    current = loop_limit_check_predicate_iterator.for_each(predicate_visitor);\n+    PredicateBlockIterator profiled_loop_predicate_iterator(current, Deoptimization::Reason_profile_predicate);\n+    current = profiled_loop_predicate_iterator.for_each(predicate_visitor);\n+    PredicateBlockIterator loop_predicate_iterator(current, Deoptimization::Reason_predicate);\n+    return loop_predicate_iterator.for_each(predicate_visitor);\n+  }\n+};\n+\n+\/\/ Unified PredicateVisitor which only provides a single visit method for a generic Predicate. This visitor can be used\n+\/\/ when it does not matter what kind of predicate is visited. Note that we override all normal visit methods from\n+\/\/ PredicateVisitor by calling the unified method. These visit methods are marked final such that they cannot be\n+\/\/ overridden by implementors of this class.\n+class UnifiedPredicateVisitor : public PredicateVisitor {\n+ public:\n+  virtual void visit(const TemplateAssertionPredicate& template_assertion_predicate) override final {\n+    visit_predicate(template_assertion_predicate);\n+  }\n+\n+  virtual void visit(const ParsePredicate& parse_predicate) override final {\n+    visit_predicate(parse_predicate);\n+  }\n+\n+  virtual void visit(const RuntimePredicate& runtime_predicate) override final {\n+    visit_predicate(runtime_predicate);\n+  }\n+\n+  virtual void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override final {\n+    visit_predicate(initialized_assertion_predicate);\n+  }\n+\n+  virtual void visit_predicate(const Predicate& predicate) = 0;\n+};\n+\n+\/\/ A block of Regular Predicates inside a Predicate Block without its Parse Predicate.\n+class RegularPredicateBlock : public StackObj {\n+  const Deoptimization::DeoptReason _deopt_reason;\n+  Node* const _entry;\n+\n+ public:\n+  RegularPredicateBlock(Node* tail, Deoptimization::DeoptReason deopt_reason)\n+      : _deopt_reason(deopt_reason),\n+        _entry(skip_all(tail)) {\n+    DEBUG_ONLY(verify_block(tail);)\n+  }\n+  NONCOPYABLE(RegularPredicateBlock);\n+\n+ private:\n+  \/\/ Walk over all Regular Predicates of this block (if any) and return the first node not belonging to the block\n+  \/\/ anymore (i.e. entry to the first Regular Predicate in this block if any or `tail` otherwise).\n+  Node* skip_all(Node* tail) const {\n+    RegularPredicateBlockIterator iterator(tail, _deopt_reason);\n+    return iterator.skip_all();\n+  }\n+\n+  DEBUG_ONLY(void verify_block(Node* tail);)\n+\n+ public:\n+  Node* entry() const {\n+    return _entry;\n+  }\n+};\n+\n+#ifndef PRODUCT\n+\/\/ Visitor class to print all the visited predicates. Used by the Predicates class which does the printing starting\n+\/\/ at the loop node and then following the inputs to the earliest predicate.\n+class PredicatePrinter : public PredicateVisitor {\n+  const char* _prefix; \/\/ Prefix added to each dumped string.\n+\n+ public:\n+  explicit PredicatePrinter(const char* prefix) : _prefix(prefix) {}\n+  NONCOPYABLE(PredicatePrinter);\n+\n+  void visit(const ParsePredicate& parse_predicate) override {\n+    print_predicate_node(\"Parse Predicate\", parse_predicate);\n+  }\n+\n+  void visit(const RuntimePredicate& runtime_predicate) override {\n+    print_predicate_node(\"Runtime Predicate\", runtime_predicate);\n+  }\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    print_predicate_node(\"Template Assertion Predicate\", template_assertion_predicate);\n+  }\n+\n+  void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override {\n+    print_predicate_node(\"Initialized Assertion Predicate\", initialized_assertion_predicate);\n+  }\n+\n+ private:\n+  void print_predicate_node(const char* predicate_name, const Predicate& predicate) const {\n+    tty->print_cr(\"%s- %s: %d %s\", _prefix, predicate_name, predicate.head()->_idx, predicate.head()->Name());\n+  }\n+};\n+#endif \/\/ NOT PRODUCT\n@@ -424,5 +727,8 @@\n-  ParsePredicate _parse_predicate; \/\/ Could be missing.\n-  Node* _entry;\n-\n-  static Node* skip_regular_predicates(Node* regular_predicate_proj, Deoptimization::DeoptReason deopt_reason);\n-  DEBUG_ONLY(void verify_block();)\n+  const ParsePredicate _parse_predicate; \/\/ Could be missing.\n+  const RegularPredicateBlock _regular_predicate_block;\n+  Node* const _entry;\n+#ifndef PRODUCT\n+  \/\/ Used for dumping.\n+  Node* const _tail;\n+  const Deoptimization::DeoptReason _deopt_reason;\n+#endif \/\/ NOT PRODUCT\n@@ -431,5 +737,10 @@\n-  PredicateBlock(Node* predicate_proj, Deoptimization::DeoptReason deopt_reason)\n-      : _parse_predicate(predicate_proj, deopt_reason),\n-        _entry(skip_regular_predicates(_parse_predicate.entry(), deopt_reason)) {\n-    DEBUG_ONLY(verify_block();)\n-  }\n+  PredicateBlock(Node* tail, Deoptimization::DeoptReason deopt_reason)\n+      : _parse_predicate(tail, deopt_reason),\n+        _regular_predicate_block(_parse_predicate.entry(), deopt_reason),\n+        _entry(_regular_predicate_block.entry())\n+#ifndef PRODUCT\n+        , _tail(tail)\n+        , _deopt_reason(deopt_reason)\n+#endif \/\/ NOT PRODUCT\n+        {}\n+  NONCOPYABLE(PredicateBlock);\n@@ -456,1 +767,1 @@\n-    return _parse_predicate.node();\n+    return _parse_predicate.head();\n@@ -460,1 +771,1 @@\n-    return _parse_predicate.success_proj();\n+    return _parse_predicate.tail();\n@@ -474,0 +785,5 @@\n+\n+#ifndef PRODUCT\n+  void dump() const;\n+  void dump(const char* prefix) const;\n+#endif \/\/ NOT PRODUCT\n@@ -478,5 +794,5 @@\n-  Node* _loop_entry;\n-  PredicateBlock _loop_limit_check_predicate_block;\n-  PredicateBlock _profiled_loop_predicate_block;\n-  PredicateBlock _loop_predicate_block;\n-  Node* _entry;\n+  Node* const _tail;\n+  const PredicateBlock _loop_limit_check_predicate_block;\n+  const PredicateBlock _profiled_loop_predicate_block;\n+  const PredicateBlock _loop_predicate_block;\n+  Node* const _entry;\n@@ -485,2 +801,2 @@\n-  Predicates(Node* loop_entry)\n-      : _loop_entry(loop_entry),\n+  explicit Predicates(Node* loop_entry)\n+      : _tail(loop_entry),\n@@ -493,0 +809,1 @@\n+  NONCOPYABLE(Predicates);\n@@ -513,1 +830,1 @@\n-    return _entry != _loop_entry;\n+    return _entry != _tail;\n@@ -515,9 +832,0 @@\n-};\n-\n-\/\/ This class iterates over the Parse Predicates of a loop.\n-class ParsePredicateIterator : public StackObj {\n-  GrowableArray<ParsePredicateNode*> _parse_predicates;\n-  int _current_index;\n-\n- public:\n-  ParsePredicateIterator(const Predicates& predicates);\n@@ -525,5 +833,8 @@\n-  bool has_next() const {\n-    return _current_index < _parse_predicates.length();\n-  }\n-\n-  ParsePredicateNode* next();\n+#ifndef PRODUCT\n+  \/*\n+   * Debug printing functions.\n+   *\/\n+  void dump() const;\n+  static void dump_at(Node* node);\n+  static void dump_for_loop(LoopNode* loop_node);\n+#endif \/\/ NOT PRODUCT\n@@ -532,12 +843,0 @@\n-\/\/ Special predicate iterator that can be used to walk through predicate entries, regardless of whether the predicate\n-\/\/ belongs to the same loop or not (i.e. leftovers from already folded nodes). The iterator returns the next entry\n-\/\/ to a predicate.\n-class PredicateEntryIterator : public StackObj {\n-  Node* _current;\n-\n- public:\n-  explicit PredicateEntryIterator(Node* start) : _current(start) {};\n-\n-  bool has_next() const;\n-  Node* next_entry();\n-};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":360,"deletions":61,"binary":false,"changes":421,"status":"modified"},{"patch":"@@ -309,2 +309,2 @@\n-      assert(false, \"RA Split failed: attempt to clone node with anti_dependence\");\n-      C->record_method_not_compilable(\"RA Split failed: attempt to clone node with anti_dependence\");\n+      assert(C->failure_is_artificial(), \"RA Split failed: attempt to clone node with anti_dependence\");\n+      C->record_method_not_compilable(\"RA Split failed: attempt to clone node with anti_dependence\" DEBUG_ONLY(COMMA true));\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -660,3 +660,0 @@\n-        } else if (out->Opcode() == Op_StoreCM && out->in(MemNode::OopStore) == n) {\n-          \/\/ StoreCM has an input edge used as a precedence edge.\n-          \/\/ Maybe an issue when oop stores are vectorized.\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -231,2 +231,2 @@\n-      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n-      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+      BasicType element_type = _vloop_analyzer.types().velt_basic_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type == T_LONG) {\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(TypeInt::BOOL, MaxVectorSize))->hashcons();\n+  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(T_BOOLEAN, MaxVectorSize))->hashcons();\n@@ -690,2 +690,2 @@\n-  if (Matcher::vector_size_supported(T_BYTE,4)) {\n-    TypeVect::VECTS = TypeVect::make(T_BYTE,4);\n+  if (Matcher::vector_size_supported(T_BYTE, 4)) {\n+    TypeVect::VECTS = TypeVect::make(T_BYTE, 4);\n@@ -693,2 +693,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,2)) {\n-    TypeVect::VECTD = TypeVect::make(T_FLOAT,2);\n+  if (Matcher::vector_size_supported(T_FLOAT, 2)) {\n+    TypeVect::VECTD = TypeVect::make(T_FLOAT, 2);\n@@ -696,2 +696,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,4)) {\n-    TypeVect::VECTX = TypeVect::make(T_FLOAT,4);\n+  if (Matcher::vector_size_supported(T_FLOAT, 4)) {\n+    TypeVect::VECTX = TypeVect::make(T_FLOAT, 4);\n@@ -699,2 +699,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,8)) {\n-    TypeVect::VECTY = TypeVect::make(T_FLOAT,8);\n+  if (Matcher::vector_size_supported(T_FLOAT, 8)) {\n+    TypeVect::VECTY = TypeVect::make(T_FLOAT, 8);\n@@ -702,2 +702,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,16)) {\n-    TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);\n+  if (Matcher::vector_size_supported(T_FLOAT, 16)) {\n+    TypeVect::VECTZ = TypeVect::make(T_FLOAT, 16);\n@@ -2485,7 +2485,7 @@\n-const TypeVect *TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n-const TypeVect *TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n-const TypeVect *TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n-const TypeVect *TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n-const TypeVect *TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n-const TypeVect *TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n-const TypeVect *TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n+const TypeVect* TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n+const TypeVect* TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n+const TypeVect* TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n+const TypeVect* TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n+const TypeVect* TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n+const TypeVect* TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n+const TypeVect* TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n@@ -2494,1 +2494,1 @@\n-const TypeVect* TypeVect::make(const Type *elem, uint length, bool is_mask) {\n+const TypeVect* TypeVect::make(BasicType elem_bt, uint length, bool is_mask) {\n@@ -2496,1 +2496,1 @@\n-    return makemask(elem, length);\n+    return makemask(elem_bt, length);\n@@ -2498,1 +2498,0 @@\n-  BasicType elem_bt = elem->array_element_basic_type();\n@@ -2504,1 +2503,1 @@\n-    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectA(elem_bt, length))->hashcons();\n@@ -2506,1 +2505,1 @@\n-    return (TypeVect*)(new TypeVectS(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectS(elem_bt, length))->hashcons();\n@@ -2510,1 +2509,1 @@\n-    return (TypeVect*)(new TypeVectD(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectD(elem_bt, length))->hashcons();\n@@ -2512,1 +2511,1 @@\n-    return (TypeVect*)(new TypeVectX(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectX(elem_bt, length))->hashcons();\n@@ -2514,1 +2513,1 @@\n-    return (TypeVect*)(new TypeVectY(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectY(elem_bt, length))->hashcons();\n@@ -2516,1 +2515,1 @@\n-    return (TypeVect*)(new TypeVectZ(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectZ(elem_bt, length))->hashcons();\n@@ -2522,2 +2521,1 @@\n-const TypeVect *TypeVect::makemask(const Type* elem, uint length) {\n-  BasicType elem_bt = elem->array_element_basic_type();\n+const TypeVect* TypeVect::makemask(BasicType elem_bt, uint length) {\n@@ -2526,1 +2524,1 @@\n-    return TypeVectMask::make(elem, length);\n+    return TypeVectMask::make(elem_bt, length);\n@@ -2528,1 +2526,1 @@\n-    return make(elem, length);\n+    return make(elem_bt, length);\n@@ -2533,2 +2531,3 @@\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeVect::xmeet( const Type *t ) const {\n+\/\/ Compute the MEET of two types. Since each TypeVect is the only instance of\n+\/\/ its species, meeting often returns itself\n+const Type* TypeVect::xmeet(const Type* t) const {\n@@ -2536,1 +2535,3 @@\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (this == t) {\n+    return this;\n+  }\n@@ -2546,7 +2547,1 @@\n-  case VectorMask: {\n-    const TypeVectMask* v = t->is_vectmask();\n-    assert(  base() == v->base(), \"\");\n-    assert(length() == v->length(), \"\");\n-    assert(element_basic_type() == v->element_basic_type(), \"\");\n-    return TypeVect::makemask(_elem->xmeet(v->_elem), _length);\n-  }\n+  case VectorMask:\n@@ -2560,1 +2555,1 @@\n-    assert(  base() == v->base(), \"\");\n+    assert(base() == v->base(), \"\");\n@@ -2563,1 +2558,1 @@\n-    return TypeVect::make(_elem->xmeet(v->_elem), _length);\n+    return this;\n@@ -2572,3 +2567,3 @@\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeVect::xdual() const {\n-  return new TypeVect(base(), _elem->dual(), _length);\n+\/\/ Since each TypeVect is the only instance of its species, it is self-dual\n+const Type* TypeVect::xdual() const {\n+  return this;\n@@ -2579,3 +2574,3 @@\n-bool TypeVect::eq(const Type *t) const {\n-  const TypeVect *v = t->is_vect();\n-  return (_elem == v->_elem) && (_length == v->_length);\n+bool TypeVect::eq(const Type* t) const {\n+  const TypeVect* v = t->is_vect();\n+  return (element_basic_type() == v->element_basic_type()) && (length() == v->length());\n@@ -2587,1 +2582,1 @@\n-  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_length;\n+  return (uint)base() + (uint)(uintptr_t)_elem_bt + (uint)(uintptr_t)_length;\n@@ -2591,1 +2586,1 @@\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple\n@@ -2601,1 +2596,1 @@\n-  return _elem->empty();\n+  return false;\n@@ -2606,1 +2601,1 @@\n-void TypeVect::dump2(Dict &d, uint depth, outputStream *st) const {\n+void TypeVect::dump2(Dict& d, uint depth, outputStream* st) const {\n@@ -2609,1 +2604,1 @@\n-    st->print(\"vectora[\"); break;\n+    st->print(\"vectora\"); break;\n@@ -2611,1 +2606,1 @@\n-    st->print(\"vectors[\"); break;\n+    st->print(\"vectors\"); break;\n@@ -2613,1 +2608,1 @@\n-    st->print(\"vectord[\"); break;\n+    st->print(\"vectord\"); break;\n@@ -2615,1 +2610,1 @@\n-    st->print(\"vectorx[\"); break;\n+    st->print(\"vectorx\"); break;\n@@ -2617,1 +2612,1 @@\n-    st->print(\"vectory[\"); break;\n+    st->print(\"vectory\"); break;\n@@ -2619,1 +2614,1 @@\n-    st->print(\"vectorz[\"); break;\n+    st->print(\"vectorz\"); break;\n@@ -2621,1 +2616,1 @@\n-    st->print(\"vectormask[\"); break;\n+    st->print(\"vectormask\"); break;\n@@ -2625,3 +2620,1 @@\n-  st->print(\"%d]:{\", _length);\n-  _elem->dump2(d, depth, st);\n-  st->print(\"}\");\n+  st->print(\"<%c,%u>\", type2char(element_basic_type()), length());\n@@ -2631,16 +2624,2 @@\n-bool TypeVectMask::eq(const Type *t) const {\n-  const TypeVectMask *v = t->is_vectmask();\n-  return (element_type() == v->element_type()) && (length() == v->length());\n-}\n-\n-const Type *TypeVectMask::xdual() const {\n-  return new TypeVectMask(element_type()->dual(), length());\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const BasicType elem_bt, uint length) {\n-  return make(get_const_basic_type(elem_bt), length);\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const Type* elem, uint length) {\n-  const TypeVectMask* mtype = Matcher::predicate_reg_type(elem, length);\n-  return (TypeVectMask*) const_cast<TypeVectMask*>(mtype)->hashcons();\n+const TypeVectMask* TypeVectMask::make(const BasicType elem_bt, uint length) {\n+  return (TypeVectMask*) (new TypeVectMask(elem_bt, length))->hashcons();\n@@ -3135,2 +3114,2 @@\n-const TypeRawPtr *TypeRawPtr::make( address bits ) {\n-  assert( bits, \"Use TypePtr for null\" );\n+const TypeRawPtr *TypeRawPtr::make(address bits) {\n+  assert(bits != nullptr, \"Use TypePtr for null\");\n@@ -3225,1 +3204,0 @@\n-  case TypePtr::Null:\n@@ -3227,3 +3205,11 @@\n-    address bits = _bits+offset;\n-    if ( bits == 0 ) return TypePtr::NULL_PTR;\n-    return make( bits );\n+    uintptr_t bits = (uintptr_t)_bits;\n+    uintptr_t sum = bits + offset;\n+    if (( offset < 0 )\n+        ? ( sum > bits )        \/\/ Underflow?\n+        : ( sum < bits )) {     \/\/ Overflow?\n+      return BOTTOM;\n+    } else if ( sum == 0 ) {\n+      return TypePtr::NULL_PTR;\n+    } else {\n+      return make( (address)sum );\n+    }\n@@ -3233,1 +3219,0 @@\n-  return nullptr;                  \/\/ Lint noise\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":71,"deletions":86,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -787,2 +787,2 @@\n-  const Type*   _elem;  \/\/ Vector's element type\n-  const uint  _length;  \/\/ Elements in vector (power of 2)\n+  const BasicType _elem_bt;  \/\/ Vector's element type\n+  const uint _length;  \/\/ Elements in vector (power of 2)\n@@ -791,2 +791,2 @@\n-  TypeVect(TYPES t, const Type* elem, uint length) : Type(t),\n-    _elem(elem), _length(length) {}\n+  TypeVect(TYPES t, BasicType elem_bt, uint length) : Type(t),\n+    _elem_bt(elem_bt), _length(length) {}\n@@ -795,2 +795,1 @@\n-  const Type* element_type() const { return _elem; }\n-  BasicType element_basic_type() const { return _elem->array_element_basic_type(); }\n+  BasicType element_basic_type() const { return _elem_bt; }\n@@ -799,1 +798,1 @@\n-   return _length * type2aelembytes(element_basic_type());\n+    return _length * type2aelembytes(element_basic_type());\n@@ -802,1 +801,1 @@\n-  virtual bool eq(const Type *t) const;\n+  virtual bool eq(const Type* t) const;\n@@ -807,13 +806,2 @@\n-  static const TypeVect *make(const BasicType elem_bt, uint length, bool is_mask = false) {\n-    \/\/ Use bottom primitive type.\n-    return make(get_const_basic_type(elem_bt), length, is_mask);\n-  }\n-  \/\/ Used directly by Replicate nodes to construct singleton vector.\n-  static const TypeVect *make(const Type* elem, uint length, bool is_mask = false);\n-\n-  static const TypeVect *makemask(const BasicType elem_bt, uint length) {\n-    \/\/ Use bottom primitive type.\n-    return makemask(get_const_basic_type(elem_bt), length);\n-  }\n-  static const TypeVect *makemask(const Type* elem, uint length);\n-\n+  static const TypeVect* make(const BasicType elem_bt, uint length, bool is_mask = false);\n+  static const TypeVect* makemask(const BasicType elem_bt, uint length);\n@@ -821,2 +809,2 @@\n-  virtual const Type *xmeet( const Type *t) const;\n-  virtual const Type *xdual() const;     \/\/ Compute dual right now.\n+  virtual const Type* xmeet( const Type *t) const;\n+  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n@@ -824,7 +812,7 @@\n-  static const TypeVect *VECTA;\n-  static const TypeVect *VECTS;\n-  static const TypeVect *VECTD;\n-  static const TypeVect *VECTX;\n-  static const TypeVect *VECTY;\n-  static const TypeVect *VECTZ;\n-  static const TypeVect *VECTMASK;\n+  static const TypeVect* VECTA;\n+  static const TypeVect* VECTS;\n+  static const TypeVect* VECTD;\n+  static const TypeVect* VECTX;\n+  static const TypeVect* VECTY;\n+  static const TypeVect* VECTZ;\n+  static const TypeVect* VECTMASK;\n@@ -833,1 +821,1 @@\n-  virtual void dump2(Dict &d, uint, outputStream *st) const; \/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n@@ -839,1 +827,1 @@\n-  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+  TypeVectA(BasicType elem_bt, uint length) : TypeVect(VectorA, elem_bt, length) {}\n@@ -844,1 +832,1 @@\n-  TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}\n+  TypeVectS(BasicType elem_bt, uint length) : TypeVect(VectorS, elem_bt, length) {}\n@@ -849,1 +837,1 @@\n-  TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}\n+  TypeVectD(BasicType elem_bt, uint length) : TypeVect(VectorD, elem_bt, length) {}\n@@ -854,1 +842,1 @@\n-  TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}\n+  TypeVectX(BasicType elem_bt, uint length) : TypeVect(VectorX, elem_bt, length) {}\n@@ -859,1 +847,1 @@\n-  TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}\n+  TypeVectY(BasicType elem_bt, uint length) : TypeVect(VectorY, elem_bt, length) {}\n@@ -864,1 +852,1 @@\n-  TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}\n+  TypeVectZ(BasicType elem_bt, uint length) : TypeVect(VectorZ, elem_bt, length) {}\n@@ -870,3 +858,1 @@\n-  TypeVectMask(const Type* elem, uint length) : TypeVect(VectorMask, elem, length) {}\n-  virtual bool eq(const Type *t) const;\n-  virtual const Type *xdual() const;\n+  TypeVectMask(BasicType elem_bt, uint length) : TypeVect(VectorMask, elem_bt, length) {}\n@@ -874,1 +860,0 @@\n-  static const TypeVectMask* make(const Type* elem, uint length);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":26,"deletions":41,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    operation = gen_call_to_vector_math(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n@@ -473,3 +473,3 @@\n-      log_if_needed(\"  ** svml call failed for %s_%s_%d\",\n-                         (elem_bt == T_FLOAT)?\"float\":\"double\",\n-                         VectorSupport::svmlname[opr->get_con() - VectorSupport::VECTOR_OP_SVML_START],\n+      log_if_needed(\"  ** Vector math call failed for %s_%s_%d\",\n+                         (elem_bt == T_FLOAT) ? \"float\" : \"double\",\n+                         VectorSupport::mathname[opr->get_con() - VectorSupport::VECTOR_OP_MATH_START],\n@@ -527,1 +527,0 @@\n-  const Type* type_bt = Type::get_const_basic_type(elem_bt);\n@@ -530,1 +529,1 @@\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, type_bt));\n+  Node* bcast_mod_mask = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, elem_bt));\n@@ -535,3 +534,3 @@\n-  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n-  const TypeVect* vmask_type = TypeVect::makemask(type_bt, num_elem);\n-  Node*  mask = gvn().transform(new VectorMaskCmpNode(pred, bcast_lane_cnt, index_vec, pred_node, vmask_type));\n+  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, elem_bt));\n+  const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+  Node* mask = gvn().transform(new VectorMaskCmpNode(pred, bcast_lane_cnt, index_vec, pred_node, vmask_type));\n@@ -603,2 +602,1 @@\n-  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n-  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n@@ -612,1 +610,1 @@\n-    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n+    Node* bcast_step = gvn().transform(VectorNode::scalar2vector(step, num_elem, elem_bt));\n@@ -621,1 +619,1 @@\n-    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n+    Node* bcast_start = gvn().transform(VectorNode::scalar2vector(start, num_elem, elem_bt));\n@@ -625,2 +623,2 @@\n-  Node * mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n+  Node* mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n+  Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, elem_bt));\n@@ -805,3 +803,2 @@\n-  const Type* shuffle_type_bt = Type::get_const_basic_type(shuffle_bt);\n-  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_type_bt));\n+  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem - 1));\n+  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_bt));\n@@ -911,1 +908,1 @@\n-    broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_mask);\n+    broadcast = VectorNode::scalar2vector(elem, num_elem, elem_bt, is_mask);\n@@ -1355,1 +1352,1 @@\n-      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, Type::get_const_basic_type(mem_elem_bt)));\n+      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, mem_elem_bt));\n@@ -1681,1 +1678,1 @@\n-    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, Type::get_const_basic_type(elem_bt)));\n+    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, elem_bt));\n@@ -2062,1 +2059,1 @@\n-      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));\n@@ -2074,1 +2071,1 @@\n-static address get_svml_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n+static address get_vector_math_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n@@ -2078,2 +2075,2 @@\n-  assert((vop >= VectorSupport::VECTOR_OP_SVML_START) && (vop <= VectorSupport::VECTOR_OP_SVML_END), \"unexpected\");\n-  int op = vop - VectorSupport::VECTOR_OP_SVML_START;\n+  assert((vop >= VectorSupport::VECTOR_OP_MATH_START) && (vop <= VectorSupport::VECTOR_OP_MATH_END), \"unexpected\");\n+  int op = vop - VectorSupport::VECTOR_OP_MATH_START;\n@@ -2087,1 +2084,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_float%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_fixed\", VectorSupport::mathname[op], bits);\n@@ -2091,1 +2088,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_double%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_fixed\", VectorSupport::mathname[op], bits);\n@@ -2096,3 +2093,5 @@\n-      snprintf(name_ptr, name_len, \"invalid\");\n-      addr = nullptr;\n-      Unimplemented();\n+      if (!Matcher::supports_scalable_vector() || !Matcher::vector_size_supported(bt, bits\/type2aelembytes(bt)) ) {\n+        snprintf(name_ptr, name_len, \"invalid\");\n+        addr = nullptr;\n+        Unimplemented();\n+      }\n@@ -2102,0 +2101,11 @@\n+  if (addr == nullptr && Matcher::supports_scalable_vector()) {\n+    if (bt == T_FLOAT) {\n+      snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_scalable\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    } else {\n+      assert(bt == T_DOUBLE, \"must be FP type only\");\n+      snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_scalable\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    }\n+  }\n+\n@@ -2205,2 +2215,1 @@\n-  const Type * byte_bt = Type::get_const_basic_type(T_BYTE);\n-  const TypeVect * byte_vt  = TypeVect::make(byte_bt, num_elem);\n+  const TypeVect* byte_vt = TypeVect::make(T_BYTE, num_elem);\n@@ -2212,1 +2221,1 @@\n-  Node* bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, byte_bt));\n+  Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, T_BYTE));\n@@ -2216,1 +2225,1 @@\n-  const TypeVect * shuffle_vt  = TypeVect::make(elem_bt, num_elem);\n+  const TypeVect* shuffle_vt = TypeVect::make(elem_bt, num_elem);\n@@ -2233,1 +2242,1 @@\n-      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));\n@@ -2249,1 +2258,1 @@\n-Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+Node* LibraryCallKit::gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n@@ -2251,1 +2260,1 @@\n-  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_MATH_START && vector_api_op_id <= VectorSupport::VECTOR_OP_MATH_END, \"need valid op id\");\n@@ -2257,2 +2266,2 @@\n-  \/\/ Get address for svml method.\n-  address addr = get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n+  \/\/ Get address for vector math method.\n+  address addr = get_vector_math_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n@@ -2381,1 +2390,0 @@\n-      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n@@ -2383,1 +2391,1 @@\n-      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, elem_bt));\n@@ -3041,1 +3049,1 @@\n-    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, Type::get_const_basic_type(elem_bt)));\n+    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, elem_bt));\n@@ -3154,1 +3162,1 @@\n-    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, Type::get_const_basic_type(elem_bt)));\n+    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, elem_bt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":51,"deletions":43,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -802,2 +802,1 @@\n-VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask) {\n-  BasicType bt = opd_t->array_element_basic_type();\n+VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, BasicType bt, bool is_mask) {\n@@ -805,1 +804,1 @@\n-    const TypeVect* vt = TypeVect::make(opd_t, vlen, true);\n+    const TypeVect* vt = TypeVect::make(bt, vlen, true);\n@@ -809,2 +808,1 @@\n-  const TypeVect* vt = opd_t->singleton() ? TypeVect::make(opd_t, vlen)\n-                                          : TypeVect::make(bt, vlen);\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n@@ -1629,2 +1627,0 @@\n-    const Type* elem_ty = Type::get_const_basic_type(bt);\n-\n@@ -1642,2 +1638,2 @@\n-    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, elem_ty));\n-    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, elem_ty));\n+    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, bt));\n+    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, bt));\n@@ -1885,1 +1881,1 @@\n-      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, Type::get_const_basic_type(bt)));\n+      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, bt));\n@@ -1890,1 +1886,1 @@\n-      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, Type::get_const_basic_type(bt)));\n+      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, bt));\n@@ -1907,1 +1903,1 @@\n-  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, Type::get_const_basic_type(bt)));\n+  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, bt));\n@@ -2072,2 +2068,1 @@\n-    return VectorNode::scalar2vector(zero, length(), Type::get_const_basic_type(bt),\n-                                     bottom_type()->isa_vectmask() != nullptr);\n+    return VectorNode::scalar2vector(zero, length(), bt, bottom_type()->isa_vectmask() != nullptr);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask = false);\n+  static VectorNode* scalar2vector(Node* s, uint vlen, BasicType bt, bool is_mask = false);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -425,2 +425,1 @@\n-  tty->print(\"vlen=%d element_type=\", _vlen);\n-  _element_type->dump();\n+  tty->print(\"vlen=%d element_type=%s\", _vlen, type2name(_element_type));\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  const Type* _element_type;\n+  BasicType _element_type;\n@@ -359,1 +359,1 @@\n-  VTransformReplicateNode(VTransform& vtransform, int vlen, const Type* element_type) :\n+  VTransformReplicateNode(VTransform& vtransform, int vlen, BasicType element_type) :\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2951,0 +2951,1 @@\n+    ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n@@ -2953,1 +2954,1 @@\n-    MutexLocker mu(Threads_lock);\n+    MutexLocker ml(Threads_lock);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-const char* VectorSupport::svmlname[VectorSupport::NUM_SVML_OP] = {\n+const char* VectorSupport::mathname[VectorSupport::NUM_VECTOR_OP_MATH] = {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,3 +124,3 @@\n-    VECTOR_OP_SVML_START = VECTOR_OP_TAN,\n-    VECTOR_OP_SVML_END   = VECTOR_OP_HYPOT,\n-    NUM_SVML_OP = VECTOR_OP_SVML_END - VECTOR_OP_SVML_START + 1\n+    VECTOR_OP_MATH_START = VECTOR_OP_TAN,\n+    VECTOR_OP_MATH_END   = VECTOR_OP_HYPOT,\n+    NUM_VECTOR_OP_MATH   = VECTOR_OP_MATH_END - VECTOR_OP_MATH_START + 1\n@@ -134,1 +134,2 @@\n-    NUM_VEC_SIZES = 4\n+    VEC_SIZE_SCALABLE = 4,\n+    NUM_VEC_SIZES = 5\n@@ -142,1 +143,1 @@\n-  static const char* svmlname[VectorSupport::NUM_SVML_OP];\n+  static const char* mathname[VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1994,0 +1994,4 @@\n+                                                                            \\\n+  product(bool, UseThreadsLockThrottleLock, true, DIAGNOSTIC,               \\\n+          \"Use an extra lock during Thread start and exit to alleviate\"     \\\n+          \"contention on Threads_lock.\")                                    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,2 +241,0 @@\n- private:\n-  SafepointMechanism::ThreadData _poll_data;\n@@ -601,0 +599,16 @@\n+  static ByteSize polling_word_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_word);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n+  static ByteSize polling_page_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_page);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n@@ -790,2 +804,0 @@\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -638,2 +638,5 @@\n-    \/\/ It is assumed that enter_for must enter on an object without contention.\n-    monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+    do {\n+      \/\/ It is assumed that enter_for must enter on an object without contention.\n+      monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+      \/\/ But there may still be a race with deflation.\n+    } while (monitor == nullptr);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+Monitor* ThreadsLockThrottle_lock     = nullptr;\n@@ -320,0 +321,2 @@\n+  MUTEX_DEFN(ThreadsLockThrottle_lock        , PaddedMonitor, safepoint);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+extern Monitor* ThreadsLockThrottle_lock;        \/\/ used by Thread start\/exit to reduce competition for Threads_lock,\n+                                                 \/\/ so a VM thread calling a safepoint is prioritized\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,2 @@\n-  assert(strcmp(value, system_value) == 0, \"property value mustn't differ from System.getProperty\");\n+  assert(strcmp(value, system_value) == 0, \"property value mustn't differ from System.getProperty. Our value is: %s, System.getProperty is: %s\",\n+         value, system_value);\n","filename":"src\/hotspot\/share\/runtime\/statSampler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -179,2 +179,2 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -297,2 +297,2 @@\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/safepointMechanism.hpp\"\n@@ -112,0 +113,1 @@\n+  friend class JavaThread;\n@@ -138,0 +140,5 @@\n+  \/\/ Poll data is used in generated code for safepoint polls.\n+  \/\/ It is important for performance to put this at lower offset\n+  \/\/ in Thread. The accessors are in JavaThread.\n+  SafepointMechanism::ThreadData _poll_data;\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1031,1 +1031,3 @@\n-  { MonitorLocker ml(Threads_lock);\n+  {\n+    ConditionalMutexLocker throttle_ml(ThreadsLockThrottle_lock, UseThreadsLockThrottleLock);\n+    MonitorLocker ml(Threads_lock);\n@@ -1079,1 +1081,1 @@\n-  } \/\/ unlock Threads_lock\n+  } \/\/ unlock Threads_lock and ThreadsLockThrottle_lock\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1593,1 +1593,0 @@\n-  declare_c2_type(StoreCMNode, StoreNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-     * {@return A {@link ConstantValueEntry} descripbing the provided\n+     * {@return A {@link ConstantValueEntry} describing the provided\n@@ -477,0 +477,1 @@\n+     * @see ConstantValueEntry#constantValue()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.classfile.Attributes;\n@@ -32,2 +33,2 @@\n- * {@code ConstantValue} attribute; this includes the four primitive constant\n- * types and {@linkplain String} constants.\n+ * {@link Attributes#constantValue() ConstantValue} attribute; this includes the four\n+ * primitive constant types and {@linkplain String} constants.\n@@ -45,0 +46,2 @@\n+     *\n+     * @see ConstantPoolBuilder#constantValueEntry(ConstantDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantValueEntry.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.classfile.FieldBuilder;\n@@ -42,1 +41,0 @@\n-import java.lang.constant.DynamicConstantDesc;\n@@ -54,1 +52,1 @@\n-import java.lang.classfile.constantpool.MethodRefEntry;\n+\n@@ -58,2 +56,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -64,0 +60,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -74,1 +71,1 @@\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    private static final @Stable String[] ARG_NAME_CACHE = {\"arg$1\", \"arg$2\", \"arg$3\", \"arg$4\", \"arg$5\", \"arg$6\", \"arg$7\", \"arg$8\"};\n@@ -99,1 +96,0 @@\n-    private final String[] argNames;                 \/\/ Generated names for the constructor arguments\n@@ -177,0 +173,2 @@\n+        ClassDesc[] argDescs;\n+        MethodTypeDesc constructorTypeDesc;\n@@ -178,1 +176,0 @@\n-            argNames = new String[parameterCount];\n@@ -181,1 +178,0 @@\n-                argNames[i] = \"arg$\" + (i + 1);\n@@ -184,0 +180,1 @@\n+            constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n@@ -185,1 +182,0 @@\n-            argNames = EMPTY_STRING_ARRAY;\n@@ -187,0 +183,1 @@\n+            constructorTypeDesc = MTD_void;\n@@ -188,1 +185,6 @@\n-        constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n+        this.argDescs = argDescs;\n+        this.constructorTypeDesc = constructorTypeDesc;\n+    }\n+\n+    private static String argName(int i) {\n+        return i < ARG_NAME_CACHE.length ? ARG_NAME_CACHE[i] :  \"arg$\" + (i + 1);\n@@ -316,1 +318,1 @@\n-                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n+                    clb.withField(argName(i), argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -397,4 +399,3 @@\n-                            cob.aload(0);\n-                            Class<?> argType = factoryType.parameterType(i);\n-                            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n-                            cob.putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                            cob.aload(0)\n+                               .loadLocal(TypeKind.from(factoryType.parameterType(i)), cob.parameterSlot(i))\n+                               .putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -452,1 +453,1 @@\n-                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -509,1 +510,1 @@\n-                for (int i = 0; i < argNames.length; i++) {\n+                for (int i = 0; i < argDescs.length; i++) {\n@@ -511,1 +512,1 @@\n-                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -894,4 +894,3 @@\n-        cob.goto_w(L_done);\n-\n-        \/\/ L_fallback:\n-        cob.labelBinding(L_fallback);\n+        cob.goto_w(L_done)\n+           \/\/ L_fallback:\n+           .labelBinding(L_fallback);\n@@ -948,4 +947,3 @@\n-        cob.exceptionCatch(L_startBlock, L_endBlock, L_handler, CD_Throwable);\n-\n-        \/\/ Normal case\n-        cob.labelBinding(L_startBlock);\n+        cob.exceptionCatch(L_startBlock, L_endBlock, L_handler, CD_Throwable)\n+           \/\/ Normal case\n+           .labelBinding(L_startBlock);\n@@ -955,9 +953,7 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n-        cob.labelBinding(L_endBlock);\n-        cob.goto_w(L_done);\n-\n-        \/\/ Exceptional case\n-        cob.labelBinding(L_handler);\n-\n-        \/\/ Check exception's type\n-        cob.dup();\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()))\n+           .labelBinding(L_endBlock)\n+           .goto_w(L_done)\n+           \/\/ Exceptional case\n+           .labelBinding(L_handler)\n+           \/\/ Check exception's type\n+           .dup();\n@@ -966,2 +962,2 @@\n-        cob.swap();\n-        cob.invokevirtual(CD_Class, \"isInstance\", MTD_boolean_Object);\n+        cob.swap()\n+           .invokevirtual(CD_Class, \"isInstance\", MTD_boolean_Object);\n@@ -977,7 +973,5 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(catcherType.basicType()));\n-        cob.goto_w(L_done);\n-\n-        cob.labelBinding(L_rethrow);\n-        cob.athrow();\n-\n-        cob.labelBinding(L_done);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(catcherType.basicType()))\n+           .goto_w(L_done)\n+           .labelBinding(L_rethrow)\n+           .athrow()\n+           .labelBinding(L_done);\n@@ -1078,2 +1072,2 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n-        cob.labelBinding(lTo);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()))\n+           .labelBinding(lTo);\n@@ -1087,1 +1081,1 @@\n-        cob.loadConstant(null);\n+        cob.aconst_null();\n@@ -1092,6 +1086,5 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc);\n-        cob.goto_w(lDone);\n-\n-        \/\/ CATCH:\n-        cob.labelBinding(lCatch);\n-        cob.dup();\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc)\n+           .goto_w(lDone)\n+           \/\/ CATCH:\n+           .labelBinding(lCatch)\n+           .dup();\n@@ -1110,4 +1103,3 @@\n-        cob.athrow();\n-\n-        \/\/ DONE:\n-        cob.labelBinding(lDone);\n+        cob.athrow()\n+           \/\/ DONE:\n+           .labelBinding(lDone);\n@@ -1150,3 +1142,2 @@\n-        cob.tableswitch(0, numCases - 1, defaultLabel, cases);\n-\n-        cob.labelBinding(defaultLabel);\n+        cob.tableswitch(0, numCases - 1, defaultLabel, cases)\n+           .labelBinding(defaultLabel);\n@@ -1155,2 +1146,2 @@\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n-        cob.goto_(endLabel);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor)\n+           .goto_(endLabel);\n@@ -1162,2 +1153,2 @@\n-            cob.loadConstant(i);\n-            cob.aaload();\n+            cob.loadConstant(i)\n+               .aaload();\n@@ -1167,3 +1158,2 @@\n-            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n-\n-            cob.goto_(endLabel);\n+            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor)\n+               .goto_(endLabel);\n@@ -1338,4 +1328,3 @@\n-            cob.goto_w(lDone);\n-\n-            \/\/ this is the beginning of the next loop clause\n-            cob.labelBinding(lNext);\n+            cob.goto_w(lDone)\n+               \/\/ this is the beginning of the next loop clause\n+               .labelBinding(lNext);\n@@ -1344,4 +1333,3 @@\n-        cob.goto_w(lLoop);\n-\n-        \/\/ DONE:\n-        cob.labelBinding(lDone);\n+        cob.goto_w(lLoop)\n+           \/\/ DONE:\n+           .labelBinding(lDone);\n@@ -1373,2 +1361,2 @@\n-        cob.loadConstant(clause);\n-        cob.aaload();\n+        cob.loadConstant(clause)\n+           .aaload();\n@@ -1388,2 +1376,2 @@\n-        cob.loadConstant(which - 1);\n-        cob.aaload();\n+        cob.loadConstant(which - 1)\n+           .aaload();\n@@ -1522,2 +1510,2 @@\n-                                cob.loadConstant(invokerType.parameterCount());\n-                                cob.anewarray(CD_Object);\n+                                cob.loadConstant(invokerType.parameterCount())\n+                                   .anewarray(CD_Object);\n@@ -1528,2 +1516,2 @@\n-                                    cob.dup();\n-                                    cob.loadConstant(i);\n+                                    cob.dup()\n+                                       .loadConstant(i);\n@@ -1538,4 +1526,4 @@\n-                                cob.aload(0);\n-                                cob.getfield(CD_MethodHandle, \"form\", CD_LambdaForm);\n-                                cob.swap();  \/\/ swap form and array; avoid local variable\n-                                cob.invokevirtual(CD_LambdaForm, \"interpretWithArguments\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object_array));\n+                                cob.aload(0)\n+                                   .getfield(CD_MethodHandle, \"form\", CD_LambdaForm)\n+                                   .swap()  \/\/ swap form and array; avoid local variable\n+                                   .invokevirtual(CD_LambdaForm, \"interpretWithArguments\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object_array));\n@@ -1595,3 +1583,3 @@\n-                                    cob.aload(1);\n-                                    cob.loadConstant(i);\n-                                    cob.aaload();\n+                                    cob.aload(1)\n+                                       .loadConstant(i)\n+                                       .aaload();\n@@ -1648,3 +1636,3 @@\n-                    cob.ldc(os.toString());\n-                    cob.pop();\n-                    cob.return_();\n+                    cob.ldc(os.toString())\n+                       .pop()\n+                       .return_();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":63,"deletions":75,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -376,7 +376,6 @@\n-            clb.withSuperclass(CD_Object);\n-            clb.withFlags(ACC_FINAL | ACC_SYNTHETIC);\n-            clb.withInterfaceSymbols(ifaceDesc);\n-\n-            \/\/ static and instance fields\n-            clb.withField(TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-            clb.withField(TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            clb.withSuperclass(CD_Object)\n+               .withFlags(ACC_FINAL | ACC_SYNTHETIC)\n+               .withInterfaceSymbols(ifaceDesc)\n+               \/\/ static and instance fields\n+               .withField(TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL)\n+               .withField(TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n@@ -389,3 +388,3 @@\n-                cob.loadConstant(ifaceDesc);\n-                cob.putstatic(proxyDesc, TYPE_NAME, CD_Class);\n-                cob.return_();\n+                cob.loadConstant(ifaceDesc)\n+                   .putstatic(proxyDesc, TYPE_NAME, CD_Class)\n+                   .return_();\n@@ -396,11 +395,9 @@\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-\n-                \/\/ call ensureOriginalLookup to verify the given Lookup has access\n-                cob.aload(1);\n-                cob.invokestatic(proxyDesc, \"ensureOriginalLookup\", MTD_void_Lookup);\n-\n-                \/\/ this.target = target;\n-                cob.aload(0);\n-                cob.aload(2);\n-                cob.putfield(proxyDesc, TARGET_NAME, CD_MethodHandle);\n+                cob.aload(0)\n+                   .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                   \/\/ call ensureOriginalLookup to verify the given Lookup has access\n+                   .aload(1)\n+                   .invokestatic(proxyDesc, ENSURE_ORIGINAL_LOOKUP, MTD_void_Lookup)\n+                   \/\/ this.target = target;\n+                   .aload(0)\n+                   .aload(2)\n+                   .putfield(proxyDesc, TARGET_NAME, CD_MethodHandle);\n@@ -411,5 +408,5 @@\n-                    cob.aload(0);\n-                    cob.aload(3);\n-                    cob.loadConstant(mi.desc);\n-                    cob.invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType);\n-                    cob.putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                    cob.aload(0)\n+                       .aload(3)\n+                       .loadConstant(mi.desc)\n+                       .invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType)\n+                       .putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n@@ -428,20 +425,20 @@\n-                cob.aload(0);\n-                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class);\n-                cob.loadConstant(proxyDesc);\n-                cob.if_acmpne(failLabel);\n-                \/\/ check original access\n-                cob.aload(0);\n-                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int);\n-                cob.loadConstant(Lookup.ORIGINAL);\n-                cob.iand();\n-                cob.ifeq(failLabel);\n-                \/\/ success\n-                cob.return_();\n-                \/\/ throw exception\n-                cob.labelBinding(failLabel);\n-                cob.new_(CD_IllegalAccessException);\n-                cob.dup();\n-                cob.aload(0); \/\/ lookup\n-                cob.invokevirtual(CD_Object, \"toString\", MTD_String);\n-                cob.invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String);\n-                cob.athrow();\n+                cob.aload(0)\n+                   .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n+                   .loadConstant(proxyDesc)\n+                   .if_acmpne(failLabel)\n+                   \/\/ check original access\n+                   .aload(0)\n+                   .invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int)\n+                   .loadConstant(Lookup.ORIGINAL)\n+                   .iand()\n+                   .ifeq(failLabel)\n+                   \/\/ success\n+                   .return_()\n+                   \/\/ throw exception\n+                   .labelBinding(failLabel)\n+                   .new_(CD_IllegalAccessException)\n+                   .dup()\n+                   .aload(0) \/\/ lookup\n+                   .invokevirtual(CD_Object, \"toString\", MTD_String)\n+                   .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n+                   .athrow();\n@@ -456,2 +453,2 @@\n-                                    bcb.aload(0);\n-                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    bcb.aload(0)\n+                                       .getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n@@ -462,2 +459,2 @@\n-                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc);\n-                                    bcb.return_(TypeKind.from(mi.desc.returnType()));\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc)\n+                                       .return_(TypeKind.from(mi.desc.returnType()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":47,"deletions":50,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -58,0 +57,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -89,7 +89,7 @@\n-            MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int);\n-    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n-            ConstantDescs.CD_Object,\n-            ConstantDescs.CD_int);\n-    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n-            ConstantDescs.CD_Object,\n-            ConstantDescs.CD_int,\n+            MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(CD_int,\n+            CD_Object,\n+            CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(CD_int,\n+            CD_Object,\n+            CD_int,\n@@ -97,1 +97,1 @@\n-            ConstantDescs.CD_List);\n+            CD_List);\n@@ -487,5 +487,5 @@\n-            cb.iload(RESTART_IDX);\n-            cb.loadConstant(labelConstants.length + 1);\n-            cb.invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR);\n-            cb.pop();\n-            cb.aload(SELECTOR_OBJ);\n+            cb.iload(RESTART_IDX)\n+              .loadConstant(labelConstants.length + 1)\n+              .invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR)\n+              .pop()\n+              .aload(SELECTOR_OBJ);\n@@ -493,4 +493,4 @@\n-            cb.ifnonnull(nonNullLabel);\n-            cb.iconst_m1();\n-            cb.ireturn();\n-            cb.labelBinding(nonNullLabel);\n+            cb.ifnonnull(nonNullLabel)\n+              .iconst_m1()\n+              .ireturn()\n+              .labelBinding(nonNullLabel);\n@@ -499,1 +499,1 @@\n-                        .ireturn();\n+                  .ireturn();\n@@ -538,3 +538,3 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.instanceOf(Wrapper.forBasicType(classLabel).wrapperClassDescriptor());\n-                            cb.ifeq(next);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .instanceOf(Wrapper.forBasicType(classLabel).wrapperClassDescriptor())\n+                              .ifeq(next);\n@@ -545,2 +545,2 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.instanceOf(ConstantDescs.CD_Number);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .instanceOf(CD_Number);\n@@ -553,2 +553,2 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.checkcast(ConstantDescs.CD_Number);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .checkcast(CD_Number);\n@@ -556,1 +556,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -558,1 +558,1 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_long));\n+                                        MethodTypeDesc.of(CD_long));\n@@ -560,1 +560,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -562,1 +562,1 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_float));\n+                                        MethodTypeDesc.of(CD_float));\n@@ -564,1 +564,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -566,1 +566,1 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_double));\n+                                        MethodTypeDesc.of(CD_double));\n@@ -569,1 +569,1 @@\n-                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                cb.invokevirtual(CD_Number,\n@@ -571,9 +571,9 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_int));\n-                                cb.goto_(compare);\n-                                cb.labelBinding(notNumber);\n-                                cb.aload(SELECTOR_OBJ);\n-                                cb.instanceOf(ConstantDescs.CD_Character);\n-                                cb.ifeq(next);\n-                                cb.aload(SELECTOR_OBJ);\n-                                cb.checkcast(ConstantDescs.CD_Character);\n-                                cb.invokevirtual(ConstantDescs.CD_Character,\n+                                        MethodTypeDesc.of(CD_int))\n+                                  .goto_(compare)\n+                                  .labelBinding(notNumber)\n+                                  .aload(SELECTOR_OBJ)\n+                                  .instanceOf(CD_Character)\n+                                  .ifeq(next)\n+                                  .aload(SELECTOR_OBJ)\n+                                  .checkcast(CD_Character)\n+                                  .invokevirtual(CD_Character,\n@@ -581,2 +581,2 @@\n-                                        MethodTypeDesc.of(ConstantDescs.CD_char));\n-                                cb.labelBinding(compare);\n+                                        MethodTypeDesc.of(CD_char))\n+                                  .labelBinding(compare);\n@@ -589,2 +589,2 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, classDesc(typePair.from)));\n-                            cb.ifeq(next);\n+                                    MethodTypeDesc.of(CD_boolean, classDesc(typePair.from)))\n+                              .ifeq(next);\n@@ -595,3 +595,3 @@\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.instanceOf(classLabelConstableOpt.orElseThrow());\n-                            cb.ifeq(next);\n+                            cb.aload(SELECTOR_OBJ)\n+                              .instanceOf(classLabelConstableOpt.orElseThrow())\n+                              .ifeq(next);\n@@ -599,3 +599,3 @@\n-                            cb.aload(EXTRA_CLASS_LABELS);\n-                            cb.loadConstant(extraClassLabels.size());\n-                            cb.invokeinterface(ConstantDescs.CD_List,\n+                            cb.aload(EXTRA_CLASS_LABELS)\n+                              .loadConstant(extraClassLabels.size())\n+                              .invokeinterface(CD_List,\n@@ -603,5 +603,5 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_Object,\n-                                            ConstantDescs.CD_int));\n-                            cb.checkcast(ConstantDescs.CD_Class);\n-                            cb.aload(SELECTOR_OBJ);\n-                            cb.invokevirtual(ConstantDescs.CD_Class,\n+                                    MethodTypeDesc.of(CD_Object,\n+                                            CD_int))\n+                              .checkcast(CD_Class)\n+                              .aload(SELECTOR_OBJ)\n+                              .invokevirtual(CD_Class,\n@@ -609,3 +609,3 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                            ConstantDescs.CD_Object));\n-                            cb.ifeq(next);\n+                                    MethodTypeDesc.of(CD_boolean,\n+                                            CD_Object))\n+                              .ifeq(next);\n@@ -618,3 +618,3 @@\n-                    cb.aload(ENUM_CACHE);\n-                    cb.loadConstant(enumIdx);\n-                    cb.invokestatic(ConstantDescs.CD_Integer,\n+                    cb.aload(ENUM_CACHE)\n+                      .loadConstant(enumIdx)\n+                      .invokestatic(CD_Integer,\n@@ -622,4 +622,4 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n-                                    ConstantDescs.CD_int));\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.invokeinterface(CD_BiPredicate,\n+                            MethodTypeDesc.of(CD_Integer,\n+                                    CD_int))\n+                      .aload(SELECTOR_OBJ)\n+                      .invokeinterface(CD_BiPredicate,\n@@ -627,4 +627,4 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                    ConstantDescs.CD_Object,\n-                                    ConstantDescs.CD_Object));\n-                    cb.ifeq(next);\n+                            MethodTypeDesc.of(CD_boolean,\n+                                    CD_Object,\n+                                    CD_Object))\n+                      .ifeq(next);\n@@ -632,3 +632,3 @@\n-                    cb.ldc(stringLabel);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                    cb.ldc(stringLabel)\n+                      .aload(SELECTOR_OBJ)\n+                      .invokevirtual(CD_Object,\n@@ -636,3 +636,3 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                    ConstantDescs.CD_Object));\n-                    cb.ifeq(next);\n+                            MethodTypeDesc.of(CD_boolean,\n+                                    CD_Object))\n+                      .ifeq(next);\n@@ -642,6 +642,6 @@\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.instanceOf(ConstantDescs.CD_Number);\n-                    cb.ifeq(notNumber);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.checkcast(ConstantDescs.CD_Number);\n-                    cb.invokevirtual(ConstantDescs.CD_Number,\n+                    cb.aload(SELECTOR_OBJ)\n+                      .instanceOf(CD_Number)\n+                      .ifeq(notNumber)\n+                      .aload(SELECTOR_OBJ)\n+                      .checkcast(CD_Number)\n+                      .invokevirtual(CD_Number,\n@@ -649,9 +649,9 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_int));\n-                    cb.goto_(compare);\n-                    cb.labelBinding(notNumber);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.instanceOf(ConstantDescs.CD_Character);\n-                    cb.ifeq(next);\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.checkcast(ConstantDescs.CD_Character);\n-                    cb.invokevirtual(ConstantDescs.CD_Character,\n+                            MethodTypeDesc.of(CD_int))\n+                      .goto_(compare)\n+                      .labelBinding(notNumber)\n+                      .aload(SELECTOR_OBJ)\n+                      .instanceOf(CD_Character)\n+                      .ifeq(next)\n+                      .aload(SELECTOR_OBJ)\n+                      .checkcast(CD_Character)\n+                      .invokevirtual(CD_Character,\n@@ -659,2 +659,2 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_char));\n-                    cb.labelBinding(compare);\n+                            MethodTypeDesc.of(CD_char))\n+                      .labelBinding(compare)\n@@ -662,2 +662,2 @@\n-                    cb.loadConstant(integerLabel);\n-                    cb.if_icmpne(next);\n+                      .loadConstant(integerLabel)\n+                      .if_icmpne(next);\n@@ -677,3 +677,3 @@\n-                                    caseLabelWrapper.basicClassDescriptor()));\n-                    cb.aload(SELECTOR_OBJ);\n-                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                                    caseLabelWrapper.basicClassDescriptor()))\n+                      .aload(SELECTOR_OBJ)\n+                      .invokevirtual(CD_Object,\n@@ -681,3 +681,3 @@\n-                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                    ConstantDescs.CD_Object));\n-                    cb.ifeq(next);\n+                            MethodTypeDesc.of(CD_boolean,\n+                                    CD_Object))\n+                      .ifeq(next);\n@@ -688,2 +688,2 @@\n-                cb.loadConstant(idx);\n-                cb.ireturn();\n+                cb.loadConstant(idx)\n+                  .ireturn();\n@@ -691,3 +691,3 @@\n-            cb.labelBinding(dflt);\n-            cb.loadConstant(labelConstants.length);\n-            cb.ireturn();\n+            cb.labelBinding(dflt)\n+              .loadConstant(labelConstants.length)\n+              .ireturn();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":107,"deletions":107,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n- * @spec http:\/\/www.iso.org\/iso\/home\/standards\/currency_codes.htm ISO - ISO 4217 - Currency codes\n+ * @spec https:\/\/www.iso.org\/iso-4217-currency-codes.html ISO - ISO 4217 - Currency codes\n","filename":"src\/java.base\/share\/classes\/java\/util\/Currency.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2327,6 +2327,5 @@\n-            StringBuilder result = new StringBuilder();\n-            result.append((String)displayNames[1]);\n-            if (displayNames.length > 2) {\n-                result.append(\" (\");\n-                result.append((String)displayNames[2]);\n-                result.append(')');\n+            StringBuilder result = new StringBuilder((String) displayNames[1]);\n+            if (displayNames[2] != null) {\n+                result.append(\" (\")\n+                        .append((String) displayNames[2])\n+                        .append(')');\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -567,2 +567,2 @@\n-                                size = get64(extra, off);\n-                                csize = get64(extra, off + 8);\n+                                size = get64S(extra, off);\n+                                csize = get64S(extra, off + 8);\n@@ -575,1 +575,1 @@\n-                                size = get64(extra, off);\n+                                size = get64S(extra, off);\n@@ -580,1 +580,1 @@\n-                                csize = get64(extra, off + 8);\n+                                csize = get64S(extra, off + 8);\n@@ -591,1 +591,1 @@\n-                    long wtime = get64(extra, pos + 4);\n+                    long wtime = get64S(extra, pos + 4);\n@@ -595,1 +595,1 @@\n-                    wtime = get64(extra, pos + 12);\n+                    wtime = get64S(extra, pos + 12);\n@@ -599,1 +599,1 @@\n-                    wtime = get64(extra, pos + 20);\n+                    wtime = get64S(extra, pos + 20);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+ * @deprecated ZipError is no longer used and is obsolete.\n+ * {@link ZipException} should be used instead.\n@@ -34,0 +36,1 @@\n+@Deprecated(since=\"24\", forRemoval = true)\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipError.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-                    long size = CENLEN(zsrc.cen, pos) + 2;\n+                    long size = CENSIZ(zsrc.cen, pos);\n@@ -418,3 +418,0 @@\n-                    if (size <= 0) {\n-                        size = 4096;\n-                    }\n@@ -909,1 +906,1 @@\n-                        size = get64(cen, off);\n+                        size = get64S(cen, off);\n@@ -916,1 +913,1 @@\n-                        rem = get64(cen, off);\n+                        rem = get64S(cen, off);\n@@ -923,1 +920,1 @@\n-                        pos = get64(cen, off);\n+                        pos = get64S(cen, off);\n@@ -1242,1 +1239,1 @@\n-            long headerSize = (long)CENHDR + nlen + clen + elen;\n+            int headerSize = CENHDR + nlen + clen + elen;\n@@ -1247,1 +1244,1 @@\n-            if (headerSize > 0xFFFF || pos + headerSize > cen.length) {\n+            if (headerSize > 0xFFFF || pos > cen.length - headerSize) {\n@@ -1379,1 +1376,1 @@\n-                    if (get64(cen, off) < 0) {\n+                    if (get64S(cen, off) < 0) {\n@@ -1391,1 +1388,1 @@\n-                    if (get64(cen, off) < 0) {\n+                    if (get64S(cen, off) < 0) {\n@@ -1403,1 +1400,1 @@\n-                    if (get64(cen, off) < 0) {\n+                    if (get64S(cen, off) < 0) {\n@@ -1611,1 +1608,1 @@\n-            int  centot;     \/\/ 4 bytes\n+            long centot;     \/\/ 4 bytes\n@@ -1644,4 +1641,1 @@\n-                    if (buf[i+0] == (byte)'P'    &&\n-                        buf[i+1] == (byte)'K'    &&\n-                        buf[i+2] == (byte)'\\005' &&\n-                        buf[i+3] == (byte)'\\006') {\n+                    if (get32(buf, i) == ENDSIG) {\n@@ -1667,1 +1661,1 @@\n-                                 GETSIG(sbuf) != CENSIG ||\n+                                 get32(sbuf, 0) != CENSIG ||\n@@ -1669,1 +1663,1 @@\n-                                 GETSIG(sbuf) != LOCSIG) {\n+                                 get32(sbuf, 0) != LOCSIG) {\n@@ -1684,1 +1678,1 @@\n-                                != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {\n+                                != loc64.length || get32(loc64, 0) != ZIP64_LOCSIG) {\n@@ -1690,1 +1684,1 @@\n-                                != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {\n+                                != end64buf.length || get32(end64buf, 0) != ZIP64_ENDSIG) {\n@@ -1706,1 +1700,1 @@\n-                            end.centot = (int)centot64; \/\/ assume total < 2g\n+                            end.centot = centot64;\n@@ -1742,0 +1736,3 @@\n+                if (end.centot < 0 || end.centot > end.cenlen \/ CENHDR) {\n+                    zerror(\"invalid END header (total entries count too large)\");\n+                }\n@@ -1746,1 +1743,1 @@\n-                this.total = end.centot;\n+                this.total = Math.toIntExact(end.centot);\n@@ -1771,2 +1768,0 @@\n-            int entryPos = CENHDR;\n-            int limit = cen.length;\n@@ -1774,1 +1769,2 @@\n-            while (entryPos <= limit) {\n+            int limit = cen.length - CENHDR;\n+            while (pos <= limit) {\n@@ -1779,1 +1775,1 @@\n-                    initCEN(countCENHeaders(cen, limit));\n+                    initCEN(countCENHeaders(cen));\n@@ -1783,0 +1779,1 @@\n+                int entryPos = pos + CENHDR;\n@@ -1813,1 +1810,0 @@\n-                entryPos = pos + CENHDR;\n@@ -2037,1 +2033,0 @@\n-         * Will not throw, even if the ZIP file is corrupt.\n@@ -2040,1 +2035,1 @@\n-         * @param size number of bytes in central directory\n+         * @throws ZipException if a CEN header exceeds the length of the CEN array\n@@ -2042,1 +2037,1 @@\n-        private static int countCENHeaders(byte[] cen, int size) {\n+        private static int countCENHeaders(byte[] cen) throws ZipException {\n@@ -2044,3 +2039,6 @@\n-            for (int p = 0;\n-                 p + CENHDR <= size;\n-                 p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))\n+            for (int p = 0; p <= cen.length - CENHDR;) {\n+                int headerSize = CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p);\n+                if (p > cen.length - headerSize) {\n+                    zerror(\"invalid CEN header (bad header size)\");\n+                }\n+                p += headerSize;\n@@ -2048,0 +2046,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":33,"deletions":34,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -606,2 +606,2 @@\n-                    e.csize = get64(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);\n-                    e.size = get64(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);\n+                    e.csize = get64S(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);\n+                    e.size = get64S(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);\n@@ -612,2 +612,2 @@\n-                    e.csize = get64(tmpbuf, ZIP64_EXTSIZ);\n-                    e.size = get64(tmpbuf, ZIP64_EXTLEN);\n+                    e.csize = get64S(tmpbuf, ZIP64_EXTSIZ);\n+                    e.size = get64S(tmpbuf, ZIP64_EXTLEN);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -173,1 +174,4 @@\n-        return (b[off] & 0xff) | ((b[off + 1] & 0xff) << 8);\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 1, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return Short.toUnsignedInt(\n+                UNSAFE.getShortUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false));\n@@ -181,1 +185,4 @@\n-        return (get16(b, off) | ((long)get16(b, off+2) << 16)) & 0xffffffffL;\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 3, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return Integer.toUnsignedLong(\n+                UNSAFE.getIntUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false));\n@@ -188,2 +195,4 @@\n-    public static final long get64(byte[] b, int off) {\n-        return get32(b, off) | (get32(b, off+4) << 32);\n+    public static final long get64S(byte[] b, int off) {\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 7, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return UNSAFE.getLongUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false);\n@@ -198,22 +207,3 @@\n-        return (get16(b, off) | (get16(b, off+2) << 16));\n-    }\n-\n-    \/\/ fields access methods\n-    static final int CH(byte[] b, int n) {\n-        return b[n] & 0xff ;\n-    }\n-\n-    static final int SH(byte[] b, int n) {\n-        return (b[n] & 0xff) | ((b[n + 1] & 0xff) << 8);\n-    }\n-\n-    static final long LG(byte[] b, int n) {\n-        return ((SH(b, n)) | (SH(b, n + 2) << 16)) & 0xffffffffL;\n-    }\n-\n-    static final long LL(byte[] b, int n) {\n-        return (LG(b, n)) | (LG(b, n + 4) << 32);\n-    }\n-\n-    static final long GETSIG(byte[] b) {\n-        return LG(b, 0);\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 3, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return UNSAFE.getIntUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false);\n@@ -234,10 +224,10 @@\n-    static final long LOCSIG(byte[] b) { return LG(b, 0); } \/\/ signature\n-    static final int  LOCVER(byte[] b) { return SH(b, 4); } \/\/ version needed to extract\n-    static final int  LOCFLG(byte[] b) { return SH(b, 6); } \/\/ general purpose bit flags\n-    static final int  LOCHOW(byte[] b) { return SH(b, 8); } \/\/ compression method\n-    static final long LOCTIM(byte[] b) { return LG(b, 10);} \/\/ modification time\n-    static final long LOCCRC(byte[] b) { return LG(b, 14);} \/\/ crc of uncompressed data\n-    static final long LOCSIZ(byte[] b) { return LG(b, 18);} \/\/ compressed data size\n-    static final long LOCLEN(byte[] b) { return LG(b, 22);} \/\/ uncompressed data size\n-    static final int  LOCNAM(byte[] b) { return SH(b, 26);} \/\/ filename length\n-    static final int  LOCEXT(byte[] b) { return SH(b, 28);} \/\/ extra field length\n+    static final long LOCSIG(byte[] b) { return get32(b, 0); } \/\/ signature\n+    static final int  LOCVER(byte[] b) { return get16(b, 4); } \/\/ version needed to extract\n+    static final int  LOCFLG(byte[] b) { return get16(b, 6); } \/\/ general purpose bit flags\n+    static final int  LOCHOW(byte[] b) { return get16(b, 8); } \/\/ compression method\n+    static final long LOCTIM(byte[] b) { return get32(b, 10);} \/\/ modification time\n+    static final long LOCCRC(byte[] b) { return get32(b, 14);} \/\/ crc of uncompressed data\n+    static final long LOCSIZ(byte[] b) { return get32(b, 18);} \/\/ compressed data size\n+    static final long LOCLEN(byte[] b) { return get32(b, 22);} \/\/ uncompressed data size\n+    static final int  LOCNAM(byte[] b) { return get16(b, 26);} \/\/ filename length\n+    static final int  LOCEXT(byte[] b) { return get16(b, 28);} \/\/ extra field length\n@@ -246,3 +236,3 @@\n-    static final long EXTCRC(byte[] b) { return LG(b, 4);}  \/\/ crc of uncompressed data\n-    static final long EXTSIZ(byte[] b) { return LG(b, 8);}  \/\/ compressed size\n-    static final long EXTLEN(byte[] b) { return LG(b, 12);} \/\/ uncompressed size\n+    static final long EXTCRC(byte[] b) { return get32(b, 4);}  \/\/ crc of uncompressed data\n+    static final long EXTSIZ(byte[] b) { return get32(b, 8);}  \/\/ compressed size\n+    static final long EXTLEN(byte[] b) { return get32(b, 12);} \/\/ uncompressed size\n@@ -251,13 +241,13 @@\n-    static final int  ENDSUB(byte[] b) { return SH(b, 8); }  \/\/ number of entries on this disk\n-    static final int  ENDTOT(byte[] b) { return SH(b, 10);}  \/\/ total number of entries\n-    static final long ENDSIZ(byte[] b) { return LG(b, 12);}  \/\/ central directory size\n-    static final long ENDOFF(byte[] b) { return LG(b, 16);}  \/\/ central directory offset\n-    static final int  ENDCOM(byte[] b) { return SH(b, 20);}  \/\/ size of ZIP file comment\n-    static final int  ENDCOM(byte[] b, int off) { return SH(b, off + 20);}\n-\n-    \/\/ zip64 end of central directory recoder fields\n-    static final long ZIP64_ENDTOD(byte[] b) { return LL(b, 24);}  \/\/ total number of entries on disk\n-    static final long ZIP64_ENDTOT(byte[] b) { return LL(b, 32);}  \/\/ total number of entries\n-    static final long ZIP64_ENDSIZ(byte[] b) { return LL(b, 40);}  \/\/ central directory size\n-    static final long ZIP64_ENDOFF(byte[] b) { return LL(b, 48);}  \/\/ central directory offset\n-    static final long ZIP64_LOCOFF(byte[] b) { return LL(b, 8);}   \/\/ zip64 end offset\n+    static final int  ENDSUB(byte[] b) { return get16(b, 8); }  \/\/ number of entries on this disk\n+    static final int  ENDTOT(byte[] b) { return get16(b, 10);}  \/\/ total number of entries\n+    static final long ENDSIZ(byte[] b) { return get32(b, 12);}  \/\/ central directory size\n+    static final long ENDOFF(byte[] b) { return get32(b, 16);}  \/\/ central directory offset\n+    static final int  ENDCOM(byte[] b) { return get16(b, 20);}  \/\/ size of ZIP file comment\n+    static final int  ENDCOM(byte[] b, int off) { return get16(b, off + 20);}\n+\n+    \/\/ zip64 end of central directory record fields\n+    static final long ZIP64_ENDTOD(byte[] b) { return get64S(b, 24);}  \/\/ total number of entries on disk\n+    static final long ZIP64_ENDTOT(byte[] b) { return get64S(b, 32);}  \/\/ total number of entries\n+    static final long ZIP64_ENDSIZ(byte[] b) { return get64S(b, 40);}  \/\/ central directory size\n+    static final long ZIP64_ENDOFF(byte[] b) { return get64S(b, 48);}  \/\/ central directory offset\n+    static final long ZIP64_LOCOFF(byte[] b) { return get64S(b, 8);}   \/\/ zip64 end offset\n@@ -266,18 +256,18 @@\n-    static final long CENSIG(byte[] b, int pos) { return LG(b, pos + 0); }\n-    static final int  CENVEM(byte[] b, int pos) { return SH(b, pos + 4); }\n-    static final int  CENVEM_FA(byte[] b, int pos) { return CH(b, pos + 5); } \/\/ file attribute compatibility\n-    static final int  CENVER(byte[] b, int pos) { return SH(b, pos + 6); }\n-    static final int  CENFLG(byte[] b, int pos) { return SH(b, pos + 8); }\n-    static final int  CENHOW(byte[] b, int pos) { return SH(b, pos + 10);}\n-    static final long CENTIM(byte[] b, int pos) { return LG(b, pos + 12);}\n-    static final long CENCRC(byte[] b, int pos) { return LG(b, pos + 16);}\n-    static final long CENSIZ(byte[] b, int pos) { return LG(b, pos + 20);}\n-    static final long CENLEN(byte[] b, int pos) { return LG(b, pos + 24);}\n-    static final int  CENNAM(byte[] b, int pos) { return SH(b, pos + 28);}\n-    static final int  CENEXT(byte[] b, int pos) { return SH(b, pos + 30);}\n-    static final int  CENCOM(byte[] b, int pos) { return SH(b, pos + 32);}\n-    static final int  CENDSK(byte[] b, int pos) { return SH(b, pos + 34);}\n-    static final int  CENATT(byte[] b, int pos) { return SH(b, pos + 36);}\n-    static final long CENATX(byte[] b, int pos) { return LG(b, pos + 38);}\n-    static final int  CENATX_PERMS(byte[] b, int pos) { return SH(b, pos + 40);} \/\/ posix permission data\n-    static final long CENOFF(byte[] b, int pos) { return LG(b, pos + 42);}\n+    static final long CENSIG(byte[] b, int pos) { return get32(b, pos + 0); }\n+    static final int  CENVEM(byte[] b, int pos) { return get16(b, pos + 4); }\n+    static final int  CENVEM_FA(byte[] b, int pos) { return Byte.toUnsignedInt(b[pos + 5]); } \/\/ file attribute compatibility\n+    static final int  CENVER(byte[] b, int pos) { return get16(b, pos + 6); }\n+    static final int  CENFLG(byte[] b, int pos) { return get16(b, pos + 8); }\n+    static final int  CENHOW(byte[] b, int pos) { return get16(b, pos + 10);}\n+    static final long CENTIM(byte[] b, int pos) { return get32(b, pos + 12);}\n+    static final long CENCRC(byte[] b, int pos) { return get32(b, pos + 16);}\n+    static final long CENSIZ(byte[] b, int pos) { return get32(b, pos + 20);}\n+    static final long CENLEN(byte[] b, int pos) { return get32(b, pos + 24);}\n+    static final int  CENNAM(byte[] b, int pos) { return get16(b, pos + 28);}\n+    static final int  CENEXT(byte[] b, int pos) { return get16(b, pos + 30);}\n+    static final int  CENCOM(byte[] b, int pos) { return get16(b, pos + 32);}\n+    static final int  CENDSK(byte[] b, int pos) { return get16(b, pos + 34);}\n+    static final int  CENATT(byte[] b, int pos) { return get16(b, pos + 36);}\n+    static final long CENATX(byte[] b, int pos) { return get32(b, pos + 38);}\n+    static final int  CENATX_PERMS(byte[] b, int pos) { return get16(b, pos + 40);} \/\/ posix permission data\n+    static final long CENOFF(byte[] b, int pos) { return get32(b, pos + 42);}\n@@ -296,1 +286,1 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -298,2 +288,2 @@\n-    private static final long byteBufferArrayOffset = unsafe.objectFieldOffset(ByteBuffer.class, \"hb\");\n-    private static final long byteBufferOffsetOffset = unsafe.objectFieldOffset(ByteBuffer.class, \"offset\");\n+    private static final long byteBufferArrayOffset = UNSAFE.objectFieldOffset(ByteBuffer.class, \"hb\");\n+    private static final long byteBufferOffsetOffset = UNSAFE.objectFieldOffset(ByteBuffer.class, \"offset\");\n@@ -302,1 +292,1 @@\n-        return (byte[]) unsafe.getReference(byteBuffer, byteBufferArrayOffset);\n+        return (byte[]) UNSAFE.getReference(byteBuffer, byteBufferArrayOffset);\n@@ -306,1 +296,1 @@\n-        return unsafe.getInt(byteBuffer, byteBufferOffsetOffset);\n+        return UNSAFE.getInt(byteBuffer, byteBufferOffsetOffset);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":65,"deletions":75,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-        protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, CharacterRangeTableAttribute attr) {\n@@ -145,0 +145,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -147,4 +148,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.endPc());\n-                buf.writeInt(info.characterRangeStart());\n-                buf.writeInt(info.characterRangeEnd());\n+                buf.writeU2U2(info.startPc(), info.endPc());\n+                buf.writeIntInt(info.characterRangeStart(), info.characterRangeEnd());\n@@ -241,3 +240,4 @@\n-        protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n-            buf.writeIndex(attr.enclosingClass());\n-            buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n+        protected void writeBody(BufWriter bufWriter, EnclosingMethodAttribute attr) {\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2(buf.cpIndex(attr.enclosingClass()),\n+                    buf.cpIndexOrZero(attr.enclosingMethod().orElse(null)));\n@@ -278,1 +278,1 @@\n-        protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, InnerClassesAttribute attr) {\n@@ -280,0 +280,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -282,3 +283,3 @@\n-                buf.writeIndex(ic.innerClass());\n-                buf.writeIndexOrZero(ic.outerClass().orElse(null));\n-                buf.writeIndexOrZero(ic.innerName().orElse(null));\n+                buf.writeU2U2U2(buf.cpIndex(ic.innerClass()),\n+                        buf.cpIndexOrZero(ic.outerClass().orElse(null)),\n+                        buf.cpIndexOrZero(ic.innerName().orElse(null)));\n@@ -303,1 +304,1 @@\n-        protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LineNumberTableAttribute attr) {\n@@ -305,0 +306,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -307,2 +309,1 @@\n-                buf.writeU2(line.startPc());\n-                buf.writeU2(line.lineNumber());\n+                buf.writeU2U2(line.startPc(), line.lineNumber());\n@@ -326,1 +327,1 @@\n-        protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LocalVariableTableAttribute attr) {\n@@ -328,0 +329,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -330,5 +332,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.length());\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.type());\n-                buf.writeU2(info.slot());\n+                buf.writeU2U2(info.startPc(), info.length());\n+                buf.writeU2U2U2(buf.cpIndex(info.name()), buf.cpIndex(info.type()), info.slot());\n@@ -352,1 +351,1 @@\n-        protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LocalVariableTypeTableAttribute attr) {\n@@ -354,0 +353,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -356,5 +356,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.length());\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.signature());\n-                buf.writeU2(info.slot());\n+                buf.writeU2U2(info.startPc(), info.length());\n+                buf.writeU2U2U2(buf.cpIndex(info.name()), buf.cpIndex(info.signature()), info.slot());\n@@ -378,1 +375,1 @@\n-        protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, MethodParametersAttribute attr) {\n@@ -380,0 +377,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -382,2 +380,2 @@\n-                buf.writeIndexOrZero(info.name().orElse(null));\n-                buf.writeU2(info.flagsMask());\n+                buf.writeU2U2(buf.cpIndexOrZero(info.name().orElse(null)),\n+                        info.flagsMask());\n@@ -401,4 +399,5 @@\n-        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n-            buf.writeIndex(attr.moduleName());\n-            buf.writeU2(attr.moduleFlagsMask());\n-            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+        protected void writeBody(BufWriter bufWriter, ModuleAttribute attr) {\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2U2(buf.cpIndex(attr.moduleName()),\n+                    attr.moduleFlagsMask(),\n+                    buf.cpIndexOrZero(attr.moduleVersion().orElse(null)));\n@@ -407,3 +406,3 @@\n-                buf.writeIndex(require.requires());\n-                buf.writeU2(require.requiresFlagsMask());\n-                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+                buf.writeU2U2U2(buf.cpIndex(require.requires()),\n+                        require.requiresFlagsMask(),\n+                        buf.cpIndexOrZero(require.requiresVersion().orElse(null)));\n@@ -413,2 +412,2 @@\n-                buf.writeIndex(export.exportedPackage());\n-                buf.writeU2(export.exportsFlagsMask());\n+                buf.writeU2U2(buf.cpIndex(export.exportedPackage()),\n+                        export.exportsFlagsMask());\n@@ -419,2 +418,2 @@\n-                buf.writeIndex(open.openedPackage());\n-                buf.writeU2(open.opensFlagsMask());\n+                buf.writeU2U2(buf.cpIndex(open.openedPackage()),\n+                        open.opensFlagsMask());\n@@ -445,2 +444,1 @@\n-        protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n-            buf.writeIndex(attr.algorithm());\n+        protected void writeBody(BufWriter bufWriter, ModuleHashesAttribute attr) {\n@@ -448,1 +446,2 @@\n-            buf.writeU2(hashes.size());\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2(buf.cpIndex(attr.algorithm()), hashes.size());\n@@ -450,2 +449,2 @@\n-                buf.writeIndex(hash.moduleName());\n-                buf.writeU2(hash.hash().length);\n+                buf.writeU2U2(buf.cpIndex(hash.moduleName()),\n+                        hash.hash().length);\n@@ -596,1 +595,1 @@\n-        protected void writeBody(BufWriter buf, RecordAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, RecordAttribute attr) {\n@@ -598,0 +597,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -600,3 +600,3 @@\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.descriptor());\n-                Util.writeAttributes((BufWriterImpl) buf, info.attributes());\n+                buf.writeU2U2(buf.cpIndex(info.name()),\n+                        buf.cpIndex(info.descriptor()));\n+                Util.writeAttributes(buf, info.attributes());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -91,2 +91,1 @@\n-        b.writeU2(startBci);\n-        b.writeU2(length);\n+        b.writeU2U2(startBci, length);\n@@ -94,2 +93,1 @@\n-            b.writeU2(nameIndex());\n-            b.writeU2(secondaryIndex());\n+            b.writeU2U2(nameIndex(), secondaryIndex());\n@@ -98,2 +96,1 @@\n-            b.writeIndex(name());\n-            b.writeIndex(secondaryEntry());\n+            b.writeU2U2(b.cpIndex(name()), b.cpIndex(secondaryEntry()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractBoundLocalVariable.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -804,1 +804,6 @@\n-            writer.writeLocalVar(op, slot);\n+            var op = this.op;\n+            if (op.sizeIfFixed() == 1) {\n+                writer.writeBytecode(op);\n+            } else {\n+                writer.writeLocalVar(op, slot);\n+            }\n@@ -835,1 +840,6 @@\n-            writer.writeLocalVar(op, slot);\n+            var op = this.op;\n+            if (op.sizeIfFixed() == 1) {\n+                writer.writeBytecode(op);\n+            } else {\n+                writer.writeLocalVar(op, slot);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -249,0 +249,2 @@\n+            } else {\n+                inflateNonAscii(singleBytes, hash);\n@@ -250,17 +252,25 @@\n-            else {\n-                char[] chararr = new char[rawLen];\n-                int chararr_count = singleBytes;\n-                \/\/ Inflate prefix of bytes to characters\n-                JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n-\n-                int px = offset + singleBytes;\n-                int utfend = offset + rawLen;\n-                while (px < utfend) {\n-                    int c = (int) rawBytes[px] & 0xff;\n-                    switch (c >> 4) {\n-                        case 0, 1, 2, 3, 4, 5, 6, 7: {\n-                            \/\/ 0xxx xxxx\n-                            px++;\n-                            chararr[chararr_count++] = (char) c;\n-                            hash = 31 * hash + c;\n-                            break;\n+        }\n+\n+        private void inflateNonAscii(int singleBytes, int hash) {\n+            char[] chararr = new char[rawLen];\n+            int chararr_count = singleBytes;\n+            \/\/ Inflate prefix of bytes to characters\n+            JLA.inflateBytesToChars(rawBytes, offset, chararr, 0, singleBytes);\n+\n+            int px = offset + singleBytes;\n+            int utfend = offset + rawLen;\n+            while (px < utfend) {\n+                int c = (int) rawBytes[px] & 0xff;\n+                switch (c >> 4) {\n+                    case 0, 1, 2, 3, 4, 5, 6, 7: {\n+                        \/\/ 0xxx xxxx\n+                        px++;\n+                        chararr[chararr_count++] = (char) c;\n+                        hash = 31 * hash + c;\n+                        break;\n+                    }\n+                    case 12, 13: {\n+                        \/\/ 110x xxxx  10xx xxxx\n+                        px += 2;\n+                        if (px > utfend) {\n+                            throw malformedInput(utfend);\n@@ -268,14 +278,3 @@\n-                        case 12, 13: {\n-                            \/\/ 110x xxxx  10xx xxxx\n-                            px += 2;\n-                            if (px > utfend) {\n-                                throw malformedInput(utfend);\n-                            }\n-                            int char2 = rawBytes[px - 1];\n-                            if ((char2 & 0xC0) != 0x80) {\n-                                throw malformedInput(px);\n-                            }\n-                            char v = (char) (((c & 0x1F) << 6) | (char2 & 0x3F));\n-                            chararr[chararr_count++] = v;\n-                            hash = 31 * hash + v;\n-                            break;\n+                        int char2 = rawBytes[px - 1];\n+                        if ((char2 & 0xC0) != 0x80) {\n+                            throw malformedInput(px);\n@@ -283,15 +282,10 @@\n-                        case 14: {\n-                            \/\/ 1110 xxxx  10xx xxxx  10xx xxxx\n-                            px += 3;\n-                            if (px > utfend) {\n-                                throw malformedInput(utfend);\n-                            }\n-                            int char2 = rawBytes[px - 2];\n-                            int char3 = rawBytes[px - 1];\n-                            if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {\n-                                throw malformedInput(px - 1);\n-                            }\n-                            char v = (char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | (char3 & 0x3F));\n-                            chararr[chararr_count++] = v;\n-                            hash = 31 * hash + v;\n-                            break;\n+                        char v = (char) (((c & 0x1F) << 6) | (char2 & 0x3F));\n+                        chararr[chararr_count++] = v;\n+                        hash = 31 * hash + v;\n+                        break;\n+                    }\n+                    case 14: {\n+                        \/\/ 1110 xxxx  10xx xxxx  10xx xxxx\n+                        px += 3;\n+                        if (px > utfend) {\n+                            throw malformedInput(utfend);\n@@ -299,3 +293,9 @@\n-                        default:\n-                            \/\/ 10xx xxxx,  1111 xxxx\n-                            throw malformedInput(px);\n+                        int char2 = rawBytes[px - 2];\n+                        int char3 = rawBytes[px - 1];\n+                        if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {\n+                            throw malformedInput(px - 1);\n+                        }\n+                        char v = (char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | (char3 & 0x3F));\n+                        chararr[chararr_count++] = v;\n+                        hash = 31 * hash + v;\n+                        break;\n@@ -303,0 +303,3 @@\n+                    default:\n+                        \/\/ 10xx xxxx,  1111 xxxx\n+                        throw malformedInput(px);\n@@ -304,4 +307,0 @@\n-                this.contentHash = hash;\n-                charLen = chararr_count;\n-                this.chars = chararr;\n-                state = State.CHAR;\n@@ -309,0 +308,4 @@\n+            this.contentHash = hash;\n+            charLen = chararr_count;\n+            this.chars = chararr;\n+            state = State.CHAR;\n@@ -464,1 +467,0 @@\n-            pool.writeU1(TAG_UTF8);\n@@ -466,1 +468,1 @@\n-                pool.writeU2(rawLen);\n+                pool.writeU1U2(TAG_UTF8, rawLen);\n@@ -471,1 +473,1 @@\n-                pool.writeUTF(stringValue);\n+                pool.writeUtfEntry(stringValue);\n@@ -505,2 +507,1 @@\n-            pool.writeU1(tag());\n-            pool.writeU2(ref1.index());\n+            pool.writeU1U2(tag(), ref1.index());\n@@ -535,3 +536,1 @@\n-            pool.writeU1(tag());\n-            pool.writeU2(ref1.index());\n-            pool.writeU2(ref2.index());\n+            pool.writeU1U2U2(tag(), ref1.index(), ref2.index());\n@@ -867,3 +866,1 @@\n-            pool.writeU1(tag());\n-            pool.writeU2(bsmIndex);\n-            pool.writeU2(nameAndType.index());\n+            pool.writeU1U2U2(tag(), bsmIndex, nameAndType.index());\n@@ -987,3 +984,1 @@\n-            pool.writeU1(TAG_METHOD_HANDLE);\n-            pool.writeU1(refKind);\n-            pool.writeU2(reference.index());\n+            pool.writeU1U1U2(TAG_METHOD_HANDLE, refKind, reference.index());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":62,"deletions":67,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -203,5 +203,2 @@\n-            b.writeU2(startBci);\n-            b.writeU2(length);\n-            b.writeIndex(name);\n-            b.writeIndex(descriptor);\n-            b.writeU2(slot());\n+            b.writeU2U2(startBci, length);\n+            b.writeU2U2U2(b.cpIndex(name), b.cpIndex(descriptor), slot());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -285,1 +285,0 @@\n-        buf.writeIndex(annotation.className());\n@@ -287,1 +286,1 @@\n-        buf.writeU2(elements.size());\n+        buf.writeU2U2(buf.cpIndex(annotation.className()), elements.size());\n@@ -318,2 +317,1 @@\n-                buf.writeU1(tpbt.typeParameterIndex());\n-                buf.writeU1(tpbt.boundIndex());\n+                buf.writeU1U1(tpbt.typeParameterIndex(), tpbt.boundIndex());\n@@ -330,3 +328,1 @@\n-                    buf.writeU2(startPc);\n-                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n-                    buf.writeU2(e.index());\n+                    buf.writeU2U2U2(startPc, labelToBci(lr, e.endLabel(), ta) - startPc, e.index());\n@@ -338,2 +334,2 @@\n-                buf.writeU2(labelToBci(lr, tat.target(), ta));\n-                buf.writeU1(tat.typeArgumentIndex());\n+                buf.writeU2U1(labelToBci(lr, tat.target(), ta),\n+                        tat.typeArgumentIndex());\n@@ -346,2 +342,1 @@\n-            buf.writeU1(component.typePathKind().tag());\n-            buf.writeU1(component.typeArgumentIndex());\n+            buf.writeU1U1(component.typePathKind().tag(), component.typeArgumentIndex());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.Arrays;\n@@ -34,1 +33,3 @@\n-    private final List<Attribute<?>> attributes = new ArrayList<>();\n+    private static final Attribute<?>[] EMPTY_ATTRIBUTE_ARRAY = {};\n+    private int attributesCount = 0;\n+    private Attribute<?>[] attributes = EMPTY_ATTRIBUTE_ARRAY;\n@@ -42,2 +43,10 @@\n-        if (!am.allowMultiple() && isPresent(am)) {\n-            remove(am);\n+        int attributesCount = this.attributesCount;\n+        var attributes = this.attributes;\n+        if (!am.allowMultiple()) {\n+            \/\/ remove if\n+            for (int i = attributesCount - 1; i >= 0; i--) {\n+                if (attributes[i].attributeMapper() == am) {\n+                    attributesCount--;\n+                    System.arraycopy(attributes, i + 1, attributes, i, attributesCount - i);\n+                }\n+            }\n@@ -45,1 +54,8 @@\n-        attributes.add(a);\n+\n+        \/\/ add attribute\n+        if (attributesCount >= attributes.length) {\n+            int newCapacity = attributesCount + 4;\n+            this.attributes = attributes = Arrays.copyOf(attributes, newCapacity);\n+        }\n+        attributes[attributesCount] = a;\n+        this.attributesCount = attributesCount + 1;\n@@ -49,1 +65,1 @@\n-        return attributes.size();\n+        return attributesCount;\n@@ -53,1 +69,5 @@\n-        Util.writeAttributes(buf, attributes);\n+        int attributesCount = this.attributesCount;\n+        buf.writeU2(attributesCount);\n+        for (int i = 0; i < attributesCount; i++) {\n+            Util.writeAttribute(buf, attributes[i]);\n+        }\n@@ -58,1 +78,2 @@\n-        for (Attribute<?> a : attributes)\n+        for (int i = 0; i < attributesCount; i++) {\n+            Attribute<?> a = attributes[i];\n@@ -60,1 +81,2 @@\n-                return (A)a;\n+                return (A) a;\n+        }\n@@ -65,2 +87,2 @@\n-        for (Attribute<?> a : attributes)\n-            if (a.attributeMapper() == am)\n+        for (int i = 0; i < attributesCount; i++) {\n+            if (attributes[i].attributeMapper() == am)\n@@ -68,0 +90,1 @@\n+        }\n@@ -70,4 +93,0 @@\n-\n-    private void remove(AttributeMapper<?> am) {\n-        attributes.removeIf(a -> a.attributeMapper() == am);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":35,"deletions":16,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import static java.lang.classfile.constantpool.PoolEntry.TAG_UTF8;\n@@ -117,0 +118,87 @@\n+    @ForceInline\n+    public void writeU1U1(int x1, int x2) {\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) x2;\n+        this.offset = offset + 2;\n+    }\n+\n+    public void writeU1U2(int u1, int u2) {\n+        reserveSpace(3);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) u1;\n+        elems[offset + 1] = (byte) (u2 >> 8);\n+        elems[offset + 2] = (byte) u2;\n+        this.offset = offset + 3;\n+    }\n+\n+    public void writeU1U1U1(int x1, int x2, int x3) {\n+        reserveSpace(3);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) x2;\n+        elems[offset + 2] = (byte) x3;\n+        this.offset = offset + 3;\n+    }\n+\n+    public void writeU1U1U2(int x1, int x2, int x3) {\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) x2;\n+        elems[offset + 2] = (byte) (x3 >> 8);\n+        elems[offset + 3] = (byte) x3;\n+        this.offset = offset + 4;\n+    }\n+\n+    public void writeU1U2U2(int x1, int x2, int x3) {\n+        reserveSpace(5);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) (x2 >> 8);\n+        elems[offset + 2] = (byte) x2;\n+        elems[offset + 3] = (byte) (x3 >> 8);\n+        elems[offset + 4] = (byte) x3;\n+        this.offset = offset + 5;\n+    }\n+\n+    public void writeU2U1(int x1, int x2) {\n+        reserveSpace(3);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 8);\n+        elems[offset + 1] = (byte) x1;\n+        elems[offset + 2] = (byte) x2;\n+        this.offset = offset + 3;\n+    }\n+\n+    public void writeU2U2(int x1, int x2) {\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 8);\n+        elems[offset + 1] = (byte) x1;\n+        elems[offset + 2] = (byte) (x2 >> 8);\n+        elems[offset + 3] = (byte) x2;\n+        this.offset = offset + 4;\n+    }\n+\n+    public void writeU2U2U2(int x1, int x2, int x3) {\n+        reserveSpace(6);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 8);\n+        elems[offset + 1] = (byte) x1;\n+        elems[offset + 2] = (byte) (x2 >> 8);\n+        elems[offset + 3] = (byte) x2;\n+        elems[offset + 4] = (byte) (x3 >> 8);\n+        elems[offset + 5] = (byte) x3;\n+        this.offset = offset + 6;\n+    }\n+\n@@ -129,0 +217,15 @@\n+    public void writeIntInt(int x1, int x2) {\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 24);\n+        elems[offset + 1] = (byte) (x1 >> 16);\n+        elems[offset + 2] = (byte) (x1 >> 8);\n+        elems[offset + 3] = (byte)  x1;\n+        elems[offset + 4] = (byte) (x2 >> 24);\n+        elems[offset + 5] = (byte) (x2 >> 16);\n+        elems[offset + 6] = (byte) (x2 >> 8);\n+        elems[offset + 7] = (byte)  x2;\n+        this.offset = offset + 8;\n+    }\n+\n@@ -165,1 +268,1 @@\n-    void writeUTF(String str) {\n+    void writeUtfEntry(String str) {\n@@ -172,1 +275,1 @@\n-        reserveSpace(utflen + 2);\n+        reserveSpace(utflen + 3);\n@@ -177,3 +280,4 @@\n-        elems[offset    ] = (byte) (utflen >> 8);\n-        elems[offset + 1] = (byte)  utflen;\n-        offset += 2;\n+        elems[offset    ] = (byte) TAG_UTF8;\n+        elems[offset + 1] = (byte) (utflen >> 8);\n+        elems[offset + 2] = (byte)  utflen;\n+        offset += 3;\n@@ -272,3 +376,1 @@\n-    @ForceInline\n-    @Override\n-    public void writeIndex(PoolEntry entry) {\n+    public int cpIndex(PoolEntry entry) {\n@@ -278,1 +380,17 @@\n-        writeU2(idx);\n+        return idx;\n+    }\n+\n+    public int cpIndexOrZero(PoolEntry entry) {\n+        if (entry == null || entry.index() == 0)\n+            return 0;\n+        return cpIndex(entry);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void writeIndex(PoolEntry entry) {\n+        writeU2(cpIndex(entry));\n+    }\n+\n+    public void writeIndex(int bytecode, PoolEntry entry) {\n+        writeU1U2(bytecode, cpIndex(entry));\n@@ -287,4 +405,1 @@\n-        if (entry == null || entry.index() == 0)\n-            writeU2(0);\n-        else\n-            writeIndex(entry);\n+        writeU2(cpIndexOrZero(entry));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":128,"deletions":13,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -93,1 +93,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -107,1 +107,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -109,1 +109,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -123,1 +123,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -125,1 +125,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -139,1 +139,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -141,1 +141,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -155,1 +155,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -157,1 +157,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -183,1 +183,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -185,1 +185,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -199,1 +199,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -201,1 +201,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -215,1 +215,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -217,1 +217,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -231,1 +231,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -233,1 +233,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -247,1 +247,1 @@\n-                if ((slot & 0xFF) == slot)\n+                if ((slot & ~0xFF) == 0)\n@@ -249,1 +249,1 @@\n-                if ((slot & 0xFFFF) == slot)\n+                if ((slot & ~0xFFFF) == 0)\n@@ -267,0 +267,5 @@\n+    public static int returnBytecode(TypeKind tk) {\n+        int kind = Math.max(0, tk.ordinal() - 4); \/\/ BYTE, SHORT, CHAR, BOOLEAN becomes INT\n+        return IRETURN + kind;\n+    }\n+\n@@ -281,0 +286,14 @@\n+    public static int arrayLoadBytecode(TypeKind tk) {\n+        return switch (tk) {\n+            case BYTE, BOOLEAN -> BALOAD;\n+            case SHORT -> SALOAD;\n+            case INT -> IALOAD;\n+            case FLOAT -> FALOAD;\n+            case LONG -> LALOAD;\n+            case DOUBLE -> DALOAD;\n+            case REFERENCE -> AALOAD;\n+            case CHAR -> CALOAD;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+        };\n+    }\n+\n@@ -295,0 +314,14 @@\n+    public static int arrayStoreBytecode(TypeKind tk) {\n+        return switch (tk) {\n+            case BYTE, BOOLEAN -> BASTORE;\n+            case SHORT -> SASTORE;\n+            case INT -> IASTORE;\n+            case FLOAT -> FASTORE;\n+            case LONG -> LASTORE;\n+            case DOUBLE -> DASTORE;\n+            case REFERENCE -> AASTORE;\n+            case CHAR -> CASTORE;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+        };\n+    }\n+\n@@ -317,0 +350,23 @@\n+    public static int reverseBranchOpcode(int bytecode) {\n+        return switch (bytecode) {\n+            case IFEQ -> IFNE;\n+            case IFNE -> IFEQ;\n+            case IFLT -> IFGE;\n+            case IFGE -> IFLT;\n+            case IFGT -> IFLE;\n+            case IFLE -> IFGT;\n+            case IF_ICMPEQ -> IF_ICMPNE;\n+            case IF_ICMPNE -> IF_ICMPEQ;\n+            case IF_ICMPLT -> IF_ICMPGE;\n+            case IF_ICMPGE -> IF_ICMPLT;\n+            case IF_ICMPGT -> IF_ICMPLE;\n+            case IF_ICMPLE -> IF_ICMPGT;\n+            case IF_ACMPEQ -> IF_ACMPNE;\n+            case IF_ACMPNE -> IF_ACMPEQ;\n+            case IFNULL -> IFNONNULL;\n+            case IFNONNULL -> IFNULL;\n+            default -> throw new IllegalArgumentException(\n+                    String.format(\"Wrong opcode kind specified; found %d, expected %s\", bytecode, Opcode.Kind.BRANCH));\n+        };\n+    }\n+\n@@ -380,2 +436,2 @@\n-                size == 2 && slot == (slot & 0xFF) ||\n-                size == 4 && slot == (slot & 0xFFFF))\n+                size == 2 && (slot & ~0xFF) == 0 ||\n+                size == 4 && (slot & ~0xFFFF) == 0)\n@@ -387,1 +443,1 @@\n-        if ((slot & 0xFFFF) != slot)\n+        if ((slot & ~0xFFFF) != 0)\n@@ -393,1 +449,1 @@\n-        if ((slot & 0xFF) != slot) {\n+        if ((slot & ~0xFF) != 0) {\n@@ -407,2 +463,2 @@\n-        if (opcode == Opcode.RET && slot == (slot & 0xFF) ||\n-                opcode == Opcode.RET_W && slot == (slot & 0xFFFF))\n+        if (opcode == Opcode.RET && (slot & ~0xFF) == 0 ||\n+                opcode == Opcode.RET_W && (slot & ~0xFFFF) == 0)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":82,"deletions":26,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -356,1 +356,5 @@\n-        throw new ConstantPoolException(\"Not a \" + cls.getSimpleName() + \" at index: \" + index);\n+        throw checkTypeError(index, cls);\n+    }\n+\n+    private static ConstantPoolException checkTypeError(int index, Class<?> cls) {\n+        return new ConstantPoolException(\"Not a \" + cls.getSimpleName() + \" at index: \" + index);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -33,0 +34,1 @@\n+import java.util.Arrays;\n@@ -57,0 +59,2 @@\n+    static final Util.Writable[] EMPTY_WRITABLE_ARRAY = {};\n+    static final ClassEntry[] EMPTY_CLASS_ENTRY_ARRAY = {};\n@@ -58,2 +62,4 @@\n-    private final List<Util.Writable> fields = new ArrayList<>();\n-    private final List<Util.Writable> methods = new ArrayList<>();\n+    private Util.Writable[] fields = EMPTY_WRITABLE_ARRAY;\n+    private Util.Writable[] methods = EMPTY_WRITABLE_ARRAY;\n+    private int fieldsCount = 0;\n+    private int methodsCount = 0;\n@@ -140,1 +146,5 @@\n-        fields.add(field);\n+        if (fieldsCount >= fields.length) {\n+            int newCapacity = fieldsCount + 8;\n+            this.fields = Arrays.copyOf(fields, newCapacity);\n+        }\n+        fields[fieldsCount++] = field;\n@@ -145,1 +155,5 @@\n-        methods.add(method);\n+        if (methodsCount >= methods.length) {\n+            int newCapacity = methodsCount + 8;\n+            this.methods = Arrays.copyOf(methods, newCapacity);\n+        }\n+        methods[methodsCount++] = method;\n@@ -187,3 +201,1 @@\n-        List<ClassEntry> ies = new ArrayList<>(interfaceEntriesSize);\n-        for (int i = 0; i < interfaceEntriesSize; i++)\n-            ies.add(AbstractPoolEntry.maybeClone(constantPool, interfaceEntries.get(i)));\n+        ClassEntry[] ies = interfaceEntriesSize == 0 ? EMPTY_CLASS_ENTRY_ARRAY : buildInterfaceEnties(interfaceEntriesSize);\n@@ -198,2 +210,2 @@\n-        Util.writeList(tail, fields);\n-        Util.writeList(tail, methods);\n+        Util.writeList(tail, fields, fieldsCount);\n+        Util.writeList(tail, methods, methodsCount);\n@@ -210,3 +222,2 @@\n-        head.writeLong((((long) ClassFile.MAGIC_NUMBER) << 32)\n-                | ((minorVersion & 0xFFFFL) << 16)\n-                | (majorVersion & 0xFFFFL));\n+        head.writeInt(ClassFile.MAGIC_NUMBER);\n+        head.writeU2U2(minorVersion, majorVersion);\n@@ -214,4 +225,5 @@\n-        head.writeU2(flags);\n-        head.writeIndex(thisClassEntry);\n-        head.writeIndexOrZero(superclass);\n-        Util.writeListIndices(head, ies);\n+        head.writeU2U2U2(flags, head.cpIndex(thisClassEntry), head.cpIndexOrZero(superclass));\n+        head.writeU2(interfaceEntriesSize);\n+        for (int i = 0; i < interfaceEntriesSize; i++) {\n+            head.writeIndex(ies[i]);\n+        }\n@@ -222,0 +234,7 @@\n+\n+    private ClassEntry[] buildInterfaceEnties(int interfaceEntriesSize) {\n+        var ies = new ClassEntry[interfaceEntriesSize];\n+        for (int i = 0; i < interfaceEntriesSize; i++)\n+            ies[i] = AbstractPoolEntry.maybeClone(constantPool, interfaceEntries.get(i));\n+        return ies;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":35,"deletions":16,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -55,1 +57,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -57,0 +58,1 @@\n+import java.util.Arrays;\n@@ -65,2 +67,0 @@\n-import static java.lang.classfile.Opcode.*;\n-\n@@ -68,0 +68,1 @@\n+import static jdk.internal.classfile.impl.RawBytecodeHelper.*;\n@@ -72,1 +73,7 @@\n-    private final List<CharacterRange> characterRanges = new ArrayList<>();\n+    private static final CharacterRange[] EMPTY_CHARACTER_RANGE = {};\n+    private static final DeferredLabel[] EMPTY_LABEL_ARRAY = {};\n+    private static final LocalVariable[] EMPTY_LOCAL_VARIABLE_ARRAY = {};\n+    private static final LocalVariableType[] EMPTY_LOCAL_VARIABLE_TYPE_ARRAY = {};\n+    private static final AbstractPseudoInstruction.ExceptionCatchImpl[] EMPTY_HANDLER_ARRAY = {};\n+    private static final DeferredLabel[] EMPTY_DEFERRED_LABEL_ARRAY = {};\n+\n@@ -74,3 +81,7 @@\n-    private final List<LocalVariable> localVariables = new ArrayList<>();\n-    private final List<LocalVariableType> localVariableTypes = new ArrayList<>();\n-    private final boolean transformFwdJumps, transformBackJumps;\n+    private CharacterRange[] characterRanges = EMPTY_CHARACTER_RANGE;\n+    private LocalVariable[] localVariables = EMPTY_LOCAL_VARIABLE_ARRAY;\n+    private LocalVariableType[] localVariableTypes = EMPTY_LOCAL_VARIABLE_TYPE_ARRAY;\n+    private int characterRangesCount = 0;\n+    private int localVariablesCount = 0;\n+    private int localVariableTypesCount = 0;\n+    private final boolean transformDeferredJumps, transformKnownJumps;\n@@ -86,1 +97,2 @@\n-    List<DeferredLabel> deferredLabels;\n+    private DeferredLabel[] deferredLabels = EMPTY_DEFERRED_LABEL_ARRAY;\n+    private int deferredLabelsCount = 0;\n@@ -120,1 +132,1 @@\n-                              boolean transformFwdJumps) {\n+                              boolean transformDeferredJumps) {\n@@ -124,2 +136,2 @@\n-        this.transformFwdJumps = transformFwdJumps;\n-        this.transformBackJumps = context.fixShortJumps();\n+        this.transformDeferredJumps = transformDeferredJumps;\n+        this.transformKnownJumps = context.fixShortJumps();\n@@ -211,3 +223,1 @@\n-                buf.writeU2(startPc);\n-                buf.writeU2(endPc);\n-                buf.writeU2(handlerPc);\n+                buf.writeU2U2U2(startPc, endPc, handlerPc);\n@@ -230,1 +240,1 @@\n-            if (!characterRanges.isEmpty()) {\n+            if (characterRangesCount > 0) {\n@@ -236,1 +246,1 @@\n-                        int crSize = characterRanges.size();\n+                        int crSize = characterRangesCount;\n@@ -238,1 +248,2 @@\n-                        for (CharacterRange cr : characterRanges) {\n+                        for (int i = 0; i < characterRangesCount; i++) {\n+                            CharacterRange cr = characterRanges[i];\n@@ -248,4 +259,2 @@\n-                                b.writeU2(start);\n-                                b.writeU2(end - 1);\n-                                b.writeInt(cr.characterRangeStart());\n-                                b.writeInt(cr.characterRangeEnd());\n+                                b.writeU2U2(start, end - 1);\n+                                b.writeIntInt(cr.characterRangeStart(), cr.characterRangeEnd());\n@@ -255,1 +264,1 @@\n-                        if (crSize < characterRanges.size())\n+                        if (crSize < characterRangesCount)\n@@ -262,1 +271,1 @@\n-            if (!localVariables.isEmpty()) {\n+            if (localVariablesCount > 0) {\n@@ -267,1 +276,1 @@\n-                        int lvSize = localVariables.size();\n+                        int lvSize = localVariablesCount;\n@@ -269,1 +278,2 @@\n-                        for (LocalVariable l : localVariables) {\n+                        for (int i = 0; i < localVariablesCount; i++) {\n+                            LocalVariable l = localVariables[i];\n@@ -278,1 +288,1 @@\n-                        if (lvSize < localVariables.size())\n+                        if (lvSize < localVariablesCount)\n@@ -285,1 +295,1 @@\n-            if (!localVariableTypes.isEmpty()) {\n+            if (localVariableTypesCount > 0) {\n@@ -290,3 +300,4 @@\n-                        int lvtSize = localVariableTypes.size();\n-                        b.writeU2(localVariableTypes.size());\n-                        for (LocalVariableType l : localVariableTypes) {\n+                        int lvtSize = localVariableTypesCount;\n+                        b.writeU2(lvtSize);\n+                        for (int i = 0; i < localVariableTypesCount; i++) {\n+                            LocalVariableType l = localVariableTypes[i];\n@@ -301,1 +312,1 @@\n-                        if (lvtSize < localVariableTypes.size())\n+                        if (lvtSize < localVariableTypesCount)\n@@ -318,2 +329,1 @@\n-                    buf.writeU2(originalAttribute.maxStack());\n-                    buf.writeU2(originalAttribute.maxLocals());\n+                    buf.writeU2U2(originalAttribute.maxStack(), originalAttribute.maxLocals());\n@@ -322,2 +332,1 @@\n-                    buf.writeU2(cntr.maxStack());\n-                    buf.writeU2(cntr.maxLocals());\n+                    buf.writeU2U2(cntr.maxStack(), cntr.maxLocals());\n@@ -330,4 +339,4 @@\n-                StackMapGenerator gen = StackMapGenerator.of(DirectCodeBuilder.this, buf);\n-                attributes.withAttribute(gen.stackMapTableAttribute());\n-                buf.writeU2(gen.maxStack());\n-                buf.writeU2(gen.maxLocals());\n+                var dcb = DirectCodeBuilder.this;\n+                StackMapGenerator gen = StackMapGenerator.of(dcb, buf);\n+                dcb.attributes.withAttribute(gen.stackMapTableAttribute());\n+                buf.writeU2U2(gen.maxStack(), gen.maxLocals());\n@@ -355,1 +364,2 @@\n-                buf.setLabelContext(DirectCodeBuilder.this);\n+                DirectCodeBuilder dcb = DirectCodeBuilder.this;\n+                buf.setLabelContext(dcb);\n@@ -362,2 +372,2 @@\n-                            methodInfo.methodName().stringValue(),\n-                            methodInfo.methodTypeSymbol().displayDescriptor()));\n+                            dcb.methodInfo.methodName().stringValue(),\n+                            dcb.methodInfo.methodTypeSymbol().displayDescriptor()));\n@@ -366,7 +376,5 @@\n-                if (codeAndExceptionsMatch(codeLength)) {\n-                    if (context.stackMapsWhenRequired()) {\n-                        attributes.withAttribute(original.findAttribute(Attributes.stackMapTable()).orElse(null));\n-                        writeCounters(true, buf);\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n+                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n+                var context = dcb.context;\n+                if (context.stackMapsWhenRequired()) {\n+                    if (codeMatch) {\n+                        dcb.attributes.withAttribute(dcb.original.findAttribute(Attributes.stackMapTable()).orElse(null));\n@@ -374,3 +382,1 @@\n-                    }\n-                } else {\n-                    if (context.stackMapsWhenRequired()) {\n+                    } else {\n@@ -378,4 +384,0 @@\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(false, buf);\n@@ -383,0 +385,4 @@\n+                } else if (context.generateStackMaps()) {\n+                    generateStackMaps(buf);\n+                } else if (context.dropStackMaps()) {\n+                    writeCounters(codeMatch, buf);\n@@ -386,3 +392,3 @@\n-                buf.writeBytes(bytecodesBufWriter);\n-                writeExceptionHandlers(buf);\n-                attributes.writeTo(buf);\n+                buf.writeBytes(dcb.bytecodesBufWriter);\n+                dcb.writeExceptionHandlers(buf);\n+                dcb.attributes.writeTo(buf);\n@@ -408,2 +414,1 @@\n-                buf.writeU2(lastPc);\n-                buf.writeU2(lastLine);\n+                buf.writeU2U2(lastPc, lastLine);\n@@ -459,15 +464,0 @@\n-    private void writeLabelOffset(int nBytes, int instructionPc, Label label) {\n-        int targetBci = labelToBci(label);\n-        if (targetBci == -1) {\n-            int pc = bytecodesBufWriter.skip(nBytes);\n-            if (deferredLabels == null)\n-                deferredLabels = new ArrayList<>();\n-            deferredLabels.add(new DeferredLabel(pc, nBytes, instructionPc, label));\n-        }\n-        else {\n-            int branchOffset = targetBci - instructionPc;\n-            if (nBytes == 2 && (short)branchOffset != branchOffset) throw new LabelOverflowException();\n-            bytecodesBufWriter.writeIntBytes(nBytes, branchOffset);\n-        }\n-    }\n-\n@@ -475,10 +465,9 @@\n-        if (deferredLabels != null) {\n-            for (DeferredLabel dl : deferredLabels) {\n-                int branchOffset = labelToBci(dl.label) - dl.instructionPc;\n-                if (dl.size == 2) {\n-                    if ((short)branchOffset != branchOffset) throw new LabelOverflowException();\n-                    bytecodesBufWriter.patchU2(dl.labelPc, branchOffset);\n-                } else {\n-                    assert dl.size == 4;\n-                    bytecodesBufWriter.patchInt(dl.labelPc, branchOffset);\n-                }\n+        for (int i = 0; i < deferredLabelsCount; i++) {\n+            DeferredLabel dl = deferredLabels[i];\n+            int branchOffset = labelToBci(dl.label) - dl.instructionPc;\n+            if (dl.size == 2) {\n+                if ((short) branchOffset != branchOffset) throw new LabelOverflowException();\n+                bytecodesBufWriter.patchU2(dl.labelPc, branchOffset);\n+            } else {\n+                assert dl.size == 4;\n+                bytecodesBufWriter.patchInt(dl.labelPc, branchOffset);\n@@ -492,0 +481,6 @@\n+        assert !opcode.isWide();\n+        bytecodesBufWriter.writeU1(opcode.bytecode());\n+    }\n+\n+    \/\/ Instruction version, refer to opcode\n+    public void writeLocalVar(Opcode opcode, int slot) {\n@@ -493,1 +488,1 @@\n-            bytecodesBufWriter.writeU2(opcode.bytecode());\n+            bytecodesBufWriter.writeU2U2(opcode.bytecode(), slot);\n@@ -495,1 +490,1 @@\n-            bytecodesBufWriter.writeU1(opcode.bytecode());\n+            bytecodesBufWriter.writeU1U1(opcode.bytecode(), slot);\n@@ -499,7 +494,7 @@\n-    public void writeLocalVar(Opcode opcode, int localVar) {\n-        writeBytecode(opcode);\n-        switch (opcode.sizeIfFixed()) {\n-            case 1 -> { }\n-            case 2 -> bytecodesBufWriter.writeU1(localVar);\n-            case 4 -> bytecodesBufWriter.writeU2(localVar);\n-            default -> throw new IllegalArgumentException(\"Unexpected instruction size: \" + opcode);\n+    \/\/ Shortcut version, refer to and validate slot\n+    private void writeLocalVar(int bytecode, int slot) {\n+        \/\/ TODO validation like (slot & 0xFFFF) == slot\n+        if (slot < 256) {\n+            bytecodesBufWriter.writeU1U1(bytecode, slot);\n+        } else {\n+            bytecodesBufWriter.writeU1U1U2(WIDE, bytecode, slot);\n@@ -511,6 +506,1 @@\n-            bytecodesBufWriter.writeU1(RawBytecodeHelper.WIDE);\n-        }\n-        bytecodesBufWriter.writeU1(RawBytecodeHelper.IINC);\n-        if (wide) {\n-            bytecodesBufWriter.writeU2(slot);\n-            bytecodesBufWriter.writeU2(val);\n+            bytecodesBufWriter.writeU2U2U2((WIDE << 8) | IINC, slot, val);\n@@ -518,2 +508,1 @@\n-            bytecodesBufWriter.writeU1(slot);\n-            bytecodesBufWriter.writeU1(val);\n+            bytecodesBufWriter.writeU1U1U1(IINC, slot, val);\n@@ -524,0 +513,25 @@\n+        if (op.sizeIfFixed() == 3) {\n+            writeShortJump(op.bytecode(), target);\n+        } else {\n+            writeLongJump(op.bytecode(), target);\n+        }\n+    }\n+\n+    private void writeLongLabelOffset(int instructionPc, Label label) {\n+        int targetBci = labelToBci(label);\n+\n+        \/\/ algebraic union of jump | (instructionPc, target), distinguished by null == target.\n+        int jumpOrInstructionPc;\n+        Label nullOrTarget;\n+        if (targetBci == -1) {\n+            jumpOrInstructionPc = instructionPc;\n+            nullOrTarget = label;\n+        } else {\n+            jumpOrInstructionPc = targetBci - instructionPc;\n+            nullOrTarget = null;\n+        }\n+\n+        writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget);\n+    }\n+\n+    private void writeShortJump(int bytecode, Label target) {\n@@ -526,0 +540,12 @@\n+\n+        \/\/ algebraic union of jump | (instructionPc, target), distinguished by null == target.\n+        int jumpOrInstructionPc;\n+        Label nullOrTarget;\n+        if (targetBci == -1) {\n+            jumpOrInstructionPc = instructionPc;\n+            nullOrTarget = target;\n+        } else {\n+            jumpOrInstructionPc = targetBci - instructionPc;\n+            nullOrTarget = null;\n+        }\n+\n@@ -527,10 +553,28 @@\n-        if (op.sizeIfFixed() == 3 && (targetBci == -1\n-                                      ? transformFwdJumps\n-                                      : (transformBackJumps\n-                                         && targetBci - instructionPc < Short.MIN_VALUE))) {\n-            if (op == GOTO) {\n-                writeBytecode(GOTO_W);\n-                writeLabelOffset(4, instructionPc, target);\n-            } else if (op == JSR) {\n-                writeBytecode(JSR_W);\n-                writeLabelOffset(4, instructionPc, target);\n+        if (transformDeferredJumps || transformKnownJumps && nullOrTarget == null && jumpOrInstructionPc < Short.MIN_VALUE) {\n+            fixShortJump(bytecode, jumpOrInstructionPc, nullOrTarget);\n+        } else {\n+            bytecodesBufWriter.writeU1(bytecode);\n+            writeParsedShortLabel(jumpOrInstructionPc, nullOrTarget);\n+        }\n+    }\n+\n+    private void writeLongJump(int bytecode, Label target) {\n+        int instructionPc = curPc();\n+        bytecodesBufWriter.writeU1(bytecode);\n+        writeLongLabelOffset(instructionPc, target);\n+    }\n+\n+    private void fixShortJump(int bytecode, int jumpOrInstructionPc, Label nullOrTarget) {\n+        if (bytecode == GOTO) {\n+            bytecodesBufWriter.writeU1(GOTO_W);\n+            writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget);\n+        } else if (bytecode == JSR) {\n+            bytecodesBufWriter.writeU1(JSR_W);\n+            writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget);\n+        } else {\n+            bytecodesBufWriter.writeU1U2(\n+                    BytecodeHelpers.reverseBranchOpcode(bytecode),   \/\/ u1\n+                    8); \/\/ u1 + s2 + u1 + s4                         \/\/ s2\n+            bytecodesBufWriter.writeU1(GOTO_W);                      \/\/ u1\n+            if (nullOrTarget == null) {\n+                jumpOrInstructionPc -= 3; \/\/ jump -= 3;\n@@ -538,6 +582,1 @@\n-                writeBytecode(BytecodeHelpers.reverseBranchOpcode(op));\n-                Label bypassJump = newLabel();\n-                writeLabelOffset(2, instructionPc, bypassJump);\n-                writeBytecode(GOTO_W);\n-                writeLabelOffset(4, instructionPc + 3, target);\n-                labelBinding(bypassJump);\n+                jumpOrInstructionPc += 3; \/\/ instructionPc += 3;\n@@ -545,0 +584,9 @@\n+            writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget); \/\/ s4\n+        }\n+    }\n+\n+    private void writeParsedShortLabel(int jumpOrInstructionPc, Label nullOrTarget) {\n+        if (nullOrTarget == null) {\n+            if ((short) jumpOrInstructionPc != jumpOrInstructionPc)\n+                throw new LabelOverflowException();\n+            bytecodesBufWriter.writeU2(jumpOrInstructionPc);\n@@ -546,2 +594,11 @@\n-            writeBytecode(op);\n-            writeLabelOffset(op.sizeIfFixed() == 3 ? 2 : 4, instructionPc, target);\n+            int pc = bytecodesBufWriter.skip(2);\n+            addLabel(new DeferredLabel(pc, 2, jumpOrInstructionPc, nullOrTarget));\n+        }\n+    }\n+\n+    private void writeParsedLongLabel(int jumpOrInstructionPc, Label nullOrTarget) {\n+        if (nullOrTarget == null) {\n+            bytecodesBufWriter.writeInt(jumpOrInstructionPc);\n+        } else {\n+            int pc = bytecodesBufWriter.skip(4);\n+            addLabel(new DeferredLabel(pc, 4, jumpOrInstructionPc, nullOrTarget));\n@@ -553,1 +610,1 @@\n-        writeBytecode(LOOKUPSWITCH);\n+        bytecodesBufWriter.writeU1(LOOKUPSWITCH);\n@@ -557,1 +614,1 @@\n-        writeLabelOffset(4, instructionPc, defaultTarget);\n+        writeLongLabelOffset(instructionPc, defaultTarget);\n@@ -568,1 +625,2 @@\n-            writeLabelOffset(4, instructionPc, c.target());\n+            var target = c.target();\n+            writeLongLabelOffset(instructionPc, target);\n@@ -574,1 +632,1 @@\n-        writeBytecode(TABLESWITCH);\n+        bytecodesBufWriter.writeU1(TABLESWITCH);\n@@ -578,3 +636,2 @@\n-        writeLabelOffset(4, instructionPc, defaultTarget);\n-        bytecodesBufWriter.writeInt(low);\n-        bytecodesBufWriter.writeInt(high);\n+        writeLongLabelOffset(instructionPc, defaultTarget);\n+        bytecodesBufWriter.writeIntInt(low, high);\n@@ -586,1 +643,2 @@\n-            writeLabelOffset(4, instructionPc, caseMap.getOrDefault((int)l, defaultTarget));\n+            var target = caseMap.getOrDefault((int)l, defaultTarget);\n+            writeLongLabelOffset(instructionPc, target);\n@@ -591,2 +649,1 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(ref);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n@@ -596,2 +653,1 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(ref);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n@@ -603,4 +659,2 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(ref);\n-        bytecodesBufWriter.writeU1(count);\n-        bytecodesBufWriter.writeU1(0);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n+        bytecodesBufWriter.writeU1U1(count, 0);\n@@ -610,3 +664,1 @@\n-        writeBytecode(INVOKEDYNAMIC);\n-        bytecodesBufWriter.writeIndex(ref);\n-        bytecodesBufWriter.writeU2(0);\n+        bytecodesBufWriter.writeU1U2U2(INVOKEDYNAMIC, bytecodesBufWriter.cpIndex(ref), 0);\n@@ -616,2 +668,1 @@\n-        writeBytecode(NEW);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(NEW, type);\n@@ -621,2 +672,1 @@\n-        writeBytecode(NEWARRAY);\n-        bytecodesBufWriter.writeU1(newArrayCode);\n+        bytecodesBufWriter.writeU1U1(NEWARRAY, newArrayCode);\n@@ -626,2 +676,1 @@\n-        writeBytecode(ANEWARRAY);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(ANEWARRAY, type);\n@@ -631,2 +680,1 @@\n-        writeBytecode(MULTIANEWARRAY);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(MULTIANEWARRAY, type);\n@@ -637,2 +685,1 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), type);\n@@ -642,1 +689,0 @@\n-        writeBytecode(opcode);\n@@ -644,1 +690,1 @@\n-            bytecodesBufWriter.writeU2(value);\n+            bytecodesBufWriter.writeU1U2(opcode.bytecode(), value);\n@@ -646,1 +692,1 @@\n-            bytecodesBufWriter.writeU1(value);\n+            bytecodesBufWriter.writeU1U1(opcode.bytecode(), value);\n@@ -652,1 +698,1 @@\n-        \/\/ rewrite to _W if index is > 256\n+        \/\/ rewrite to _W if index is >= 256\n@@ -654,1 +700,0 @@\n-        Opcode op = opcode;\n@@ -656,1 +701,1 @@\n-            op = LDC2_W;\n+            opcode = Opcode.LDC2_W;\n@@ -658,1 +703,1 @@\n-            op = LDC_W;\n+            opcode = Opcode.LDC_W;\n@@ -660,3 +705,3 @@\n-        writeBytecode(op);\n-        if (op.sizeIfFixed() == 3) {\n-            bytecodesBufWriter.writeU2(index);\n+        assert !opcode.isWide();\n+        if (opcode.sizeIfFixed() == 3) {\n+            bytecodesBufWriter.writeU1U2(opcode.bytecode(), index);\n@@ -664,1 +709,1 @@\n-            bytecodesBufWriter.writeU1(index);\n+            bytecodesBufWriter.writeU1U1(opcode.bytecode(), index);\n@@ -680,1 +725,5 @@\n-        else if (context == mruParent) {\n+        return labelToBci(context, lab);\n+    }\n+\n+    private int labelToBci(LabelContext context, LabelImpl lab) {\n+        if (context == mruParent) {\n@@ -720,3 +769,1 @@\n-        LabelContext context = lab.labelContext();\n-\n-        if (context == this) {\n+        if (lab.labelContext() == this) {\n@@ -726,0 +773,2 @@\n+        } else {\n+            setLabelTarget(lab, bci);\n@@ -727,1 +776,5 @@\n-        else if (context == mruParent) {\n+    }\n+\n+    private void setLabelTarget(LabelImpl lab, int bci) {\n+        LabelContext context = lab.labelContext();\n+        if (context == mruParent) {\n@@ -742,1 +795,1 @@\n-            mruParentTable[lab.getBCI()] = bci + 1;\n+            table[lab.getBCI()] = bci + 1;\n@@ -754,1 +807,13 @@\n-        characterRanges.add(element);\n+        if (characterRangesCount >= characterRanges.length) {\n+            int newCapacity = characterRangesCount + 8;\n+            this.characterRanges = Arrays.copyOf(characterRanges, newCapacity);\n+        }\n+        characterRanges[characterRangesCount++] = element;\n+    }\n+\n+    public void addLabel(DeferredLabel label) {\n+        if (deferredLabelsCount >= deferredLabels.length) {\n+            int newCapacity = deferredLabelsCount + 8;\n+            this.deferredLabels = Arrays.copyOf(deferredLabels, newCapacity);\n+        }\n+        deferredLabels[deferredLabelsCount++] = label;\n@@ -766,1 +831,5 @@\n-        localVariables.add(element);\n+        if (localVariablesCount >= localVariables.length) {\n+            int newCapacity = localVariablesCount + 8;\n+            this.localVariables = Arrays.copyOf(localVariables, newCapacity);\n+        }\n+        localVariables[localVariablesCount++] = element;\n@@ -770,1 +839,5 @@\n-        localVariableTypes.add(element);\n+        if (localVariableTypesCount >= localVariableTypes.length) {\n+            int newCapacity = localVariableTypesCount + 8;\n+            this.localVariableTypes = Arrays.copyOf(localVariableTypes, newCapacity);\n+        }\n+        localVariableTypes[localVariableTypesCount++] = element;\n@@ -791,0 +864,6 @@\n+    @Override\n+    public CodeBuilder return_() {\n+        bytecodesBufWriter.writeU1(RETURN);\n+        return this;\n+    }\n+\n@@ -793,1 +872,1 @@\n-        writeBytecode(BytecodeHelpers.returnOpcode(tk));\n+        bytecodesBufWriter.writeU1(returnBytecode(tk));\n@@ -799,1 +878,14 @@\n-        writeLocalVar(BytecodeHelpers.storeOpcode(tk, slot), slot);\n+        return switch (tk) {\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> istore(slot);\n+            case LONG      -> lstore(slot);\n+            case DOUBLE    -> dstore(slot);\n+            case FLOAT     -> fstore(slot);\n+            case REFERENCE -> astore(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    @Override\n+    public CodeBuilder labelBinding(Label label) {\n+        setLabelTarget(label, curPc());\n@@ -805,2 +897,9 @@\n-        writeLocalVar(BytecodeHelpers.loadOpcode(tk, slot), slot);\n-        return this;\n+        return switch (tk) {\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> iload(slot);\n+            case LONG      -> lload(slot);\n+            case DOUBLE    -> dload(slot);\n+            case FLOAT     -> fload(slot);\n+            case REFERENCE -> aload(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n@@ -811,1 +910,1 @@\n-        if (opcode == INVOKEINTERFACE) {\n+        if (opcode == Opcode.INVOKEINTERFACE) {\n@@ -820,0 +919,24 @@\n+    @Override\n+    public CodeBuilder invokespecial(ClassDesc owner, String name, MethodTypeDesc type) {\n+        bytecodesBufWriter.writeIndex(INVOKESPECIAL, constantPool().methodRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(ClassDesc owner, String name, MethodTypeDesc type) {\n+        bytecodesBufWriter.writeIndex(INVOKESTATIC, constantPool().methodRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokevirtual(ClassDesc owner, String name, MethodTypeDesc type) {\n+        bytecodesBufWriter.writeIndex(INVOKEVIRTUAL, constantPool().methodRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder getfield(ClassDesc owner, String name, ClassDesc type) {\n+        bytecodesBufWriter.writeIndex(GETFIELD, constantPool().fieldRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n@@ -822,1 +945,1 @@\n-        writeFieldAccess(opcode, ref);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n@@ -828,1 +951,1 @@\n-        writeBytecode(BytecodeHelpers.arrayLoadOpcode(tk));\n+        bytecodesBufWriter.writeU1(BytecodeHelpers.arrayLoadBytecode(tk));\n@@ -834,1 +957,1 @@\n-        writeBytecode(BytecodeHelpers.arrayStoreOpcode(tk));\n+        bytecodesBufWriter.writeU1(BytecodeHelpers.arrayStoreBytecode(tk));\n@@ -846,1 +969,1 @@\n-        writeBytecode(NOP);\n+        bytecodesBufWriter.writeU1(NOP);\n@@ -852,1 +975,1 @@\n-        writeBytecode(ACONST_NULL);\n+        bytecodesBufWriter.writeU1(ACONST_NULL);\n@@ -858,1 +981,5 @@\n-        writeLocalVar(BytecodeHelpers.aload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ALOAD_0 + slot);\n+        } else {\n+            writeLocalVar(ALOAD, slot);\n+        }\n@@ -870,1 +997,7 @@\n-        writeBytecode(ARRAYLENGTH);\n+        bytecodesBufWriter.writeU1(ARRAYLENGTH);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder areturn() {\n+        bytecodesBufWriter.writeU1(ARETURN);\n@@ -876,1 +1009,5 @@\n-        writeLocalVar(BytecodeHelpers.astore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ASTORE_0 + slot);\n+        } else {\n+            writeLocalVar(ASTORE, slot);\n+        }\n@@ -882,1 +1019,1 @@\n-        writeBytecode(ATHROW);\n+        bytecodesBufWriter.writeU1(ATHROW);\n@@ -889,1 +1026,1 @@\n-        writeArgumentConstant(BIPUSH, b);\n+        bytecodesBufWriter.writeU1U1(BIPUSH, b);\n@@ -895,1 +1032,1 @@\n-        writeTypeCheck(CHECKCAST, type);\n+        bytecodesBufWriter.writeIndex(CHECKCAST, type);\n@@ -901,1 +1038,1 @@\n-        writeBytecode(D2F);\n+        bytecodesBufWriter.writeU1(D2F);\n@@ -907,1 +1044,1 @@\n-        writeBytecode(D2I);\n+        bytecodesBufWriter.writeU1(D2I);\n@@ -913,1 +1050,1 @@\n-        writeBytecode(D2L);\n+        bytecodesBufWriter.writeU1(D2L);\n@@ -919,1 +1056,1 @@\n-        writeBytecode(DADD);\n+        bytecodesBufWriter.writeU1(DADD);\n@@ -925,1 +1062,1 @@\n-        writeBytecode(DCMPG);\n+        bytecodesBufWriter.writeU1(DCMPG);\n@@ -931,1 +1068,1 @@\n-        writeBytecode(DCMPL);\n+        bytecodesBufWriter.writeU1(DCMPL);\n@@ -937,1 +1074,1 @@\n-        writeBytecode(DCONST_0);\n+        bytecodesBufWriter.writeU1(DCONST_0);\n@@ -943,1 +1080,1 @@\n-        writeBytecode(DCONST_1);\n+        bytecodesBufWriter.writeU1(DCONST_1);\n@@ -949,1 +1086,1 @@\n-        writeBytecode(DDIV);\n+        bytecodesBufWriter.writeU1(DDIV);\n@@ -955,1 +1092,5 @@\n-        writeLocalVar(BytecodeHelpers.dload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(DLOAD_0 + slot);\n+        } else {\n+            writeLocalVar(DLOAD, slot);\n+        }\n@@ -961,1 +1102,1 @@\n-        writeBytecode(DMUL);\n+        bytecodesBufWriter.writeU1(DMUL);\n@@ -967,1 +1108,1 @@\n-        writeBytecode(DNEG);\n+        bytecodesBufWriter.writeU1(DNEG);\n@@ -973,1 +1114,7 @@\n-        writeBytecode(DREM);\n+        bytecodesBufWriter.writeU1(DREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dreturn() {\n+        bytecodesBufWriter.writeU1(DRETURN);\n@@ -979,1 +1126,5 @@\n-        writeLocalVar(BytecodeHelpers.dstore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(DSTORE_0 + slot);\n+        } else {\n+            writeLocalVar(DSTORE, slot);\n+        }\n@@ -985,1 +1136,1 @@\n-        writeBytecode(DSUB);\n+        bytecodesBufWriter.writeU1(DSUB);\n@@ -991,1 +1142,1 @@\n-        writeBytecode(DUP);\n+        bytecodesBufWriter.writeU1(DUP);\n@@ -997,1 +1148,1 @@\n-        writeBytecode(DUP2);\n+        bytecodesBufWriter.writeU1(DUP2);\n@@ -1003,1 +1154,1 @@\n-        writeBytecode(DUP2_X1);\n+        bytecodesBufWriter.writeU1(DUP2_X1);\n@@ -1009,1 +1160,1 @@\n-        writeBytecode(DUP2_X2);\n+        bytecodesBufWriter.writeU1(DUP2_X2);\n@@ -1015,1 +1166,1 @@\n-        writeBytecode(DUP_X1);\n+        bytecodesBufWriter.writeU1(DUP_X1);\n@@ -1021,1 +1172,1 @@\n-        writeBytecode(DUP_X2);\n+        bytecodesBufWriter.writeU1(DUP_X2);\n@@ -1027,1 +1178,1 @@\n-        writeBytecode(F2D);\n+        bytecodesBufWriter.writeU1(F2D);\n@@ -1033,1 +1184,1 @@\n-        writeBytecode(F2I);\n+        bytecodesBufWriter.writeU1(F2I);\n@@ -1039,1 +1190,1 @@\n-        writeBytecode(F2L);\n+        bytecodesBufWriter.writeU1(F2L);\n@@ -1045,1 +1196,1 @@\n-        writeBytecode(FADD);\n+        bytecodesBufWriter.writeU1(FADD);\n@@ -1051,1 +1202,1 @@\n-        writeBytecode(FCMPG);\n+        bytecodesBufWriter.writeU1(FCMPG);\n@@ -1057,1 +1208,1 @@\n-        writeBytecode(FCMPL);\n+        bytecodesBufWriter.writeU1(FCMPL);\n@@ -1063,1 +1214,1 @@\n-        writeBytecode(FCONST_0);\n+        bytecodesBufWriter.writeU1(FCONST_0);\n@@ -1069,1 +1220,1 @@\n-        writeBytecode(FCONST_1);\n+        bytecodesBufWriter.writeU1(FCONST_1);\n@@ -1075,1 +1226,1 @@\n-        writeBytecode(FCONST_2);\n+        bytecodesBufWriter.writeU1(FCONST_2);\n@@ -1081,1 +1232,1 @@\n-        writeBytecode(FDIV);\n+        bytecodesBufWriter.writeU1(FDIV);\n@@ -1087,1 +1238,5 @@\n-        writeLocalVar(BytecodeHelpers.fload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(FLOAD_0 + slot);\n+        } else {\n+            writeLocalVar(FLOAD, slot);\n+        }\n@@ -1093,1 +1248,1 @@\n-        writeBytecode(FMUL);\n+        bytecodesBufWriter.writeU1(FMUL);\n@@ -1099,1 +1254,1 @@\n-        writeBytecode(FNEG);\n+        bytecodesBufWriter.writeU1(FNEG);\n@@ -1105,1 +1260,7 @@\n-        writeBytecode(FREM);\n+        bytecodesBufWriter.writeU1(FREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder freturn() {\n+        bytecodesBufWriter.writeU1(FRETURN);\n@@ -1111,1 +1272,5 @@\n-        writeLocalVar(BytecodeHelpers.fstore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(FSTORE_0 + slot);\n+        } else {\n+            writeLocalVar(FSTORE, slot);\n+        }\n@@ -1117,1 +1282,13 @@\n-        writeBytecode(FSUB);\n+        bytecodesBufWriter.writeU1(FSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder getstatic(ClassDesc owner, String name, ClassDesc type) {\n+        bytecodesBufWriter.writeIndex(GETSTATIC, constantPool().fieldRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder goto_(Label target) {\n+        writeShortJump(GOTO, target);\n@@ -1123,1 +1300,1 @@\n-        writeBytecode(I2B);\n+        bytecodesBufWriter.writeU1(I2B);\n@@ -1129,1 +1306,1 @@\n-        writeBytecode(I2C);\n+        bytecodesBufWriter.writeU1(I2C);\n@@ -1135,1 +1312,1 @@\n-        writeBytecode(I2D);\n+        bytecodesBufWriter.writeU1(I2D);\n@@ -1141,1 +1318,1 @@\n-        writeBytecode(I2F);\n+        bytecodesBufWriter.writeU1(I2F);\n@@ -1147,1 +1324,1 @@\n-        writeBytecode(I2L);\n+        bytecodesBufWriter.writeU1(I2L);\n@@ -1153,1 +1330,1 @@\n-        writeBytecode(I2S);\n+        bytecodesBufWriter.writeU1(I2S);\n@@ -1159,1 +1336,1 @@\n-        writeBytecode(IADD);\n+        bytecodesBufWriter.writeU1(IADD);\n@@ -1165,1 +1342,1 @@\n-        writeBytecode(IAND);\n+        bytecodesBufWriter.writeU1(IAND);\n@@ -1171,1 +1348,1 @@\n-        writeBytecode(ICONST_0);\n+        bytecodesBufWriter.writeU1(ICONST_0);\n@@ -1177,1 +1354,1 @@\n-        writeBytecode(ICONST_1);\n+        bytecodesBufWriter.writeU1(ICONST_1);\n@@ -1183,1 +1360,1 @@\n-        writeBytecode(ICONST_2);\n+        bytecodesBufWriter.writeU1(ICONST_2);\n@@ -1189,1 +1366,1 @@\n-        writeBytecode(ICONST_3);\n+        bytecodesBufWriter.writeU1(ICONST_3);\n@@ -1195,1 +1372,1 @@\n-        writeBytecode(ICONST_4);\n+        bytecodesBufWriter.writeU1(ICONST_4);\n@@ -1201,1 +1378,1 @@\n-        writeBytecode(ICONST_5);\n+        bytecodesBufWriter.writeU1(ICONST_5);\n@@ -1207,1 +1384,1 @@\n-        writeBytecode(ICONST_M1);\n+        bytecodesBufWriter.writeU1(ICONST_M1);\n@@ -1213,1 +1390,97 @@\n-        writeBytecode(IDIV);\n+        bytecodesBufWriter.writeU1(IDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_acmpeq(Label target) {\n+        writeShortJump(IF_ACMPEQ, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_acmpne(Label target) {\n+        writeShortJump(IF_ACMPNE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpeq(Label target) {\n+        writeShortJump(IF_ICMPEQ, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpge(Label target) {\n+        writeShortJump(IF_ICMPGE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpgt(Label target) {\n+        writeShortJump(IF_ICMPGT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmple(Label target) {\n+        writeShortJump(IF_ICMPLE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmplt(Label target) {\n+        writeShortJump(IF_ICMPLT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpne(Label target) {\n+        writeShortJump(IF_ICMPNE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifnonnull(Label target) {\n+        writeShortJump(IFNONNULL, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifnull(Label target) {\n+        writeShortJump(IFNULL, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifeq(Label target) {\n+        writeShortJump(IFEQ, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifge(Label target) {\n+        writeShortJump(IFGE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifgt(Label target) {\n+        writeShortJump(IFGT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifle(Label target) {\n+        writeShortJump(IFLE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iflt(Label target) {\n+        writeShortJump(IFLT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifne(Label target) {\n+        writeShortJump(IFNE, target);\n@@ -1225,1 +1498,5 @@\n-        writeLocalVar(BytecodeHelpers.iload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ILOAD_0 + slot);\n+        } else {\n+            writeLocalVar(ILOAD, slot);\n+        }\n@@ -1231,1 +1508,1 @@\n-        writeBytecode(IMUL);\n+        bytecodesBufWriter.writeU1(IMUL);\n@@ -1237,1 +1514,1 @@\n-        writeBytecode(INEG);\n+        bytecodesBufWriter.writeU1(INEG);\n@@ -1243,1 +1520,1 @@\n-        writeTypeCheck(INSTANCEOF, target);\n+        bytecodesBufWriter.writeIndex(INSTANCEOF, target);\n@@ -1255,1 +1532,1 @@\n-        writeInvokeInterface(INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n+        writeInvokeInterface(Opcode.INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n@@ -1261,1 +1538,1 @@\n-        writeInvokeNormal(INVOKESPECIAL, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESPECIAL, ref);\n@@ -1267,1 +1544,1 @@\n-        writeInvokeNormal(INVOKESPECIAL, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESPECIAL, ref);\n@@ -1273,1 +1550,1 @@\n-        writeInvokeNormal(INVOKESTATIC, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESTATIC, ref);\n@@ -1279,1 +1556,1 @@\n-        writeInvokeNormal(INVOKESTATIC, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESTATIC, ref);\n@@ -1285,1 +1562,1 @@\n-        writeInvokeNormal(INVOKEVIRTUAL, ref);\n+        bytecodesBufWriter.writeIndex(INVOKEVIRTUAL, ref);\n@@ -1291,1 +1568,1 @@\n-        writeBytecode(IOR);\n+        bytecodesBufWriter.writeU1(IOR);\n@@ -1297,1 +1574,7 @@\n-        writeBytecode(IREM);\n+        bytecodesBufWriter.writeU1(IREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ireturn() {\n+        bytecodesBufWriter.writeU1(IRETURN);\n@@ -1303,1 +1586,1 @@\n-        writeBytecode(ISHL);\n+        bytecodesBufWriter.writeU1(ISHL);\n@@ -1309,1 +1592,1 @@\n-        writeBytecode(ISHR);\n+        bytecodesBufWriter.writeU1(ISHR);\n@@ -1315,1 +1598,5 @@\n-        writeLocalVar(BytecodeHelpers.istore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ISTORE_0 + slot);\n+        } else {\n+            writeLocalVar(ISTORE, slot);\n+        }\n@@ -1321,1 +1608,1 @@\n-        writeBytecode(ISUB);\n+        bytecodesBufWriter.writeU1(ISUB);\n@@ -1327,1 +1614,1 @@\n-        writeBytecode(IUSHR);\n+        bytecodesBufWriter.writeU1(IUSHR);\n@@ -1333,1 +1620,1 @@\n-        writeBytecode(IXOR);\n+        bytecodesBufWriter.writeU1(IXOR);\n@@ -1345,1 +1632,1 @@\n-        writeBytecode(L2D);\n+        bytecodesBufWriter.writeU1(L2D);\n@@ -1351,1 +1638,1 @@\n-        writeBytecode(L2F);\n+        bytecodesBufWriter.writeU1(L2F);\n@@ -1357,1 +1644,1 @@\n-        writeBytecode(L2I);\n+        bytecodesBufWriter.writeU1(L2I);\n@@ -1363,1 +1650,1 @@\n-        writeBytecode(LADD);\n+        bytecodesBufWriter.writeU1(LADD);\n@@ -1369,1 +1656,1 @@\n-        writeBytecode(LAND);\n+        bytecodesBufWriter.writeU1(LAND);\n@@ -1375,1 +1662,1 @@\n-        writeBytecode(LCMP);\n+        bytecodesBufWriter.writeU1(LCMP);\n@@ -1381,1 +1668,1 @@\n-        writeBytecode(LCONST_0);\n+        bytecodesBufWriter.writeU1(LCONST_0);\n@@ -1387,1 +1674,1 @@\n-        writeBytecode(LCONST_1);\n+        bytecodesBufWriter.writeU1(LCONST_1);\n@@ -1399,1 +1686,1 @@\n-        writeBytecode(LDIV);\n+        bytecodesBufWriter.writeU1(LDIV);\n@@ -1405,1 +1692,5 @@\n-        writeLocalVar(BytecodeHelpers.lload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(LLOAD_0 + slot);\n+        } else {\n+            writeLocalVar(LLOAD, slot);\n+        }\n@@ -1411,1 +1702,1 @@\n-        writeBytecode(LMUL);\n+        bytecodesBufWriter.writeU1(LMUL);\n@@ -1417,1 +1708,1 @@\n-        writeBytecode(LNEG);\n+        bytecodesBufWriter.writeU1(LNEG);\n@@ -1423,1 +1714,1 @@\n-        writeBytecode(LOR);\n+        bytecodesBufWriter.writeU1(LOR);\n@@ -1429,1 +1720,7 @@\n-        writeBytecode(LREM);\n+        bytecodesBufWriter.writeU1(LREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lreturn() {\n+        bytecodesBufWriter.writeU1(LRETURN);\n@@ -1435,1 +1732,1 @@\n-        writeBytecode(LSHL);\n+        bytecodesBufWriter.writeU1(LSHL);\n@@ -1441,1 +1738,1 @@\n-        writeBytecode(LSHR);\n+        bytecodesBufWriter.writeU1(LSHR);\n@@ -1447,1 +1744,5 @@\n-        writeLocalVar(BytecodeHelpers.lstore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(LSTORE_0 + slot);\n+        } else {\n+            writeLocalVar(LSTORE, slot);\n+        }\n@@ -1453,1 +1754,1 @@\n-        writeBytecode(LSUB);\n+        bytecodesBufWriter.writeU1(LSUB);\n@@ -1459,1 +1760,1 @@\n-        writeBytecode(LUSHR);\n+        bytecodesBufWriter.writeU1(LUSHR);\n@@ -1465,1 +1766,1 @@\n-        writeBytecode(LXOR);\n+        bytecodesBufWriter.writeU1(LXOR);\n@@ -1471,1 +1772,1 @@\n-        writeBytecode(MONITORENTER);\n+        bytecodesBufWriter.writeU1(MONITORENTER);\n@@ -1477,1 +1778,1 @@\n-        writeBytecode(MONITOREXIT);\n+        bytecodesBufWriter.writeU1(MONITOREXIT);\n@@ -1504,1 +1805,1 @@\n-        writeBytecode(POP);\n+        bytecodesBufWriter.writeU1(POP);\n@@ -1510,1 +1811,1 @@\n-        writeBytecode(POP2);\n+        bytecodesBufWriter.writeU1(POP2);\n@@ -1517,1 +1818,1 @@\n-        writeArgumentConstant(SIPUSH, s);\n+        bytecodesBufWriter.writeU1U2(SIPUSH, s);\n@@ -1523,1 +1824,1 @@\n-        writeBytecode(SWAP);\n+        bytecodesBufWriter.writeU1(SWAP);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":584,"deletions":283,"binary":false,"changes":867,"status":"modified"},{"patch":"@@ -83,3 +83,1 @@\n-        buf.writeU2(flags);\n-        buf.writeIndex(name);\n-        buf.writeIndex(desc);\n+        buf.writeU2U2U2(flags, buf.cpIndex(name), buf.cpIndex(desc));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,3 +151,1 @@\n-        buf.writeU2(flags);\n-        buf.writeIndex(name);\n-        buf.writeIndex(desc);\n+        buf.writeU2U2U2(flags, buf.cpIndex(name), buf.cpIndex(desc));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+        var data = this.data;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/EntryMap.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,3 +87,3 @@\n-            buf.writeU2(flags().flagsMask());\n-            buf.writeIndex(fieldName());\n-            buf.writeIndex(fieldType());\n+            buf.writeU2U2U2(flags().flagsMask(),\n+                    buf.cpIndex(fieldName()),\n+                    buf.cpIndex(fieldType()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Objects;\n-\n@@ -55,1 +53,1 @@\n-        this.labelContext = Objects.requireNonNull(labelContext);\n+        this.labelContext = labelContext;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,3 +106,3 @@\n-            buf.writeU2(flags().flagsMask());\n-            buf.writeIndex(methodName());\n-            buf.writeIndex(methodType());\n+            buf.writeU2U2U2(flags().flagsMask(),\n+                    buf.cpIndex(methodName()),\n+                    buf.cpIndex(methodType()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Objects;\n@@ -90,1 +89,1 @@\n-            throw new ConstantPoolException(\"Bad CP index: \" + index);\n+            throw badCP(index);\n@@ -96,1 +95,1 @@\n-            throw new ConstantPoolException(\"Unusable CP index: \" + index);\n+            throw unusableCP(index);\n@@ -101,0 +100,8 @@\n+    private static ConstantPoolException badCP(int index) {\n+        return new ConstantPoolException(\"Bad CP index: \" + index);\n+    }\n+\n+    private static ConstantPoolException unusableCP(int index) {\n+        return new ConstantPoolException(\"Unusable CP index: \" + index);\n+    }\n+\n@@ -103,1 +110,0 @@\n-        Objects.requireNonNull(cls);\n@@ -168,0 +174,2 @@\n+        int parentSize = this.parentSize;\n+        var map = this.map;\n@@ -169,1 +177,1 @@\n-            map = new EntryMap(Math.max(size, 1024), .75f);\n+            this.map = map = new EntryMap(Math.max(size, 1024), .75f);\n@@ -206,0 +214,2 @@\n+        int bsmSize = this.bsmSize;\n+        var bsmMap = this.bsmMap;\n@@ -207,1 +217,1 @@\n-            bsmMap = new EntryMap(Math.max(bsmSize, 16), .75f);\n+            this.bsmMap = bsmMap = new EntryMap(Math.max(bsmSize, 16), .75f);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    private static final StackMapFrameInfo[] NO_STACK_FRAME_INFOS = new StackMapFrameInfo[0];\n+    private static final StackMapFrameInfo[] NO_STACK_FRAME_INFOS = {};\n@@ -138,2 +138,1 @@\n-                    out.writeU1(251 + diffLocalsSize);\n-                    out.writeU2(offsetDelta);\n+                    out.writeU1U2(251 + diffLocalsSize, offsetDelta);\n@@ -148,2 +147,1 @@\n-                out.writeU1(247);\n-                out.writeU2(offsetDelta);\n+                out.writeU1U2(247, offsetDelta);\n@@ -155,3 +153,1 @@\n-        out.writeU1(255);\n-        out.writeU2(offsetDelta);\n-        out.writeU2(fr.locals().size());\n+        out.writeU1U2U2(255, offsetDelta, fr.locals().size());\n@@ -171,2 +167,2 @@\n-        bw.writeU1(vti.tag());\n-        switch (vti.tag()) {\n+        int tag = vti.tag();\n+        switch (tag) {\n@@ -175,1 +171,1 @@\n-                {}\n+                bw.writeU1(tag);\n@@ -177,1 +173,1 @@\n-                bw.writeIndex(((ObjectVerificationTypeInfo)vti).className());\n+                bw.writeU1U2(tag, bw.cpIndex(((ObjectVerificationTypeInfo)vti).className()));\n@@ -179,1 +175,1 @@\n-                bw.writeU2(bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n+                bw.writeU1U2(tag, bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n@@ -166,1 +167,1 @@\n-    private static final Frame[] EMPTY_FRAME_ARRAY = new Frame[0];\n+    private static final Frame[] EMPTY_FRAME_ARRAY = {};\n@@ -352,0 +353,1 @@\n+            var labelContext = this.labelContext;\n@@ -393,3 +395,4 @@\n-                b.writeU2(framesCount);\n-                Frame prevFrame =  new Frame(classHierarchy);\n-                prevFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n+                var gen = StackMapGenerator.this;\n+                b.writeU2(gen.framesCount);\n+                Frame prevFrame = gen.new Frame(gen.classHierarchy);\n+                prevFrame.setLocalsFromArg(gen.methodName, gen.methodDesc, gen.isStatic, gen.thisType);\n@@ -397,2 +400,2 @@\n-                for (int i = 0; i < framesCount; i++) {\n-                    var fr = frames[i];\n+                for (int i = 0; i < gen.framesCount; i++) {\n+                    var fr = gen.frames[i];\n@@ -400,1 +403,1 @@\n-                    fr.writeTo(b, prevFrame, cp);\n+                    fr.writeTo(b, prevFrame, gen.cp);\n@@ -463,0 +466,1 @@\n+        var currentFrame = this.currentFrame;\n@@ -503,1 +507,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -505,1 +509,1 @@\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -507,1 +511,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -509,1 +513,1 @@\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -511,1 +515,1 @@\n-                currentFrame.pushStack((type1 = currentFrame.decStack(1).popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n+                currentFrame.pushStack((type1 = currentFrame.decStack().popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n@@ -513,1 +517,1 @@\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n@@ -515,1 +519,1 @@\n-                currentFrame.decStack(1).setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n@@ -521,1 +525,1 @@\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n@@ -523,1 +527,1 @@\n-                currentFrame.decStack(1).setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n@@ -537,1 +541,1 @@\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n@@ -541,36 +545,13 @@\n-                currentFrame.pushStack(type1 = currentFrame.popStack()).pushStack(type1);\n-            case DUP_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                type4 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type4).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case SWAP -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1);\n-                currentFrame.pushStack(type2);\n-            }\n+                currentFrame.dup();\n+            case DUP_X1 ->\n+                currentFrame.dup_x1();\n+            case DUP_X2 ->\n+                currentFrame.dup_x2();\n+            case DUP2 ->\n+                currentFrame.dup2();\n+            case DUP2_X1 ->\n+                currentFrame.dup2_x1();\n+            case DUP2_X2 ->\n+                currentFrame.dup2_x2();\n+            case SWAP ->\n+                currentFrame.swap();\n@@ -578,1 +559,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -580,1 +561,1 @@\n-                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack1PushStack(Type.INTEGER_TYPE);\n@@ -582,1 +563,1 @@\n-                currentFrame.decStack(4).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack4PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -584,1 +565,1 @@\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -586,1 +567,1 @@\n-                currentFrame.decStack(3).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack3PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -588,1 +569,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -590,1 +571,1 @@\n-                currentFrame.decStack(1).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack1PushStack(Type.FLOAT_TYPE);\n@@ -592,1 +573,1 @@\n-                currentFrame.decStack(4).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack4PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -594,1 +575,1 @@\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -598,1 +579,1 @@\n-                currentFrame.decStack(1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack1PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -600,1 +581,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -602,1 +583,1 @@\n-                currentFrame.decStack(1).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack1PushStack(Type.FLOAT_TYPE);\n@@ -604,1 +585,1 @@\n-                currentFrame.decStack(1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack1PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -606,1 +587,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -608,1 +589,1 @@\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -610,1 +591,1 @@\n-                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack1PushStack(Type.INTEGER_TYPE);\n@@ -612,1 +593,1 @@\n-                currentFrame.decStack(1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack1PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -614,1 +595,1 @@\n-                currentFrame.decStack(1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack1PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -616,1 +597,1 @@\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -618,1 +599,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -620,1 +601,1 @@\n-                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack1PushStack(Type.INTEGER_TYPE);\n@@ -622,1 +603,1 @@\n-                currentFrame.decStack(4).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack4PushStack(Type.INTEGER_TYPE);\n@@ -624,1 +605,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -628,1 +609,1 @@\n-                checkJumpTarget(currentFrame.decStack(1), bcs.dest());\n+                checkJumpTarget(currentFrame.decStack(), bcs.dest());\n@@ -646,1 +627,1 @@\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n@@ -656,1 +637,1 @@\n-                currentFrame.decStack(1).pushStack(getNewarrayType(bcs.getIndex()));\n+                currentFrame.decStack1PushStack(getNewarrayType(bcs.getIndex()));\n@@ -660,1 +641,1 @@\n-                currentFrame.decStack(1).pushStack(cpIndexToType(bcs.getIndexU2(), cp));\n+                currentFrame.decStack1PushStack(cpIndexToType(bcs.getIndexU2(), cp));\n@@ -663,4 +644,3 @@\n-                int dim = bcs.getU1Unchecked(bcs.bci() + 3);\n-                for (int i = 0; i < dim; i++) {\n-                    currentFrame.popStack();\n-                }\n+                currentFrame.decStack(\n+                        bcs.getU1Unchecked(bcs.bci() + 3) \/* dim *\/\n+                );\n@@ -681,0 +661,1 @@\n+        var currentFrame = this.currentFrame;\n@@ -693,1 +674,4 @@\n-        switch (cp.entryByIndex(index).tag()) {\n+        var e = cp.entryByIndex(index);\n+        byte tag = e.tag();\n+        var currentFrame = this.currentFrame;\n+        switch (tag) {\n@@ -713,1 +697,1 @@\n-                currentFrame.pushStack(cp.entryByIndex(index, ConstantDynamicEntry.class).asSymbol().constantType());\n+                currentFrame.pushStack(ClassReaderImpl.checkType(e, index, ConstantDynamicEntry.class).asSymbol().constantType());\n@@ -715,1 +699,1 @@\n-                throw generatorError(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n+                throw generatorError(\"CP entry #%d %s is not loadable constant\".formatted(index, tag));\n@@ -724,1 +708,1 @@\n-        currentFrame.popStack();\n+        currentFrame.decStack();\n@@ -768,2 +752,1 @@\n-                currentFrame.decStack(1);\n-                currentFrame.pushStack(desc);\n+                currentFrame.dec1PushStack(desc);\n@@ -807,1 +790,1 @@\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n@@ -820,1 +803,1 @@\n-        currentFrame.popStack();\n+        currentFrame.decStack();\n@@ -824,0 +807,7 @@\n+    \/**\n+     * {@return the generator error with stack underflow}\n+     *\/\n+    private IllegalArgumentException stackUnderflow() {\n+        return generatorError(\"Operand stack underflow\");\n+    }\n+\n@@ -903,0 +893,1 @@\n+\n@@ -971,0 +962,95 @@\n+        Frame dup() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 1) throw stackUnderflow();\n+            checkStack(stackSize + 1);\n+            stack[stackSize] = stack[stackSize - 1];\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame dup_x1() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 2) throw stackUnderflow();\n+            checkStack(stackSize + 1);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 2];\n+            Type type1 = stack[stackSize - 1];\n+            stack[stackSize - 2] = type1;\n+            stack[stackSize - 1] = type0;\n+            stack[stackSize    ] = type1;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame dup_x2() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 3) throw stackUnderflow();\n+            checkStack(stackSize + 1);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 3];\n+            Type type1 = stack[stackSize - 2];\n+            Type type2 = stack[stackSize - 1];\n+            stack[stackSize - 3] = type2;\n+            stack[stackSize - 2] = type0;\n+            stack[stackSize - 1] = type1;\n+            stack[stackSize    ] = type2;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame dup2() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 2) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            stack[stackSize    ] = stack[stackSize - 2];\n+            stack[stackSize + 1] = stack[stackSize - 1];\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame dup2_x1() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 3) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 3];\n+            Type type1 = stack[stackSize - 2];\n+            Type type2 = stack[stackSize - 1];\n+            stack[stackSize - 3] = type1;\n+            stack[stackSize - 2] = type2;\n+            stack[stackSize - 1] = type0;\n+            stack[stackSize    ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame dup2_x2() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 4) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 4];\n+            Type type1 = stack[stackSize - 3];\n+            Type type2 = stack[stackSize - 2];\n+            Type type3 = stack[stackSize - 1];\n+            stack[stackSize - 4] = type2;\n+            stack[stackSize - 3] = type3;\n+            stack[stackSize - 2] = type0;\n+            stack[stackSize - 1] = type1;\n+            stack[stackSize    ] = type2;\n+            stack[stackSize + 1] = type3;\n+            this.stackSize = stackSize + 4;\n+            return this;\n+        }\n+\n+        Frame swap() {\n+            int stackSize = this.stackSize - 2;\n+            if (stackSize < 0) throw stackUnderflow();\n+            var stack = this.stack;\n+            Type type = stack[stackSize];\n+            stack[stackSize] = stack[stackSize + 1];\n+            stack[stackSize + 1] = type;\n+            return this;\n+        }\n+\n@@ -972,14 +1058,17 @@\n-            return switch (desc.descriptorString().charAt(0)) {\n-                case 'J' ->\n-                    pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n-                case 'D' ->\n-                    pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-                case 'I', 'Z', 'B', 'C', 'S' ->\n-                    pushStack(Type.INTEGER_TYPE);\n-                case 'F' ->\n-                    pushStack(Type.FLOAT_TYPE);\n-                case 'V' ->\n-                    this;\n-                default ->\n-                    pushStack(Type.referenceType(desc));\n-            };\n+            if (desc == CD_long)   return pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            if (desc == CD_double) return pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            return desc == CD_void ? this\n+                    : pushStack(\n+                    desc instanceof PrimitiveClassDescImpl\n+                            ? (desc == CD_float ? Type.FLOAT_TYPE : Type.INTEGER_TYPE)\n+                            : Type.referenceType(desc));\n+        }\n+\n+        Frame dec1PushStack(ClassDesc desc) {\n+            if (desc == CD_long)   return decStack1PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            if (desc == CD_double) return decStack1PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            return desc == CD_void ? this\n+                    : decStack1PushStack(\n+                    desc instanceof PrimitiveClassDescImpl\n+                            ? (desc == CD_float ? Type.FLOAT_TYPE : Type.INTEGER_TYPE)\n+                            : Type.referenceType(desc));\n@@ -989,0 +1078,1 @@\n+            int stackSize = this.stackSize;\n@@ -990,1 +1080,2 @@\n-            stack[stackSize++] = type;\n+            stack[stackSize] = type;\n+            this.stackSize = stackSize + 1;\n@@ -995,0 +1086,1 @@\n+            int stackSize = this.stackSize;\n@@ -996,2 +1088,3 @@\n-            stack[stackSize++] = type1;\n-            stack[stackSize++] = type2;\n+            stack[stackSize] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n@@ -1002,2 +1095,9 @@\n-            if (stackSize < 1) throw generatorError(\"Operand stack underflow\");\n-            return stack[--stackSize];\n+            int stackSize = this.stackSize - 1;\n+            if (stackSize < 0) throw stackUnderflow();\n+            this.stackSize = stackSize;\n+            return stack[stackSize];\n+        }\n+\n+        Frame decStack() {\n+            if (--stackSize < 0) throw stackUnderflow();\n+            return this;\n@@ -1008,1 +1108,62 @@\n-            if (stackSize < 0) throw generatorError(\"Operand stack underflow\");\n+            if (stackSize < 0) throw stackUnderflow();\n+            return this;\n+        }\n+\n+        Frame decStack1PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 1;\n+            if (stackSize < 0) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            stack[stackSize    ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame decStack1PushStack(Type type) {\n+            int stackSize = this.stackSize - 1;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize] = type;\n+            return this;\n+        }\n+\n+        Frame decStack2PushStack(Type type) {\n+            int stackSize = this.stackSize - 2;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize] = type;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame decStack2PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 2;\n+            if (stackSize < 0) throw stackUnderflow();\n+            var stack = this.stack;\n+            stack[stackSize   ] = type1;\n+            stack[stackSize + 1] = type2;\n+            return this;\n+        }\n+\n+        Frame decStack3PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 3;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize   ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame decStack4PushStack(Type type) {\n+            int stackSize = this.stackSize - 4;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize] = type;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame decStack4PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 4;\n+            if (stackSize < 0) throw stackUnderflow();\n+            var stack = this.stack;\n+            stack[stackSize   ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n@@ -1037,2 +1198,1 @@\n-                locals = new Type[index + FRAME_DEFAULT_CAPACITY];\n-                Arrays.fill(locals, Type.TOP_TYPE);\n+                initLocals(index);\n@@ -1040,3 +1200,1 @@\n-                int current = locals.length;\n-                locals = Arrays.copyOf(locals, index + FRAME_DEFAULT_CAPACITY);\n-                Arrays.fill(locals, current, locals.length, Type.TOP_TYPE);\n+                growLocals(index);\n@@ -1047,0 +1205,11 @@\n+        private void initLocals(int index) {\n+            locals = new Type[index + FRAME_DEFAULT_CAPACITY];\n+            Arrays.fill(locals, Type.TOP_TYPE);\n+        }\n+\n+        private void growLocals(int index) {\n+            int current = locals.length;\n+            locals = Arrays.copyOf(locals, index + FRAME_DEFAULT_CAPACITY);\n+            Arrays.fill(locals, current, locals.length, Type.TOP_TYPE);\n+        }\n+\n@@ -1050,2 +1219,1 @@\n-                stack = new Type[index + FRAME_DEFAULT_CAPACITY];\n-                Arrays.fill(stack, Type.TOP_TYPE);\n+                initStack(index);\n@@ -1053,3 +1221,1 @@\n-                int current = stack.length;\n-                stack = Arrays.copyOf(stack, index + FRAME_DEFAULT_CAPACITY);\n-                Arrays.fill(stack, current, stack.length, Type.TOP_TYPE);\n+                growStack(index);\n@@ -1059,0 +1225,11 @@\n+        private void initStack(int index) {\n+            stack = new Type[index + FRAME_DEFAULT_CAPACITY];\n+            Arrays.fill(stack, Type.TOP_TYPE);\n+        }\n+\n+        private void growStack(int index) {\n+            int current = stack.length;\n+            stack = Arrays.copyOf(stack, index + FRAME_DEFAULT_CAPACITY);\n+            Arrays.fill(stack, current, stack.length, Type.TOP_TYPE);\n+        }\n+\n@@ -1061,0 +1238,1 @@\n+            var locals = this.locals;\n@@ -1065,0 +1243,8 @@\n+        private void setLocalRawInternal(int index, Type type1, Type type2) {\n+            checkLocal(index + 1);\n+            var locals = this.locals;\n+            localsChanged |= !type1.equals(locals[index]) || !type2.equals(locals[index + 1]);\n+            locals[index    ] = type1;\n+            locals[index + 1] = type2;\n+        }\n+\n@@ -1165,2 +1351,1 @@\n-            }\n-            if (old == Type.DOUBLE2_TYPE || old == Type.LONG2_TYPE) {\n+            } else if (old == Type.DOUBLE2_TYPE || old == Type.LONG2_TYPE) {\n@@ -1184,2 +1369,1 @@\n-            setLocalRawInternal(index, type1);\n-            setLocalRawInternal(index + 1, type2);\n+            setLocalRawInternal(index, type1, type2);\n@@ -1206,1 +1390,4 @@\n-                    types[compressed++] = types[i];\n+                    if (compressed != i) {\n+                        types[compressed] = types[i];\n+                    }\n+                    compressed++;\n@@ -1222,1 +1409,3 @@\n-        void writeTo(BufWriter out, Frame prevFrame, ConstantPoolBuilder cp) {\n+        void writeTo(BufWriterImpl out, Frame prevFrame, ConstantPoolBuilder cp) {\n+            int localsSize = this.localsSize;\n+            int stackSize = this.stackSize;\n@@ -1231,2 +1420,1 @@\n-                        out.writeU1(251 + diffLocalsSize);\n-                        out.writeU2(offsetDelta);\n+                        out.writeU1U2(251 + diffLocalsSize, offsetDelta);\n@@ -1241,2 +1429,1 @@\n-                    out.writeU1(247);\n-                    out.writeU2(offsetDelta);\n+                    out.writeU1U2(247, offsetDelta);\n@@ -1248,3 +1435,1 @@\n-            out.writeU1(255);\n-            out.writeU2(offsetDelta);\n-            out.writeU2(localsSize);\n+            out.writeU1U2U2(255, offsetDelta, localsSize);\n@@ -1417,2 +1602,1 @@\n-        void writeTo(BufWriter bw, ConstantPoolBuilder cp) {\n-            bw.writeU1(tag);\n+        void writeTo(BufWriterImpl bw, ConstantPoolBuilder cp) {\n@@ -1421,1 +1605,1 @@\n-                    bw.writeU2(cp.classEntry(sym).index());\n+                    bw.writeU1U2(tag, cp.classEntry(sym).index());\n@@ -1423,1 +1607,3 @@\n-                    bw.writeU2(bci);\n+                    bw.writeU1U2(tag, bci);\n+                default ->\n+                    bw.writeU1(tag);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":325,"deletions":139,"binary":false,"changes":464,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-    private static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n+    public static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n@@ -255,2 +255,1 @@\n-    static void writeList(BufWriterImpl buf, List<Writable> list) {\n-        int size = list.size();\n+    static void writeList(BufWriterImpl buf, Writable[] array, int size) {\n@@ -259,1 +258,1 @@\n-            list.get(i).writeTo(buf);\n+            array[i].writeTo(buf);\n@@ -291,2 +290,1 @@\n-                                    b.writeU2(-1);\/\/max stack\n-                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeU2U2(-1, -1);\/\/max stack & locals\n@@ -295,2 +293,1 @@\n-                                    b.writeU2(0);\/\/exception handlers\n-                                    b.writeU2(0);\/\/attributes\n+                                    b.writeU2U2(0, 0);\/\/exception handlers & attributes\n@@ -404,0 +401,1 @@\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n@@ -414,1 +412,1 @@\n-        return digit == 0 ? 1 : powers[powersIndex(digit, index)];\n+        return digit == 0 ? 1 : powers[powersIndex(digit, index) & 0x3F]; \/\/ & 0x3F eliminates bound check\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -290,7 +290,24 @@\n-        int len = 2 + returnType.descriptorString().length();\n-        for (ClassDesc argType : argTypes) {\n-            len += argType.descriptorString().length();\n-        }\n-        StringBuilder sb = new StringBuilder(len).append('(');\n-        for (ClassDesc argType : argTypes) {\n-            sb.append(argType.descriptorString());\n+        return buildDescriptorString();\n+    }\n+\n+    private String buildDescriptorString() {\n+        var returnType = this.returnType;\n+        var returnTypeDesc = returnType.descriptorString();\n+        var argTypes = this.argTypes;\n+        String desc;\n+        if (argTypes.length == 0) {\n+            \/\/ getter\n+            desc = \"()\".concat(returnTypeDesc);\n+        } else if (argTypes.length == 1 && returnType == ConstantDescs.CD_void) {\n+            \/\/ setter\n+            desc = ConstantUtils.concat(\"(\", argTypes[0].descriptorString(), \")V\");\n+        } else {\n+            int len = 2 + returnTypeDesc.length();\n+            for (ClassDesc argType : argTypes) {\n+                len += argType.descriptorString().length();\n+            }\n+            StringBuilder sb = new StringBuilder(len).append('(');\n+            for (ClassDesc argType : argTypes) {\n+                sb.append(argType.descriptorString());\n+            }\n+            desc = sb.append(')').append(returnTypeDesc).toString();\n@@ -298,1 +315,0 @@\n-        desc = sb.append(')').append(returnType.descriptorString()).toString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -196,5 +196,4 @@\n-            clb.withFlags(ACC_PUBLIC + ACC_FINAL + ACC_SUPER);\n-            clb.withSuperclass(CD_Object);\n-            clb.withVersion(CLASSFILE_VERSION, 0);\n-\n-            clb.withMethodBody(METHOD_NAME, methodTypeDesc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n+            clb.withFlags(ACC_PUBLIC + ACC_FINAL + ACC_SUPER)\n+               .withSuperclass(CD_Object)\n+               .withVersion(CLASSFILE_VERSION, 0)\n+               .withMethodBody(METHOD_NAME, methodTypeDesc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n@@ -278,2 +277,2 @@\n-                    cb.loadConstant(null);\n-                    cb.storeLocal(REFERENCE, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                    cb.aconst_null()\n+                      .astore(scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n@@ -288,2 +287,2 @@\n-            cb.loadConstant(callingSequence.allocationSize());\n-            cb.invokestatic(CD_SharedUtils, \"newBoundedArena\", MTD_NEW_BOUNDED_ARENA);\n+            cb.loadConstant(callingSequence.allocationSize())\n+              .invokestatic(CD_SharedUtils, \"newBoundedArena\", MTD_NEW_BOUNDED_ARENA);\n@@ -296,1 +295,1 @@\n-        cb.storeLocal(REFERENCE, contextIdx);\n+        cb.astore(contextIdx);\n@@ -304,1 +303,1 @@\n-            cb.storeLocal(REFERENCE, returnBufferIdx);\n+            cb.astore(returnBufferIdx);\n@@ -327,1 +326,1 @@\n-                    cb.loadLocal(REFERENCE, returnBufferIdx);\n+                    cb.aload(returnBufferIdx);\n@@ -343,1 +342,1 @@\n-                    cb.storeLocal(REFERENCE, returnBufferIdx);\n+                    cb.astore(returnBufferIdx);\n@@ -358,1 +357,1 @@\n-            cb.loadLocal(REFERENCE, 0); \/\/ load target arg\n+            cb.aload(0); \/\/ load target arg\n@@ -499,2 +498,2 @@\n-        cb.checkcast(CD_AbstractMemorySegmentImpl);\n-        cb.invokevirtual(CD_AbstractMemorySegmentImpl, \"sessionImpl\", MTD_SESSION_IMPL);\n+        cb.checkcast(CD_AbstractMemorySegmentImpl)\n+          .invokevirtual(CD_AbstractMemorySegmentImpl, \"sessionImpl\", MTD_SESSION_IMPL);\n@@ -508,3 +507,3 @@\n-            cb.dup(); \/\/ dup for comparison\n-            cb.loadLocal(REFERENCE, scopeSlots[i]);\n-            cb.if_acmpeq(skipAcquire);\n+            cb.dup() \/\/ dup for comparison\n+              .aload(scopeSlots[i])\n+              .if_acmpeq(skipAcquire);\n@@ -517,2 +516,2 @@\n-        cb.invokevirtual(CD_MemorySessionImpl, \"acquire0\", MTD_ACQUIRE0); \/\/ call acquire on the other\n-        cb.storeLocal(REFERENCE, nextScopeLocal); \/\/ store off one to release later\n+        cb.invokevirtual(CD_MemorySessionImpl, \"acquire0\", MTD_ACQUIRE0) \/\/ call acquire on the other\n+          .astore(nextScopeLocal); \/\/ store off one to release later\n@@ -521,4 +520,3 @@\n-            cb.goto_(end);\n-\n-            cb.labelBinding(skipAcquire);\n-            cb.pop(); \/\/ drop scope\n+            cb.goto_(end)\n+              .labelBinding(skipAcquire)\n+              .pop(); \/\/ drop scope\n@@ -532,4 +530,4 @@\n-            cb.loadLocal(REFERENCE, scopeLocal);\n-            cb.ifThen(Opcode.IFNONNULL, ifCb -> {\n-                ifCb.loadLocal(REFERENCE, scopeLocal);\n-                ifCb.invokevirtual(CD_MemorySessionImpl, \"release0\", MTD_RELEASE0);\n+            cb.aload(scopeLocal)\n+              .ifThen(Opcode.IFNONNULL, ifCb -> {\n+                ifCb.aload(scopeLocal)\n+                    .invokevirtual(CD_MemorySessionImpl, \"release0\", MTD_RELEASE0);\n@@ -554,4 +552,4 @@\n-        cb.loadLocal(REFERENCE, contextIdx);\n-        cb.checkcast(CD_Arena);\n-        cb.invokeinterface(CD_Arena, \"scope\", MTD_SCOPE);\n-        cb.checkcast(CD_MemorySessionImpl);\n+        cb.aload(contextIdx)\n+          .checkcast(CD_Arena)\n+          .invokeinterface(CD_Arena, \"scope\", MTD_SCOPE)\n+          .checkcast(CD_MemorySessionImpl);\n@@ -562,1 +560,1 @@\n-        cb.loadLocal(REFERENCE, contextIdx);\n+        cb.aload(contextIdx);\n@@ -567,3 +565,3 @@\n-        cb.loadLocal(REFERENCE, contextIdx);\n-        cb.checkcast(CD_Arena);\n-        cb.invokeinterface(CD_Arena, \"close\", MTD_CLOSE);\n+        cb.aload(contextIdx)\n+          .checkcast(CD_Arena)\n+          .invokeinterface(CD_Arena, \"close\", MTD_CLOSE);\n@@ -574,2 +572,2 @@\n-        cb.loadConstant(boxAddress.size());\n-        cb.loadConstant(boxAddress.align());\n+        cb.loadConstant(boxAddress.size())\n+          .loadConstant(boxAddress.align());\n@@ -588,1 +586,1 @@\n-            cb.loadLocal(REFERENCE, returnAllocatorIdx);\n+            cb.aload(returnAllocatorIdx);\n@@ -610,2 +608,2 @@\n-            cb.loadConstant(offset);\n-            cb.loadLocal(storeTypeKind, valueIdx);\n+            cb.loadConstant(offset)\n+              .loadLocal(storeTypeKind, valueIdx);\n@@ -622,1 +620,1 @@\n-            cb.storeLocal(LONG, longValueIdx);\n+            cb.lstore(longValueIdx);\n@@ -624,1 +622,1 @@\n-            cb.storeLocal(REFERENCE, writeAddrIdx);\n+            cb.astore(writeAddrIdx);\n@@ -651,3 +649,3 @@\n-                cb.loadLocal(LONG, longValueIdx);\n-                cb.loadConstant(mask);\n-                cb.land();\n+                cb.lload(longValueIdx)\n+                  .loadConstant(mask)\n+                  .land();\n@@ -655,2 +653,2 @@\n-                    cb.loadConstant(shiftAmount);\n-                    cb.lushr();\n+                    cb.loadConstant(shiftAmount)\n+                      .lushr();\n@@ -661,1 +659,1 @@\n-                cb.storeLocal(chunkStoreTypeKind, chunkIdx);\n+                cb.storeLocal(chunkStoreTypeKind, chunkIdx)\n@@ -665,1 +663,1 @@\n-                cb.loadLocal(REFERENCE, writeAddrIdx);\n+                  .aload(writeAddrIdx);\n@@ -668,2 +666,2 @@\n-                cb.loadConstant(writeOffset);\n-                cb.loadLocal(chunkStoreTypeKind, chunkIdx);\n+                cb.loadConstant(writeOffset)\n+                  .loadLocal(chunkStoreTypeKind, chunkIdx);\n@@ -693,3 +691,0 @@\n-                int valueIdx = cb.allocateLocal(storeTypeKind);\n-                cb.storeLocal(storeTypeKind, valueIdx); \/\/ store away the stored value, need it later\n-\n@@ -697,1 +692,3 @@\n-                cb.loadLocal(REFERENCE, returnBufferIdx);\n+                int valueIdx = cb.allocateLocal(storeTypeKind);\n+                cb.storeLocal(storeTypeKind, valueIdx) \/\/ store away the stored value, need it later\n+                  .aload(returnBufferIdx);\n@@ -699,4 +696,5 @@\n-                cb.loadConstant(retBufOffset);\n-                cb.loadLocal(storeTypeKind, valueIdx);\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(storeType));\n-                cb.invokeinterface(CD_MemorySegment, \"set\", descriptor);\n+                cb.loadConstant(retBufOffset)\n+                  .loadLocal(storeTypeKind, valueIdx)\n+                  .invokeinterface(CD_MemorySegment,\n+                        \"set\",\n+                        MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(storeType)));\n@@ -717,1 +715,1 @@\n-                cb.loadLocal(REFERENCE, returnBufferIdx);\n+                cb.aload(returnBufferIdx);\n@@ -719,3 +717,4 @@\n-                cb.loadConstant(retBufOffset);\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long);\n-                cb.invokeinterface(CD_MemorySegment, \"get\", descriptor);\n+                cb.loadConstant(retBufOffset)\n+                  .invokeinterface(CD_MemorySegment,\n+                          \"get\",\n+                          MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long));\n@@ -739,2 +738,2 @@\n-        cb.loadConstant(shiftLeft.shiftAmount() * Byte.SIZE);\n-        cb.lshl();\n+        cb.loadConstant(shiftLeft.shiftAmount() * Byte.SIZE)\n+          .lshl();\n@@ -746,2 +745,2 @@\n-        cb.loadConstant(shiftRight.shiftAmount() * Byte.SIZE);\n-        cb.lushr();\n+        cb.loadConstant(shiftRight.shiftAmount() * Byte.SIZE)\n+          .lushr();\n@@ -761,5 +760,4 @@\n-                cb.loadConstant(0xFF);\n-                cb.iand();\n-\n-                \/\/ convert to boolean\n-                cb.invokestatic(CD_Utils, \"byteToBoolean\", MTD_BYTE_TO_BOOLEAN);\n+                cb.loadConstant(0xFF)\n+                  .iand()\n+                  \/\/ convert to boolean\n+                  .invokestatic(CD_Utils, \"byteToBoolean\", MTD_BYTE_TO_BOOLEAN);\n@@ -785,2 +783,2 @@\n-        cb.checkcast(CD_AbstractMemorySegmentImpl);\n-        cb.invokevirtual(CD_AbstractMemorySegmentImpl, \"unsafeGetBase\", MTD_UNSAFE_GET_BASE);\n+        cb.checkcast(CD_AbstractMemorySegmentImpl)\n+          .invokevirtual(CD_AbstractMemorySegmentImpl, \"unsafeGetBase\", MTD_UNSAFE_GET_BASE);\n@@ -794,2 +792,2 @@\n-            cb.dup();\n-            cb.invokestatic(CD_SharedUtils, \"checkNative\", MTD_CHECK_NATIVE);\n+            cb.dup()\n+              .invokestatic(CD_SharedUtils, \"checkNative\", MTD_CHECK_NATIVE);\n@@ -797,2 +795,2 @@\n-        cb.checkcast(CD_AbstractMemorySegmentImpl);\n-        cb.invokevirtual(CD_AbstractMemorySegmentImpl, \"unsafeGetOffset\", MTD_UNSAFE_GET_OFFSET);\n+        cb.checkcast(CD_AbstractMemorySegmentImpl)\n+          .invokevirtual(CD_AbstractMemorySegmentImpl, \"unsafeGetOffset\", MTD_UNSAFE_GET_OFFSET);\n@@ -812,3 +810,4 @@\n-            cb.loadConstant(offset);\n-            MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long);\n-            cb.invokeinterface(CD_MemorySegment, \"get\", descriptor);\n+            cb.loadConstant(offset)\n+              .invokeinterface(CD_MemorySegment,\n+                      \"get\",\n+                      MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long));\n@@ -818,3 +817,2 @@\n-            cb.storeLocal(REFERENCE, readAddrIdx);\n-\n-            cb.loadConstant(0L); \/\/ result\n+            cb.astore(readAddrIdx)\n+              .loadConstant(0L); \/\/ result\n@@ -822,1 +820,1 @@\n-            cb.storeLocal(LONG, resultIdx);\n+            cb.lstore(resultIdx);\n@@ -851,1 +849,1 @@\n-                cb.loadLocal(REFERENCE, readAddrIdx);\n+                cb.aload(readAddrIdx);\n@@ -855,3 +853,3 @@\n-                cb.loadConstant(readOffset);\n-                cb.invokeinterface(CD_MemorySegment, \"get\", descriptor);\n-                cb.invokestatic(toULongHolder, \"toUnsignedLong\", toULongDescriptor);\n+                cb.loadConstant(readOffset)\n+                  .invokeinterface(CD_MemorySegment, \"get\", descriptor)\n+                  .invokestatic(toULongHolder, \"toUnsignedLong\", toULongDescriptor);\n@@ -862,2 +860,2 @@\n-                    cb.loadConstant(shiftAmount);\n-                    cb.lshl();\n+                    cb.loadConstant(shiftAmount)\n+                      .lshl();\n@@ -866,3 +864,3 @@\n-                cb.loadLocal(LONG, resultIdx);\n-                cb.lor();\n-                cb.storeLocal(LONG, resultIdx);\n+                cb.lload(resultIdx)\n+                  .lor()\n+                  .lstore(resultIdx);\n@@ -874,1 +872,1 @@\n-            cb.loadLocal(LONG, resultIdx);\n+            cb.lload(resultIdx);\n@@ -901,6 +899,5 @@\n-        cb.storeLocal(REFERENCE, storeIdx);\n-        cb.loadConstant(0L);\n-        cb.loadConstant(size);\n-        cb.invokestatic(CD_MemorySegment, \"copy\", MTD_COPY, true);\n-\n-        cb.loadLocal(REFERENCE, storeIdx);\n+        cb.astore(storeIdx)\n+          .loadConstant(0L)\n+          .loadConstant(size)\n+          .invokestatic(CD_MemorySegment, \"copy\", MTD_COPY, true)\n+          .aload(storeIdx);\n@@ -911,3 +908,3 @@\n-        cb.loadConstant(size);\n-        cb.loadConstant(alignment);\n-        cb.invokeinterface(CD_SegmentAllocator, \"allocate\", MTD_ALLOCATE);\n+        cb.loadConstant(size)\n+          .loadConstant(alignment)\n+          .invokeinterface(CD_SegmentAllocator, \"allocate\", MTD_ALLOCATE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":103,"deletions":106,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs;\n+\n+import sun.security.util.DerInputStream;\n+import sun.security.util.DerValue;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.security.auth.DestroyFailedException;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+\n+\/\/\/ Represents a private key from an algorithm family that is specialized\n+\/\/\/ with a named parameter set.\n+\/\/\/\n+\/\/\/ This key is generated by either a [sun.security.provider.NamedKeyPairGenerator]\n+\/\/\/ or [sun.security.provider.NamedKeyFactory]. Its [#getAlgorithm] method\n+\/\/\/ returns the algorithm family name, while its [#getParams()] method returns\n+\/\/\/ the parameter set name as a [NamedParameterSpec] object. The algorithm\n+\/\/\/ identifier in the PKCS #8 encoding of the key is always a single OID derived\n+\/\/\/ from the parameter set name.\n+\/\/\/\n+\/\/\/ @see sun.security.provider.NamedKeyPairGenerator\n+public final class NamedPKCS8Key extends PKCS8Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] rawBytes;\n+\n+    private transient boolean destroyed = false;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.rawBytes = rawBytes;\n+\n+        DerValue val = new DerValue(DerValue.tag_OctetString, rawBytes);\n+        try {\n+            this.key = val.toByteArray();\n+        } finally {\n+            val.clear();\n+        }\n+    }\n+\n+    \/\/\/ Ctor from family name, and PKCS #8 bytes\n+    public NamedPKCS8Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        super(encoded);\n+        this.fname = fname;\n+        try {\n+            paramSpec = new NamedParameterSpec(algid.getName());\n+            if (algid.getEncodedParams() != null) {\n+                throw new InvalidKeyException(\"algorithm identifier has params\");\n+            }\n+            rawBytes = new DerInputStream(key).getOctetString();\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Cannot parse input\", e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" private key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return rawBytes;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedPKCS8Key keys are not directly deserializable\");\n+    }\n+\n+    @Override\n+    public void destroy() throws DestroyFailedException {\n+        Arrays.fill(rawBytes, (byte)0);\n+        Arrays.fill(key, (byte)0);\n+        if (encodedKey != null) {\n+            Arrays.fill(encodedKey, (byte)0);\n+        }\n+        destroyed = true;\n+    }\n+\n+    @Override\n+    public boolean isDestroyed() {\n+        return destroyed;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `KEM` implementations that can be\n+\/\/\/ configured with a named parameter set. See [NamedKeyPairGenerator]\n+\/\/\/ for more details.\n+public abstract class NamedKEM implements KEMSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKEM` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKEM(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"The \" + fname + \" algorithm does not take any parameters\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        var pk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), pk,\n+                implCheckPublicKey(nk.getParams().getName(), pk), secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(\n+            PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"The \" + fname + \" algorithm does not take any parameters\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        var sk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), sk,\n+                implCheckPrivateKey(nk.getParams().getName(), sk), null);\n+    }\n+\n+    \/\/ We don't have a flag on whether key is public key or private key.\n+    \/\/ The correct method should always be called.\n+    private record KeyConsumerImpl(NamedKEM kem, String name, int sslen,\n+            int clen, byte[] key, Object k2, SecureRandom sr)\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from, int to,\n+                String algorithm) throws DecapsulateException {\n+            if (encapsulation.length != clen) {\n+                throw new DecapsulateException(\"Invalid key encapsulation message length\");\n+            }\n+            var ss = kem.implDecapsulate(name, key, k2, encapsulation);\n+            try {\n+                return new SecretKeySpec(ss,\n+                        from, to - from, algorithm);\n+            } finally {\n+                Arrays.fill(ss, (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+            var enc = kem.implEncapsulate(name, key, k2, sr);\n+            try {\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(enc[1],\n+                                from, to - from, algorithm),\n+                        enc[0],\n+                        null);\n+            } finally {\n+                Arrays.fill(enc[1], (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return sslen;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return clen;\n+        }\n+    }\n+\n+    private static KeyConsumerImpl getKeyConsumerImpl(NamedKEM kem,\n+            NamedParameterSpec nps, byte[] key, Object k2, SecureRandom sr) {\n+        String name = nps.getName();\n+        return new KeyConsumerImpl(kem, name, kem.implSecretSize(name), kem.implEncapsulationSize(name),\n+                key, k2, sr);\n+    }\n+\n+    \/\/\/ User-defined encap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none. See [#implCheckPublicKey].\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the key encapsulation message and the shared key (in this order)\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract byte[][] implEncapsulate(String name, byte[] pk, Object pk2, SecureRandom sr);\n+\n+    \/\/\/ User-defined decap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none. See [#implCheckPrivateKey].\n+    \/\/\/ @param encap the key encapsulation message\n+    \/\/\/ @return the shared key\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws DecapsulateException if there is another error\n+    protected abstract byte[] implDecapsulate(String name, byte[] sk, Object sk2, byte[] encap)\n+            throws DecapsulateException;\n+\n+    \/\/\/ User-defined function returning shared secret key length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return shared secret key length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract int implSecretSize(String name);\n+\n+    \/\/\/ User-defined function returning key encapsulation message length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return key encapsulation message length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract int implEncapsulationSize(String name);\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newEncapsulator`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implEncapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newDecapsulator`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implDecapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.AsymmetricKey;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactorySpi;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.spec.EncodedKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `KeyFactory` implementations that can be\n+\/\/\/ configured with a named parameter set. See [NamedKeyPairGenerator]\n+\/\/\/ for more details.\n+\/\/\/\n+\/\/\/ This factory supports reading and writing to RAW formats:\n+\/\/\/\n+\/\/\/ 1. It reads from a RAW key using `translateKey` if `key.getFormat` is \"RAW\".\n+\/\/\/ 2. It writes to a RAW [EncodedKeySpec] if `getKeySpec(key, EncodedKeySpec.class)`\n+\/\/\/    is called. The format of the output is \"RAW\" and the algorithm is\n+\/\/\/    intentionally left unspecified.\n+\/\/\/ 3. It reads from and writes to the internal type [RawKeySpec].\n+\/\/\/\n+\/\/\/ When reading from a RAW format, it needs enough info to derive the\n+\/\/\/ parameter set name.\n+public class NamedKeyFactory extends KeyFactorySpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKeyFactory` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKeyFactory(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidKeyException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidKeyException(\"Unsupported parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof X509EncodedKeySpec xspec) {\n+            try {\n+                return fromX509(xspec.getEncoded());\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            }\n+        } else if (keySpec instanceof RawKeySpec rks) {\n+            if (pnames.length == 1) {\n+                return new NamedX509Key(fname, pnames[0], rks.getKeyArr());\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else if (keySpec instanceof EncodedKeySpec espec\n+                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n+            if (pnames.length == 1) {\n+                return new NamedX509Key(fname, pnames[0], espec.getEncoded());\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    @Override\n+    protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof PKCS8EncodedKeySpec pspec) {\n+            var bytes = pspec.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            } finally {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        } else if (keySpec instanceof RawKeySpec rks) {\n+            if (pnames.length == 1) {\n+                var bytes = rks.getKeyArr();\n+                try {\n+                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n+                } finally {\n+                    Arrays.fill(bytes, (byte) 0);\n+                }\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else if (keySpec instanceof EncodedKeySpec espec\n+                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n+            if (pnames.length == 1) {\n+                var bytes = espec.getEncoded();\n+                try {\n+                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n+                } finally {\n+                    Arrays.fill(bytes, (byte) 0);\n+                }\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    private PrivateKey fromPKCS8(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedPKCS8Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private PublicKey fromX509(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedX509Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private static class RawEncodedKeySpec extends EncodedKeySpec {\n+        public RawEncodedKeySpec(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"RAW\";\n+        }\n+    }\n+\n+    @Override\n+    protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+            throws InvalidKeySpecException {\n+        try {\n+            key = engineTranslateKey(key);\n+        } catch (InvalidKeyException e) {\n+            throw new InvalidKeySpecException(e);\n+        }\n+        \/\/ key is now either NamedPKCS8Key or NamedX509Key of permitted param set\n+        if (key instanceof NamedPKCS8Key nk) {\n+            byte[] bytes = null;\n+            try {\n+                if (keySpec == PKCS8EncodedKeySpec.class) {\n+                    return keySpec.cast(\n+                            new PKCS8EncodedKeySpec(bytes = key.getEncoded()));\n+                } else if (keySpec == RawKeySpec.class) {\n+                    return keySpec.cast(new RawKeySpec(nk.getRawBytes()));\n+                } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                    return keySpec.cast(\n+                            new RawEncodedKeySpec(nk.getRawBytes()));\n+                } else {\n+                    throw new InvalidKeySpecException(\"Unsupported type: \" + keySpec);\n+                }\n+            } finally {\n+                if (bytes != null) {\n+                    Arrays.fill(bytes, (byte)0);\n+                }\n+            }\n+        } else if (key instanceof NamedX509Key nk) {\n+            if (keySpec == X509EncodedKeySpec.class\n+                    && key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+                return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));\n+            } else if (keySpec == RawKeySpec.class) {\n+                return keySpec.cast(new RawKeySpec(nk.getRawBytes()));\n+            } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                return keySpec.cast(new RawEncodedKeySpec(nk.getRawBytes()));\n+            } else {\n+                throw new InvalidKeySpecException(\"Unsupported type: \" + keySpec);\n+            }\n+        }\n+        throw new AssertionError(\"No \" + keySpec.getName() + \" for \" + key.getClass());\n+    }\n+\n+    @Override\n+    protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Key must not be null\");\n+        }\n+        if (key instanceof NamedX509Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        if (key instanceof NamedPKCS8Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        var format = key.getFormat();\n+        if (format == null) {\n+            throw new InvalidKeyException(\"Unextractable key\");\n+        } else if (format.equalsIgnoreCase(\"RAW\")) {\n+            var kAlg = key.getAlgorithm();\n+            if (key instanceof AsymmetricKey pk) {\n+                String name;\n+                \/\/ Three cases that we can find the parameter set name from a RAW key:\n+                \/\/ 1. getParams() returns one\n+                \/\/ 2. getAlgorithm() returns param set name (some provider does this)\n+                \/\/ 3. getAlgorithm() returns family name but this KF is for param set name\n+                if (pk.getParams() instanceof NamedParameterSpec nps) {\n+                    name = checkName(nps.getName());\n+                } else {\n+                    if (kAlg.equalsIgnoreCase(fname)) {\n+                        if (pnames.length == 1) {\n+                            name = pnames[0];\n+                        } else {\n+                            throw new InvalidKeyException(\"No parameter set info\");\n+                        }\n+                    } else {\n+                        name = checkName(kAlg);\n+                    }\n+                }\n+                return key instanceof PrivateKey\n+                        ? new NamedPKCS8Key(fname, name, key.getEncoded())\n+                        : new NamedX509Key(fname, name, key.getEncoded());\n+            } else {\n+                throw new InvalidKeyException(\"Unsupported key type: \" + key.getClass());\n+            }\n+        } else if (format.equalsIgnoreCase(\"PKCS#8\") && key instanceof PrivateKey) {\n+            var bytes = key.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid PKCS#8 key\", e);\n+            } finally {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        } else if (format.equalsIgnoreCase(\"X.509\") && key instanceof PublicKey) {\n+            try {\n+                return fromX509(key.getEncoded());\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid X.509 key\", e);\n+            }\n+        } else {\n+            throw new InvalidKeyException(\"Unsupported key format: \" + key.getFormat());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGeneratorSpi;\n+import java.security.ProviderException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `KeyPairGenerator` implementations that can be\n+\/\/\/ configured with a named parameter set.\n+\/\/\/\n+\/\/\/ Together with [NamedKeyFactory], [NamedKEM], and [NamedSignature], these\n+\/\/\/ classes form a compact framework designed to support any public key\n+\/\/\/ algorithm standardized with named parameter sets. In this scenario,\n+\/\/\/ the algorithm name is the \"family name\" and each standardized parameter\n+\/\/\/ set has a \"parameter set name\". Implementations of these classes are able\n+\/\/\/ to instantiate a `KeyPairGenerator`, `KeyFactory`, or `KEM` or `Signature`\n+\/\/\/ object using either the family name or a parameter set name. All keys used\n+\/\/\/ in this context will be of the type [NamedPKCS8Key] or [NamedX509Key],\n+\/\/\/ with `getAlgorithm` returning the family name, and `getParams` returning\n+\/\/\/ the parameter set name as a [NamedParameterSpec] object.\n+\/\/\/\n+\/\/\/ An implementation must include a zero-argument public constructor that\n+\/\/\/ calls `super(fname, pnames)`, where `fname` is the family name of the\n+\/\/\/ algorithm and `pnames` are its supported parameter set names. `pnames`\n+\/\/\/ must contain at least one element. For an implementation of\n+\/\/\/ `NamedKeyPairGenerator`, the first element becomes its default parameter\n+\/\/\/ set, i.e. the parameter set to be used in key pair generation unless\n+\/\/\/ [#initialize(AlgorithmParameterSpec, java.security.SecureRandom)]\n+\/\/\/ is called on a different parameter set.\n+\/\/\/\n+\/\/\/ An implementation must implement all abstract methods. For all these\n+\/\/\/ methods, the implementation must relinquish any \"ownership\" of any input\n+\/\/\/ and output array argument. Precisely, the implementation must not retain\n+\/\/\/ any reference to a returning array so that it won't be able to modify its\n+\/\/\/ content later. Similarly, the implementation must not modify any input\n+\/\/\/ array argument and must not retain any reference to an input array argument\n+\/\/\/ after the call.\n+\/\/\/\n+\/\/\/ Also, an implementation must not keep any extra copy of a private key.\n+\/\/\/ For key generation, the only copy is the one returned in the\n+\/\/\/ [#implGenerateKeyPair] call. For all other methods, it must not make\n+\/\/\/ a copy of the input private key. A `KEM` implementation also must not\n+\/\/\/ keep a copy of the shared secret key, no matter if it's an encapsulator\n+\/\/\/ or a decapsulator. Only the code that owns these sensitive data can\n+\/\/\/ choose to perform cleanup when it determines they are no longer needed.\n+\/\/\/\n+\/\/\/ The `NamedSignature` and `NamedKEM` classes provide `implCheckPublicKey`\n+\/\/\/ and `implCheckPrivateKey` methods that allow an implementation to validate\n+\/\/\/ a key before using it. An implementation may return a parsed key in\n+\/\/\/ a local type, and this parsed key will be passed to an operational method\n+\/\/\/ (For example, `implSign`) later. An implementation must not retain\n+\/\/\/ a reference of the parsed key.\n+\/\/\/\n+\/\/\/ When constructing a [NamedX509Key] or [NamedPKCS8Key] object from raw key\n+\/\/\/ bytes, the key bytes are directly referenced within the object, so the\n+\/\/\/ caller must not modify them afterward. Similarly, the key's `getRawBytes`\n+\/\/\/ method returns direct references to the underlying raw key bytes, meaning\n+\/\/\/ the caller must not alter the contents of the returned value.\n+\/\/\/\n+\/\/\/ Together, these measures ensure the classes are as efficient as possible,\n+\/\/\/ preventing unnecessary array cloning and potential data leaks. While these\n+\/\/\/ classes should not be considered immutable, strictly adhering to the rules\n+\/\/\/ above will ensure data integrity is maintained.\n+\/\/\/\n+\/\/\/ Note: A limitation of `NamedKeyPairGenerator` and `NamedKeyFactory` is\n+\/\/\/ that the keys generated by their implementations will always be of type\n+\/\/\/ `NamedX509Key` or `NamedPKCS8Key`. Existing implementations of algorithms\n+\/\/\/ like EdDSA and XDH have been generating keys implementing `EdECKey` or\n+\/\/\/ `XECKey` interfaces, and they are not rewritten with this framework.\n+\/\/\/ `NamedParameterSpec` fields not implemented with this framework include\n+\/\/\/ Ed25519, Ed448, X25519, and X448.\n+public abstract class NamedKeyPairGenerator extends KeyPairGeneratorSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    protected String name; \/\/ init as\n+    private SecureRandom secureRandom;\n+\n+    \/\/\/ Creates a new `NamedKeyPairGenerator` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames supported parameter set names, at least one is needed.\n+    \/\/\/     If multiple, the first one becomes the default parameter set name.\n+    protected NamedKeyPairGenerator(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidAlgorithmParameterException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+                \"Unsupported parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    public void initialize(AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidAlgorithmParameterException {\n+        if (params instanceof NamedParameterSpec spec) {\n+            name = checkName(spec.getName());\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unsupported AlgorithmParameterSpec: \" + params);\n+        }\n+        this.secureRandom = random;\n+    }\n+\n+    @Override\n+    public void initialize(int keysize, SecureRandom random) {\n+        if (keysize != -1) {\n+            \/\/ User can call initialize(-1, sr) to provide a SecureRandom\n+            \/\/ without touching the parameter set currently used\n+            throw new InvalidParameterException(\"keysize not supported\");\n+        }\n+        this.secureRandom = random;\n+    }\n+\n+    @Override\n+    public KeyPair generateKeyPair() {\n+        String pname = name != null ? name : pnames[0];\n+        var keys = implGenerateKeyPair(pname, secureRandom);\n+        return new KeyPair(new NamedX509Key(fname, pname, keys[0]),\n+                new NamedPKCS8Key(fname, pname, keys[1]));\n+    }\n+\n+    \/\/\/ User-defined key pair generator.\n+    \/\/\/\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param sr `SecureRandom` object, `null` if not initialized\n+    \/\/\/ @return public key and private key (in this order) in raw bytes\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract byte[][] implGenerateKeyPair(String pname, SecureRandom sr);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidParameterException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureException;\n+import java.security.SignatureSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `Signature` implementations that can be\n+\/\/\/ configured with a named parameter set. See [NamedKeyPairGenerator]\n+\/\/\/ for more details.\n+\/\/\/\n+\/\/\/ This class does not work with preHash signatures.\n+public abstract class NamedSignature extends SignatureSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    private final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\n+    \/\/ init with...\n+    private String name;\n+    private byte[] secKey;\n+    private byte[] pubKey;\n+\n+    private Object sk2;\n+    private Object pk2;\n+\n+    \/\/\/ Creates a new `NamedSignature` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedSignature(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        name = nk.getParams().getName();\n+        pubKey = nk.getRawBytes();\n+        pk2 = implCheckPublicKey(name, pubKey);\n+        secKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        name = nk.getParams().getName();\n+        secKey = nk.getRawBytes();\n+        sk2 = implCheckPrivateKey(name, secKey);\n+        pubKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        bout.write(b);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len) throws SignatureException {\n+        bout.write(b, off, len);\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        if (secKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implSign(name, secKey, sk2, msg, appRandom);\n+        } else {\n+            throw new SignatureException(\"No private key\");\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sig) throws SignatureException {\n+        if (pubKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implVerify(name, pubKey, pk2, msg, sig);\n+        } else {\n+            throw new SignatureException(\"No public key\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"setParameter() not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param) throws InvalidParameterException {\n+        throw new InvalidParameterException(\"getParameter() not supported\");\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"The \" + fname + \" algorithm does not take any parameters\");\n+        }\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined sign function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none. See [#implCheckPrivateKey].\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the signature\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    protected abstract byte[] implSign(String name, byte[] sk, Object sk2,\n+            byte[] msg, SecureRandom sr) throws SignatureException;\n+\n+    \/\/\/ User-defined verify function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none. See [#implCheckPublicKey].\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sig the signature\n+    \/\/\/ @return true if verified\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    protected abstract boolean implVerify(String name, byte[] pk, Object pk2,\n+            byte[] msg, byte[] sig) throws SignatureException;\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initVerify`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implVerify] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initSign`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implSign] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -187,2 +187,2 @@\n-        if (key instanceof ECKey) {\n-            ECParameterSpec paramSpec = ((ECKey) key).getParams();\n+        if (key instanceof AsymmetricKey ak) {\n+            AlgorithmParameterSpec paramSpec = ak.getParams();\n@@ -191,0 +191,2 @@\n+            } else if (paramSpec instanceof NamedParameterSpec nps) {\n+                result = nps.getName();\n@@ -192,2 +194,0 @@\n-        } else if (key instanceof EdECKey) {\n-            result = ((EdECKey) key).getParams().getName();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.security.pkcs.NamedPKCS8Key;\n@@ -277,1 +278,1 @@\n-                    \"Unknown algorithm: \" + signatureAlgorithm);\n+                    \"Cannot extract digest algorithm from \" + signatureAlgorithm);\n@@ -393,2 +394,2 @@\n-            if (key instanceof EdECKey) {\n-                return AlgorithmId.get(((EdECKey) key).getParams().getName());\n+            if (key.getParams() instanceof NamedParameterSpec nps) {\n+                return AlgorithmId.get(nps.getName());\n@@ -434,0 +435,8 @@\n+        if (key instanceof NamedPKCS8Key n8k) {\n+            if (!sAlg.equalsIgnoreCase(n8k.getAlgorithm())\n+                    && !sAlg.equalsIgnoreCase(n8k.getParams().getName())) {\n+                throw new IllegalArgumentException(\n+                        \"key algorithm not compatible with signature algorithm\");\n+            }\n+            return;\n+        }\n@@ -498,2 +507,4 @@\n-            default -> kAlg; \/\/ All modern signature algorithms,\n-                             \/\/ RSASSA-PSS, ED25519, ED448, HSS\/LMS, etc\n+            default -> kAlg.contains(\"KEM\") ? null : kAlg;\n+                \/\/ All modern signature algorithms use the same name across\n+                \/\/ key algorithms and signature algorithms, for example,\n+                \/\/ RSASSA-PSS, ED25519, ED448, HSS\/LMS, etc\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.x509;\n+\n+import sun.security.util.BitArray;\n+\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.KeyRep;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+\n+\/\/\/ Represents a public key from an algorithm family that is specialized\n+\/\/\/ with a named parameter set.\n+\/\/\/\n+\/\/\/ This key is generated by either a [sun.security.provider.NamedKeyPairGenerator]\n+\/\/\/ or [sun.security.provider.NamedKeyFactory]. Its [#getAlgorithm] method\n+\/\/\/ returns the algorithm family name, while its [#getParams()] method returns\n+\/\/\/ the parameter set name as a [NamedParameterSpec] object. The algorithm\n+\/\/\/ identifier in the X.509 encoding of the key is always a single OID derived\n+\/\/\/ from the parameter set name.\n+\/\/\/\n+\/\/\/ @see sun.security.provider.NamedKeyPairGenerator\n+public final class NamedX509Key extends X509Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] rawBytes;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedX509Key(String fname, String pname, byte[] rawBytes) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.rawBytes = rawBytes;\n+\n+        setKey(new BitArray(rawBytes.length * 8, rawBytes));\n+    }\n+\n+    \/\/\/ Ctor from family name, and X.509 bytes\n+    public NamedX509Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        this.fname = fname;\n+        decode(encoded);\n+        this.paramSpec = new NamedParameterSpec(algid.getName());\n+        if (algid.encodedParams != null) {\n+            throw new InvalidKeyException(\"algorithm identifier has params\");\n+        }\n+        this.rawBytes = getKey().toByteArray();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" public key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return rawBytes;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n+        return new KeyRep(KeyRep.Type.PUBLIC, getAlgorithm(), getFormat(),\n+                getEncoded());\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedX509Key keys are not directly deserializable\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NamedX509Key.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -262,1 +262,1 @@\n-    if ((*env)->ExceptionOccurred(env))\n+    if ((*env)->ExceptionCheck(env))\n","filename":"src\/java.base\/share\/native\/libjava\/ClassLoader.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        if ((*env)->ExceptionOccurred(env))                \\\n+        if ((*env)->ExceptionCheck(env))                \\\n@@ -89,1 +89,1 @@\n-        if ((*env)->ExceptionOccurred(env))                \\\n+        if ((*env)->ExceptionCheck(env))                \\\n","filename":"src\/java.base\/share\/native\/libjava\/System.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-    if (!(*env)->ExceptionOccurred(env)) {\n+    if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-    if (!(*env)->ExceptionOccurred(env)) {\n+    if (!(*env)->ExceptionCheck(env)) {\n@@ -169,1 +169,1 @@\n-    if (!(*env)->ExceptionOccurred(env)) {\n+    if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n@@ -366,1 +366,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n@@ -1525,1 +1525,1 @@\n-        if (!(*env)->ExceptionOccurred(env)) {\n+        if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n@@ -256,1 +256,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -153,1 +153,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/unix\/native\/libjava\/io_util_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,1 +377,1 @@\n-        if (sock < 0 && (*env)->ExceptionOccurred(env)) {\n+        if (sock < 0 && (*env)->ExceptionCheck(env)) {\n@@ -386,1 +386,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n@@ -404,1 +404,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -859,1 +859,1 @@\n-    if (sock < 0 && (*env)->ExceptionOccurred(env)) {\n+    if (sock < 0 && (*env)->ExceptionCheck(env)) {\n@@ -868,1 +868,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -887,1 +887,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1240,1 +1240,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1284,1 +1284,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n@@ -1481,1 +1481,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1555,1 +1555,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1720,1 +1720,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1760,1 +1760,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/unix\/native\/libnet\/NetworkInterface.c","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        if (res < 0 && !(*env)->ExceptionOccurred(env))\n+        if (res < 0 && !(*env)->ExceptionCheck(env))\n","filename":"src\/java.base\/unix\/native\/libnet\/SdpSupport.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2666,1 +2666,1 @@\n-        Shape result = textLine.getOutline(tx);\n+        Shape result = textLine.getOutline();\n@@ -2671,0 +2671,9 @@\n+        if (tx != null) {\n+            if (result instanceof GeneralPath gp) {\n+                \/\/ transform in place\n+                gp.transform(tx);\n+            } else {\n+                \/\/ create a transformed copy\n+                result = tx.createTransformedShape(result);\n+            }\n+        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/TextLayout.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-    public Shape getOutline(AffineTransform tx) {\n+    public Shape getOutline() {\n@@ -873,1 +873,0 @@\n-\n@@ -877,3 +876,0 @@\n-        if (tx != null) {\n-            dstShape.transform(tx);\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/TextLine.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        if ((*env)->ExceptionOccurred(env)) return;\n+        if ((*env)->ExceptionCheck(env)) return;\n@@ -214,1 +214,1 @@\n-        if ((*env)->ExceptionOccurred(env)) return NULL;\n+        if ((*env)->ExceptionCheck(env)) return NULL;\n@@ -895,1 +895,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n@@ -943,1 +943,1 @@\n-    if ((*env)->ExceptionOccurred(env)) return; \/\/ already failed\n+    if ((*env)->ExceptionCheck(env)) return; \/\/ already failed\n@@ -946,1 +946,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -963,1 +963,1 @@\n-        if ((*env)->ExceptionOccurred(env)) goto bad;\n+        if ((*env)->ExceptionCheck(env)) goto bad;\n@@ -965,1 +965,1 @@\n-        if ((*env)->ExceptionOccurred(env)) goto bad;\n+        if ((*env)->ExceptionCheck(env)) goto bad;\n@@ -1006,1 +1006,1 @@\n-            if (!(*env)->ExceptionOccurred(env)) {\n+            if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.prefs\/macosx\/native\/libprefs\/MacOSXPreferencesFile.m","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        if ((*env)->ExceptionOccurred(env) != NULL) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.security.jgss\/macosx\/native\/libosxkrb5\/SCDynamicStoreConfig.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -886,1 +886,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -996,1 +996,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -1021,1 +1021,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.security.jgss\/windows\/native\/libw2k_lsa_auth\/NativeCreds.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-            if ((*env)->ExceptionOccurred(env)) return;\n+            if ((*env)->ExceptionCheck(env)) return;\n@@ -466,1 +466,1 @@\n-    if ((*env)->ExceptionOccurred(env)) return;\n+    if ((*env)->ExceptionCheck(env)) return;\n@@ -639,1 +639,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/jdk.attach\/windows\/native\/libattach\/VirtualMachineImpl.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -423,0 +423,17 @@\n+        noModule = new ModuleSymbol(names.empty, null) {\n+            @Override public boolean isNoModule() {\n+                return true;\n+            }\n+        };\n+        addRootPackageFor(noModule);\n+\n+        Source source = Source.instance(context);\n+        if (Feature.MODULES.allowedInSource(source)) {\n+            java_base = enterModule(names.java_base);\n+            \/\/avoid completing java.base during the Symtab initialization\n+            java_base.completer = Completer.NULL_COMPLETER;\n+            java_base.visiblePackages = Collections.emptyMap();\n+        } else {\n+            java_base = noModule;\n+        }\n+\n@@ -430,1 +447,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -450,1 +466,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -459,7 +474,0 @@\n-        noModule = new ModuleSymbol(names.empty, null) {\n-            @Override public boolean isNoModule() {\n-                return true;\n-            }\n-        };\n-        addRootPackageFor(noModule);\n-\n@@ -529,10 +537,0 @@\n-        Source source = Source.instance(context);\n-        if (Feature.MODULES.allowedInSource(source)) {\n-            java_base = enterModule(names.java_base);\n-            \/\/avoid completing java.base during the Symtab initialization\n-            java_base.completer = Completer.NULL_COMPLETER;\n-            java_base.visiblePackages = Collections.emptyMap();\n-        } else {\n-            java_base = noModule;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1856,0 +1856,4 @@\n+        if (bestSoFar.kind == AMBIGUOUS) {\n+            AmbiguityError a_err = (AmbiguityError)bestSoFar.baseSymbol();\n+            bestSoFar = a_err.mergeAbstracts(site);\n+        }\n@@ -2760,1 +2764,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2792,1 +2796,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2916,1 +2920,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2975,1 +2979,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -3506,12 +3510,0 @@\n-        @Override\n-        final Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n-            Symbol sym = doLookup(env, phase);\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n-            return sym;\n-        }\n-\n-        abstract Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase);\n-\n@@ -3564,4 +3556,0 @@\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -423,1 +423,0 @@\n-  int i;\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -359,1 +359,0 @@\n-      int rslt;\n@@ -393,2 +392,3 @@\n-      rslt = hcreate_r(htab_sz, symtab->hash_table);\n-      \/\/ guarantee(rslt, \"unexpected failure: hcreate_r\");\n+      if (hcreate_r(htab_sz, symtab->hash_table) == 0) {\n+        goto bad;\n+      }\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/symtab.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ On riscv, sleef vector apis depend on native vector intrinsic, which is supported on\n+\/\/ some compiler, e.g. gcc 14+.\n+\/\/ __riscv_v_intrinsic is used to tell if the compiler supports vector intrinsic.\n+\/\/\n+\/\/ At compile-time, if the current compiler does support vector intrinsics, bridge\n+\/\/ functions will be built in the library. In case the current compiler doesn't support\n+\/\/ vector intrinsics (gcc < 14), then the bridge functions won't be compiled.\n+\/\/ At run-time, if the library is found and the bridge functions are available in the\n+\/\/ library, then the java vector API will call into the bridge functions and sleef.\n+\n+#if __GNUC__ >= 14 || (defined(__clang_major__) && __clang_major__ >= 17)\n+\n+#ifdef __riscv_v_intrinsic\n+\n+#include <stdint.h>\n+\n+#include <riscv_vector.h>\n+\n+#include \"..\/generated\/misc.h\"\n+#include \"..\/generated\/sleefinline_rvvm1.h\"\n+\n+#include <jni.h>\n+\n+\/\/ We maintain an invariant in java world that default dynamic rounding mode is RNE,\n+\/\/ please check JDK-8330094, JDK-8330266 for more details.\n+\/\/ Currently, sleef source on riscv does not change rounding mode to others except\n+\/\/ of RNE. But we still think it's safer to make sure that after calling into sleef\n+\/\/ the dynamic rounding mode is always RNE.\n+\n+#ifdef DEBUG\n+#define CHECK_FRM   __asm__ __volatile__ (     \\\n+    \"    frrm   t0              \\n\\t\"          \\\n+    \"    beqz   t0, 2f          \\n\\t\"          \\\n+    \"    csrrw  x0, cycle, x0   \\n\\t\"          \\\n+    \"2:                         \\n\\t\"          \\\n+    : : : \"memory\" );\n+#else\n+#define CHECK_FRM\n+#endif\n+\n+#define DEFINE_VECTOR_MATH_UNARY_RVV(op, type) \\\n+JNIEXPORT                                      \\\n+type op##rvv(type input) {                     \\\n+  type res = Sleef_##op##rvvm1(input);         \\\n+  CHECK_FRM                                    \\\n+  return res;                                  \\\n+}\n+\n+#define DEFINE_VECTOR_MATH_BINARY_RVV(op, type) \\\n+JNIEXPORT                                       \\\n+type op##rvv(type input1, type input2) {        \\\n+  type res = Sleef_##op##rvvm1(input1, input2); \\\n+  CHECK_FRM                                     \\\n+  return res;                                   \\\n+}\n+\n+DEFINE_VECTOR_MATH_UNARY_RVV(tanfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sinfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sinhfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cosfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(coshfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(asinfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(acosfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(atanfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cbrtfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(logfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log10fx_u10, vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log1pfx_u10, vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expm1fx_u10, vfloat_rvvm1_sleef)\n+\n+DEFINE_VECTOR_MATH_UNARY_RVV(tandx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sindx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sinhdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cosdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(coshdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(asindx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(acosdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(atandx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cbrtdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(logdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log10dx_u10, vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log1pdx_u10, vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expm1dx_u10, vdouble_rvvm1_sleef)\n+\n+DEFINE_VECTOR_MATH_BINARY_RVV(atan2fx_u10, vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(powfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(hypotfx_u05, vfloat_rvvm1_sleef)\n+\n+DEFINE_VECTOR_MATH_BINARY_RVV(atan2dx_u10, vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(powdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(hypotdx_u05, vdouble_rvvm1_sleef)\n+\n+#undef DEFINE_VECTOR_MATH_UNARY_RVV\n+\n+#undef DEFINE_VECTOR_MATH_BINARY_RVV\n+\n+#endif  \/* __riscv_v_intrinsic *\/\n+\n+#endif  \/* check gcc and clang version *\/\n","filename":"src\/jdk.incubator.vector\/linux\/native\/libsleef\/lib\/vector_math_rvv.c","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -31,2 +31,2 @@\n-    --body-text-color: #353833;\n-    --block-text-color: #474747;\n+    --body-text-color: #282828;\n+    --block-text-color: #282828;\n@@ -52,1 +52,1 @@\n-    --link-color: #4A6782;\n+    --link-color: #437291;\n@@ -54,0 +54,3 @@\n+    \/* Table of contents *\/\n+    --toc-background-color: var(--section-background-color);\n+    --toc-link-color: #4a698a;\n@@ -102,0 +105,3 @@\n+nav a:link, nav a:visited {\n+    color: var(--toc-link-color);\n+}\n@@ -401,1 +407,1 @@\n-    background-color: var(--section-background-color);\n+    background-color: var(--toc-background-color);\n@@ -412,2 +418,0 @@\n-    background-color: var(--section-background-color);\n-    border-right: 1px solid var(--border-color);\n@@ -476,1 +480,0 @@\n-    background-color: var(--body-background-color);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -147,1 +147,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -177,1 +177,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -224,1 +224,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -329,1 +329,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/jdk.jdi\/share\/native\/libdt_shmem\/SharedMemoryConnection.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -112,1 +112,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -146,1 +146,1 @@\n-        if ((nameString == NULL) && !(*env)->ExceptionOccurred(env)) {\n+        if ((nameString == NULL) && !(*env)->ExceptionCheck(env)) {\n@@ -193,1 +193,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/jdk.jdi\/share\/native\/libdt_shmem\/SharedMemoryTransport.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,4 +43,0 @@\n-    \/\/\n-\n-    \/\/ by default log everything\n-    const Logger::LogLevel defaultLogLevel = Logger::LOG_TRACE;\n","filename":"src\/jdk.jpackage\/share\/native\/common\/Log.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.time.Duration;\n@@ -53,0 +54,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -54,0 +57,1 @@\n+import java.util.stream.IntStream;\n@@ -98,1 +102,1 @@\n-    private static final int MIN_TIMEOUT = 50; \/\/ msec after which there are no retries.\n+    private static final int MIN_TIMEOUT = 0; \/\/ msec after which there are no retries.\n@@ -226,1 +230,4 @@\n-\n+        \/\/ Holder for unfulfilled timeouts left for each server\n+        AtomicLong[] unfulfilledUdpTimeouts = IntStream.range(0, servers.length)\n+                .mapToObj(_ -> new AtomicLong())\n+                .toArray(AtomicLong[]::new);\n@@ -233,2 +240,2 @@\n-            for (int retry = 0; retry < retries; retry++) {\n-\n+            for (int retry = 0; retry <= retries; retry++) {\n+                boolean isLastRetry = retry == retries;\n@@ -240,0 +247,5 @@\n+                    \/\/ unfulfilledServerTimeout is always >= 0\n+                    AtomicLong unfulfilledServerTimeout = unfulfilledUdpTimeouts[i];\n+                    if (isLastRetry && unfulfilledServerTimeout.get() == 0) {\n+                        continue;\n+                    }\n@@ -248,1 +260,1 @@\n-                                                retry, xid);\n+                                retry, xid, unfulfilledServerTimeout, isLastRetry);\n@@ -262,1 +274,6 @@\n-                            int retryTimeout = (timeout * (1 << retry));\n+                            long retryTimeout = Math.clamp(\n+                                    timeout * (1L << (isLastRetry\n+                                            ? retry - 1\n+                                            : retry)),\n+                                    0L, Integer.MAX_VALUE);\n+                            ;\n@@ -304,1 +321,3 @@\n-                        if (caughtException == null) {\n+                        if (caughtException == null || servers.length == 1) {\n+                            \/\/ If there are several servers we continue trying with other\n+                            \/\/ servers, otherwise this exception will be reported\n@@ -306,0 +325,3 @@\n+                        } else {\n+                            \/\/ Best reporting effort\n+                            caughtException.addSuppressed(ex);\n@@ -312,1 +334,4 @@\n-                        if (caughtException == null) {\n+                        if (caughtException instanceof CommunicationException ce) {\n+                            e.addSuppressed(ce);\n+                            caughtException = e;\n+                        } else if (caughtException == null) {\n@@ -330,1 +355,3 @@\n-                        if (caughtException == null) {\n+                        if (caughtException == null || servers.length == 1) {\n+                            \/\/ If there are several servers we continue trying with other\n+                            \/\/ servers, otherwise this exception will be reported\n@@ -332,0 +359,3 @@\n+                        } else {\n+                            \/\/ Best reporting effort\n+                            caughtException.addSuppressed(e);\n@@ -342,2 +372,2 @@\n-        if (caughtException instanceof NamingException) {\n-            throw (NamingException) caughtException;\n+        if (caughtException instanceof NamingException ne) {\n+            throw ne;\n@@ -427,1 +457,3 @@\n-                                     int port, int retry, int xid)\n+                              int port, int retry, int xid,\n+                              AtomicLong unfulfilledTimeout,\n+                              boolean unfulfilledOnly)\n@@ -431,0 +463,20 @@\n+\n+\n+        \/\/ use 1L below to ensure conversion to long and avoid potential\n+        \/\/ integer overflow (timeout is an int).\n+        \/\/ no point in supporting timeout > Integer.MAX_VALUE, clamp if needed\n+        \/\/ timeout remaining after successive 'blockingReceive()'.\n+        long thisIterationTimeout = unfulfilledOnly\n+                ? 0L\n+                : Math.clamp(timeout * (1L << retry), 0L, Integer.MAX_VALUE);\n+\n+        \/\/ Compensate with server's positive unfulfilled timeout.\n+        \/\/ Calling method never supplies zero 'unfulfilledTimeout' when\n+        \/\/ 'unfulfilledOnly' is 'true', therefore 'thisIterationTimeout'\n+        \/\/ will always be a positive number, ie infinite timeout\n+        \/\/ is not possible.\n+        thisIterationTimeout += unfulfilledTimeout.get();\n+\n+        \/\/ Track left timeout for the current retry\n+        long timeoutLeft = thisIterationTimeout;\n+        long start = 0;\n@@ -439,1 +491,0 @@\n-                int pktTimeout = (timeout * (1 << retry));\n@@ -442,2 +493,0 @@\n-                \/\/ timeout remaining after successive 'blockingReceive()'\n-                int timeoutLeft = pktTimeout;\n@@ -446,0 +495,1 @@\n+                start = System.nanoTime();\n@@ -459,3 +509,1 @@\n-                    long start = System.currentTimeMillis();\n-                    gotData = blockingReceive(udpChannel, ipkt, timeoutLeft);\n-                    long end = System.currentTimeMillis();\n+                    gotData = blockingReceive(udpChannel, target, ipkt, timeoutLeft);\n@@ -474,1 +522,3 @@\n-                    timeoutLeft = pktTimeout - ((int) (end - start));\n+                    long elapsedMillis = TimeUnit.NANOSECONDS\n+                                                 .toMillis(System.nanoTime() - start);\n+                    timeoutLeft = thisIterationTimeout - elapsedMillis;\n@@ -480,0 +530,3 @@\n+            long carryoverTimeout = thisIterationTimeout -\n+                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n+            unfulfilledTimeout.set(Math.max(0, carryoverTimeout));\n@@ -484,1 +537,2 @@\n-    boolean blockingReceive(DatagramChannel dc, ByteBuffer buffer, long timeout) throws IOException {\n+    boolean blockingReceive(DatagramChannel dc, InetSocketAddress target,\n+                            ByteBuffer buffer, long timeout) throws IOException {\n@@ -494,2 +548,8 @@\n-                dc.receive(buffer);\n-                dataReceived = true;\n+                int before = buffer.position();\n+                var senderAddress = dc.receive(buffer);\n+                \/\/ Empty packets are ignored\n+                dataReceived = target.equals(senderAddress) && buffer.position() > before;\n+            }\n+            \/\/ Avoid contention with Selector.close() if called by a clean-up thread\n+            synchronized (keys) {\n+                keys.clear();\n@@ -497,1 +557,0 @@\n-            keys.clear();\n@@ -753,1 +812,1 @@\n-    private int timeoutLeft;\n+    private long timeoutLeft;\n@@ -755,1 +814,1 @@\n-    Tcp(InetAddress server, int port, int timeout) throws IOException {\n+    Tcp(InetAddress server, int port, long timeout) throws IOException {\n@@ -758,3 +817,8 @@\n-            long start = System.currentTimeMillis();\n-            sock.connect(new InetSocketAddress(server, port), timeout);\n-            timeoutLeft = (int) (timeout - (System.currentTimeMillis() - start));\n+            long start = System.nanoTime();\n+            \/\/ It is safe to cast to int since the value is\n+            \/\/ clamped by the caller\n+            int intTimeout = (int) timeout;\n+            sock.connect(new InetSocketAddress(server, port), intTimeout);\n+            timeoutLeft = Duration.ofMillis(timeout)\n+                    .minus(Duration.ofNanos((System.nanoTime() - start)))\n+                    .toMillis();\n@@ -788,3 +852,4 @@\n-\n-        sock.setSoTimeout(timeoutLeft);\n-        long start = System.currentTimeMillis();\n+        \/\/ It is safe to cast to int since the value is clamped\n+        int intTimeout = (int) timeoutLeft;\n+        sock.setSoTimeout(intTimeout);\n+        long start = System.nanoTime();\n@@ -795,1 +860,2 @@\n-            timeoutLeft -= (int) (System.currentTimeMillis() - start);\n+            timeoutLeft -= TimeUnit.NANOSECONDS.toMillis(\n+                    System.nanoTime() - start);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":99,"deletions":33,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-                timeout = val;\n+                timeout = Math.max(val, 0);\n@@ -185,1 +185,1 @@\n-                retries = val;\n+                retries = Math.clamp(val, 1, 30);\n@@ -260,1 +260,1 @@\n-            : Integer.parseInt(val);\n+            : Math.max(Integer.parseInt(val), 0);\n@@ -264,1 +264,1 @@\n-            : Integer.parseInt(val);\n+            : Math.clamp(Integer.parseInt(val), 1, 30);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsContext.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+###########################################################################\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+###########################################################################\n+\n+#############################################################################\n+#\n+# List of quarantined tests -- tests that should not be run by default, because\n+# they may fail due to known reason. The reason (CR#) must be mandatory specified.\n+#\n+# List items are testnames followed by labels, all MUST BE commented\n+#   as to why they are here and use a label:\n+#     generic-all   Problems on all platforms\n+#     generic-ARCH  Where ARCH is one of: x64, i586, ppc64, ppc64le, s390x etc.\n+#     OSNAME-all    Where OSNAME is one of: linux, windows, macosx, aix\n+#     OSNAME-ARCH   Specific on to one OSNAME and ARCH, e.g. macosx-x64\n+#     OSNAME-REV    Specific on to one OSNAME and REV, e.g. macosx-10.7.4\n+#\n+# More than one label is allowed but must be on the same line.\n+#\n+#############################################################################\n","filename":"test\/docs\/ProblemList.txt","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#\n+\n+# This file identifies the root of the test-suite hierarchy.\n+# It also contains test-suite configuration information.\n+\n+# The list of keywords supported in the entire test suite.  The\n+# \"intermittent\" keyword marks tests known to fail intermittently.\n+# The \"randomness\" keyword marks tests using randomness with test\n+# cases differing from run to run. (A test using a fixed random seed\n+# would not count as \"randomness\" by this definition.) Extra care\n+# should be taken to handle test failures of intermittent or\n+# randomness tests.\n+\n+# Group definitions\n+groups=TEST.groups\n+\n+# Minimum jtreg version\n+requiredVersion=7.4+1\n+\n+# Use new module options\n+useNewOptions=true\n+\n+# Use --patch-module instead of -Xmodule:\n+useNewPatchModule=true\n+\n+# Path to libraries in the topmost test directory. This is needed so @library\n+# does not need ..\/..\/ notation to reach them\n+external.lib.roots = ..\/..\/\n","filename":"test\/docs\/TEST.ROOT","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+#  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+#  This code is free software; you can redistribute it and\/or modify it\n+#  under the terms of the GNU General Public License version 2 only, as\n+#  published by the Free Software Foundation.\n+#\n+#  This code is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+#  version 2 for more details (a copy is included in the LICENSE file that\n+#  accompanied this code).\n+#\n+#  You should have received a copy of the GNU General Public License version\n+#  2 along with this work; if not, write to the Free Software Foundation,\n+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+#  or visit www.oracle.com if you need additional information or have any\n+#  questions.\n+#\n+\n+# Docs-specific test groups\n+\n+docs_all = \\\n+    \/\n+\n+tier2 = \\\n+    :docs_all\n","filename":"test\/docs\/TEST.groups","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib ..\/..\/tools\/tester\n+ * @build jtreg.SkippedException\n+ * @summary example of a test on the generated documentation\n+ * @run main TestDocs\n+ *\/\n+\n+import java.nio.file.Files;\n+\n+public class TestDocs {\n+    public static void main(String... args) throws Exception {\n+        var docs = DocTester.resolveDocs();\n+        System.err.println(\"path to docs is: \" + docs);\n+        System.err.println(\"Do docs exits?\");\n+        System.err.println(Files.exists(docs));\n+        System.err.println(\"Where is tidy\");\n+        System.err.println(System.getProperty(\"tidy\"));\n+        System.err.println(\"End of test\");\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/TestDocs.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+echo_file test\/TEST.properties\n","filename":"test\/docs\/req.flg","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jtreg.SkippedException;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * Test framework for performing tests on the generated documentation.\n+ *\/\n+public class DocTester {\n+    private final static String DIR = System.getenv(\"DOCS_IMAGE_DIR\");\n+    private static final Path firstCandidate = Path.of(System.getProperty(\"test.jdk\"))\n+            .getParent().resolve(\"docs\");\n+\n+    public static Path resolveDocs() {\n+        if (DIR != null && !DIR.isBlank() && Files.exists(Path.of(DIR))) {\n+            return Path.of(DIR);\n+        } else if (Files.exists(firstCandidate)) {\n+            return firstCandidate;\n+        }else {\n+            throw new SkippedException(\"docs folder not found in either location\");\n+        }\n+    }\n+}\n","filename":"test\/docs\/tools\/tester\/DocTester.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -363,1 +363,1 @@\n-    auto pretouch = [heap, size](Thread*, int) {\n+    auto pretouch = [heap](Thread*, int) {\n@@ -366,1 +366,1 @@\n-    auto useMemory = [heap, size](Thread*, int) {\n+    auto useMemory = [heap](Thread*, int) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,3 +42,5 @@\n-vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manyDiff_a\/TestDescription.java 8308367 windows-x64\n-vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manySame_a\/TestDescription.java 8308367 windows-x64\n-vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/redefineClassInTarget\/TestDescription.java 8308367 windows-x64\n+vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manyDiff_a\/TestDescription.java 8308367 generic-all\n+vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manySame_a\/TestDescription.java 8308367 generic-all\n+vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2none_b\/TestDescription.java 8308367 generic-all\n+vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_none2indy_b\/TestDescription.java 8308367 generic-all\n+vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/redefineClassInTarget\/TestDescription.java 8308367 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+applications\/ctw\/modules\/java_base_2.java 8341831 linux-x64\n+\n@@ -56,1 +58,0 @@\n-compiler\/c2\/irTests\/TestIfMinMax.java 8339220 linux-s390x\n@@ -125,0 +126,1 @@\n+containers\/docker\/TestJcmdWithSideCar.java 8341518 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    docker.support \\\n+    container.support \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336726\n+ * @summary Test that post-parse call devirtualization works when call does not have an IO projection.\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp -XX:CompileCommand=compileonly,TestCallDevirtualizationWithInfiniteLoop::test\n+ *                   TestCallDevirtualizationWithInfiniteLoop\n+ *\/\n+\n+public class TestCallDevirtualizationWithInfiniteLoop {\n+\n+    static interface I {\n+        public void method();\n+    }\n+\n+    static final class A implements I {\n+        @Override\n+        public void method() { };\n+    }\n+\n+    static final class B implements I {\n+        @Override\n+        public void method() { };\n+    }\n+\n+    static final A a = new A();\n+    static final B b = new B();\n+\n+    public static void test(boolean flag) {\n+        \/\/ Avoid executing endless loop\n+        if (flag) {\n+            return;\n+        }\n+\n+        \/\/ We only know after loop opts that the receiver type is B.\n+        I recv = a;\n+        for (int i = 0; i < 3; ++i) {\n+            if (i > 1) {\n+                recv = b;\n+            }\n+        }\n+        \/\/ Post-parse call devirtualization will then convert below\n+        \/\/ virtual call to a static call.\n+        recv.method();\n+\n+        \/\/ Endless loop which does not use IO. As a result the IO\n+        \/\/ projection of the call is removed unexpectedly.\n+        while (true) { }\n+    }\n+\n+    public static void main(String[] args) {\n+        test(true);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCallDevirtualizationWithInfiniteLoop.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8325495\n+ * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestSerialAdditions\n+ *\/\n+public class TestSerialAdditions {\n+    private static final Random RNG = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"addTo2\",\n+            \"addTo3\",\n+            \"addTo4\",\n+            \"shiftAndAddTo4\",\n+            \"mulAndAddTo4\",\n+            \"addTo5\",\n+            \"addTo6\",\n+            \"addTo7\",\n+            \"addTo8\",\n+            \"addTo16\",\n+            \"addAndShiftTo16\",\n+            \"addTo42\",\n+            \"mulAndAddTo42\",\n+            \"mulAndAddToMax\",\n+            \"mulAndAddToOverflow\",\n+            \"mulAndAddToZero\",\n+            \"mulAndAddToMinus1\",\n+            \"mulAndAddToMinus42\"\n+    })\n+    private void runIntTests() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, RNG.nextInt() }) {\n+            Asserts.assertEQ(a * 2, addTo2(a));\n+            Asserts.assertEQ(a * 3, addTo3(a));\n+            Asserts.assertEQ(a * 4, addTo4(a));\n+            Asserts.assertEQ(a * 4, shiftAndAddTo4(a));\n+            Asserts.assertEQ(a * 4, mulAndAddTo4(a));\n+            Asserts.assertEQ(a * 5, addTo5(a));\n+            Asserts.assertEQ(a * 6, addTo6(a));\n+            Asserts.assertEQ(a * 7, addTo7(a));\n+            Asserts.assertEQ(a * 8, addTo8(a));\n+            Asserts.assertEQ(a * 16, addTo16(a));\n+            Asserts.assertEQ(a * 16, addAndShiftTo16(a));\n+            Asserts.assertEQ(a * 42, addTo42(a));\n+            Asserts.assertEQ(a * 42, mulAndAddTo42(a));\n+            Asserts.assertEQ(a * Integer.MAX_VALUE, mulAndAddToMax(a));\n+            Asserts.assertEQ(a * Integer.MIN_VALUE, mulAndAddToOverflow(a));\n+            Asserts.assertEQ(0, mulAndAddToZero(a));\n+            Asserts.assertEQ(a * -1, mulAndAddToMinus1(a));\n+            Asserts.assertEQ(a * -42, mulAndAddToMinus42(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"mulAndAddToIntOverflowL\",\n+            \"mulAndAddToMaxL\",\n+            \"mulAndAddToOverflowL\"\n+    })\n+    private void runLongTests() {\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, RNG.nextLong() }) {\n+            Asserts.assertEQ(a * (Integer.MAX_VALUE + 1L), mulAndAddToIntOverflowL(a));\n+            Asserts.assertEQ(a * Long.MAX_VALUE, mulAndAddToMaxL(a));\n+            Asserts.assertEQ(a * Long.MIN_VALUE, mulAndAddToOverflowL(a));\n+        }\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = IRNode.LSHIFT_I)\n+    private static int addTo2(int a) {\n+        return a + a; \/\/ Simple additions like a + a should be kept as-is\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo3(int a) {\n+        return a + a + a; \/\/ a*3 => (a<<1) + a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo4(int a) {\n+        return a + a + a + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int shiftAndAddTo4(int a) {\n+        return (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddTo4(int a) {\n+        return a * 3 + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo5(int a) {\n+        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    private static int addTo6(int a) {\n+        return a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int addTo7(int a) {\n+        return a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo8(int a) {\n+        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo16(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addAndShiftTo16(int a) {\n+        return (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int addTo42(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddTo42(int a) {\n+        return a * 40 + a + a; \/\/ a*41 + a => a*42\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMax(int a) {\n+        return a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - a => (a<<31) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddToOverflow(int a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static int mulAndAddToZero(int a) {\n+        return a * -1 + a; \/\/ 0\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMinus1(int a) {\n+        return a * -2 + a; \/\/ a*-1 => a - (a<<1)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddToMinus42(int a) {\n+        return a * -43 + a; \/\/ a*-42\n+    }\n+\n+    \/\/ --- long tests ---\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToIntOverflowL(long a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.SUB_L, \"1\" })\n+    private static long mulAndAddToMaxL(long a) {\n+        return a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToOverflowL(long a) {\n+        return a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -49,0 +49,9 @@\n+    public static long lseed = 1;\n+    public static int iseed = 2;\n+    public static short sseed = 3;\n+    public static byte bseed = 4;\n+    public static long lres = lseed;\n+    public static int ires = iseed;\n+    public static short sres = sseed;\n+    public static byte bres = bseed;\n+\n@@ -53,1 +62,1 @@\n-        private static final long lseed = 1;\n+        private static final long data;\n@@ -63,0 +72,1 @@\n+            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n@@ -64,1 +74,2 @@\n-            UNSAFE.putLongUnaligned(BYTES, 127, rawdata+lseed);\n+            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n+            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n@@ -66,1 +77,2 @@\n-            UNSAFE.putLongUnaligned(BYTES, 1096, rawdata-lseed);\n+            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n+            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n@@ -75,1 +87,1 @@\n-        private static final int iseed = 2;\n+        private static final int data;\n@@ -84,0 +96,1 @@\n+            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n@@ -85,1 +98,2 @@\n-            UNSAFE.putIntUnaligned(BYTES, 255, rawdata + iseed);\n+            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n+            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n@@ -87,1 +101,2 @@\n-            UNSAFE.putIntUnaligned(BYTES, 528, rawdata - iseed);\n+            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n+            data = UNSAFE.getIntUnaligned(BYTES, 528);\n@@ -96,1 +111,1 @@\n-        private static final short sseed = 3;\n+        private static final short data;\n@@ -105,0 +120,1 @@\n+            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n@@ -106,1 +122,2 @@\n-            UNSAFE.putShortUnaligned(BYTES, 253, (short) (rawdata + sseed));\n+            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n+            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n@@ -108,1 +125,2 @@\n-            UNSAFE.putShortUnaligned(BYTES, 272, (short) (rawdata - sseed));\n+            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n+            data = UNSAFE.getShortUnaligned(BYTES, 272);\n@@ -117,1 +135,1 @@\n-        private static final byte bseed = 4;\n+        private static final byte data;\n@@ -126,0 +144,1 @@\n+            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n@@ -127,1 +146,2 @@\n-            UNSAFE.putByte(BYTES, 53, (byte) (rawdata + bseed));\n+            UNSAFE.putByte(BYTES, 53, bres);\n+            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n@@ -129,1 +149,2 @@\n-            UNSAFE.putByte(BYTES, 1027, (byte) (rawdata - bseed));\n+            UNSAFE.putByte(BYTES, 1027, bres);\n+            data = UNSAFE.getByte(BYTES, 1027);\n@@ -136,3 +157,1 @@\n-        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1030), ta.rawdata, \"putUnaligned long failed!\");\n-        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 127), ta.rawdata + ta.lseed, \"putUnaligned long failed!\");\n-        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1096), ta.rawdata - ta.lseed, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n@@ -141,3 +160,1 @@\n-        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 274), tb.rawdata, \"putUnaligned int failed!\");\n-        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 255), tb.rawdata + tb.iseed, \"putUnaligned int failed!\");\n-        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 528), tb.rawdata - tb.iseed, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n@@ -146,3 +163,1 @@\n-        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 257), tc.rawdata, \"putUnaligned short failed!\");\n-        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 253), (short) (tc.rawdata + tc.sseed), \"putUnaligned short failed!\");\n-        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 272), (short) (tc.rawdata - tc.sseed), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n@@ -151,3 +166,1 @@\n-        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 272), td.rawdata, \"put byte failed!\");\n-        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 53), (byte) (td.rawdata + td.bseed), \"put byte failed!\");\n-        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 1027), (byte) (td.rawdata - td.bseed), \"put byte failed!\");\n+        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java","additions":37,"deletions":24,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    @IR(counts = { IRNode.NOP, \"1\" })\n+    @IR(counts = { IRNode.NOP, \"<=1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPadding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8337066\n+ * @summary Test that MergeMem is skipped when looking for stores\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,java.lang.StringUTF16::reverse\n+ *                   compiler.controldependency.TestAntiDependencyForPinnedLoads\n+ *\/\n+\n+package compiler.controldependency;\n+\n+public class TestAntiDependencyForPinnedLoads {\n+    public static void main(String[] args) {\n+        for(int i = 0; i < 50_000; i++) {\n+            String str = \"YYYY年MM月DD日\";\n+            StringBuffer strBuffer = new StringBuffer(str);\n+            String revStr = strBuffer.reverse().toString();\n+            if (!revStr.equals(\"日DD月MM年YYYY\")) throw new InternalError(\"FAIL\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestAntiDependencyForPinnedLoads.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.debug;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8330157\n+ * @requires vm.debug == true & vm.compiler2.enabled & (vm.opt.AbortVMOnCompilationFailure == \"null\" | !vm.opt.AbortVMOnCompilationFailure)\n+ * @summary Basic tests for bailout stress flag.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.debug.TestStressBailout\n+ *\/\n+\n+public class TestStressBailout {\n+\n+    static void runTest(int invprob) throws Exception {\n+        String[] procArgs = {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+StressBailout\",\n+                             \"-XX:StressBailoutMean=\" + invprob, \"-version\"};\n+        ProcessBuilder pb  = ProcessTools.createTestJavaProcessBuilder(procArgs);\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Random r = Utils.getRandomInstance();\n+        \/\/ Likely bail out on -version, for some low Mean value.\n+        runTest(r.nextInt(1, 10));\n+        \/\/ Higher value\n+        runTest(r.nextInt(10, 1_000_000));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/debug\/TestStressBailout.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -122,7 +122,7 @@\n-    private static final String TYPE_BYTE   = \"byte\";\n-    private static final String TYPE_CHAR   = \"char\";\n-    private static final String TYPE_SHORT  = \"short\";\n-    private static final String TYPE_INT    = \"int\";\n-    private static final String TYPE_LONG   = \"long\";\n-    private static final String TYPE_FLOAT  = \"float\";\n-    private static final String TYPE_DOUBLE = \"double\";\n+    private static final String TYPE_BYTE   = \"B\";\n+    private static final String TYPE_CHAR   = \"C\";\n+    private static final String TYPE_SHORT  = \"S\";\n+    private static final String TYPE_INT    = \"I\";\n+    private static final String TYPE_LONG   = \"J\";\n+    private static final String TYPE_FLOAT  = \"F\";\n+    private static final String TYPE_DOUBLE = \"D\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,1 @@\n-        return nodeRegex.replaceAll(IRNode.IS_REPLACED,\n-                                    \"vector[A-Za-z]\\\\\\\\[\" + sizeRegex + \"\\\\\\\\]:\\\\\\\\{\" + type + \"\\\\\\\\}\");\n+        return nodeRegex.replaceAll(IRNode.IS_REPLACED, \"vector[A-Za-z]<\" + type + \",\" + sizeRegex + \">\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawIRNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8336702\n+ * @summary C2 compilation fails with \"all memory state should have been processed\" assert\n+ *\n+ * @run main\/othervm TestSafePointWithEAState\n+ *\n+ *\/\n+\n+public class TestSafePointWithEAState {\n+    int[] b = new int[400];\n+\n+    void c() {\n+        int e;\n+        float f;\n+        for (long d = 0; d < 5000; d++) {\n+            e = 1;\n+            while ((e += 3) < 200) {\n+                if (d < b.length) {\n+                    for (int g = 0; g < 10000; ++g) ;\n+                }\n+            }\n+            synchronized (TestSafePointWithEAState.class) {\n+                f = new h(e).n;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] m) {\n+        TestSafePointWithEAState o = new TestSafePointWithEAState();\n+        o.c();\n+    }\n+}\n+\n+class h {\n+    float n;\n+    h(float n) {\n+        this.n = n;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestSafePointWithEAState.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8340214\n+ * @summary C2 compilation asserts with \"no node with a side effect\" in PhaseIdealLoop::try_sink_out_of_loop\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestBadMemSliceWithInterfaces\n+ *\n+ *\/\n+\n+public class TestBadMemSliceWithInterfaces {\n+    public static void main(String[] args) {\n+        B b = new B();\n+        C c = new C();\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(b, c, true);\n+            test1(b, c, false);\n+            b.field = 0;\n+            c.field = 0;\n+            int res = test2(b, c, true);\n+            if (res != 42) {\n+                throw new RuntimeException(\"incorrect result \" + res);\n+            }\n+            res = test2(b, c, false);\n+            if (res != 42) {\n+                throw new RuntimeException(\"incorrect result \" + res);\n+            }\n+        }\n+    }\n+\n+    private static void test1(B b, C c, boolean flag) {\n+        A a;\n+        if (flag) {\n+            a = b;\n+        } else {\n+            a = c;\n+        }\n+        for (int i = 0; i < 1000; i++) {\n+            a.field = 42;\n+        }\n+    }\n+\n+    private static int test2(B b, C c, boolean flag) {\n+        A a;\n+        if (flag) {\n+            a = b;\n+        } else {\n+            a = c;\n+        }\n+        int v = 0;\n+        for (int i = 0; i < 2; i++) {\n+            v += a.field;\n+            a.field = 42;\n+        }\n+        return v;\n+    }\n+\n+    interface I {\n+        void m();\n+    }\n+\n+    static class A {\n+        int field;\n+    }\n+\n+    static class B extends A implements I {\n+        @Override\n+        public void m() {\n+\n+        }\n+    }\n+\n+    static class C extends A implements I {\n+        @Override\n+        public void m() {\n+\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestBadMemSliceWithInterfaces.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/DockerBasicTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/ShareTmpDir.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUSets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestContainerInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @requires (docker.support & os.maxMemory >= 2g)\n+ * @requires (container.support & os.maxMemory >= 2g)\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFREvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFRNetworkEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFRWithJMX.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +32,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestLimitsUpdating.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestPids.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import jdk.internal.misc.Unsafe;\n+\n+\/*\n+ * @test\n+ * @bug 8341471\n+ * @summary Reversed field layout caused by unstable sorting\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm TestFieldLayout\n+ *\/\n+\n+public class TestFieldLayout {\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean endResult = true;\n+        long previous = 0;\n+\n+        for (Field f : Test.class.getDeclaredFields()) {\n+            long current = U.objectFieldOffset(f);\n+            if (current < previous) {\n+                System.out.printf(\"FAILED: field %s offset %d previous %d\\n\",\n+                                  f.getName(), current, previous);\n+                endResult = false;\n+            }\n+            previous = current;\n+        }\n+\n+        System.out.println(endResult ? \"Test PASSES\" : \"Test FAILS\");\n+        if (!endResult) {\n+            throw new Error(\"Test failed\");\n+        }\n+    }\n+\n+    public class Test {\n+        char a000;\n+        char a001;\n+        char a002;\n+        char a003;\n+        char a004;\n+        char a005;\n+        char a006;\n+        char a007;\n+        char a008;\n+        char a009;\n+        char a00a;\n+        char a00b;\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/TestFieldLayout.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -312,0 +312,7 @@\n+        \/\/ Use this stress mode 10% of the time as it could make some long-running compilations likely to abort.\n+        if (rng.nextInt(10) == 0) {\n+            Args.add(\"-XX:+StressBailout\");\n+            Args.add(\"-XX:StressBailoutMean=100000\");\n+            Args.add(\"-XX:+CaptureBailoutInformation\");\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-java\/lang\/management\/MemoryMXBean\/CollectionUsageThreshold.java 8318668 generic-all\n+java\/foreign\/TestUpcallStress.java                              8341584 generic-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-java\/awt\/Frame\/InitialIconifiedTest.java 8203920 macosx-all,linux-all\n+java\/awt\/Frame\/InitialIconifiedTest.java 7144049,8203920 macosx-all,linux-all\n@@ -126,0 +126,1 @@\n+java\/awt\/Frame\/FocusTest.java 8341480 macosx-all\n@@ -131,0 +132,3 @@\n+java\/awt\/dnd\/DragExitBeforeDropTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DragThresholdTest.java 8076299 macosx-all\n+java\/awt\/dnd\/CustomDragCursorTest.java 8242805 macosx-all\n@@ -143,0 +147,1 @@\n+java\/awt\/EventQueue\/PushPopDeadlock\/PushPopDeadlock.java 8024034 generic-all\n@@ -199,0 +204,3 @@\n+java\/awt\/dnd\/DnDRemoveFocusOwnerCrashTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DnDCursorCrashTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DnDClipboardDeadlockTest.java 8079553 linux-all\n@@ -213,0 +221,3 @@\n+java\/awt\/TrayIcon\/MouseMoveTest.java 8203053 linux-all\n+java\/awt\/TrayIcon\/TrayIconKeySelectTest.java 8341557 windows-all\n+java\/awt\/TrayIcon\/TrayIconTest.java 8341559 generic-all\n@@ -436,0 +447,1 @@\n+java\/awt\/Mouse\/MouseClickCount.java 8017182 macosx-all\n@@ -469,0 +481,2 @@\n+java\/awt\/Dialog\/FileDialogUserFilterTest.java 8001142 generic-all\n+\n@@ -633,0 +647,2 @@\n+sun\/security\/tools\/keytool\/GenKeyPairSigner.java                8342002 generic-all\n+\n@@ -673,1 +689,0 @@\n-javax\/swing\/JTabbedPane\/8007563\/Test8007563.java 8051591 generic-all\n@@ -809,0 +824,1 @@\n+java\/awt\/dnd\/WinMoveFileToShellTest.java 8341665 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    docker.support \\\n+    container.support \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,0 +161,13 @@\n+ *\n+ * @bug 8341819\n+ * @comment Regression test for re-locking racing with deflation with LM_LIGHTWEIGHT.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ *                 -XX:GuaranteedAsyncDeflationInterval=1\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.time.Instant;\n@@ -43,1 +42,1 @@\n- * @run main Timeout\n+ * @run main\/othervm Timeout\n@@ -51,0 +50,4 @@\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 0;\n@@ -52,1 +55,1 @@\n-    private Instant startTime;\n+    private long startTime;\n@@ -84,1 +87,1 @@\n-            startTime = Instant.now();\n+            startTime = System.nanoTime();\n@@ -95,1 +98,1 @@\n-            Duration elapsedTime = Duration.between(startTime, Instant.now());\n+            Duration elapsedTime = Duration.ofNanos(System.nanoTime() - startTime);\n@@ -101,2 +104,8 @@\n-            Duration expectedTime = Duration.ofMillis(TIMEOUT)\n-                    .multipliedBy((1 << RETRIES) - 1);\n+            Duration minAllowedTime = Duration.ofMillis(TIMEOUT)\n+                    .multipliedBy((1 << RETRIES) - 1)\n+                    .minus(Duration.ofMillis(DNS_CLIENT_MIN_TIMEOUT * RETRIES));\n+            Duration maxAllowedTime = Duration.ofMillis(TIMEOUT)\n+                    .multipliedBy((1 << RETRIES) - 1)\n+                    \/\/ max allowed timeout value is set to 2 * expected timeout\n+                    .multipliedBy(2);\n+\n@@ -104,1 +113,3 @@\n-            DNSTestUtils.debug(\"Expected (ms): \" + expectedTime.toMillis());\n+            String expectedRangeMsg = \"%s - %s\"\n+                    .formatted(minAllowedTime.toMillis(), maxAllowedTime.toMillis());\n+            DNSTestUtils.debug(\"Expected range (ms): \" + expectedRangeMsg);\n@@ -107,4 +118,3 @@\n-            \/\/ not more than 50% greater.\n-            if (elapsedTime.compareTo(expectedTime) >= 0 &&\n-                    elapsedTime.multipliedBy(2)\n-                            .compareTo(expectedTime.multipliedBy(3)) <= 0) {\n+            \/\/ not more than 2 times greater.\n+            if (elapsedTime.compareTo(minAllowedTime) >= 0 &&\n+                elapsedTime.compareTo(maxAllowedTime) <= 0) {\n@@ -115,2 +125,2 @@\n-                    \"Failed: timeout in \" + elapsedTime.toMillis()\n-                            + \" ms, expected\" + expectedTime.toMillis() + \"ms\");\n+                    \"Failed: timeout in \" + elapsedTime.toMillis() +\n+                    \" ms, expected to be in a range (ms): \" + expectedRangeMsg);\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/Timeout.java","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.naming.CommunicationException;\n+import javax.naming.Context;\n+import javax.naming.directory.InitialDirContext;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 8339538\n+ * @summary Tests that DnsClient correctly calculates left timeout in\n+ *          presence of empty datagram packets.\n+ * @library ..\/lib \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm TimeoutWithEmptyDatagrams\n+ *\/\n+\n+public class TimeoutWithEmptyDatagrams extends DNSTestBase {\n+    \/\/ initial timeout = 1\/4 sec\n+    private static final int TIMEOUT = 250;\n+    \/\/ try 5 times per server\n+    private static final int RETRIES = 5;\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 0;\n+\n+    public TimeoutWithEmptyDatagrams() {\n+        setLocalServer(false);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new TimeoutWithEmptyDatagrams().run(args);\n+    }\n+\n+    \/*\n+     * Tests that we can set the initial UDP timeout interval and the\n+     * number of retries.\n+     *\/\n+    @Override\n+    public void runTest() throws Exception {\n+        \/\/ Create a DatagramSocket and bind it to the loopback address to simulate\n+        \/\/ UDP DNS server that doesn't respond\n+        try (DatagramSocket ds = new DatagramSocket(new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0))) {\n+            CountDownLatch gotClientAddress = new CountDownLatch(1);\n+            AtomicReference<SocketAddress> clientAddress = new AtomicReference<>();\n+            AtomicBoolean stopTestThreads = new AtomicBoolean();\n+\n+            String allQuietUrl = URIBuilder.newBuilder()\n+                    .scheme(\"dns\")\n+                    .loopback()\n+                    .port(ds.getLocalPort())\n+                    .build()\n+                    .toString();\n+\n+            \/\/ Run a virtual thread that receives client request packets and extracts\n+            \/\/ sender address from them.\n+            Thread receiverThread = Thread.ofVirtual().start(() -> {\n+                while (!stopTestThreads.get()) {\n+                    try {\n+                        DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);\n+                        ds.receive(packet);\n+                        System.err.println(\"Got packet from \" + packet.getSocketAddress());\n+                        boolean hasClientAddress = clientAddress.get() != null;\n+                        clientAddress.set(packet.getSocketAddress());\n+                        if (!hasClientAddress) {\n+                            gotClientAddress.countDown();\n+                        }\n+                    } catch (IOException e) {\n+                        if (!stopTestThreads.get()) {\n+                            throw new RuntimeException(e);\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                }\n+            });\n+\n+            \/\/ Run a virtual thread that will send an empty packets via server socket\n+            \/\/ that should wake up the selector on a client side.\n+            Thread wakeupThread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    long timeout = Math.max(1, TIMEOUT \/ 4);\n+                    \/\/ wait for a first packet on a server socket\n+                    gotClientAddress.await();\n+\n+                    \/\/ Now start sending empty packets until we get a notification\n+                    \/\/ from client part to stop sending\n+                    while (!stopTestThreads.get()) {\n+                        System.err.println(\"Server timeout = \" + timeout);\n+                        TimeUnit.MILLISECONDS.sleep(timeout);\n+                        System.err.println(\"Sending wakeup packet to \" + clientAddress.get());\n+                        var wakeupPacket = new DatagramPacket(new byte[0], 0);\n+                        wakeupPacket.setSocketAddress(clientAddress.get());\n+                        ds.send(wakeupPacket);\n+                        timeout += Math.max(1, timeout \/ 2);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(\"Test machinery failure\", ioe);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(\"Interrupted during wakeup packets sending\");\n+                } finally {\n+                    System.err.println(\"Server thread exiting\");\n+                }\n+            });\n+\n+            long startTime = 0;\n+            try {\n+                env().put(Context.PROVIDER_URL, allQuietUrl);\n+                env().put(\"com.sun.jndi.dns.timeout.initial\", String.valueOf(TIMEOUT));\n+                env().put(\"com.sun.jndi.dns.timeout.retries\", String.valueOf(RETRIES));\n+                setContext(new InitialDirContext(env()));\n+\n+                startTime = System.nanoTime();\n+                context().getAttributes(\"\");\n+\n+                \/\/ Any request should fail after timeouts have expired.\n+                throw new RuntimeException(\"Failed: getAttributes succeeded unexpectedly\");\n+            } catch (CommunicationException ce) {\n+                \/\/ We need to catch CommunicationException outside the test framework\n+                \/\/ flow because wakeupThread.join() can take some time that could\n+                \/\/ increase measured timeout\n+                long endTime = System.nanoTime();\n+                Duration elapsedTime = Duration.ofNanos(endTime - startTime);\n+                if (ce.getRootCause() instanceof SocketTimeoutException) {\n+\n+                    Duration minAllowedTime = Duration.ofMillis(TIMEOUT)\n+                            .multipliedBy((1 << RETRIES) - 1)\n+                            .minus(Duration.ofMillis(DNS_CLIENT_MIN_TIMEOUT * RETRIES));\n+                    Duration maxAllowedTime = Duration.ofMillis(TIMEOUT)\n+                            .multipliedBy((1 << RETRIES) - 1)\n+                            \/\/ max allowed timeout value is set to 2 * expected timeout\n+                            .multipliedBy(2);\n+\n+                    DNSTestUtils.debug(\"Elapsed (ms):  \" + elapsedTime.toMillis());\n+                    String expectedRangeMsg = \"%s - %s\"\n+                            .formatted(minAllowedTime.toMillis(), maxAllowedTime.toMillis());\n+                    DNSTestUtils.debug(\"Expected range (ms): \" + expectedRangeMsg);\n+\n+                    \/\/ Check that elapsed time is as long as expected, and\n+                    \/\/ not more than 2 times greater.\n+                    if (elapsedTime.compareTo(minAllowedTime) >= 0 &&\n+                        elapsedTime.compareTo(maxAllowedTime) <= 0) {\n+                        System.out.println(\"elapsed time is as long as expected.\");\n+                    } else {\n+                        throw new RuntimeException(\n+                                \"Failed: timeout in \" + elapsedTime.toMillis() +\n+                                \" ms, expected to be in a range (ms): \" + expectedRangeMsg);\n+                    }\n+                } else {\n+                    throw ce;\n+                }\n+            } finally {\n+                stopTestThreads.set(true);\n+                wakeupThread.join();\n+                ds.close();\n+                receiverThread.join();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/TimeoutWithEmptyDatagrams.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6251983 6722236\n+ * @summary MouseDragged events not triggered for Choice when dragging it with left mouse button\n+ * @key headful\n+ * @run main ChoiceDragEventsInside\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionAdapter;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ChoiceDragEventsInside extends Frame {\n+    Robot robot;\n+    Choice choice1;\n+    Point pt;\n+    Dimension size;\n+    volatile boolean mouseDragged = false;\n+    volatile boolean mouseDraggedOutside = false;\n+\n+    public void setupUI() {\n+        setTitle(\"Choce Drag Events Inside\");\n+        choice1 = new Choice();\n+        for (int i = 1; i < 50; i++) {\n+            choice1.add(\"item-0\" + i);\n+        }\n+        choice1.setForeground(Color.red);\n+        choice1.setBackground(Color.red);\n+        choice1.addMouseMotionListener(new MouseMotionAdapter() {\n+                public void mouseMoved(MouseEvent me) {\n+                    System.out.println(me);\n+                }\n+\n+                public void mouseDragged(MouseEvent me) {\n+                    System.out.println(me);\n+                    mouseDragged = true;\n+                    if (me.getY() < 0) {\n+                        mouseDraggedOutside = true;\n+                    }\n+                }\n+            }\n+        );\n+        add(choice1);\n+        setLayout(new FlowLayout());\n+        setSize(200, 200);\n+        setLocationRelativeTo(null);\n+        setVisible(true);\n+        validate();\n+    }\n+\n+    public void start() {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(50);\n+            robot.delay(100);\n+            EventQueue.invokeAndWait(() -> {\n+                pt = choice1.getLocationOnScreen();\n+                size = choice1.getSize();\n+            });\n+            testDragInsideChoice(InputEvent.BUTTON1_MASK);\n+            testDragInsideChoiceList(InputEvent.BUTTON1_MASK);\n+            testDragOutsideChoice(InputEvent.BUTTON1_MASK);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Test failed. Exception thrown: \" + e);\n+        }\n+    }\n+\n+    public void testDragInsideChoice(int button) {\n+        robot.mouseMove(pt.x + size.width \/ 2, pt.y + size.height \/ 2);\n+        robot.delay(100);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+\n+        robot.mouseMove(pt.x + size.width \/ 4, pt.y + size.height \/ 2);\n+        robot.mousePress(button);\n+\n+        dragMouse(pt.x + size.width \/ 4, pt.y + size.height \/ 2,\n+                pt.x + size.width * 3 \/ 4, pt.y + size.height \/ 2);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        if (!mouseDragged) {\n+            throw new RuntimeException(\"Test failed. Choice should generate MouseDragged events inside Choice itself\");\n+        } else {\n+            System.out.println(\"Stage 1 passed. Choice generates MouseDragged events inside Choice itself\");\n+        }\n+        mouseDragged = false;\n+        \/\/close opened choice\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+    }\n+\n+    public void testDragInsideChoiceList(int button) {\n+        robot.mouseMove(pt.x + size.width \/ 2, pt.y + size.height \/ 2);\n+        robot.delay(100);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+\n+        robot.mouseMove(pt.x + size.width \/ 2, pt.y + 5 * size.height);\n+        robot.delay(200);\n+        robot.mousePress(button);\n+\n+        dragMouse(pt.x + size.width \/ 2, pt.y + 5 * size.height,\n+                pt.x + size.width \/ 2, pt.y + 8 * size.height);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        if (mouseDragged) {\n+            throw new RuntimeException(\"Test failed. Choice shouldn't generate MouseDragged events inside Choice's list\");\n+        } else {\n+            System.out.println(\"Stage 2 passed. Choice doesn't generate MouseDragged events inside Choice's list\");\n+        }\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+        mouseDragged = false;\n+    }\n+\n+    public void testDragOutsideChoice(int button) {\n+        pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + size.width \/ 2, pt.y + size.height \/ 2);\n+        robot.delay(100);\n+\n+        robot.mousePress(button);\n+        \/\/drag mouse outside of Choice\n+        dragMouse(pt.x + size.width \/ 2, pt.y + size.height \/ 2,\n+                pt.x + size.width \/ 2, pt.y - 3 * size.height);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        if (!mouseDragged || !mouseDraggedOutside) {\n+            throw new RuntimeException(\"Test failed. Choice should generate MouseDragged events outside Choice\");\n+        } else {\n+            System.out.println(\"Stage 3 passed. Choice generates MouseDragged events outside Choice\");\n+        }\n+        robot.keyPress(KeyEvent.VK_ESCAPE);\n+        robot.keyRelease(KeyEvent.VK_ESCAPE);\n+        robot.delay(200);\n+        mouseDragged = false;\n+    }\n+\n+    public void dragMouse(int x0, int y0, int x1, int y1) {\n+        int curX = x0;\n+        int curY = y0;\n+        int dx = x0 < x1 ? 1 : -1;\n+        int dy = y0 < y1 ? 1 : -1;\n+\n+        while (curX != x1) {\n+            curX += dx;\n+            robot.mouseMove(curX, curY);\n+        }\n+        while (curY != y1) {\n+            curY += dy;\n+            robot.mouseMove(curX, curY);\n+        }\n+    }\n+\n+    public static void main(final String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        ChoiceDragEventsInside app = new ChoiceDragEventsInside();\n+        try {\n+            EventQueue.invokeAndWait(app::setupUI);\n+            app.start();\n+        } finally {\n+            EventQueue.invokeAndWait(app::dispose);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceDragEventsInside.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4319246\n+ * @summary Tests that MouseReleased, MouseClicked and MouseDragged are triggered on choice\n+ * @key headful\n+ * @run main ChoiceMouseEventTest\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+\n+public class ChoiceMouseEventTest extends Frame {\n+    static volatile boolean mousePressed = false;\n+    static volatile boolean mouseReleased = false;\n+    static volatile boolean mouseClicked = false;\n+    Choice choice = new Choice();\n+    static Point location;\n+    static Dimension size;\n+\n+    public void setupGUI() {\n+        setTitle(\"Choice Mouse Event Test\");\n+        this.setLayout(new BorderLayout());\n+        choice.add(\"item-1\");\n+        choice.add(\"item-2\");\n+        choice.add(\"item-3\");\n+        choice.add(\"item-4\");\n+        add(\"Center\", choice);\n+        choice.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                mouseClicked = true;\n+            }\n+\n+            @Override\n+            public void mousePressed(MouseEvent e) {\n+                mousePressed = true;\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleased = true;\n+            }\n+        });\n+        setLocationRelativeTo(null);\n+        setSize(400, 200);\n+        setVisible(true);\n+    }\n+\n+    public Point _location() {\n+        return choice.getLocationOnScreen();\n+    }\n+\n+    public Dimension _size() {\n+        return choice.getSize();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException, AWTException {\n+        ChoiceMouseEventTest test = new ChoiceMouseEventTest();\n+        try {\n+            EventQueue.invokeAndWait(test::setupGUI);\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(50);\n+            robot.delay(1000);\n+            robot.waitForIdle();\n+            EventQueue.invokeAndWait(() -> {\n+                location = test._location();\n+                size = test._size();\n+            });\n+            robot.waitForIdle();\n+            robot.mouseMove(location.x + size.width - 10, location.y + (size.height \/ 2));\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(2000);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(2000);\n+            robot.waitForIdle();\n+            if (!mouseClicked || !mousePressed || !mouseReleased) {\n+                throw new RuntimeException(String.format(\"One of the events not arrived: \" +\n+                        \"mouseClicked = %b, mousePressed = %b, mouseReleased = %b\",\n+                        mouseClicked, mousePressed, mouseReleased));\n+            }\n+        } finally {\n+            if (test != null) {\n+                EventQueue.invokeAndWait(test::dispose);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceMouseEventTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4079027\n+ * @summary Removing an item dynamically from a Choice object breaks lower items.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ChoiceRemoveTest\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ChoiceRemoveTest extends Frame {\n+    Choice selector;\n+    static final String INSTRUCTIONS = \"\"\"\n+            After window 'Choice Remove Test' appears wait for three seconds\n+            and then click on the choice. In popup there should be no\n+            'Choice A' variant. Try selecting each variant with mouse\n+            and verify by the log that the correct variant gets selected.\n+            If after selecting item in the list the correct item gets selected\n+            and correct item name appears in the log press Pass otherwise press Fail.\n+            \"\"\";\n+\n+    public static void main(String[] argv) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .testUI(ChoiceRemoveTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public ChoiceRemoveTest() {\n+        super(\"Choice Remove Test\");\n+        Panel p;\n+        Label prompt;\n+\n+        addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowOpened(WindowEvent e) {\n+                super.windowOpened(e);\n+                new Thread(() -> {\n+                    try {\n+                        Thread.sleep(2000);\n+                    } catch (InterruptedException ignore) {\n+                    }\n+                    removeFirst();\n+                }).start();\n+            }\n+        });\n+\n+        setLayout(new GridLayout());\n+        p = new Panel();\n+\n+        prompt = new Label(\"Select different items including the last one\");\n+        p.add(prompt);\n+\n+        selector = new Choice();\n+        selector.add(\"Choice A\");\n+        selector.add(\"Choice B\");\n+        selector.add(\"Choice C\");\n+        selector.add(\"Choice D\");\n+        selector.add(\"Choice E\");\n+        selector.addItemListener(e -> {\n+            if (e.getStateChange() == ItemEvent.SELECTED) {\n+                Object selected = e.getItem();\n+                PassFailJFrame.log(selected.toString());\n+            }\n+        });\n+        p.add(selector);\n+        add(p);\n+        pack();\n+    }\n+\n+    public void removeFirst() {\n+        selector.remove(\"Choice A\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceRemoveTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6240046\n+ * @summary REG:Choice's Drop-down does not disappear when clicking somewhere, after popup menu is disposed-XTkt\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PopupMenuOnChoiceArea\n+ *\/\n+\n+\n+import java.awt.CheckboxMenuItem;\n+import java.awt.Choice;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.PopupMenu;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class PopupMenuOnChoiceArea extends Frame {\n+    static final String INSTRUCTIONS = \"\"\"\n+            You would see a window named 'Popup menu on choice area'\n+            with Choice in it. Move the mouse pointer to the choice.\n+            Click right mouse button on it.\n+            You should see a popup menu with 'File' in it.\n+            Close this popup menu by pressing Esc.\n+            Click the left mouse button on the Choice.\n+            You should see a Choice drop-down menu.\n+            Move mouse pointer into drop-down menu.\n+            Click right mouse button on any item in it.\n+            If you see a 'File' popup menu press Fail.\n+            If Choice drop-down closes instead press Pass.\n+            \"\"\";\n+\n+    public PopupMenuOnChoiceArea() {\n+        super(\"Popup menu on choice area\");\n+        this.setLayout(new FlowLayout());\n+        Choice choice = new Choice();\n+        choice.add(\"item-1\");\n+        choice.add(\"item-2\");\n+        choice.add(\"item-3\");\n+        choice.add(\"item-4\");\n+        add(\"Center\", choice);\n+        Menu fileMenu = new Menu(\"File\");\n+        Menu open = new Menu(\"Open\");\n+        Menu save = new Menu(\"save\");\n+        CheckboxMenuItem exit = new CheckboxMenuItem(\"Exit\");\n+        fileMenu.add(open);\n+        fileMenu.add(save);\n+        fileMenu.add(exit);\n+        final PopupMenu pop = new PopupMenu();\n+        pop.setLabel(\"This is a popup menu\");\n+        pop.setName(\"a menu\");\n+        pop.add(fileMenu);\n+        choice.add(pop);\n+        choice.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    pop.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+\n+            public void mouseReleased(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    pop.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+        });\n+        setSize(200, 200);\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .testUI(PopupMenuOnChoiceArea::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/PopupMenuOnChoiceArea.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6405707\n+ * @summary Choice popup & scrollbar gets Flickering when mouse is pressed & drag on the scrollbar\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ScrollbarFlickers\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Frame;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ScrollbarFlickers extends Frame {\n+    static final String INSTRUCTIONS = \"\"\"\n+            Open the choice popup. Select any item in it and\n+            drag it with the mouse above or below the choice.\n+            Keep the choice opened.\n+            Continue dragging the mouse outside of the choice\n+            making content of the popup scroll.\n+            If you see that scrollbar flickers press Fail.\n+            Otherwise press Pass.\n+            \"\"\";\n+\n+    public ScrollbarFlickers() {\n+        super(\"Scrollbar Flickering Test\");\n+        Choice ch = new Choice();\n+        setLayout(new BorderLayout());\n+        ch.add(\"Praveen\");\n+        ch.add(\"Mohan\");\n+        ch.add(\"Rakesh\");\n+        ch.add(\"Menon\");\n+        ch.add(\"Girish\");\n+        ch.add(\"Ramachandran\");\n+        ch.add(\"Elancheran\");\n+        ch.add(\"Subramanian\");\n+        ch.add(\"Raju\");\n+        ch.add(\"Pallath\");\n+        ch.add(\"Mayank\");\n+        ch.add(\"Joshi\");\n+        ch.add(\"Sundar\");\n+        ch.add(\"Srinivas\");\n+        ch.add(\"Mandalika\");\n+        ch.add(\"Suresh\");\n+        ch.add(\"Chandar\");\n+        add(ch);\n+        setSize(200, 200);\n+        validate();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .testUI(ScrollbarFlickers::new)\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/ScrollbarFlickers.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6255196\n+ * @key headful\n+ * @summary Verifies the supported actions on different platforms.\n+ * @library \/test\/lib\n+ * @run main\/othervm ActionSupportTest\n+ *\/\n+\n+import java.awt.Desktop;\n+import java.io.File;\n+import java.net.URI;\n+import javax.swing.JMenuBar;\n+import jtreg.SkippedException;\n+\n+import static java.awt.desktop.QuitStrategy.NORMAL_EXIT;\n+\n+public class ActionSupportTest {\n+\n+    public static void main(String[] args) {\n+        final File file = new File(\"nonExistentFile\");\n+        final URI uri = URI.create(\"nonExistentSchema:anything\");\n+        final StringBuilder error = new StringBuilder();\n+\n+        if (!Desktop.isDesktopSupported()) {\n+            throw new SkippedException(\"Class java.awt.Desktop is not supported on \" +\n+                    \"current platform. Farther testing will not be performed\");\n+        }\n+\n+        Desktop desktop = Desktop.getDesktop();\n+        for (Desktop.Action action : Desktop.Action.values()) {\n+            boolean supported = desktop.isSupported(action);\n+\n+            try {\n+                switch (action) {\n+                    case OPEN:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.open(file);\n+                        break;\n+                    case EDIT:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.edit(file);\n+                        break;\n+                    case PRINT:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.print(file);\n+                        break;\n+                    case MAIL:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.mail(uri);\n+                        break;\n+                    case BROWSE:\n+                        if (supported) {\n+                            continue; \/\/ prevent native message about strange schema\n+                        }\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.browse(uri);\n+                        break;\n+                    case APP_EVENT_FOREGROUND:\n+                    case APP_EVENT_HIDDEN:\n+                    case APP_EVENT_REOPENED:\n+                    case APP_EVENT_SCREEN_SLEEP:\n+                    case APP_EVENT_SYSTEM_SLEEP:\n+                    case APP_EVENT_USER_SESSION:\n+                        continue; \/\/ Has no effect if SystemEventListener's sub-type\n+                        \/\/ is unsupported on the current platform.\n+                    case APP_ABOUT:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setAboutHandler(e -> {\n+                        });\n+                        break;\n+                    case APP_PREFERENCES:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setPreferencesHandler(e -> {\n+                        });\n+                        break;\n+                    case APP_OPEN_FILE:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setOpenFileHandler(e -> {\n+                        });\n+                        break;\n+                    case APP_PRINT_FILE:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setPrintFileHandler(e -> {\n+                        });\n+                        break;\n+                    case APP_OPEN_URI:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setOpenURIHandler(e -> {\n+                        });\n+                        break;\n+                    case APP_QUIT_HANDLER:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setQuitHandler((e, response) -> {\n+                        });\n+                        break;\n+                    case APP_QUIT_STRATEGY:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setQuitStrategy(NORMAL_EXIT);\n+                        break;\n+                    case APP_SUDDEN_TERMINATION:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.enableSuddenTermination();\n+                        break;\n+                    case APP_REQUEST_FOREGROUND:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.requestForeground(true);\n+                        break;\n+                    case APP_HELP_VIEWER:\n+                        if (supported) {\n+                            continue; \/\/ prevent open separate window\n+                        }\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.openHelpViewer();\n+                        break;\n+                    case APP_MENU_BAR:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.setDefaultMenuBar(new JMenuBar());\n+                        break;\n+                    case BROWSE_FILE_DIR:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.browseFileDirectory(file);\n+                        break;\n+                    case MOVE_TO_TRASH:\n+                        \/\/ if not supported, an UnsupportedOperationException will be thrown.\n+                        \/\/ if supported, other exception might be thrown.\n+                        desktop.moveToTrash(file);\n+                        break;\n+                }\n+                \/\/ no exception has been thrown.\n+                if (!supported) {\n+                    error.append(\"Action \" + action.name() + \" is an \" +\n+                            \"unsupported operation, but no exception has been thrown\\n\");\n+                }\n+            } catch (UnsupportedOperationException uoe) {\n+                if (!supported) {\n+                    System.out.println(\"Action \" + action.name() + \"is not supported.\");\n+                } else {\n+                    error.append(\"Action \" + action.name() + \" is a \" +\n+                            \"supported operation, \" +\n+                            \"but UnsupportedOperationException has been thrown\\n\");\n+                }\n+            } catch (Exception e) {\n+                if (supported) {\n+                    System.out.println(\"Action \" + action.name() + \"supported.\");\n+                } else {\n+                    error.append(\"Action \" + action.name() + \" is an \" +\n+                            \"unsupported operation, but \" +\n+                            \"UnsupportedOperationException has not been thrown\\n\");\n+                }\n+            }\n+        }\n+\n+        if (!error.isEmpty()) {\n+            System.err.println(error);\n+            throw new RuntimeException(\"One or more tests failed. \" +\n+                    \"Look at the error output for details\");\n+        }\n+        System.out.println(\"Test completed\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Desktop\/ActionSupportTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6255196\n+ * @summary  Verifies the function of method browse(java.net.URI uri).\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual BrowseTest\n+ *\/\n+\n+import java.awt.Desktop;\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import javax.swing.JPanel;\n+\n+public class BrowseTest extends JPanel {\n+    static final String INSTRUCTIONS = \"\"\"\n+            This test could launch default file manager to open user's home\n+            directory, and default web browser to show the URL of java vendor.\n+            After test execution close the native file manager and web browser\n+            windows if they were launched by test.\n+            Also check output for any unexpected EXCEPTIONS,\n+            if you see any failure messages press Fail otherwise press Pass.\n+            \"\"\";\n+\n+    public BrowseTest() {\n+        if (!Desktop.isDesktopSupported()) {\n+            PassFailJFrame.log(\"Class java.awt.Desktop is not supported on \" +\n+                    \"current platform. Farther testing will not be performed\");\n+            PassFailJFrame.forcePass();\n+        }\n+\n+        Desktop desktop = Desktop.getDesktop();\n+\n+        URI dirURI = new File(System.getProperty(\"user.home\")).toURI();\n+        URI webURI = URI.create(System.getProperty(\"java.vendor.url\", \"http:\/\/www.java.com\"));\n+        boolean failed = false;\n+        try {\n+            PassFailJFrame.log(\"Try to browse \" + dirURI + \" ...\");\n+            desktop.browse(dirURI);\n+            PassFailJFrame.log(\"Succeed.\\n\");\n+        } catch (Exception e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        }\n+\n+        try {\n+            PassFailJFrame.log(\"Try to browse \" + webURI + \" ...\");\n+            desktop.browse(webURI);\n+            PassFailJFrame.log(\"Succeed.\\n\");\n+        } catch (Exception e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Browser Test\")\n+                .splitUI(BrowseTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Desktop\/BrowseTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6255196\n+ * @key headful\n+ * @summary Verifies if class Desktop is supported on current platform.\n+ * @run main DesktopSupportTest\n+ *\/\n+\n+import java.awt.Desktop;\n+\n+public class DesktopSupportTest {\n+    public static void main(String[] args) {\n+        boolean supported = Desktop.isDesktopSupported();\n+        try {\n+            Desktop desktop = Desktop.getDesktop();\n+            if (!supported) {\n+                throw new RuntimeException(\"UnsupportedOperationException \" +\n+                        \"should be thrown, as this class is not supported \" +\n+                        \"on current platform.\");\n+            }\n+        } catch (UnsupportedOperationException uoe) {\n+            if (supported) {\n+                throw new RuntimeException(\"UnsupportedOperationException \" +\n+                        \"should NOT be thrown, as this class is supported \" +\n+                        \"on current platform.\");\n+            }\n+        } catch (Exception e) {\n+            if (!supported) {\n+                throw new RuntimeException(\"UnsupportedOperationException \" +\n+                        \"should be thrown, as this class is not supported \" +\n+                        \"on current platform. But \" + e.getClass().getName() +\n+                        \" has been thrown instead.\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Desktop\/DesktopSupportTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6255196\n+ * @summary Verifies the function of methods mail() and mail(java.net.URI uri).\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MailTest\n+ *\/\n+\n+import java.awt.Desktop;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import javax.swing.JPanel;\n+\n+public class MailTest extends JPanel {\n+\n+    static final String INSTRUCTIONS = \"\"\"\n+            This test could launch the mail client to compose mail\n+            with and without filling the message fields.\n+            After test execution close the mail composing windows if they\n+            were launched by test.\n+            If you see any unexpected EXCEPTION messages in the output\n+            press Fail. Otherwise press Pass.\n+            \"\"\";\n+\n+    private MailTest() {\n+        if (!Desktop.isDesktopSupported()) {\n+            PassFailJFrame.log(\"Class java.awt.Desktop is not supported on \" +\n+                    \"current platform. Farther testing will not be performed\");\n+            PassFailJFrame.forcePass();\n+        }\n+\n+        Desktop desktop = Desktop.getDesktop();\n+        if (!desktop.isSupported(Desktop.Action.MAIL)) {\n+            PassFailJFrame.log(\"Action.MAIL is not supported.\");\n+            PassFailJFrame.forcePass();\n+        }\n+\n+        \/*\n+         * Part 1: launch the mail composing window without a mailto URI.\n+         *\/\n+        try {\n+            desktop.mail();\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        }\n+\n+        \/*\n+         * Part 2: launch the mail composing window with a mailto URI.\n+         *\/\n+        URI testURI = null;\n+        try {\n+            testURI = new URI(\"mailto\", \"foo@bar.com?subject=test subject\" +\n+                    \"&cc=foocc@bar.com&body=test body\", null);\n+            desktop.mail(testURI);\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        } catch (java.net.URISyntaxException use) {\n+            \/\/ Should not reach here.\n+            PassFailJFrame.log(\"EXCEPTION: \" + use.getMessage());\n+        }\n+\n+        \/*\n+         * Part 3: try to launch the mail composing window with a URI with a\n+         * scheme which is not \"mailto\":\n+         *   http:\/\/java.net.\n+         * An IOException should be thrown in this case.\n+         *\/\n+        try {\n+            testURI = URI.create(\"http:\/\/java.com\");\n+            PassFailJFrame.log(\"Try to mail: \" + testURI);\n+            desktop.mail(testURI);\n+        } catch (IllegalArgumentException e) {\n+            PassFailJFrame.log(\"Caught expected IllegalArgumentException\");\n+        } catch (IOException ioe) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + ioe.getMessage());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Mail Test\")\n+                .splitUI(MailTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Desktop\/MailTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6255196\n+ * @summary Verifies the function of method open(java.io.File file).\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual\/othervm OpenTest\n+ *\/\n+\n+import java.awt.Desktop;\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.JPanel;\n+\n+public class OpenTest extends JPanel {\n+\n+    static final String INSTRUCTIONS = \"\"\"\n+            This test could open the user's home directory and a .txt file.\n+            After test execution, close the native application windows that\n+            are used to open the directory and .txt file if they were launched\n+            by the test.\n+            If you see any unexpected EXCEPTION messages in the output press Fail.\n+            Otherwise press Pass.\n+            \"\"\";\n+\n+    public OpenTest() {\n+        if (!Desktop.isDesktopSupported()) {\n+            PassFailJFrame.log(\"Class java.awt.Desktop is not supported on \" +\n+                    \"current platform. Further testing will not be performed\");\n+            PassFailJFrame.forcePass();\n+        }\n+\n+        Desktop desktop = Desktop.getDesktop();\n+\n+        \/*\n+         * Part 1: open a directory, which should launch the system default\n+         * file explorer.\n+         *\n+         * On Windows platforms, the default file explorer is explorer;\n+         * on UNIX platforms with Gnome installed and running, the default\n+         * file explorer is Nautilus.\n+         *\/\n+        File userHome = new File(System.getProperty(\"user.home\"));\n+\n+        try {\n+            PassFailJFrame.log(\"Try to open \" + userHome);\n+            desktop.open(userHome);\n+            PassFailJFrame.log(\"Succeed.\");\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        }\n+\n+        \/*\n+         * Part 2: open a normal .txt file, which should launch the registered\n+         * application for .txt files.\n+         *\/\n+        \/\/ Create a temp .txt file for test.\n+        File testFile = null;\n+        try {\n+            PassFailJFrame.log(\"Creating temporary file\");\n+            testFile = File.createTempFile(\"JDIC-test\", \".txt\",\n+                    new File(System.getProperty(\"java.io.tmpdir\")));\n+            testFile.deleteOnExit();\n+        } catch (java.io.IOException ioe) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + ioe.getMessage());\n+            PassFailJFrame.log(\"Failed to create test file\");\n+        }\n+\n+        try {\n+            PassFailJFrame.log(\"Try to open \" + testFile);\n+            desktop.open(testFile);\n+            PassFailJFrame.log(\"Succeed.\");\n+        } catch (IOException e) {\n+            PassFailJFrame.log(\"EXCEPTION: \" + e.getMessage());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame.builder()\n+                .title(\"Mail Test\")\n+                .splitUI(OpenTest::new)\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(40)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Desktop\/OpenTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Image;\n+import java.awt.Label;\n+import java.awt.MediaTracker;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4779641\n+ * @summary Test to verify that Non-resizable dialogs should not show icons\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogIconTest\n+ *\/\n+\n+public class DialogIconTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. This is a Windows-only test of Dialog icons\n+                2. You can see a frame with a swing icon and two dialogs that it\n+                   owns. The resizable dialog should have the same icon as the\n+                   frame. The non-resizable dialog should have no icon at all\n+                3. Press PASS if this is true, press FAIL otherwise\n+                 \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static List<Window> initialize() {\n+        Frame f = new Frame(\"Parent frame\");\n+        f.setBounds(50, 50, 200, 200);\n+\n+        Dialog dr = new Dialog(f, \"Resizable Dialog\");\n+        dr.setLocation(100, 100);\n+        dr.add(new Label(\"Should inherit icon from parent\"));\n+        dr.pack();\n+\n+        Dialog dn = new Dialog(f, \"NON Resizable Dialog\");\n+        dn.setLocation(150, 150);\n+        dn.add(new Label(\"Should have no icon\"));\n+        dn.pack();\n+        dn.setResizable(false);\n+\n+        String fileName = System.getProperty(\"test.src\") +\n+                System.getProperty(\"file.separator\") + \"swing.small.gif\";\n+\n+        Image icon = Toolkit.getDefaultToolkit().createImage(fileName);\n+        MediaTracker tracker = new MediaTracker(f);\n+        tracker.addImage(icon, 0);\n+        try {\n+            tracker.waitForAll();\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"MediaTracker addImage Interrupted!\");\n+        }\n+        f.setIconImage(icon);\n+        return List.of(f, dn, dr);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogIconTest\/DialogIconTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/DialogIconTest\/swing.small.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/swing\/JTable\/4170447\/swing.small.gif","status":"copied"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Event;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Window;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4058370\n+ * @summary Test to verify Modality of Dialog\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogModalityTest\n+ *\/\n+\n+public class DialogModalityTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. When the test is running, there will be a Frame, a Modal Dialog\n+                   and a Window that is Modal Dialog's parent.\n+                2. Verify that it is impossible to bring up the menu in Frame before\n+                   closing the Modal Dialog.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static List<Window> initialize() {\n+        Frame f = new Frame(\"Parent Frame\");\n+        DialogTest dlg = new DialogTest(f, \"Modal Dialog\");\n+        f.add(new Button(\"push me\"));\n+        f.setSize(200, 200);\n+        f.setLocation(210, 1);\n+        dlg.setBounds(210, 203, 200, 200);\n+        return List.of(f, dlg);\n+    }\n+}\n+\n+class DialogTest extends Dialog {\n+    Button closeButton;\n+    Frame parent;\n+\n+    public DialogTest(Frame parent, String title) {\n+        this(parent, title, true);\n+    }\n+\n+    public DialogTest(Frame parent, String title, boolean modal) {\n+        super(parent, title, modal);\n+        this.parent = parent;\n+        setLayout(new BorderLayout());\n+        Panel buttonPanel = new Panel();\n+        closeButton = new Button(\"Close\");\n+        buttonPanel.add(closeButton);\n+        add(\"Center\", buttonPanel);\n+        pack();\n+    }\n+\n+    public boolean action(Event e, Object arg) {\n+        if (e.target == closeButton) {\n+            Dialog dialog = null;\n+            Component c = (Component) e.target;\n+\n+            while (c != null && !(c instanceof Dialog)) {\n+                c = c.getParent();\n+            }\n+\n+            if (c != null) {\n+                dialog = (Dialog) c;\n+            }\n+\n+            if (dialog == null) {\n+                return false;\n+            }\n+\n+            dialog.setVisible(false);\n+            dialog.dispose();\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogModalityTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Checkbox;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.lang.Exception;\n+import java.lang.String;\n+import java.lang.System;\n+\n+\/*\n+ * @test\n+ * @bug 4115213\n+ * @summary Test to verify Checks that with resizable set to false,\n+ *          dialog can not be resized\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogResizeTest\n+ *\/\n+\n+public class DialogResizeTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. When this test is run a dialog will display (setResizable Test)\n+                   Click on the checkbox to change the dialog resizable state\n+                2. For both dialog resizable states (resizable, non-resizable) try to\n+                   change the size of the dialog. When isResizable is true the dialog\n+                   is resizable. When isResizable is false the dialog is non-resizable\n+                3. If this is the behavior that you observe, the test has passed, Press\n+                   the Pass button. Otherwise the test has failed, Press the Fail button\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Dialog initialize() {\n+        Frame f = new Frame(\"Owner Frame\");\n+        MyDialog ld = new MyDialog(f);\n+        ld.setBounds(100, 100, 400, 150);\n+        ld.setResizable(false);\n+        System.out.println(\"isResizable is set to: \" + ld.isResizable());\n+        return ld;\n+    }\n+}\n+\n+class MyDialog extends Dialog implements ItemListener {\n+    String sText = \"Tests java.awt.Dialog.setResizable method\";\n+    TextArea ta = new TextArea(sText, 2, 40, TextArea.SCROLLBARS_NONE);\n+\n+    public MyDialog(Frame f) {\n+\n+        super(f, \"setResizable test\", false);\n+\n+        Panel cbPanel = new Panel();\n+        cbPanel.setLayout(new FlowLayout());\n+\n+        Panel taPanel = new Panel();\n+        taPanel.setLayout(new FlowLayout());\n+        taPanel.add(ta);\n+\n+        Checkbox cb = new Checkbox(\"Check this box to change the dialog's \" +\n+                \"resizable state\", null, isResizable());\n+        cb.setState(false);\n+        cb.addItemListener(this);\n+        cbPanel.add(cb);\n+\n+        add(\"North\", taPanel);\n+        add(\"South\", cbPanel);\n+        pack();\n+    }\n+\n+    public void itemStateChanged(ItemEvent evt) {\n+        setResizable(evt.getStateChange() == ItemEvent.SELECTED);\n+\n+        boolean bResizeState = isResizable();\n+        PassFailJFrame.log(\"isResizable is set to: \" + bResizeState);\n+\n+        if (isResizable()) {\n+            ta.setText(\"dialog is resizable (isResizable = \" + bResizeState + \")\");\n+        } else {\n+            ta.setText(\"dialog is NOT resizable (isResizable = \" + bResizeState + \")\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogResizeTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+\n+\/*\n+ * @test\n+ * @bug 4172302\n+ * @summary Test to make sure non-resizable Dialogs can be resized with the\n+ *          setSize() method.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogResizeTest2\n+ *\/\n+\n+public class DialogResizeTest2 {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This tests the programmatic resizability of non-resizable Dialogs\n+                Even when a Dialog is set to be non-resizable, it should be\n+                programmatically resizable using the setSize() method.\n+\n+                1. Initially the Dialog will be resizable.  Try using the \\\\\"Smaller\\\\\"\n+                   and \\\\\"Larger\\\\\" buttons to verify that the Dialog resizes correctly\n+                2. Then, click the \\\\\"Toggle\\\\\" button to make the Dialog non-resizable\n+                3. Again, verify that clicking the \\\\\"Larger\\\\\" and \\\\\"Smaller\\\\\" buttons\n+                    causes the Dialog to get larger and smaller.  If the Dialog does\n+                    not change size, or does not re-layout correctly, the test FAILS\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        Frame frame = new Frame(\"Parent Frame\");\n+        frame.add(new Button(\"Button\"));\n+        frame.setSize(100, 100);\n+        new dlg(frame).setVisible(true);\n+        return frame;\n+    }\n+\n+    static class dlg extends Dialog {\n+        public dlg(Frame f_) {\n+            super(f_, \"Dialog\", false);\n+            setSize(200, 200);\n+            Button bLarger = new Button(\"Larger\");\n+            bLarger.addActionListener(e -> setSize(400, 400));\n+            Button bSmaller = new Button(\"Smaller\");\n+            bSmaller.addActionListener(e -> setSize(200, 100));\n+            Button bCheck = new Button(\"Resizable?\");\n+            bCheck.addActionListener(e -> {\n+                if (isResizable()) {\n+                    PassFailJFrame.log(\"Dialog is resizable\");\n+                } else {\n+                    PassFailJFrame.log(\"Dialog is not resizable\");\n+                }\n+            });\n+            Button bToggle = new Button(\"Toggle\");\n+            bToggle.addActionListener(e -> {\n+                if (isResizable()) {\n+                    setResizable(false);\n+                    PassFailJFrame.log(\"Dialog is now not resizable\");\n+                } else {\n+                    setResizable(true);\n+                    PassFailJFrame.log(\"Dialog is now resizable\");\n+                }\n+            });\n+            setLayout(new GridLayout(1, 4));\n+            add(bSmaller);\n+            add(bLarger);\n+            add(bCheck);\n+            add(bToggle);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogResizeTest2.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.image.BufferedImage;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 4035189\n+ * @summary Test to verify that PIT File Dialog icon not matching with\n+ *          the new java icon (frame Icon) - PIT build\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogIconTest\n+ *\/\n+\n+public class FileDialogIconTest {\n+    public static Frame frame;\n+    public static Image image;\n+    public static List<Image> images;\n+    static String fileBase;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Select the Image for a Dialog and Frame using either\n+                   Load\/Save\/Just Dialog.\n+                2. Set the Icon Image\/s to Frame and Dialog. Verify that the\n+                   Icon is set for the respective Frame and Dialog.\n+                   If selected Icon is set to Frame and Dialog press PASS\n+                   else FAIL.\n+                                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static void setImagesToFD(java.util.List<Image> listIcon) {\n+        FileDialogIconTest.images = listIcon;\n+    }\n+\n+    public static void setImagesToFrame(java.util.List<Image> listIcon) {\n+        frame.setIconImages(listIcon);\n+    }\n+\n+    public static void setImageToFD(Image img) {\n+        FileDialogIconTest.image = img;\n+    }\n+\n+    public static void setImageToFrame(Image img) {\n+        frame.setIconImage(img);\n+    }\n+\n+    public static Frame initialize() {\n+        frame = new Frame(\"FileDialogIconTest\");\n+        Button setImageButton1 = new Button(\"setIconImageToFrame\");\n+        Button setImageButton2 = new Button(\"setIconImageToDialog\");\n+        Button setImageButton3 = new Button(\"setIconImagesToFrame\");\n+        Button setImageButton4 = new Button(\"setIconImagesToDialog\");\n+        Button setImageButton5 = new Button(\"setIconBufferedImagesToDialog\");\n+        Button setImageButton6 = new Button(\"setIconBufferedImagesToFrame\");\n+\n+        if (System.getProperty(\"test.src\") == null) {\n+            fileBase = \"\";\n+        } else {\n+            fileBase = System.getProperty(\"test.src\") + System.getProperty(\"file.separator\");\n+        }\n+\n+        final String fileName = fileBase + \"loading-msg.gif\";\n+\n+        setImageButton1.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                    setImageToFrame(image);\n+                    PassFailJFrame.log(\"Loaded image . setting to frame\");\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        setImageButton2.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                    setImageToFD(image);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        setImageButton3.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image;\n+                    java.util.List<Image> list = new java.util.ArrayList();\n+                    for (int i = 1; i <= 4; i++) {\n+                        String fileName = fileBase + \"T\" + i + \".gif\";\n+                        image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                        PassFailJFrame.log(\"Loaded image \" + fileName + \". setting to the list for frame\");\n+                        list.add(image);\n+                    }\n+                    setImagesToFrame(list);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+\n+        setImageButton4.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image;\n+                    List<Image> list = new ArrayList<>();\n+                    for (int i = 1; i <= 4; i++) {\n+                        String fileName = fileBase + \"T\" + i + \".gif\";\n+                        image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                        PassFailJFrame.log(\"Loaded image \" + fileName + \". setting to the list for dialog\");\n+                        list.add(image);\n+                    }\n+                    setImagesToFD(list);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+\n+        setImageButton5.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                List<BufferedImage> list = new ArrayList<>();\n+                try {\n+                    Robot robot = new Robot();\n+                    Rectangle rectangle;\n+                    for (int i = 1; i <= 4; i++) {\n+                        rectangle = new Rectangle(i * 10, i * 10, i * 10 + 40, i * 10 + 40);\n+                        java.awt.image.BufferedImage image = robot.createScreenCapture(rectangle);\n+                        robot.delay(100);\n+                        list.add(image);\n+                    }\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                }\n+                PassFailJFrame.log(\"Captured images and set to the list for dialog\");\n+            }\n+        });\n+\n+        setImageButton6.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                List<BufferedImage> list = new ArrayList<>();\n+                try {\n+                    Robot robot = new Robot();\n+                    Rectangle rectangle;\n+                    for (int i = 1; i <= 4; i++) {\n+                        rectangle = new Rectangle(i * 10, i * 10, i * 10 + 40, i * 10 + 40);\n+                        java.awt.image.BufferedImage image = robot.createScreenCapture(rectangle);\n+                        robot.delay(100);\n+                        list.add(image);\n+                    }\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                }\n+                PassFailJFrame.log(\"Captured images and set to the list for frame\");\n+            }\n+        });\n+\n+        Button buttonLoad = new Button(\"Load Dialog\");\n+        Button buttonSave = new Button(\"Save Dialog\");\n+        Button buttonSimple = new Button(\"Just Dialog\");\n+        buttonLoad.addActionListener(new MyActionListener(FileDialog.LOAD, \"LOAD\"));\n+        buttonSave.addActionListener(new MyActionListener(FileDialog.SAVE, \"SAVE\"));\n+        buttonSimple.addActionListener(new MyActionListener(-1, \"\"));\n+\n+        frame.setSize(400, 400);\n+        frame.setLayout(new FlowLayout());\n+        frame.add(buttonLoad);\n+        frame.add(buttonSave);\n+        frame.add(buttonSimple);\n+        frame.add(setImageButton1);\n+        frame.add(setImageButton2);\n+        frame.add(setImageButton3);\n+        frame.add(setImageButton4);\n+        frame.pack();\n+        return frame;\n+    }\n+}\n+\n+class MyActionListener implements ActionListener {\n+    int id;\n+    String name;\n+\n+    public MyActionListener(int id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        try {\n+            FileDialog filedialog;\n+            if (id == -1 && Objects.equals(name, \"\")) {\n+                filedialog = new FileDialog(FileDialogIconTest.frame);\n+            } else {\n+                filedialog = new FileDialog(FileDialogIconTest.frame, name, id);\n+            }\n+            if (FileDialogIconTest.image != null) {\n+                filedialog.setIconImage(FileDialogIconTest.image);\n+            }\n+\n+            if (FileDialogIconTest.images != null) {\n+                filedialog.setIconImages(FileDialogIconTest.images);\n+            }\n+            filedialog.setVisible(true);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/FileDialogIconTest.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T1.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b1.gif","status":"copied"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T2.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b1p.gif","status":"copied"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T3.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b2.gif","status":"copied"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T4.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b3.gif","status":"copied"},{"filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/loading-msg.gif","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Event;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.TextField;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+\n+\/*\n+ * @test\n+ * @bug 4293697 4416433 4417139 4409600\n+ * @summary Test to verify that user filter always gets called on changing the\n+ *          directory in FileDialog\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogUserFilterTest\n+ *\/\n+\n+public class FileDialogUserFilterTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                        1. Enter a mask into the <filter> field, a directory into\n+                           the <directory> field (or leave the default values).\n+                        2. Then click the <Load> button, file dialog will appear.\n+                           Output of the user filter will be shown in the output\n+                           area. Enter several different directories to the file dialog\n+                           via double-clicking on the directory list. The output\n+                           area should show some filtering output on each directory\n+                           change. If any output was only given on dialog startup,\n+                           the test is FAILED.\n+                        3. Look at the list of files accepted by the filter.\n+                           If some files do not match the filter,\n+                           the test is FAILED.\n+                        4. Open dialog with an empty filter.\n+                           Enter some directories with a lot of files (like \/usr\/bin).\n+                           If dialog crashes the test is FAILED.\n+                           Enter the directory that contain files and other directories.\n+                           If the directories are shown in the files box along with files\n+                           then the test is FAILED.\n+                        5. Click in checkbox 'do not use filter', make it checked.\n+                           Open dialog, enter the directory with some files.\n+                           If no files is shown in the File list box (while you are sure\n+                           there are some files there) the test is FAILED\n+                           Otherwise it is PASSED.\"\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(new DialogFilterTest())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class DialogFilterTest extends Frame implements FilenameFilter {\n+    FileDialog fd;\n+    static TextField tfDirectory = new TextField();\n+    static TextField tfFile = new TextField();\n+    static TextField tfFilter = new TextField();\n+    static Checkbox useFilterCheck = new Checkbox(\"do not use filter\");\n+\n+    public DialogFilterTest() {\n+        setTitle(\"File Dialog User Filter test\");\n+        add(\"North\", new Button(\"Load\"));\n+        Panel p = new Panel();\n+        p.setLayout(new GridBagLayout());\n+        addRow(p, new Label(\"directory:\", Label.RIGHT), tfDirectory);\n+        addRow(p, new Label(\"file:\", Label.RIGHT), tfFile);\n+        addRow(p, new Label(\"filter:\", Label.RIGHT), tfFilter);\n+        addRow(p, new Label(\"\"), useFilterCheck);\n+        tfFilter.setText(\".java\");\n+        tfDirectory.setText(\".\");\n+        add(\"Center\", p);\n+        setSize(300, 200);\n+    }\n+\n+    static void addRow(Container cont, Component c1, Component c2) {\n+        GridBagLayout gbl = (GridBagLayout) cont.getLayout();\n+        GridBagConstraints c = new GridBagConstraints();\n+        c.fill = GridBagConstraints.BOTH;\n+        cont.add(c1);\n+        gbl.setConstraints(c1, c);\n+\n+        c.gridwidth = GridBagConstraints.REMAINDER;\n+        c.weightx = 1.0;\n+        cont.add(c2);\n+        gbl.setConstraints(c2, c);\n+    }\n+\n+    public boolean accept(File dir, String name) {\n+        System.out.println(\"File \" + dir + \" String \" + name);\n+        if (fd.getMode() == FileDialog.LOAD) {\n+            return name.lastIndexOf(tfFilter.getText()) > 0;\n+        }\n+        return true;\n+    }\n+\n+    public boolean action(Event evt, Object what) {\n+        boolean load = \"Load\".equals(what);\n+\n+        if (load || \"Save\".equals(what)) {\n+            fd = new FileDialog(new Frame(), null,\n+                    load ? FileDialog.LOAD : FileDialog.SAVE);\n+            fd.setDirectory(tfDirectory.getText());\n+            fd.setFile(tfFile.getText());\n+            if (!useFilterCheck.getState()) {\n+                fd.setFilenameFilter(this);\n+            }\n+            fd.setVisible(true);\n+            tfDirectory.setText(fd.getDirectory());\n+            tfFile.setText(fd.getFile());\n+\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogUserFilterTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+\n+\/*\n+ * @test\n+ * @bug 4779118\n+ * @summary Tests that FileDialog with wrong initial file name\n+ *          doesn't crash when Open button is pressed.\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogWrongNameCrash\n+ *\/\n+\n+public class FileDialogWrongNameCrash {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                (This is Windows only test)\n+                1. You should see a frame 'Frame' with button 'Load'. Press button.\",\n+                2. You should see 'Load file' dialog, select any file and press 'Open'\",\n+                   (not 'Cancel'!!!). If Java doesn't crash - press PASS, else FAIL\n+                    \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame initialize() {\n+        Frame frame = new Frame(\"File Dialog Wrong Name Crash Test\");\n+        Button fileButton = new Button(\"Load\");\n+        fileButton.addActionListener(new java.awt.event.ActionListener() {\n+            public void actionPerformed(java.awt.event.ActionEvent e) {\n+                final java.awt.FileDialog selector =\n+                        new java.awt.FileDialog(frame);\n+                selector.setFile(\"Z:\\\\O2 XDA\\\\LogiTest\\\\\\\\Testcase.xml\");\n+                selector.setVisible(true);\n+            }\n+        });\n+        frame.add(fileButton);\n+        frame.setSize(100, 60);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogWrongNameCrash.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Window;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4168481\n+ * @summary Test to verify Dialog getLocation() regression on Solaris\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual GetLocationTest_1\n+ *\/\n+\n+public class GetLocationTest_1 {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Click in in the blue square and the yellow window should come\n+                   up with the top left by the cursor\n+                2. If you see this correct behavior press PASS. If you see that\n+                   the yellow window location is offset by some inset, press FAIL\n+                   \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Dialog initialize() {\n+        Frame f = new Frame(\"Owner Frame\");\n+        ColorComponent blue = new ColorComponent();\n+        blue.setBackground(Color.blue);\n+        blue.setSize(50, 50);\n+\n+        final Dialog dialog = new Dialog(f, \"GetLocation test\");\n+        dialog.setLocation(300, 300);\n+        System.out.println(\"Dialog location = \" + dialog.getLocation());\n+        blue.setLocation(50, 50);\n+        dialog.setLayout(null);\n+        dialog.add(blue);\n+        dialog.setSize(200, 200);\n+\n+        final ColorWindow w = new ColorWindow(f);\n+        w.setSize(50, 50);\n+        w.setBackground(Color.yellow);\n+\n+        blue.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent e) {\n+                PassFailJFrame.log(\"Dialog location = \" + dialog.getLocation());\n+                Point p = e.getPoint();\n+                Component c = e.getComponent();\n+                PassFailJFrame.log(\"Position = \" + p);\n+                convertPointToScreen(p, c);\n+                PassFailJFrame.log(\"Converted to = \" + p);\n+                w.setLocation(p.x, p.y);\n+                w.setVisible(true);\n+            }\n+        });\n+        return dialog;\n+    }\n+\n+    static class ColorComponent extends Component {\n+        public void paint(Graphics g) {\n+            g.setColor(getBackground());\n+            Rectangle bounds = getBounds();\n+            g.fillRect(0, 0, bounds.width, bounds.height);\n+        }\n+    }\n+\n+    static class ColorWindow extends Window {\n+        ColorWindow(Frame f) {\n+            super(f);\n+        }\n+\n+        public void paint(Graphics g) {\n+            g.setColor(getBackground());\n+            Rectangle bounds = getBounds();\n+            g.fillRect(0, 0, bounds.width, bounds.height);\n+        }\n+    }\n+\n+    public static void convertPointToScreen(Point p, Component c) {\n+        do {\n+            Point b = c.getLocation();\n+            PassFailJFrame.log(\"Adding \" + b + \" for \" + c);\n+            p.x += b.x;\n+            p.y += b.y;\n+\n+            if (c instanceof java.awt.Window) {\n+                break;\n+            }\n+            c = c.getParent();\n+        } while (c != null);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/GetLocationTest_1.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4048664 4065506 4122094 4171979\n+ * @summary Test if Dialog can be successfully hidden, see that no other app\n+ *          comes to front, see if hide + dispose causes assertion failure\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual HideDialogTest\n+ *\/\n+\n+public class HideDialogTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. A Frame should appear with a \"test\" button in it\n+                2. Click on the \"test\" button. A Dialog will appear with a \"dismiss\" button\n+                   and a \"dismiss-with-dispose\" button\n+                3. First, click on the \"dismiss-with-dispose\" button. Verify that\n+                   no assertion failure appears.\n+                4. Now, click on the \"dismiss\" button. The Dialog should go away.\n+                5. Repeat from (2) 10-20 times.\n+                6. When the dialog goes away check that the frame window does not briefly\n+                   get obscured by another app or repaint it's entire area. There should be\n+                   no flicker at all in areas obscured by the dialog. (4065506 4122094)\n+                   If there is the test fails.\n+                7. If the Dialog is successfully hidden each time, the test passed.  If the\n+                   Dialog did not hide, the test failed (4048664).\n+\n+                NOTE: When the dialog does not go away (meaning the bug has manifested itself),\n+                the \"dismiss-with-dispose\" button can be used to get rid of it.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(new MyFrame())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class MyDialog extends Dialog {\n+    public MyDialog(Frame f) {\n+        super(f, \"foobar\", true);\n+        setSize(200, 200);\n+        setLayout(new BorderLayout());\n+        Panel p = new Panel();\n+        p.setLayout(new FlowLayout(FlowLayout.CENTER));\n+        Button okButton;\n+        okButton = new Button(\"dismiss\");\n+        p.add(okButton);\n+        okButton.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                System.out.println(\"Calling setVisible(false)\");\n+                setVisible(false);\n+            }\n+        });\n+        Button newButton;\n+        p.add(newButton = new Button(\"dismiss-with-dispose\"));\n+        newButton.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                System.out.println(\"Calling setVisible(false) + dispose()\");\n+                setVisible(false);\n+                dispose();\n+            }\n+        });\n+        add(\"South\", p);\n+        pack();\n+    }\n+}\n+\n+class MyFrame extends Frame implements ActionListener {\n+    public MyFrame() {\n+        super();\n+        setSize(600, 400);\n+        setTitle(\"HideDialogTest\");\n+        setLayout(new BorderLayout());\n+        Panel toolbar = new Panel();\n+        toolbar.setLayout(new FlowLayout(FlowLayout.LEFT));\n+        Button testButton = new Button(\"test\");\n+        testButton.addActionListener(this);\n+        toolbar.add(testButton);\n+        add(\"North\", toolbar);\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        String s = e.getActionCommand();\n+        if (s.equals(\"test\")) {\n+            System.out.println(\"Begin test\");\n+            MyDialog d = new MyDialog(this);\n+            d.setVisible(true);\n+            System.out.println(\"End test\");\n+        }\n+    }\n+\n+    public void paint(Graphics g) {\n+        for (int i = 0; i < 10; i++) {\n+            g.setColor(Color.red);\n+            g.fillRect(0, 0, 2000, 2000);\n+            g.setColor(Color.blue);\n+            g.fillRect(0, 0, 2000, 2000);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/HideDialogTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+\n+\/*\n+ * @test\n+ * @bug 4078176\n+ * @summary Test to verify Modal dialogs don't act modal if addNotify()\n+ *          is called before setModal(true).\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ModalDialogTest\n+ *\/\n+\n+public class ModalDialogTest implements ActionListener {\n+    public boolean modal = true;\n+    Button closeBtn = new Button(\"Close me\");\n+    Button createBtn = new Button(\"Create Dialog\");\n+    Button createNewBtn = new Button(\"Create Modal Dialog\");\n+    Button lastBtn = new Button(\"Show Last Dialog\");\n+    Dialog dialog;\n+    Dialog newDialog;\n+    Frame testFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Use 'Modal' checkbox to select which dialog you're\n+                   going to create - modal or non-modal.\n+                   (this checkbox affects only new created dialog but\n+                   not existing one)\n+                2. Use 'Create Dialog' button to create a dialog.\n+                   If you have selected 'Modal' checkbox then dialog has to\n+                   be created modal - you can make sure of that clicking\n+                   on any other control (i.e. 'Modal' checkbox) - they\n+                   should not work.\n+                3. Use 'Show Last Dialog' button to bring up last\n+                   created dialog - to make sure that if you show\/hide\n+                   modal dialog several times it stays modal.\n+                4. On the appearing dialog there are two buttons:\n+                   'Close Me' which closes the dialog,\n+                   and 'Create Modal Dialog' which creates one more\n+                   MODAL dialog just to make sure that\n+                   in situation with two modal dialogs all is fine.\n+                5. If created modal dialogs are really modal\n+                   (which means that they blocks the calling app)\n+                   then test is PASSED, otherwise it's FAILED.\"\n+                                 \"\"\";\n+        ModalDialogTest test = new ModalDialogTest();\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(test.initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public Frame initialize() {\n+        testFrame = new Frame(\"Parent Frame\");\n+        Frame frame = new Frame(\"Modal Dialog test\");\n+        Panel panel = new Panel();\n+        panel.setLayout(new BorderLayout());\n+\n+        createBtn.addActionListener(this);\n+        createNewBtn.addActionListener(this);\n+        closeBtn.addActionListener(this);\n+        lastBtn.addActionListener(this);\n+        panel.add(\"Center\", createBtn);\n+        panel.add(\"South\", lastBtn);\n+        Checkbox cb = new Checkbox(\"Modal\", modal);\n+        cb.addItemListener(new ItemListener() {\n+            public void itemStateChanged(ItemEvent e) {\n+                modal = ((Checkbox) e.getSource()).getState();\n+            }\n+        });\n+        panel.add(\"North\", cb);\n+        panel.setSize(200, 100);\n+\n+        frame.add(panel);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        if (e.getSource() == createBtn) {\n+            if (dialog != null) {\n+                dialog.dispose();\n+            }\n+            dialog = new Dialog(testFrame, \"Modal Dialog\");\n+            dialog.add(\"North\", closeBtn);\n+            dialog.add(\"South\", createNewBtn);\n+            createBtn.setEnabled(false);\n+            dialog.pack();\n+            dialog.setModal(modal);\n+            dialog.setVisible(true);\n+        } else if (e.getSource() == closeBtn && dialog != null) {\n+            createBtn.setEnabled(true);\n+            dialog.setVisible(false);\n+        } else if (e.getSource() == lastBtn && dialog != null) {\n+            dialog.setVisible(true);\n+        } else if (e.getSource() == createNewBtn && newDialog == null) {\n+            newDialog = new Dialog(testFrame, \"New Modal Dialog\");\n+            Button clsBtn = new Button(\"Close Me\");\n+            clsBtn.addActionListener(new ActionListener() {\n+                public void actionPerformed(ActionEvent e) {\n+                    newDialog.dispose();\n+                    newDialog = null;\n+                }\n+            });\n+            newDialog.add(\"North\", clsBtn);\n+            newDialog.pack();\n+            newDialog.setModal(true);\n+            newDialog.setVisible(true);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/ModalDialogTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4212687\n+ * @summary Verifies that calling EventQueue.push() and EventQueue.pop()\n+ *          does not deadlock.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PushPopDeadlock\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+\n+public class PushPopDeadlock {\n+    static int counter = 0;\n+    static Robot robot;\n+    static Frame f;\n+    static Label l;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        String INSTRUCTIONS = \"\"\"\n+                Click rapidly in the Frame labeled 'Click Here!'.\n+                The number in the Frame should continue to increase. If the number\n+                stops increasing (remains at a constant value), the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame pfJFrame = PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(PushPopDeadlock::createUI)\n+                .build();\n+        PushPopDeadlock.test();\n+        pfJFrame.awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        f = new Frame(\"Click Here!\");\n+        l = new Label(\"Counter: \" + counter);\n+        f.add(l);\n+        f.setSize(200, 200);\n+        return f;\n+    }\n+\n+    public static void test() {\n+        EventQueue q = new EventQueue() {\n+            public void push(EventQueue queue) {\n+                super.push(queue);\n+                pop();\n+            }\n+        };\n+        EventQueue q2 = new EventQueue();\n+\n+        Toolkit.getDefaultToolkit().getSystemEventQueue().push(q);\n+\n+        new Thread(() -> {\n+            while (true) {\n+                robot.delay(500);\n+                l.setText(\"Counter: \" + ++counter);\n+                q.push(q2);\n+                try {\n+                    Thread.currentThread().sleep(500);\n+                } catch (InterruptedException e) {\n+                    return;\n+                }\n+            }\n+        }).start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/EventQueue\/PushPopDeadlock\/PushPopDeadlock.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.Robot;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4159883\n+ * @summary Adding\/Removing a menu causes frame to unexpected small size\n+ * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ *\/\n+\n+public class AddRemoveMenuBarTest_5 {\n+\n+    static Frame frame;\n+    static MenuBar menu;\n+    static Button btnAdd, btnRemove;\n+    static Dimension oldSize;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        try {\n+            EventQueue.invokeAndWait(AddRemoveMenuBarTest_5::initAndShowGui);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                oldSize = frame.getSize();\n+                changeMenubar(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                checkSize();\n+                changeMenubar(false);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            EventQueue.invokeAndWait(AddRemoveMenuBarTest_5::checkSize);\n+        } finally {\n+            EventQueue.invokeAndWait(frame::dispose);\n+        }\n+    }\n+\n+    public static void initAndShowGui() {\n+        frame = new Frame();\n+        frame.setLocationRelativeTo(null);\n+        frame.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowOpened(WindowEvent e) {\n+                System.out.println(\"Frame size:\" + frame.getSize().toString());\n+                System.out.println(\"Button size:\" + btnAdd.getSize().toString());\n+            }\n+        });\n+        frame.add(\"West\", btnAdd = new Button(\"TRY:ADD\"));\n+        frame.add(\"East\", btnRemove = new Button(\"TRY:REMOVE\"));\n+\n+\n+        btnAdd.addActionListener((e) -> changeMenubar(true));\n+        btnRemove.addActionListener((e) -> changeMenubar(false));\n+        frame.setSize(500, 100);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void changeMenubar(boolean enable) {\n+        if (enable) {\n+            menu = new MenuBar();\n+            menu.add(new Menu(\"BAAAAAAAAAAAAAAA\"));\n+            menu.add(new Menu(\"BZZZZZZZZZZZZZZZ\"));\n+            menu.add(new Menu(\"BXXXXXXXXXXXXXXX\"));\n+        } else {\n+            menu = null;\n+        }\n+        frame.setMenuBar(menu);\n+        frame.invalidate();\n+        frame.validate();\n+\n+        System.out.println(\"Frame size:\" + frame.getSize().toString());\n+        System.out.println(\"Button size:\" + btnAdd.getSize().toString());\n+    }\n+\n+    private static void checkSize() {\n+        Dimension newSize = frame.getSize();\n+        if (!oldSize.equals(newSize)) {\n+            throw new RuntimeException(\"Frame size changed: old %s new %s\"\n+                    .formatted(oldSize, newSize));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/AddRemoveMenuBarTest_5.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Window;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4140293\n+ * @summary Tests that focus is returned to the correct Component when a Frame\n+ *          is reactivated.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FocusTest\n+ *\/\n+\n+public class FocusTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+              Click on the bottom rectangle. Move the mouse slightly.\n+              A focus rectangle should appear around the bottom rectangle.\n+\n+              Now, deactivate the window and then reactivate it.\n+              (You would click on the caption bar of another window,\n+              and then on the caption bar of the FocusTest Frame.)\n+\n+              If the focus rectangle appears again, the test passes.\n+              If it does not appear, or appears around the top rectangle,\n+              the test fails.\n+              \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FocusTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .logArea(6)\n+                .testUI(FocusTest::createAndShowUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createAndShowUI() {\n+        Frame frame = new Frame(\"FocusTest\");\n+\n+        frame.add(new FocusTestPanel());\n+        frame.setSize(400, 400);\n+\n+        frame.addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent e) {\n+                frame.dispose();\n+            }\n+        });\n+\n+        frame.validate();\n+        return frame;\n+    }\n+\n+    private static class FocusTestPanel extends Panel {\n+        PassiveClient pc1 = new PassiveClient(\"pc1\");\n+        PassiveClient pc2 = new PassiveClient(\"pc2\");\n+\n+        public FocusTestPanel() {\n+            super();\n+            setLayout(new GridLayout(2, 1, 10, 10));\n+            add(pc1);\n+            add(pc2);\n+        }\n+    }\n+\n+    private static class PassiveClient extends Canvas implements FocusListener {\n+        boolean haveFocus = false;\n+        final String name;\n+\n+        PassiveClient(String name) {\n+            super();\n+            this.name = name;\n+            setSize(400, 100);\n+            setBackground(Color.cyan);\n+            setVisible(true);\n+            setEnabled(true);\n+            addMouseListener(new MouseAdapter() {\n+                @Override\n+                public void mouseClicked(MouseEvent e) {\n+                    requestFocus();\n+                }\n+            });\n+            addFocusListener(this);\n+        }\n+\n+        public void paint(Graphics g) {\n+            g.setColor(getBackground());\n+            Dimension size = getSize();\n+            g.fillRect(0, 0, size.width, size.height);\n+            if (haveFocus) {\n+                g.setColor(Color.black);\n+                g.drawRect(0, 0, size.width - 1, size.height - 1);\n+                g.drawRect(1, 1, size.width - 3, size.height - 3);\n+            }\n+            g.setColor(getForeground());\n+        }\n+\n+        public void focusGained(FocusEvent event) {\n+            haveFocus = true;\n+            paint(getGraphics());\n+            PassFailJFrame.log(\"<<<< %s Got focus!! %s>>>>\".formatted(this, event));\n+        }\n+\n+        public void focusLost(FocusEvent event) {\n+            haveFocus = false;\n+            paint(getGraphics());\n+            PassFailJFrame.log(\"<<<< %s Lost focus!! %s>>>>\".formatted(this, event));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"PassiveClient \" + name;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FocusTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 1231233\n+ * @summary  Tests whether the resizable property of a Frame is\n+ *           respected after it is set.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameResizableTest\n+ *\/\n+\n+public class FrameResizableTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            There is a frame with two buttons and a label.  The label\n+            reads 'true' or 'false' to indicate whether the frame can be\n+            resized or not.\n+\n+            When the first button, 'Set Resizable', is\n+            clicked, you should be able to resize the frame.\n+            When the second button, 'UnSet Resizable', is clicked, you should\n+            not be able to resize the frame.\n+\n+            A frame is resized in a way which depends upon the window manager (WM) running.\n+            You may resize the frame by dragging the corner resize handles or the borders,\n+            or you may use the title bar's resize menu items and buttons.\n+\n+            Upon test completion, click Pass or Fail appropriately.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FrameResizableTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(50)\n+                .testUI(FrameResizable::new)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static class FrameResizable extends Frame {\n+        Label label;\n+        Button buttonResizable;\n+        Button buttonNotResizable;\n+\n+        public FrameResizable() {\n+            super(\"FrameResizable\");\n+            setResizable(false);\n+            Panel panel = new Panel();\n+\n+            add(\"North\", panel);\n+            ActionListener actionListener = (e) -> {\n+                if (e.getSource() == buttonResizable) {\n+                    setResizable(true);\n+                } else if (e.getSource() == buttonNotResizable) {\n+                    setResizable(false);\n+                }\n+                label.setText(\"Resizable: \" + isResizable());\n+            };\n+\n+            panel.add(buttonResizable = new Button(\"Set Resizable\"));\n+            panel.add(buttonNotResizable = new Button(\"UnSet Resizable\"));\n+            panel.add(label = new Label(\"Resizable: \" + isResizable()));\n+            buttonResizable.addActionListener(actionListener);\n+            buttonNotResizable.addActionListener(actionListener);\n+\n+            setSize(400, 200);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameResizableTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Window;\n+\n+\/*\n+ * @test\n+ * @bug 6269884 4929291\n+ * @summary Tests that title which contains mix of non-English characters is displayed correctly\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual I18NTitle\n+ *\/\n+\n+public class I18NTitle {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            You will see a frame with some title (S. Chinese, Cyrillic and German).\n+            Please check if non-English characters are visible and compare\n+            the visible title with the same string shown in the label\n+            (it should not look worse than the label).\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"I18NTitle Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(50)\n+                .testUI(I18NTitle::createAndShowGUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createAndShowGUI() {\n+        String s = \"\\u4e2d\\u6587\\u6d4b\\u8bd5 \\u0420\\u0443\\u0441\\u0441\\u043a\\u0438\\u0439 Zur\\u00FCck\";\n+        Frame frame = new Frame(s);\n+        frame.setLayout(new BorderLayout());\n+        Label l = new Label(s);\n+        frame.add(l);\n+        frame.setSize(400, 100);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/I18NTitle.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -53,0 +53,2 @@\n+    private static final StringBuilder FAILURES = new StringBuilder();\n+\n@@ -55,1 +57,0 @@\n-\n@@ -57,1 +58,1 @@\n-            EventQueue.invokeAndWait(InitialIconifiedTest::initAndShowGui);\n+            EventQueue.invokeAndWait(InitialIconifiedTest::initAndShowBackground);\n@@ -60,1 +61,3 @@\n-            test();\n+\n+            test(false);\n+            test(true);\n@@ -67,0 +70,28 @@\n+\n+        if (!FAILURES.isEmpty()) {\n+            throw new RuntimeException(FAILURES.toString());\n+        }\n+    }\n+\n+    private static void test(boolean isUndecorated) throws Exception {\n+        String prefix = isUndecorated ? \"undecorated\" : \"decorated\";\n+\n+        EventQueue.invokeAndWait(() -> initAndShowTestedFrame(isUndecorated));\n+        \/\/ On macos, we can observe the animation of the window from the initial\n+        \/\/ NORMAL state to the ICONIFIED state,\n+        \/\/ even if the window was created in the ICONIFIED state.\n+        \/\/ The following delay is commented out to capture this animation\n+        \/\/ robot.waitForIdle();\n+        \/\/ robot.delay(500);\n+        if (!testIfIconified(prefix + \"_no_extra_delay\")) {\n+            FAILURES.append(\"Case %s frame with no extra delay failed\\n\"\n+                    .formatted(isUndecorated ? \"undecorated\" : \"decorated\"));\n+        }\n+\n+        EventQueue.invokeAndWait(() -> initAndShowTestedFrame(isUndecorated));\n+        robot.waitForIdle();\n+        robot.delay(500);\n+        if (!testIfIconified(prefix + \"_with_extra_delay\")) {\n+            FAILURES.append(\"Case %s frame with extra delay failed\\n\"\n+                    .formatted(isUndecorated ? \"undecorated\" : \"decorated\"));\n+        }\n@@ -69,1 +100,1 @@\n-    private static void initAndShowGui() {\n+    private static void initAndShowBackground() {\n@@ -75,0 +106,1 @@\n+    }\n@@ -76,0 +108,4 @@\n+    private static void initAndShowTestedFrame(boolean isUndecorated) {\n+        if (testedFrame != null) {\n+            testedFrame.dispose();\n+        }\n@@ -77,0 +113,3 @@\n+        if (isUndecorated) {\n+            testedFrame.setUndecorated(true);\n+        }\n@@ -82,1 +121,1 @@\n-    private static void test() {\n+    private static boolean testIfIconified(String prefix) {\n@@ -91,1 +130,1 @@\n-                                new File(\"failure.png\"));\n+                                new File(prefix + \"_failure.png\"));\n@@ -93,1 +132,1 @@\n-                    throw new RuntimeException(\"Test failed\");\n+                    return false;\n@@ -97,0 +136,1 @@\n+        return true;\n","filename":"test\/jdk\/java\/awt\/Frame\/InitialIconifiedTest.java","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+\n+\/*\n+ * @test\n+ * @bug 4180577\n+ * @summary offset problems with menus in frames: (2 * 1)  should be (2 * menuBarBorderSize)\n+ * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MenuBarOffsetTest\n+*\/\n+\n+public class MenuBarOffsetTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            If a menubar containing a menubar item labeled Test appears.\n+            in a frame, and fits within the frame, press Pass, else press Fail.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"MenuBarOffsetTest Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(FrameTest::new)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static class FrameTest extends Frame {\n+        public FrameTest() {\n+            super(\"MenuBarOffsetTest FrameTest\");\n+            MenuBar m = new MenuBar();\n+            setMenuBar(m);\n+            Menu test = m.add(new Menu(\"Test\"));\n+            test.add(\"1\");\n+            test.add(\"2\");\n+            setSize(100, 100);\n+        }\n+\n+        public void paint(Graphics g) {\n+            setForeground(Color.red);\n+            Insets i = getInsets();\n+            Dimension d = getSize();\n+            System.err.println(getBounds());\n+            System.err.println(\"\" + i);\n+\n+            g.drawRect(i.left, i.top,\n+                    d.width - i.left - i.right - 1,\n+                    d.height - i.top - i.bottom - 1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MenuBarOffsetTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 1256759\n+ * @summary Checks that Frames with a very small size don't cause Motif\n+ * to generate VendorShells which consume the entire desktop.\n+ *\/\n+\n+public class MinimumSizeTest {\n+\n+    private static final Color BG_COLOR = Color.RED;\n+    private static Frame backgroundFrame;\n+    private static Frame testedFrame;\n+\n+    private static Robot robot;\n+    private static final Point location = new Point(200, 200);\n+    private static final Point[] testPointLocations = {\n+            new Point(100, 200),\n+            new Point(200, 100),\n+            new Point(450, 210),\n+            new Point(210, 350),\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+\n+        try {\n+            EventQueue.invokeAndWait(MinimumSizeTest::initAndShowGui);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            test();\n+            System.out.println(\"Test passed.\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                backgroundFrame.dispose();\n+                testedFrame.dispose();\n+            });\n+        }\n+    }\n+\n+    private static void test() {\n+        for (Point testLocation : testPointLocations) {\n+            Color pixelColor = robot.getPixelColor(testLocation.x, testLocation.y);\n+\n+            if (!pixelColor.equals(BG_COLOR)) {\n+                Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+                BufferedImage screenCapture = robot.createScreenCapture(new Rectangle(screenSize));\n+                try {\n+                    ImageIO.write(screenCapture, \"png\", new File(\"failure.png\"));\n+                } catch (IOException ignored) {}\n+                throw new RuntimeException(\"Pixel color does not match expected color %s at %s\"\n+                        .formatted(pixelColor, testLocation));\n+            }\n+        }\n+    }\n+\n+    private static void initAndShowGui() {\n+        backgroundFrame = new Frame(\"MinimumSizeTest background\");\n+        backgroundFrame.setUndecorated(true);\n+        backgroundFrame.setBackground(BG_COLOR);\n+        backgroundFrame.setBounds(new Rectangle(Toolkit.getDefaultToolkit().getScreenSize()));\n+        backgroundFrame.setVisible(true);\n+\n+        testedFrame = new MinimumSizeTestFrame();\n+        testedFrame.setVisible(true);\n+    }\n+\n+    private static class MinimumSizeTestFrame extends Frame {\n+        public MinimumSizeTestFrame() {\n+            super(\"MinimumSizeTest\");\n+            setVisible(true);\n+            setBackground(Color.BLUE);\n+            setSize(0, 0);\n+            setLocation(location);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/MinimumSizeTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Label;\n+import java.awt.Rectangle;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4473671\n+ * @summary Test to verify GraphicsEnvironment.getDefaultScreenDevice always\n+ *          returning first screen\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DefaultScreenDeviceTest\n+ *\/\n+\n+public class DefaultScreenDeviceTest {\n+    private static Frame testFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        GraphicsEnvironment ge = GraphicsEnvironment.\n+                getLocalGraphicsEnvironment();\n+        GraphicsDevice[] gds = ge.getScreenDevices();\n+        if (gds.length < 2) {\n+            System.out.println(\"Test requires at least 2 displays\");\n+            return;\n+        }\n+\n+        String INSTRUCTIONS = \"\"\"\n+                1. The test is for systems which allows primary display\n+                   selection in multiscreen systems.\n+                   Set the system primary screen to be the rightmost\n+                   (i.e. the right screen in two screen configuration)\n+                   This can be done by going to OS Display Settings\n+                   selecting the screen and checking the 'Use this device\n+                   as primary monitor' checkbox.\n+                2. When done, click on 'Frame on Primary Screen' button and\n+                   see where the frame will pop up\n+                3. If Primary Frame pops up on the primary display,\n+                   the test passed, otherwise it failed\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static List<Frame> initialize() {\n+        Frame frame = new Frame(\"Default screen device test\");\n+        GraphicsConfiguration gc =\n+                GraphicsEnvironment.getLocalGraphicsEnvironment().\n+                        getDefaultScreenDevice().getDefaultConfiguration();\n+\n+        testFrame = new Frame(\"Primary screen frame\", gc);\n+        frame.setLayout(new BorderLayout());\n+        frame.setSize(200, 200);\n+\n+        Button b = new Button(\"Frame on Primary Screen\");\n+        b.addActionListener(e -> {\n+            if (testFrame != null) {\n+                testFrame.setVisible(false);\n+                testFrame.dispose();\n+            }\n+\n+            testFrame.addWindowListener(new WindowAdapter() {\n+                public void windowClosing(WindowEvent e1) {\n+                    testFrame.setVisible(false);\n+                    testFrame.dispose();\n+                }\n+            });\n+            testFrame.add(new Label(\"This frame should be on the primary screen\"));\n+            testFrame.setBackground(Color.red);\n+            testFrame.pack();\n+            Rectangle rect = gc.getBounds();\n+            testFrame.setLocation(rect.x + 100, rect.y + 100);\n+            testFrame.setVisible(true);\n+        });\n+        frame.add(b);\n+        return List.of(testFrame, frame);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/GraphicsEnvironment\/DefaultScreenDeviceTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4058400\n+ * @summary Tests that calling addNotify on a lightweight component more than\n+ *          once does not break event dispatching for that component.\n+ * @key headful\n+ * @run main MultipleAddNotifyTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class MultipleAddNotifyTest {\n+    static volatile boolean passFlag;\n+    static volatile int posX;\n+    static volatile int posY;\n+    static Frame f;\n+    static LightComponent l;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot r;\n+        try {\n+            r = new Robot();\n+            r.setAutoWaitForIdle(true);\n+            passFlag = false;\n+\n+            EventQueue.invokeAndWait(() -> {\n+                f = new Frame(\"Multiple addNotify Test\");\n+                l = new LightComponent();\n+                f.setLayout(new FlowLayout());\n+                l.addMouseListener(new MouseAdapter() {\n+                    @Override\n+                    public void mouseClicked(MouseEvent e) {\n+                        System.out.println(\"Mouse Clicked\");\n+                        passFlag = true;\n+                    }\n+                });\n+                f.add(l);\n+                f.addNotify();\n+                f.addNotify();\n+\n+                if (!l.isVisible()) {\n+                    throw new RuntimeException(\"Test failed. LW Component \" +\n+                            \"not visible.\");\n+                }\n+                f.setSize(200, 200);\n+                f.setLocationRelativeTo(null);\n+                f.setVisible(true);\n+            });\n+            r.waitForIdle();\n+            r.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                posX = f.getX() + l.getWidth() + (l.getWidth() \/ 2);\n+                posY = f.getY() + l.getHeight();\n+            });\n+\n+            r.mouseMove(posX, posY);\n+            r.delay(500);\n+\n+            r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            r.delay(500);\n+\n+            if (!passFlag) {\n+                throw new RuntimeException(\"Test failed. MouseClicked event \" +\n+                        \"not working properly.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+class LightComponent extends Component {\n+    public void paint(Graphics g) {\n+        setSize(100, 100);\n+        Dimension d = getSize();\n+        g.setColor(Color.red);\n+        g.fillRect(0, 0, d.width, d.height);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/LightweightComponent\/MultipleAddNotifyTest\/MultipleAddNotifyTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4476083\n+ * @summary Disabled components do not receive MouseEvent in Popups\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PopupTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Frame;\n+\n+import javax.swing.JButton;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+\n+public class PopupTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                PopupMenus should disappear when a disabled component is\n+                clicked.\n+\n+                Step 1. Pop down the popup menu by clicking on it.\n+                Step 2. Click on the disabled component to make the menu\n+                disappear.\n+\n+                If the menu disappears when the disabled component is clicked,\n+                the test passes, otherwise, the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(PopupTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"Disabled Component in Popup Test\");\n+        f.setLayout(new BorderLayout());\n+\n+        JButton b = new JButton(\"step 1: press me to display menu\");\n+        b.addActionListener(e -> {\n+            JPopupMenu m = new JPopupMenu();\n+            m.add(new JMenuItem(\"item 1\"));\n+            m.add(new JMenuItem(\"item 2\"));\n+            m.add(new JMenuItem(\"item 3\"));\n+            m.add(new JMenuItem(\"item 4\"));\n+            m.add(new JMenuItem(\"item 5\"));\n+            m.add(new JMenuItem(\"item 6\"));\n+            m.show((Component) e.getSource(), 0, 10);\n+        });\n+\n+        JLabel disabled = new JLabel(\"step 2: click me. the menu should be \" +\n+                \"dismissed\");\n+        disabled.setEnabled(false);\n+\n+        JLabel enabled = new JLabel(\"step 3: there is no step 3\");\n+\n+        f.add(BorderLayout.NORTH, b);\n+        f.add(BorderLayout.CENTER, disabled);\n+        f.add(BorderLayout.SOUTH, enabled);\n+        f.setSize(300, 200);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/LightweightComponent\/PopupTest\/PopupTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Event;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+\n+\/*\n+ * @test\n+ * @bug 4092370\n+ * @summary Test to verify double click\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DoubleClickTest\n+ *\/\n+\n+public class DoubleClickTest {\n+    static TextArea ta = new TextArea(\"\", 10, 40);\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Double click on the red area.\n+                2. Verify that the event reports click_count > 1 on\n+                   Double-Click. If click_count shows only 1 for every\n+                   Double-Clicks then test FAILS, else test PASS.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        Frame frame = new Frame(\"Double-click Test\");\n+        frame.setLayout(new BorderLayout());\n+        frame.add(\"East\", new MyPanel(ta));\n+        frame.add(\"West\", ta);\n+        frame.setSize(200, 200);\n+        return frame;\n+    }\n+}\n+\n+class MyPanel extends Panel {\n+    TextArea ta;\n+\n+    MyPanel(TextArea ta) {\n+        this.ta = ta;\n+        setBackground(Color.red);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(50, 50);\n+    }\n+\n+\n+    public boolean mouseDown(Event event, int x, int y) {\n+        ta.append(\"event click count= \" + event.clickCount + \"\\n\");\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/DoubleClickTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.TextArea;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4199397\n+ * @summary Test to mouse click count\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MouseClickCount\n+ *\/\n+\n+public class MouseClickCount {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Clicking on Frame panel quickly will produce clickCount larger than 1\n+                   in the TextArea the count is printed for each mouse click\n+                2. Verify that a left-button click followed by a right button click quickly\n+                   will not generate 1, 2, i.e. it's not considered a double clicking.\n+                 \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame initialize() {\n+        Frame f = new Frame(\"Mouse Click Count Test\");\n+        final TextArea ta = new TextArea();\n+        f.add(\"South\", ta);\n+        f.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent e) {\n+                if (e.getClickCount() == 1) ta.append(\"\\n1\");\n+                else ta.append(\", \" + e.getClickCount());\n+            }\n+        });\n+        f.setSize(300, 500);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseClickCount.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4141361\n+ * @summary Test to Ensures that mouse enter \/ exit is delivered to a new\n+ *          frame or component during a drag\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MouseDragEnterExitTest\n+ *\/\n+\n+public class MouseDragEnterExitTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Click on the blue frame, drag to the white frame, and back\n+                You should get enter\/exit messages for the frames when dragging\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(MouseEvents.initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class MouseEvents extends Frame {\n+    static int WITH_WIDGET = 0;\n+\n+    public MouseEvents(int mode) {\n+        super(\"Mouse Drag Enter\/Exit Test\");\n+        setSize(300, 300);\n+\n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseEntered(MouseEvent e) {\n+                PassFailJFrame.log(\"Frame MOUSE_ENTERED\" + \": \" + \" \" +\n+                        e.getX() + \" \" + e.getY());\n+            }\n+\n+            @Override\n+            public void mouseExited(MouseEvent e) {\n+                PassFailJFrame.log(\"Frame MOUSE_EXITED\" + \": \" + \" \" +\n+                        e.getX() + \" \" + e.getY());\n+            }\n+        });\n+\n+        if (mode == WITH_WIDGET) {\n+            setLayout(new BorderLayout());\n+            add(\"Center\", new SimplePanel());\n+        }\n+    }\n+\n+    public static List<Frame> initialize() {\n+        MouseEvents m = new MouseEvents(MouseEvents.WITH_WIDGET);\n+        m.setLocation(500, 300);\n+        MouseEvents t = new MouseEvents(MouseEvents.WITH_WIDGET + 1);\n+        t.setLocation(200, 200);\n+        return List.of(m, t);\n+    }\n+}\n+\n+class SimplePanel extends Panel {\n+    public SimplePanel() {\n+        super();\n+        setName(\"Test Panel\");\n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseEntered(MouseEvent e) {\n+                PassFailJFrame.log(\"Panel MOUSE_ENTERED\" + \": \" + \" \" +\n+                        e.getX() + \" \" + e.getY());\n+            }\n+\n+            @Override\n+            public void mouseExited(MouseEvent e) {\n+                PassFailJFrame.log(\"Panel MOUSE_EXITED\" + \": \" + \" \" +\n+                        e.getX() + \" \" + e.getY());\n+            }\n+        });\n+        setSize(100, 100);\n+        setBackground(Color.blue);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseDragEnterExitTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionAdapter;\n+import java.awt.event.MouseMotionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4035189\n+ * @summary Test to verify that Drag events go to wrong component\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MouseDragTest\n+ *\/\n+\n+class HeavySquare extends Canvas {\n+    private final Color colorNormal;\n+    private boolean gotADragEvent;\n+\n+    public HeavySquare(Color color) {\n+        colorNormal = color;\n+        setBackground(colorNormal);\n+        new MouseChecker(this);\n+        addMouseMotionListener(new DragAdapter());\n+        addMouseListener(new PressReleaseAdapter());\n+    }\n+\n+    class DragAdapter extends MouseMotionAdapter {\n+        public void mouseDragged(MouseEvent ev) {\n+            if (gotADragEvent)\n+                return;\n+\n+            Point mousePt = ev.getPoint();\n+            Dimension csize = getSize();\n+            boolean inBounds =\n+                    (mousePt.x >= 0 && mousePt.x <= csize.width &&\n+                            mousePt.y >= 0 && mousePt.y <= csize.height);\n+            if (!inBounds) {\n+                setBackground(Color.green);\n+            }\n+            gotADragEvent = true;\n+        }\n+    }\n+\n+    class PressReleaseAdapter extends MouseAdapter {\n+        public void mousePressed(MouseEvent ev) {\n+            gotADragEvent = false;\n+        }\n+\n+        public void mouseReleased(MouseEvent ev) {\n+            setBackground(colorNormal);\n+        }\n+    }\n+\n+    public Dimension preferredSize() {\n+        return new Dimension(50, 50);\n+    }\n+}\n+\n+class MouseFrame extends Frame {\n+    public MouseFrame() {\n+        super(\"MouseDragTest\");\n+        new MouseChecker(this);\n+        setLayout(new FlowLayout());\n+        add(new HeavySquare(Color.red));\n+        add(new HeavySquare(Color.blue));\n+        setBounds(new Rectangle(20, 20, 400, 300));\n+    }\n+}\n+\n+public class MouseDragTest {\n+    static Frame TestFrame;\n+\n+    public MouseDragTest() {\n+        TestFrame = new MouseFrame();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. A frame with two boxes will appear. Click and drag _very_ quickly\n+                   off one of the components. You will know you were quick enough\n+                   when the component you dragged off of turns green\n+                2. Repeat this several times on both boxes, ensuring you get them\n+                   to turn green. The components should revert to their original\n+                   color when you release the mouse\n+                3. The test FAILS if the component doesn't revert to original\n+                   color, else PASS.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(new MouseFrame())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class MouseChecker implements MouseListener, MouseMotionListener {\n+    private boolean isPressed = false;\n+    private MouseEvent evPrev = null;\n+    private MouseEvent evPrevPrev = null;\n+\n+    public MouseChecker(Component comp) {\n+        comp.addMouseListener(this);\n+        comp.addMouseMotionListener(this);\n+    }\n+\n+    private void recordEv(MouseEvent ev) {\n+        evPrevPrev = evPrev;\n+        evPrev = ev;\n+    }\n+\n+    private synchronized void failure(String str) {\n+        PassFailJFrame.forceFail(\"Test Failed : \"+str);\n+    }\n+\n+    public void mouseClicked(MouseEvent ev) {\n+        if (!(evPrev.getID() == MouseEvent.MOUSE_RELEASED &&\n+                evPrevPrev.getID() == MouseEvent.MOUSE_PRESSED)) {\n+            failure(\"Got mouse click without press\/release preceding.\");\n+        }\n+        recordEv(ev);\n+    }\n+\n+    public void mousePressed(MouseEvent ev) {\n+        recordEv(ev);\n+        if (isPressed) {\n+            failure(\"Got two mouse presses without a release.\");\n+        }\n+        isPressed = true;\n+    }\n+\n+    public void mouseReleased(MouseEvent ev) {\n+        recordEv(ev);\n+        if (!isPressed) {\n+            failure(\"Got mouse release without being pressed.\");\n+        }\n+        isPressed = false;\n+    }\n+\n+    public void mouseEntered(MouseEvent ev) {\n+        recordEv(ev);\n+        Point mousePt = ev.getPoint();\n+        Component comp = (Component) ev.getSource();\n+        Dimension size = comp.getSize();\n+        boolean inBounds =\n+                (mousePt.x >= 0 && mousePt.x <= size.width &&\n+                        mousePt.y >= 0 && mousePt.y <= size.height);\n+\n+        if (!inBounds) {\n+            failure(\"Got mouse entered, but mouse not inside component.\");\n+        }\n+    }\n+\n+    public void mouseExited(MouseEvent ev) {\n+        recordEv(ev);\n+        Point mousePt = ev.getPoint();\n+        Component comp = (Component) ev.getSource();\n+        if (comp instanceof Frame) {\n+            return;\n+        }\n+        Dimension size = comp.getSize();\n+        boolean isOnChild = (comp != comp.getComponentAt(mousePt));\n+        boolean inBounds =\n+                (mousePt.x >= 0 && mousePt.x <= size.width &&\n+                        mousePt.y >= 0 && mousePt.y <= size.height);\n+        if (!isOnChild && inBounds) {\n+            failure(\"Got mouse exit, but mouse still inside component.\");\n+        }\n+    }\n+\n+    public void mouseDragged(MouseEvent ev) {\n+        recordEv(ev);\n+        if (!isPressed) {\n+            failure(\"Got drag without a press first.\");\n+        }\n+    }\n+\n+    public void mouseMoved(MouseEvent ev) {\n+        recordEv(ev);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseDragTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Cursor;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Robot;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4050138\n+ * @key headful\n+ * @summary Test to verify Lightweight components don't get\n+ *          enter\/exit during drags\n+ * @run main MouseEnterExitTest\n+ *\/\n+\n+class LWSquare extends Container {\n+    int width;\n+    int height;\n+\n+    public LWSquare(Color color, int w, int h) {\n+        setBackground(color);\n+        setLayout(new FlowLayout());\n+        width = w;\n+        height = h;\n+        addMouseListener(new EnterExitAdapter(this));\n+        setName(\"LWSquare-\" + color.toString());\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.setColor(getBackground());\n+        g.fillRect(0, 0, getSize().width, getSize().height);\n+        super.paint(g);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(width, height);\n+    }\n+\n+    public Cursor getCursor() {\n+        return new Cursor(Cursor.CROSSHAIR_CURSOR);\n+    }\n+}\n+\n+class MouseFrame extends Frame {\n+    public LWSquare lw;\n+\n+    public MouseFrame() {\n+        super(\"MouseEnterExitTest\");\n+        setLayout(new FlowLayout());\n+\n+        lw = new LWSquare(Color.red, 75, 75);\n+        add(lw);\n+        setBounds(50, 50, 300, 200);\n+        setVisible(true);\n+        System.out.println(getInsets());\n+\n+        addMouseListener(new EnterExitAdapter(this));\n+        addWindowListener(\n+                new WindowAdapter() {\n+                    public void windowClosing(WindowEvent ev) {\n+                        dispose();\n+                    }\n+                }\n+        );\n+        addKeyListener(\n+                new KeyAdapter() {\n+                    public void keyPressed(KeyEvent ev) {\n+                        MouseEnterExitTest.getFrame().setTitle(\"MouseEnterExitTest\");\n+                    }\n+                }\n+        );\n+    }\n+}\n+\n+\n+public class MouseEnterExitTest {\n+    static MouseFrame testFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        robot.setAutoDelay(100);\n+        try {\n+            EventQueue.invokeAndWait(() -> testFrame = new MouseFrame());\n+            if (testFrame.lw.getBackground() != Color.red) {\n+                throw new RuntimeException(\"Initial Background color not matching\");\n+            }\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            EventQueue.invokeAndWait(() -> robot.mouseMove(\n+                    testFrame.getLocationOnScreen().x + testFrame.getSize().width \/ 2,\n+                    testFrame.getLocationOnScreen().y + testFrame.getSize().height \/ 2));\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            if (testFrame.lw.getBackground() != Color.green) {\n+                throw new RuntimeException(\"Initial Background color not matching\");\n+            }\n+            EventQueue.invokeAndWait(() -> robot.mouseMove(\n+                    testFrame.getLocationOnScreen().x + testFrame.getSize().width * 2,\n+                    testFrame.getLocationOnScreen().y + testFrame.getSize().height \/ 2));\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            if (testFrame.lw.getBackground() != Color.red) {\n+                throw new RuntimeException(\"Initial Background color not matching\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (testFrame != null) {\n+                    testFrame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static Frame getFrame() {\n+        return testFrame;\n+    }\n+}\n+\n+class EnterExitAdapter extends MouseAdapter {\n+    Component compToColor;\n+    Color colorNormal;\n+\n+    EnterExitAdapter(Component comp) {\n+        compToColor = comp;\n+        colorNormal = comp.getBackground();\n+    }\n+\n+    public void mouseEntered(MouseEvent ev) {\n+        compToColor.setBackground(Color.green);\n+        compToColor.repaint();\n+    }\n+\n+    public void mouseExited(MouseEvent ev) {\n+        compToColor.setBackground(colorNormal);\n+        compToColor.repaint();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseEnterExitTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Rectangle;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+\n+\/*\n+ * @test\n+ * @bug 4150851\n+ * @summary Tests enter and exit events when a lightweight component is on a border\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MouseEnterExitTest2\n+ *\/\n+\n+public class MouseEnterExitTest2 {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Verify that white component turns black whenever mouse enters the frame,\n+                   except when it enters the red rectangle.\n+                2. When the mouse enters the red part of the frame the component should stay white.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(EntryExitTest.initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class EntryExitTest extends Component {\n+    boolean inWin;\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(200, 150);\n+    }\n+\n+    public void paint(Graphics g) {\n+        Color c1, c2;\n+        String s;\n+        if (inWin) {\n+            c1 = Color.black;\n+            c2 = Color.white;\n+            s = \"IN\";\n+        } else {\n+            c2 = Color.black;\n+            c1 = Color.white;\n+            s = \"OUT\";\n+        }\n+        g.setColor(c1);\n+        Rectangle r = getBounds();\n+        g.fillRect(0, 0, r.width, r.height);\n+        g.setColor(c2);\n+        g.drawString(s, r.width \/ 2, r.height \/ 2);\n+    }\n+\n+    public static Frame initialize() {\n+        EntryExitTest test = new EntryExitTest();\n+        MouseListener frameEnterExitListener = new MouseAdapter() {\n+            public void mouseEntered(MouseEvent e) {\n+                test.inWin = true;\n+                test.repaint();\n+            }\n+\n+            public void mouseExited(MouseEvent e) {\n+                test.inWin = false;\n+                test.repaint();\n+            }\n+        };\n+\n+        Frame f = new Frame(\"Mouse Modifier Test\");\n+\n+        f.add(test);\n+        Component jc = new Component() {\n+            public Dimension getPreferredSize() {\n+                return new Dimension(100, 50);\n+            }\n+\n+            public void paint(Graphics g) {\n+                Dimension d = getSize();\n+                g.setColor(Color.red);\n+                g.fillRect(0, 0, d.width, d.height);\n+            }\n+        };\n+        final Container cont = new Container() {\n+            public Dimension getPreferredSize() {\n+                return new Dimension(100, 100);\n+            }\n+        };\n+        cont.setLayout(new GridLayout(2, 1));\n+        cont.add(jc);\n+        jc.addMouseListener(new MouseAdapter() {\n+            public void mouseEntered(MouseEvent e) {\n+                \/\/System.out.println(\"Component entered\");\n+            }\n+            public void mouseExited(MouseEvent e) {\n+                \/\/System.out.println(\"Component exited\");\n+            }\n+        });\n+\n+        f.add(cont, BorderLayout.NORTH);\n+        f.addMouseListener(frameEnterExitListener);\n+        f.pack();\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseEnterExitTest2.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import javax.swing.JButton;\n+\n+\/*\n+ * @test\n+ * @bug 4431868\n+ * @summary Tests that hw container doesn't receive mouse enter\/exit events when mouse\n+ *          is moved between its lw and hw children\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MouseEnterExitTest3\n+ *\/\n+\n+public class MouseEnterExitTest3 {\n+    static final Button button = new Button(\"Button\");\n+    static final JButton jbutton = new JButton(\"JButton\");\n+    static final Frame frame = new Frame(\"Mouse Enter\/Exit Test\");\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Move the mouse between Button and JButton\n+                2. Verify that the frame doesn't receive enter\/exit events\n+                   (Enter\/exit events are dumped to the area below)\n+                4. If you see enter\/exit events dumped the test fails\n+                        \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(4)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    final static MouseListener listener = new MouseAdapter() {\n+        public void mouseEntered(MouseEvent e) {\n+            PassFailJFrame.log(e.toString());\n+        }\n+\n+        public void mouseExited(MouseEvent e) {\n+            PassFailJFrame.log(e.toString());\n+        }\n+    };\n+\n+    public static Frame initialize() {\n+        frame.setLayout(new GridLayout(2, 1));\n+        frame.add(button);\n+        frame.add(jbutton);\n+        frame.addMouseListener(listener);\n+        frame.pack();\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseEnterExitTest3.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.Window;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+\n+\/*\n+ * @test\n+ * @bug 4431868\n+ * @key headful\n+ * @summary Tests that window totally obscured by its child doesn't receive\n+ *          enter\/exit events when located over another frame\n+ * @run main MouseEnterExitTest4\n+ *\/\n+\n+public class MouseEnterExitTest4 {\n+    static Button button = new Button(\"Button\");\n+    static Frame frame = new Frame(\"Mouse Enter\/Exit test\");\n+    static Window window = new Window(frame);\n+    static MouseListener listener = new MouseAdapter() {\n+        public void mouseEntered(MouseEvent e) {\n+            throw new RuntimeException(\"Test failed due to Mouse Enter event\");\n+        }\n+\n+        public void mouseExited(MouseEvent e) {\n+            throw new RuntimeException(\"Test failed due to Mouse Exit event\");\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        robot.setAutoDelay(100);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                button.setBackground(Color.red);\n+                window.add(button);\n+                frame.setBounds(100, 100, 300, 300);\n+                window.setBounds(200, 200, 100, 100);\n+                window.addMouseListener(listener);\n+                window.setVisible(true);\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(200);\n+            EventQueue.invokeAndWait(() -> robot.mouseMove(\n+                    frame.getLocationOnScreen().x + frame.getSize().width \/ 2,\n+                    frame.getLocationOnScreen().y + frame.getSize().height \/ 2));\n+            robot.waitForIdle();\n+            robot.delay(200);\n+            EventQueue.invokeAndWait(() -> robot.mouseMove(\n+                    window.getLocationOnScreen().x + window.getSize().width * 2,\n+                    window.getLocationOnScreen().y + window.getSize().height \/ 2));\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            System.out.println(\"Test Passed\");\n+\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+               if (frame != null) {\n+                   frame.dispose();\n+               }\n+               if (window != null) {\n+                   window.dispose();\n+               }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseEnterExitTest4.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Container;\n+import java.awt.GridLayout;\n+import javax.swing.JButton;\n+import javax.swing.JCheckBox;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JRadioButton;\n+import javax.swing.JScrollPane;\n+import javax.swing.JToggleButton;\n+\n+\/*\n+ * @test\n+ * @bug 4268759\n+ * @summary Tests whether clicking on the edge of a lightweight button\n+ *          causes sticking behavior\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MousePressedTest\n+ *\/\n+\n+public class MousePressedTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Click and hold on the very bottom border (2-pixel-wide border) of the\n+                   JButton. Then drag the mouse straight down out of the JButton and\n+                   into the JRadioButton, and release the mouse button\n+                2. If the component remains highlighted as if the mouse button is still\n+                   down, the test fails\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static JFrame initialize() {\n+        JFrame f = new JFrame(\"JButton Test\");\n+        JPanel p = new JPanel();\n+        p.setLayout(new GridLayout(2, 2));\n+        JButton b = new JButton(\"JButton\");\n+        p.add(b);\n+        JCheckBox cb = new JCheckBox(\"JCheckBox\");\n+        p.add(cb);\n+        JRadioButton rb = new JRadioButton(\"JRadioButton\");\n+        p.add(rb);\n+        p.add(new JToggleButton(\"JToggleButton\"));\n+\n+        JScrollPane j = new JScrollPane(p,\n+                JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n+\n+        Container c = f.getContentPane();\n+        c.setLayout(new GridLayout(1, 1));\n+        c.add(j);\n+        f.pack();\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MousePressedTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,455 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4148078\n+ * @summary Repainting problems in scrolled panel\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PanelRepaint\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Scrollbar;\n+import java.awt.TextField;\n+import java.awt.event.AdjustmentEvent;\n+import java.awt.event.AdjustmentListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+\n+public class PanelRepaint extends Panel implements FocusListener {\n+    static ScrollPanel sPanel;\n+    static Panel panel;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Using scrollbars or tab keys to scroll the panel and\n+                the panel is messy sometimes, e.g. one row bumps into\n+                another. If all components painted correctly, the test passes.\n+                Otherwise, the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(PanelRepaint::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"Panel Repaint Test\");\n+        f.setLayout(new FlowLayout());\n+        f.setSize(620, 288);\n+        PanelRepaint pr = new PanelRepaint();\n+\n+        panel = new Panel();\n+        panel.setLayout(null);\n+        panel.setSize(500, 500);\n+        sPanel = new ScrollPanel(panel);\n+\n+        Button btn = new Button(\"Open\");\n+        pr.addComp(btn);\n+        btn.setBounds(400, 10, 60, 20);\n+        btn.setActionCommand(\"OPEN\");\n+\n+        Button btn1 = new Button(\"Close\");\n+        pr.addComp(btn1);\n+        btn1.setBounds(400, 50, 60, 20);\n+        btn1.setActionCommand(\"CLOSE\");\n+\n+        TextField t1 = new TextField(\"1\");\n+        pr.addComp(t1);\n+        t1.setBounds(10, 10, 100, 20);\n+        TextField t2 = new TextField(\"2\");\n+        pr.addComp(t2);\n+        t2.setBounds(10, 50, 100, 20);\n+        TextField t3 = new TextField(\"3\");\n+        pr.addComp(t3);\n+        t3.setBounds(10, 90, 100, 20);\n+        TextField t4 = new TextField(\"4\");\n+        pr.addComp(t4);\n+        t4.setBounds(10, 130, 100, 20);\n+        TextField t5 = new TextField(\"5\");\n+        pr.addComp(t5);\n+        t5.setBounds(10, 170, 100, 20);\n+        TextField t6 = new TextField(\"6\");\n+        pr.addComp(t6);\n+        t6.setBounds(10, 210, 100, 20);\n+        TextField t7 = new TextField(\"7\");\n+        pr.addComp(t7);\n+        t7.setBounds(10, 250, 100, 20);\n+        TextField t8 = new TextField(\"8\");\n+        pr.addComp(t8);\n+        t8.setBounds(10, 290, 100, 20);\n+        TextField t9 = new TextField(\"9\");\n+        pr.addComp(t9);\n+        t9.setBounds(10, 330, 100, 20);\n+\n+        TextField t11 = new TextField(\"1\");\n+        pr.addComp(t11);\n+        t11.setBounds(120, 10, 100, 20);\n+        TextField t12 = new TextField(\"2\");\n+        pr.addComp(t12);\n+        t12.setBounds(120, 50, 100, 20);\n+        TextField t13 = new TextField(\"3\");\n+        pr.addComp(t13);\n+        t13.setBounds(120, 90, 100, 20);\n+        TextField t14 = new TextField(\"4\");\n+        pr.addComp(t14);\n+        t14.setBounds(120, 130, 100, 20);\n+        TextField t15 = new TextField(\"5\");\n+        pr.addComp(t15);\n+        t15.setBounds(120, 170, 100, 20);\n+        TextField t16 = new TextField(\"6\");\n+        pr.addComp(t16);\n+        t16.setBounds(120, 210, 100, 20);\n+        TextField t17 = new TextField(\"7\");\n+        pr.addComp(t17);\n+        t17.setBounds(120, 250, 100, 20);\n+        TextField t18 = new TextField(\"8\");\n+        pr.addComp(t18);\n+        t18.setBounds(120, 290, 100, 20);\n+        TextField t19 = new TextField(\"9\");\n+        pr.addComp(t19);\n+        t19.setBounds(120, 330, 100, 20);\n+\n+\n+        TextField t21 = new TextField(\"1\");\n+        pr.addComp(t21);\n+        t21.setBounds(240, 10, 100, 20);\n+        TextField t22 = new TextField(\"2\");\n+        pr.addComp(t22);\n+        t22.setBounds(240, 50, 100, 20);\n+        TextField t23 = new TextField(\"3\");\n+        pr.addComp(t23);\n+        t23.setBounds(240, 90, 100, 20);\n+        TextField t24 = new TextField(\"4\");\n+        pr.addComp(t24);\n+        t24.setBounds(240, 130, 100, 20);\n+        TextField t25 = new TextField(\"5\");\n+        pr.addComp(t25);\n+        t25.setBounds(240, 170, 100, 20);\n+        TextField t26 = new TextField(\"6\");\n+        pr.addComp(t26);\n+        t26.setBounds(240, 210, 100, 20);\n+        TextField t27 = new TextField(\"7\");\n+        pr.addComp(t27);\n+        t27.setBounds(240, 250, 100, 20);\n+        TextField t28 = new TextField(\"8\");\n+        pr.addComp(t28);\n+        t28.setBounds(240, 290, 100, 20);\n+        TextField t29 = new TextField(\"9\");\n+        pr.addComp(t29);\n+        t29.setBounds(240, 330, 100, 20);\n+\n+        pr.add(sPanel);\n+        f.add(pr);\n+        sPanel.setBounds(100, 100, 500, 250);\n+        sPanel.doLayout();\n+        return f;\n+    }\n+\n+    public void addComp(Component c) {\n+        panel.add(c);\n+        c.addFocusListener(this);\n+    }\n+\n+    public void focusGained(FocusEvent e) {\n+        sPanel.showComponent(e.getComponent());\n+    }\n+\n+    public void focusLost(FocusEvent e) {\n+    }\n+}\n+\n+class ScrollPanel extends Panel implements AdjustmentListener {\n+    \/**\n+     * Constructor\n+     *\/\n+    public ScrollPanel(Component c) {\n+        setLayout(null);\n+        setBackground(Color.lightGray);\n+        add(hScroll = new Scrollbar(Scrollbar.HORIZONTAL));\n+        add(vScroll = new Scrollbar(Scrollbar.VERTICAL));\n+        add(square = new Panel());\n+        square.setBackground(Color.lightGray);\n+        add(c);\n+    }\n+\n+    \/**\n+     * Scroll up\/down\/left\/right to show the component specified\n+     *\n+     * @param comp is the component to be shown\n+     *\/\n+    public void showComponent(Component comp) {\n+        Component view = getComponent(3);\n+        Rectangle viewRect = view.getBounds();\n+        Rectangle scrollRect = getBounds();\n+        Rectangle rect = comp.getBounds();\n+        while (comp != null) {\n+            Component parent = comp.getParent();\n+            if (parent == null || parent == view) {\n+                break;\n+            }\n+            Point p = parent.getLocation();\n+            rect.x += p.x;\n+            rect.y += p.y;\n+            comp = parent;\n+        }\n+\n+        int i = viewRect.y + rect.y;\n+        int j = (viewRect.y + rect.y + rect.height + ScrollPanel.H_HEIGHT)\n+                - (scrollRect.height);\n+\n+        if (i < 0) {\n+            vertUpdate(i);\n+        } else if (j > 0) {\n+            vertUpdate(j);\n+        }\n+\n+        i = viewRect.x + rect.x;\n+        j = (viewRect.x + rect.x + rect.width + (V_WIDTH * 2)) - (scrollRect.width);\n+\n+        if (i < 0) {\n+            horzUpdate(i);\n+        } else if (j > 0) {\n+            horzUpdate(j);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the panel component of ScrollPanel\n+     *\n+     * @return the panel component of ScrollPanel\n+     *\/\n+    public Component getScrolled() {\n+        return getComponent(3);\n+    }\n+\n+    \/**\n+     * updates the scroll panel vertically with value i passed\n+     *\n+     * @param i the value to be updated with\n+     *\/\n+    public void vertUpdate(int i) {\n+        update(true, vScroll.getValue() + i);\n+    }\n+\n+    \/**\n+     * updates the scroll panel horizontally with value i passed\n+     *\n+     * @param i the value to be updated with\n+     *\/\n+    public void horzUpdate(int i) {\n+        update(false, hScroll.getValue() + i);\n+    }\n+\n+    \/**\n+     * updates the scroll panel vertically if bVert is true else horizontally\n+     *\n+     * @param n is the value\n+     *\/\n+    public void update(boolean bVert, int n) {\n+        if (n < 0) n = 0;\n+        if (bVert) {\n+            if (n > max.height) {\n+                n = max.height;\n+            }\n+            if (offset.y != n) {\n+                offset.y = n;\n+                vScroll.setValue(n);\n+            }\n+        } else {\n+            if (n > max.width) {\n+                n = max.width;\n+            }\n+            if (offset.x != n) {\n+                offset.x = n;\n+                hScroll.setValue(n);\n+            }\n+        }\n+        getScrolled().setLocation(-offset.x, -offset.y);\n+    }\n+\n+    \/**\n+     * Implementation of AdjustmentListener\n+     *\/\n+    public void adjustmentValueChanged(AdjustmentEvent e) {\n+        boolean bVert = e.getSource() == vScroll;\n+        update(bVert, e.getValue());\n+    }\n+\n+    \/**\n+     * Reimplementation of Component Methods\n+     *\/\n+    public void addNotify() {\n+        super.addNotify();\n+        vScroll.addAdjustmentListener(this);\n+        hScroll.addAdjustmentListener(this);\n+    }\n+\n+    public void removeNotify() {\n+        super.removeNotify();\n+        vScroll.removeAdjustmentListener(this);\n+        hScroll.removeAdjustmentListener(this);\n+    }\n+\n+    public void setBounds(int x, int y, int w, int h) {\n+        super.setBounds(x, y, w, h);\n+        doLayout();\n+    }\n+\n+    public void doLayout() {\n+        Component c = getScrolled();\n+        Dimension d = c.getSize();\n+        if (d.width == 0 || d.height == 0) {\n+            d = c.getPreferredSize();\n+        }\n+        vert = 0;\n+        horz = 0;\n+        Dimension m = getSize();\n+        if (d.height > m.height || isScroll(true, m.height - horz, 0, d.height)) {\n+            vert = V_WIDTH;\n+        }\n+        if (d.width + vert > m.width || isScroll(false, m.width - vert, 0, d.width)) {\n+            horz = H_HEIGHT;\n+        }\n+        if (d.height + horz > m.height || isScroll(true, m.height - horz, 0, d.height)) {\n+            vert = V_WIDTH;\n+        }\n+        if (d.width + vert > m.width || isScroll(false, m.width - vert, 0, d.width)) {\n+            horz = H_HEIGHT;\n+        }\n+        if (horz != 0) {\n+            if (m.width <= 0) {\n+                m.width = 1;\n+            }\n+            hScroll.setBounds(0, m.height - H_HEIGHT, m.width - vert, H_HEIGHT);\n+            hScroll.setValues(offset.x, m.width - vert, 0, d.width);\n+            int i = d.width \/ 10;\n+            if (i < 2) {\n+                i = 2;\n+            }\n+            hScroll.setBlockIncrement(i);\n+            i = d.width \/ 50;\n+            if (i < 1) {\n+                i = 1;\n+            }\n+            hScroll.setUnitIncrement(i);\n+            max.width = d.width;\n+            hScroll.setVisible(true);\n+        } else {\n+            offset.x = 0;\n+        }\n+        if (vert != 0) {\n+            if (m.height <= 0) {\n+                m.height = 1;\n+            }\n+            vScroll.setBounds(m.width - V_WIDTH, 0, V_WIDTH, m.height - horz);\n+            vScroll.setValues(offset.y, m.height - horz, 0, d.height);\n+            int i = d.height \/ 10;\n+            if (i < 2) i = 2;\n+            vScroll.setBlockIncrement(i);\n+            i = d.height \/ 50;\n+            if (i < 1) i = 1;\n+            vScroll.setUnitIncrement(i);\n+            max.height = d.height;\n+            vScroll.setVisible(true);\n+        } else {\n+            offset.y = 0;\n+        }\n+        if (horz != 0 && vert != 0) {\n+            square.setBounds(m.width - V_WIDTH, m.height - H_HEIGHT, V_WIDTH, H_HEIGHT);\n+            square.setVisible(true);\n+        } else {\n+            square.setVisible(false);\n+        }\n+        c.setBounds(-offset.x, -offset.y, d.width, d.height);\n+        c.repaint();\n+        updateScroll(true, offset.y);\n+        updateScroll(false, offset.x);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return getScrolled().getPreferredSize();\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return getScrolled().getMinimumSize();\n+    }\n+\n+    boolean isScroll(boolean bVert, int visible, int min, int max) {\n+        int tot = max - min;\n+        int net = tot - visible;\n+        if (net <= 0) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void updateScroll(boolean bVert, int n) {\n+        Component c = getScrolled();\n+        Dimension d = c.getSize();\n+        Dimension m = getSize();\n+        m.width -= vert;\n+        m.height -= horz;\n+        if (bVert) {\n+            if (n >= 0 && d.height > m.height) {\n+                if (n + m.height > d.height)\n+                    n = d.height - m.height;\n+            } else\n+                n = 0;\n+            update(true, n);\n+        } else {\n+            if (n >= 0 && d.width > m.width) {\n+                if (n + m.width > d.width)\n+                    n = d.width - m.width;\n+            } else\n+                n = 0;\n+            update(false, n);\n+        }\n+    }\n+\n+    static Scrollbar hScroll;\n+    static Scrollbar vScroll;\n+    static int vert = 0;\n+    static int horz = 0;\n+\n+    static Point offset = new Point();\n+    static Dimension max = new Dimension();\n+    \/\/  ScrollTimer timer;\n+    static Component square;\n+    final static int V_WIDTH = 17;\n+    final static int H_HEIGHT = 17;\n+}\n","filename":"test\/jdk\/java\/awt\/Panel\/PanelRepaint\/PanelRepaint.java","additions":455,"deletions":0,"binary":false,"changes":455,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.PopupMenu;\n+import java.awt.Robot;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+import java.util.Hashtable;\n+\n+\/*\n+ * @test\n+ * @bug 4214550\n+ * @summary Tests that there is no seg fault on repeatedly showing\n+ *          PopupMenu by right-clicking Label, Panel or Button\n+ * @key headful\n+ * @run main ActivePopupCrashTest\n+ *\/\n+\n+public class ActivePopupCrashTest {\n+    private static Frame f;\n+    private static Label l;\n+    private static Button b;\n+    private static Panel p;\n+\n+    private static volatile Point labelCenter;\n+    private static volatile Point buttonCenter;\n+    private static volatile Point panelCenter;\n+\n+    public static void main(String[] args) throws Exception {\n+        final int REPEAT_COUNT = 5;\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(50);\n+            EventQueue.invokeAndWait(ActivePopupCrashTest::createAndShowUI);\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                labelCenter = getCenterPoint(l);\n+                buttonCenter = getCenterPoint(b);\n+                panelCenter = getCenterPoint(p);\n+            });\n+\n+            for (int i = 0; i < REPEAT_COUNT; i++) {\n+                robot.mouseMove(labelCenter.x, labelCenter.y);\n+                robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n+\n+                robot.mouseMove(buttonCenter.x, buttonCenter.y);\n+                robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n+\n+                robot.mouseMove(panelCenter.x, panelCenter.y);\n+                robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n+            }\n+\n+            \/\/ To close the popup, otherwise test fails on windows with timeout error\n+            robot.mouseMove(panelCenter.x - 5, panelCenter.y - 5);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static Point getCenterPoint(Component component) {\n+        Point p = component.getLocationOnScreen();\n+        Dimension size = component.getSize();\n+        return new Point(p.x + size.width \/ 2, p.y + size.height \/ 2);\n+    }\n+\n+    public static void createAndShowUI() {\n+        f = new Frame(\"ActivePopupCrashTest Test\");\n+        MenuItem item = new MenuItem(\"file-1\");\n+        item.addActionListener(ActivePopupCrashTest::logActionEvent);\n+        Menu m = new Menu(\"file\");\n+        m.add(item);\n+        item = new MenuItem(\"file-2\");\n+        m.add(item);\n+        MenuBar mb = new MenuBar();\n+        mb.add(m);\n+\n+        f.setMenuBar(mb);\n+        f.setSize(200, 200);\n+        f.setLayout(new BorderLayout());\n+\n+        l = new Label(\"label\");\n+        addPopup(l, \"label\");\n+        f.add(l, BorderLayout.NORTH);\n+\n+        p = new Panel();\n+        addPopup(p, \"panel\");\n+        f.add(p, BorderLayout.CENTER);\n+\n+        b = new Button(\"button\");\n+        addPopup(b, \"button\");\n+        f.add(b, BorderLayout.SOUTH);\n+\n+        f.setSize(400, 300);\n+        f.setLocationRelativeTo(null);\n+        f.setVisible(true);\n+    }\n+\n+    static void addPopup(Component c, String name) {\n+        PopupMenu pm = new PopupMenu();\n+        MenuItem mi = new MenuItem(name + \"-1\");\n+        mi.addActionListener(ActivePopupCrashTest::logActionEvent);\n+        pm.add(mi);\n+\n+        mi = new MenuItem(name + \"-2\");\n+        pm.add(mi);\n+\n+        setHash(c, pm);\n+        c.add(pm);\n+        c.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                mouseAction(\"mouseClicked\", e);\n+            }\n+\n+            @Override\n+            public void mousePressed(MouseEvent e) {\n+                mouseAction(\"mousePressed\", e);\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseAction(\"mouseReleased\", e);\n+            }\n+        });\n+    }\n+\n+    static void logActionEvent(ActionEvent e) {\n+        System.out.println(\"actionPerformed, event=\" + e + \", mod=\" + getMods(e));\n+        System.out.println(\"command=\" + e.getActionCommand());\n+        System.out.println(\"param=\" + e.paramString());\n+        System.out.println(\"source=\" + e.getSource());\n+    }\n+\n+    static String getMods(ActionEvent e) { return getMods(e.getModifiers()); }\n+\n+    static String getMods(MouseEvent e) { return getMods(e.getModifiers()); }\n+\n+    static String getMods(int mods) {\n+        String modstr = \"\";\n+        if ((mods & ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK) {\n+            modstr += (\" SHIFT\");\n+        } else if ((mods & ActionEvent.ALT_MASK) == ActionEvent.ALT_MASK) {\n+            modstr += (\" ALT\");\n+        } else if ((mods & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK) {\n+            modstr += (\" CTRL\");\n+        } else if ((mods & ActionEvent.META_MASK) == ActionEvent.META_MASK) {\n+            modstr += (\" META\");\n+        }\n+        return modstr;\n+    }\n+\n+    static void mouseAction(String which, MouseEvent e) {\n+        Component c = e.getComponent();\n+        System.out.println(which + \" e = \" + e + \" , mods = \" + getMods(e) +\n+                \" , component = \" + c);\n+        if (e.isPopupTrigger()) {\n+            System.out.println(\"isPopup\");\n+            PopupMenu pm = getHash(c);\n+            pm.show(c, c.getWidth() \/ 2, c.getHeight() \/ 2);\n+        }\n+    }\n+\n+    static Hashtable<Component, PopupMenu> popupTable = new Hashtable<>();\n+\n+    static void setHash(Component c, PopupMenu p) {\n+        popupTable.put(c, p);\n+    }\n+\n+    static PopupMenu getHash(Component c) {\n+        return popupTable.get(c);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/ActivePopupCrashTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Menu;\n+import java.awt.MenuItem;\n+import java.awt.Point;\n+import java.awt.PopupMenu;\n+import java.awt.Robot;\n+\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 5021183\n+ * @summary Tests Key Traversal doesn't crash PopupMenu\n+ * @key headful\n+ * @run main KeyTraversalCrash\n+ *\/\n+\n+public class KeyTraversalCrash {\n+    private static Frame f;\n+    private static Label label;\n+\n+    private static volatile Point loc;\n+    private static volatile Dimension dim;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            EventQueue.invokeAndWait(KeyTraversalCrash::createAndShowUI);\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                loc = label.getLocationOnScreen();\n+                dim = label.getSize();\n+            });\n+\n+            robot.mouseMove(loc.x + 20, loc.y + 20);\n+            robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n+\n+            robot.mouseMove(loc.x + 25, loc.y + 25);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            robot.keyPress(KeyEvent.VK_LEFT);\n+            robot.keyRelease(KeyEvent.VK_LEFT);\n+\n+            robot.keyPress(KeyEvent.VK_DOWN);\n+            robot.keyRelease(KeyEvent.VK_DOWN);\n+\n+            \/\/ To close the popup, otherwise test fails on windows with timeout error\n+            robot.mouseMove(loc.x + dim.width - 20, loc.y + dim.height - 20);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void createAndShowUI() {\n+        f = new Frame(\"KeyTraversalCrash Test\");\n+        final PopupMenu popup = new PopupMenu();\n+        for (int i = 0; i < 10; i++) {\n+            Menu menu = new Menu(\"Menu \" + i);\n+            for(int j = 0; j < 10; j++) {\n+                MenuItem menuItem = new MenuItem(\"MenuItem \" + j);\n+                menu.add(menuItem);\n+            }\n+            popup.add(menu);\n+        }\n+        label = new Label(\"Label\");\n+        f.add(label);\n+        f.add(popup);\n+        label.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mousePressed(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    popup.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    popup.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+        });\n+        f.setSize(200, 200);\n+        f.setLocationRelativeTo(null);\n+        f.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/KeyTraversalCrash.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Button;\n+import java.awt.Frame;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4186663 4265525\n+ * @summary Tests that multiple PopupMenus cannot appear at the same time\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiplePopupMenusTest\n+ *\/\n+\n+public class MultiplePopupMenusTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Click the right mouse button on the button\n+                If multiple popups appear at the same time the\n+                test fails else passes.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"MultiplePopupMenusTest Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(30)\n+                .testUI(MultiplePopupMenusTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame fr = new Frame(\"MultiplePopupMenusTest Test\");\n+        TestButton button = new TestButton(\"button\");\n+        fr.add(button);\n+        fr.setSize(200, 200);\n+        return fr;\n+    }\n+\n+    static class TestButton extends Button {\n+        public TestButton(String title) {\n+            super(title);\n+            enableEvents(AWTEvent.MOUSE_EVENT_MASK);\n+        }\n+\n+        @Override\n+        public void processMouseEvent(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                for (int i = 0; i < 10; i++) {\n+                    PopupMenu pm = new PopupMenu(\"Popup \" + i);\n+                    pm.add(new MenuItem(\"item 1\"));\n+                    pm.add(new MenuItem(\"item 2\"));\n+                    add(pm);\n+                    pm.show(this, e.getX() + i * 5, e.getY() + i * 5);\n+                }\n+            }\n+            super.processMouseEvent(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/MultiplePopupMenusTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4281273\n+ * @summary PopupMenu crashed in Java. Simplified testcase.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"windows\")\n+ * @run main\/manual PopupMenuCrash\n+ *\/\n+\n+public class PopupMenuCrash {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This tests a windows specific problem.\n+                When you see a frame titled \"PopupMenuCrash Test\", right-click on it\n+                several times for a few seconds. Then wait about 10 seconds before the\n+                PopupMenus start to appear. Then dispose them one by one by clicking on them.\n+                When PopupMenus do not appear anymore, press Pass.\n+                In case of a failure, you'll see a crash.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"PopupMenuCrash Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(PopupMenuCrash::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        final Frame f = new Frame(\"PopupMenuCrash Test\");\n+        f.setLayout(new FlowLayout());\n+        f.add(new Label(\"Press right mouse button inside this frame.\"));\n+        f.add(new Label(\"A pop-up menu should appear.\"));\n+        f.addMouseListener(new MouseAdapter() {\n+            PopupMenu popup;\n+            boolean firstPress = true;\n+\n+            @Override\n+            public void mousePressed(MouseEvent evt) {\n+                if (firstPress) {\n+                    firstPress = false;\n+                    try {\n+                        Thread.sleep(10000);\n+                    } catch (InterruptedException ignored) {\n+                    }\n+                }\n+\n+                if ((evt.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {\n+                    popup = new PopupMenu(\"Popup Menu Title\");\n+                    MenuItem mi = new MenuItem(\"MenuItem\");\n+                    popup.add(mi);\n+                    f.add(popup);\n+                    popup.show(evt.getComponent(), evt.getX(), evt.getY());\n+                }\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent evt) {\n+                if ((evt.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {\n+                    if (popup != null) {\n+                        f.remove(popup);\n+                        popup = null;\n+                    }\n+                }\n+            }\n+        });\n+\n+        f.setSize(400, 350);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PopupMenuCrash.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.MenuItem;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.PopupMenu;\n+import java.awt.Robot;\n+\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4083400\n+ * @key headful\n+ * @summary Tests that excessive popping up and down does not crash or\n+ *          throw an exception.\n+ * @run main StressTest\n+ *\/\n+\n+public class StressTest {\n+    private static Frame fr;\n+    private static PopupTestPanel panel;\n+\n+    private static volatile Point panelCenter;\n+\n+    public static void main(String[] args) throws Exception {\n+        final int REPEAT_COUNT = 5;\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(50);\n+            EventQueue.invokeAndWait(StressTest::createAndShowUI);\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                Point loc = panel.getLocationOnScreen();\n+                Dimension dim = panel.getSize();\n+                panelCenter = new Point(loc.x + dim.width \/ 2, loc.y + dim.height \/ 2);\n+            });\n+\n+            for (int i = 0; i < REPEAT_COUNT; i++) {\n+                robot.mouseMove(panelCenter.x + i * 2, panelCenter.y + i * 2);\n+\n+                robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n+\n+                robot.mouseMove(panelCenter.x - i * 2, panelCenter.y - i * 2);\n+\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void createAndShowUI() {\n+        fr = new Frame(\"PopupMenu Test\");\n+        panel = new PopupTestPanel();\n+        fr.add(panel);\n+        fr.setSize(300, 200);\n+        fr.setVisible(true);\n+    }\n+\n+    static class PopupTestPanel extends Panel {\n+\n+        static class Item extends MenuItem {\n+            public Item(String text) {\n+                super(text);\n+            }\n+\n+            public boolean isEnabled() {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException ignored) {\n+                }\n+                return super.isEnabled();\n+            }\n+        }\n+\n+        final PopupMenu popup;\n+\n+        public PopupTestPanel() {\n+            popup = new PopupMenu();\n+            popup.add(new Item(\"Soap\"));\n+            popup.add(new Item(\"Sponge\"));\n+            popup.add(new Item(\"Flannel\"));\n+            popup.add(new Item(\"Mat\"));\n+            popup.add(new Item(\"Towel\"));\n+            add(popup);\n+            addMouseListener(new MouseAdapter() {\n+                @Override\n+                public void mousePressed(MouseEvent e) {\n+                    if (e.isPopupTrigger()) {\n+                        showPopup(e);\n+                    }\n+                }\n+\n+                @Override\n+                public void mouseReleased(MouseEvent e) {\n+                    if (e.isPopupTrigger()) {\n+                        showPopup(e);\n+                    }\n+                }\n+\n+                private void showPopup(MouseEvent e) {\n+                    popup.show((Component) e.getSource(), e.getX(), e.getY());\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/StressTest.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.RenderingHints;\n+import java.awt.SystemTray;\n+import java.awt.TrayIcon;\n+import java.awt.image.BufferedImage;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 6267936\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @summary Tests that the previous image in TrayIcon is cleared\n+ *          when a new image is set\n+ * @run main\/manual ClearPrevImageTest\n+ *\/\n+\n+public class ClearPrevImageTest {\n+    private static SystemTray tray;\n+    private static TrayIcon icon;\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This test checks that the previous image in TrayIcon is cleared\n+            when a new image is set.\n+\n+            When the test starts, a RED square TrayIcon is added\n+            to the SystemTray (also, called Taskbar Status Area in MS Windows,\n+            Notification Area in, GNOME and System Tray in KDE).\n+\n+            You should see it change into YELLOW after 5 seconds.\n+            If you still see RED TrayIcon after 5 seconds,\n+            press FAIL, otherwise press PASS\n+            \"\"\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+         if (!SystemTray.isSupported()) {\n+             throw new SkippedException(\"Test not applicable as\"\n+                                        + \" System Tray not supported\");\n+         }\n+\n+        PassFailJFrame passFailJFrame\n+                = PassFailJFrame.builder()\n+                                .title(\"TrayIcon Change Test Instructions\")\n+                                .instructions(INSTRUCTIONS)\n+                                .columns(40)\n+                                .build();\n+\n+        EventQueue.invokeAndWait(ClearPrevImageTest::createAndShowTrayIcon);\n+        try {\n+            changeTrayIcon();\n+            passFailJFrame.awaitAndCheck();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Test failed: \", e);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (tray != null) {\n+                    tray.remove(icon);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowTrayIcon() {\n+        Image img1 = createIcon(Color.RED);\n+        tray = SystemTray.getSystemTray();\n+        icon = new TrayIcon(img1);\n+        icon.setImageAutoSize(true);\n+\n+        try {\n+            tray.add(icon);\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\"Error while adding\"\n+                                       + \" icon to system tray\", e);\n+        }\n+    }\n+\n+    private static void changeTrayIcon() {\n+        try {\n+            Thread.sleep(5000);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        Image img2 = createIcon(Color.YELLOW);\n+        icon.setImage(img2);\n+    }\n+\n+    private static Image createIcon(Color color) {\n+        BufferedImage image = new BufferedImage(16, 16,\n+                                                BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D g = image.createGraphics();\n+        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                           RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+        g.setColor(color);\n+        g.fillRect(0, 0, 16, 16);\n+        g.dispose();\n+        return image;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/ClearPrevImageTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.SystemTray;\n+import java.awt.TextArea;\n+import java.awt.TrayIcon;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.image.BufferedImage;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 6269309\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @summary Tests that focus is transferred properly back\n+ *          to toplevel after clicking on a tray icon.\n+ * @run main\/manual FocusLostAfterTrayTest\n+ *\/\n+\n+public class FocusLostAfterTrayTest {\n+    private static SystemTray tray;\n+    private static TrayIcon icon;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This test checks that focus is transferred properly back\n+            to top-level after clicking on a tray icon.\n+\n+            When the test starts, a Frame with a text area & a RED tray icon\n+            are shown. If you don't see a tray icon please make sure that\n+            the tray area (also called Taskbar Status Area on MS Windows\n+            Notification Area on Gnome or System Tray on KDE) is visible.\n+\n+            Click with a mouse inside a text area and make sure that it has\n+            received input focus. Then click on the tray icon and then back\n+            on the text area and verify that it has input focus again. Repeat\n+            the last step several times. Ensure that the text area always\n+            has the input focus and there are no \"FOCUS LOST\" event\n+            for text area in the log section.\n+\n+            If above is true, Press PASS, else FAIL.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!SystemTray.isSupported()) {\n+            throw new SkippedException(\"Test not applicable as\"\n+                                       + \" System Tray not supported\");\n+        }\n+\n+        try {\n+            PassFailJFrame.builder()\n+                          .title(\"FocusLostAfterTrayTest Instructions\")\n+                          .instructions(INSTRUCTIONS)\n+                          .columns(40)\n+                          .testUI(FocusLostAfterTrayTest::createAndShowTrayIcon)\n+                          .logArea()\n+                          .build()\n+                          .awaitAndCheck();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (tray != null) {\n+                    tray.remove(icon);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static Frame createAndShowTrayIcon() {\n+        Frame frame = new Frame(\"FocusLostAfterTrayTest\");\n+        frame.setBounds(100, 300, 200, 200);\n+        frame.setLayout(new BorderLayout());\n+        TextArea ta = new TextArea();\n+        ta.addFocusListener(new FocusAdapter() {\n+            @Override\n+            public void focusGained(FocusEvent e) {\n+                PassFailJFrame.log(\"FOCUS GAINED: \"\n+                                   + e.getComponent().getClass().toString());\n+            }\n+            @Override\n+            public void focusLost(FocusEvent e) {\n+                PassFailJFrame.log(\"FOCUS LOST !! \"\n+                                   + e.getComponent().getClass().toString());\n+            }\n+        });\n+        frame.add(ta);\n+\n+        BufferedImage image = new BufferedImage(16, 16,\n+                                                BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D g = image.createGraphics();\n+        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                           RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+        g.setColor(Color.RED);\n+        g.fillRect(0, 0, 16, 16);\n+        g.dispose();\n+        tray = SystemTray.getSystemTray();\n+        icon = new TrayIcon(image);\n+        icon.setImageAutoSize(true);\n+\n+        try {\n+            tray.add(icon);\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\"Error while adding\"\n+                                       + \" icon to system tray\", e);\n+        }\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/FocusLostAfterTrayTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.SystemTray;\n+import java.awt.TrayIcon;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionAdapter;\n+import java.awt.image.BufferedImage;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 6267980\n+ * @summary PIT:Spurious MouseMoved events are triggered by Tray Icon\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @run main\/manual MouseMoveTest\n+ *\/\n+\n+public class MouseMoveTest {\n+    private static SystemTray tray;\n+    private static TrayIcon icon;\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1) You will see a tray icon (white square) in notification area,\n+            2) Move mouse pointer to the icon and leave it somewhere inside the icon,\n+            3) Verify that MOUSE_MOVE events are NOT triggered after you have STOPPED\n+               moving mouse.\n+            4) If events are still triggered Press FAIL else PASS.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!SystemTray.isSupported()) {\n+            throw new SkippedException(\"Test not applicable as\"\n+                                       + \" System Tray not supported\");\n+        }\n+\n+        PassFailJFrame passFailJFrame\n+                = PassFailJFrame.builder()\n+                                .title(\"TrayIcon Change Test Instructions\")\n+                                .instructions(INSTRUCTIONS)\n+                                .columns(45)\n+                                .logArea()\n+                                .build();\n+\n+        try {\n+            EventQueue.invokeAndWait(MouseMoveTest::createAndShowTrayIcon);\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (tray != null) {\n+                    tray.remove(icon);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowTrayIcon() {\n+        BufferedImage img = new BufferedImage(32, 32,\n+                                              BufferedImage.TYPE_INT_ARGB);\n+        Graphics g = img.createGraphics();\n+        g.setColor(Color.WHITE);\n+        g.fillRect(0, 0, 32, 32);\n+        g.dispose();\n+\n+        tray = SystemTray.getSystemTray();\n+        icon = new TrayIcon(img);\n+        icon.setImageAutoSize(true);\n+\n+        icon.addMouseMotionListener(new MouseMotionAdapter() {\n+                public void mouseMoved(MouseEvent me){\n+                    PassFailJFrame.log(me.toString());\n+                }\n+        });\n+\n+        try {\n+            tray.add(icon);\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\"Error while adding\"\n+                                       + \" icon to system tray\", e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/MouseMoveTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.SystemTray;\n+import java.awt.TrayIcon;\n+import java.awt.image.BufferedImage;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 6267943\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @summary Tests the possibility of selecting a tray icon with the keyboard.\n+ * @run main\/manual TrayIconKeySelectTest\n+ *\/\n+\n+public class TrayIconKeySelectTest {\n+    private static SystemTray tray;\n+    private static TrayIcon icon;\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Tests that TrayIcon is selectable with the keyboard\n+            When the test is started you will see three-color icon\n+            in the system tray.\n+\n+            1. Bring the focus to the icon with TAB. Press ENTER key.\n+            - One or more ActionEvent should be generated\n+               (see the output area of the test)\n+\n+            2. Bring the focus again to the icon. Press SPACE key twice.\n+            - One or more ActionEvent should be generated.\n+\n+            3. Bring the focus again to the icon. Click on the icon with\n+            the LEFT mouse button twice.\n+            - One or more ActionEvent should be generated.\n+\n+            4. Again bring the focus to the icon. Click on the icon with\n+            the LEFT mouse button just once.\n+            - NO ActionEvent should be generated.\n+\n+            5. Repeat the 4th step with other mouse buttons.\n+\n+            If all the above are true press PASS, else FAIL\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!SystemTray.isSupported()) {\n+            throw new SkippedException(\"Test not applicable as\"\n+                                       + \" System Tray not supported\");\n+        }\n+        PassFailJFrame passFailJFrame;\n+        try {\n+            passFailJFrame\n+                    = PassFailJFrame.builder()\n+                                    .title(\"TrayIconKeySelectTest Instructions\")\n+                                    .instructions(INSTRUCTIONS)\n+                                    .columns(40)\n+                                    .logArea()\n+                                    .build();\n+\n+            EventQueue.invokeAndWait(TrayIconKeySelectTest::createAndShowTrayIcon);\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (tray != null) {\n+                    tray.remove(icon);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowTrayIcon() {\n+        BufferedImage im = new BufferedImage(16, 16,\n+                                             BufferedImage.TYPE_INT_ARGB);\n+        Graphics gr = im.createGraphics();\n+        gr.setColor(Color.white);\n+        gr.fillRect(0, 0, 16, 5);\n+        gr.setColor(Color.blue);\n+        gr.fillRect(0, 5, 16, 10);\n+        gr.setColor(Color.red);\n+        gr.fillRect(0, 10, 16, 16);\n+        gr.dispose();\n+\n+        tray = SystemTray.getSystemTray();\n+        icon = new TrayIcon(im);\n+        icon.setImageAutoSize(true);\n+        icon.addActionListener(e -> PassFailJFrame.log(e.toString()));\n+\n+        try {\n+            tray.add(icon);\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\"Error while adding\"\n+                                       + \" icon to system tray\", e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/TrayIconKeySelectTest.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,613 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.CheckboxGroup;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.Insets;\n+import java.awt.Label;\n+import java.awt.MenuItem;\n+import java.awt.Panel;\n+import java.awt.PopupMenu;\n+import java.awt.RenderingHints;\n+import java.awt.SystemTray;\n+import java.awt.TextField;\n+import java.awt.Toolkit;\n+import java.awt.TrayIcon;\n+import java.awt.TrayIcon.MessageType;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionAdapter;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.BufferedImage;\n+import java.beans.PropertyChangeEvent;\n+import java.util.HashMap;\n+import java.util.Map;\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4310333\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @summary  A unit test for TrayIcon RFE\n+ * @run main\/manual TrayIconTest\n+ *\/\n+\n+public class TrayIconTest {\n+    private static SystemTray tray;\n+    static Frame frame = new Frame(\"TrayIcon Test\");\n+    private static final String INSTRUCTIONS = \"\"\"\n+            The test frame contains CheckboxGroup of tray icons.\n+            A selected checkbox represents the TrayIcon (or null\n+            TrayIcon) whose functionality is currently tested.\n+\n+            If you are under Linux make sure your Application Panel has\n+            System Tray (on Gnome it is called Notification Area).\n+\n+            Perform all the cases (1-7) documented below.\n+\n+            CASE 1: Testing ADD\/REMOVE\/PropertyChange functionality.\n+            --------------------------------------------------------\n+             1. Select null TrayIcon and pressAdd button:\n+                - NullPointerException should be thrown.\n+             2. Select some of the valid TrayIcons and press Add button:\n+                - The selected TrayIcon should appear in the SystemTray.\n+                - PropertyChangeEvent should be fired (the property is\n+                  an array of TrayIcons added to the system tray).\n+             3. Press Add button again:\n+                - IllegalArgumentException should be thrown.\n+                - No PropertyChangeEvent should be fired.\n+             4. Press Remove button:\n+                - The TrayIcon should disappear from the SystemTray.\n+                - PropertyChangeEvent should be fired.\n+             5. Press Remove button again:\n+                - It should have no effect.\n+                - No PropertyChangeEvent should be fired.\n+             6. Add all the valid TrayIcons (by selecting everyone and pressing Add\n+                button):\n+                - All the TrayIcons should appear in the SystemTray.\n+                - PropertyChangeEvent should be fired on each adding.\n+             7. Remove all the TrayIcons (again by selecting everyone and pressing\n+                Remove):\n+                - All the TrayIcons should disappear from the SystemTray.\n+                - PropertyChangeEvent should be fired on each removing.\n+             8. Not for Windows! Remove the system tray (Notification Area) from\n+                the desktop. Try to add some valid TrayIcon:\n+                - AWTException should be thrown.\n+                - No PropertyChangeEvent should be fired.\n+             9. Not for Windows! Add the system tray back to the desktop. Add all the\n+                valid TrayIcons:\n+                - All the TrayIcons should appear in the system tray.\n+                - PropertyChangeEvent should be fired on each adding.\n+             11. Not for Windows! Remove the system tray from the desktop:\n+                - All the TrayIcons should disappear.\n+                - PropertyChangeEvent should be fired for each TrayIcon\n+                  removal.\n+                - PropertyChangeEvent should be fired for SystemTray removal.\n+             12. Add the system tray and go to the next step.\n+                - All the TrayIcons should appear again.\n+                - PropertyChangeEvent should be fired for SystemTray addition.\n+                - PropertyChangeEvent shouldn't be fired for TrayIcon removal.\n+\n+            CASE 2: Testing RESIZE functionality.\n+            -------------------------------------\n+             1. Select some of the TrayIcons and add it. Then press resize button:\n+                - The TrayIcon selected should be resized to fit the area it occupies.\n+             2. Press resize button again:\n+                - The TrayIcon should be resized to the original size.\n+             3. Repeat the 1-2 steps for other TrayIcons:\n+                - The TrayIcons should be resized appropriately.\n+\n+            CASE 3: Testing EVENTS functionality\n+            ---------------------------------\n+             1. Select some of the TrayIcons and add it. Select MouseEvent from the\n+                group of checkboxes at the top-right of the test frame.\n+                Click on the TrayIcon in the SystemTray:\n+                - MOUSE_PRESSED MOUSE_RELEASED and MOUSE_CLICKED events should be\n+                  generated.\n+             2. Press mouse inside the TrayIcon dragging mouse and releasing it.\n+                - Make sure that MOUSE_CLICKED event is not triggered.\n+             3. Click on the TrayIcon with different modification keys:\n+                - there should be appropriate modifiers in the events.\n+             4. Keep clicking on the TrayIcon:\n+               - there should be correct absolute coordinates in the events.\n+             5. Only for Windows! Focus the system tray using keyboard:\n+               - press WIN key once to bring up the start menu then press ESC once to\n+                 close the menu the focus should be on the start button\n+               - press TAB key for several times until you focus on the system\n+                 tray then use ARROW keys to move to the TrayIcon\n+               - press ENTER or SPACE should trigger ACTION_PERFORMED message\n+                 make sure that mouse events are not  triggered.\n+             6. Select MouseMotionEvent checkbox. Move mouse over the TrayIcon:\n+               - MOUSE_MOVED event should be generated. It should contain\n+                 correct coordinates.\n+             7. Deselect both the checkboxes and then select AWTEventListener.\n+                Click on the TrayIcon and then move mouse over it:\n+                - Appropriate mouse events should be generated (catched by the\n+                  AWTEventListener).\n+             8. Deselect all the checkboxes and go to the following step.\n+\n+            CASE 4: Testing DISPLAY MESSAGE functionality.\n+            ----------------------------------------------\n+             1. Select some of the TrayIcons and add it. Then press Display message\n+                button:\n+                - A balloon message should appear near the TrayIcon.\n+             2. After the message is displayed wait for some period:\n+                - The message window should be closed automatically.\n+             3. Display the message again. Close it by pressing X in its top-right\n+                corner:\n+                - The message window should be closed immediately.\n+             4. Display the message again. Click inside it:\n+                - The message should be closed an ACTION_PERFORMED event should be\n+                  generated with correct information and an Ok dialog should appear.\n+                  Close the dialog.\n+             5. Select a message type from the Type choice and display the message\n+                again:\n+                - It should contain an icon appropriate to the message type selected\n+                  or no icon if NONE is selected.\n+             6. Change the content of the Message and Caption text fields and\n+                display the message:\n+                - The message content should be changed in the accordance with the text\n+                  typed.\n+             7. Not for Windows! Type some too long or too short text for the Caption\n+                and Message:\n+                - The message should process the text correctly. The long text should\n+                  be cut.\n+             8. Not for Windows! Type null in the Message text field and display\n+                the message:\n+                - The message body should contain no text.\n+             9. Type null in the Caption text field and display the message:\n+                - The message caption should contain no text.\n+             10. Type null in the both Message and Caption fields and display\n+                 the message:\n+                - NullPointerException should be generated and no message should be\n+                  displayed.\n+             11. Try to hide the taskbar. Click Display message for several times.\n+                 Then restore the taskbar. Click on the TrayIcon:\n+                 - No message should appear.\n+                 Try to display the message once more:\n+                 - It should appear appropriately.\n+             12. Try to display the message for other TrayIcons:\n+                 - The messages should be displayed appropriately.\n+\n+            CASE 5: Testing POPUP MENU functionality.\n+            -----------------------------------------\n+             1. Add some TrayIcon to the system tray. Press Set button in the\n+                Popup menu test area. Trigger the popup menu for the TrayIcon with\n+                the mouse:\n+                - A popup menu should appear. Make sure it behaves properly.\n+                - Make sure the 'duke.gif' image is animated while the popup menu is shown.\n+             2. Press Remove button for the popup menu and try to trigger it again:\n+                - No popup menu should appear.\n+             3. Perform 1-2 steps for other TrayIcons:\n+                - Make sure the popup menu behaves properly.\n+             4. Add more than one TrayIcons to the system tray. Press Set button in\n+                the PopupMenu test area for some of the TrayIcon added. Trigger\n+                the popup menu for this TrayIcon:\n+                - A popup menu should appear properly.\n+             5. Try to set the popup menu to the same TrayIcon again:\n+                - It should have no effect\n+             6. Try to set the popup menu for other TrayIcons you've added to the system\n+                tray:\n+                - for each one IllegalArgumentException should be thrown.\n+\n+            CASE 6: Testing TOOLTIP functionality.\n+            --------------------------------------\n+             1. Type something in the Tooltip text field and press Set button.\n+                Then move mouse cursor over the TrayIcon and wait for a second:\n+                - A tooltip should appear containing the text typed.\n+             2. Show a tooltip again and keep your mouse over the TrayIcon for some period:\n+                - The tooltip should disappear automatically.\n+             3. Show a tooltip again and leave the TrayIcon:\n+                - The tooltip should disappear immediately.\n+             4. Type null in the Tooltip field and press set then move your\n+                mouse to the SystemTray:\n+                - The tooltip shouldn't appear.\n+             5. Type something too long in the Tooltip field and show the tooltip:\n+                - The tooltip text should be cut.\n+\n+            CASE 7: Testing ACTION functionality.\n+            -------------------------------------\n+             1. Add some TrayIcon to the system tray. Double click it with the left mouse\n+                button:\n+                - An ACTION_PERFORMED event should be generated.\n+             2. Double click the TrayIcon with the left mouse button several times:\n+                - Several ACTION_PERFORMED events should be generated\n+                - Make sure that the time-stamp of each event ('when' field) is increased.\n+\n+            If all the above cases work as expected Press PASS else FAIL.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!SystemTray.isSupported()) {\n+            throw new SkippedException(\"Test not applicable as\"\n+                                       + \" System Tray not supported\");\n+        }\n+        try {\n+            PassFailJFrame.builder()\n+                          .title(\"TrayIconTest Instructions\")\n+                          .instructions(INSTRUCTIONS)\n+                          .columns(50)\n+                          .rows(40)\n+                          .testUI(TrayIconTest::createAndShowUI)\n+                          .logArea(10)\n+                          .build()\n+                          .awaitAndCheck();\n+\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (tray != null) {\n+                    \/\/Remove any remaining tray icons before ending the test.\n+                    TrayIcon[] icons = tray.getTrayIcons();\n+                    for (TrayIcon icon : icons) {\n+                        tray.remove(icon);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    private static Frame createAndShowUI() {\n+        final TrayIconControl ctrl = new TrayIconControl();\n+        frame.setLayout(new BorderLayout());\n+        frame.add(ctrl.cont, BorderLayout.CENTER);\n+        frame.setBackground(Color.LIGHT_GRAY);\n+\n+        frame.addWindowListener(new WindowAdapter() {\n+                public void windowClosing(WindowEvent e) {\n+                    ctrl.dispose();\n+                }\n+            });\n+\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    private static class TrayIconControl {\n+        final String RED_ICON = \"RED ICON\";\n+        final String BLUE_ICON = \"BLUE ICON\";\n+        final String GREEN_ICON = \"GREEN ICON\";\n+\n+        CheckboxGroup cbg = new CheckboxGroup();\n+        Button addButton = new PackedButton(\"   Add   \");\n+        Button remButton = new PackedButton(\"Remove\");\n+        Button resizeButton = new PackedButton(\"Resize\");\n+        Button balloonButton = new PackedButton(\"Display message\");\n+        Choice balloonChoice = new Choice();\n+        String[] balloonTypes = new String[] { \"ERROR\", \"WARNING\", \"INFO\", \"NONE\" };\n+\n+        TextField balloonText = new TextField(\n+                                \"A TrayIcon can generate various MouseEvents and\"\n+                                + \" supports adding corresponding listeners to receive\"\n+                                + \" notification of these events. TrayIcon processes\"\n+                                + \" some of the events by itself. For example,\"\n+                                + \" by default, when the right-mouse click\", 70);\n+        TextField balloonCaption = new TextField(\"TrayIcon\", 70);\n+\n+        MessageType[] typeArr = new MessageType[] { MessageType.ERROR, MessageType.WARNING,\n+                MessageType.INFO, MessageType.NONE };\n+        Checkbox mouseListenerCbox =  new Checkbox(\"MouseEvent\");\n+        Checkbox motionListenerCbox = new Checkbox(\"  MouseMotionEvent\");\n+        Checkbox awtListenerCbox =    new Checkbox(\"  AWTEventListener\");\n+        TextField tipText = new TextField(\"TrayIcon\", 50);\n+        Button tipButton = new PackedButton(\"Set\");\n+        Button setPopupButton = new PackedButton(\"Set\");\n+        Button remPopupButton = new PackedButton(\"Remove\");\n+\n+        PopupMenu popupMenu = new PopupMenu();\n+\n+        Map<String, TrayIcon> resToObjMap = new HashMap<>();\n+\n+        Container cont = new Container();\n+\n+        TrayIconControl() {\n+            Toolkit.getDefaultToolkit().addAWTEventListener(e -> {\n+                if (e.getSource() instanceof TrayIcon && awtListenerCbox.getState()) {\n+                    PassFailJFrame.log(e.toString());\n+                }\n+            }, MouseEvent.MOUSE_EVENT_MASK | MouseEvent.MOUSE_MOTION_EVENT_MASK |\n+                   ActionEvent.ACTION_EVENT_MASK);\n+\n+            cont.setLayout(new GridLayout(4, 1));\n+\n+            Container raw1 = new Container();\n+            raw1.setLayout(new GridLayout(1, 4));\n+            cont.add(raw1);\n+\n+            InsetsPanel cbgPanel = new InsetsPanel();\n+            cbgPanel.setLayout(new GridLayout(4, 1));\n+            Checkbox nullCbox = new Checkbox(\"null\", cbg, true);\n+            Checkbox redCbox = new Checkbox(RED_ICON, cbg, false);\n+            Checkbox blueCbox = new Checkbox(BLUE_ICON, cbg, false);\n+            Checkbox greenCbox = new Checkbox(GREEN_ICON, cbg, false);\n+            cbgPanel.add(nullCbox);\n+            cbgPanel.add(redCbox);\n+            cbgPanel.add(blueCbox);\n+            cbgPanel.add(greenCbox);\n+            cbgPanel.addTo(raw1);\n+\n+            InsetsPanel addremPanel = new InsetsPanel();\n+            addremPanel.setLayout(new BorderLayout());\n+            addremPanel.add(addButton.getParent(), BorderLayout.NORTH);\n+            addremPanel.add(remButton.getParent(), BorderLayout.SOUTH);\n+            addremPanel.addTo(raw1);\n+\n+            InsetsPanel resizePanel = new InsetsPanel();\n+            resizePanel.add(resizeButton);\n+            resizePanel.addTo(raw1);\n+\n+            InsetsPanel lstPanel = new InsetsPanel();\n+            lstPanel.setLayout(new GridLayout(3, 1));\n+            lstPanel.add(mouseListenerCbox);\n+            lstPanel.add(motionListenerCbox);\n+            lstPanel.add(awtListenerCbox);\n+            lstPanel.addTo(raw1);\n+\n+            Container raw2 = new Container();\n+            raw2.setLayout(new BorderLayout());\n+            cont.add(raw2);\n+\n+            InsetsPanel balloonPanel = new InsetsPanel();\n+            balloonPanel.setLayout(new BorderLayout());\n+            balloonPanel.add(balloonButton.getParent(), BorderLayout.NORTH);\n+            Container bc = new Container();\n+            bc.setLayout(new FlowLayout());\n+            bc.add(new Label(\"  Type:\"));\n+            bc.add(balloonChoice);\n+            balloonPanel.add(bc, BorderLayout.SOUTH);\n+            balloonPanel.addTo(raw2, BorderLayout.WEST);\n+\n+            InsetsPanel blnTextPanel = new InsetsPanel();\n+            blnTextPanel.setLayout(new GridLayout(2, 2));\n+            Container c1 = new Panel();\n+            c1.setLayout(new FlowLayout());\n+            blnTextPanel.add(c1);\n+            c1.add(new Label(\"Message:\"));\n+            c1.add(balloonText);\n+\n+            Container c2 = new Panel();\n+            c2.setLayout(new FlowLayout());\n+            blnTextPanel.add(c2);\n+            c2.add(new Label(\"Caption:\"));\n+            c2.add(balloonCaption);\n+            blnTextPanel.addTo(raw2, BorderLayout.CENTER);\n+\n+\n+            Container raw3 = new Container();\n+            raw3.setLayout(new BorderLayout());\n+            cont.add(raw3);\n+\n+            InsetsPanel popupPanel = new InsetsPanel();\n+            popupPanel.setLayout(new FlowLayout());\n+            popupPanel.add(new Label(\"Popup menu:\"));\n+            popupPanel.add(setPopupButton);\n+            popupPanel.add(remPopupButton);\n+            popupPanel.addTo(raw3);\n+\n+\n+            Container raw4 = new Container();\n+            raw4.setLayout(new BorderLayout());\n+            cont.add(raw4);\n+\n+            InsetsPanel tipPanel = new InsetsPanel();\n+            tipPanel.setLayout(new FlowLayout());\n+            tipPanel.add(new Label(\"Tooltip:\"));\n+            tipPanel.add(tipText);\n+            tipPanel.add(tipButton);\n+            tipPanel.addTo(raw4);\n+\n+            addButton.addActionListener(e -> {\n+                try {\n+                    tray.add(getCurIcon());\n+                } catch (NullPointerException npe) {\n+                    if (npe.getMessage() == null) {\n+                        PassFailJFrame.log(\"Probably wrong path to the images.\");\n+                        throw npe; \/\/ if wrong images path was set\n+                    }\n+                    PassFailJFrame.log(npe.toString());\n+                } catch (IllegalArgumentException iae) {\n+                    PassFailJFrame.log(iae.toString());\n+                } catch (AWTException ise) {\n+                    PassFailJFrame.log(ise.toString());\n+                }\n+            });\n+            remButton.addActionListener(e -> tray.remove(getCurIcon()));\n+\n+            resizeButton.addActionListener(\n+                    e -> getCurIcon().setImageAutoSize(!getCurIcon().isImageAutoSize()));\n+\n+            balloonButton.addActionListener(e -> {\n+                String text = null, caption = null;\n+                if (balloonText.getText().compareToIgnoreCase(\"null\") != 0) {\n+                    text = balloonText.getText();\n+                }\n+                if (balloonCaption.getText().compareToIgnoreCase(\"null\") != 0) {\n+                    caption = balloonCaption.getText();\n+                }\n+                try {\n+                    getCurIcon().displayMessage(caption, text, typeArr[balloonChoice.getSelectedIndex()]);\n+                } catch (NullPointerException npe) {\n+                    PassFailJFrame.log(npe.toString());\n+                }\n+            });\n+\n+            tipButton.addActionListener(e -> {\n+                String tip = null;\n+                if (tipText.getText().compareToIgnoreCase(\"null\") != 0) {\n+                    tip = tipText.getText();\n+                }\n+                getCurIcon().setToolTip(tip);\n+            });\n+\n+            setPopupButton.addActionListener(e -> {\n+                try {\n+                    getCurIcon().setPopupMenu(popupMenu);\n+                } catch (IllegalArgumentException iae) {\n+                    PassFailJFrame.log(iae.toString());\n+                }\n+            });\n+\n+            remPopupButton.addActionListener(e -> getCurIcon().setPopupMenu(null));\n+            for (String s: balloonTypes) {\n+                balloonChoice.add(s);\n+            }\n+\n+            init();\n+        }\n+\n+        void init() {\n+            tray = SystemTray.getSystemTray();\n+            tray.addPropertyChangeListener(\"trayIcons\",\n+                                           e -> printPropertyChangeEvent(e));\n+\n+            tray.addPropertyChangeListener(\"systemTray\",\n+                                           e -> printPropertyChangeEvent(e));\n+\n+            configureTrayIcon(RED_ICON);\n+            configureTrayIcon(BLUE_ICON);\n+            configureTrayIcon(GREEN_ICON);\n+\n+            for (String s: balloonTypes) {\n+                popupMenu.add(new MenuItem(s));\n+            }\n+        }\n+\n+        void printPropertyChangeEvent(PropertyChangeEvent e) {\n+            String name = e.getPropertyName();\n+            Object oldValue = e.getOldValue();\n+            Object newValue = e.getNewValue();\n+\n+            PassFailJFrame.log(\"PropertyChangeEvent[name=\" + name\n+                               + \",oldValue=\" + oldValue + \",newValue=\" + newValue + \"]\");\n+        }\n+\n+        void configureTrayIcon(String icon) {\n+            Color color = Color.WHITE;\n+            switch (icon) {\n+                case \"RED ICON\" -> color = Color.RED;\n+                case \"BLUE ICON\" -> color = Color.BLUE;\n+                case \"GREEN ICON\" -> color = Color.GREEN;\n+            }\n+            Image image = createIcon(color);\n+            TrayIcon trayIcon = new TrayIcon(image);\n+\n+            trayIcon.addMouseListener(new MouseAdapter() {\n+                public void mousePressed(MouseEvent e) {\n+                    if (mouseListenerCbox.getState())\n+                        PassFailJFrame.log(e.toString());\n+                }\n+                public void mouseReleased(MouseEvent e) {\n+                    if (mouseListenerCbox.getState())\n+                        PassFailJFrame.log(e.toString());\n+                }\n+                public void mouseClicked(MouseEvent e) {\n+                    if (mouseListenerCbox.getState())\n+                        PassFailJFrame.log(e.toString());\n+                }\n+            });\n+            trayIcon.addMouseMotionListener(new MouseMotionAdapter() {\n+                public void mouseMoved(MouseEvent e) {\n+                    if (motionListenerCbox.getState())\n+                        PassFailJFrame.log(e.toString());\n+                }\n+            });\n+            trayIcon.addActionListener(e -> PassFailJFrame.log(e.toString()));\n+\n+            resToObjMap.remove(icon);\n+            resToObjMap.put(icon, trayIcon);\n+        }\n+\n+        String getCurImgName() {\n+            return cbg.getSelectedCheckbox().getLabel();\n+        }\n+\n+        TrayIcon getCurIcon() {\n+            return resToObjMap.get(getCurImgName());\n+        }\n+\n+        public void dispose() {\n+            tray.remove(getCurIcon());\n+        }\n+\n+        private static Image createIcon(Color color) {\n+            BufferedImage image = new BufferedImage(16, 16,\n+                                                    BufferedImage.TYPE_INT_ARGB);\n+            Graphics2D g = image.createGraphics();\n+            g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                               RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+            g.setColor(color);\n+            g.fillRect(0, 0, 16, 16);\n+            g.dispose();\n+            return image;\n+        }\n+\n+    }\n+\n+    private static class InsetsPanel extends Panel {\n+        Container parent = new Container() {\n+            public Insets getInsets() {\n+                return new Insets(2, 2, 2, 2);\n+            }\n+        };\n+\n+        InsetsPanel() {\n+            parent.setLayout(new BorderLayout());\n+            setBackground(new Color(240, 240, 240));\n+        }\n+\n+        void addTo(Container c) {\n+            parent.add(this);\n+            c.add(parent);\n+        }\n+\n+        void addTo(Container c, String pos) {\n+            parent.add(this);\n+            c.add(parent, pos);\n+        }\n+    }\n+\n+    private static class PackedButton extends Button {\n+        Container parent = new Container();\n+        PackedButton(String l) {\n+            super(l);\n+            parent.setLayout(new FlowLayout());\n+            parent.add(this);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/TrayIconTest.java","additions":613,"deletions":0,"binary":false,"changes":613,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Cursor;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+\/*\n+ * @test\n+ * @bug 4451328\n+ * @summary tests that a custom drag cursor is not changed\n+           to the default drag cursor\n+ * @key headful\n+ * @run main CustomDragCursorTest\n+ *\/\n+\n+public class CustomDragCursorTest {\n+    private static Frame frame;\n+    private static final DragSourcePanel dragSourcePanel = new DragSourcePanel();\n+    private static final DropTargetPanel dropTargetPanel = new DropTargetPanel();\n+\n+    private static volatile Point srcPoint;\n+    private static volatile Point dstPoint;\n+    private static volatile boolean passed = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            EventQueue.invokeAndWait(CustomDragCursorTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                Point p = dragSourcePanel.getLocationOnScreen();\n+                Dimension d = dragSourcePanel.getSize();\n+                p.translate(d.width \/ 2, d.height \/ 2);\n+                srcPoint = p;\n+\n+                p = dropTargetPanel.getLocationOnScreen();\n+                d = dropTargetPanel.getSize();\n+                p.translate(d.width \/ 2, d.height \/ 2);\n+                dstPoint = p;\n+            });\n+\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (; !srcPoint.equals(dstPoint);\n+                 srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                    sign(dstPoint.y - srcPoint.y))) {\n+                robot.mouseMove(srcPoint.x, srcPoint.y);\n+                robot.delay(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            if (!passed) {\n+                throw new RuntimeException(\"Custom drag cursor changed to default.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new Frame(\"CustomDragCursorTest\");\n+        frame.setLayout(new GridLayout(2, 1));\n+        frame.add(dragSourcePanel);\n+        frame.add(dropTargetPanel);\n+        frame.setLocationRelativeTo(null);\n+        frame.setSize(300, 400);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void failed() {\n+        passed = false;\n+    }\n+\n+    private static int sign(int n) {\n+        return Integer.compare(n, 0);\n+    }\n+\n+    private static class DragSourceButton extends Button implements Serializable,\n+                                                                    Transferable,\n+                                                                    DragGestureListener,\n+                                                                    DragSourceListener {\n+        private final DataFlavor dataflavor =\n+                new DataFlavor(Button.class, \"DragSourceButton\");\n+        private final Cursor dragCursor = new Cursor(Cursor.HAND_CURSOR);\n+\n+        public DragSourceButton() {\n+            this(\"DragSourceButton\");\n+        }\n+\n+        public DragSourceButton(String str) {\n+            super(str);\n+\n+            DragSource ds = DragSource.getDefaultDragSource();\n+            ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                                  this);\n+        }\n+\n+        public void dragGestureRecognized(DragGestureEvent dge) {\n+            dge.startDrag(dragCursor, this, this);\n+        }\n+\n+        public void dragEnter(DragSourceDragEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dragExit(DragSourceEvent dse) {\n+            if (!dragCursor.equals(dse.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dragOver(DragSourceDragEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dragDropEnd(DragSourceDropEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dropActionChanged(DragSourceDragEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public Object getTransferData(DataFlavor flavor)\n+                throws UnsupportedFlavorException, IOException {\n+\n+            if (!isDataFlavorSupported(flavor)) {\n+                throw new UnsupportedFlavorException(flavor);\n+            }\n+\n+            Object retObj;\n+\n+            ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n+            ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n+            ooStream.writeObject(this);\n+\n+            ByteArrayInputStream baiStream = new ByteArrayInputStream(baoStream.toByteArray());\n+            ObjectInputStream ois = new ObjectInputStream(baiStream);\n+            try {\n+                retObj = ois.readObject();\n+            } catch (ClassNotFoundException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(e.toString());\n+            }\n+\n+            return retObj;\n+        }\n+\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return new DataFlavor[] { dataflavor };\n+        }\n+\n+        public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+            return dataflavor.equals(dflavor);\n+        }\n+    }\n+\n+    private static class DragSourcePanel extends Panel {\n+\n+        final Dimension preferredDimension = new Dimension(200, 100);\n+\n+        public DragSourcePanel() {\n+            setLayout(new GridLayout(1, 1));\n+            add(new DragSourceButton());\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return preferredDimension;\n+        }\n+    }\n+\n+    private static class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+        final Dimension preferredDimension = new Dimension(200, 100);\n+\n+        public DropTargetPanel() {\n+            setDropTarget(new DropTarget(this, this));\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return preferredDimension;\n+        }\n+\n+        public void dragEnter(DropTargetDragEvent dtde) {}\n+\n+        public void dragExit(DropTargetEvent dte) {}\n+\n+        public void dragOver(DropTargetDragEvent dtde) {}\n+\n+        public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+        public void drop(DropTargetDropEvent dtde) {\n+            DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+            if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+                dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+            } else {\n+                dtde.rejectDrop();\n+            }\n+\n+            DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+            Component comp = null;\n+\n+            if(dfs != null && dfs.length >= 1) {\n+                Transferable transfer = dtde.getTransferable();\n+\n+                try {\n+                    comp = (Component)transfer.getTransferData(dfs[0]);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                    dtc.dropComplete(false);\n+                }\n+            }\n+            dtc.dropComplete(true);\n+            add(comp);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/CustomDragCursorTest.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+\n+\/*\n+ * @test\n+ * @bug 4166541 4225247 4297663\n+ * @summary Tests Basic DnD functionality\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DnDAcceptanceTest\n+ *\/\n+\n+public class DnDAcceptanceTest {\n+     private static final String INSTRUCTIONS = \"\"\"\n+            When test runs a Frame which contains a yellow button labeled\n+            \"Drag ME!\" and a RED Panel will appear.\n+\n+            Click on the button and drag to the red panel.\n+            When the mouse enters the red panel\n+            during the drag the panel should turn yellow.\n+\n+            Release the mouse button, panel should turn red again and\n+            a yellow button labeled Drag ME! should appear inside the panel.\n+            You should be able to repeat this operation multiple times.\n+\n+            If above is true press PASS, else press FAIL.\n+            \"\"\";\n+\n+     public static void main(String[] args) throws Exception {\n+         PassFailJFrame.builder()\n+                       .title(\"Test Instructions\")\n+                       .instructions(INSTRUCTIONS)\n+                       .columns(38)\n+                       .testUI(DnDAcceptanceTest::createUI)\n+                       .build()\n+                       .awaitAndCheck();\n+     }\n+\n+     private static Frame createUI() {\n+         Frame frame = new Frame(\"DnDAcceptanceTest\");\n+         Panel mainPanel;\n+         Component dragSource, dropTarget;\n+\n+         frame.setSize(400, 400);\n+         frame.setLayout(new BorderLayout());\n+\n+         mainPanel = new Panel();\n+         mainPanel.setLayout(new BorderLayout());\n+\n+         mainPanel.setBackground(Color.BLACK);\n+\n+         dropTarget = new DnDTarget(Color.RED, Color.YELLOW);\n+         dragSource = new DnDSource(\"Drag ME!\");\n+\n+         mainPanel.add(dragSource, \"North\");\n+         mainPanel.add(dropTarget, \"Center\");\n+         frame.add(mainPanel, BorderLayout.CENTER);\n+         frame.setAlwaysOnTop(true);\n+         return frame;\n+     }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDAcceptanceTest\/DnDAcceptanceTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.MouseDragGestureRecognizer;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.InvalidDnDOperationException;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+class DnDSource extends Button implements Transferable,\n+                                          DragGestureListener,\n+                                          DragSourceListener {\n+    private DataFlavor df;\n+    private transient int dropAction;\n+\n+    DnDSource(String label) {\n+        super(label);\n+        Toolkit.getDefaultToolkit().createDragGestureRecognizer(MouseDragGestureRecognizer.class,\n+                                                                DragSource.getDefaultDragSource(),\n+                                                                this, DnDConstants.ACTION_COPY, this);\n+        setBackground(Color.yellow);\n+        setForeground(Color.blue);\n+        df = new DataFlavor(DnDSource.class, \"DnDSource\");\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        System.err.println(\"starting Drag\");\n+        try {\n+            dge.startDrag(null, this, this);\n+        } catch (InvalidDnDOperationException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragEnter\");\n+        dsde.getDragSourceContext().setCursor(DragSource.DefaultCopyDrop);\n+    }\n+\n+    public void dragOver(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragOver\");\n+        dropAction = dsde.getDropAction();\n+        System.out.println(\"dropAction = \" + dropAction);\n+    }\n+\n+    public void dragGestureChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragGestureChanged\");\n+        dropAction = dsde.getDropAction();\n+        System.out.println(\"dropAction = \" + dropAction);\n+    }\n+\n+    public void dragExit(DragSourceEvent dsde) {\n+        System.err.println(\"[Source] dragExit\");\n+        dsde.getDragSourceContext().setCursor(null);\n+    }\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {\n+        System.err.println(\"[Source] dragDropEnd\");\n+    }\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dropActionChanged\");\n+        dropAction = dsde.getDropAction();\n+        System.out.println(\"dropAction = \" + dropAction);\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[] {df};\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor sdf) {\n+        return df.equals(sdf);\n+    }\n+\n+    public Object getTransferData(DataFlavor tdf) throws UnsupportedFlavorException, IOException {\n+\n+        Object copy = null;\n+\n+        if (!df.equals(tdf)) {\n+            throw new UnsupportedFlavorException(tdf);\n+        }\n+        Container parent = getParent();\n+        switch (dropAction) {\n+            case DnDConstants.ACTION_COPY:\n+                try {\n+                    copy = this.clone();\n+                } catch (CloneNotSupportedException e) {\n+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    ObjectOutputStream oos  = new ObjectOutputStream(baos);\n+\n+                    oos.writeObject(this);\n+                    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+                    ObjectInputStream ois = new ObjectInputStream(bais);\n+                    try {\n+                        copy = ois.readObject();\n+                    } catch (ClassNotFoundException cnfe) {\n+                        \/\/ do nothing\n+                    }\n+                }\n+\n+                parent.add(this);\n+                return copy;\n+\n+            case DnDConstants.ACTION_MOVE:\n+                synchronized(this) {\n+                    if (parent != null) parent.remove(this);\n+                }\n+                return this;\n+\n+            case DnDConstants.ACTION_LINK:\n+                return this;\n+\n+            default:\n+                \/\/throw new IOException(\"bad operation\");\n+                return this; \/\/ workaround for: 4135456  getDropAction() always return 0\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDAcceptanceTest\/DnDSource.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Panel;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.io.IOException;\n+\n+class DnDTarget extends Panel implements DropTargetListener {\n+    Color bgColor;\n+    Color htColor;\n+\n+    DnDTarget(Color bgColor, Color htColor) {\n+        super();\n+        this.bgColor = bgColor;\n+        this.htColor = htColor;\n+        setBackground(bgColor);\n+        setDropTarget(new DropTarget(this, this));\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent e) {\n+        System.err.println(\"[Target] dragEnter\");\n+        e.acceptDrag(DnDConstants.ACTION_COPY);\n+        setBackground(htColor);\n+        repaint();\n+    }\n+\n+    public void dragOver(DropTargetDragEvent e) {\n+        System.err.println(\"[Target] dragOver\");\n+        e.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public void dragExit(DropTargetEvent e) {\n+        System.err.println(\"[Target] dragExit\");\n+        setBackground(bgColor);\n+        repaint();\n+    }\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        System.err.println(\"[Target] drop\");\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+            return;\n+        }\n+\n+        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+        if (dfs != null && dfs.length >= 1) {\n+            Transferable transfer = dtde.getTransferable();\n+            Object obj;\n+            try {\n+                obj = transfer.getTransferData(dfs[0]);\n+            } catch (IOException | UnsupportedFlavorException ex) {\n+                System.err.println(ex.getMessage());\n+                dtc.dropComplete(false);\n+                return;\n+            }\n+\n+            if (obj != null) {\n+                Button button;\n+                try {\n+                    button = (Button) obj;\n+                } catch (Exception e) {\n+                    System.err.println(e.getMessage());\n+                    dtc.dropComplete(false);\n+                    return;\n+                }\n+                add(button);\n+                repaint();\n+            }\n+        }\n+        setBackground(bgColor);\n+        invalidate();\n+        validate();\n+        repaint();\n+        dtc.dropComplete(true);\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent e) {\n+    System.err.println(\"[Target] dropActionChanged\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDAcceptanceTest\/DnDTarget.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,441 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4388802\n+ * @summary tests that clipboard operations during drag-and-drop don't deadlock\n+ * @key headful\n+ * @run main DnDClipboardDeadlockTest\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+\n+public class DnDClipboardDeadlockTest {\n+\n+    public static final int CODE_NOT_RETURNED = -1;\n+    public static final int CODE_OK = 0;\n+    public static final int CODE_FAILURE = 1;\n+\n+    private int returnCode = CODE_NOT_RETURNED;\n+\n+    final Frame frame = new Frame();\n+    Robot robot = null;\n+    Panel panel = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        DnDClipboardDeadlockTest test = new DnDClipboardDeadlockTest();\n+        if (args.length == 4) {\n+            test.run(args);\n+        } else {\n+            test.start();\n+        }\n+    }\n+\n+    public void run(String[] args) throws InterruptedException, AWTException {\n+        try {\n+            if (args.length != 4) {\n+                throw new RuntimeException(\"Incorrect command line arguments.\");\n+            }\n+\n+            int x = Integer.parseInt(args[0]);\n+            int y = Integer.parseInt(args[1]);\n+            int w = Integer.parseInt(args[2]);\n+            int h = Integer.parseInt(args[3]);\n+\n+            Transferable t = new StringSelection(\"TEXT\");\n+            panel = new DragSourcePanel(t);\n+\n+            frame.setTitle(\"DragSource frame\");\n+            frame.setLocation(300, 200);\n+            frame.add(panel);\n+            frame.pack();\n+            frame.setVisible(true);\n+\n+            Util.waitForInit();\n+\n+            Point sourcePoint = panel.getLocationOnScreen();\n+            Dimension d = panel.getSize();\n+            sourcePoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+            Point targetPoint = new Point(x + w \/ 2, y + h \/ 2);\n+\n+            robot = new Robot();\n+\n+            if (!Util.pointInComponent(robot, sourcePoint, panel)) {\n+                throw new RuntimeException(\"WARNING: Cannot locate source panel\");\n+            }\n+\n+            robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (; !sourcePoint.equals(targetPoint);\n+                 sourcePoint.translate(sign(targetPoint.x - sourcePoint.x),\n+                         sign(targetPoint.y - sourcePoint.y))) {\n+                robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+                Thread.sleep(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    } \/\/ run()\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void start() {\n+        panel = new DropTargetPanel();\n+\n+        frame.setTitle(\"DropTarget frame\");\n+        frame.setLocation(10, 200);\n+        frame.add(panel);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+\n+        try {\n+            Util.waitForInit();\n+\n+            Point p = panel.getLocationOnScreen();\n+            Dimension d = panel.getSize();\n+\n+            try {\n+                Robot robot = new Robot();\n+                Point center = new Point(p);\n+                center.translate(d.width \/ 2, d.height \/ 2);\n+                if (!Util.pointInComponent(robot, center, panel)) {\n+                    System.err.println(\"WARNING: Cannot locate target panel\");\n+                    return;\n+                }\n+            } catch (AWTException awte) {\n+                awte.printStackTrace();\n+                return;\n+            }\n+\n+            String javaPath = System.getProperty(\"java.home\", \"\");\n+            String command = javaPath + File.separator + \"bin\" +\n+                    File.separator + \"java -cp \"\n+                    + System.getProperty(\"java.class.path\", \".\")\n+                    + \" DnDClipboardDeadlockTest \" +\n+                    p.x + \" \" + p.y + \" \" + d.width + \" \" + d.height;\n+\n+            Process process = Runtime.getRuntime().exec(command);\n+            returnCode = process.waitFor();\n+\n+            InputStream errorStream = process.getErrorStream();\n+            int count = errorStream.available();\n+            if (count > 0) {\n+                byte[] b = new byte[count];\n+                errorStream.read(b);\n+                System.err.println(\"========= Child VM System.err ========\");\n+                System.err.print(new String(b));\n+                System.err.println(\"======================================\");\n+            }\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+        switch (returnCode) {\n+            case CODE_NOT_RETURNED:\n+                System.err.println(\"Child VM: failed to start\");\n+                break;\n+            case CODE_OK:\n+                System.err.println(\"Child VM: normal termination\");\n+                break;\n+            case CODE_FAILURE:\n+                System.err.println(\"Child VM: abnormal termination\");\n+                break;\n+        }\n+        if (returnCode != CODE_OK) {\n+            throw new RuntimeException(\"The test failed.\");\n+        }\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    } \/\/ start()\n+} \/\/ class DnDClipboardDeadlockTest\n+\n+class Util implements AWTEventListener {\n+    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n+    private static final Object SYNC_LOCK = new Object();\n+    private Component clickedComponent = null;\n+    private static final int PAINT_TIMEOUT = 10000;\n+    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n+    private static final Util util = new Util();\n+\n+    static {\n+        tk.addAWTEventListener(util, 0xFFFFFFFF);\n+    }\n+\n+    private void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component) e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        return util.isPointInComponent(robot, p, comp);\n+    }\n+\n+    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        tk.sync();\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+\n+    public static void waitForInit() throws InterruptedException {\n+        final Frame f = new Frame() {\n+            public void paint(Graphics g) {\n+                dispose();\n+                synchronized (SYNC_LOCK) {\n+                    SYNC_LOCK.notifyAll();\n+                }\n+            }\n+        };\n+        f.setBounds(600, 400, 200, 200);\n+        synchronized (SYNC_LOCK) {\n+            f.setVisible(true);\n+            SYNC_LOCK.wait(PAINT_TIMEOUT);\n+        }\n+        tk.sync();\n+    }\n+}\n+\n+class DragSourceButton extends Button implements Serializable,\n+        DragGestureListener,\n+        DragSourceListener {\n+    static final Clipboard systemClipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+    final Transferable transferable;\n+\n+    public DragSourceButton(Transferable t) {\n+        super(\"DragSourceButton\");\n+\n+        this.transferable = t;\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        dge.startDrag(null, transferable, this);\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {\n+    }\n+\n+    public void dragExit(DragSourceEvent dse) {\n+    }\n+\n+    public void dragOver(DragSourceDragEvent dsde) {\n+        try {\n+            Transferable t = systemClipboard.getContents(null);\n+            if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n+                String str = (String) t.getTransferData(DataFlavor.stringFlavor);\n+            }\n+            systemClipboard.setContents(new StringSelection(\"SOURCE\"), null);\n+        } catch (IOException ioe) {\n+            ioe.printStackTrace();\n+            if (!ioe.getMessage().equals(\"Owner failed to convert data\")) {\n+                throw new RuntimeException(\"Owner failed to convert data\");\n+            }\n+        } catch (IllegalStateException e) {\n+            \/\/ IllegalStateExceptions do not indicate a bug in this case.\n+            \/\/ They result from concurrent modification of system clipboard\n+            \/\/ contents by the parent and child processes.\n+            \/\/ These exceptions are numerous, so we avoid dumping their\n+            \/\/ backtraces to prevent blocking child process io, which\n+            \/\/ causes test failure on timeout.\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {\n+        System.exit(DnDClipboardDeadlockTest.CODE_OK);\n+    }\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {\n+    }\n+}\n+\n+class DragSourcePanel extends Panel {\n+\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+\n+    public DragSourcePanel(Transferable t) {\n+        setLayout(new GridLayout(1, 1));\n+        add(new DragSourceButton(t));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+    static final Clipboard systemClipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+\n+    public DropTargetPanel() {\n+        setBackground(Color.green);\n+        setDropTarget(new DropTarget(this, this));\n+        setLayout(new GridLayout(1, 1));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public void dragExit(DropTargetEvent dte) {\n+    }\n+\n+    public void dragOver(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+        try {\n+            Transferable t = systemClipboard.getContents(null);\n+            if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n+                String str = (String) t.getTransferData(DataFlavor.stringFlavor);\n+            }\n+            systemClipboard.setContents(new StringSelection(\"TARGET\"), null);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+            return;\n+        }\n+\n+        removeAll();\n+        final List list = new List();\n+        add(list);\n+\n+        Transferable t = dtde.getTransferable();\n+        DataFlavor[] dfs = t.getTransferDataFlavors();\n+\n+        for (int i = 0; i < dfs.length; i++) {\n+\n+            DataFlavor flavor = dfs[i];\n+            String str = null;\n+\n+            if (DataFlavor.stringFlavor.equals(flavor)) {\n+                try {\n+                    str = (String) t.getTransferData(flavor);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+\n+            list.add(str + \":\" + flavor.getMimeType());\n+        }\n+\n+        dtc.dropComplete(true);\n+        validate();\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDClipboardDeadlockTest.java","additions":441,"deletions":0,"binary":false,"changes":441,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4343300\n+ * @summary tests that drag attempt doesn't cause crash when\n+ *          custom cursor is used\n+ * @key headful\n+ * @run main DnDCursorCrashTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Cursor;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+public class DnDCursorCrashTest {\n+    static final Frame frame = new Frame();\n+    static final DragSourcePanel dragSourcePanel = new DragSourcePanel();\n+    static final DropTargetPanel dropTargetPanel = new DropTargetPanel();\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setTitle(\"DnD Cursor Test Frame\");\n+                frame.setLocation(200, 200);\n+                frame.setLayout(new GridLayout(2, 1));\n+                frame.add(dragSourcePanel);\n+                frame.add(dropTargetPanel);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.delay(1000);\n+            robot.mouseMove(250, 250);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (int y = 250; y < 350; y += 5) {\n+                robot.mouseMove(250, y);\n+                robot.delay(100);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+}\n+\n+class DragSourceButton extends Button implements Serializable,\n+                                                 Transferable,\n+                                                 DragGestureListener,\n+                                                 DragSourceListener {\n+    private final DataFlavor dataflavor =\n+        new DataFlavor(Button.class, \"DragSourceButton\");\n+\n+    public DragSourceButton() {\n+        this(\"DragSourceButton\");\n+    }\n+\n+    public DragSourceButton(String str) {\n+        super(str);\n+\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                              this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        dge.startDrag(new Cursor(Cursor.HAND_CURSOR), this, this);\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {}\n+\n+    public void dragExit(DragSourceEvent dse) {}\n+\n+    public void dragOver(DragSourceDragEvent dsde) {}\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {}\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {}\n+\n+    public Object getTransferData(DataFlavor flavor)\n+      throws UnsupportedFlavorException, IOException {\n+\n+        if (!isDataFlavorSupported(flavor)) {\n+            throw new UnsupportedFlavorException(flavor);\n+        }\n+\n+        Object retObj;\n+\n+        ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n+        ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n+        ooStream.writeObject(this);\n+\n+        ByteArrayInputStream baiStream = new ByteArrayInputStream(baoStream.toByteArray());\n+        ObjectInputStream ois = new ObjectInputStream(baiStream);\n+        try {\n+            retObj = ois.readObject();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e.toString());\n+        }\n+\n+        return retObj;\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[] { dataflavor };\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+        return dataflavor.equals(dflavor);\n+    }\n+}\n+\n+class DragSourcePanel extends Panel {\n+\n+    final Dimension preferredDimension = new Dimension(200, 100);\n+\n+    public DragSourcePanel() {\n+        setLayout(new GridLayout(1, 1));\n+        add(new DragSourceButton());\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+    final Dimension preferredDimension = new Dimension(200, 100);\n+\n+    public DropTargetPanel() {\n+        setDropTarget(new DropTarget(this, this));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {}\n+\n+    public void dragExit(DropTargetEvent dte) {}\n+\n+    public void dragOver(DropTargetDragEvent dtde) {}\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+        }\n+\n+        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+        Component comp = null;\n+\n+        if (dfs != null && dfs.length >= 1) {\n+            Transferable transfer = dtde.getTransferable();\n+\n+            try {\n+                comp = (Component)transfer.getTransferData(dfs[0]);\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+                dtc.dropComplete(false);\n+            }\n+        }\n+        dtc.dropComplete(true);\n+\n+        add(comp);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDCursorCrashTest.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4357905\n+ * @summary Tests that removal of the focus owner component during\n+ *          drop processing doesn't cause crash\n+ * @key headful\n+ * @run main DnDRemoveFocusOwnerCrashTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.Serializable;\n+\n+public class DnDRemoveFocusOwnerCrashTest {\n+    public static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n+    public static Frame frame;\n+    public static Robot robot;\n+    public static DragSourceButton dragSourceButton;\n+    static volatile Point p;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame();\n+                dragSourceButton = new DragSourceButton();\n+                DropTargetPanel dropTargetPanel =\n+                        new DropTargetPanel(dragSourceButton);\n+                frame.add(new Button(\"Test\"));\n+                frame.setTitle(\"Remove Focus Owner Test Frame\");\n+                frame.setLocation(200, 200);\n+                frame.add(dropTargetPanel);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                p = dragSourceButton.getLocationOnScreen();\n+                p.translate(10, 10);\n+            });\n+\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            robot.mouseMove(p.x, p.y);\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (int dy = 0; dy < 50; dy++) {\n+                robot.mouseMove(p.x, p.y + dy);\n+                robot.delay(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    static class DragSourceButton extends Button implements Serializable,\n+            Transferable,\n+            DragGestureListener,\n+            DragSourceListener {\n+\n+        private static DataFlavor dataflavor;\n+\n+        static {\n+            try {\n+                dataflavor =\n+                        new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType);\n+                dataflavor.setHumanPresentableName(\"Local Object Flavor\");\n+            } catch (ClassNotFoundException e) {\n+                e.printStackTrace();\n+                throw new ExceptionInInitializerError();\n+            }\n+        }\n+\n+        public DragSourceButton() {\n+            this(\"DragSourceButton\");\n+        }\n+\n+        public DragSourceButton(String str) {\n+            super(str);\n+\n+            DragSource ds = DragSource.getDefaultDragSource();\n+            ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                    this);\n+        }\n+\n+        public void dragGestureRecognized(DragGestureEvent dge) {\n+            dge.startDrag(null, this, this);\n+        }\n+\n+        public void dragEnter(DragSourceDragEvent dsde) {\n+        }\n+\n+        public void dragExit(DragSourceEvent dse) {\n+        }\n+\n+        public void dragOver(DragSourceDragEvent dsde) {\n+        }\n+\n+        public void dragDropEnd(DragSourceDropEvent dsde) {\n+        }\n+\n+        public void dropActionChanged(DragSourceDragEvent dsde) {\n+        }\n+\n+        public Object getTransferData(DataFlavor flavor)\n+                throws UnsupportedFlavorException {\n+\n+            if (!isDataFlavorSupported(flavor)) {\n+                throw new UnsupportedFlavorException(flavor);\n+            }\n+\n+            return this;\n+        }\n+\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return new DataFlavor[]{dataflavor};\n+        }\n+\n+        public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+            return dataflavor.equals(dflavor);\n+        }\n+    }\n+\n+    static class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+        public DropTargetPanel(DragSourceButton button) {\n+            setLayout(new FlowLayout(FlowLayout.CENTER, 50, 50));\n+            add(button);\n+            setDropTarget(new DropTarget(this, this));\n+        }\n+\n+        public void dragEnter(DropTargetDragEvent dtde) {\n+        }\n+\n+        public void dragExit(DropTargetEvent dte) {\n+        }\n+\n+        public void dragOver(DropTargetDragEvent dtde) {\n+        }\n+\n+        public void dropActionChanged(DropTargetDragEvent dtde) {\n+        }\n+\n+        public void drop(DropTargetDropEvent dtde) {\n+            removeAll();\n+\n+            DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+            if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+                dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+            } else {\n+                dtde.rejectDrop();\n+            }\n+\n+            DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+            Component comp = null;\n+\n+            if (dfs != null && dfs.length >= 1) {\n+                Transferable transfer = dtde.getTransferable();\n+\n+                try {\n+                    comp = (Component) transfer.getTransferData(dfs[0]);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                    dtc.dropComplete(false);\n+                }\n+            }\n+            dtc.dropComplete(true);\n+\n+            add(comp);\n+            validate();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDRemoveFocusOwnerCrashTest.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6362095\n+ * @summary Tests basic DnD functionality to a wordpad\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DnDToWordpadTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Panel;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.InvalidDnDOperationException;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+\n+public class DnDToWordpadTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                The test window contains a yellow button. Click on the button\n+                to copy image into the clipboard or drag the image.\n+                Paste or drop the image over Wordpad (when the mouse\n+                enters the Wordpad during the drag, the application\n+                should change the cursor to indicate that a copy operation is\n+                about to happen; release the mouse button).\n+                An image of a red rectangle should appear inside the document.\n+                You should be able to repeat this operation multiple times.\n+                Please, click \"Pass\" if above conditions are true,\n+                otherwise click \"Fail\".\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(DnDToWordpadTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"DnD To WordPad Test\");\n+        Panel mainPanel;\n+        Component dragSource;\n+\n+        mainPanel = new Panel();\n+        mainPanel.setLayout(null);\n+\n+        mainPanel.setBackground(Color.black);\n+        try {\n+            dragSource = new DnDSource(\"Drag ME!\");\n+            mainPanel.add(dragSource);\n+            f.add(mainPanel);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+\n+        f.setSize(200, 200);\n+        return f;\n+    }\n+}\n+\n+class DnDSource extends Button implements Transferable,\n+        DragGestureListener,\n+        DragSourceListener {\n+    private DataFlavor m_df;\n+    private transient int m_dropAction;\n+    private Image m_img;\n+\n+    DnDSource(String label) throws IOException {\n+        super(label);\n+\n+        setBackground(Color.yellow);\n+        setForeground(Color.blue);\n+        setSize(200, 120);\n+\n+        m_df = DataFlavor.imageFlavor;\n+\n+        DragSource dragSource = new DragSource();\n+        dragSource.createDefaultDragGestureRecognizer(\n+                this,\n+                DnDConstants.ACTION_COPY_OR_MOVE,\n+                this\n+        );\n+        dragSource.addDragSourceListener(this);\n+\n+        \/\/ Create test gif image to drag\n+        Path p = Path.of(System.getProperty(\"test.classes\", \".\"));\n+        BufferedImage bImg = new BufferedImage(79, 109, TYPE_INT_ARGB);\n+        Graphics2D cg = bImg.createGraphics();\n+        cg.setColor(Color.RED);\n+        cg.fillRect(0, 0, 79, 109);\n+        ImageIO.write(bImg, \"png\", new File(p + java.io.File.separator +\n+                \"DnDSource_Red.gif\"));\n+\n+        m_img = Toolkit.getDefaultToolkit()\n+                .getImage(System.getProperty(\"test.classes\", \".\")\n+                + java.io.File.separator + \"DnDSource_Red.gif\");\n+\n+        addActionListener(\n+                ae -> Toolkit.getDefaultToolkit().getSystemClipboard().setContents(\n+                        (Transferable) DnDSource.this,\n+                        null\n+                )\n+        );\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.drawImage(m_img, 10, 10, null);\n+    }\n+\n+    \/**\n+     * a Drag gesture has been recognized\n+     *\/\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        System.err.println(\"starting Drag\");\n+        try {\n+            dge.startDrag(null, this, this);\n+        } catch (InvalidDnDOperationException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    \/**\n+     * as the hotspot enters a platform dependent drop site\n+     *\/\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragEnter\");\n+    }\n+\n+    \/**\n+     * as the hotspot moves over a platform dependent drop site\n+     *\/\n+\n+    public void dragOver(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragOver\");\n+        m_dropAction = dsde.getDropAction();\n+        System.out.println(\"m_dropAction = \" + m_dropAction);\n+    }\n+\n+    \/**\n+     * as the operation changes\n+     *\/\n+\n+    public void dragGestureChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragGestureChanged\");\n+        m_dropAction = dsde.getDropAction();\n+        System.out.println(\"m_dropAction = \" + m_dropAction);\n+    }\n+\n+    \/**\n+     * as the hotspot exits a platform dependent drop site\n+     *\/\n+\n+    public void dragExit(DragSourceEvent dsde) {\n+        System.err.println(\"[Source] dragExit\");\n+    }\n+\n+    \/**\n+     * as the operation completes\n+     *\/\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {\n+        System.err.println(\"[Source] dragDropEnd\");\n+    }\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dropActionChanged\");\n+        m_dropAction = dsde.getDropAction();\n+        System.out.println(\"m_dropAction = \" + m_dropAction);\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[]{m_df};\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor sdf) {\n+        System.err.println(\"[Source] isDataFlavorSupported\" + m_df.equals(sdf));\n+        return m_df.equals(sdf);\n+    }\n+\n+    public Object getTransferData(DataFlavor tdf) throws UnsupportedFlavorException {\n+        if (!m_df.equals(tdf)) {\n+            throw new UnsupportedFlavorException(tdf);\n+        }\n+        System.err.println(\"[Source] Ok\");\n+        return m_img;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDToWordpadTest.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+\/*\n+ * @test\n+ * @bug 4395290\n+ * @key headful\n+ * @summary tests that dragExit() is not called before drop()\n+ *\/\n+\n+public class DragExitBeforeDropTest {\n+    private static Frame frame;\n+    private static final DragSourceButton dragSourceButton = new DragSourceButton();\n+    private static final DropTargetPanel dropTargetPanel = new DropTargetPanel();\n+    private static volatile Point srcPoint;\n+    private static volatile Point dstPoint;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            EventQueue.invokeAndWait(DragExitBeforeDropTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                Point p = dragSourceButton.getLocationOnScreen();\n+                Dimension d = dragSourceButton.getSize();\n+                p.translate(d.width \/ 2, d.height \/ 2);\n+                srcPoint = p;\n+\n+                p = dropTargetPanel.getLocationOnScreen();\n+                d = dropTargetPanel.getSize();\n+                p.translate(d.width \/ 2, d.height \/ 2);\n+                dstPoint = p;\n+            });\n+\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (; !srcPoint.equals(dstPoint);\n+                 srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                    sign(dstPoint.y - srcPoint.y))) {\n+                robot.mouseMove(srcPoint.x, srcPoint.y);\n+                robot.delay(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            if (!dropTargetPanel.getStatus()) {\n+                throw new RuntimeException(\"The test failed: dragExit()\"\n+                                           + \" is called before drop()\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new Frame(\"DragExitBeforeDropTest\");\n+        frame.setLayout(new GridLayout(2, 1));\n+        frame.add(dragSourceButton);\n+        frame.add(dropTargetPanel);\n+        frame.setLocationRelativeTo(null);\n+        frame.setSize(300, 400);\n+        frame.setVisible(true);\n+    }\n+\n+    public static int sign(int n) {\n+        return Integer.compare(n, 0);\n+    }\n+\n+    private static class DragSourceButton extends Button implements Serializable,\n+            Transferable,\n+            DragGestureListener,\n+            DragSourceListener {\n+        private final DataFlavor dataflavor =\n+                new DataFlavor(Button.class, \"DragSourceButton\");\n+\n+        public DragSourceButton() {\n+            this(\"DragSourceButton\");\n+        }\n+\n+        public DragSourceButton(String str) {\n+            super(str);\n+\n+            DragSource ds = DragSource.getDefaultDragSource();\n+            ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                                  this);\n+        }\n+\n+        public void dragGestureRecognized(DragGestureEvent dge) {\n+            dge.startDrag(null, this, this);\n+        }\n+\n+        public void dragEnter(DragSourceDragEvent dsde) {}\n+\n+        public void dragExit(DragSourceEvent dse) {}\n+\n+        public void dragOver(DragSourceDragEvent dsde) {}\n+\n+        public void dragDropEnd(DragSourceDropEvent dsde) {}\n+\n+        public void dropActionChanged(DragSourceDragEvent dsde) {}\n+\n+        public Object getTransferData(DataFlavor flavor)\n+                throws UnsupportedFlavorException, IOException {\n+\n+            if (!isDataFlavorSupported(flavor)) {\n+                throw new UnsupportedFlavorException(flavor);\n+            }\n+\n+            Object retObj;\n+\n+            ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n+            ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n+            ooStream.writeObject(this);\n+\n+            ByteArrayInputStream baiStream =\n+                    new ByteArrayInputStream(baoStream.toByteArray());\n+            ObjectInputStream ois = new ObjectInputStream(baiStream);\n+            try {\n+                retObj = ois.readObject();\n+            } catch (ClassNotFoundException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(e.toString());\n+            }\n+\n+            return retObj;\n+        }\n+\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return new DataFlavor[] { dataflavor };\n+        }\n+\n+        public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+            return dataflavor.equals(dflavor);\n+        }\n+    }\n+\n+    private static class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+        final Dimension preferredDimension = new Dimension(200, 100);\n+        volatile boolean testPassed = true;\n+\n+        public DropTargetPanel() {\n+            setDropTarget(new DropTarget(this, this));\n+        }\n+\n+        public boolean getStatus() {\n+            return testPassed;\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return preferredDimension;\n+        }\n+\n+        public void dragEnter(DropTargetDragEvent dtde) {}\n+\n+        public void dragExit(DropTargetEvent dte) {\n+            testPassed = false;\n+        }\n+\n+        public void dragOver(DropTargetDragEvent dtde) {}\n+\n+        public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+        public void drop(DropTargetDropEvent dtde) {\n+            DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+            if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+                dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+            } else {\n+                dtde.rejectDrop();\n+            }\n+\n+            DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+            Component comp = null;\n+\n+            if(dfs != null && dfs.length >= 1) {\n+                Transferable transfer = dtde.getTransferable();\n+\n+                try {\n+                    comp = (Component)transfer.getTransferData(dfs[0]);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                    dtc.dropComplete(false);\n+                }\n+            }\n+            dtc.dropComplete(true);\n+            add(comp);\n+        }\n+    }\n+}\n+\n+\n+\n","filename":"test\/jdk\/java\/awt\/dnd\/DragExitBeforeDropTest.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionAdapter;\n+\n+\/*\n+  @test\n+  @key headful\n+  @bug 4415175\n+  @summary tests DragSource.getDragThreshold() and\n+           that the AWT default drag gesture recognizers\n+           honor the drag gesture motion threshold\n+*\/\n+\n+public class DragThresholdTest {\n+    private static Frame frame;\n+    private static Panel panel;\n+    private static MouseEvent lastMouseEvent;\n+    private static volatile boolean failed;\n+    private static volatile Point startPoint;\n+    private static volatile Point endPoint;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+\n+            EventQueue.invokeAndWait(DragThresholdTest::createAndShowDnD);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                Point p = panel.getLocationOnScreen();\n+                p.translate(50, 50);\n+                startPoint = p;\n+                endPoint = new Point(p.x + 2 * DragSource.getDragThreshold(),\n+                                     p.y + 2 * DragSource.getDragThreshold());\n+            });\n+\n+            robot.mouseMove(startPoint.x, startPoint.y);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (Point p = new Point(startPoint); !p.equals(endPoint);\n+                 p.translate(sign(endPoint.x - p.x),\n+                             sign(endPoint.y - p.y))) {\n+                robot.mouseMove(p.x, p.y);\n+                robot.delay(100);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(200);\n+\n+            if (failed) {\n+                throw new RuntimeException(\"drag gesture recognized too early\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowDnD() {\n+        frame = new Frame(\"DragThresholdTest\");\n+        panel = new Panel();\n+        \/\/ Mouse motion listener mml is added to the panel first.\n+        \/\/ We rely on it that this listener will be called first.\n+        panel.addMouseMotionListener(new MouseMotionAdapter() {\n+            public void mouseDragged(MouseEvent evt) {\n+                lastMouseEvent = evt;\n+                System.out.println(evt);\n+            }\n+        });\n+        frame.add(panel);\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+\n+        DragGestureListener dgl = dge -> {\n+            Point dragOrigin = dge.getDragOrigin();\n+            int diffx = Math.abs(dragOrigin.x - lastMouseEvent.getX());\n+            int diffy = Math.abs(dragOrigin.y - lastMouseEvent.getY());\n+            System.out.println(\"dragGestureRecognized(): \" +\n+                               \" diffx=\" + diffx + \" diffy=\" + diffy +\n+                               \" DragSource.getDragThreshold()=\"\n+                               + DragSource.getDragThreshold());\n+            if (diffx <= DragSource.getDragThreshold() &&\n+                diffy <= DragSource.getDragThreshold()) {\n+                failed = true;\n+                System.out.println(\"drag gesture recognized too early!\");\n+            }\n+        };\n+\n+        \/\/ Default drag gesture recognizer is a mouse motion listener.\n+        \/\/ It is added to the panel second.\n+        new DragSource().createDefaultDragGestureRecognizer(\n+                panel,\n+                DnDConstants.ACTION_COPY_OR_MOVE, dgl);\n+        frame.setVisible(true);\n+    }\n+\n+    private static int sign(int n) {\n+        return Integer.compare(n, 0);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DragThresholdTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4187490\n+ * @summary Verify that Non-ASCII file names can be dragged and dropped\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual NonAsciiFilenames\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.io.File;\n+import java.util.AbstractList;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+\n+public class NonAsciiFilenames {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This test must be run on an OS which does not use ISO 8859-1\n+                as its default encoding.\n+\n+                Open a native file browsing application, such as Windows\n+                Explorer. Try to find a file whose name uses non-ISO 8859-1\n+                characters. Create a file and name it such that it contains\n+                non-ISO 8859-1 characters (For ex. é, à, ö, €, ¥). Drag\n+                the file from the native application and drop it on the test\n+                Frame. If the file name appears normally, then the test passes.\n+                If boxes or question marks appear for characters, or if you see\n+                the word \"Error\", then the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(NonAsciiFilenames::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static JFrame createUI() {\n+        JFrame frame = new JFrame();\n+        frame.setTitle(\"DropLabel test\");\n+        frame.getContentPane().add(new DropLabel(\"Drop here\"));\n+        frame.setSize(300, 100);\n+        return frame;\n+    }\n+}\n+\n+class DropLabel extends JLabel implements DropTargetListener {\n+    public DropLabel(String s) {\n+        setText(s);\n+        new DropTarget(this, DnDConstants.ACTION_COPY, this, true);\n+        showDrop(false);\n+    }\n+\n+    private void showDrop(boolean b) {\n+        setForeground(b ? Color.white : Color.black);\n+    }\n+\n+    \/**\n+     * Configure to desired flavor of dropped data.\n+     *\/\n+    private DataFlavor getDesiredFlavor() {\n+        return DataFlavor.javaFileListFlavor;\n+    }\n+\n+    \/**\n+     * Check to make sure that the contains the expected object types.\n+     *\/\n+    private void checkDroppedData(Object data) {\n+        System.out.println(\"Got data: \" + data.getClass().getName());\n+        if (data instanceof AbstractList) {\n+            AbstractList files = (AbstractList) data;\n+            if (((File) files.get(0)).isFile())\n+                setText(((File) files.get(0)).toString());\n+            else\n+                setText(\"Error: not valid file: \" +\n+                        ((File) files.get(0)).toString());\n+        } else {\n+            System.out.println(\"Error: wrong type of data dropped\");\n+        }\n+    }\n+\n+    private boolean isDragOk(DropTargetDragEvent e) {\n+        boolean canDrop = false;\n+        try {\n+            canDrop = e.isDataFlavorSupported(getDesiredFlavor());\n+        } catch (Exception ex) {\n+        }\n+\n+        if (canDrop)\n+            e.acceptDrag(DnDConstants.ACTION_COPY);\n+        else\n+            e.rejectDrag();\n+        showDrop(canDrop);\n+        return canDrop;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent e) {\n+        isDragOk(e);\n+    }\n+\n+\n+    public void dragOver(DropTargetDragEvent e) {\n+        isDragOk(e);\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent e) {\n+        isDragOk(e);\n+    }\n+\n+    public void dragExit(DropTargetEvent e) {\n+        showDrop(false);\n+    }\n+\n+    public void drop(DropTargetDropEvent e) {\n+        try {\n+            e.acceptDrop(DnDConstants.ACTION_COPY);\n+            checkDroppedData(e.getTransferable().\n+                    getTransferData(getDesiredFlavor()));\n+        } catch (Exception err) {\n+        }\n+        e.dropComplete(true);\n+        showDrop(false);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/NonAsciiFilenames.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4414739\n+ * @requires (os.family == \"windows\")\n+ * @summary verifies that getDropSuccess() returns correct value for moving\n+            a file from a Java drag source to the Windows shell\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual WinMoveFileToShellTest\n+ *\/\n+\n+public class WinMoveFileToShellTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Drag from the frame titled \"Drag Frame\" and drop on to Windows Desktop.\n+            After Drag and Drop, check for \"Drop Success\" status in the log area.\n+            If \"Drop Success\" is true press PASS else FAIL.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .title(\"Test Instructions\")\n+                      .instructions(INSTRUCTIONS)\n+                      .columns(40)\n+                      .testUI(WinMoveFileToShellTest::createAndShowUI)\n+                      .logArea(5)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Frame createAndShowUI() {\n+        Frame frame = new Frame(\"Drag Frame\");\n+        final DragSourceListener dsl = new DragSourceAdapter() {\n+            public void dragDropEnd(DragSourceDropEvent e) {\n+                PassFailJFrame.log(\"Drop Success: \" + e.getDropSuccess());\n+            }\n+        };\n+\n+        DragGestureListener dgl = dge -> {\n+            File file = new File(System.getProperty(\"test.classes\", \".\")\n+                                 + File.separator + \"move.me\");\n+            try {\n+                file.createNewFile();\n+            } catch (IOException exc) {\n+                exc.printStackTrace();\n+            }\n+            ArrayList<File> list = new ArrayList<>();\n+            list.add(file);\n+            dge.startDrag(null, new FileListSelection(list), dsl);\n+        };\n+\n+        new DragSource().createDefaultDragGestureRecognizer(frame,\n+                                                            DnDConstants.ACTION_MOVE, dgl);\n+        frame.setSize(200, 100);\n+        return frame;\n+    }\n+\n+    private static class FileListSelection implements Transferable {\n+        private static final int FL = 0;\n+\n+        private static final DataFlavor[] flavors =\n+                new DataFlavor[] { DataFlavor.javaFileListFlavor };\n+\n+\n+        private List data;\n+\n+        public FileListSelection(List data) {\n+            this.data = data;\n+        }\n+\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return flavors.clone();\n+        }\n+\n+        public boolean isDataFlavorSupported(DataFlavor flavor) {\n+            for (DataFlavor dataFlavor : flavors) {\n+                if (flavor.equals(dataFlavor)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public Object getTransferData(DataFlavor flavor)\n+                throws UnsupportedFlavorException, IOException\n+        {\n+            if (flavor.equals(flavors[FL])) {\n+                return data;\n+            } else {\n+                throw new UnsupportedFlavorException(flavor);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/WinMoveFileToShellTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+\n+import javax.imageio.ImageIO;\n+\n+\/*\n+ * @test\n+ * @bug 8339974\n+ * @summary Verifies that text draws correctly using scaled and rotated fonts.\n+ *\/\n+public class RotatedScaledFontTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(0);\n+        test(1);\n+        test(2);\n+        test(3);\n+        test(4);\n+    }\n+\n+    private static void test(int quadrants) throws Exception {\n+\n+        int size = 2000;\n+        int center = size \/ 2;\n+        Font base = new Font(\"SansSerif\", Font.PLAIN, 10);\n+        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_BYTE_BINARY);\n+        Graphics2D g2d = image.createGraphics();\n+\n+        try {\n+            for (int scale = 1; scale <= 100; scale++) {\n+                AffineTransform at = AffineTransform.getQuadrantRotateInstance(quadrants);\n+                at.scale(scale, scale);\n+                Font font = base.deriveFont(at);\n+                g2d.setColor(Color.WHITE);\n+                g2d.fillRect(0, 0, image.getWidth(), image.getHeight());\n+                g2d.setColor(Color.BLACK);\n+                g2d.setFont(font);\n+                g2d.drawString(\"TEST\", center, center);\n+                Rectangle bounds = findTextBoundingBox(image);\n+                if (bounds == null) {\n+                    saveImage(\"bounds\", image);\n+                    throw new RuntimeException(\"Text missing: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center);\n+                }\n+                boolean horizontal = (bounds.width > bounds.height);\n+                boolean expectedHorizontal = (quadrants % 2 == 0);\n+                if (horizontal != expectedHorizontal) {\n+                    saveImage(\"orientation\", image);\n+                    throw new RuntimeException(\"Wrong orientation: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center\n+                        + \", bounds=\" + bounds + \", horizontal=\" + horizontal\n+                        + \", expectedHorizontal=\" + expectedHorizontal);\n+                }\n+                if (!roughlyEqual(center, bounds.x, scale) && !roughlyEqual(center, bounds.x + bounds.width, scale)) {\n+                    saveImage(\"xedge\", image);\n+                    throw new RuntimeException(\"No x-edge at center: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center\n+                        + \", bounds=\" + bounds);\n+                }\n+                if (!roughlyEqual(center, bounds.y, scale) && !roughlyEqual(center, bounds.y + bounds.height, scale)) {\n+                    saveImage(\"yedge\", image);\n+                    throw new RuntimeException(\"No y-edge at center: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center\n+                        + \", bounds=\" + bounds);\n+                }\n+            }\n+        } finally {\n+            g2d.dispose();\n+        }\n+    }\n+\n+    private static Rectangle findTextBoundingBox(BufferedImage image) {\n+        int minX = Integer.MAX_VALUE;\n+        int minY = Integer.MAX_VALUE;\n+        int maxX = Integer.MIN_VALUE;\n+        int maxY = Integer.MIN_VALUE;\n+        int width = image.getWidth();\n+        int height = image.getHeight();\n+        int[] rowPixels = new int[width];\n+        for (int y = 0; y < height; y++) {\n+            image.getRGB(0, y, width, 1, rowPixels, 0, width);\n+            for (int x = 0; x < width; x++) {\n+                boolean white = (rowPixels[x] == -1);\n+                if (!white) {\n+                    if (x < minX) {\n+                        minX = x;\n+                    }\n+                    if (y < minY) {\n+                        minY = y;\n+                    }\n+                    if (x > maxX) {\n+                        maxX = x;\n+                    }\n+                    if (y > maxY) {\n+                        maxY = y;\n+                    }\n+                }\n+            }\n+        }\n+        if (minX != Integer.MAX_VALUE) {\n+            return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static boolean roughlyEqual(int x1, int x2, int scale) {\n+        return Math.abs(x1 - x2) <= Math.ceil(scale \/ 2d) + 1; \/\/ higher scale = higher allowed variance\n+    }\n+\n+    private static void saveImage(String name, BufferedImage image) {\n+        try {\n+            String dir = System.getProperty(\"test.classes\", \".\");\n+            String path = dir + File.separator + name + \".png\";\n+            File file = new File(path);\n+            ImageIO.write(image, \"png\", file);\n+        } catch (Exception e) {\n+            \/\/ we tried, and that's enough\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/FontScaling\/RotatedScaledFontTest.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.awt.FlowLayout;\n@@ -47,0 +48,1 @@\n+import java.nio.file.Paths;\n@@ -72,0 +74,1 @@\n+import javax.swing.border.Border;\n@@ -290,1 +293,4 @@\n-    private static final String TITLE = \"Test Instruction Frame\";\n+    \/** A default title for the instruction frame. *\/\n+    private static final String TITLE = \"Test Instructions\";\n+\n+    \/** A default test timeout. *\/\n@@ -292,0 +298,2 @@\n+\n+    \/** A default number of rows for displaying the test instructions. *\/\n@@ -293,0 +301,1 @@\n+    \/** A default number of columns for displaying the test instructions. *\/\n@@ -305,1 +314,1 @@\n-     * The failure reason message when the user didn't provide one.\n+     * The failure reason message when the user doesn't provide one.\n@@ -658,0 +667,2 @@\n+        main.setBorder(createFrameBorder());\n+\n@@ -667,1 +678,1 @@\n-        textPanel.setBorder(createEmptyBorder(4, 0, 0, 0));\n+        textPanel.setBorder(createEmptyBorder(GAP, 0, GAP, 0));\n@@ -684,1 +695,2 @@\n-        JPanel buttonsPanel = new JPanel();\n+        JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.CENTER,\n+                                                        GAP, 0));\n@@ -695,0 +707,1 @@\n+            logArea.setBorder(createTextBorder());\n@@ -699,0 +712,1 @@\n+            buttonsLogPanel.add(Box.createVerticalStrut(GAP));\n@@ -716,1 +730,1 @@\n-        text.setBorder(createEmptyBorder(4, 4, 4, 4));\n+        text.setBorder(createTextBorder());\n@@ -738,0 +752,23 @@\n+    \/** A default gap between components. *\/\n+    private static final int GAP = 4;\n+\n+    \/**\n+     * Creates a default border for frames or dialogs.\n+     * It uses the default gap of {@value GAP}.\n+     *\n+     * @return the border for frames and dialogs\n+     *\/\n+    private static Border createFrameBorder() {\n+        return createEmptyBorder(GAP, GAP, GAP, GAP);\n+    }\n+\n+    \/**\n+     * Creates a border set to text area.\n+     * It uses the default gap of {@value GAP}.\n+     *\n+     * @return the border for text area\n+     *\/\n+    private static Border createTextBorder() {\n+        return createEmptyBorder(GAP, GAP, GAP, GAP);\n+    }\n+\n@@ -1089,4 +1126,4 @@\n-        final JDialog dialog = new JDialog(frame, \"Test Failure \", true);\n-        dialog.setTitle(\"Failure reason\");\n-        JPanel jPanel = new JPanel(new BorderLayout());\n-        JTextArea jTextArea = new JTextArea(5, 20);\n+        final JDialog dialog = new JDialog(frame, \"Failure reason\", true);\n+\n+        JTextArea reason = new JTextArea(5, 20);\n+        reason.setBorder(createTextBorder());\n@@ -1096,1 +1133,1 @@\n-            String text = jTextArea.getText();\n+            String text = reason.getText();\n@@ -1102,3 +1139,3 @@\n-        jPanel.add(new JScrollPane(jTextArea), BorderLayout.CENTER);\n-\n-        JPanel okayBtnPanel = new JPanel();\n+        JPanel okayBtnPanel = new JPanel(new FlowLayout(FlowLayout.CENTER,\n+                                                        GAP, 0));\n+        okayBtnPanel.setBorder(createEmptyBorder(GAP, 0, 0, 0));\n@@ -1107,2 +1144,6 @@\n-        jPanel.add(okayBtnPanel, BorderLayout.SOUTH);\n-        dialog.add(jPanel);\n+        JPanel main = new JPanel(new BorderLayout());\n+        main.setBorder(createFrameBorder());\n+        main.add(new JScrollPane(reason), BorderLayout.CENTER);\n+        main.add(okayBtnPanel, BorderLayout.SOUTH);\n+\n+        dialog.add(main);\n@@ -1793,0 +1834,32 @@\n+        \/**\n+         * Returns the file name of the test, if the {@code test.file} property\n+         * is defined, concatenated with {@code \" - \"} which serves as a prefix\n+         * to the default instruction frame title;\n+         * or an empty string if the {@code test.file} property is not defined.\n+         *\n+         * @return the prefix to the default title:\n+         *         either the file name of the test or an empty string\n+         *\n+         * @see <a href=\"https:\/\/openjdk.org\/jtreg\/tag-spec.html#testvars\">jtreg\n+         * test-specific system properties and environment variables<\/a>\n+         *\/\n+        private static String getTestFileNamePrefix() {\n+            String testFile = System.getProperty(\"test.file\");\n+            if (testFile == null) {\n+                return \"\";\n+            }\n+\n+            return Paths.get(testFile).getFileName().toString()\n+                   + \" - \";\n+        }\n+\n+        \/**\n+         * Validates the state of the builder and\n+         * expands parameters that have no assigned values\n+         * to their default values.\n+         *\n+         * @throws IllegalStateException if no instructions are provided,\n+         *              or if {@code PositionWindows} implementation is\n+         *              provided but neither window creator nor\n+         *              test window list are set\n+         *\/\n@@ -1795,1 +1868,1 @@\n-                title = TITLE;\n+                title = getTestFileNamePrefix() + TITLE;\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":89,"deletions":16,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,2 @@\n+        System.out.println(INDENT + \"CollectionThresholdCount: \" +\n+            (pool.isCollectionUsageThresholdSupported() ? pool.getCollectionUsageThresholdCount() : -1));\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryUtil.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+        opts.add(\"trace\");\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/RunUtil.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm -Djava.locale.providers=CLDR,SPI DateFormatProviderTest\n+ * @run main\/othervm\/timeout=300 -Djava.locale.providers=CLDR,SPI DateFormatProviderTest\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/DateFormatProviderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8341595\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Verify that ZipFile can read from a ZIP file with a maximally large CEN size\n+ * @run junit\/othervm\/manual -Xmx2500M CenSizeMaximum\n+ *\/\n+\n+import jdk.internal.util.ArraysSupport;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class CenSizeMaximum {\n+\n+    \/\/ Maximum allowed CEN size allowed by the ZipFile implementation\n+    static final int MAX_CEN_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n+\n+    \/**\n+     * From the APPNOTE.txt specification:\n+     *    4.4.10 file name length: (2 bytes)\n+     *    4.4.11 extra field length: (2 bytes)\n+     *    4.4.12 file comment length: (2 bytes)\n+     *\n+     *        The length of the file name, extra field, and comment\n+     *        fields respectively.  The combined length of any\n+     *        directory record and these three fields SHOULD NOT\n+     *        generally exceed 65,535 bytes.\n+     *.\n+     * Create a maximum extra field which does not exceed 65,535 bytes\n+     *\/\n+    static final int MAX_EXTRA_FIELD_SIZE = 65_535 - ZipFile.CENHDR;\n+\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+\n+    \/\/ The size of one CEN header, including the name and the extra field\n+    static final int CEN_HEADER_SIZE = ZipFile.CENHDR + MAX_EXTRA_FIELD_SIZE;\n+\n+    \/\/ The size of the extra data field header (tag id + data block length)\n+    static final int EXTRA_FIELD_HEADER_SIZE = 2 * Short.BYTES;\n+\n+    \/\/ Zip file to create for testing\n+    private Path hugeZipFile = Path.of(\"cen-size-on-limit.zip\");\n+\n+    \/**\n+     * Clean up ZIP file created in this test\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        \/\/Files.deleteIfExists(hugeZipFile);\n+    }\n+\n+    \/**\n+     * Validates that ZipFile opens a ZIP file with a CEN size close\n+     * to the {@link #MAX_CEN_SIZE} implementation limit.\n+     *\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    @Test\n+    public void maximumCenSize() throws IOException {\n+        int numCenHeaders = zipWithWithExactCenSize(MAX_CEN_SIZE, true, false);\n+        try (var zf = new ZipFile(hugeZipFile.toFile())) {\n+            assertEquals(numCenHeaders, zf.size());\n+        }\n+    }\n+\n+    \/**\n+     * Validates that ZipFile rejects a ZIP where the last CEN record\n+     * overflows the CEN size and the END header CENTOT field is smaller\n+     * than the actual number of headers\n+     *\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    @Test\n+    public void lastCENHeaderBadSize() throws IOException {\n+        int numCenHeaders = zipWithWithExactCenSize(1024, true, true);\n+        ZipException zipException = assertThrows(ZipException.class, () -> {\n+            try (var zf = new ZipFile(hugeZipFile.toFile())) {\n+                assertEquals(numCenHeaders, zf.size());\n+            }\n+        });\n+        assertEquals(\"invalid CEN header (bad header size)\", zipException.getMessage());\n+\n+    }\n+\n+    \/**\n+     * Produce a ZIP file with an exact CEN size. To minimize the number of CEN headers\n+     * written, maximally large, empty extra data blocks are written sparsely.\n+     *\n+     * @param cenSize the exact CEN size of the ZIP file to produce\n+     * @param invalidateEndTotal whether to decrement the END header's TOT field by one\n+     * @return the number of CEN headers produced\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    private int zipWithWithExactCenSize(long cenSize, boolean invalidateEndTotal, boolean overflowLastCEN)\n+            throws IOException {\n+        \/\/ Sanity check\n+        assertTrue(cenSize <= MAX_CEN_SIZE);\n+\n+        \/\/ The number of CEN headers we need to write\n+        int numCenHeaders = (int) (cenSize \/ CEN_HEADER_SIZE) + 1;\n+        \/\/ Size if all extra data fields were of maximum size\n+        long overSized = numCenHeaders * (long) CEN_HEADER_SIZE;\n+        \/\/ Length to trim from the first CEN's extra data\n+        int negativPadding = (int) (overSized - cenSize);\n+        int firstExtraSize = MAX_EXTRA_FIELD_SIZE - negativPadding;\n+\n+        \/\/ Sanity check\n+        long computedCenSize = (numCenHeaders -1L ) * CEN_HEADER_SIZE + ZipEntry.CENHDR + firstExtraSize;\n+        assertEquals(computedCenSize, cenSize);\n+\n+        \/\/ A CEN header, followed by the four-bytes extra data header\n+        ByteBuffer cenHeader = createCENHeader();\n+        \/\/ An END header\n+        ByteBuffer endHeader = createENDHeader();\n+        \/\/ Update the END header\n+        if (invalidateEndTotal) {\n+            \/\/ To trigger countCENHeaders\n+            endHeader.putShort(ZipEntry.ENDTOT, (short) (numCenHeaders -1 & 0xFFFF));\n+        } else {\n+            endHeader.putShort(ZipEntry.ENDTOT, (short) (numCenHeaders & 0xFFFF));\n+        }\n+        \/\/ Update CEN size and offset fields\n+        endHeader.putInt(ZipEntry.ENDSIZ, (int) (cenSize & 0xFFFFFFFFL));\n+        endHeader.putInt(ZipEntry.ENDOFF, 0);\n+\n+        \/\/ When creating a sparse file, the file must not already exit\n+        Files.deleteIfExists(hugeZipFile);\n+\n+        \/\/ Open a FileChannel for writing a sparse file\n+        EnumSet<StandardOpenOption> options = EnumSet.of(StandardOpenOption.CREATE_NEW,\n+                StandardOpenOption.WRITE,\n+                StandardOpenOption.SPARSE);\n+\n+        try (FileChannel channel = FileChannel.open(hugeZipFile, options)) {\n+            \/\/ Write CEN headers\n+            for (int i = 0; i < numCenHeaders; i++) {\n+                \/\/ The first CEN header has trimmed extra data\n+                int extraSize = i == 0 ? firstExtraSize : MAX_EXTRA_FIELD_SIZE;\n+                if (overflowLastCEN && i == numCenHeaders - 1) {\n+                    \/\/ make last CEN header overflow the CEN size\n+                    cenHeader.putShort(ZipEntry.CENNAM, Short.MAX_VALUE);\n+                }\n+                \/\/ update elen field\n+                cenHeader.putShort(ZipEntry.CENEXT, (short) (extraSize & 0xFFFF));\n+                \/\/ update data block len of the extra field header\n+                short dlen = (short) ((extraSize - EXTRA_FIELD_HEADER_SIZE) & 0xFFFF);\n+                cenHeader.putShort(ZipEntry.CENHDR + Short.BYTES, dlen);\n+                \/\/ Write the CEN header plus the four-byte extra header\n+                channel.write(cenHeader.rewind());\n+                \/\/ Sparse \"write\" of the extra data block\n+                channel.position(channel.position() + extraSize - EXTRA_FIELD_HEADER_SIZE);\n+            }\n+            \/\/ Sanity check\n+            assertEquals(cenSize,  channel.position());\n+            \/\/ Write the END header\n+            channel.write(endHeader.rewind());\n+        }\n+        return numCenHeaders;\n+    }\n+\n+    \/\/ Creates a ByteBuffer representing a CEN header with a trailing extra field header\n+    private ByteBuffer createCENHeader() throws IOException {\n+        byte[] bytes = smallZipfile();\n+        ByteBuffer buf = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+        int endOff = bytes.length - ZipEntry.ENDHDR;\n+        int cenSize = buf.getInt(endOff + ZipEntry.ENDSIZ);\n+        int cenOff = buf.getInt(endOff + ZipEntry.ENDOFF);\n+        return ByteBuffer.wrap(\n+                Arrays.copyOfRange(bytes, cenOff, cenOff + ZipEntry.CENHDR + EXTRA_FIELD_HEADER_SIZE)\n+        ).order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    \/\/ Creates a ByteBuffer representing an END header\n+    private ByteBuffer createENDHeader() throws IOException {\n+        byte[] bytes = smallZipfile();\n+        ByteBuffer buf = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+        int endOff = bytes.length - ZipEntry.ENDHDR;\n+        return ByteBuffer.wrap(\n+                        Arrays.copyOfRange(bytes, endOff, endOff + ZipEntry.ENDHDR)\n+        ).order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    \/\/ Create a byte array with a minimal ZIP file\n+    private static byte[] smallZipfile() throws IOException {\n+        var out = new ByteArrayOutputStream();\n+        try (var zo = new ZipOutputStream(out)) {\n+            ZipEntry entry = new ZipEntry(\"\");\n+            entry.setExtra(makeDummyExtraField());\n+            zo.putNextEntry(entry);\n+        }\n+        return out.toByteArray();\n+    }\n+\n+    \/\/ Create a minimally sized extra field\n+    private static byte[] makeDummyExtraField() {\n+        byte[] extra = new byte[EXTRA_FIELD_HEADER_SIZE];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort((short) 0);\n+        return extra;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeMaximum.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm EndOfCenValidation\n+ * @run junit\/othervm EndOfCenValidation\n@@ -32,3 +32,5 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -46,0 +48,1 @@\n+import java.util.HexFormat;\n@@ -51,1 +54,1 @@\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -73,1 +76,1 @@\n-    private static int MAX_CEN_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n+    private static final int MAX_CEN_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n@@ -81,0 +84,2 @@\n+    \/\/ Expected message when total entry count is too large\n+    private static final String INVALID_BAD_ENTRY_COUNT = \"invalid END header (total entries count too large)\";\n@@ -89,1 +94,1 @@\n-    @BeforeTest\n+    @BeforeEach\n@@ -98,1 +103,1 @@\n-    @AfterTest\n+    @AfterEach\n@@ -116,1 +121,1 @@\n-        ZipException ex = expectThrows(ZipException.class, () -> {\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n@@ -120,1 +125,1 @@\n-        assertEquals(ex.getMessage(), INVALID_CEN_SIZE_TOO_LARGE);\n+        assertEquals(INVALID_CEN_SIZE_TOO_LARGE, ex.getMessage());\n@@ -136,1 +141,1 @@\n-        ZipException ex = expectThrows(ZipException.class, () -> {\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n@@ -140,1 +145,1 @@\n-        assertEquals(ex.getMessage(), INVALID_CEN_BAD_SIZE);\n+        assertEquals(INVALID_CEN_BAD_SIZE, ex.getMessage());\n@@ -156,1 +161,1 @@\n-        ZipException ex = expectThrows(ZipException.class, () -> {\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n@@ -160,1 +165,128 @@\n-        assertEquals(ex.getMessage(), INVALID_CEN_BAD_OFFSET);\n+        assertEquals(INVALID_CEN_BAD_OFFSET, ex.getMessage());\n+    }\n+\n+    \/**\n+     * Validate that a 'Zip64 End of Central Directory' record (the END header)\n+     * where the value of the 'total entries' field is larger than what fits\n+     * in the CEN size is rejected.\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(longs = {\n+            -1,                   \/\/ Negative\n+            Long.MIN_VALUE,       \/\/ Very negative\n+            0x3B \/ 3L - 1,        \/\/ Cannot fit in test ZIP's CEN\n+            MAX_CEN_SIZE \/ 3 + 1, \/\/ Too large to allocate int[] entries array\n+            Long.MAX_VALUE        \/\/ Unreasonably large\n+    })\n+    public void shouldRejectBadTotalEntries(long totalEntries) throws IOException {\n+        \/**\n+         * A small ZIP using the ZIP64 format.\n+         *\n+         * ZIP created using: \"echo -n hello | zip zip64.zip -\"\n+         * Hex encoded using: \"cat zip64.zip | xxd -ps\"\n+         *\n+         * The file has the following structure:\n+         *\n+         * 0000 LOCAL HEADER #1       04034B50\n+         * 0004 Extract Zip Spec      2D '4.5'\n+         * 0005 Extract OS            00 'MS-DOS'\n+         * 0006 General Purpose Flag  0000\n+         * 0008 Compression Method    0000 'Stored'\n+         * 000A Last Mod Time         5947AB78 'Mon Oct  7 21:27:48 2024'\n+         * 000E CRC                   363A3020\n+         * 0012 Compressed Length     FFFFFFFF\n+         * 0016 Uncompressed Length   FFFFFFFF\n+         * 001A Filename Length       0001\n+         * 001C Extra Length          0014\n+         * 001E Filename              '-'\n+         * 001F Extra ID #0001        0001 'ZIP64'\n+         * 0021   Length              0010\n+         * 0023   Uncompressed Size   0000000000000006\n+         * 002B   Compressed Size     0000000000000006\n+         * 0033 PAYLOAD               hello.\n+         *\n+         * 0039 CENTRAL HEADER #1     02014B50\n+         * 003D Created Zip Spec      1E '3.0'\n+         * 003E Created OS            03 'Unix'\n+         * 003F Extract Zip Spec      2D '4.5'\n+         * 0040 Extract OS            00 'MS-DOS'\n+         * 0041 General Purpose Flag  0000\n+         * 0043 Compression Method    0000 'Stored'\n+         * 0045 Last Mod Time         5947AB78 'Mon Oct  7 21:27:48 2024'\n+         * 0049 CRC                   363A3020\n+         * 004D Compressed Length     00000006\n+         * 0051 Uncompressed Length   FFFFFFFF\n+         * 0055 Filename Length       0001\n+         * 0057 Extra Length          000C\n+         * 0059 Comment Length        0000\n+         * 005B Disk Start            0000\n+         * 005D Int File Attributes   0001\n+         *      [Bit 0]               1 Text Data\n+         * 005F Ext File Attributes   11B00000\n+         * 0063 Local Header Offset   00000000\n+         * 0067 Filename              '-'\n+         * 0068 Extra ID #0001        0001 'ZIP64'\n+         * 006A   Length              0008\n+         * 006C   Uncompressed Size   0000000000000006\n+         *\n+         * 0074 ZIP64 END CENTRAL DIR 06064B50\n+         *      RECORD\n+         * 0078 Size of record        000000000000002C\n+         * 0080 Created Zip Spec      1E '3.0'\n+         * 0081 Created OS            03 'Unix'\n+         * 0082 Extract Zip Spec      2D '4.5'\n+         * 0083 Extract OS            00 'MS-DOS'\n+         * 0084 Number of this disk   00000000\n+         * 0088 Central Dir Disk no   00000000\n+         * 008C Entries in this disk  0000000000000001\n+         * 0094 Total Entries         0000000000000001\n+         * 009C Size of Central Dir   000000000000003B\n+         * 00A4 Offset to Central dir 0000000000000039\n+         *\n+         * 00AC ZIP64 END CENTRAL DIR 07064B50\n+         *      LOCATOR\n+         * 00B0 Central Dir Disk no   00000000\n+         * 00B4 Offset to Central dir 0000000000000074\n+         * 00BC Total no of Disks     00000001\n+         *\n+         * 00C0 END CENTRAL HEADER    06054B50\n+         * 00C4 Number of this disk   0000\n+         * 00C6 Central Dir Disk no   0000\n+         * 00C8 Entries in this disk  0001\n+         * 00CA Total Entries         0001\n+         * 00CC Size of Central Dir   0000003B\n+         * 00D0 Offset to Central Dir FFFFFFFF\n+         * 00D4 Comment Length        0000\n+         *\/\n+\n+        byte[] zipBytes = HexFormat.of().parseHex(\"\"\"\n+                504b03042d000000000078ab475920303a36ffffffffffffffff01001400\n+                2d010010000600000000000000060000000000000068656c6c6f0a504b01\n+                021e032d000000000078ab475920303a3606000000ffffffff01000c0000\n+                00000001000000b011000000002d010008000600000000000000504b0606\n+                2c000000000000001e032d00000000000000000001000000000000000100\n+                0000000000003b000000000000003900000000000000504b060700000000\n+                740000000000000001000000504b050600000000010001003b000000ffff\n+                ffff0000\n+                \"\"\".replaceAll(\"\\n\",\"\"));\n+\n+        \/\/ Buffer to manipulate the above ZIP\n+        ByteBuffer buf = ByteBuffer.wrap(zipBytes).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Offset of the 'total entries' in the 'ZIP64 END CENTRAL DIR' record\n+        \/\/ Update ZIP64 entry count to a value which cannot possibly fit in the small CEN\n+        buf.putLong(0x94, totalEntries);\n+        \/\/ The corresponding END field needs the ZIP64 magic value\n+        buf.putShort(0xCA, (short) 0xFFFF);\n+        \/\/ Write the ZIP to disk\n+        Path zipFile = Path.of(\"bad-entry-count.zip\");\n+        Files.write(zipFile, zipBytes);\n+\n+        \/\/ Verify that the END header is rejected\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (var zf = new ZipFile(zipFile.toFile())) {\n+            }\n+        });\n+\n+        assertEquals(INVALID_BAD_ENTRY_COUNT, ex.getMessage());\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EndOfCenValidation.java","additions":146,"deletions":14,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import javax.print.Doc;\n+import javax.print.DocFlavor;\n+import javax.print.DocPrintJob;\n+import javax.print.SimpleDoc;\n+import javax.print.StreamPrintService;\n+import javax.print.StreamPrintServiceFactory;\n+import javax.print.event.PrintJobAdapter;\n+import javax.print.event.PrintJobEvent;\n+\n+\/*\n+ * @test\n+ * @bug 8339974\n+ * @summary Verifies that text prints correctly using scaled and rotated fonts.\n+ *\/\n+public class PostScriptRotatedScaledFontTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(0);\n+        test(1);\n+        test(2);\n+        test(3);\n+        test(4);\n+    }\n+\n+    private static void test(int quadrants) throws Exception {\n+\n+        DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;\n+        String mime = \"application\/postscript\";\n+        StreamPrintServiceFactory[] factories = StreamPrintServiceFactory.lookupStreamPrintServiceFactories(flavor, mime);\n+        if (factories.length == 0) {\n+            throw new RuntimeException(\"Unable to find PostScript print service factory\");\n+        }\n+\n+        StreamPrintServiceFactory factory = factories[0];\n+\n+        \/\/ required to trigger \"text-as-shapes\" code path in\n+        \/\/ PSPathGraphics.drawString(String, float, float, Font, FontRenderContext, float)\n+        \/\/ for *all* text, not just text that uses a transformed font\n+        String shapeText = \"sun.java2d.print.shapetext\";\n+        System.setProperty(shapeText, \"true\");\n+\n+        try {\n+            for (int scale = 1; scale <= 100; scale++) {\n+\n+                ByteArrayOutputStream output = new ByteArrayOutputStream();\n+                StreamPrintService service = factory.getPrintService(output);\n+                DocPrintJob job = service.createPrintJob();\n+\n+                PrintJobMonitor monitor = new PrintJobMonitor();\n+                job.addPrintJobListener(monitor);\n+\n+                Printable printable = new TestPrintable(scale, quadrants);\n+                Doc doc = new SimpleDoc(printable, flavor, null);\n+                job.print(doc, null);\n+                monitor.waitForJobToFinish();\n+\n+                byte[] ps = output.toByteArray();\n+                Rectangle2D.Double bounds = findTextBoundingBox(ps);\n+                if (bounds == null) {\n+                    throw new RuntimeException(\"Text missing: scale=\" + scale\n+                        + \", quadrants=\" + quadrants);\n+                }\n+\n+                boolean horizontal = (bounds.width > bounds.height);\n+                boolean expectedHorizontal = (quadrants % 2 == 0);\n+                if (horizontal != expectedHorizontal) {\n+                    throw new RuntimeException(\"Wrong orientation: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", bounds=\" + bounds\n+                        + \", expectedHorizontal=\" + expectedHorizontal\n+                        + \", horizontal=\" + horizontal);\n+                }\n+            }\n+        } finally {\n+            System.clearProperty(shapeText);\n+        }\n+    }\n+\n+    \/\/ very basic, uses moveto (\"x y M\"), lineto (\"x y L\"), and curveto (\"x1 y1 x2 y2 x3 y3 C\")\n+    private static Rectangle2D.Double findTextBoundingBox(byte[] ps) {\n+        double minX = Double.MAX_VALUE;\n+        double minY = Double.MAX_VALUE;\n+        double maxX = Double.MIN_VALUE;\n+        double maxY = Double.MIN_VALUE;\n+        boolean pastPageClip = false;\n+        List< String > lines = new String(ps, StandardCharsets.ISO_8859_1).lines().toList();\n+        for (String line : lines) {\n+            if (!pastPageClip) {\n+                pastPageClip = \"WC\".equals(line);\n+                continue;\n+            }\n+            String[] values = line.split(\" \");\n+            if (values.length == 3 || values.length == 7) {\n+                String cmd = values[values.length - 1];\n+                if (\"M\".equals(cmd) || \"L\".equals(cmd) || \"C\".equals(cmd)) {\n+                    String sx = values[values.length - 3];\n+                    String sy = values[values.length - 2];\n+                    double x = Double.parseDouble(sx);\n+                    double y = Double.parseDouble(sy);\n+                    if (x < minX) {\n+                        minX = x;\n+                    }\n+                    if (y < minY) {\n+                        minY = y;\n+                    }\n+                    if (x > maxX) {\n+                        maxX = x;\n+                    }\n+                    if (y > maxY) {\n+                        maxY = y;\n+                    }\n+                }\n+            }\n+        }\n+        if (minX != Double.MAX_VALUE) {\n+            return new Rectangle2D.Double(minX, minY, maxX - minX, maxY - minY);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static final class TestPrintable implements Printable {\n+        private final int scale;\n+        private final int quadrants;\n+        public TestPrintable(int scale, int quadrants) {\n+            this.scale = scale;\n+            this.quadrants = quadrants;\n+        }\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n+            if (pageIndex > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+            AffineTransform at = AffineTransform.getQuadrantRotateInstance(quadrants);\n+            at.scale(scale, scale);\n+            Font base = new Font(\"SansSerif\", Font.PLAIN, 10);\n+            Font font = base.deriveFont(at);\n+            graphics.setFont(font);\n+            graphics.drawString(\"TEST\", 300, 300);\n+            return PAGE_EXISTS;\n+        }\n+    }\n+\n+    private static class PrintJobMonitor extends PrintJobAdapter {\n+        private boolean finished;\n+        @Override\n+        public void printJobCanceled(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobCompleted(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobFailed(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobNoMoreEvents(PrintJobEvent pje) {\n+            finished();\n+        }\n+        private synchronized void finished() {\n+            finished = true;\n+            notify();\n+        }\n+        public synchronized void waitForJobToFinish() {\n+            try {\n+                while (!finished) {\n+                    wait();\n+                }\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/print\/PostScriptRotatedScaledFontTest.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -29,0 +29,2 @@\n+import jtreg.SkippedException;\n+\n@@ -32,1 +34,1 @@\n- * @library \/java\/awt\/regtesthelpers\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n@@ -41,0 +43,7 @@\n+\n+        \/\/ ColorChooser UI design is different for GTK L&F.\n+        \/\/ There is no Swatches tab available for GTK L&F, skip the testing.\n+        if (UIManager.getLookAndFeel().getName().contains(\"GTK\")) {\n+            throw new SkippedException(\"Test not applicable for GTK L&F\");\n+        }\n+\n@@ -48,1 +57,0 @@\n-                .rows(5)\n@@ -50,1 +58,0 @@\n-                .testTimeOut(10)\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test4887836.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4587721\n+ * @summary Tests if JFileChooser details view chops off text\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual bug4587721\n+ *\/\n+\n+import java.awt.Font;\n+import java.util.Enumeration;\n+\n+import javax.swing.JFileChooser;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.FontUIResource;\n+import javax.swing.plaf.metal.MetalLookAndFeel;\n+\n+public class bug4587721 {\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(new MetalLookAndFeel());\n+\n+        String instructions = \"\"\"\n+                Click on the Details button in JFileChooser Window.\n+                If the filename text is chopped off by height,\n+                then Press FAIL else Press PASS.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"bug4587721\")\n+                .instructions(instructions)\n+                .columns(40)\n+                .testUI(bug4587721::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static JFileChooser createUI() {\n+        setFonts();\n+        JFileChooser fc = new JFileChooser();\n+        return fc;\n+    }\n+\n+    public static void setFonts() {\n+        UIDefaults defaults = UIManager.getDefaults();\n+        Enumeration keys = defaults.keys();\n+        while (keys.hasMoreElements()) {\n+            Object key = keys.nextElement();\n+            if (defaults.get(key) instanceof Font)\n+                UIManager.put(key, new FontUIResource(new Font(\"Courier\", Font.BOLD, 30)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/bug4587721.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.*;\n-import java.util.ArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import javax.swing.JFrame;\n-import javax.swing.JLabel;\n-import javax.swing.JTabbedPane;\n-\n-import static javax.swing.UIManager.*;\n-import static javax.swing.SwingUtilities.*;\n-\n-\/*\n- * @test\n- * @key headful\n- * @bug 8007563\n- * @summary Tests JTabbedPane background\n- * @author Sergey Malenkov\n- *\/\n-\n-public class Test8007563 implements Runnable {\n-    private static final ArrayList<String> LIST = new ArrayList<>();\n-    private static final LookAndFeelInfo[] INFO = getInstalledLookAndFeels();\n-    private static final CountDownLatch LATCH = new CountDownLatch(INFO.length);\n-    private static Robot ROBOT;\n-\n-    public static void main(String[] args) throws Exception {\n-        ROBOT = new Robot();\n-        invokeLater(new Test8007563());\n-        LATCH.await();\n-        if (!LIST.isEmpty()) {\n-            throw new Error(LIST.toString());\n-        }\n-    }\n-\n-    private static void addOpaqueError(boolean opaque) {\n-        LIST.add(getLookAndFeel().getName() + \" opaque=\" + opaque);\n-    }\n-\n-    private static boolean updateLookAndFeel() {\n-        int index = (int) LATCH.getCount() - 1;\n-        if (index >= 0) {\n-            try {\n-                LookAndFeelInfo info = INFO[index];\n-                System.err.println(\"L&F: \" + info.getName());\n-                setLookAndFeel(info.getClassName());\n-                return true;\n-            } catch (Exception exception) {\n-                exception.printStackTrace();\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private JFrame frame;\n-    private JTabbedPane pane;\n-\n-    public void run() {\n-        if (this.frame == null) {\n-            if (!updateLookAndFeel()) {\n-                return;\n-            }\n-            this.pane = new JTabbedPane();\n-            this.pane.setOpaque(false);\n-            this.pane.setBackground(Color.RED);\n-            for (int i = 0; i < 3; i++) {\n-                this.pane.addTab(\"Tab \" + i, new JLabel(\"Content area \" + i));\n-            }\n-            this.frame = new JFrame(getClass().getSimpleName());\n-            this.frame.getContentPane().setBackground(Color.BLUE);\n-            this.frame.add(this.pane);\n-            this.frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n-            this.frame.setSize(400, 200);\n-            this.frame.setLocationRelativeTo(null);\n-            this.frame.setVisible(true);\n-        } else {\n-            Point point = new Point(this.pane.getWidth() - 2, 2);\n-            convertPointToScreen(point, this.pane);\n-            Color actual = ROBOT.getPixelColor(point.x, point.y);\n-\n-            boolean opaque = this.pane.isOpaque();\n-            Color expected = opaque\n-                    ? this.pane.getBackground()\n-                    : this.frame.getContentPane().getBackground();\n-\n-            if (!expected.equals(actual)){\n-                addOpaqueError(opaque);\n-            }\n-            if (!opaque) {\n-                this.pane.setOpaque(true);\n-                this.pane.repaint();\n-            } else {\n-                this.frame.dispose();\n-                this.frame = null;\n-                this.pane = null;\n-                LATCH.countDown();\n-            }\n-\n-        }\n-        SecondaryLoop secondaryLoop =\n-                Toolkit.getDefaultToolkit().getSystemEventQueue()\n-                        .createSecondaryLoop();\n-        new Thread() {\n-            @Override\n-            public void run() {\n-                try {\n-                    Thread.sleep(200);\n-                } catch (InterruptedException e) {\n-                }\n-                secondaryLoop.exit();\n-                invokeLater(Test8007563.this);\n-            }\n-        }.start();\n-        secondaryLoop.enter();\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/8007563\/Test8007563.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.util.ArrayList;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JTabbedPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8007563\n+ * @summary Tests JTabbedPane background\n+ *\/\n+\n+public class TestJTabbedPaneBackgroundColor {\n+    private static ArrayList<String> lafList = new ArrayList<>();\n+    private static JFrame frame;\n+    private static JTabbedPane pane;\n+    private static Robot robot;\n+    private static volatile Dimension dim;\n+    private static volatile Point loc;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing: \" + laf.getName());\n+            setLookAndFeel(laf);\n+\n+            try {\n+                SwingUtilities.invokeAndWait(TestJTabbedPaneBackgroundColor::createAndShowUI);\n+                robot.waitForIdle();\n+                robot.delay(500);\n+\n+                SwingUtilities.invokeAndWait(() -> {\n+                    loc = pane.getLocationOnScreen();\n+                    dim = pane.getSize();\n+                });\n+\n+                loc = new Point(loc.x + dim.width - 2, loc.y + 2);\n+                doTesting(loc, laf);\n+\n+                if (!pane.isOpaque()) {\n+                    pane.setOpaque(true);\n+                    pane.repaint();\n+                }\n+                robot.waitForIdle();\n+                robot.delay(500);\n+\n+                doTesting(loc, laf);\n+\n+            } finally {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                        frame.dispose();\n+                    }\n+                });\n+            }\n+        }\n+        if (!lafList.isEmpty()) {\n+            throw new RuntimeException(lafList.toString());\n+        }\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        pane = new JTabbedPane();\n+        pane.setOpaque(false);\n+        pane.setBackground(Color.RED);\n+        for (int i = 0; i < 3; i++) {\n+            pane.addTab(\"Tab \" + i, new JLabel(\"Content area \" + i));\n+        }\n+        frame = new JFrame(\"Test Background Color\");\n+        frame.getContentPane().setBackground(Color.BLUE);\n+        frame.add(pane);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.setSize(400, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void doTesting(Point p, UIManager.LookAndFeelInfo laf) {\n+        boolean isOpaque = pane.isOpaque();\n+        Color actual = robot.getPixelColor(p.x, p.y);\n+        Color expected = isOpaque\n+                ? pane.getBackground()\n+                : frame.getContentPane().getBackground();\n+\n+        if (!expected.equals(actual)) {\n+            addOpaqueError(laf.getName(), isOpaque);\n+        }\n+    }\n+\n+    private static void addOpaqueError(String lafName, boolean opaque) {\n+        lafList.add(lafName + \" opaque=\" + opaque);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/TestJTabbedPaneBackgroundColor.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import javax.swing.JColorChooser;\n+import javax.swing.UIManager;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 4419255\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame\n+ * @summary Tests if Metal Slider's thumb isn't clipped\n+ * @run main\/manual bug4419255\n+ *\/\n+\n+public class bug4419255 {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ ColorChooser UI design is different for GTK L&F.\n+        \/\/ There is no RGB tab available for GTK L&F, skip the testing.\n+        if (UIManager.getLookAndFeel().getName().contains(\"GTK\")) {\n+            throw new SkippedException(\"Test not applicable for GTK L&F\");\n+        }\n+        String instructions = \"\"\"\n+                Choose RGB tab. If sliders' thumbs are painted correctly\n+                (top is not clipped, black line is visible),\n+                then test passed. Otherwise it failed.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"bug4419255\")\n+                .instructions(instructions)\n+                .columns(40)\n+                .testUI(bug4419255::createColorChooser)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JColorChooser createColorChooser() {\n+        return new JColorChooser(Color.BLUE);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicSliderUI\/bug4419255.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -123,1 +123,1 @@\n-        int[] powers = new int[7 * UtilAccess.significantOctalDigits()];\n+        int[] powers = new int[64];\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerBasic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +32,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestSystemMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestUseContainerSupport.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @requires vm.compMode!=\"Xint\"\n+ * @requires vm.compMode == \"Xmixed\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerCompile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- *\n+ * @requires vm.compMode == \"Xmixed\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerInlining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @requires vm.compMode != \"Xint\"\n+ * @requires vm.compMode == \"Xmixed\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestDeoptimization.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4269775\n+ * @bug 4269775 8341535\n@@ -49,0 +49,2 @@\n+import javax.imageio.ImageIO;\n+import java.io.File;\n@@ -108,1 +110,5 @@\n-    static void compare(BufferedImage bi1, BufferedImage bi2) {\n+    static void compare(BufferedImage bi1, String name1, BufferedImage bi2, String name2) throws Exception {\n+        int nonWhite1 = 0;\n+        int nonWhite2 = 0;\n+        int differences = 0;\n+        int whitePixel = Color.white.getRGB();\n@@ -111,0 +117,4 @@\n+                int pix1 = bi1.getRGB(x, y);\n+                int pix2 = bi2.getRGB(x, y);\n+                if (pix1 != whitePixel) { nonWhite1++; }\n+                if (pix2 != whitePixel) { nonWhite2++; }\n@@ -112,1 +122,1 @@\n-                    throw new RuntimeException(\"Different rendering\");\n+                    differences++;\n@@ -116,0 +126,9 @@\n+        int nonWhite = (nonWhite1 < nonWhite2) ? nonWhite1 : nonWhite2;\n+        if (differences > 0 && ((nonWhite \/ differences) < 20)) {\n+             ImageIO.write(bi1, \"png\", new File(name1 + \".png\"));\n+             ImageIO.write(bi2, \"png\", new File(name2 + \".png\"));\n+             System.err.println(\"nonWhite image 1 = \" + nonWhite1);\n+             System.err.println(\"nonWhite image 2 = \" + nonWhite2);\n+             System.err.println(\"Number of non-white differing pixels=\" + differences);\n+             throw new RuntimeException(\"Different rendering: \" + differences + \" pixels differ.\");\n+        }\n@@ -118,1 +137,1 @@\n-    public static void main(String args[]) {\n+    public static void main(String args[]) throws Exception {\n@@ -152,2 +171,2 @@\n-      compare(tl_Image, st_Image);\n-      compare(gv_Image, st_Image);\n+      compare(tl_Image, \"textlayout\", st_Image, \"string\");\n+      compare(gv_Image, \"glyphvector\", st_Image, \"string\");\n","filename":"test\/jdk\/sun\/awt\/font\/TestDevTransform.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.ec.ed\n+ *          java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.jca\n+ *          java.base\/sun.security.provider\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import sun.security.ec.ed.EdDSAOperations;\n+import sun.security.ec.ed.EdDSAParameters;\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.jca.JCAUtil;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.provider.NamedSignature;\n+\n+import java.security.*;\n+import java.security.spec.EdDSAParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class NamedEdDSA {\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"Named\", \"0\", \"\");\n+            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n+            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n+            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n+            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n+            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n+            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n+            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n+            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n+            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n+        }\n+    }\n+\n+    public static class EdDSASignature extends NamedSignature {\n+        public EdDSASignature() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSASignature(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSASignature {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSASignature {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[] implSign(String name, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) throws SignatureException {\n+            return getOps(name).sign(plain, sk, msg);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String name, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n+            return getOps(name).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n+        }\n+\n+        @Override\n+        public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+            return getOps(name).decodeAffinePoint(InvalidKeyException::new, pk);\n+        }\n+    }\n+\n+    public static class EdDSAKeyFactory extends NamedKeyFactory {\n+        public EdDSAKeyFactory() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyFactory(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyFactory {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyFactory {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+    }\n+\n+    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n+        public EdDSAKeyPairGenerator() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyPairGenerator(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyPairGenerator {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyPairGenerator {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n+            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n+            var op = getOps(pname);\n+            var sk = op.generatePrivate(sr);\n+            var point = op.computePublic(sk);\n+            byte[] encodedPoint = point.getY().toByteArray();\n+            reverse(encodedPoint);\n+            \/\/ array may be too large or too small, depending on the value\n+            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n+            \/\/ set the high-order bit of the encoded point\n+            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n+            encodedPoint[encodedPoint.length - 1] |= msb;\n+            return new byte[][] { encodedPoint, sk };\n+        }\n+\n+        private static void swap(byte[] arr, int i, int j) {\n+            byte tmp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = tmp;\n+        }\n+\n+        private static void reverse(byte [] arr) {\n+            int i = 0;\n+            int j = arr.length - 1;\n+\n+            while (i < j) {\n+                swap(arr, i, j);\n+                i++;\n+                j--;\n+            }\n+        }\n+    }\n+\n+    private static EdDSAOperations getOps(String pname) {\n+        var op = switch (pname) {\n+            case \"Ed25519\" -> e2;\n+            case \"Ed448\" -> e4;\n+            default -> throw new AssertionError(\"unknown pname \" + pname);\n+        };\n+        return op;\n+    }\n+\n+    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n+    static final EdDSAOperations e2, e4;\n+    static {\n+        try {\n+            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n+            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n+        for (var p1 : ps) {\n+            for (var p2 : ps) {\n+                for (var p3 : ps) {\n+                    test(p1, p2, p3);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n+        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n+        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n+        g.initialize(NamedParameterSpec.ED448);\n+        var kp = g.generateKeyPair();\n+        var s1 = Signature.getInstance(\"EdDSA\", p2);\n+        var s2 = Signature.getInstance(\"EdDSA\", p3);\n+        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n+        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n+        var sk = (PrivateKey) f1.translateKey(kp.getPrivate());\n+        var pk = (PublicKey) f2.translateKey(kp.getPublic());\n+        \/\/ sign and verify twice to make sure the key is intact\n+        s1.initSign(sk);\n+        var sig1 = s1.sign();\n+        s1.initSign(sk);\n+        var sig2 = s1.sign();\n+        \/\/ EdDSA signing is deterministic\n+        Asserts.assertEqualsByteArray(sig1, sig2);\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig1));\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig2));\n+        \/\/ No parameters defined\n+        s1.setParameter(null);\n+        Utils.runAndCheckException(() -> s1.setParameter(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedEdDSA.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+\n+public class NamedKeyFactoryTest {\n+\n+    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+\n+        var g = KeyPairGenerator.getInstance(\"sHA\");\n+        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n+        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n+        var kf = KeyFactory.getInstance(\"ShA\");\n+        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n+        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+\n+        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n+                InvalidAlgorithmParameterException.class); \/\/ diff pname\n+        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n+\n+        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n+        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+\n+        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAND.nBytes(2));\n+        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAND.nBytes(2));\n+        checkKey(pk, \"sHa\", \"ShA-256\");\n+        checkKey(sk, \"sHa\", \"SHa-256\");\n+\n+        Asserts.assertEquals(\"X.509\", pk.getFormat());\n+        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n+\n+        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n+        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+\n+        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n+        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KeySpec\n+        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n+        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n+        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n+        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n+        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var pk1 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var pk2 = new PublicKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var pk3 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n+\n+        var sk1 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var sk2 = new PrivateKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var sk3 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n+    }\n+\n+    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n+        checkKey(kp.getPrivate(), algName, toString);\n+        checkKey(kp.getPublic(), algName, toString);\n+    }\n+\n+    static void checkKey(Key k, String algName, String pname) {\n+        Asserts.assertEquals(algName, k.getAlgorithm());\n+        Asserts.assertTrue(k.toString().contains(pname));\n+        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n+            Asserts.assertEquals(pname, nps.getName());\n+        }\n+    }\n+\n+    \/\/ Provider\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"...\");\n+            put(\"KeyFactory.SHA\", KF.class.getName());\n+            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n+            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n+            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n+            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n+            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n+        }\n+    }\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+    }\n+    public static class KF1 extends NamedKeyFactory {\n+        public KF1() {\n+            super(\"SHA\", \"SHA-256\");\n+        }\n+    }\n+    public static class KF2 extends NamedKeyFactory {\n+        public KF2() {\n+            super(\"SHA\", \"SHA-512\");\n+        }\n+    }\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"SHA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            var out = new byte[2][];\n+            out[0] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n+            out[1] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n+            return out;\n+        }\n+    }\n+    public static class KPG1 extends KPG {\n+        public KPG1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedKeyFactoryTest.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -134,1 +134,1 @@\n-        map.put(\"docker.support\", this::dockerSupport);\n+        map.put(\"container.support\", this::containerSupport);\n@@ -588,1 +588,1 @@\n-     * A simple check for docker support\n+     * A simple check for container support\n@@ -590,1 +590,1 @@\n-     * @return true if docker is supported in a given environment\n+     * @return true if container is supported in a given environment\n@@ -592,2 +592,2 @@\n-    protected String dockerSupport() {\n-        log(\"Entering dockerSupport()\");\n+    protected String containerSupport() {\n+        log(\"Entering containerSupport()\");\n@@ -597,1 +597,1 @@\n-           \/\/ currently docker testing is only supported for Linux,\n+           \/\/ currently container testing is only supported for Linux,\n@@ -613,1 +613,1 @@\n-        log(\"dockerSupport(): platform check: isSupported = \" + isSupported);\n+        log(\"containerSupport(): platform check: isSupported = \" + isSupported);\n@@ -617,1 +617,1 @@\n-              isSupported = checkProgramSupport(\"checkDockerSupport()\", Container.ENGINE_COMMAND);\n+              isSupported = checkProgramSupport(\"checkContainerSupport()\", Container.ENGINE_COMMAND);\n@@ -623,1 +623,1 @@\n-        log(\"dockerSupport(): returning isSupported = \" + isSupported);\n+        log(\"containerSupport(): returning isSupported = \" + isSupported);\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -800,0 +800,46 @@\n+\n+    @Test\n+    public void testImportModuleNoModules(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                              List<String> l;\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors = new JavacTask(tb)\n+            .options(\"--release\", \"8\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"-XDdev\",\n+                     \"-XDrawDiagnostics\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+                \"- compiler.warn.option.obsolete.source: 8\",\n+                \"- compiler.warn.option.obsolete.target: 8\",\n+                \"- compiler.warn.option.obsolete.suppression\",\n+                \"Test.java:2:8: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.module.imports)\",\n+                \"Test.java:2:1: compiler.err.import.module.not.found: java.base\",\n+                \"Test.java:4:5: compiler.err.cant.resolve.location: kindname.class, List, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"3 errors\",\n+                \"3 warnings\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8337980\n+ * @summary Test compiler crash due to failure to resolve method ambiguity\n+ * @compile\/fail\/ref=MethodAmbiguityCrash1.out -XDrawDiagnostics MethodAmbiguityCrash1.java\n+ *\/\n+public class MethodAmbiguityCrash1 {\n+\n+    public interface A {\n+        int op();\n+    }\n+\n+    public abstract static class B {\n+        abstract int op();\n+    }\n+\n+    public abstract static class C extends B implements A {\n+\n+        public static int test() {\n+            return op();    \/\/ compile should fail here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash1.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+MethodAmbiguityCrash1.java:20:20: compiler.err.non-static.cant.be.ref: kindname.method, op()\n+1 error\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash1.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8337980\n+ * @summary Test compiler crash due to failure to resolve method ambiguity\n+ * @compile\/fail\/ref=MethodAmbiguityCrash2.out -XDrawDiagnostics MethodAmbiguityCrash2.java\n+ *\/\n+public class MethodAmbiguityCrash2 {\n+\n+    public interface A {\n+        int op();\n+    }\n+\n+    public abstract static class B {\n+        public abstract int op();\n+    }\n+\n+    public abstract static class C extends B implements A {\n+\n+        public C(int x) {\n+        }\n+\n+        public C() {\n+            this(op());     \/\/ compile should fail here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash2.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+MethodAmbiguityCrash2.java:23:18: compiler.err.cant.ref.before.ctor.called: op()\n+1 error\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,1 @@\n-    \/\/ Use this property to specify docker location on your system.\n+    \/\/ Use this property to specify container runtime location (e.g. docker) on your system.\n@@ -28,1 +29,1 @@\n-    \/\/ that it can be used in VMProps as well which checks docker support\n+    \/\/ that it can be used in VMProps as well which checks container support\n","filename":"test\/lib\/jdk\/test\/lib\/Container.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,0 +110,9 @@\n+\n+    \/\/ Provide a simple one-off run without JMH dependencies enable simple debugging,\n+    \/\/ diagnostics and dual-purposing this micro as a startup test.\n+    public static void main(String... args) throws Exception {\n+        var bench = new ZipFileOpen();\n+        bench.size = 1024*4;\n+        bench.beforeRun();\n+        bench.openCloseZipFile();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/zip\/ZipFileOpen.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -65,0 +65,9 @@\n+    static final int REPEATS = 40;\n+    static final String[] METHOD_NAMES;\n+    static {\n+        var names = new String[REPEATS];\n+        for (int xi = 0; xi < REPEATS; ++xi) {\n+            names[xi] = \"main\" + ((xi == 0) ? \"\" : \"\" + xi);\n+        }\n+        METHOD_NAMES = names;\n+    }\n@@ -93,2 +102,2 @@\n-        for (int xi = 0; xi < 40; ++xi) {\n-            MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, \"main\"+ ((xi==0)? \"\" : \"\"+xi), \"([Ljava\/lang\/String;)V\", null, null);\n+        for (int xi = 0; xi < REPEATS; ++xi) {\n+            MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, METHOD_NAMES[xi], \"([Ljava\/lang\/String;)V\", null, null);\n@@ -144,3 +153,3 @@\n-                      .withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n-                                              .invoke(INVOKESPECIAL, CD_Object, INIT_NAME, MTD_void, false)\n-                                              .return_(VOID)\n+                      .withCode(codeb -> codeb.aload(0)\n+                                              .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                              .return_()\n@@ -149,2 +158,2 @@\n-            for (int xi = 0; xi < 40; ++xi) {\n-                cb.withMethod(\"main\" + ((xi == 0) ? \"\" : \"\" + xi), MTD_void_StringArray,\n+            for (int xi = 0; xi < REPEATS; ++xi) {\n+                cb.withMethod(METHOD_NAMES[xi], MTD_void_StringArray,\n@@ -183,48 +192,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public byte[] jdkTreePrimitive() {\n-\n-        byte[] bytes = ClassFile.of().build(CD_MyClass, cb -> {\n-            cb.withFlags(AccessFlag.PUBLIC);\n-            cb.withVersion(52, 0);\n-            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n-              .withMethod(INIT_NAME, MTD_void, 0,\n-                          mb -> mb.withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n-                                                          .invokespecial(CD_Object, INIT_NAME, MTD_void, false)\n-                                                          .return_()\n-                          )\n-              );\n-            for (int xi = 0; xi < 40; ++xi) {\n-                cb.withMethod(\"main\" + ((xi == 0) ? \"\" : \"\" + xi), MTD_void_StringArray,\n-                              ACC_PUBLIC | ACC_STATIC,\n-                              mb -> mb.withCode(c0 -> {\n-                                  java.lang.classfile.Label loopTop = c0.newLabel();\n-                                  java.lang.classfile.Label loopEnd = c0.newLabel();\n-                                  int vFac = 1;\n-                                  int vI = 2;\n-                                  c0.iconst_1()         \/\/ 0\n-                                    .istore(1)          \/\/ 1\n-                                    .iconst_1()         \/\/ 2\n-                                    .istore(2)          \/\/ 3\n-                                    .labelBinding(loopTop)\n-                                    .iload(2)           \/\/ 4\n-                                    .bipush(10)         \/\/ 5\n-                                    .if_icmpge(loopEnd) \/\/ 6\n-                                    .iload(1)           \/\/ 7\n-                                    .iload(2)           \/\/ 8\n-                                    .imul()             \/\/ 9\n-                                    .istore(1)          \/\/ 10\n-                                    .iinc(2, 1)         \/\/ 11\n-                                    .goto_(loopTop)     \/\/ 12\n-                                    .labelBinding(loopEnd)\n-                                    .getstatic(CD_System, \"out\", CD_PrintStream)  \/\/ 13\n-                                    .iload(1)\n-                                    .invokevirtual(CD_PrintStream, \"println\", MTD_void_int)  \/\/ 15\n-                                    .return_();\n-                        }));\n-            }\n-        });\n-        if (writeClassBc) writeClass(bytes, checkFileBc);\n-        return bytes;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":16,"deletions":55,"binary":false,"changes":71,"status":"modified"}]}