{"files":[{"patch":"@@ -47,0 +47,2 @@\n+  } else if (inst->is_li48()) {\n+    return pc_offset + NativeMovConstReg::li48_instruction_size;\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -643,1 +643,1 @@\n-  movptr(t0, 0, offset);\n+  li48(t0, t1, 0, offset); \/\/ lui + lui + ssli + add\n@@ -780,0 +780,38 @@\n+void MacroAssembler::li48(Register Rd, Register tmp, address addr, int32_t &offset) {\n+  assert_different_registers(Rd, tmp, noreg);\n+  li48_imp(Rd, tmp, (uintptr_t)addr, offset);\n+}\n+\n+void MacroAssembler::li48(Register Rd, Register tmp, address addr) {\n+  assert_different_registers(Rd, tmp, noreg);\n+  int offset = 0;\n+  li48_imp(Rd, tmp, (uintptr_t)addr, offset);\n+  addi(Rd, Rd, offset);\n+}\n+\n+void MacroAssembler::li48_imp(Register Rd, Register tmp, uintptr_t addr, int32_t &offset) {\n+  assert_different_registers(Rd, tmp, noreg);\n+  assert(addr < (1ull << 48), \"48-bit overflow in address constant\");\n+  unsigned int upper18 = (addr >> 30ull);\n+  int lower30 = (addr & 0x3fffffffu);\n+  int low12 = (lower30 << 20) >> 20;\n+  int mid18 = ((lower30 - low12) >> 12);\n+\n+#ifndef PRODUCT\n+  {\n+    char buffer[64];\n+    snprintf(buffer, sizeof(buffer), \"li48: 0x%\" PRIx64, addr);\n+    block_comment(buffer);\n+  }\n+#endif\n+\n+  lui(tmp, upper18 << 12);\n+  lui(Rd, mid18 << 12);\n+\n+  slli(tmp, tmp, 18);\n+  add(Rd, Rd, tmp);\n+\n+  offset = low12;\n+\n+}\n+\n@@ -1426,0 +1464,20 @@\n+static int patch_addr_in_li48(address instruction_address, address target) {\n+  uintptr_t addr = (uintptr_t)target;\n+\n+  assert(addr < (1ull << 48), \"48-bit overflow in address constant\");\n+  unsigned int upper18 = (addr >> 30ull);\n+  int lower30 = (addr & 0x3fffffffu);\n+  int low12 = (lower30 << 20) >> 20;\n+  int mid18 = ((lower30 - low12) >> 12);\n+\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 0), 31, 12, (upper18 & 0xfffff)); \/\/ Lui\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 1), 31, 12, (mid18   & 0xfffff)); \/\/ Lui\n+                                                                                                                  \/\/ Slli\n+                                                                                                                  \/\/ Add\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 4), 31, 20, low12 & 0xfff);      \/\/ Addi\/Jalr\/Load\n+\n+  assert(MacroAssembler::target_addr_for_insn(instruction_address) == target, \"Must be\");\n+\n+  return 5 * NativeInstruction::instruction_size;                                                                 \/\/ lui + lui + slli + add + addi\/jalr\/load\n+}\n+\n@@ -1506,0 +1564,11 @@\n+static address get_target_of_li48(address insn_addr) {\n+  assert_cond(insn_addr != nullptr);\n+  int32_t upper18 = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 0), 31, 12)) & 0xfffff); \/\/ Lui\n+  int32_t mid18   = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 1), 31, 12)) & 0xfffff); \/\/ Lui\n+                                                                                                                       \/\/ 2                              \/\/ Slli\n+                                                                                                                       \/\/ 3                              \/\/ Add\n+  int32_t low12  = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 4), 31, 20))); \/\/ Addi\/Jalr\/Load.\n+  address ret = (address)(((intptr_t)upper18<<30ll) + ((intptr_t)mid18<<12ll) + low12);\n+  return ret;\n+}\n+\n@@ -1525,14 +1594,16 @@\n-int MacroAssembler::pd_patch_instruction_size(address branch, address target) {\n-  assert_cond(branch != nullptr);\n-  int64_t offset = target - branch;\n-  if (NativeInstruction::is_jal_at(branch)) {                         \/\/ jal\n-    return patch_offset_in_jal(branch, offset);\n-  } else if (NativeInstruction::is_branch_at(branch)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n-    return patch_offset_in_conditional_branch(branch, offset);\n-  } else if (NativeInstruction::is_pc_relative_at(branch)) {          \/\/ auipc, addi\/jalr\/load\n-    return patch_offset_in_pc_relative(branch, offset);\n-  } else if (NativeInstruction::is_movptr_at(branch)) {               \/\/ movptr\n-    return patch_addr_in_movptr(branch, target);\n-  } else if (NativeInstruction::is_li64_at(branch)) {                 \/\/ li64\n-    return patch_imm_in_li64(branch, target);\n-  } else if (NativeInstruction::is_li32_at(branch)) {                 \/\/ li32\n+int MacroAssembler::pd_patch_instruction_size(address instruction_address, address target) {\n+  assert_cond(instruction_address != nullptr);\n+  int64_t offset = target - instruction_address;\n+  if (NativeInstruction::is_jal_at(instruction_address)) {                         \/\/ jal\n+    return patch_offset_in_jal(instruction_address, offset);\n+  } else if (NativeInstruction::is_branch_at(instruction_address)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n+    return patch_offset_in_conditional_branch(instruction_address, offset);\n+  } else if (NativeInstruction::is_pc_relative_at(instruction_address)) {          \/\/ auipc, addi\/jalr\/load\n+    return patch_offset_in_pc_relative(instruction_address, offset);\n+  } else if (NativeInstruction::is_movptr_at(instruction_address)) {               \/\/ movptr\n+    return patch_addr_in_movptr(instruction_address, target);\n+  } else if (NativeInstruction::is_li48_at(instruction_address)) {                 \/\/ li48\n+    return patch_addr_in_li48(instruction_address, target);\n+  } else if (NativeInstruction::is_li64_at(instruction_address)) {                 \/\/ li64\n+    return patch_imm_in_li64(instruction_address, target);\n+  } else if (NativeInstruction::is_li32_at(instruction_address)) {                 \/\/ li32\n@@ -1540,2 +1611,2 @@\n-    return patch_imm_in_li32(branch, (int32_t)imm);\n-  } else if (NativeInstruction::is_li16u_at(branch)) {\n+    return patch_imm_in_li32(instruction_address, (int32_t)imm);\n+  } else if (NativeInstruction::is_li16u_at(instruction_address)) {\n@@ -1543,1 +1614,1 @@\n-    return patch_imm_in_li16u(branch, (uint16_t)imm);\n+    return patch_imm_in_li16u(instruction_address, (uint16_t)imm);\n@@ -1547,2 +1618,2 @@\n-                  Assembler::ld_instr(branch), p2i(branch));\n-    Disassembler::decode(branch - 16, branch + 16);\n+                  Assembler::ld_instr(instruction_address), p2i(instruction_address));\n+    Disassembler::decode(instruction_address - 16, instruction_address + 16);\n@@ -1570,0 +1641,2 @@\n+  } else if (NativeInstruction::is_li48_at(insn_addr)) {             \/\/ li48\n+    return get_target_of_li48(insn_addr);\n@@ -2110,0 +2183,1 @@\n+  assert((uintptr_t)obj < (1ull << 48), \"48-bit overflow in metadata\");\n@@ -3547,1 +3621,1 @@\n-  movptr(t1, (address)Universe::non_oop_word());\n+  li48(t1, t0, (address)Universe::non_oop_word());\n@@ -3654,2 +3728,2 @@\n-  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n-  return 12 * NativeInstruction::instruction_size;\n+  \/\/ (lui, addi, slli, addi, slli, addi) + (lui + lui + ssli + add) + jalr\n+  return 11 * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":97,"deletions":23,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -749,0 +749,6 @@\n+  void li48(Register Rd, Register tmp, address addr, int32_t &offset);\n+  void li48(Register Rd, Register tmp, address addr);\n+ private:\n+  void li48_imp(Register Rd, Register tmp, uintptr_t addr, int32_t &offset);\n+ public:\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,0 +99,11 @@\n+bool NativeInstruction::is_li48_at(address instr) {\n+  return is_lui_at(instr) && \/\/ lui\n+         is_lui_at(instr + instruction_size) && \/\/ lui\n+         is_slli_shift_at(instr + instruction_size * 2, 18) && \/\/ slli Rd, Rs, 18\n+         is_add_at(instr + instruction_size * 3) &&\n+         (is_addi_at(instr + instruction_size * 4) ||\n+          is_jalr_at(instr + instruction_size * 4) ||\n+          is_load_at(instr + instruction_size * 4)) && \/\/ Addi\/Jalr\/Load\n+         check_li48_data_dependency(instr);\n+}\n+\n@@ -204,3 +215,3 @@\n-  if (!(nativeInstruction_at(instruction_address())->is_movptr() ||\n-        is_auipc_at(instruction_address()))) {\n-    fatal(\"should be MOVPTR or AUIPC\");\n+  NativeInstruction* ni = nativeInstruction_at(instruction_address());\n+  if (ni->is_movptr() || ni->is_auipc() || ni->is_li48()) {\n+    return;\n@@ -208,0 +219,1 @@\n+  fatal(\"should be MOVPTR or AUIPC ot LI48\");\n@@ -226,1 +238,1 @@\n-    ICache::invalidate_range(instruction_address(), movptr_instruction_size);\n+    ICache::invalidate_range(instruction_address(), movptr_instruction_size \/* > li48_instruction_size *\/ );\n@@ -396,0 +408,2 @@\n+\/\/-------------------------------------------------------------------\n+\n@@ -402,1 +416,1 @@\n-  a.movptr(t0, entry, offset); \/\/ lui, addi, slli, addi, slli\n+  a.li48(t0, t1, entry, offset); \/\/ lui, addi, slli, addi, slli\n@@ -413,0 +427,1 @@\n+\/\/-------------------------------------------------------------------\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  bool is_auipc()                           const { return is_auipc_at(addr_at(0));       }\n+  bool is_li48()                            const { return is_li48_at(addr_at(0));        }\n@@ -79,0 +81,1 @@\n+  static bool is_add_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110011 && extract_funct3(instr) == 0b000; }\n@@ -81,1 +84,1 @@\n-  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n+  static bool is_addiw_to_zr_at(address instr){ assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n@@ -130,0 +133,20 @@\n+  \/\/ the instruction sequence of li48 is as below:\n+  \/\/     lui\n+  \/\/     lui\n+  \/\/     slli\n+  \/\/     add\n+  \/\/     addi\/jalr\/load\n+  static bool check_li48_data_dependency(address instr) {\n+    address lui1 = instr;\n+    address lui2 = lui1 + instruction_size;\n+    address slli = lui2 + instruction_size;\n+    address add  = slli + instruction_size;\n+    address last_instr = add + instruction_size;\n+    return extract_rd(add) == extract_rd(lui2) &&\n+           extract_rs1(add) == extract_rd(lui2) &&\n+           extract_rs2(add) == extract_rd(slli) &&\n+           extract_rs1(slli) == extract_rd(lui1) &&\n+           extract_rd(slli) == extract_rd(lui1) &&\n+           extract_rs1(last_instr) == extract_rd(add);\n+  }\n+\n@@ -208,0 +231,1 @@\n+  static bool is_li48_at(address instr);\n@@ -355,0 +379,1 @@\n+    li48_instruction_size               =    5 * NativeInstruction::instruction_size, \/\/ lui, lui, slli, add, addi.  See li48_imp().\n@@ -378,0 +403,8 @@\n+    } else if (nativeInstruction_at(instruction_address())->is_li48()) {\n+      if (is_addi_at(addr_at(li48_instruction_size - NativeInstruction::instruction_size))) {\n+        \/\/ Assume: lui, addi, slli, addi, slli, addi\n+        return addr_at(li48_instruction_size);\n+      } else {\n+        \/\/ Assume: lui, addi, slli, addi, slli\n+        return addr_at(li48_instruction_size - NativeInstruction::instruction_size);\n+      }\n@@ -388,1 +421,1 @@\n-      ICache::invalidate_range(instruction_address(), movptr_instruction_size);\n+      ICache::invalidate_range(instruction_address(), movptr_instruction_size \/* > li48_instruction_size *\/);\n@@ -487,4 +520,1 @@\n-    instruction_size            =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, jalr\n-    instruction_offset          =    0,\n-    data_offset                 =    0,\n-    next_instruction_offset     =    6 * NativeInstruction::instruction_size  \/\/ lui, addi, slli, addi, slli, jalr\n+    instruction_size            =    5 * NativeInstruction::instruction_size, \/\/ lui, lui, slli, add, jalr\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1247,1 +1247,1 @@\n-  return 7 * NativeInstruction::instruction_size; \/\/ movptr, jal\n+  return NativeMovConstReg::li48_instruction_size +  NativeInstruction::instruction_size; \/\/ li48, jal\n@@ -1292,2 +1292,1 @@\n-  const int movptr_size = 6 * NativeInstruction::instruction_size;\n-  current_offset += movptr_size;\n+  current_offset += NativeMovConstReg::li48_instruction_size;\n@@ -9984,1 +9983,1 @@\n-  ins_cost(BRANCH_COST + ALU_COST * 6);\n+  ins_cost(BRANCH_COST + ALU_COST * 5);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}