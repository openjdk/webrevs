{"files":[{"patch":"@@ -138,1 +138,1 @@\n-    __ movptr(tmp, addr->disp());\n+    __ movptr(tmp, (address)addr->disp());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,4 @@\n-  } else if (inst->is_movptr()) {\n-    return pc_offset + NativeMovConstReg::movptr_instruction_size;\n+  } else if (inst->is_movptr1()) {\n+    return pc_offset + NativeMovConstReg::movptr1_instruction_size;\n+  } else if (inst->is_movptr2()) {\n+    return pc_offset + NativeMovConstReg::movptr2_instruction_size;\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -643,1 +643,1 @@\n-  movptr(t0, 0, offset);\n+  movptr(t0, 0, offset, t1); \/\/ lui + lui + ssli + add\n@@ -1415,1 +1415,1 @@\n-static int patch_addr_in_movptr(address branch, address target) {\n+static int patch_addr_in_movptr1(address branch, address target) {\n@@ -1426,0 +1426,20 @@\n+static int patch_addr_in_movptr2(address instruction_address, address target) {\n+  uintptr_t addr = (uintptr_t)target;\n+\n+  assert(addr < (1ull << 48), \"48-bit overflow in address constant\");\n+  unsigned int upper18 = (addr >> 30ull);\n+  int lower30 = (addr & 0x3fffffffu);\n+  int low12 = (lower30 << 20) >> 20;\n+  int mid18 = ((lower30 - low12) >> 12);\n+\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 0), 31, 12, (upper18 & 0xfffff)); \/\/ Lui\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 1), 31, 12, (mid18   & 0xfffff)); \/\/ Lui\n+                                                                                                                  \/\/ Slli\n+                                                                                                                  \/\/ Add\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 4), 31, 20, low12 & 0xfff);      \/\/ Addi\/Jalr\/Load\n+\n+  assert(MacroAssembler::target_addr_for_insn(instruction_address) == target, \"Must be\");\n+\n+  return 5 * NativeInstruction::instruction_size;                                                                 \/\/ lui + lui + slli + add + addi\/jalr\/load\n+}\n+\n@@ -1506,0 +1526,11 @@\n+static address get_target_of_movptr2(address insn_addr) {\n+  assert_cond(insn_addr != nullptr);\n+  int32_t upper18 = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 0), 31, 12)) & 0xfffff); \/\/ Lui\n+  int32_t mid18   = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 1), 31, 12)) & 0xfffff); \/\/ Lui\n+                                                                                                                       \/\/ 2                              \/\/ Slli\n+                                                                                                                       \/\/ 3                              \/\/ Add\n+  int32_t low12  = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 4), 31, 20))); \/\/ Addi\/Jalr\/Load.\n+  address ret = (address)(((intptr_t)upper18<<30ll) + ((intptr_t)mid18<<12ll) + low12);\n+  return ret;\n+}\n+\n@@ -1525,14 +1556,16 @@\n-int MacroAssembler::pd_patch_instruction_size(address branch, address target) {\n-  assert_cond(branch != nullptr);\n-  int64_t offset = target - branch;\n-  if (NativeInstruction::is_jal_at(branch)) {                         \/\/ jal\n-    return patch_offset_in_jal(branch, offset);\n-  } else if (NativeInstruction::is_branch_at(branch)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n-    return patch_offset_in_conditional_branch(branch, offset);\n-  } else if (NativeInstruction::is_pc_relative_at(branch)) {          \/\/ auipc, addi\/jalr\/load\n-    return patch_offset_in_pc_relative(branch, offset);\n-  } else if (NativeInstruction::is_movptr_at(branch)) {               \/\/ movptr\n-    return patch_addr_in_movptr(branch, target);\n-  } else if (NativeInstruction::is_li64_at(branch)) {                 \/\/ li64\n-    return patch_imm_in_li64(branch, target);\n-  } else if (NativeInstruction::is_li32_at(branch)) {                 \/\/ li32\n+int MacroAssembler::pd_patch_instruction_size(address instruction_address, address target) {\n+  assert_cond(instruction_address != nullptr);\n+  int64_t offset = target - instruction_address;\n+  if (NativeInstruction::is_jal_at(instruction_address)) {                         \/\/ jal\n+    return patch_offset_in_jal(instruction_address, offset);\n+  } else if (NativeInstruction::is_branch_at(instruction_address)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n+    return patch_offset_in_conditional_branch(instruction_address, offset);\n+  } else if (NativeInstruction::is_pc_relative_at(instruction_address)) {          \/\/ auipc, addi\/jalr\/load\n+    return patch_offset_in_pc_relative(instruction_address, offset);\n+  } else if (NativeInstruction::is_movptr1_at(instruction_address)) {              \/\/ movptr\n+    return patch_addr_in_movptr1(instruction_address, target);\n+  } else if (NativeInstruction::is_movptr2_at(instruction_address)) {              \/\/ movptr2\n+    return patch_addr_in_movptr2(instruction_address, target);\n+  } else if (NativeInstruction::is_li64_at(instruction_address)) {                 \/\/ li64\n+    return patch_imm_in_li64(instruction_address, target);\n+  } else if (NativeInstruction::is_li32_at(instruction_address)) {                 \/\/ li32\n@@ -1540,2 +1573,2 @@\n-    return patch_imm_in_li32(branch, (int32_t)imm);\n-  } else if (NativeInstruction::is_li16u_at(branch)) {\n+    return patch_imm_in_li32(instruction_address, (int32_t)imm);\n+  } else if (NativeInstruction::is_li16u_at(instruction_address)) {\n@@ -1543,1 +1576,1 @@\n-    return patch_imm_in_li16u(branch, (uint16_t)imm);\n+    return patch_imm_in_li16u(instruction_address, (uint16_t)imm);\n@@ -1547,2 +1580,2 @@\n-                  Assembler::ld_instr(branch), p2i(branch));\n-    Disassembler::decode(branch - 16, branch + 16);\n+                  Assembler::ld_instr(instruction_address), p2i(instruction_address));\n+    Disassembler::decode(instruction_address - 16, instruction_address + 16);\n@@ -1564,1 +1597,1 @@\n-  } else if (NativeInstruction::is_movptr_at(insn_addr)) {           \/\/ movptr\n+  } else if (NativeInstruction::is_movptr1_at(insn_addr)) {          \/\/ movptr\n@@ -1566,0 +1599,2 @@\n+  } else if (NativeInstruction::is_movptr2_at(insn_addr)) {          \/\/ movptr2\n+    return get_target_of_movptr2(insn_addr);\n@@ -1584,1 +1619,1 @@\n-  } else if (NativeInstruction::is_movptr_at(insn_addr)) {\n+  } else if (NativeInstruction::is_movptr1_at(insn_addr)) {\n@@ -1586,1 +1621,4 @@\n-    return patch_addr_in_movptr(insn_addr, o);\n+    return patch_addr_in_movptr1(insn_addr, o);\n+  } else if (NativeInstruction::is_movptr2_at(insn_addr)) {\n+    \/\/ Move wide OOP\n+    return patch_addr_in_movptr2(insn_addr, o);\n@@ -1607,2 +1645,8 @@\n-void MacroAssembler::movptr(Register Rd, address addr, int32_t &offset) {\n-  int64_t imm64 = (int64_t)addr;\n+void MacroAssembler::movptr(Register Rd, address addr, Register temp) {\n+  int offset = 0;\n+  movptr(Rd, addr, offset, temp);\n+  addi(Rd, Rd, offset);\n+}\n+\n+void MacroAssembler::movptr(Register Rd, address addr, int32_t &offset, Register temp) {\n+  uint64_t uimm64 = (uint64_t)addr;\n@@ -1612,1 +1656,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n@@ -1616,1 +1660,10 @@\n-  assert((uintptr_t)imm64 < (1ull << 48), \"48-bit overflow in address constant\");\n+  assert(uimm64 < (1ull << 48), \"48-bit overflow in address constant\");\n+\n+  if (temp == noreg) {\n+    movptr1(Rd, uimm64, offset);\n+  } else {\n+    movptr2(Rd, uimm64, offset, temp);\n+  }\n+}\n+\n+void MacroAssembler::movptr1(Register Rd, uint64_t imm64, int32_t &offset) {\n@@ -1635,0 +1688,17 @@\n+void MacroAssembler::movptr2(Register Rd, uint64_t addr, int32_t &offset, Register tmp) {\n+  assert_different_registers(Rd, tmp, noreg);\n+\n+  uint32_t upper18 = (addr >> 30ull);\n+  int32_t  lower30 = (addr & 0x3fffffffu);\n+  int32_t  low12   = (lower30 << 20) >> 20;\n+  int32_t  mid18   = ((lower30 - low12) >> 12);\n+\n+  lui(tmp, upper18 << 12);\n+  lui(Rd, mid18 << 12);\n+\n+  slli(tmp, tmp, 18);\n+  add(Rd, Rd, tmp);\n+\n+  offset = low12;\n+}\n+\n@@ -2110,0 +2180,1 @@\n+  assert((uintptr_t)obj < (1ull << 48), \"48-bit overflow in metadata\");\n@@ -3547,1 +3618,1 @@\n-  movptr(t1, (address)Universe::non_oop_word());\n+  movptr(t1, (address)Universe::non_oop_word(), t0);\n@@ -3654,2 +3725,2 @@\n-  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n-  return 12 * NativeInstruction::instruction_size;\n+  \/\/ (lui, addi, slli, addi, slli, addi) + (lui + lui + ssli + add) + jalr\n+  return 11 * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":102,"deletions":31,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -774,11 +774,10 @@\n-  void movptr(Register Rd, address addr, int32_t &offset);\n-\n-  void movptr(Register Rd, address addr) {\n-    int offset = 0;\n-    movptr(Rd, addr, offset);\n-    addi(Rd, Rd, offset);\n-  }\n-\n-  inline void movptr(Register Rd, uintptr_t imm64) {\n-    movptr(Rd, (address)imm64);\n-  }\n+  \/\/ Generates a load of a 48-bit constant which can be\n+  \/\/ patched to any 48-bit constant, i.e. address.\n+  \/\/ If common case supply additional temp register\n+  \/\/ to shorten the instruction sequence.\n+  void movptr(Register Rd, address addr, Register tmp = noreg);\n+  void movptr(Register Rd, address addr, int32_t &offset, Register tmp = noreg);\n+ private:\n+  void movptr1(Register Rd, uintptr_t addr, int32_t &offset);\n+  void movptr2(Register Rd, uintptr_t addr, int32_t &offset, Register tmp);\n+ public:\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-bool NativeInstruction::is_movptr_at(address instr) {\n+bool NativeInstruction::is_movptr1_at(address instr) {\n@@ -99,0 +99,11 @@\n+bool NativeInstruction::is_movptr2_at(address instr) {\n+  return is_lui_at(instr) && \/\/ lui\n+         is_lui_at(instr + instruction_size) && \/\/ lui\n+         is_slli_shift_at(instr + instruction_size * 2, 18) && \/\/ slli Rd, Rs, 18\n+         is_add_at(instr + instruction_size * 3) &&\n+         (is_addi_at(instr + instruction_size * 4) ||\n+          is_jalr_at(instr + instruction_size * 4) ||\n+          is_load_at(instr + instruction_size * 4)) && \/\/ Addi\/Jalr\/Load\n+         check_movptr2_data_dependency(instr);\n+}\n+\n@@ -204,3 +215,3 @@\n-  if (!(nativeInstruction_at(instruction_address())->is_movptr() ||\n-        is_auipc_at(instruction_address()))) {\n-    fatal(\"should be MOVPTR or AUIPC\");\n+  NativeInstruction* ni = nativeInstruction_at(instruction_address());\n+  if (ni->is_movptr() || ni->is_auipc()) {\n+    return;\n@@ -208,0 +219,1 @@\n+  fatal(\"should be MOVPTR or AUIPC\");\n@@ -226,1 +238,1 @@\n-    ICache::invalidate_range(instruction_address(), movptr_instruction_size);\n+    ICache::invalidate_range(instruction_address(), movptr1_instruction_size \/* > movptr2_instruction_size *\/ );\n@@ -396,0 +408,2 @@\n+\/\/-------------------------------------------------------------------\n+\n@@ -402,1 +416,1 @@\n-  a.movptr(t0, entry, offset); \/\/ lui, addi, slli, addi, slli\n+  a.movptr(t0, entry, offset, t1); \/\/ lui, addi, slli, addi, slli\n@@ -413,0 +427,1 @@\n+\/\/-------------------------------------------------------------------\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -67,1 +67,5 @@\n-  bool is_movptr()                          const { return is_movptr_at(addr_at(0));      }\n+  bool is_movptr()                          const { return is_movptr1_at(addr_at(0)) ||\n+                                                           is_movptr2_at(addr_at(0));     }\n+  bool is_movptr1()                         const { return is_movptr1_at(addr_at(0));     }\n+  bool is_movptr2()                         const { return is_movptr2_at(addr_at(0));     }\n+  bool is_auipc()                           const { return is_auipc_at(addr_at(0));       }\n@@ -79,0 +83,1 @@\n+  static bool is_add_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110011 && extract_funct3(instr) == 0b000; }\n@@ -81,1 +86,1 @@\n-  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n+  static bool is_addiw_to_zr_at(address instr){ assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n@@ -130,0 +135,20 @@\n+  \/\/ the instruction sequence of movptr2 is as below:\n+  \/\/     lui\n+  \/\/     lui\n+  \/\/     slli\n+  \/\/     add\n+  \/\/     addi\/jalr\/load\n+  static bool check_movptr2_data_dependency(address instr) {\n+    address lui1 = instr;\n+    address lui2 = lui1 + instruction_size;\n+    address slli = lui2 + instruction_size;\n+    address add  = slli + instruction_size;\n+    address last_instr = add + instruction_size;\n+    return extract_rd(add) == extract_rd(lui2) &&\n+           extract_rs1(add) == extract_rd(lui2) &&\n+           extract_rs2(add) == extract_rd(slli) &&\n+           extract_rs1(slli) == extract_rd(lui1) &&\n+           extract_rd(slli) == extract_rd(lui1) &&\n+           extract_rs1(last_instr) == extract_rd(add);\n+  }\n+\n@@ -207,1 +232,2 @@\n-  static bool is_movptr_at(address instr);\n+  static bool is_movptr1_at(address instr);\n+  static bool is_movptr2_at(address instr);\n@@ -354,4 +380,3 @@\n-    movptr_instruction_size             =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr().\n-    load_pc_relative_instruction_size   =    2 * NativeInstruction::instruction_size, \/\/ auipc, ld\n-    instruction_offset                  =    0,\n-    displacement_offset                 =    0\n+    movptr1_instruction_size            =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr().\n+    movptr2_instruction_size            =    5 * NativeInstruction::instruction_size, \/\/ lui, lui, slli, add, addi.  See movptr2_imp().\n+    load_pc_relative_instruction_size   =    2 * NativeInstruction::instruction_size  \/\/ auipc, ld\n@@ -360,1 +385,1 @@\n-  address instruction_address() const       { return addr_at(instruction_offset); }\n+  address instruction_address() const       { return addr_at(0); }\n@@ -367,2 +392,2 @@\n-    if (nativeInstruction_at(instruction_address())->is_movptr()) {\n-      if (is_addi_at(addr_at(movptr_instruction_size - NativeInstruction::instruction_size))) {\n+    if (is_movptr1_at(instruction_address())) {\n+      if (is_addi_at(addr_at(movptr1_instruction_size - NativeInstruction::instruction_size))) {\n@@ -370,1 +395,1 @@\n-        return addr_at(movptr_instruction_size);\n+        return addr_at(movptr1_instruction_size);\n@@ -373,1 +398,1 @@\n-        return addr_at(movptr_instruction_size - NativeInstruction::instruction_size);\n+        return addr_at(movptr1_instruction_size - NativeInstruction::instruction_size);\n@@ -378,0 +403,8 @@\n+    } else if (is_movptr2_at(instruction_address())) {\n+      if (is_addi_at(addr_at(movptr2_instruction_size - NativeInstruction::instruction_size))) {\n+        \/\/ Assume: lui, addi, slli, addi, slli, addi\n+        return addr_at(movptr2_instruction_size);\n+      } else {\n+        \/\/ Assume: lui, addi, slli, addi, slli\n+        return addr_at(movptr2_instruction_size - NativeInstruction::instruction_size);\n+      }\n@@ -388,1 +421,1 @@\n-      ICache::invalidate_range(instruction_address(), movptr_instruction_size);\n+      ICache::invalidate_range(instruction_address(), movptr1_instruction_size \/* > movptr2_instruction_size *\/);\n@@ -402,1 +435,1 @@\n-  NativeMovConstReg* test = (NativeMovConstReg*)(addr - NativeMovConstReg::instruction_offset);\n+  NativeMovConstReg* test = (NativeMovConstReg*)(addr);\n@@ -409,1 +442,1 @@\n-  NativeMovConstReg* test = (NativeMovConstReg*)(addr - NativeMovConstReg::instruction_size - NativeMovConstReg::instruction_offset);\n+  NativeMovConstReg* test = (NativeMovConstReg*)(addr - NativeMovConstReg::instruction_size);\n@@ -487,4 +520,1 @@\n-    instruction_size            =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, jalr\n-    instruction_offset          =    0,\n-    data_offset                 =    0,\n-    next_instruction_offset     =    6 * NativeInstruction::instruction_size  \/\/ lui, addi, slli, addi, slli, jalr\n+    instruction_size            =    5 * NativeInstruction::instruction_size, \/\/ lui, lui, slli, add, jalr\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":49,"deletions":19,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1247,1 +1247,1 @@\n-  return 7 * NativeInstruction::instruction_size; \/\/ movptr, jal\n+  return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n@@ -1288,1 +1288,1 @@\n-  \/\/ skip the movptr in MacroAssembler::ic_call():\n+  \/\/ skip the movptr2 in MacroAssembler::ic_call():\n@@ -1292,2 +1292,1 @@\n-  const int movptr_size = 6 * NativeInstruction::instruction_size;\n-  current_offset += movptr_size;\n+  current_offset += NativeMovConstReg::movptr2_instruction_size;\n@@ -10017,1 +10016,1 @@\n-  ins_cost(BRANCH_COST + ALU_COST * 6);\n+  ins_cost(BRANCH_COST + ALU_COST * 5);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  __ movptr(c_rarg1, (intptr_t) receiver);\n+  __ movptr(c_rarg1, (address) receiver);\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}