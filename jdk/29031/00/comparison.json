{"files":[{"patch":"@@ -84,1 +84,3 @@\n-                    SINK = segment.get(ValueLayout.JAVA_INT, 0);\n+                    SINK = segment.get(ValueLayout.JAVA_INT, 0); \/\/ should throw\n+                    System.err.println(\"No exception thrown during outer memory access\");\n+                    System.exit(1);\n@@ -110,1 +112,3 @@\n-                    SINK = arena.allocate(4).get(ValueLayout.JAVA_INT, 0);\n+                    SINK = arena.allocate(4).get(ValueLayout.JAVA_INT, 0); \/\/ should throw\n+                    System.err.println(\"No exception thrown during reentrant memory access\");\n+                    System.exit(1);\n","filename":"test\/jdk\/java\/foreign\/sharedclosejvmti\/TestSharedCloseJvmti.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-#include <string.h>\n+#include <cstring>\n+#include <cstdlib>\n@@ -30,0 +31,1 @@\n+static jclass EXCEPTION_CLS;\n@@ -38,0 +40,2 @@\n+static const char* EXCEPTION_CLASS_NAME = \"Ljdk\/internal\/misc\/ScopedMemoryAccess$ScopedAccessError;\";\n+\n@@ -53,0 +57,8 @@\n+\n+  jclass ex_cls = jni_env->FindClass(EXCEPTION_CLASS_NAME);\n+  if (ex_cls == nullptr) {\n+    jni_env->ExceptionDescribe();\n+    return;\n+  }\n+\n+  EXCEPTION_CLS = (jclass) jni_env->NewGlobalRef(ex_cls);\n@@ -63,2 +75,3 @@\n-  if (strcmp(method_name, INTERCEPT_METHOD_NAME) != 0) {\n-    jvmti_env->Deallocate((unsigned char*) method_name);\n+  bool is_intercept_method = strcmp(method_name, INTERCEPT_METHOD_NAME) == 0;\n+  jvmti_env->Deallocate((unsigned char*) method_name);\n+  if (!is_intercept_method) {\n@@ -71,1 +84,0 @@\n-    jvmti_env->Deallocate((unsigned char*) method_name);\n@@ -78,1 +90,0 @@\n-    jvmti_env->Deallocate((unsigned char*) method_name);\n@@ -82,3 +93,3 @@\n-  if (strcmp(class_sig, INTERCEPT_CLASS_NAME) != 0) {\n-    jvmti_env->Deallocate((unsigned char*) method_name);\n-    jvmti_env->Deallocate((unsigned char*) class_sig);\n+  bool is_intercept_class = strcmp(class_sig, INTERCEPT_CLASS_NAME) == 0;\n+  jvmti_env->Deallocate((unsigned char*) class_sig);\n+  if (!is_intercept_class) {\n@@ -89,1 +100,6 @@\n-  if (jni_env->ExceptionOccurred()) {\n+  jthrowable ex = jni_env->ExceptionOccurred();\n+  if (ex != nullptr) {\n+    \/\/ we can not return with a pending exception from this JMVTI callback,\n+    \/\/ and there is no way to propagate it to the caller so that the memory\n+    \/\/ access will be interrupted.\n+    \/\/ We log the exception for testing purposes end then terminate the process.\n@@ -91,0 +107,5 @@\n+    if (jni_env->IsInstanceOf(ex, EXCEPTION_CLS)) {\n+      exit(0); \/\/ success\n+    }\n+    \/\/ else, another exception was thrown. Let the java logic handle the lack of\n+    \/\/ ScopedAccessError\n@@ -92,3 +113,0 @@\n-\n-  jvmti_env->Deallocate((unsigned char*) method_name);\n-  jvmti_env->Deallocate((unsigned char*) class_sig);\n","filename":"test\/jdk\/java\/foreign\/sharedclosejvmti\/libSharedCloseAgent.cpp","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"}]}