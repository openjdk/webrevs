{"files":[{"patch":"@@ -3142,0 +3142,7 @@\n+  \/\/ If the current thread is attaching from native and its Java thread object\n+  \/\/ is being allocated, things are not ready for allocation sampling.\n+  JavaThread* jt = JavaThread::cast(thread);\n+  if (jt->is_attaching_via_jni() && jt->threadObj() == nullptr) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-  if (thread_oop == nullptr) {  \/\/ Then thread should not be null (see assert above).\n-    thread_oop = thread->jvmti_vthread() != nullptr ? thread->jvmti_vthread() : thread->threadObj();\n-  }\n-\n@@ -88,2 +84,5 @@\n-  if (state == nullptr && thread != nullptr && thread->is_exiting()) {\n-    \/\/ Don't add a JvmtiThreadState to a thread that is exiting.\n+  if (state == nullptr && thread != nullptr &&\n+      (thread->is_exiting() || thread->is_attaching_via_jni())) {\n+    \/\/ Don't add a JvmtiThreadState to a thread that is exiting or is attaching.\n+    \/\/ When a thread is attaching, it may not have a Java level thread object\n+    \/\/ created yet.\n@@ -92,0 +91,11 @@\n+\n+  \/\/ Make sure we don't see an incomplete state. An incomplete state can cause\n+  \/\/ a duplicate JvmtiThreadState being created below and bound to the 'thread'\n+  \/\/ incorrectly, which leads to stale JavaThread* from the JvmtiThreadState\n+  \/\/ after the thread exits.\n+  assert(state == nullptr || state->get_thread_oop() != nullptr,\n+         \"incomplete state\");\n+\n+  if (thread_oop == nullptr) {  \/\/ Then thread should not be null (see assert above).\n+    thread_oop = thread->jvmti_vthread() != nullptr ? thread->jvmti_vthread() : thread->threadObj();\n+  }\n@@ -101,0 +111,1 @@\n+  assert(state != nullptr, \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"}]}