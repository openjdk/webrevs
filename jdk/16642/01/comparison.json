{"files":[{"patch":"@@ -3142,0 +3142,9 @@\n+  \/\/ If the current thread is attaching from native and its thread oop is being\n+  \/\/ allocated, things are not ready for allocation sampling.\n+  if (thread->is_Java_thread()) {\n+    JavaThread* jt = JavaThread::cast(thread);\n+    if (jt->is_attaching_via_jni() && jt->threadObj() == nullptr) {\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-  if (thread_oop == nullptr) {  \/\/ Then thread should not be null (see assert above).\n-    thread_oop = thread->jvmti_vthread() != nullptr ? thread->jvmti_vthread() : thread->threadObj();\n-  }\n-\n@@ -92,0 +88,14 @@\n+\n+#ifdef ASSERT\n+  \/\/ Make sure we don't see an incomplete state. An incomplete state can cause\n+  \/\/ a duplicate JvmtiThreadState being created below and bound to the 'thread'\n+  \/\/ incorrectly, which leads to stale JavaThread* from the JvmtiThreadState\n+  \/\/ after the thread exits.\n+  if (state != nullptr) {\n+    assert(state->get_thread_oop() != nullptr, \"incomplete state\");\n+  }\n+#endif\n+\n+  if (thread_oop == nullptr) {  \/\/ Then thread should not be null (see assert above).\n+    thread_oop = thread->jvmti_vthread() != nullptr ? thread->jvmti_vthread() : thread->threadObj();\n+  }\n@@ -101,0 +111,1 @@\n+  assert(state != nullptr, \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}