{"files":[{"patch":"@@ -3142,0 +3142,9 @@\n+  \/\/ If the current thread is attaching from native and its thread oop is being\n+  \/\/ allocated, things are not ready for allocation sampling.\n+  if (thread->is_Java_thread()) {\n+    JavaThread* jt = JavaThread::cast(thread);\n+    if (jt->is_attaching_via_jni() && jt->threadObj() == nullptr) {\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -89,0 +89,10 @@\n+#ifdef ASSERT\n+  \/\/ Make sure we don't see an incomplete state. An incomplete state can cause\n+  \/\/ a duplicate JvmtiThreadState being created below and bound to the 'thread'\n+  \/\/ incorrectly, which leads to stale JavaThread* from the JvmtiThreadState\n+  \/\/ after the thread exits.\n+  if (state != nullptr) {\n+    assert(state->get_thread_oop() != nullptr, \"incomplete state\");\n+  }\n+#endif\n+\n@@ -92,5 +102,1 @@\n-  \/\/ The state->get_thread_oop() may be null if the state is created during\n-  \/\/ the allocation of the thread oop when a native thread is attaching. Make\n-  \/\/ sure we don't create a new state for the JavaThread.\n-  if (state == nullptr || (state->get_thread_oop() != nullptr &&\n-                           state->get_thread_oop() != thread_oop)) {\n+  if (state == nullptr || state->get_thread_oop() != thread_oop) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}