{"files":[{"patch":"@@ -479,0 +479,3 @@\n+                \/\/ Add to the cache, to enable the fast path, next time.\n+                checkCacheLoad();\n+                addToCache(classValue, updated);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,3 +26,1 @@\n- * @bug 8351045 8351996\n- * @enablePreview\n- * @comment Remove preview if ScopedValue is finalized\n+ * @bug 8351045 8351996 8358535\n@@ -30,0 +28,1 @@\n+ * @modules java.base\/java.lang:+open\n@@ -36,0 +35,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -37,0 +37,1 @@\n+import java.lang.invoke.MethodType;\n@@ -42,1 +43,0 @@\n-import java.util.Iterator;\n@@ -52,1 +52,0 @@\n-import org.junit.jupiter.api.RepeatedTest;\n@@ -54,1 +53,0 @@\n-import org.junit.jupiter.api.Timeout;\n@@ -482,0 +480,63 @@\n+\n+    \/\/ ClassValue cache invalidated and not reinstated when another\n+    \/\/ unrelated entry is removed\n+    @Test\n+    public void testCacheRefresh() throws Throwable {\n+        \/\/ Setup\n+        var lookup = MethodHandles.privateLookupIn(ClassValue.class, MethodHandles.lookup());\n+        var classValueEntryClass = Class.forName(\"java.lang.ClassValue$Entry\");\n+        MethodHandle getCacheCarefully = lookup.findStatic(ClassValue.class, \"getCacheCarefully\",\n+                MethodType.methodType(classValueEntryClass.arrayType(), Class.class));\n+        var classValueMapClass = Class.forName(\"java.lang.ClassValue$ClassValueMap\");\n+        MethodHandle probeHomeLocation = lookup.findStatic(classValueMapClass, \"probeHomeLocation\",\n+                MethodType.methodType(classValueEntryClass, classValueEntryClass.arrayType(), ClassValue.class));\n+        MethodHandle match = lookup.findVirtual(ClassValue.class, \"match\",\n+                MethodType.methodType(boolean.class, classValueEntryClass));\n+\n+        \/\/ Work\n+        ClassValue<?> clv = new ClassValue<>() {\n+            @Override\n+            protected String computeValue(Class<?> type) {\n+                return \"\";\n+            }\n+        };\n+        \/\/ A class that shouldn't have arbitrary values stuffing the cache\n+        var cleanClass = clv.getClass();\n+        clv.get(cleanClass); \/\/ create cache on clean class\n+        assertTrue(checkDirectCacheMatch(\n+                getCacheCarefully,\n+                probeHomeLocation,\n+                match,\n+                clv,\n+                cleanClass\n+        ));\n+        clv.get(int.class);\n+        clv.remove(int.class); \/\/ invalidate cache on clean class\n+        assertFalse(checkDirectCacheMatch(\n+                getCacheCarefully,\n+                probeHomeLocation,\n+                match,\n+                clv,\n+                cleanClass\n+        ));\n+        clv.get(cleanClass);\n+        assertTrue(checkDirectCacheMatch(\n+                getCacheCarefully,\n+                probeHomeLocation,\n+                match,\n+                clv,\n+                cleanClass\n+        ));\n+    }\n+\n+    private static boolean checkDirectCacheMatch(\n+            MethodHandle getCacheCarefully,\n+            MethodHandle probeHomeLocation,\n+            MethodHandle match,\n+            ClassValue<?> clv,\n+            Class<?> cl\n+    ) throws Throwable {\n+        Object cache = getCacheCarefully.invoke(cl);\n+        Object entry = probeHomeLocation.invoke(cache, clv);\n+        return (boolean) match.invoke(clv, entry);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":67,"deletions":6,"binary":false,"changes":73,"status":"modified"}]}