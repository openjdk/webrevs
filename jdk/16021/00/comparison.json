{"files":[{"patch":"@@ -520,27 +520,0 @@\n-    \/*\n-     * Initialize after phase1.\n-     *\/\n-    private static class LateInit {\n-        static final MethodHandle GETCHAR_LATIN1_MH;\n-\n-        static final MethodHandle GETCHAR_UTF16_MH;\n-\n-        static final MethodHandle PUTCHAR_LATIN1_MH;\n-\n-        static final MethodHandle PUTCHAR_UTF16_MH;\n-\n-        static {\n-            MethodType getCharMT =\n-                MethodType.methodType(char.class,\n-                        byte[].class, int.class);\n-            MethodType putCharMT =\n-                MethodType.methodType(void.class,\n-                        byte[].class, int.class, int.class);\n-            GETCHAR_LATIN1_MH = lookupStatic(\"getCharLatin1\", getCharMT);\n-            GETCHAR_UTF16_MH = lookupStatic(\"getCharUTF16\", getCharMT);\n-            PUTCHAR_LATIN1_MH = lookupStatic(\"putCharLatin1\", putCharMT);\n-            PUTCHAR_UTF16_MH = lookupStatic(\"putCharUTF16\", putCharMT);\n-        }\n-\n-    }\n-\n@@ -553,0 +526,6 @@\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static boolean isLatin1(long indexCoder) {\n+        return indexCoder < UTF16;\n+    }\n+\n@@ -571,14 +550,0 @@\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectGetChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.GETCHAR_LATIN1_MH :\n-                                    LateInit.GETCHAR_UTF16_MH;\n-    }\n-\n-    @ForceInline\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-    static MethodHandle selectPutChar(long indexCoder) {\n-        return indexCoder < UTF16 ? LateInit.PUTCHAR_LATIN1_MH :\n-                                    LateInit.PUTCHAR_UTF16_MH;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":6,"deletions":41,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2490,0 +2490,3 @@\n+            public void putCharUTF16(byte[] bytes, int index, int ch) {\n+                StringUTF16.putChar(bytes, index, ch);\n+            }\n@@ -2530,0 +2533,8 @@\n+            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value) {\n+                return StringConcatHelper.prepend(indexCoder, buf, value);\n+            }\n+\n+            public boolean stringConcatHelpeIsLatin1(long lengthCoder) {\n+                return StringConcatHelper.isLatin1(lengthCoder);\n+            }\n+\n@@ -2538,0 +2549,4 @@\n+            public long stringConcatMix(long lengthCoder, char value) {\n+                return StringConcatHelper.mix(lengthCoder, value);\n+            }\n+\n@@ -2555,0 +2570,12 @@\n+            public int stringSize(long i) {\n+                return Long.stringSize(i);\n+            }\n+\n+            public int getCharsLatin1(long i, int index, byte[] buf) {\n+                return StringLatin1.getChars(i, index, buf);\n+            }\n+\n+            public int getCharsUTF16(long i, int index, byte[] buf) {\n+                return StringUTF16.getChars(i, index, buf);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -38,0 +39,1 @@\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -39,1 +41,0 @@\n-import jdk.internal.util.DecimalDigits;\n@@ -42,2 +43,1 @@\n-\n-import static java.lang.invoke.MethodType.methodType;\n+import jdk.internal.vm.annotation.Stable;\n@@ -57,17 +57,0 @@\n-    private static final MethodHandle CHAR_MIX =\n-            JLA.stringConcatHelper(\"mix\",\n-                    MethodType.methodType(long.class, long.class,char.class));\n-\n-    private static final MethodHandle STRING_PREPEND =\n-            JLA.stringConcatHelper(\"prepend\",\n-                    MethodType.methodType(long.class, long.class, byte[].class,\n-                            String.class));\n-\n-    private static final MethodHandle SELECT_GETCHAR_MH =\n-            JLA.stringConcatHelper(\"selectGetChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n-    private static final MethodHandle SELECT_PUTCHAR_MH =\n-            JLA.stringConcatHelper(\"selectPutChar\",\n-                    MethodType.methodType(MethodHandle.class, long.class));\n-\n@@ -75,7 +58,1 @@\n-        try {\n-            return (long)CHAR_MIX.invokeExact(lengthCoder, value);\n-        } catch (Error | RuntimeException ex) {\n-            throw ex;\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        return JLA.stringConcatMix(lengthCoder, value);\n@@ -88,7 +65,2 @@\n-    private static long stringPrepend(long lengthCoder, byte[] buffer,\n-                                            String value) throws Throwable {\n-        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value);\n-    }\n-\n-    private static MethodHandle selectGetChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_GETCHAR_MH.invokeExact(indexCoder);\n+    private static long stringPrepend(long lengthCoder, byte[] buffer, String value) {\n+        return JLA.stringConcatHelperPrepend(lengthCoder, buffer, value);\n@@ -97,15 +69,2 @@\n-    private static MethodHandle selectPutChar(long indexCoder) throws Throwable {\n-        return (MethodHandle)SELECT_PUTCHAR_MH.invokeExact(indexCoder);\n-    }\n-\n-    private static final MethodHandle PUT_CHAR_DIGIT;\n-\n-    static {\n-        try {\n-            Lookup lookup = MethodHandles.lookup();\n-            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n-                    MethodType.methodType(void.class,\n-                            byte[].class, int.class, int.class));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(\"putByte lookup failed\", ex);\n-        }\n+    private static void putCharUTF16(byte[] buffer, int index, int ch) {\n+        JLA.putCharUTF16(buffer, index, ch);\n@@ -114,2 +73,2 @@\n-    private static void putByte(byte[] buffer, int index, int ch) {\n-        buffer[index] = (byte)ch;\n+    private static boolean isLatin1(long lengthCoder) {\n+        return JLA.stringConcatHelpeIsLatin1(lengthCoder);\n@@ -130,1 +89,0 @@\n-        private final byte[] digits;\n@@ -140,1 +98,1 @@\n-                          boolean parentheses, int groupSize, long value) throws Throwable {\n+                          boolean parentheses, int groupSize, long value) {\n@@ -145,3 +103,1 @@\n-            int length = DecimalDigits.INSTANCE.size(value);\n-            this.digits = new byte[length];\n-            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n+            int length = JLA.stringSize(value);\n@@ -173,2 +129,10 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n+\n+        private long prependLatin1(long lengthCoder, byte[] buffer) {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n@@ -177,1 +141,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n+                buffer[--lengthCoderLatin1] = ')';\n@@ -183,0 +147,4 @@\n+                int digitLength = this.length + (isNegative ? 1 : 0);\n+                byte[] digits = new byte[digitLength];\n+                JLA.getCharsLatin1(value, digitLength, digits);\n+\n@@ -185,2 +153,1 @@\n-                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                                (int)groupingSeparator);\n+                        buffer[--lengthCoderLatin1] = (byte) groupingSeparator;\n@@ -190,2 +157,1 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    buffer[--lengthCoderLatin1] = (byte) (digits[digits.length - i] + digitOffset);\n@@ -194,0 +160,31 @@\n+                JLA.getCharsLatin1(value, lengthCoderLatin1, buffer);\n+                lengthCoderLatin1 -= length;\n+            }\n+\n+            for (int i = length + signLength() + groupLength(); i < width; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            if (parentheses) {\n+                buffer[--lengthCoderLatin1] = '(';\n+            }\n+\n+            if (prefixSign != '\\0') {\n+                buffer[--lengthCoderLatin1] = prefixSign;\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        private long prependUTF16(long lengthCoder, byte[] buffer) {\n+            if (parentheses) {\n+                putCharUTF16(buffer, (int)--lengthCoder, (int)')');\n+            }\n+\n+            if (0 < groupSize) {\n+                int groupIndex = groupSize;\n+\n+                int digitLength = this.length + (isNegative ? 1 : 0);\n+                byte[] digits = new byte[digitLength];\n+                JLA.getCharsLatin1(value, digitLength, digits);\n+\n@@ -195,2 +192,6 @@\n-                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n-                            digits[digits.length - i] + digitOffset);\n+                    if (groupIndex-- == 0) {\n+                        putCharUTF16(buffer, (int) --lengthCoder, (int) groupingSeparator);\n+                        groupIndex = groupSize - 1;\n+                    }\n+\n+                    putCharUTF16(buffer, (int) --lengthCoder, digits[digits.length - i] + digitOffset);\n@@ -198,0 +199,3 @@\n+            } else {\n+                JLA.getCharsUTF16(value, (int)lengthCoder, buffer);\n+                lengthCoder -= length;\n@@ -201,1 +205,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '0');\n@@ -205,1 +209,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) '(');\n@@ -207,0 +211,1 @@\n+\n@@ -208,1 +213,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n+                putCharUTF16(buffer, (int) --lengthCoder, (int) prefixSign);\n@@ -228,1 +233,1 @@\n-            this.length = HexDigits.INSTANCE.size(value);\n+            this.length = HexDigits.stringSize(value);\n@@ -245,3 +250,23 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n+\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            HexDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n+            lengthCoderLatin1 -= length;\n+\n+            if (hasPrefix && value != 0) {\n+                buffer[--lengthCoderLatin1] = 'x';\n+                buffer[--lengthCoderLatin1] = '0';\n+            }\n+\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) {\n+            HexDigits.getCharsUTF16(value, (int)lengthCoder, buffer);\n@@ -251,1 +276,1 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -254,3 +279,3 @@\n-            if (hasPrefix) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            if (hasPrefix && value != 0) {\n+                putCharUTF16(buffer, (int)--lengthCoder, 'x');\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -276,1 +301,1 @@\n-            this.length = OctalDigits.INSTANCE.size(value);\n+            this.length = OctalDigits.stringSize(value);\n@@ -293,4 +318,7 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n-            lengthCoder -= length;\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                return prependLatin1(lengthCoder, buffer);\n+            } else {\n+                return prependUTF16(lengthCoder, buffer);\n+            }\n+        }\n@@ -298,2 +326,12 @@\n-            for (int i = 0; i < zeroesLength(); i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+        protected long prependLatin1(long lengthCoder, byte[] buffer) {\n+            int lengthCoderLatin1 = (int) lengthCoder;\n+            OctalDigits.getCharsLatin1(value, lengthCoderLatin1, buffer);\n+            lengthCoderLatin1 -= length;\n+\n+            int zeroesLength = zeroesLength();\n+            if (hasPrefix && value != 0) {\n+                zeroesLength++;\n+            }\n+\n+            for (int i = 0; i < zeroesLength; i++) {\n+                buffer[--lengthCoderLatin1] = '0';\n@@ -302,0 +340,8 @@\n+            return lengthCoderLatin1;\n+        }\n+\n+        protected long prependUTF16(long lengthCoder, byte[] buffer) {\n+            OctalDigits.getCharsUTF16(value, (int) lengthCoder, buffer);\n+            lengthCoder -= length;\n+\n+            int zeroesLength = zeroesLength();\n@@ -303,1 +349,4 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+                zeroesLength++;\n+            }\n+            for (int i = 0; i < zeroesLength; i++) {\n+                putCharUTF16(buffer, (int)--lengthCoder, '0');\n@@ -314,0 +363,6 @@\n+        static final int TRUE_LATIN1;\n+        static final long TRUE_UTF16;\n+\n+        static final int FALS_LATIN1;\n+        static final long FALS_UTF16;\n+\n@@ -316,0 +371,20 @@\n+        static {\n+            byte[] bytes4 = new byte[] {'t', 'r', 'u', 'e'};\n+            byte[] bytes8 = new byte[8];\n+            TRUE_LATIN1 = ByteArrayLittleEndian.getInt(bytes4, 0);\n+            for (int i = 0; i < bytes4.length; i++) {\n+                JLA.putCharUTF16(bytes8, i, bytes4[i]);\n+            }\n+            TRUE_UTF16 = ByteArrayLittleEndian.getLong(bytes8, 0);\n+\n+            bytes4[0] = 'f';\n+            bytes4[1] = 'a';\n+            bytes4[2] = 'l';\n+            bytes4[3] = 's';\n+            FALS_LATIN1 = ByteArrayLittleEndian.getInt(bytes4, 0);\n+            for (int i = 0; i < bytes4.length; i++) {\n+                JLA.putCharUTF16(bytes8, i, bytes4[i]);\n+            }\n+            FALS_UTF16 = ByteArrayLittleEndian.getLong(bytes8, 0);\n+        }\n+\n@@ -322,1 +397,1 @@\n-            return lengthCoder + (value ? \"true\".length() : \"false\".length());\n+            return lengthCoder + (value ? 4 : 5);\n@@ -326,8 +401,10 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            if (value) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'r');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'t');\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            boolean latin1 = isLatin1(lengthCoder);\n+\n+            lengthCoder -= (value ? 4 : 5);\n+            int off = ((int) lengthCoder) << (latin1 ? 0 : 1);\n+            if (latin1) {\n+                ByteArrayLittleEndian.setInt(buffer, off, value ? TRUE_LATIN1 : FALS_LATIN1);\n+                if (!value) {\n+                    buffer[off + 4] = 'e';\n+                }\n@@ -335,5 +412,4 @@\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'s');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'a');\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'f');\n+                ByteArrayLittleEndian.setLong(buffer, off, value ? TRUE_UTF16 : FALS_UTF16);\n+                if (!value) {\n+                    JLA.putCharUTF16(buffer, (off >> 1) + 4, 'e');\n+                }\n@@ -341,1 +417,0 @@\n-\n@@ -343,1 +418,1 @@\n-         }\n+        }\n@@ -362,4 +437,6 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)value);\n-\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            if (isLatin1(lengthCoder)) {\n+                buffer[(int) --lengthCoder] = (byte) value;\n+            } else {\n+                putCharUTF16(buffer, (int) --lengthCoder, value);\n+            }\n@@ -386,1 +463,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+        public long prepend(long lengthCoder, byte[] buffer) {\n@@ -422,1 +499,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+        public long prepend(long lengthCoder, byte[] buffer) {\n@@ -428,2 +505,2 @@\n-        permits FormatItemFillLeft,\n-                FormatItemFillRight\n+            permits FormatItemFillLeft,\n+            FormatItemFillRight\n@@ -451,1 +528,1 @@\n-        public abstract long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+        public abstract long prepend(long lengthCoder, byte[] buffer);\n@@ -472,2 +549,1 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+        public long prepend(long lengthCoder, byte[] buffer) {\n@@ -476,2 +552,8 @@\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+            if (isLatin1(lengthCoder)) {\n+                for (int i = length(); i < width; i++) {\n+                    buffer[(int) --lengthCoder] = ' ';\n+                }\n+            } else {\n+                for (int i = length(); i < width; i++) {\n+                    putCharUTF16(buffer, (int) --lengthCoder, (int) ' ');\n+                }\n@@ -502,5 +584,10 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            for (int i = length(); i < width; i++) {\n-                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            int length = length();\n+            if (isLatin1(lengthCoder)) {\n+                for (int i = length; i < width; i++) {\n+                    buffer[(int)--lengthCoder] = ' ';\n+                }\n+            } else {\n+                for (int i = length; i < width; i++) {\n+                    putCharUTF16(buffer, (int)--lengthCoder, ' ');\n+                }\n@@ -520,0 +607,13 @@\n+        static final int NULL_LATIN1;\n+        static final long NULL_UTF16;\n+\n+        static {\n+            byte[] bytes4 = new byte[] {'n', 'u', 'l', 'l'};\n+            byte[] bytes8 = new byte[8];\n+            NULL_LATIN1 = ByteArrayLittleEndian.getInt(bytes4, 0);\n+            for (int i = 0; i < bytes4.length; i++) {\n+                JLA.putCharUTF16(bytes8, i, bytes4[i]);\n+            }\n+            NULL_UTF16 = ByteArrayLittleEndian.getLong(bytes8, 0);\n+        }\n+\n@@ -525,1 +625,1 @@\n-            return lengthCoder + \"null\".length();\n+            return lengthCoder + 4;\n@@ -529,7 +629,2 @@\n-        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n-            MethodHandle putCharMH = selectPutChar(lengthCoder);\n-\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n-            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'n');\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            boolean latin1 = isLatin1(lengthCoder);\n@@ -537,0 +632,7 @@\n+            lengthCoder -= 4;\n+            int off = ((int) lengthCoder) << (latin1 ? 0 : 1);\n+            if (latin1) {\n+                ByteArrayLittleEndian.setInt(buffer, off, NULL_LATIN1);\n+            } else {\n+                ByteArrayLittleEndian.setLong(buffer, off, NULL_UTF16);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":228,"deletions":126,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -361,0 +361,9 @@\n+    \/**\n+     * Put the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     *\/\n+    void putCharUTF16(byte[] bytes, int index, int ch);\n+\n@@ -414,0 +423,11 @@\n+    \/**\n+     * Returns {@code true} if lengthCoder is Latin1\n+     *\/\n+    boolean stringConcatHelpeIsLatin1(long lengthCoder);\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\/\n+    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value);\n+\n@@ -424,0 +444,5 @@\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     *\/\n+    long stringConcatMix(long lengthCoder, char value);\n+\n@@ -451,0 +476,6 @@\n+    int stringSize(long i);\n+\n+    int getCharsLatin1(long i, int index, byte[] buf);\n+\n+    int getCharsUTF16(long i, int index, byte[] buf);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public final class DecimalDigits implements Digits {\n+public final class DecimalDigits {\n@@ -75,5 +75,0 @@\n-    \/**\n-     * Singleton instance of DecimalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new DecimalDigits();\n-\n@@ -86,68 +81,0 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n-        boolean negative = value < 0;\n-        if (!negative) {\n-            value = -value;\n-        }\n-\n-        long q;\n-        int r;\n-        while (value <= Integer.MIN_VALUE) {\n-            q = value \/ 100;\n-            r = (int)((q * 100) - value);\n-            value = q;\n-            int digits = DIGITS[r];\n-\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        int iq, ivalue = (int)value;\n-        while (ivalue <= -100) {\n-            iq = ivalue \/ 100;\n-            r = (iq * 100) - ivalue;\n-            ivalue = iq;\n-            int digits = DIGITS[r];\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        if (ivalue < 0) {\n-            ivalue = -ivalue;\n-        }\n-\n-        int digits = DIGITS[ivalue];\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n-\n-        if (9 < ivalue) {\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n-        }\n-\n-        if (negative) {\n-            putCharMH.invokeExact(buffer, --index, (int)'-');\n-        }\n-\n-        return index;\n-    }\n-\n-    @Override\n-    public int size(long value) {\n-        boolean negative = value < 0;\n-        int sign = negative ? 1 : 0;\n-\n-        if (!negative) {\n-            value = -value;\n-        }\n-\n-        long precision = -10;\n-        for (int i = 1; i < 19; i++) {\n-            if (value > precision)\n-                return i + sign;\n-\n-            precision = 10 * precision;\n-        }\n-\n-        return 19 + sign;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":1,"deletions":74,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Digits provides a fast methodology for converting integers and longs to\n- * ASCII strings.\n- *\n- * @since 21\n- *\/\n-public sealed interface Digits permits DecimalDigits, HexDigits, OctalDigits {\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param buffer     byte buffer to copy into\n-     * @param index      insert point + 1\n-     * @param putCharMH  method to put character\n-     *\n-     * @return the last index used\n-     *\n-     * @throws Throwable if putCharMH fails (unusual).\n-     *\/\n-    int digits(long value, byte[] buffer, int index,\n-               MethodHandle putCharMH) throws Throwable;\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    int size(long value);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Digits.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -54,2 +54,0 @@\n-     *\n-     * @throws Throwable if fails to prepend value (unusual).\n@@ -57,1 +55,1 @@\n-    long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+    long prepend(long lengthCoder, byte[] buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/FormatConcatItem.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +35,2 @@\n- * Digits class for hexadecimal digits.\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * hexadecimal digits ASCII strings.\n@@ -37,1 +40,3 @@\n-public final class HexDigits implements Digits {\n+public final class HexDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -68,5 +73,0 @@\n-    \/**\n-     * Singleton instance of HexDigits.\n-     *\/\n-    public static final Digits INSTANCE = new HexDigits();\n-\n@@ -139,3 +139,39 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n+        while ((value & ~0xFF) != 0) {\n+            short pair = DIGITS[((int) value) & 0xFF];\n+            buffer[--index] = (byte)(pair >> 8);\n+            buffer[--index] = (byte)(pair);\n+            value >>>= 8;\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0xFF)];\n+        buffer[--index] = (byte) (digits >> 8);\n+\n+        if (0xF < value) {\n+            buffer[--index] = (byte) (digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer) {\n@@ -143,1 +179,3 @@\n-            int digits = DIGITS[(int) (value & 0xFF)];\n+            int pair = (int) DIGITS[((int) value) & 0xFF];\n+            JLA.putCharUTF16(buffer, --index, pair >> 8);\n+            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n@@ -145,2 +183,0 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n@@ -150,1 +186,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        JLA.putCharUTF16(buffer, --index, (byte) (digits >> 8));\n@@ -153,1 +189,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            JLA.putCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n@@ -159,2 +195,8 @@\n-    @Override\n-    public int size(long value) {\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":59,"deletions":17,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +39,9 @@\n-public final class OctalDigits implements Digits {\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * octal digits ASCII strings.\n+ *\n+ * @since 21\n+ *\/\n+public final class OctalDigits {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -41,5 +51,0 @@\n-    \/**\n-     * Singleton instance of OctalDigits.\n-     *\/\n-    public static final Digits INSTANCE = new OctalDigits();\n-\n@@ -67,3 +72,11 @@\n-    @Override\n-    public int digits(long value, byte[] buffer, int index,\n-                      MethodHandle putCharMH) throws Throwable {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer){\n@@ -71,1 +84,1 @@\n-            int digits = DIGITS[(int) (value & 0x3F)];\n+            int digits = DIGITS[((int) value) & 0x3F];\n@@ -73,2 +86,2 @@\n-            putCharMH.invokeExact(buffer, --index, digits >> 8);\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits >> 8);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -78,1 +91,1 @@\n-        putCharMH.invokeExact(buffer, --index, digits >> 8);\n+        buffer[--index] = (byte) (digits >> 8);\n@@ -81,1 +94,1 @@\n-            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+            buffer[--index] = (byte) (digits & 0xFF);\n@@ -87,2 +100,38 @@\n-    @Override\n-    public int size(long value) {\n+\n+    \/**\n+     * This is a variant of {@link OctalDigits#getCharsLatin1(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer){\n+        while ((value & ~0x3F) != 0) {\n+            int pair = (int) DIGITS[((int) value) & 0x3F];\n+            JLA.putCharUTF16(buffer, --index, pair >> 8);\n+            JLA.putCharUTF16(buffer, --index, pair & 0xFF);\n+            value >>>= 6;\n+        }\n+\n+        int digits = DIGITS[(int) (value & 0x3F)];\n+        JLA.putCharUTF16(buffer, --index, digits >> 8);\n+\n+        if (7 < value) {\n+            JLA.putCharUTF16(buffer, --index, digits & 0xFF);\n+        }\n+\n+        return index;\n+    }\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    public static int stringSize(long value) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OctalDigits.java","additions":65,"deletions":16,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -92,0 +92,14 @@\n+        \/\/ utf16\n+        test(String.format(\"\\u8336%b\", false), fmt.\"\\u8336%b\\{false}\");\n+        test(String.format(\"\\u8336%b\", true), fmt.\"\\u8336%b\\{true}\");\n+        test(String.format(\"\\u8336%10b\", false), fmt.\"\\u8336%10b\\{false}\");\n+        test(String.format(\"\\u8336%10b\", true), fmt.\"\\u8336%10b\\{true}\");\n+        test(String.format(\"\\u8336%-10b\", false), fmt.\"\\u8336%-10b\\{false}\");\n+        test(String.format(\"\\u8336%-10b\", true), fmt.\"\\u8336%-10b\\{true}\");\n+        test(String.format(\"\\u8336%B\", false), fmt.\"\\u8336%B\\{false}\");\n+        test(String.format(\"\\u8336%B\", true), fmt.\"\\u8336%B\\{true}\");\n+        test(String.format(\"\\u8336%10B\", false), fmt.\"\\u8336%10B\\{false}\");\n+        test(String.format(\"\\u8336%10B\", true), fmt.\"\\u8336%10B\\{true}\");\n+        test(String.format(\"\\u8336%-10B\", false), fmt.\"\\u8336%-10B\\{false}\");\n+        test(String.format(\"\\u8336%-10B\", true), fmt.\"\\u8336%-10B\\{true}\");\n+\n@@ -113,0 +127,1 @@\n+        test(String.format(\"\\u8336%s\", nullObject), fmt.\"\\u8336%s\\{nullObject}\"); \/\/ utf16\n@@ -155,0 +170,1 @@\n+        test(String.format(\"\\u8336%c\", 'a'), fmt.\"\\u8336%c\\{'a'}\"); \/\/ utf16\n@@ -190,0 +206,1 @@\n+        test(String.format(\"\\u8336%10d\", -12345), fmt.\"\\u8336%10d\\{-12345}\"); \/\/ utf16\n@@ -334,0 +351,1 @@\n+        test(String.format(\"\\u8336%o\", -12345), fmt.\"\\u8336%o\\{-12345}\"); \/\/ utf16\n@@ -359,0 +377,1 @@\n+        test(String.format(\"\\u8336%x\", -12345), fmt.\"\\u8336%x\\{-12345}\");\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}