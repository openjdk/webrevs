{"files":[{"patch":"@@ -27,1 +27,0 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"nmt\/nativeMemoryFileTracker.hpp\"\n@@ -32,1 +32,1 @@\n-MemoryFileTracker::MemoryFile* ZNMT::_device = nullptr;\n+NativeMemoryFileTracker::MemoryFile* ZNMT::_device = nullptr;\n","filename":"src\/hotspot\/share\/gc\/z\/zNMT.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"nmt\/nativeMemoryFileTracker.hpp\"\n@@ -36,1 +36,1 @@\n-  static MemoryFileTracker::MemoryFile* _device;\n+  static NativeMemoryFileTracker::MemoryFile* _device;\n","filename":"src\/hotspot\/share\/gc\/z\/zNMT.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    MemoryFileTracker::Instance::summary_snapshot(&_virtual_memory_snapshot);\n+    NativeMemoryFileTracker::Instance::summary_snapshot(&_virtual_memory_snapshot);\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n+#include \"nmt\/nativeMemoryFileTracker.hpp\"\n@@ -469,1 +469,1 @@\n-    MemoryFileTracker::Instance::print_all_reports_on(&st, scale());\n+    NativeMemoryFileTracker::Instance::print_all_reports_on(&st, scale());\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        !MemoryFileTracker::Instance::initialize(level) ||\n+        !NativeMemoryFileTracker::Instance::initialize(level) ||\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n+#include \"nmt\/nativeMemoryFileTracker.hpp\"\n@@ -176,1 +176,1 @@\n-  static inline MemoryFileTracker::MemoryFile* register_file(const char* descriptive_name) {\n+  static inline NativeMemoryFileTracker::MemoryFile* register_file(const char* descriptive_name) {\n@@ -180,1 +180,1 @@\n-    return MemoryFileTracker::Instance::make_file(descriptive_name);\n+    return NativeMemoryFileTracker::Instance::make_file(descriptive_name);\n@@ -183,1 +183,1 @@\n-  static inline void remove_file(MemoryFileTracker::MemoryFile* file) {\n+  static inline void remove_file(NativeMemoryFileTracker::MemoryFile* file) {\n@@ -188,1 +188,1 @@\n-    MemoryFileTracker::Instance::free_file(file);\n+    NativeMemoryFileTracker::Instance::free_file(file);\n@@ -191,1 +191,1 @@\n-  static inline void allocate_memory_in(MemoryFileTracker::MemoryFile* file, size_t offset, size_t size,\n+  static inline void allocate_memory_in(NativeMemoryFileTracker::MemoryFile* file, size_t offset, size_t size,\n@@ -197,1 +197,1 @@\n-    MemoryFileTracker::Instance::allocate_memory(file, offset, size, stack, mem_tag);\n+    NativeMemoryFileTracker::Instance::allocate_memory(file, offset, size, stack, mem_tag);\n@@ -200,1 +200,1 @@\n-  static inline void free_memory_in(MemoryFileTracker::MemoryFile* file,\n+  static inline void free_memory_in(NativeMemoryFileTracker::MemoryFile* file,\n@@ -206,1 +206,1 @@\n-    MemoryFileTracker::Instance::free_memory(file, offset, size);\n+    NativeMemoryFileTracker::Instance::free_memory(file, offset, size);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"nmt\/memoryFileTracker.hpp\"\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n-#include \"nmt\/vmatree.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/nativeCallStack.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-MemoryFileTracker* MemoryFileTracker::Instance::_tracker = nullptr;\n-\n-MemoryFileTracker::MemoryFileTracker(bool is_detailed_mode)\n-  : _stack_storage(is_detailed_mode), _files() {}\n-\n-void MemoryFileTracker::allocate_memory(MemoryFile* file, size_t offset,\n-                                        size_t size, const NativeCallStack& stack,\n-                                        MemTag mem_tag) {\n-  NativeCallStackStorage::StackIndex sidx = _stack_storage.push(stack);\n-  VMATree::RegionData regiondata(sidx, mem_tag);\n-  VMATree::SummaryDiff diff = file->_tree.commit_mapping(offset, size, regiondata);\n-  for (int i = 0; i < mt_number_of_tags; i++) {\n-    VirtualMemory* summary = file->_summary.by_tag(NMTUtil::index_to_tag(i));\n-    summary->reserve_memory(diff.tag[i].commit);\n-    summary->commit_memory(diff.tag[i].commit);\n-  }\n-}\n-\n-void MemoryFileTracker::free_memory(MemoryFile* file, size_t offset, size_t size) {\n-  VMATree::SummaryDiff diff = file->_tree.release_mapping(offset, size);\n-  for (int i = 0; i < mt_number_of_tags; i++) {\n-    VirtualMemory* summary = file->_summary.by_tag(NMTUtil::index_to_tag(i));\n-    summary->reserve_memory(diff.tag[i].commit);\n-    summary->commit_memory(diff.tag[i].commit);\n-  }\n-}\n-\n-void MemoryFileTracker::print_report_on(const MemoryFile* file, outputStream* stream, size_t scale) {\n-  assert(MemTracker::tracking_level() == NMT_detail, \"must\");\n-\n-  stream->print_cr(\"Memory map of %s\", file->_descriptive_name);\n-  stream->cr();\n-  VMATree::TreapNode* prev = nullptr;\n-#ifdef ASSERT\n-  VMATree::TreapNode* broken_start = nullptr;\n-  VMATree::TreapNode* broken_end = nullptr;\n-#endif\n-  file->_tree.visit_in_order([&](VMATree::TreapNode* current) {\n-    if (prev == nullptr) {\n-      \/\/ Must be first node.\n-      prev = current;\n-      return;\n-    }\n-#ifdef ASSERT\n-    if (broken_start != nullptr && prev->val().out.mem_tag() != current->val().in.mem_tag()) {\n-      broken_start = prev;\n-      broken_end = current;\n-    }\n-#endif\n-    if (prev->val().out.type() == VMATree::StateType::Committed) {\n-      const VMATree::position& start_addr = prev->key();\n-      const VMATree::position& end_addr = current->key();\n-      stream->print_cr(\"[\" PTR_FORMAT \" - \" PTR_FORMAT \"] allocated %zu%s\" \" for %s from\",\n-                       start_addr, end_addr,\n-                       NMTUtil::amount_in_scale(end_addr - start_addr, scale),\n-                       NMTUtil::scale_name(scale),\n-                       NMTUtil::tag_to_name(prev->val().out.mem_tag()));\n-      {\n-        streamIndentor si(stream, 4);\n-        _stack_storage.get(prev->val().out.stack()).print_on(stream);\n-      }\n-      stream->cr();\n-    }\n-    prev = current;\n-  });\n-#ifdef ASSERT\n-  if (broken_start != nullptr) {\n-    tty->print_cr(\"Broken tree found with first occurrence at nodes %zu, %zu\",\n-                  broken_start->key(), broken_end->key());\n-    tty->print_cr(\"Expected start out to have same type as end in, but was: %s, %s\",\n-                  VMATree::statetype_to_string(broken_start->val().out.type()),\n-                  VMATree::statetype_to_string(broken_end->val().in.type()));\n-  }\n-#endif\n-}\n-\n-MemoryFileTracker::MemoryFile* MemoryFileTracker::make_file(const char* descriptive_name) {\n-  MemoryFile* file_place = new MemoryFile{descriptive_name};\n-  _files.push(file_place);\n-  return file_place;\n-}\n-\n-void MemoryFileTracker::free_file(MemoryFile* file) {\n-  if (file == nullptr) return;\n-  _files.remove(file);\n-  delete file;\n-}\n-\n-const GrowableArrayCHeap<MemoryFileTracker::MemoryFile*, mtNMT>& MemoryFileTracker::files() {\n-  return _files;\n-}\n-\n-bool MemoryFileTracker::Instance::initialize(NMT_TrackingLevel tracking_level) {\n-  if (tracking_level == NMT_TrackingLevel::NMT_off) return true;\n-  _tracker = static_cast<MemoryFileTracker*>(os::malloc(sizeof(MemoryFileTracker), mtNMT));\n-  if (_tracker == nullptr) return false;\n-  new (_tracker) MemoryFileTracker(tracking_level == NMT_TrackingLevel::NMT_detail);\n-  return true;\n-}\n-\n-void MemoryFileTracker::Instance::allocate_memory(MemoryFile* file, size_t offset,\n-                                                  size_t size, const NativeCallStack& stack,\n-                                                  MemTag mem_tag) {\n-  _tracker->allocate_memory(file, offset, size, stack, mem_tag);\n-}\n-\n-void MemoryFileTracker::Instance::free_memory(MemoryFile* file, size_t offset, size_t size) {\n-  _tracker->free_memory(file, offset, size);\n-}\n-\n-MemoryFileTracker::MemoryFile*\n-MemoryFileTracker::Instance::make_file(const char* descriptive_name) {\n-  return _tracker->make_file(descriptive_name);\n-}\n-\n-void MemoryFileTracker::Instance::free_file(MemoryFileTracker::MemoryFile* file) {\n-  return _tracker->free_file(file);\n-}\n-\n-void MemoryFileTracker::Instance::print_report_on(const MemoryFile* file,\n-                                                  outputStream* stream, size_t scale) {\n-  assert(file != nullptr, \"must be\");\n-  assert(stream != nullptr, \"must be\");\n-  _tracker->print_report_on(file, stream, scale);\n-}\n-\n-void MemoryFileTracker::Instance::print_all_reports_on(outputStream* stream, size_t scale) {\n-  const GrowableArrayCHeap<MemoryFileTracker::MemoryFile*, mtNMT>& files =\n-      MemoryFileTracker::Instance::files();\n-  stream->cr();\n-  stream->print_cr(\"Memory file details\");\n-  stream->cr();\n-  for (int i = 0; i < files.length(); i++) {\n-    MemoryFileTracker::MemoryFile* file = files.at(i);\n-    MemoryFileTracker::Instance::print_report_on(file, stream, scale);\n-  }\n-}\n-\n-const GrowableArrayCHeap<MemoryFileTracker::MemoryFile*, mtNMT>& MemoryFileTracker::Instance::files() {\n-  return _tracker->files();\n-};\n-\n-void MemoryFileTracker::summary_snapshot(VirtualMemorySnapshot* snapshot) const {\n-  iterate_summary([&](MemTag tag, const VirtualMemory* current) {\n-    VirtualMemory* snap = snapshot->by_tag(tag);\n-    \/\/ Only account the committed memory.\n-    snap->commit_memory(current->committed());\n-  });\n-}\n-\n-void MemoryFileTracker::Instance::summary_snapshot(VirtualMemorySnapshot* snapshot) {\n-  _tracker->summary_snapshot(snapshot);\n-}\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/nativeMemoryFileTracker.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n+#include \"nmt\/vmatree.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+NativeMemoryFileTracker* NativeMemoryFileTracker::Instance::_tracker = nullptr;\n+\n+NativeMemoryFileTracker::NativeMemoryFileTracker(bool is_detailed_mode)\n+  : _stack_storage(is_detailed_mode), _files() {}\n+\n+void NativeMemoryFileTracker::allocate_memory(MemoryFile* file, size_t offset,\n+                                        size_t size, const NativeCallStack& stack,\n+                                        MemTag mem_tag) {\n+  NativeCallStackStorage::StackIndex sidx = _stack_storage.push(stack);\n+  VMATree::RegionData regiondata(sidx, mem_tag);\n+  VMATree::SummaryDiff diff = file->_tree.commit_mapping(offset, size, regiondata);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    VirtualMemory* summary = file->_summary.by_tag(NMTUtil::index_to_tag(i));\n+    summary->reserve_memory(diff.tag[i].commit);\n+    summary->commit_memory(diff.tag[i].commit);\n+  }\n+}\n+\n+void NativeMemoryFileTracker::free_memory(MemoryFile* file, size_t offset, size_t size) {\n+  VMATree::SummaryDiff diff = file->_tree.release_mapping(offset, size);\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    VirtualMemory* summary = file->_summary.by_tag(NMTUtil::index_to_tag(i));\n+    summary->reserve_memory(diff.tag[i].commit);\n+    summary->commit_memory(diff.tag[i].commit);\n+  }\n+}\n+\n+void NativeMemoryFileTracker::print_report_on(const MemoryFile* file, outputStream* stream, size_t scale) {\n+  assert(MemTracker::tracking_level() == NMT_detail, \"must\");\n+\n+  stream->print_cr(\"Memory map of %s\", file->_descriptive_name);\n+  stream->cr();\n+  VMATree::TreapNode* prev = nullptr;\n+#ifdef ASSERT\n+  VMATree::TreapNode* broken_start = nullptr;\n+  VMATree::TreapNode* broken_end = nullptr;\n+#endif\n+  file->_tree.visit_in_order([&](VMATree::TreapNode* current) {\n+    if (prev == nullptr) {\n+      \/\/ Must be first node.\n+      prev = current;\n+      return;\n+    }\n+#ifdef ASSERT\n+    if (broken_start != nullptr && prev->val().out.mem_tag() != current->val().in.mem_tag()) {\n+      broken_start = prev;\n+      broken_end = current;\n+    }\n+#endif\n+    if (prev->val().out.type() == VMATree::StateType::Committed) {\n+      const VMATree::position& start_addr = prev->key();\n+      const VMATree::position& end_addr = current->key();\n+      stream->print_cr(\"[\" PTR_FORMAT \" - \" PTR_FORMAT \"] allocated %zu%s\" \" for %s from\",\n+                       start_addr, end_addr,\n+                       NMTUtil::amount_in_scale(end_addr - start_addr, scale),\n+                       NMTUtil::scale_name(scale),\n+                       NMTUtil::tag_to_name(prev->val().out.mem_tag()));\n+      {\n+        streamIndentor si(stream, 4);\n+        _stack_storage.get(prev->val().out.stack()).print_on(stream);\n+      }\n+      stream->cr();\n+    }\n+    prev = current;\n+  });\n+#ifdef ASSERT\n+  if (broken_start != nullptr) {\n+    tty->print_cr(\"Broken tree found with first occurrence at nodes %zu, %zu\",\n+                  broken_start->key(), broken_end->key());\n+    tty->print_cr(\"Expected start out to have same type as end in, but was: %s, %s\",\n+                  VMATree::statetype_to_string(broken_start->val().out.type()),\n+                  VMATree::statetype_to_string(broken_end->val().in.type()));\n+  }\n+#endif\n+}\n+\n+NativeMemoryFileTracker::MemoryFile* NativeMemoryFileTracker::make_file(const char* descriptive_name) {\n+  MemoryFile* file_place = new MemoryFile{descriptive_name};\n+  _files.push(file_place);\n+  return file_place;\n+}\n+\n+void NativeMemoryFileTracker::free_file(MemoryFile* file) {\n+  if (file == nullptr) return;\n+  _files.remove(file);\n+  delete file;\n+}\n+\n+const GrowableArrayCHeap<NativeMemoryFileTracker::MemoryFile*, mtNMT>& NativeMemoryFileTracker::files() {\n+  return _files;\n+}\n+\n+bool NativeMemoryFileTracker::Instance::initialize(NMT_TrackingLevel tracking_level) {\n+  if (tracking_level == NMT_TrackingLevel::NMT_off) return true;\n+  _tracker = static_cast<NativeMemoryFileTracker*>(os::malloc(sizeof(NativeMemoryFileTracker), mtNMT));\n+  if (_tracker == nullptr) return false;\n+  new (_tracker) NativeMemoryFileTracker(tracking_level == NMT_TrackingLevel::NMT_detail);\n+  return true;\n+}\n+\n+void NativeMemoryFileTracker::Instance::allocate_memory(MemoryFile* file, size_t offset,\n+                                                  size_t size, const NativeCallStack& stack,\n+                                                  MemTag mem_tag) {\n+  _tracker->allocate_memory(file, offset, size, stack, mem_tag);\n+}\n+\n+void NativeMemoryFileTracker::Instance::free_memory(MemoryFile* file, size_t offset, size_t size) {\n+  _tracker->free_memory(file, offset, size);\n+}\n+\n+NativeMemoryFileTracker::MemoryFile*\n+NativeMemoryFileTracker::Instance::make_file(const char* descriptive_name) {\n+  return _tracker->make_file(descriptive_name);\n+}\n+\n+void NativeMemoryFileTracker::Instance::free_file(NativeMemoryFileTracker::MemoryFile* file) {\n+  return _tracker->free_file(file);\n+}\n+\n+void NativeMemoryFileTracker::Instance::print_report_on(const MemoryFile* file,\n+                                                  outputStream* stream, size_t scale) {\n+  assert(file != nullptr, \"must be\");\n+  assert(stream != nullptr, \"must be\");\n+  _tracker->print_report_on(file, stream, scale);\n+}\n+\n+void NativeMemoryFileTracker::Instance::print_all_reports_on(outputStream* stream, size_t scale) {\n+  const GrowableArrayCHeap<NativeMemoryFileTracker::MemoryFile*, mtNMT>& files =\n+      NativeMemoryFileTracker::Instance::files();\n+  stream->cr();\n+  stream->print_cr(\"Memory file details\");\n+  stream->cr();\n+  for (int i = 0; i < files.length(); i++) {\n+    NativeMemoryFileTracker::MemoryFile* file = files.at(i);\n+    NativeMemoryFileTracker::Instance::print_report_on(file, stream, scale);\n+  }\n+}\n+\n+const GrowableArrayCHeap<NativeMemoryFileTracker::MemoryFile*, mtNMT>& NativeMemoryFileTracker::Instance::files() {\n+  return _tracker->files();\n+};\n+\n+void NativeMemoryFileTracker::summary_snapshot(VirtualMemorySnapshot* snapshot) const {\n+  iterate_summary([&](MemTag tag, const VirtualMemory* current) {\n+    VirtualMemory* snap = snapshot->by_tag(tag);\n+    \/\/ Only account the committed memory.\n+    snap->commit_memory(current->committed());\n+  });\n+}\n+\n+void NativeMemoryFileTracker::Instance::summary_snapshot(VirtualMemorySnapshot* snapshot) {\n+  _tracker->summary_snapshot(snapshot);\n+}\n","filename":"src\/hotspot\/share\/nmt\/nativeMemoryFileTracker.cpp","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_NMT_MEMORYFILETRACKER_HPP\n-#define SHARE_NMT_MEMORYFILETRACKER_HPP\n+#ifndef SHARE_NMT_NATIVEMEMORYFILETRACKER_HPP\n+#define SHARE_NMT_NATIVEMEMORYFILETRACKER_HPP\n@@ -43,1 +43,1 @@\n-class MemoryFileTracker {\n+class NativeMemoryFileTracker {\n@@ -51,2 +51,2 @@\n-    friend MemoryFileTracker;\n-    friend class NMTMemoryFileTrackerTest;\n+    friend NativeMemoryFileTracker;\n+    friend class NMTNativeMemoryFileTrackerTest;\n@@ -67,1 +67,1 @@\n-  MemoryFileTracker(bool is_detailed_mode);\n+  NativeMemoryFileTracker(bool is_detailed_mode);\n@@ -94,1 +94,1 @@\n-    static MemoryFileTracker* _tracker;\n+    static NativeMemoryFileTracker* _tracker;\n@@ -121,1 +121,1 @@\n-#endif \/\/ SHARE_NMT_MEMORYFILETRACKER_HPP\n+#endif \/\/ SHARE_NMT_NATIVEMEMORYFILETRACKER_HPP\n","filename":"src\/hotspot\/share\/nmt\/nativeMemoryFileTracker.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n+#include \"nmt\/nativeMemoryFileTracker.hpp\"\n@@ -95,2 +95,2 @@\n-  { \/\/ MemoryFileTracker addition\n-    using MFT = MemoryFileTracker::Instance;\n+  { \/\/ NativeMemoryFileTracker addition\n+    using NMFT = NativeMemoryFileTracker::Instance;\n@@ -98,1 +98,1 @@\n-    MFT::iterate_summary([&](MemTag tag, const VirtualMemory* vm) {\n+    NMFT::iterate_summary([&](MemTag tag, const VirtualMemory* vm) {\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"unittest.hpp\"\n-\n-class NMTMemoryFileTrackerTest : public testing::Test {\n-public:\n-  size_t sz(int x) { return (size_t) x; }\n-  void basics() {\n-    MemoryFileTracker tracker(false);\n-    MemoryFileTracker::MemoryFile* file = tracker.make_file(\"test\");\n-    tracker.allocate_memory(file, 0, 100, CALLER_PC, mtTest);\n-    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(100));\n-    tracker.allocate_memory(file, 100, 100, CALLER_PC, mtTest);\n-    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(200));\n-    tracker.allocate_memory(file, 200, 100, CALLER_PC, mtTest);\n-    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(300));\n-    tracker.free_memory(file, 0, 300);\n-    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(0));\n-    tracker.allocate_memory(file, 0, 100, CALLER_PC, mtTest);\n-    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(100));\n-    tracker.free_memory(file, 50, 10);\n-    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(90));\n-  };\n-};\n-\n-TEST_VM_F(NMTMemoryFileTrackerTest, Basics) {\n-  this->basics();\n-}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_memoryfiletracker.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"unittest.hpp\"\n+\n+class NMTNativeMemoryFileTrackerTest : public testing::Test {\n+public:\n+  size_t sz(int x) { return (size_t) x; }\n+  void basics() {\n+    NativeMemoryFileTracker tracker(false);\n+    NativeMemoryFileTracker::MemoryFile* file = tracker.make_file(\"test\");\n+    tracker.allocate_memory(file, 0, 100, CALLER_PC, mtTest);\n+    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(100));\n+    tracker.allocate_memory(file, 100, 100, CALLER_PC, mtTest);\n+    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(200));\n+    tracker.allocate_memory(file, 200, 100, CALLER_PC, mtTest);\n+    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(300));\n+    tracker.free_memory(file, 0, 300);\n+    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(0));\n+    tracker.allocate_memory(file, 0, 100, CALLER_PC, mtTest);\n+    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(100));\n+    tracker.free_memory(file, 50, 10);\n+    EXPECT_EQ(file->_summary.by_tag(mtTest)->committed(), sz(90));\n+  };\n+};\n+\n+TEST_VM_F(NMTNativeMemoryFileTrackerTest, Basics) {\n+  this->basics();\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_nativememoryfiletracker.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"}]}