{"files":[{"patch":"@@ -1847,0 +1847,4 @@\n+         * For comparison, the prefix length is at most\n+         *       23 for BINARY_16_IX (Float16, once integrated in java.base)\n+         *      114 for BINARY_32_IX (float)\n+         *      769 for BINARY_64_IX (double)\n@@ -1864,1 +1868,1 @@\n-        \/* Determine whether we are facing a symbolic value or hex notation.\n+        \/*\n@@ -1869,0 +1873,2 @@\n+         *\n+         * Determine whether we are facing a symbolic value or hex notation.\n@@ -1930,1 +1936,1 @@\n-            \/* Scan the exponent digits. Accumulate in ep, 10^12 means too large. *\/\n+            \/* Scan the exponent digits. Accumulate in ep, clamping at 10^10. *\/\n@@ -1942,1 +1948,4 @@\n-        \/* |ep| < 10^12, or |ep| = 10^12 when too large. *\/\n+        \/*\n+         * |ep| < 10^10, or |ep| = 10^10 when considered \"large\".\n+         * A \"large\" ep either generates a zero or an infinity.\n+         *\/\n@@ -2017,11 +2026,1 @@\n-         * |ep| < 10^13\n-         *\n-         * For decimal input, the magnitude x of the input meets\n-         *      x = f 10^ep\n-         * where integer f = <f_1 ... f_n> consists of the n digits found\n-         * in the portion [lz, tnz) of the input, and f_1 != 0, f_n != 0.\n-\n-         * For hexadecimal input, the magnitude x of the input meets\n-         *      x = f 2^ep\n-         * where integer f = <f_1 ... f_n> consists of the n hex digits found\n-         * in the portion [lz, tnz) of the input, and f_1 != 0, f_n != 0.\n+         * |ep| < 10^11\n@@ -2029,20 +2028,5 @@\n-         * According to IEEE 754-2019, a finite positive binary floating-point\n-         * of precision P is expressed as\n-         *      c 2^q\n-         * where integers c and q meet\n-         *      Q_MIN <= q <= Q_MAX\n-         *      either      2^(P-1) <= c < 2^P  (normal)\n-         *      or          0 < c < 2^(P-1)  &  q = Q_MIN  (subnormal)\n-         *      c = <d_0 d_1 ... d_(P-1)>, d_i in [0, 2)\n-         * Such a representation is unique.\n-         * Equivalently, the fp value can be expressed as\n-         *      m 2^ep\n-         * where integer ep and real f meet\n-         *      ep = q + P - 1\n-         *      m = c 2^(1-P)\n-         * Hence,\n-         *      E_MIN = Q_MIN + P - 1, E_MAX = Q_MAX + P - 1,\n-         *      1 <= m < 2      (normal)\n-         *      m < 1           (subnormal)\n-         *      m = <d_0 . d_1 ... d_(P-1)>\n-         * with a (binary) point between d_0 and d_1\n+         * The magnitude x of the input meets\n+         *      x = f 10^ep  (decimal)\n+         *      x = f 2^ep  (hexadecimal)\n+         * Integer f = <f_1 ... f_n> consists of the n decimal or hexadecimal\n+         * digits found in part [lz, tnz) of the input, and f_1 != 0, f_n != 0.\n@@ -2068,1 +2052,1 @@\n-                c |= 0b1;\n+                c |= 0b1;  \/\/ force a sticky bit\n@@ -2122,4 +2106,0 @@\n-         * Let x be the magnitude of the decimal in the input in, so\n-         *      x = f 10^ep\n-         * where integer f = <f_1 ... f_n> consists of the n digits found\n-         * in the portion [lz, tnz) of the input, and f_1 != 0, f_n != 0.\n@@ -2133,2 +2113,0 @@\n-         *\n-         * |e'| < 10^14\n@@ -2171,1 +2149,2 @@\n-         * These are the boundaries of the rounding intervals.\n+         * These are the boundaries of the rounding intervals and are key for\n+         * correct rounding.\n@@ -2175,1 +2154,1 @@\n-         * Hence, to correctly round x it's enough to retain its integer part,\n+         * Hence, to correctly round x, it's enough to retain its integer part,\n@@ -2186,2 +2165,2 @@\n-         * The boundaries (c + 1\/2) 2^q have a fractional part consisting of\n-         * 1 - q digits (the rightmost one is always a 5).\n+         * The boundaries (c + 1\/2) 2^q = (2c + 1) 2^(q-1) have a fractional part\n+         * of 1 - q digits: some (or zero) leading zeros, the rightmost is 5.\n@@ -2190,1 +2169,4 @@\n-         * the rest (tail) of the fractional part is non-zero.\n+         * the rest of the fractional part beyond the 1 - q digits is non-zero.\n+         * (Again, the sticky digit is only needed when the digit in f at the\n+         * same position as the last 5 of the rounding boundary is 5 as well.\n+         * But let's keep it simple for now.)\n@@ -2273,4 +2255,1 @@\n-    \/*\n-     * Arithmetically \"appends the digit\" ch to v >= 0, up to 10^12.\n-     * Returns 10^12 on overflow, and keeps returning it on subsequent invocations.\n-     *\/\n+    \/* Arithmetically \"appends the digit\" ch to v >= 0, clamping at 10^10. *\/\n@@ -2278,1 +2257,1 @@\n-        return v < 1_000_000_000_000L \/ 10 ? 10 * v + (ch - '0') : 1_000_000_000_000L;\n+        return v < 10_000_000_000L \/ 10 ? 10 * v + (ch - '0') : 10_000_000_000L;\n@@ -2299,3 +2278,1 @@\n-        while (i < len && in.charAt(i) <= ' ') {\n-            ++i;\n-        }\n+        for (; i < len && in.charAt(i) <= ' '; ++i);  \/\/ empty body\n@@ -2306,1 +2283,1 @@\n-     * Attempts to scan sub and opt trailing whitespaces, starting at index i.\n+     * Attempts to scan sub and optional trailing whitespaces, starting at index i.\n@@ -2310,1 +2287,1 @@\n-        int high = i + sub.length();  \/\/ might overflow, checked below\n+        int high = i + sub.length();  \/\/ might overflow, checked in next line\n@@ -2329,0 +2306,2 @@\n+    private static final int L_HALF = (MAX_OUT - OMITTED.length()) \/ 2;\n+    private static final int R_HALF = MAX_OUT - (L_HALF + OMITTED.length());\n@@ -2330,2 +2309,2 @@\n-    private static void check(String in, boolean b) {\n-        if (!b) {\n+    private static void check(String in, boolean expected) {\n+        if (!expected) {\n@@ -2334,4 +2313,1 @@\n-                int halfish = (MAX_OUT - OMITTED.length()) \/ 2;\n-                in = in.substring(0, halfish)\n-                        + OMITTED\n-                        + in.substring(len - (MAX_OUT - OMITTED.length() - halfish));\n+                in = in.substring(0, L_HALF) + OMITTED + in.substring(len - R_HALF);\n@@ -2343,0 +2319,23 @@\n+    \/*\n+     * According to IEEE 754-2019, a finite positive binary floating-point\n+     * of precision P is (uniquely) expressed as\n+     *      c 2^q\n+     * where integers c and q meet\n+     *      Q_MIN <= q <= Q_MAX\n+     *      either      2^(P-1) <= c < 2^P  (normal)\n+     *      or          0 < c < 2^(P-1)  &  q = Q_MIN  (subnormal)\n+     *      c = <d_0 d_1 ... d_(P-1)>, d_i in [0, 2)\n+     *\n+     * Equivalently, the fp value can be (uniquely) expressed as\n+     *      m 2^ep\n+     * where integer ep and real f meet\n+     *      ep = q + P - 1\n+     *      m = c 2^(1-P)\n+     * Hence,\n+     *      E_MIN = Q_MIN + P - 1, E_MAX = Q_MAX + P - 1,\n+     *      1 <= m < 2      (normal)\n+     *      m < 1           (subnormal)\n+     *      m = <d_0 . d_1 ... d_(P-1)>\n+     * with a (binary) point between d_0 and d_1\n+     *\/\n+\n@@ -2387,9 +2386,0 @@\n-    \/* Minimum exponent in the m 2^e representation. *\/\n-    private static final int[] E_MIN = {\n-            (-1 << W[BINARY_16_IX] - 1) + 2,\n-            (-1 << W[BINARY_32_IX] - 1) + 2,\n-            (-1 << W[BINARY_64_IX] - 1) + 2,\n-\/\/            (-1 << W[BINARY_128_IX] - 1) + 2,\n-\/\/            (-1 << W[BINARY_256_IX] - 1) + 2,\n-    };\n-\n@@ -2405,0 +2395,9 @@\n+    \/* Minimum exponent in the m 2^e representation. *\/\n+    private static final int[] E_MIN = {\n+            1 - E_MAX[BINARY_16_IX],\n+            1 - E_MAX[BINARY_32_IX],\n+            1 - E_MAX[BINARY_64_IX],\n+\/\/            1 - E_MAX[BINARY_128_IX],\n+\/\/            1 - E_MAX[BINARY_256_IX],\n+    };\n+\n@@ -2407,5 +2406,5 @@\n-            E_MIN[BINARY_16_IX] - P[BINARY_16_IX] + 1,\n-            E_MIN[BINARY_32_IX] - P[BINARY_32_IX] + 1,\n-            E_MIN[BINARY_64_IX] - P[BINARY_64_IX] + 1,\n-\/\/            E_MIN[BINARY_128_IX] - P[BINARY_128_IX] + 1,\n-\/\/            E_MIN[BINARY_256_IX] - P[BINARY_256_IX] + 1,\n+            E_MIN[BINARY_16_IX] - (P[BINARY_16_IX] - 1),\n+            E_MIN[BINARY_32_IX] - (P[BINARY_32_IX] - 1),\n+            E_MIN[BINARY_64_IX] - (P[BINARY_64_IX] - 1),\n+\/\/            E_MIN[BINARY_128_IX] - (P[BINARY_128_IX] - 1),\n+\/\/            E_MIN[BINARY_256_IX] - (P[BINARY_256_IX] - 1),\n@@ -2415,3 +2414,2 @@\n-     * HEX_COUNT = maximum number of hex digits required to host P +1 rounding\n-     * bit +1 sticky bit = P + 2 adjacent one bits with arbitrary alignment.\n-     * HEX_COUNT = floor(P\/4) + 2\n+     * The most significant P +1 rounding bit +1 sticky bit = P + 2 bits in a\n+     * hexadecimal string need up to HEX_COUNT = floor(P\/4) + 2 hex digits.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":77,"deletions":79,"binary":false,"changes":156,"status":"modified"}]}