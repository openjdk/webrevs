{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+#include \"path_util.h\"\n@@ -80,0 +81,33 @@\n+\/*\n+ * remove repeated path separators ('\/') in the giving 'path'.\n+ *\/\n+static void\n+removeDuplicateSlashes(char* path)\n+{\n+    char *left = path;\n+    char *right = path;\n+    char *end = path + strlen(path);\n+    \/*\n+     * Find first '\/\/'\n+     *\/\n+    for (; right < end; right++) {\n+        if (*right == '\/' && *(right + 1) == '\/') break;\n+    }\n+\n+    for (left = right; right < end; right++) {\n+        \/\/ Skip sequence of multiple path-separators.\n+        while (*right == '\/' && *(right + 1) == '\/') {\n+            right++;\n+        }\n+\n+        while (*right != '\\0' && !(*right == '\/' && *(right + 1) == '\/')) {\n+            *left++ = *right++;\n+        }\n+\n+        if (*right == '\\0') {\n+            *left = '\\0';\n+            break;\n+        }\n+    }\n+}\n+\n@@ -299,0 +333,2 @@\n+        removeDuplicateSlashes(linkbuf);\n+        collapse(linkbuf);\n","filename":"src\/java.base\/unix\/native\/libjava\/TimeZone_md.c","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,0 @@\n-#if !defined(_ALLBSD_SOURCE)\n-#include <alloca.h>\n-#endif\n@@ -41,0 +38,1 @@\n+#include \"path_util.h\"\n@@ -45,140 +43,0 @@\n-\n-\/* Check the given name sequence to see if it can be further collapsed.\n-   Return zero if not, otherwise return the number of names in the sequence. *\/\n-\n-static int\n-collapsible(char *names)\n-{\n-    char *p = names;\n-    int dots = 0, n = 0;\n-\n-    while (*p) {\n-        if ((p[0] == '.') && ((p[1] == '\\0')\n-                              || (p[1] == '\/')\n-                              || ((p[1] == '.') && ((p[2] == '\\0')\n-                                                    || (p[2] == '\/'))))) {\n-            dots = 1;\n-        }\n-        n++;\n-        while (*p) {\n-            if (*p == '\/') {\n-                p++;\n-                break;\n-            }\n-            p++;\n-        }\n-    }\n-    return (dots ? n : 0);\n-}\n-\n-\n-\/* Split the names in the given name sequence,\n-   replacing slashes with nulls and filling in the given index array *\/\n-\n-static void\n-splitNames(char *names, char **ix)\n-{\n-    char *p = names;\n-    int i = 0;\n-\n-    while (*p) {\n-        ix[i++] = p++;\n-        while (*p) {\n-            if (*p == '\/') {\n-                *p++ = '\\0';\n-                break;\n-            }\n-            p++;\n-        }\n-    }\n-}\n-\n-\n-\/* Join the names in the given name sequence, ignoring names whose index\n-   entries have been cleared and replacing nulls with slashes as needed *\/\n-\n-static void\n-joinNames(char *names, int nc, char **ix)\n-{\n-    int i;\n-    char *p;\n-\n-    for (i = 0, p = names; i < nc; i++) {\n-        if (!ix[i]) continue;\n-        if (i > 0) {\n-            p[-1] = '\/';\n-        }\n-        if (p == ix[i]) {\n-            p += strlen(p) + 1;\n-        } else {\n-            char *q = ix[i];\n-            while ((*p++ = *q++));\n-        }\n-    }\n-    *p = '\\0';\n-}\n-\n-\n-\/* Collapse \".\" and \"..\" names in the given path wherever possible.\n-   A \".\" name may always be eliminated; a \"..\" name may be eliminated if it\n-   follows a name that is neither \".\" nor \"..\".  This is a syntactic operation\n-   that performs no filesystem queries, so it should only be used to cleanup\n-   after invoking the realpath() procedure. *\/\n-\n-static void\n-collapse(char *path)\n-{\n-    char *names = (path[0] == '\/') ? path + 1 : path; \/* Preserve first '\/' *\/\n-    int nc;\n-    char **ix;\n-    int i, j;\n-    char *p, *q;\n-\n-    nc = collapsible(names);\n-    if (nc < 2) return;         \/* Nothing to do *\/\n-    ix = (char **)alloca(nc * sizeof(char *));\n-    splitNames(names, ix);\n-\n-    for (i = 0; i < nc; i++) {\n-        int dots = 0;\n-\n-        \/* Find next occurrence of \".\" or \"..\" *\/\n-        do {\n-            char *p = ix[i];\n-            if (p[0] == '.') {\n-                if (p[1] == '\\0') {\n-                    dots = 1;\n-                    break;\n-                }\n-                if ((p[1] == '.') && (p[2] == '\\0')) {\n-                    dots = 2;\n-                    break;\n-                }\n-            }\n-            i++;\n-        } while (i < nc);\n-        if (i >= nc) break;\n-\n-        \/* At this point i is the index of either a \".\" or a \"..\", so take the\n-           appropriate action and then continue the outer loop *\/\n-        if (dots == 1) {\n-            \/* Remove this instance of \".\" *\/\n-            ix[i] = 0;\n-        }\n-        else {\n-            \/* If there is a preceding name, remove both that name and this\n-               instance of \"..\"; otherwise, leave the \"..\" as is *\/\n-            for (j = i - 1; j >= 0; j--) {\n-                if (ix[j]) break;\n-            }\n-            if (j < 0) continue;\n-            ix[j] = 0;\n-            ix[i] = 0;\n-        }\n-        \/* i will be incremented at the top of the loop *\/\n-    }\n-\n-    joinNames(names, nc, ix);\n-}\n-\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/canonicalize_md.c","additions":2,"deletions":144,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#if !defined(_ALLBSD_SOURCE)\n+#include <alloca.h>\n+#endif\n+\n+#include \"path_util.h\"\n+\n+\/* Check the given name sequence to see if it can be further collapsed.\n+   Return zero if not, otherwise return the number of names in the sequence. *\/\n+\n+static int\n+collapsible(char *names)\n+{\n+    char *p = names;\n+    int dots = 0, n = 0;\n+\n+    while (*p) {\n+        if ((p[0] == '.') && ((p[1] == '\\0')\n+                              || (p[1] == '\/')\n+                              || ((p[1] == '.') && ((p[2] == '\\0')\n+                                                    || (p[2] == '\/'))))) {\n+            dots = 1;\n+        }\n+        n++;\n+        while (*p) {\n+            if (*p == '\/') {\n+                p++;\n+                break;\n+            }\n+            p++;\n+        }\n+    }\n+    return (dots ? n : 0);\n+}\n+\n+\n+\/* Split the names in the given name sequence,\n+   replacing slashes with nulls and filling in the given index array *\/\n+\n+static void\n+splitNames(char *names, char **ix)\n+{\n+    char *p = names;\n+    int i = 0;\n+\n+    while (*p) {\n+        ix[i++] = p++;\n+        while (*p) {\n+            if (*p == '\/') {\n+                *p++ = '\\0';\n+                break;\n+            }\n+            p++;\n+        }\n+    }\n+}\n+\n+\n+\/* Join the names in the given name sequence, ignoring names whose index\n+   entries have been cleared and replacing nulls with slashes as needed *\/\n+\n+static void\n+joinNames(char *names, int nc, char **ix)\n+{\n+    int i;\n+    char *p;\n+\n+    for (i = 0, p = names; i < nc; i++) {\n+        if (!ix[i]) continue;\n+        if (i > 0) {\n+            p[-1] = '\/';\n+        }\n+        if (p == ix[i]) {\n+            p += strlen(p) + 1;\n+        } else {\n+            char *q = ix[i];\n+            while ((*p++ = *q++));\n+        }\n+    }\n+    *p = '\\0';\n+}\n+\n+\/* Collapse \".\" and \"..\" names in the given path wherever possible.\n+   A \".\" name may always be eliminated; a \"..\" name may be eliminated if it\n+   follows a name that is neither \".\" nor \"..\".  This is a syntactic operation\n+   that performs no filesystem queries, so it should only be used to cleanup\n+   after invoking the realpath() procedure. *\/\n+\n+void\n+collapse(char *path)\n+{\n+    char *names = (path[0] == '\/') ? path + 1 : path; \/* Preserve first '\/' *\/\n+    int nc;\n+    char **ix;\n+    int i, j;\n+    char *p, *q;\n+\n+    nc = collapsible(names);\n+    if (nc < 2) return;         \/* Nothing to do *\/\n+    ix = (char **)alloca(nc * sizeof(char *));\n+    splitNames(names, ix);\n+\n+    for (i = 0; i < nc; i++) {\n+        int dots = 0;\n+\n+        \/* Find next occurrence of \".\" or \"..\" *\/\n+        do {\n+            char *p = ix[i];\n+            if (p[0] == '.') {\n+                if (p[1] == '\\0') {\n+                    dots = 1;\n+                    break;\n+                }\n+                if ((p[1] == '.') && (p[2] == '\\0')) {\n+                    dots = 2;\n+                    break;\n+                }\n+            }\n+            i++;\n+        } while (i < nc);\n+        if (i >= nc) break;\n+\n+        \/* At this point i is the index of either a \".\" or a \"..\", so take the\n+           appropriate action and then continue the outer loop *\/\n+        if (dots == 1) {\n+            \/* Remove this instance of \".\" *\/\n+            ix[i] = 0;\n+        }\n+        else {\n+            \/* If there is a preceding name, remove both that name and this\n+               instance of \"..\"; otherwise, leave the \"..\" as is *\/\n+            for (j = i - 1; j >= 0; j--) {\n+                if (ix[j]) break;\n+            }\n+            if (j < 0) continue;\n+            ix[j] = 0;\n+            ix[i] = 0;\n+        }\n+        \/* i will be incremented at the top of the loop *\/\n+    }\n+\n+    joinNames(names, nc, ix);\n+}\n","filename":"src\/java.base\/unix\/native\/libjava\/path_util.c","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-package p;\n@@ -27,3 +26,2 @@\n-public class Foo {\n-     protected enum T { ONE }\n-}\n+#ifndef PATH_UTIL_H\n+#define PATH_UTIL_H\n@@ -31,0 +29,3 @@\n+void collapse(char *path);\n+\n+#endif\n","filename":"src\/java.base\/unix\/native\/libjava\/path_util.h","additions":5,"deletions":4,"binary":false,"changes":9,"previous_filename":"test\/jdk\/java\/lang\/invoke\/accessClassAndFindClass\/p\/Foo.java","status":"copied"}]}