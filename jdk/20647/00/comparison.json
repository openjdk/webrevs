{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +32,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -48,1 +50,1 @@\n-    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -56,1 +58,1 @@\n-        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n+        return accessType.accessModeType(MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -100,1 +102,1 @@\n-    static AbstractMemorySegmentImpl checkReadOnly(Object obb, boolean ro) {\n+    static AbstractMemorySegmentImpl checkSegment(Object obb, Object encl, long base, boolean ro) {\n@@ -102,1 +104,1 @@\n-        oo.checkReadOnly(ro);\n+        Utils.checkEnclosingLayout(oo, base, (MemoryLayout)encl, ro);\n@@ -107,1 +109,1 @@\n-    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long base, long offset, long alignmentMask) {\n@@ -111,1 +113,1 @@\n-        return offsetPlain(bb, offset);\n+        return offsetPlain(bb, base, offset);\n@@ -115,3 +117,3 @@\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset) {\n-        long base = bb.unsafeGetOffset();\n-        return base + offset;\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long base, long offset) {\n+        long segment_base = bb.unsafeGetOffset();\n+        return segment_base + base + offset;\n@@ -121,1 +123,1 @@\n-    static $type$ get(VarHandle ob, Object obb, long base) {\n+    static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -123,1 +125,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -127,1 +129,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -134,1 +136,1 @@\n-                offsetPlain(bb, base));\n+                offsetPlain(bb, base, offset));\n@@ -138,1 +140,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -145,1 +147,1 @@\n-    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void set(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -147,1 +149,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -151,1 +153,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -158,1 +160,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -163,1 +165,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -171,1 +173,1 @@\n-    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n+    static $type$ getVolatile(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -173,1 +175,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -177,1 +179,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -181,1 +183,1 @@\n-    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setVolatile(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -183,1 +185,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -186,1 +188,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -191,1 +193,1 @@\n-    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n+    static $type$ getAcquire(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -193,1 +195,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -197,1 +199,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -201,1 +203,1 @@\n-    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -203,1 +205,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -206,1 +208,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -211,1 +213,1 @@\n-    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n+    static $type$ getOpaque(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -213,1 +215,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -217,1 +219,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -221,1 +223,1 @@\n-    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setOpaque(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -223,1 +225,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -226,1 +228,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -232,1 +234,1 @@\n-    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean compareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -234,1 +236,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -237,1 +239,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -242,1 +244,1 @@\n-    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchange(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -244,1 +246,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -248,1 +250,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -253,1 +255,1 @@\n-    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -255,1 +257,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -259,1 +261,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -264,1 +266,1 @@\n-    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -266,1 +268,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -270,1 +272,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -275,1 +277,1 @@\n-    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -277,1 +279,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -280,1 +282,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -285,1 +287,1 @@\n-    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -287,1 +289,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -290,1 +292,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -295,1 +297,1 @@\n-    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -297,1 +299,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -300,1 +302,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -305,1 +307,1 @@\n-    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -307,1 +309,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -310,1 +312,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -315,1 +317,1 @@\n-    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -317,1 +319,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -321,1 +323,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -326,1 +328,1 @@\n-    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -328,1 +330,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -332,1 +334,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -337,1 +339,1 @@\n-    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -339,1 +341,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -343,1 +345,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -350,1 +352,1 @@\n-    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAdd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -352,1 +354,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -356,1 +358,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -359,1 +361,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -364,1 +366,1 @@\n-    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -366,1 +368,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -370,1 +372,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -373,1 +375,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -378,1 +380,1 @@\n-    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -380,1 +382,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -384,1 +386,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -387,1 +389,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -406,1 +408,1 @@\n-    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -408,1 +410,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -412,1 +414,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -415,1 +417,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -420,1 +422,1 @@\n-    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -422,1 +424,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -426,1 +428,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -429,1 +431,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -434,1 +436,1 @@\n-    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -436,1 +438,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -440,1 +442,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -443,1 +445,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -460,1 +462,1 @@\n-    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -462,1 +464,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -466,1 +468,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -469,1 +471,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -474,1 +476,1 @@\n-    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -476,1 +478,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -480,1 +482,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -483,1 +485,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -488,1 +490,1 @@\n-    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -490,1 +492,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -494,1 +496,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -497,1 +499,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -515,1 +517,1 @@\n-    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -517,1 +519,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -521,1 +523,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -524,1 +526,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -529,1 +531,1 @@\n-    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -531,1 +533,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -535,1 +537,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -538,1 +540,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -543,1 +545,1 @@\n-    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -545,1 +547,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -549,1 +551,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -552,1 +554,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":120,"deletions":118,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class));\n@@ -183,2 +183,1 @@\n-        handle = MethodHandles.filterReturnValue(handle,\n-                MethodHandles.insertArguments(MH_SEGMENT_RESIZE, 1, derefLayout));\n+        handle = MethodHandles.filterReturnValue(handle, MH_SEGMENT_RESIZE);\n@@ -188,2 +187,4 @@\n-    private static MemorySegment resizeSegment(MemorySegment segment, MemoryLayout layout) {\n-        return Utils.longToAddress(segment.address(), layout.byteSize(), layout.byteAlignment());\n+    private static MemorySegment resizeSegment(MemorySegment segment) {\n+        \/\/ Avoid adapting for specific target layout. The check for the root layout\n+        \/\/ size and alignment will be inserted by LayoutPath::dereferenceHandle anyway.\n+        return Utils.longToAddress(segment.address(), Long.MAX_VALUE, 1);\n@@ -208,13 +209,9 @@\n-        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);\n-        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n-\n-        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n-        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n-        \/\/ (see Utils::longToAddress)\n-        if (derefAdapters.length == 0) {\n-            \/\/ insert align check for the root layout on the initial MS + offset\n-            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n-            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n-            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n-            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n+        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);              \/\/ (MS, ML, long, long)\n+        handle = MethodHandles.insertCoordinates(handle, 1, rootLayout());          \/\/ (MS, long, long)\n+        if (strides.length > 0) {\n+            MethodHandle offsetAdapter = offsetHandle();\n+            offsetAdapter = MethodHandles.insertArguments(offsetAdapter, 0, 0L);\n+            handle = MethodHandles.collectCoordinates(handle, 2, offsetAdapter);    \/\/ (MS, long)\n+        } else {\n+            \/\/ simpler adaptation\n+            handle = MethodHandles.insertCoordinates(handle, 2, offset);            \/\/ (MS, long)\n@@ -244,0 +241,4 @@\n+        \/\/ note: the below can overflow, depending on 'base'. When constructing var handles\n+        \/\/ through the layout API, this is never the case, as the segment offset is checked\n+        \/\/ against the segment size. But when using 'byteOffsetHandle' this might return a\n+        \/\/ negative value. Seems incompatible also with scale(), which use exact operations.\n@@ -288,6 +289,1 @@\n-        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), true);\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n-                    , offset, enclosing.byteAlignment(), enclosing, segment));\n-        }\n+        Utils.checkEnclosingLayout(segment, offset, enclosing, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n+    private static final MethodHandle LONG_TO_ADDRESS_TARGET;\n+    private static final MethodHandle LONG_TO_ADDRESS_NO_TARGET;\n@@ -77,2 +78,4 @@\n-            LONG_TO_ADDRESS = lookup.findStatic(Utils.class, \"longToAddress\",\n-                    MethodType.methodType(MemorySegment.class, long.class, long.class, long.class));\n+            LONG_TO_ADDRESS_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n+            LONG_TO_ADDRESS_NO_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n@@ -132,5 +135,4 @@\n-            handle = MethodHandles.filterValue(handle,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n-                    MethodHandles.explicitCastArguments(MethodHandles.insertArguments(LONG_TO_ADDRESS, 1,\n-                                    pointeeByteSize(addressLayout), pointeeByteAlign(addressLayout)),\n-                            MethodType.methodType(MemorySegment.class, baseCarrier)));\n+            MethodHandle longToAddressAdapter = addressLayout.targetLayout().isPresent() ?\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS_TARGET, 1, addressLayout) :\n+                    LONG_TO_ADDRESS_NO_TARGET;\n+            handle = MethodHandles.filterValue(handle, ADDRESS_TO_LONG, longToAddressAdapter);\n@@ -149,0 +151,10 @@\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr) {\n+        return longToAddress(addr, 0, 1);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr, AddressLayout layout) {\n+        return longToAddress(addr, pointeeByteSize(layout), pointeeByteAlign(layout));\n+    }\n+\n@@ -232,0 +244,10 @@\n+    @ForceInline\n+    public static void checkEnclosingLayout(MemorySegment segment, long offset, MemoryLayout enclosing, boolean readOnly) {\n+        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), readOnly);\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, enclosing.byteAlignment(), enclosing, segment));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"}]}