{"files":[{"patch":"@@ -432,1 +432,1 @@\n-                    Text whitespace = Text.of(line.substring(0, idx));\n+                    Text whitespace = Text.of(utils.normalizeNewlines(line.substring(0, idx)));\n@@ -441,1 +441,1 @@\n-                    c = HtmlTree.SPAN(Text.of(sequence));\n+                    c = HtmlTree.SPAN(Text.of(utils.normalizeNewlines(sequence)));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -364,0 +364,3 @@\n+doclet.tag.attribute.value.missing=\\\n+ missing value for attribute \"{0}\"\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -87,0 +86,39 @@\n+        try {\n+            return generateContent(holder, tag, writer);\n+        } catch (BadSnippetException e) {\n+            error(writer, holder, e.tag(), e.key(), e.args());\n+            return badSnippet(writer);\n+        }\n+    }\n+\n+    private static final class BadSnippetException extends Exception {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1;\n+\n+        private final transient DocTree tag;\n+        private final String key;\n+        private final transient Object[] args;\n+\n+        BadSnippetException(DocTree tag, String key, Object... args) {\n+            this.tag = tag;\n+            this.key = key;\n+            this.args = args;\n+        }\n+\n+        DocTree tag() {\n+            return tag;\n+        }\n+\n+        String key() {\n+            return key;\n+        }\n+\n+        Object[] args() {\n+            return args;\n+        }\n+    }\n+\n+    private Content generateContent(Element holder, DocTree tag, TagletWriter writer)\n+            throws BadSnippetException\n+    {\n@@ -101,3 +139,2 @@\n-            error(writer, holder, a, \"doclet.tag.attribute.repeated\",\n-                a.getName().toString());\n-            return badSnippet(writer);\n+            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n+                    a.getName().toString());\n@@ -114,3 +151,2 @@\n-            error(writer, holder, attributes.get(CLASS),\n-                \"doclet.snippet.contents.ambiguity.external\");\n-            return badSnippet(writer);\n+            throw new BadSnippetException(attributes.get(CLASS),\n+                    \"doclet.snippet.contents.ambiguity.external\");\n@@ -118,2 +154,1 @@\n-            error(writer, holder, tag, \"doclet.snippet.contents.none\");\n-            return badSnippet(writer);\n+            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n@@ -125,1 +160,1 @@\n-            regionName = stringOf(region.getValue());\n+            regionName = stringValueOf(region);\n@@ -127,3 +162,2 @@\n-                error(writer, holder, region, \"doclet.tag.attribute.value.illegal\",\n-                    \"region\", region.getValue());\n-                return badSnippet(writer);\n+                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n+                        \"region\", region.getValue());\n@@ -144,2 +178,2 @@\n-                ? stringOf((a = attributes.get(FILE)).getValue())\n-                : stringOf((a = attributes.get(CLASS)).getValue()).replace(\".\", \"\/\") + \".java\";\n+                    ? stringValueOf((a = attributes.get(FILE)))\n+                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n@@ -148,2 +182,2 @@\n-                error(writer, holder, a, \"doclet.tag.attribute.value.illegal\",\n-                    containsFile ? FILE : CLASS, v);\n+                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n+                        containsFile ? FILE : CLASS, v);\n@@ -168,1 +202,1 @@\n-            } catch (IOException | IllegalArgumentException e) {\n+            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n@@ -170,2 +204,1 @@\n-                error(writer, holder, a, \"doclet.exception.read.file\", v, e.getCause());\n-                return badSnippet(writer);\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e.getCause());\n@@ -176,2 +209,1 @@\n-                error(writer, holder, a, \"doclet.File_not_found\", v);\n-                return badSnippet(writer);\n+                throw new BadSnippetException(a, \"doclet.File_not_found\", v);\n@@ -182,4 +214,3 @@\n-            } catch (IOException e) {\n-                error(writer, holder, a, \"doclet.exception.read.file\",\n-                    fileObject.getName(), e.getCause());\n-                return badSnippet(writer);\n+            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n+                        fileObject.getName(), e.getCause());\n@@ -200,1 +231,1 @@\n-                .getDocTreePath(snippetTag.getBody());\n+                    .getDocTreePath(snippetTag.getBody());\n@@ -203,1 +234,1 @@\n-                .getText(\"doclet.snippet.markup\", e.getMessage());\n+                    .getText(\"doclet.snippet.markup\", e.getMessage());\n@@ -205,1 +236,1 @@\n-                path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n@@ -216,1 +247,1 @@\n-                e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n@@ -238,2 +269,1 @@\n-                error(writer, holder, tag, \"doclet.snippet.region.not_found\", regionName);\n-                return badSnippet(writer);\n+                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n@@ -255,3 +285,1 @@\n-                error(writer, holder, tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n-                \/\/ output one above the other\n-                return badSnippet(writer);\n+                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n@@ -266,2 +294,2 @@\n-        if (langAttr != null && langAttr.getValueKind() != AttributeTree.ValueKind.EMPTY) {\n-            lang = stringOf(langAttr.getValue());\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n@@ -274,3 +302,3 @@\n-        String id = idAttr == null || idAttr.getValueKind() == AttributeTree.ValueKind.EMPTY\n-                        ? null\n-                        : stringOf(idAttr.getValue());\n+        String id = idAttr == null\n+                ? null\n+                : stringValueOf(idAttr);\n@@ -307,2 +335,6 @@\n-    private static String stringOf(List<? extends DocTree> value) {\n-        return value.stream()\n+    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n+        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n+            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n+                    at.getName().toString());\n+        }\n+        return at.getValue().stream()\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":74,"deletions":42,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n-public \/* sealed *\/ abstract class Attribute {\n+public abstract class Attribute {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,8 +70,0 @@\n-\n-    public int size() {\n-        return attributes.values().stream().mapToInt(List::size).sum();\n-    }\n-\n-    public boolean isEmpty() {\n-        return attributes.isEmpty();\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-                List<Tag> parsedTags = null;\n+                List<Tag> parsedTags;\n@@ -159,1 +159,1 @@\n-                    \/\/ adjust index\n+                    \/\/ translate error position from markup to file line\n@@ -163,1 +163,1 @@\n-                    t.lineSourceOffset = next.offset;\n+                    t.lineSourceOffset = next.offset();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        int off = 0; \/\/ offset because of the replacements (can be negative)\n+        int off = 0; \/\/ cumulative offset caused by replacements (can become negative)\n@@ -82,1 +82,1 @@\n-            text.subText(r.start, r.end).replace(Set.of(), r.value);\n+            text.subText(r.start(), r.end()).replace(Set.of(), r.value());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n-public \/* sealed *\/ interface Style {\n+public sealed interface Style {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.ObjIntConsumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class SnippetTester extends JavadocTester {\n+\n+    protected final ToolBox tb = new ToolBox();\n+\n+    protected void checkOrder(Output output, String... strings) {\n+        new OutputChecker(output).setExpectOrdered(true).check(strings);\n+    }\n+\n+    \/*\n+     * When checking for errors, it is important not to confuse one error with\n+     * another. This method checks that there are no crashes (which are also\n+     * errors) by checking for stack traces. We never expect crashes.\n+     *\/\n+    protected void checkNoCrashes() {\n+        checking(\"check crashes\");\n+        Matcher matcher = Pattern.compile(\"\\\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n+                .matcher(getOutput(Output.STDERR));\n+        if (!matcher.find()) {\n+            passed(\"\");\n+        } else {\n+            failed(\"Looks like a stacktrace: \" + matcher.group());\n+        }\n+    }\n+\n+    \/*\n+     * This is a convenience method to iterate through a list.\n+     * Unlike List.forEach, this method provides the consumer not only with an\n+     * element but also that element's index.\n+     *\n+     * See JDK-8184707.\n+     *\/\n+    protected static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n+        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n+            action.accept(iterator.next(), iterator.previousIndex());\n+        }\n+    }\n+\n+    \/\/ TODO:\n+    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n+    \/\/   see if any of them could be used instead of this one\n+    protected static void addSnippetFile(Path srcDir, String packageName, String fileName, String content)\n+            throws UncheckedIOException\n+    {\n+        String[] components = packageName.split(\"\\\\.\");\n+        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n+        try {\n+            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n+            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    protected void checkOutputEither(Output out, String first, String... other) {\n+        var strings = Stream.concat(Stream.of(first), Stream.of(other))\n+                .toArray(String[]::new);\n+        new OutputChecker(out).checkAnyOf(strings);\n+    }\n+\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content) {\n+        return getSnippetHtmlRepresentation(pathToHtmlFile, content, Optional.empty(), Optional.empty());\n+    }\n+\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content,\n+                                                  Optional<String> lang,\n+                                                  Optional<String> id) {\n+        \/\/ the further away from the root, the further to reach to common resources\n+        int nComponents = (int) pathToHtmlFile.chars().filter(c -> c == '\/').count();\n+        var svgString = \"..\/\".repeat(nComponents) + \"copy.svg\";\n+        var idString = id.isEmpty() ? \"\" : \" id=\\\"%s\\\"\".formatted(id.get());\n+        var langString = lang.isEmpty() ? \"\" : \" class=\\\"language-%s\\\"\".formatted(lang.get());\n+        return \"\"\"\n+                <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet(this)\">\\\n+                <span data-copied=\"Copied!\">Copy<\/span><img src=\"%s\" alt=\"Copy\"><\/button>\n+                <pre class=\"snippet\"%s><code%s>%s<\/code><\/pre>\n+                <\/div>\"\"\".formatted(svgString, idString, langString, content);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/SnippetTester.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,574 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetMarkup\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+\n+import builder.ClassBuilder;\n+import toolbox.ToolBox;\n+\n+import static javax.tools.DocumentationTool.Location.DOCUMENTATION_OUTPUT;\n+\n+public class TestSnippetMarkup extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetMarkup().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+     * The semantics of expectedOutput depends on the test case this record is\n+     * used in.\n+     *\/\n+    record TestCase(String region, String input, String expectedOutput) {\n+        TestCase(String input, String expectedOutput) {\n+            this(\"\", input, expectedOutput);\n+        }\n+    }\n+\n+    \/\/ @highlight [region|region=<name>]\n+    \/\/            [regex=<val>|substring=<val>]\n+    \/\/            [type=bold|italics|highlighted]\n+    \/\/            [:]\n+    @Test\n+    public void testHighlight(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase( \/\/ FIXME: newline should not be included\n+                        \"\"\"\n+                                First line  \/\/ @highlight\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First line\n+                                <\/span>  Second line\n+                                \"\"\"),\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @highlight regex=\"\\\\w\" type=\"bold\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First<\/span> <span class=\"bold\">line<\/span>\n+                                  Second line\n+                                \"\"\"),\n+                new TestCase( \/\/ FIXME: newline should not be included\n+                        \"\"\"\n+                                First line  \/\/ @highlight @highlight regex=\"\\\\w\" type=\"bold\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First line\n+                                <\/span>  Second line\n+                                \"\"\"\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    \/\/ @replace [region|region=<name>]\n+    \/\/          [regex=<val>|substring=<val>]\n+    \/\/          [replacement=<val>]\n+    \/\/          [:]\n+    @Test\n+    public void testReplace(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @replace regex=\"\\\\w\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                ..... ....\n+                                  Second line\n+                                \"\"\"),\n+                new TestCase( \/\/ \"substring\" is not treated like \"regex\"\n+                        \"\"\"\n+                                First line  \/\/ @replace substring=\"\\\\w\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                First line\n+                                  Second line\n+                                \"\"\"\n+                ),\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @replace substring=\"i\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                F.rst l.ne\n+                                  Second line\n+                                \"\"\"\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    \/\/ @link [region|region=<name>]\n+    \/\/       [regex=<val>|substring=<val>]\n+    \/\/       [target=<val>]\n+    \/\/       [type=link|linkplain]\n+    \/\/       [:]\n+    @Test\n+    public void testLink(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @link regex=\"\\\\w\" target=\"java.lang.Object#Object\"\n+                                  Second line\n+                                \"\"\",\n+                        replace(\"\"\"\n+                                link(First) link(line)\n+                                  Second line\n+                                \"\"\", \"link\\\\((.+?)\\\\)\", r -> link(true, \"java.lang.Object#Object\", r.group(1)))\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testCornerCases(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase( \/\/ This is how one might represent a unicode escape sequence uninterpreted, if required.\n+                        \"\"\"\n+                                \\\\$0041  \/\/ @replace substring=\"$\" replacement=\"u\"\n+                                \"\"\",\n+                        \"\"\"\n+                                \\\\u0041\n+                                \"\"\"\n+                ),\n+                new TestCase( \/\/ This is how one might represent `*\/` without ending an enclosing comment, if required.\n+                              \/\/ A non-whitespace character that is also not `*` is needed before `*` so that `*`\n+                              \/\/ is not confused with the optional doc comment decoration.\n+                              \/\/ (We cannot use, for example, `**$` or ` *$`.)\n+                        \"\"\"\n+                                a*$  \/\/ @replace substring=\"$\" replacement=\"\/\"\n+                                \"\"\",\n+                        \"\"\"\n+                                a*\/\n+                                \"\"\"\n+                ),\n+                new TestCase( \/\/ This is how one might output markup, if required.\n+                              \/\/ Append a no-op markup since only the rightmost markup is parsed.\n+                        \"\"\"\n+                                \/\/ @highlight \/\/ @start region=throwaway @end\n+                                \"\"\",\n+                        \"\"\"\n+                                \/\/ @highlight\n+                                \"\"\"\n+                )\n+        );\n+        testPositive(base, testCases);\n+    }\n+\n+    \/*\n+     * For all but the last line of snippet source, next-line markup behaves\n+     * as if that markup without the next-line modifier were put on that\n+     * next line.\n+     *\/\n+\/\/    @Test\n+    public void testPositiveInlineExternalTagMarkup_NextLine(Path base) throws Exception {\n+        throw new RuntimeException(\"Not yet implemented\");\n+    }\n+\n+    \/*\n+     * If next-line markup is put on the last line of a snippet source,\n+     * an error occurs.\n+     *\/\n+    @Test\n+    public void testNegativeInlineExternalHybridTagMarkup_NextLinePutOnLastLine(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var goodFile = \"good.txt\";\n+        var badFile = \"bad.txt\";\n+        var badFile2 = \"bad2.txt\"; \/\/ to workaround error deduplication\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void inline() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet :\n+                                             First line \/\/ @highlight :\n+                                             }\n+                                             \"\"\"))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void external() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(badFile)))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void hybrid1() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             First line\n+                                             }\n+                                             \"\"\".formatted(badFile2)))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void hybrid2() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             First line \/\/ @highlight :\n+                                             }\n+                                             \"\"\".formatted(goodFile)))\n+                \/\/ TODO: these two hybrids are to test what *this* test should not test.\n+                \/\/  Add a test that checks that an error in either part\n+                \/\/  of a hybrid snippet causes the snippet to fail (property-based testing)\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", goodFile, \"\"\"\n+First line \/\/ @highlight\n+ \"\"\");\n+        addSnippetFile(srcDir, \"pkg\", badFile, \"\"\"\n+First line \/\/ @highlight :\n+ \"\"\");\n+        addSnippetFile(srcDir, \"pkg\", badFile2, \"\"\"\n+First line \/\/ @highlight :\n+ \"\"\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+\"\"\"\n+A.java:5: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\",\n+\"\"\"\n+A.java:24: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\",\n+\"\"\"\n+%s:1: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\".formatted(badFile),\n+\"\"\"\n+%s:1: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\".formatted(badFile2));\n+        checkNoCrashes();\n+    }\n+\n+    private void testPositive(Path base, List<TestCase> testCases)\n+            throws IOException {\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(testCases, (i, n) -> {\n+            String r = i.region.isBlank() ? \"\" : \"region=\" + i.region;\n+            var methodDef = \"\"\"\n+\n+                    \/**\n+                    {@snippet %s:\n+                    %s}*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(r, i.input, n);\n+            methods.append(methodDef);\n+        });\n+        var classDef = \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classDef);\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.OK);\n+        checkNoCrashes();\n+        forEachNumbered(testCases, (t, index) -> {\n+            String html = \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        %s\n+                        <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\", t.expectedOutput()));\n+            checkOutput(\"A.html\", true, html);\n+        });\n+    }\n+\n+    \/\/ FIXME: move error (i.e. negative) tests from TestSnippetTag to here\n+\n+    \/\/ @start region=<name> ... @end [region|region=<name>]\n+    @Test\n+    public void testStart(Path base) throws Exception {\n+        var testCases = new ArrayList<TestCase>();\n+        for (var variant : generateStartEndVariants()) {\n+            var t = new TestCase(variant.region,\n+                    \"\"\"\n+                            First line\n+                              Second line \/\/ ###START\n+                              Third line\n+                              Fourth line \/\/ ###END\n+                            Fifth line\n+                            \"\"\".replaceFirst(\"###START\", variant.start)\n+                            .replaceFirst(\"###END\", variant.end),\n+                    \"\"\"\n+                            Second line\n+                            Third line\n+                            Fourth line\"\"\");\n+            testCases.add(t);\n+        }\n+        testPositive(base, testCases);\n+    }\n+\n+    private static String link(boolean linkPlain,\n+                               String targetReference,\n+                               String content)\n+            throws UncheckedIOException {\n+\n+        \/\/ The HTML <a> tag generated from the @link snippet markup tag is the\n+        \/\/ same as that of the {@link} Standard doclet tag. This is specified\n+        \/\/ and can be used for comparison and testing.\n+\n+        \/\/ generate documentation for {@link} to grab its HTML <a> tag;\n+        \/\/ generate documentation at low cost and do not interfere with the\n+        \/\/ calling test state; for that, do not create file trees, do not write\n+        \/\/ to std out\/err, and generally try to keep everything in memory\n+\n+        String source = \"\"\"\n+                \/** {@link %s %s} *\/\n+                public interface A { }\n+                \"\"\".formatted(targetReference, content);\n+\n+        JavaFileObject src = new JavaFileObject() {\n+            @Override\n+            public Kind getKind() {return Kind.SOURCE;}\n+\n+            @Override\n+            public boolean isNameCompatible(String simpleName, Kind kind) {\n+                return kind == Kind.SOURCE;\n+            }\n+\n+            @Override\n+            public NestingKind getNestingKind() {return NestingKind.TOP_LEVEL;}\n+\n+            @Override\n+            public Modifier getAccessLevel() {return Modifier.PUBLIC;}\n+\n+            @Override\n+            public URI toUri() {throw new UnsupportedOperationException();}\n+\n+            @Override\n+            public String getName() {return \"A.java\";}\n+\n+            @Override\n+            public InputStream openInputStream() {\n+                return new ByteArrayInputStream(source.getBytes(StandardCharsets.UTF_8));\n+            }\n+\n+            @Override\n+            public OutputStream openOutputStream() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+\n+            @Override\n+            public Reader openReader(boolean ignoreEncodingErrors) {\n+                return new StringReader(source);\n+            }\n+\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return source;\n+            }\n+\n+            @Override\n+            public Writer openWriter() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+\n+            @Override\n+            public long getLastModified() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public boolean delete() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+        };\n+\n+        var documentationTool = ToolProvider.getSystemDocumentationTool();\n+        var writer = new StringWriter();\n+\n+        \/\/ FileManager has to be StandardJavaFileManager; JavaDoc is adamant about it\n+        class InMemoryFileManager extends ToolBox.MemoryFileManager\n+                implements StandardJavaFileManager {\n+\n+            private final StandardJavaFileManager delegate = documentationTool\n+                    .getStandardFileManager(null, null, null);\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> files) {\n+                return delegate.getJavaFileObjectsFromFiles(files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjects(File... files) {\n+                return delegate.getJavaFileObjects(files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings(Iterable<String> names) {\n+                return delegate.getJavaFileObjectsFromStrings(names);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjects(String... names) {\n+                return delegate.getJavaFileObjects(names);\n+            }\n+\n+            @Override\n+            public void setLocation(Location location, Iterable<? extends File> files) throws IOException {\n+                delegate.setLocation(location, files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends File> getLocation(Location location) {\n+                return delegate.getLocation(location);\n+            }\n+\n+            @Override\n+            public FileObject getFileForOutput(Location location,\n+                                               String packageName,\n+                                               String relativeName,\n+                                               FileObject sibling) {\n+                return getJavaFileForOutput(location, packageName + relativeName, JavaFileObject.Kind.OTHER, null);\n+            }\n+        }\n+        try {\n+            var fileManager = new InMemoryFileManager();\n+            fileManager.setLocation(DOCUMENTATION_OUTPUT, Collections.singleton(new File(\".\")));\n+            \/\/ exclude extraneous output; we're only after @link\n+            List<String> options = List.of(\"--limit-modules\", \"java.base\",\n+                    \"-quiet\", \"-nohelp\", \"-noindex\", \"-nonavbar\", \"-nosince\",\n+                    \"-notimestamp\", \"-notree\", \"-Xdoclint:none\");\n+            var documentationTask = documentationTool.getTask(null, fileManager,\n+                    null, null, options, List.of(src));\n+            if (!documentationTask.call()) {\n+                throw new IOException(writer.toString());\n+            }\n+            String output = fileManager.getFileString(DOCUMENTATION_OUTPUT, \"A.html\");\n+            \/\/ use the [^<>] regex to select HTML elements that immediately enclose \"content\"\n+            Matcher m = Pattern.compile(\"(?is)<a href=\\\"[^<>]*\\\" title=\\\"[^<>]*\\\" class=\\\"[^<>]*\\\"><code>\"\n+                    + content + \"<\/code><\/a>\").matcher(output);\n+            if (!m.find()) {\n+                throw new IOException(output);\n+            }\n+            return m.group(0);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private static String replace(String source,\n+                                  String regex,\n+                                  Function<MatchResult, String> replacer) {\n+        return Pattern.compile(regex).matcher(source).replaceAll(replacer);\n+    }\n+\n+    private static final AtomicLong UNIQUE_INTEGER_NUMBER = new AtomicLong();\n+\n+    private static Collection<StartEndVariant> generateStartEndVariants() {\n+        var variants = new ArrayList<StartEndVariant>();\n+        for (var start : startAttributes())\n+            for (var end : endAttributes()) {\n+                var region = uniqueValue();\n+                var v = new StartEndVariant(region,\n+                        \"@start\" + start.apply(region),\n+                        \"@end\" + end.apply(region));\n+                variants.add(v);\n+            }\n+        return variants;\n+    }\n+\n+    private static String uniqueValue() {\n+        return \"auto_generated_value_\" + UNIQUE_INTEGER_NUMBER.incrementAndGet();\n+    }\n+\n+    public static Collection<Function<String, String>> startAttributes() {\n+        return attributes(\"region\");\n+    }\n+\n+    private static Collection<Function<String, String>> endAttributes() {\n+        var variants = new ArrayList<Function<String, String>>();\n+        variants.add(value -> \"\");\n+        variants.add(value -> \" region\");\n+        variants.addAll(attributes(\"region\"));\n+        return variants;\n+    }\n+\n+    private static Collection<Function<String, String>> attributes(String name) {\n+        var variants = new ArrayList<Function<String, String>>();\n+        for (var whitespace1 : List.of(\" \", \"  \"))\n+            for (var whitespace2 : List.of(\"\", \" \"))\n+                for (var quote : List.of(\"\", \"'\", \"\\\"\"))\n+                    for (var whitespace3 : List.of(\"\", \" \")) {\n+                        Function<String, String> f = value ->\n+                                whitespace1 + name + whitespace2\n+                                        + \"=\" + whitespace3 + (quote + value + quote);\n+                        variants.add(f);\n+                    }\n+        return variants;\n+    }\n+\n+    record StartEndVariant(String region, String start, String end) {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetPathOption\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class TestSnippetPathOption extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetPathOption().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+        #   snippet-files   snippet-path   result\n+       ---+--------------+--------------+---------------------\n+        1         +              +         snippet-files\n+        2         +           invalid      snippet-files\n+        3         -              +         snippet-path\n+        4         -           invalid      error\n+     *\/\n+\n+    @Test\n+    public void test1(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"directoryA\/mysnippet.txt\"), \"Hello, directoryA!\");\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeFile(src.resolve(\"pkg\/snippet-files\/mysnippet.txt\"), \"Hello, snippet-files!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, snippet-files!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryA!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryB!\");\n+    }\n+\n+    @Test\n+    public void test2(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"pkg\/snippet-files\/mysnippet.txt\"), \"Hello, snippet-files!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, snippet-files!\");\n+    }\n+\n+    @Test\n+    public void test3(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"directoryA\/mysnippet.txt\"), \"Hello, directoryA!\");\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, directoryA!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryB!\");\n+    }\n+\n+    @Test\n+    public void test4(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+    }\n+\n+    \/*\n+     * Tests that the elements of the snippet path are iteratively searched\n+     * until the file is found. In particular, tests that if the file is not\n+     * immediately found, the search is not abandoned.\n+     *\/\n+    @Test\n+    public void testSearchPath(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        \/\/ do not put snippet in directoryA; only put snippet in directoryB\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        \/\/ directoryA goes first, assuming that paths are searched in\n+        \/\/ the same order they are specified in\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, directoryB!\");\n+    }\n+\n+    \/*\n+     * Tests translation from FQN (the \"class\" attribute) to file path\n+     * (the \"file\" attribute).\n+     *\/\n+    @Test\n+    public void testClassToFile(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        Path directoryA = Files.createDirectories(src.resolve(\"directoryA\"));\n+        tb.writeJavaFiles(directoryA, \"\"\"\n+                                      package com.example.snippet;\n+\n+                                      public interface Y { }\n+                                      \"\"\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet class=\"com.example.snippet.Y\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"public interface Y { }\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetPathOption.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -36,6 +36,0 @@\n-import builder.ClassBuilder;\n-import builder.ClassBuilder.MethodBuilder;\n-import javadoc.tester.JavadocTester;\n-import toolbox.ModuleBuilder;\n-import toolbox.ToolBox;\n-\n@@ -43,1 +37,0 @@\n-import java.io.UncheckedIOException;\n@@ -48,1 +41,1 @@\n-import java.util.Arrays;\n+import java.util.ArrayList;\n@@ -53,2 +46,0 @@\n-import java.util.function.ObjIntConsumer;\n-import java.util.regex.Matcher;\n@@ -56,1 +47,4 @@\n-import java.util.stream.Stream;\n+\n+import builder.ClassBuilder;\n+import builder.ClassBuilder.MethodBuilder;\n+import toolbox.ModuleBuilder;\n@@ -66,1 +60,16 @@\n- * General notes.\n+ * General notes\n+ * =============\n+ *\n+ * To simplify maintenance of this test suite, a test name uses a convention.\n+ * By convention, a test name is a concatenation of the following parts:\n+ *\n+ *    1. \"test\"\n+ *    2. (\"Positive\", \"Negative\")\n+ *    3. (\"Inline\", \"External\", \"Hybrid\")\n+ *    4. (\"Tag\", \"Markup\")\n+ *    5. <custom string>\n+ *\n+ * A test can be either positive or negative; it cannot be both or neither.\n+ * A test can exercise inline, external or hybrid variant or any combination\n+ * thereof, including none at all. A test can exercise tag syntax, markup syntax\n+ * or both.\n@@ -76,5 +85,1 @@\n-public class TestSnippetTag extends JavadocTester {\n-\n-    private final ToolBox tb = new ToolBox();\n-\n-    private TestSnippetTag() { }\n+public class TestSnippetTag extends SnippetTester {\n@@ -87,2 +92,4 @@\n-     * Make sure the \"id\" and \"lang\" attributes defined in JEP 413 are rendered\n-     * properly as recommended by the HTML5 specification.\n+     * Make sure the \"id\" and \"lang\" attributes defined in JEP 413 are translated\n+     * to HTML. In particular, verify that the \"lang\" attribute is translated\n+     * to a value added to the \"class\" attribute as recommended by the HTML5 specification:\n+     * https:\/\/html.spec.whatwg.org\/multipage\/text-level-semantics.html#the-code-element\n@@ -91,1 +98,1 @@\n-    public void testIdAndLangAttributes(Path base) throws IOException {\n+    public void testPositiveInlineTag_IdAndLangAttributes(Path base) throws IOException {\n@@ -96,8 +103,1 @@\n-        record SnippetAttributes(String content, String id, String lang) {\n-            public String idAttribute() {\n-                return id == null ? \"\" : \" id=\\\"\" + id + \"\\\"\";\n-            }\n-            public String langAttribute() {\n-                return lang == null ? \"\" : \" class=\\\"language-\" + lang + \"\\\"\";\n-            }\n-        }\n+        record SnippetAttributes(String content, String id, String lang) { }\n@@ -105,0 +105,1 @@\n+        \/\/ TODO: use combinatorial methods, e.g. just like in TestSnippetMarkup\n@@ -221,1 +222,3 @@\n-            SnippetAttributes snippet = snippets.get(j);\n+            var attr = snippets.get(j);\n+            var snippetHtml = getSnippetHtmlRepresentation(\"pkg\/A.html\", \"    Hello, Snippet!\\n\",\n+                    Optional.ofNullable(attr.lang()), Optional.ofNullable(attr.id()));\n@@ -227,7 +230,2 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"%s><code%s>    Hello, Snippet!\n-                        <\/code><\/pre>\n-                        <\/div>\n-                        \"\"\".formatted(j, snippet.idAttribute(), snippet.langAttribute()));\n+                        %s\n+                        \"\"\".formatted(j, snippetHtml));\n@@ -238,3 +236,5 @@\n-     * Make sure the lang attribute is derived correctly from the snippet source file\n-     * for external snippets when it is not defined in the snippet. Defining the lang\n-     * attribute in the snippet should always override this mechanism.\n+     * If the \"lang\" attribute is absent in the snippet tag for an external snippet,\n+     * then the \"class\" attribute is derived from the snippet source file extension.\n+     *\n+     * If the \"class\" attribute can be derived both from the \"lang\" attribute and\n+     * the file extension, then it is derived from the \"lang\" attribute.\n@@ -242,0 +242,1 @@\n+    \/\/ TODO: restructure this as a list of TestCase records\n@@ -243,1 +244,1 @@\n-    public void testExternalImplicitAttributes(Path base) throws IOException {\n+    public void testPositiveInlineExternalTagMarkup_ImplicitAttributes(Path base) throws IOException {\n@@ -279,38 +280,1 @@\n-        checkOutput(\"com\/example\/Cls.html\", true,\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet1\"><code class=\"language-java\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet2\"><code class=\"language-java\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet3\"><code class=\"language-none\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet4\"><code class=\"language-none\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet5\"><code>\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet6\"><code>\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet7\"><code class=\"language-properties\">user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet8\"><code class=\"language-none\">user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet9\"><code>user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\");\n-    }\n+        final var javaContent = \"\"\"\n@@ -318,11 +282,16 @@\n-    \/*\n-     * This is a convenience method to iterate through a list.\n-     * Unlike List.forEach, this method provides the consumer not only with an\n-     * element but also that element's index.\n-     *\n-     * See JDK-8184707.\n-     *\/\n-    private static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n-        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n-            action.accept(iterator.next(), iterator.previousIndex());\n-        }\n+                System.out.println(msg);\n+                \"\"\";\n+        final var propertiesContent = \"\"\"\n+                user=jane\n+                home=\/home\/jane\n+                \"\"\";\n+        checkOutput(\"com\/example\/Cls.html\", true,\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"java\"), Optional.of(\"snippet1\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"java\"), Optional.of(\"snippet2\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"none\"), Optional.of(\"snippet3\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"none\"), Optional.of(\"snippet4\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.empty(), Optional.of(\"snippet5\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.empty(), Optional.of(\"snippet6\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.of(\"properties\"), Optional.of(\"snippet7\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.of(\"none\"), Optional.of(\"snippet8\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.empty(), Optional.of(\"snippet9\")));\n@@ -332,1 +301,1 @@\n-    public void testBadTagSyntax(Path base) throws IOException {\n+    public void testNegativeInlineTag_BadTagSyntax(Path base) throws IOException {\n@@ -669,37 +638,0 @@\n-    \/\/ TODO This is a temporary method; it should be removed after JavadocTester has provided similar functionality (JDK-8273154).\n-    private void checkOrder(Output output, String... strings) {\n-        String outputString = getOutput(output);\n-        int prevIndex = -1;\n-        for (String s : strings) {\n-            s = s.replace(\"\\n\", NL); \/\/ normalize new lines\n-            int currentIndex = outputString.indexOf(s, prevIndex + 1);\n-            checking(\"output: \" + output + \": \" + s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(output + \": \" + s + \" not found.\");\n-                continue;\n-            }\n-            if (currentIndex > prevIndex) {\n-                passed(output + \": \" + \" is in the correct order\");\n-            } else {\n-                failed(output + \": \" + \" is in the wrong order.\");\n-            }\n-            prevIndex = currentIndex;\n-        }\n-    }\n-\n-    \/*\n-     * When checking for errors, it is important not to confuse one error with\n-     * another. This method checks that there are no crashes (which are also\n-     * errors) by checking for stack traces. We never expect crashes.\n-     *\/\n-    private void checkNoCrashes() {\n-        checking(\"check crashes\");\n-        Matcher matcher = Pattern.compile(\"\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n-                .matcher(getOutput(Output.STDERR));\n-        if (!matcher.find()) {\n-            passed(\"\");\n-        } else {\n-            failed(\"Looks like a stacktrace: \" + matcher.group());\n-        }\n-    }\n-\n@@ -712,1 +644,1 @@\n-    public void testUnknownTag(Path base) throws IOException {\n+    public void testNegativeInlineTagUnknownTag(Path base) throws IOException {\n@@ -749,1 +681,1 @@\n-    public void testInline(Path base) throws Exception {\n+    public void testPositiveInlineTag(Path base) throws Exception {\n@@ -951,5 +883,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(id, t.expectedOutput()));\n+                        %s\"\"\".formatted(id, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -960,1 +888,1 @@\n-    public void testExternalFile(Path base) throws Exception {\n+    public void testPositiveExternalTag_File(Path base) throws Exception {\n@@ -1047,5 +975,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, expectedOutput));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", expectedOutput)));\n@@ -1055,14 +979,0 @@\n-    \/\/ TODO:\n-    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n-    \/\/   see if any of them could be used instead of this one\n-    private void addSnippetFile(Path srcDir, String packageName, String fileName, String content) throws UncheckedIOException {\n-        String[] components = packageName.split(\"\\\\.\");\n-        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n-        try {\n-            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n-            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n@@ -1070,1 +980,1 @@\n-    public void testInlineSnippetInDocFiles(Path base) throws IOException {\n+    public void testPositiveInlineTag_InDocFiles(Path base) throws IOException {\n@@ -1112,1 +1022,1 @@\n-    public void testExternalSnippetInDocFiles(Path base) throws IOException {\n+    public void testPositiveExternalTag_InDocFiles(Path base) throws IOException {\n@@ -1154,1 +1064,1 @@\n-    public void testExternalFileNotFound(Path base) throws Exception {\n+    public void testNegativeExternalTag_FileNotFound(Path base) throws Exception {\n@@ -1177,2 +1087,2 @@\n-    @Test \/\/ TODO perhaps this could be unified with testExternalFile\n-    public void testExternalFileModuleSourcePath(Path base) throws Exception {\n+    @Test \/\/ TODO perhaps this could be unified with testPositiveExternalTagFile\n+    public void testNegativeExternalTag_FileModuleSourcePath(Path base) throws Exception {\n@@ -1203,2 +1113,2 @@\n-    @Test \/\/ TODO perhaps this could be unified with testExternalFileNotFound\n-    public void testExternalFileNotFoundModuleSourcePath(Path base) throws Exception {\n+    @Test \/\/ TODO perhaps this could be unified with testNegativeExternalTagFileNotFound\n+    public void testNegativeExternalTag_FileNotFoundModuleSourcePath(Path base) throws Exception {\n@@ -1233,1 +1143,1 @@\n-    public void testNoContents(Path base) throws Exception {\n+    public void testNegativeTag_NoContents(Path base) throws Exception {\n@@ -1253,1 +1163,31 @@\n-    public void testConflict20(Path base) throws Exception {\n+    public void testNegativeExternalTagMarkup(Path base) throws Exception {\n+        \/\/ External snippet issues are handled similarly to those of internal snippet\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        addSnippetFile(srcDir, \"pkg\", \"file.txt\", \"\"\"\n+                                                  \/\/ @start\n+                                                  \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case0() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"file.txt\"}\n+                                             \"\"\"));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+\"\"\"\n+: error: snippet markup: missing attribute \"region\"\n+\/\/ @start\n+    ^\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeInlineTag_AttributeConflict20(Path base) throws Exception {\n@@ -1279,1 +1219,1 @@\n-    public void testConflict30(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict30(Path base) throws Exception {\n@@ -1300,13 +1240,0 @@\n-    \/\/ TODO: perhaps this method could be added to JavadocTester\n-    private void checkOutputEither(Output out, String first, String... other) {\n-        checking(\"checkOutputEither\");\n-        String output = getOutput(out);\n-        Stream<String> strings = Stream.concat(Stream.of(first), Stream.of(other));\n-        Optional<String> any = strings.filter(output::contains).findAny();\n-        if (any.isPresent()) {\n-            passed(\": following text is found:\\n\" + any.get());\n-        } else {\n-            failed(\": nothing found\");\n-        }\n-    }\n-\n@@ -1314,1 +1241,1 @@\n-    public void testConflict60(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict60(Path base) throws Exception {\n@@ -1334,1 +1261,1 @@\n-    public void testConflict70(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict70(Path base) throws Exception {\n@@ -1354,1 +1281,1 @@\n-    public void testConflict80(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict80(Path base) throws Exception {\n@@ -1378,1 +1305,1 @@\n-    public void testConflict90(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict90(Path base) throws Exception {\n@@ -1402,1 +1329,1 @@\n-    public void testErrorPositionResolution(Path base) throws Exception {\n+    public void testNegativeTag_PositionResolution(Path base) throws Exception {\n@@ -1430,1 +1357,1 @@\n-    public void testRegion(Path base) throws Exception {\n+    public void testPositiveInlineTag_AttributeConflictRegion(Path base) throws Exception {\n@@ -1608,5 +1535,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -1650,1 +1573,1 @@\n-    public void testAttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_AttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n@@ -1684,1 +1607,1 @@\n-    public void testAttributeValueSyntaxCurly(Path base) throws Exception {\n+    public void testPositiveInlineTagMarkup_SyntaxCurly(Path base) throws Exception {\n@@ -1725,5 +1648,1 @@\n-                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n-                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n-                    ><\/button>\n-                    <pre class=\"snippet\"><code><\/code><\/pre>\n-                    <\/div>\"\"\");\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n@@ -1734,5 +1653,1 @@\n-                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n-                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n-                    ><\/button>\n-                    <pre class=\"snippet\"><code><\/code><\/pre>\n-                    <\/div>\"\"\");\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n@@ -1741,2 +1656,2 @@\n-    @Test\n-    public void testAttributeValueSyntax(Path base) throws Exception {\n+    @Test \/\/ TODO: use combinatorial methods\n+    public void testPositiveExternalTagMarkup_AttributeValueSyntax(Path base) throws Exception {\n@@ -1835,6 +1750,2 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>2<\/code><\/pre>\n-                        <\/div>\n-                        \"\"\".formatted(j));\n+                        %s\n+                        \"\"\".formatted(j, getSnippetHtmlRepresentation(\"pkg\/A.html\", \"2\")));\n@@ -1845,1 +1756,1 @@\n-    public void testComment(Path base) throws Exception {\n+    public void testPositiveInlineTagMarkup_Comment(Path base) throws Exception {\n@@ -1919,5 +1830,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -1928,1 +1835,1 @@\n-    public void testRedundantFileNotFound(Path base) throws Exception {\n+    public void testNegativeHybridTag_FileNotFound(Path base) throws Exception {\n@@ -1953,1 +1860,104 @@\n-    public void testRedundantRegionNotFound(Path base) throws Exception {\n+    public void testNegativeTag_ValuelessAttributes(Path base) throws IOException {\n+        \/\/ none of these attributes should ever be valueless\n+        record TestCase(String input, String expectedError) { }\n+        var testCases = new ArrayList<TestCase>();\n+        for (String attrName : List.of(\"class\", \"file\", \"id\", \"lang\", \"region\")) {\n+            \/\/ special case: valueless region attribute\n+            TestCase t = new TestCase(\"\"\"\n+{@snippet %s:\n+    First line\n+      Second line\n+}\n+\"\"\".formatted(attrName),\n+\"\"\"\n+: error: missing value for attribute \"%s\"\n+{@snippet %s:\n+          ^\"\"\".formatted(attrName, attrName));\n+            testCases.add(t);\n+        }\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        \/\/ use the facility from JDK-8273154 when it becomes available\n+        checkOutput(Output.OUT, true, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeTag_BlankRegion(Path base) throws Exception {\n+        \/\/ If a blank region were allowed, it could not be used without quotes\n+        record TestCase(String input, String expectedError) { }\n+\n+      var testCases = new ArrayList<TestCase>();\n+      for (String quote : List.of(\"\", \"'\", \"\\\"\"))\n+          for (String value : List.of(\"\", \" \")) {\n+              var t = new TestCase(\"\"\"\n+{@snippet region=%s%s%s:\n+    First line\n+      Second line\n+}\n+\"\"\".formatted(quote, value, quote),\n+                      \"\"\"\n+: error: illegal value for attribute \"region\": \"%s\"\n+{@snippet region=%s%s%s:\n+          ^\"\"\".formatted(quote.isEmpty() ? \"\" : value, quote, value, quote)); \/\/ unquoted whitespace translates to empty string\n+              testCases.add(t);\n+          }\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        \/\/ use the facility from JDK-8273154 when it becomes available\n+        checkOutput(Output.OUT, true, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeHybridTagMarkup_RegionNotFound(Path base) throws Exception {\n@@ -1984,1 +1994,1 @@\n-    public void testRedundantMismatch(Path base) throws Exception {\n+    public void testNegativeHybridTag_Mismatch(Path base) throws Exception {\n@@ -2013,1 +2023,1 @@\n-    public void testRedundantRegionRegionMismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_RegionRegionMismatch(Path base) throws Exception {\n@@ -2053,1 +2063,1 @@\n-    public void testRedundantRegion1Mismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_Region1Mismatch(Path base) throws Exception {\n@@ -2087,1 +2097,1 @@\n-    public void testRedundantRegion2Mismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_Region2Mismatch(Path base) throws Exception {\n@@ -2124,1 +2134,1 @@\n-    public void testRedundant(Path base) throws Exception {\n+    public void testPositiveHybridTagMarkup(Path base) throws Exception {\n@@ -2251,5 +2261,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -2260,1 +2266,1 @@\n-    public void testInvalidRegexDiagnostics(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_InvalidRegexDiagnostics(Path base) throws Exception {\n@@ -2344,1 +2350,1 @@\n-    public void testErrorMessages(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_ErrorMessages(Path base) throws Exception {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":234,"deletions":228,"binary":false,"changes":462,"status":"modified"}]}