{"files":[{"patch":"@@ -173,0 +173,1 @@\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_atomic.ad \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3341,67 +3341,0 @@\n-  enc_class aarch64_enc_cmpxchg(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgw(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgs(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgb(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-\n-  \/\/ The only difference between aarch64_enc_cmpxchg and\n-  \/\/ aarch64_enc_cmpxchg_acq is that we use load-acquire in the\n-  \/\/ CompareAndSwap sequence to serve as a barrier on acquiring a\n-  \/\/ lock.\n-  enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegL oldval, iRegL newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegI oldval, iRegI newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegI oldval, iRegI newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegI oldval, iRegI newval) %{\n-    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n-    __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, noreg);\n-  %}\n-\n-  \/\/ auxiliary used for CompareAndSwapX to set result register\n-  enc_class aarch64_enc_cset_eq(iRegI res) %{\n-    Register res_reg = as_Register($res$$reg);\n-    __ cset(res_reg, Assembler::EQ);\n-  %}\n-\n@@ -8379,965 +8312,0 @@\n-\/\/ ============================================================================\n-\/\/ Atomic operation instructions\n-\/\/\n-\n-\/\/ standard CompareAndSwapX when we are using barriers\n-\/\/ these have higher priority than the rules selected by a predicate\n-\n-\/\/ XXX No flag versions for CompareAndSwap{I,L,P,N} because matcher\n-\/\/ can't match them\n-\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgb $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgb(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgs $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgs(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-\n-  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  ins_cost(2 * VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ alternative CompareAndSwapX when we are eliding barriers\n-\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgb_acq $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgb_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpxchgs_acq $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgs_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw_acq $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg_acq $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchg_acq $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  effect(KILL cr);\n-\n- format %{\n-    \"cmpxchgw_acq $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n-    \"cset $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n- %}\n-\n- ins_encode(aarch64_enc_cmpxchgw_acq(mem, oldval, newval),\n-            aarch64_enc_cset_eq(res));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\n-\/\/ ---------------------------------------------------------------------\n-\n-\/\/ BEGIN This section of the file is automatically generated. Do not edit --------------\n-\n-\/\/ Sundry CAS operations.  Note that release is always true,\n-\/\/ regardless of the memory ordering of the CAS.  This is because we\n-\/\/ need the volatile case to be sequentially consistent but there is\n-\/\/ no trailing StoreLoad barrier emitted by C2.  Unfortunately we\n-\/\/ can't check the type of memory ordering here, so we always emit a\n-\/\/ STLXR.\n-\n-\/\/ This section is generated from cas.m4\n-\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgb $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxtbw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgs $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxthw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeL(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgb_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxtbw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgs_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ sxthw($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeLAcq(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgb $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgs $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgb_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgs_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (int, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (long, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n-  ins_cost(VOLATILE_REF_COST);\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ END This section of the file is automatically generated. Do not edit --------------\n-\/\/ ---------------------------------------------------------------------\n-\n-instruct get_and_setI(indirect mem, iRegI newv, iRegINoSp prev) %{\n-  match(Set prev (GetAndSetI mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setL(indirect mem, iRegL newv, iRegLNoSp prev) %{\n-  match(Set prev (GetAndSetL mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setN(indirect mem, iRegN newv, iRegINoSp prev) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set prev (GetAndSetN mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setP(indirect mem, iRegP newv, iRegPNoSp prev) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set prev (GetAndSetP mem newv));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchg($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setIAcq(indirect mem, iRegI newv, iRegINoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set prev (GetAndSetI mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw_acq  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setLAcq(indirect mem, iRegL newv, iRegLNoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set prev (GetAndSetL mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg_acq  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setNAcq(indirect mem, iRegN newv, iRegINoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n-  match(Set prev (GetAndSetN mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchgw_acq $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgalw($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_setPAcq(indirect mem, iRegP newv, iRegPNoSp prev) %{\n-  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n-  match(Set prev (GetAndSetP mem newv));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"atomic_xchg_acq  $prev, $newv, [$mem]\" %}\n-  ins_encode %{\n-    __ atomic_xchgal($prev$$Register, $newv$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-\n-instruct get_and_addL(indirect mem, iRegLNoSp newval, iRegL incr) %{\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addL_no_res(indirect mem, Universe dummy, iRegL incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addL [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLi(indirect mem, iRegLNoSp newval, immLAddSub incr) %{\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLi_no_res(indirect mem, Universe dummy, immLAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addL [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_add(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addI(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addI_no_res(indirect mem, Universe dummy, iRegIorL2I incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addI [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIi(indirect mem, iRegINoSp newval, immIAddSub incr) %{\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIi_no_res(indirect mem, Universe dummy, immIAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(2 * VOLATILE_REF_COST);\n-  format %{ \"get_and_addI [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addw(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLAcq(indirect mem, iRegLNoSp newval, iRegL incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addL_no_resAcq(indirect mem, Universe dummy, iRegL incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addL_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLiAcq(indirect mem, iRegLNoSp newval, immLAddSub incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addL_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addLi_no_resAcq(indirect mem, Universe dummy, immLAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddL mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addL_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addal(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIAcq(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw($newval$$Register, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addI_no_resAcq(indirect mem, Universe dummy, iRegIorL2I incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addI_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw(noreg, $incr$$Register, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIiAcq(indirect mem, iRegINoSp newval, immIAddSub incr) %{\n-  predicate(needs_acquiring_load_exclusive(n));\n-  match(Set newval (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST + 1);\n-  format %{ \"get_and_addI_acq $newval, [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw($newval$$Register, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct get_and_addIi_no_resAcq(indirect mem, Universe dummy, immIAddSub incr) %{\n-  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n-  match(Set dummy (GetAndAddI mem incr));\n-  ins_cost(VOLATILE_REF_COST);\n-  format %{ \"get_and_addI_acq [$mem], $incr\" %}\n-  ins_encode %{\n-    __ atomic_addalw(noreg, $incr$$constant, as_Register($mem$$base));\n-  %}\n-  ins_pipe(pipe_serial);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":1032,"binary":false,"changes":1032,"status":"modified"},{"patch":"@@ -0,0 +1,909 @@\n+\/\/ Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2016, 2021, Red Hat Inc. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+\/\/ BEGIN This file is automatically generated. Do not edit --------------\n+\n+\/\/ Sundry CAS operations.  Note that release is always true,\n+\/\/ regardless of the memory ordering of the CAS.  This is because we\n+\/\/ need the volatile case to be sequentially consistent but there is\n+\/\/ no trailing StoreLoad barrier emitted by C2.  Unfortunately we\n+\/\/ can't check the type of memory ordering here, so we always emit a\n+\/\/ STLXR.\n+\n+\/\/ This section is generated from aarch64_atomic_ad.m4\n+\n+\n+instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgb $res = $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+    __ sxtbw($res$$Register, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgs $res = $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+    __ sxthw($res$$Register, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeL(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgb_acq $res = $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+    __ sxtbw($res$$Register, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgs_acq $res = $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+    __ sxthw($res$$Register, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeLAcq(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgb $res = $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgs $res = $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndSwapI mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n+  match(Set res (CompareAndSwapL mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw $res = $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgb_acq $res = $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgs_acq $res = $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndSwapI mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (CompareAndSwapL mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw_acq $res = $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ false, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgb_weak $res = $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::byte, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgs_weak $res = $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::halfword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw_weak $res = $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n+  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg_weak $res = $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw_weak $res = $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg_weak $res = $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ false, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgb_acq_weak $res = $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::byte, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgs_acq_weak $res = $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::halfword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw_acq_weak $res = $mem, $oldval, $newval\\t# (int) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg_acq_weak $res = $mem, $oldval, $newval\\t# (long) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchgw_acq_weak $res = $mem, $oldval, $newval\\t# (narrow oop) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::word, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg_acq_weak $res = $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::xword, \/*acquire*\/ true, \/*release*\/ true,\n+               \/*weak*\/ true, noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct getAndSetI(indirect mem, iRegI newval, iRegINoSp oldval) %{\n+  match(Set oldval (GetAndSetI mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgw  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchgw($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndSetL(indirect mem, iRegL newval, iRegLNoSp oldval) %{\n+  match(Set oldval (GetAndSetL mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchg($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndSetN(indirect mem, iRegN newval, iRegNNoSp oldval) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set oldval (GetAndSetN mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgw  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchgw($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndSetP(indirect mem, iRegP newval, iRegPNoSp oldval) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set oldval (GetAndSetP mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchg($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndSetIAcq(indirect mem, iRegI newval, iRegINoSp oldval) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set oldval (GetAndSetI mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgw_acq  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchgalw($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndSetLAcq(indirect mem, iRegL newval, iRegLNoSp oldval) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set oldval (GetAndSetL mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg_acq  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchgal($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndSetNAcq(indirect mem, iRegN newval, iRegNNoSp oldval) %{\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n+  match(Set oldval (GetAndSetN mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchgw_acq  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchgalw($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndSetPAcq(indirect mem, iRegP newval, iRegPNoSp oldval) %{\n+  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));\n+  match(Set oldval (GetAndSetP mem newval));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg_acq  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchgal($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddI(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{\n+  match(Set newval (GetAndAddI mem incr));\n+  ins_cost(2*VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addI $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addw($newval$$Register, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddIAcq(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set newval (GetAndAddI mem incr));\n+  ins_cost(VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addI_acq $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addalw($newval$$Register, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddINoRes(indirect mem, Universe dummy, iRegIorL2I incr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddI mem incr));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"get_and_addI noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addw(noreg, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddIAcqNoRes(indirect mem, Universe dummy, iRegIorL2I incr) %{\n+  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n+  match(Set dummy (GetAndAddI mem incr));\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"get_and_addI_acq noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addalw(noreg, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddIConst(indirect mem, iRegINoSp newval, immIAddSub incr) %{\n+  match(Set newval (GetAndAddI mem incr));\n+  ins_cost(2*VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addI $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addw($newval$$Register, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddIAcqConst(indirect mem, iRegINoSp newval, immIAddSub incr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set newval (GetAndAddI mem incr));\n+  ins_cost(VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addI_acq $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addalw($newval$$Register, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddINoResConst(indirect mem, Universe dummy, immIAddSub incr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddI mem incr));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"get_and_addI noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addw(noreg, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddIAcqNoResConst(indirect mem, Universe dummy, immIAddSub incr) %{\n+  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n+  match(Set dummy (GetAndAddI mem incr));\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"get_and_addI_acq noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addalw(noreg, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddL(indirect mem, iRegLNoSp newval, iRegL incr) %{\n+  match(Set newval (GetAndAddL mem incr));\n+  ins_cost(2*VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addL $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_add($newval$$Register, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddLAcq(indirect mem, iRegLNoSp newval, iRegL incr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set newval (GetAndAddL mem incr));\n+  ins_cost(VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addL_acq $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addal($newval$$Register, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddLNoRes(indirect mem, Universe dummy, iRegL incr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddL mem incr));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"get_and_addL noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_add(noreg, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddLAcqNoRes(indirect mem, Universe dummy, iRegL incr) %{\n+  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n+  match(Set dummy (GetAndAddL mem incr));\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"get_and_addL_acq noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addal(noreg, $incr$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddLConst(indirect mem, iRegLNoSp newval, immLAddSub incr) %{\n+  match(Set newval (GetAndAddL mem incr));\n+  ins_cost(2*VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addL $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_add($newval$$Register, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddLAcqConst(indirect mem, iRegLNoSp newval, immLAddSub incr) %{\n+  predicate(needs_acquiring_load_exclusive(n));\n+  match(Set newval (GetAndAddL mem incr));\n+  ins_cost(VOLATILE_REF_COST+1);\n+  format %{ \"get_and_addL_acq $newval, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addal($newval$$Register, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddLNoResConst(indirect mem, Universe dummy, immLAddSub incr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddL mem incr));\n+  ins_cost(2*VOLATILE_REF_COST);\n+  format %{ \"get_and_addL noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_add(noreg, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct getAndAddLAcqNoResConst(indirect mem, Universe dummy, immLAddSub incr) %{\n+  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));\n+  match(Set dummy (GetAndAddL mem incr));\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"get_and_addL_acq noreg, [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_addal(noreg, $incr$$constant, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_atomic.ad","additions":909,"deletions":0,"binary":false,"changes":909,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/\/ Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2016, 2021, Red Hat Inc. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+\/\/ BEGIN This file is automatically generated. Do not edit --------------\n+\n+\/\/ Sundry CAS operations.  Note that release is always true,\n+\/\/ regardless of the memory ordering of the CAS.  This is because we\n+\/\/ need the volatile case to be sequentially consistent but there is\n+\/\/ no trailing StoreLoad barrier emitted by C2.  Unfortunately we\n+\/\/ can't check the type of memory ordering here, so we always emit a\n+\/\/ STLXR.\n+\n+\/\/ This section is generated from aarch64_atomic_ad.m4\n+\n+dnl Return Arg1 with two spaces before it. We need this because m4\n+dnl strips leading spaces from macro args.\n+define(`INDENT', `  $1')dnl\n+dnl\n+dnl\n+dnl\n+dnl ====================== CompareAndExchange*\n+dnl\n+define(`CAE_INSN1',\n+`\n+instruct compareAndExchange$1$7(iReg$2NoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n+ifelse($7,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),`dnl')\n+  match(Set res (CompareAndExchange$1 mem (Binary oldval newval)));\n+  ins_cost(`'ifelse($7,Acq,,2*)VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchg$5`'ifelse($7,Acq,_acq,) $res = $mem, $oldval, $newval\\t# ($3) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::$4, \/*acquire*\/ ifelse($7,Acq,true,false), \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+    __ $6($res$$Register, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+define(`CAE_INSN2',\n+`\n+instruct compareAndExchange$1$6(iReg$2NoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n+ifelse($1$6,PAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));),\n+       $1$6,NAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);),\n+       $1,P,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $1,N,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n+       `dnl')\n+  match(Set res (CompareAndExchange$1 mem (Binary oldval newval)));\n+  ins_cost(`'ifelse($6,Acq,,2*)VOLATILE_REF_COST);\n+  effect(TEMP_DEF res, KILL cr);\n+  format %{\n+    \"cmpxchg$5`'ifelse($6,Acq,_acq,) $res = $mem, $oldval, $newval\\t# ($3) if $mem == $oldval then $mem <-- $newval\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::$4, \/*acquire*\/ ifelse($6,Acq,true,false), \/*release*\/ true,\n+               \/*weak*\/ false, $res$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+CAE_INSN1(B,    I,  byte,       byte,       b,  sxtbw,  )\n+CAE_INSN1(S,    I,  short,      halfword,   s,  sxthw,  )\n+CAE_INSN2(I,    I,  int,        word,       w,  ,   )\n+CAE_INSN2(L,    L,  long,       xword,      ,   ,   )\n+CAE_INSN2(N,    N,  narrow oop, word,       w,  ,   )\n+CAE_INSN2(P,    P,  ptr,        xword,      ,   ,   )\n+dnl\n+CAE_INSN1(B,    I,  byte,       byte,       b,  sxtbw,  Acq)\n+CAE_INSN1(S,    I,  short,      halfword,   s,  sxthw,  Acq)\n+CAE_INSN2(I,    I,  int,        word,       w,  Acq)\n+CAE_INSN2(L,    L,  long,       xword,      ,   Acq)\n+CAE_INSN2(N,    N,  narrow oop, word,       w,  Acq)\n+CAE_INSN2(P,    P,  ptr,        xword,      ,   Acq)\n+dnl\n+dnl\n+dnl\n+dnl ====================== (Weak)CompareAndSwap*\n+dnl\n+define(`CAS_INSN1',\n+`\n+instruct ifelse($7,Weak,'weakCompare`,'compare`)AndSwap$1$6(iRegINoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n+ifelse($6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),`dnl')\n+  match(Set res ($7CompareAndSwap$1 mem (Binary oldval newval)));\n+  ins_cost(`'ifelse($6,Acq,,2*)VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg$5`'ifelse($6,Acq,_acq,)`'ifelse($7,Weak,_weak) $res = $mem, $oldval, $newval\\t# ($3) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::$4, \/*acquire*\/ ifelse($6,Acq,true,false), \/*release*\/ true,\n+               \/*weak*\/ ifelse($7,Weak,true,false), noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+define(`CAS_INSN2',\n+`\n+instruct ifelse($7,Weak,'weakCompare`,'compare`)AndSwap$1$6(iRegINoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n+ifelse($1$6,PAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));),\n+       $1$6,NAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);),\n+       $1,P,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $1,N,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n+       `dnl')\n+  match(Set res ($7CompareAndSwap$1 mem (Binary oldval newval)));\n+  ins_cost(`'ifelse($6,Acq,,2*)VOLATILE_REF_COST);\n+  effect(KILL cr);\n+  format %{\n+    \"cmpxchg$5`'ifelse($6,Acq,_acq,)`'ifelse($7,Weak,_weak) $res = $mem, $oldval, $newval\\t# ($3) if $mem == $oldval then $mem <-- $newval\"\n+    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n+  %}\n+  ins_encode %{\n+    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n+               Assembler::$4, \/*acquire*\/ ifelse($6,Acq,true,false), \/*release*\/ true,\n+               \/*weak*\/ ifelse($7,Weak,true,false), noreg);\n+    __ csetw($res$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+CAS_INSN1(B,    I,  byte,       byte,       b,  ,           )\n+CAS_INSN1(S,    I,  short,      halfword,   s,  ,           )\n+CAS_INSN2(I,    I,  int,        word,       w,  ,           )\n+CAS_INSN2(L,    L,  long,       xword,      ,   ,           )\n+CAS_INSN2(N,    N,  narrow oop, word,       w,  ,           )\n+CAS_INSN2(P,    P,  ptr,        xword,      ,   ,           )\n+dnl\n+CAS_INSN1(B,    I,  byte,       byte,       b,  Acq,        )\n+CAS_INSN1(S,    I,  short,      halfword,   s,  Acq,        )\n+CAS_INSN2(I,    I,  int,        word,       w,  Acq,        )\n+CAS_INSN2(L,    L,  long,       xword,      ,   Acq,        )\n+CAS_INSN2(N,    N,  narrow oop, word,       w,  Acq,        )\n+CAS_INSN2(P,    P,  ptr,        xword,      ,   Acq,        )\n+dnl\n+CAS_INSN1(B,    I,  byte,       byte,       b,  ,       Weak)\n+CAS_INSN1(S,    I,  short,      halfword,   s,  ,       Weak)\n+CAS_INSN2(I,    I,  int,        word,       w,  ,       Weak)\n+CAS_INSN2(L,    L,  long,       xword,      ,   ,       Weak)\n+CAS_INSN2(N,    N,  narrow oop, word,       w,  ,       Weak)\n+CAS_INSN2(P,    P,  ptr,        xword,      ,   ,       Weak)\n+dnl\n+CAS_INSN1(B,    I,  byte,       byte,       b,  Acq,    Weak)\n+CAS_INSN1(S,    I,  short,      halfword,   s,  Acq,    Weak)\n+CAS_INSN2(I,    I,  int,        word,       w,  Acq,    Weak)\n+CAS_INSN2(L,    L,  long,       xword,      ,   Acq,    Weak)\n+CAS_INSN2(N,    N,  narrow oop, word,       w,  Acq,    Weak)\n+CAS_INSN2(P,    P,  ptr,        xword,      ,   Acq,    Weak)\n+dnl\n+dnl\n+dnl\n+dnl ====================== GetAndSet*\n+dnl\n+define(`GAS_INSN1',\n+`\n+instruct getAndSet$1$3(indirect mem, iReg$1 newval, iReg$1NoSp oldval) %{\n+ifelse($1$3,PAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));),\n+       $1$3,NAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);),\n+       $1,P,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $1,N,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $3,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n+       `dnl')\n+  match(Set oldval (GetAndSet$1 mem newval));\n+  ins_cost(`'ifelse($4,Acq,,2*)VOLATILE_REF_COST);\n+  format %{ \"atomic_xchg$2`'ifelse($3,Acq,_acq)  $oldval, $newval, [$mem]\" %}\n+  ins_encode %{\n+    __ atomic_xchg`'ifelse($3,Acq,al)$2($oldval$$Register, $newval$$Register, as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}')dnl\n+dnl\n+GAS_INSN1(I,    w,  )\n+GAS_INSN1(L,    ,   )\n+GAS_INSN1(N,    w,  )\n+GAS_INSN1(P,    ,   )\n+dnl\n+GAS_INSN1(I,    w,  Acq)\n+GAS_INSN1(L,    ,   Acq)\n+GAS_INSN1(N,    w,  Acq)\n+GAS_INSN1(P,    ,   Acq)\n+dnl\n+dnl\n+dnl\n+dnl ====================== GetAndAdd*\n+dnl\n+define(`GAA_INSN1',\n+`\n+instruct getAndAdd$1$4$5$6(indirect mem, `'ifelse($5,NoRes,Universe dummy,iReg$1NoSp newval), `'ifelse($6,Const,imm$1AddSub incr,iReg$2 incr)) %{\n+ifelse($4$5,AcqNoRes,INDENT(predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));),\n+       $5,NoRes,INDENT(predicate(n->as_LoadStore()->result_not_used());),\n+       $4,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n+       `dnl')\n+  match(Set ifelse($5,NoRes,dummy,newval) (GetAndAdd$1 mem incr));\n+  ins_cost(`'ifelse($4,Acq,,2*)VOLATILE_REF_COST`'ifelse($5,NoRes,,+1));\n+  format %{ \"get_and_add$1`'ifelse($4,Acq,_acq) `'ifelse($5,NoRes,noreg,$newval), [$mem], $incr\" %}\n+  ins_encode %{\n+    __ atomic_add`'ifelse($4,Acq,al)$3(`'ifelse($5,NoRes,noreg,$newval$$Register), `'ifelse($6,Const,$incr$$constant,$incr$$Register), as_Register($mem$$base));\n+  %}\n+  ins_pipe(pipe_serial);\n+%}')dnl\n+dnl\n+dnl\n+GAA_INSN1(I,    IorL2I,     w,  ,       ,           )\n+GAA_INSN1(I,    IorL2I,     w,  Acq,    ,           )\n+GAA_INSN1(I,    IorL2I,     w,  ,       NoRes,      )\n+GAA_INSN1(I,    IorL2I,     w,  Acq,    NoRes,      )\n+GAA_INSN1(I,    I,          w,  ,       ,       Const)\n+GAA_INSN1(I,    I,          w,  Acq,    ,       Const)\n+GAA_INSN1(I,    I,          w,  ,       NoRes,  Const)\n+GAA_INSN1(I,    I,          w,  Acq,    NoRes,  Const)\n+dnl\n+GAA_INSN1(L,    L,          ,   ,       ,           )\n+GAA_INSN1(L,    L,          ,   Acq,    ,           )\n+GAA_INSN1(L,    L,          ,   ,       NoRes,      )\n+GAA_INSN1(L,    L,          ,   Acq,    NoRes,      )\n+GAA_INSN1(L,    L,          ,   ,       ,       Const)\n+GAA_INSN1(L,    L,          ,   Acq,    ,       Const)\n+GAA_INSN1(L,    L,          ,   ,       NoRes,  Const)\n+GAA_INSN1(L,    L,          ,   Acq,    NoRes,  Const)\n+dnl\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_atomic_ad.m4","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -1,161 +0,0 @@\n-dnl Copyright (c) 2016, 2021, Red Hat Inc. All rights reserved.\n-dnl DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-dnl\n-dnl This code is free software; you can redistribute it and\/or modify it\n-dnl under the terms of the GNU General Public License version 2 only, as\n-dnl published by the Free Software Foundation.\n-dnl\n-dnl This code is distributed in the hope that it will be useful, but WITHOUT\n-dnl ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-dnl FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-dnl version 2 for more details (a copy is included in the LICENSE file that\n-dnl accompanied this code).\n-dnl\n-dnl You should have received a copy of the GNU General Public License version\n-dnl 2 along with this work; if not, write to the Free Software Foundation,\n-dnl Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-dnl\n-dnl Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-dnl or visit www.oracle.com if you need additional information or have any\n-dnl questions.\n-dnl\n-dnl\n-dnl Process this file with m4 cas.m4 to generate the CAE and wCAS\n-dnl instructions used in aarch64.ad.\n-dnl\n-\n-\/\/ BEGIN This section of the file is automatically generated. Do not edit --------------\n-\n-\/\/ Sundry CAS operations.  Note that release is always true,\n-\/\/ regardless of the memory ordering of the CAS.  This is because we\n-\/\/ need the volatile case to be sequentially consistent but there is\n-\/\/ no trailing StoreLoad barrier emitted by C2.  Unfortunately we\n-\/\/ can't check the type of memory ordering here, so we always emit a\n-\/\/ STLXR.\n-\n-\/\/ This section is generated from cas.m4\n-\n-dnl Return Arg1 with two spaces before it. We need this because m4\n-dnl strips leading spaces from macro args.\n-define(`INDENT', `  $1')dnl\n-dnl\n-define(`CAS_INSN',\n-`\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchange$1$6(iReg$2NoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n-ifelse($1$6,PAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));),\n-       $1$6,NAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);),\n-       $1,P,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n-       $1,N,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n-       $6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n-       `dnl')\n-  match(Set res (CompareAndExchange$1 mem (Binary oldval newval)));\n-  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg$5`'ifelse($6,Acq,_acq,) $res = $mem, $oldval, $newval\\t# ($3, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::$4, \/*acquire*\/ ifelse($6,Acq,true,false), \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-define(`CAS_INSN4',\n-`\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct compareAndExchange$1$7(iReg$2NoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n-ifelse($7,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),`dnl')\n-  match(Set res (CompareAndExchange$1 mem (Binary oldval newval)));\n-  ifelse($7,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n-  effect(TEMP_DEF res, KILL cr);\n-  format %{\n-    \"cmpxchg$5`'ifelse($7,Acq,_acq,) $res = $mem, $oldval, $newval\\t# ($3, weak) if $mem == $oldval then $mem <-- $newval\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::$4, \/*acquire*\/ ifelse($7,Acq,true,false), \/*release*\/ true,\n-               \/*weak*\/ false, $res$$Register);\n-    __ $6($res$$Register, $res$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-CAS_INSN4(B,I,byte,byte,b,sxtbw)\n-CAS_INSN4(S,I,short,halfword,s,sxthw)\n-CAS_INSN(I,I,int,word,w)\n-CAS_INSN(L,L,long,xword)\n-CAS_INSN(N,N,narrow oop,word,w)\n-CAS_INSN(P,P,ptr,xword)\n-dnl\n-CAS_INSN4(B,I,byte,byte,b,sxtbw,Acq)\n-CAS_INSN4(S,I,short,halfword,s,sxthw,Acq)\n-CAS_INSN(I,I,int,word,w,Acq)\n-CAS_INSN(L,L,long,xword,,Acq)\n-CAS_INSN(N,N,narrow oop,word,w,Acq)\n-CAS_INSN(P,P,ptr,xword,,Acq)\n-dnl\n-define(`CAS_INSN2',\n-`\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwap$1$6(iRegINoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n-ifelse($6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),`dnl')\n-  match(Set res (WeakCompareAndSwap$1 mem (Binary oldval newval)));\n-  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg$5`'ifelse($6,Acq,_acq,) $res = $mem, $oldval, $newval\\t# ($3, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::$4, \/*acquire*\/ ifelse($6,Acq,true,false), \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-define(`CAS_INSN3',\n-`\n-\/\/ This pattern is generated automatically from cas.m4.\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct weakCompareAndSwap$1$6(iRegINoSp res, indirect mem, iReg$2 oldval, iReg$2 newval, rFlagsReg cr) %{\n-ifelse($1$6,PAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));),\n-       $1$6,NAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);),\n-       $1,P,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n-       $1,N,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n-       $6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n-       `dnl')\n-  match(Set res (WeakCompareAndSwap$1 mem (Binary oldval newval)));\n-  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n-  effect(KILL cr);\n-  format %{\n-    \"cmpxchg$5`'ifelse($6,Acq,_acq,) $res = $mem, $oldval, $newval\\t# ($3, weak) if $mem == $oldval then $mem <-- $newval\"\n-    \"csetw $res, EQ\\t# $res <-- (EQ ? 1 : 0)\"\n-  %}\n-  ins_encode %{\n-    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,\n-               Assembler::$4, \/*acquire*\/ ifelse($6,Acq,true,false), \/*release*\/ true,\n-               \/*weak*\/ true, noreg);\n-    __ csetw($res$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-CAS_INSN2(B,I,byte,byte,b)\n-CAS_INSN2(S,I,short,halfword,s)\n-CAS_INSN3(I,I,int,word,w)\n-CAS_INSN3(L,L,long,xword)\n-CAS_INSN3(N,N,narrow oop,word,w)\n-CAS_INSN3(P,P,ptr,xword)\n-CAS_INSN2(B,I,byte,byte,b,Acq)\n-CAS_INSN2(S,I,short,halfword,s,Acq)\n-CAS_INSN3(I,I,int,word,w,Acq)\n-CAS_INSN3(L,L,long,xword,,Acq)\n-CAS_INSN3(N,N,narrow oop,word,w,Acq)\n-CAS_INSN3(P,P,ptr,xword,,Acq)\n-dnl\n-\n-\/\/ END This section of the file is automatically generated. Do not edit --------------\n","filename":"src\/hotspot\/cpu\/aarch64\/cas.m4","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"}]}