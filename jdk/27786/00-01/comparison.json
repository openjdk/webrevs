{"files":[{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/g1\/g1FreeIdSet.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/atomicAccess.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/semaphore.inline.hpp\"\n-#include \"runtime\/thread.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-#include \"threadHelper.inline.hpp\"\n-#include \"unittest.hpp\"\n-\n-struct G1FreeIdSet::TestSupport : AllStatic {\n-  static uint next(const G1FreeIdSet& set, uint index) {\n-    assert(index < set._size, \"precondition\");\n-    return set._next[index];\n-  }\n-\n-  static uint start(const G1FreeIdSet& set) { return set._start; }\n-  static uint size(const G1FreeIdSet& set) { return set._size; }\n-  static uintx mask(const G1FreeIdSet& set) { return set._head_index_mask; }\n-  static uintx head(const G1FreeIdSet& set) { return AtomicAccess::load(&set._head); }\n-\n-  static uint head_index(const G1FreeIdSet& set, uintx head) {\n-    return set.head_index(head);\n-  }\n-};\n-\n-typedef G1FreeIdSet::TestSupport TestSupport;\n-\n-TEST_VM(G1FreeIdSetTest, initial_state) {\n-  const uint start = 5;\n-  const uint size = 4;\n-  G1FreeIdSet set(start, size);\n-\n-  ASSERT_EQ(start, TestSupport::start(set));\n-  ASSERT_EQ(size, TestSupport::size(set));\n-  ASSERT_EQ(7u, TestSupport::mask(set));\n-  ASSERT_EQ(0u, TestSupport::head(set));\n-  for (uint i = 0; i < size; ++i) {\n-    ASSERT_EQ(i + 1, TestSupport::next(set, i));\n-  }\n-}\n-\n-TEST_VM(G1FreeIdSetTest, non_blocking_ops) {\n-  const uint start = 5;\n-  const uint size = 3;\n-  G1FreeIdSet set(start, size);\n-\n-  ASSERT_EQ(5u, set.claim_par_id());\n-  ASSERT_EQ(1u, TestSupport::head_index(set, TestSupport::head(set)));\n-  ASSERT_EQ(6u, set.claim_par_id());\n-  ASSERT_EQ(2u, TestSupport::head_index(set, TestSupport::head(set)));\n-  ASSERT_EQ(7u, set.claim_par_id());\n-  ASSERT_EQ(3u, TestSupport::head_index(set, TestSupport::head(set)));\n-\n-  set.release_par_id(5u);\n-  set.release_par_id(6u);\n-  ASSERT_EQ(6u, set.claim_par_id());\n-  ASSERT_EQ(5u, set.claim_par_id());\n-}\n-\n-class TestG1FreeIdSetThread : public JavaTestThread {\n-  G1FreeIdSet* _set;\n-  volatile size_t* _total_allocations;\n-  volatile bool* _continue_running;\n-  size_t _allocations;\n-  uint _thread_number;\n-\n-public:\n-  TestG1FreeIdSetThread(uint thread_number,\n-                        Semaphore* post,\n-                        G1FreeIdSet* set,\n-                        volatile size_t* total_allocations,\n-                        volatile bool* continue_running) :\n-    JavaTestThread(post),\n-    _set(set),\n-    _total_allocations(total_allocations),\n-    _continue_running(continue_running),\n-    _allocations(0),\n-    _thread_number(thread_number)\n-  {}\n-\n-  virtual void main_run() {\n-    while (AtomicAccess::load_acquire(_continue_running)) {\n-      uint id = _set->claim_par_id();\n-      _set->release_par_id(id);\n-      ++_allocations;\n-      ThreadBlockInVM tbiv(this); \/\/ Safepoint check.\n-    }\n-    tty->print_cr(\"%u allocations: %zu\", _thread_number, _allocations);\n-    AtomicAccess::add(_total_allocations, _allocations);\n-  }\n-};\n-\n-TEST_VM(G1FreeIdSetTest, stress) {\n-  const uint start = 5;\n-  const uint size = 3;\n-  const uint nthreads = size + 1;\n-  const uint milliseconds_to_run = 1000;\n-\n-  Semaphore post;\n-  volatile size_t total_allocations = 0;\n-  volatile bool continue_running = true;\n-\n-  G1FreeIdSet set(start, size);\n-\n-  TestG1FreeIdSetThread* threads[nthreads] = {};\n-  for (uint i = 0; i < nthreads; ++i) {\n-    threads[i] = new TestG1FreeIdSetThread(i,\n-                                           &post,\n-                                           &set,\n-                                           &total_allocations,\n-                                           &continue_running);\n-    threads[i]->doit();\n-  }\n-\n-  JavaThread* this_thread = JavaThread::current();\n-  tty->print_cr(\"Stressing G1FreeIdSet for %u ms\", milliseconds_to_run);\n-  {\n-    ThreadInVMfromNative invm(this_thread);\n-    this_thread->sleep(milliseconds_to_run);\n-  }\n-  AtomicAccess::release_store(&continue_running, false);\n-  for (uint i = 0; i < nthreads; ++i) {\n-    ThreadInVMfromNative invm(this_thread);\n-    post.wait_with_safepoint_check(this_thread);\n-  }\n-  tty->print_cr(\"total allocations: %zu\", total_allocations);\n-  tty->print_cr(\"final free list: \");\n-  uint ids[size] = {};\n-  for (uint i = 0; i < size; ++i) {\n-    uint id = set.claim_par_id();\n-    uint index = id - TestSupport::start(set);\n-    ASSERT_LT(index, TestSupport::size(set));\n-    tty->print_cr(\"  %u: %u\", i, index);\n-  }\n-  ASSERT_EQ(size, TestSupport::head_index(set, TestSupport::head(set)));\n-}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1FreeIdSet.cpp","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"}]}