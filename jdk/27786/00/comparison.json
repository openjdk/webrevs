{"files":[{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/g1\/g1FreeIdSet.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/atomicAccess.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-G1FreeIdSet::G1FreeIdSet(uint start, uint size) :\n-  _sem(size),          \/\/ counting semaphore for available ids\n-  _next(nullptr),      \/\/ array of \"next\" indices\n-  _start(start),       \/\/ first id value\n-  _size(size),         \/\/ number of available ids\n-  _head_index_mask(0), \/\/ mask for extracting index from a _head value.\n-  _head(0)             \/\/ low part: index; high part: update counter\n-{\n-  assert(size != 0, \"precondition\");\n-  assert(start <= (UINT_MAX - size),\n-         \"start (%u) + size (%u) overflow: \", start, size);\n-  \/\/ 2^shift must be greater than size. Equal is not permitted, because\n-  \/\/ size is the \"end of list\" value, and can be the index part of _head.\n-  uint shift = log2i(size) + 1;\n-  assert(shift <= (BitsPerWord \/ 2), \"excessive size %u\", size);\n-  _head_index_mask = (uintx(1) << shift) - 1;\n-  assert(size <= _head_index_mask, \"invariant\");\n-  _next = NEW_C_HEAP_ARRAY(uint, size, mtGC);\n-  for (uint i = 0; i < size; ++i) {\n-    _next[i] = i + 1;\n-  }\n-}\n-\n-G1FreeIdSet::~G1FreeIdSet() {\n-  FREE_C_HEAP_ARRAY(uint, _next);\n-}\n-\n-uint G1FreeIdSet::head_index(uintx head) const {\n-  return checked_cast<uint>(head & _head_index_mask);\n-}\n-\n-uintx G1FreeIdSet::make_head(uint index, uintx old_head) const {\n-  \/\/ Include incremented old update counter to avoid ABA problem.\n-  return index | ((old_head & ~_head_index_mask) + 1 + _head_index_mask);\n-}\n-\n-const uint Claimed = UINT_MAX;\n-\n-uint G1FreeIdSet::claim_par_id() {\n-  _sem.wait();\n-  \/\/ Semaphore gate permits passage by no more than the number of\n-  \/\/ available ids, so there must be one that we can claim.  But there\n-  \/\/ may be multiple threads trying to claim ids at the same time.\n-  uintx old_head = AtomicAccess::load(&_head);\n-  uint index;\n-  while (true) {\n-    index = head_index(old_head);\n-    assert(index < _size, \"invariant\");\n-    uintx new_head = make_head(_next[index], old_head);\n-    new_head = AtomicAccess::cmpxchg(&_head, old_head, new_head);\n-    if (new_head == old_head) break;\n-    old_head = new_head;\n-  }\n-  DEBUG_ONLY(_next[index] = Claimed;)\n-  return _start + index;\n-}\n-\n-void G1FreeIdSet::release_par_id(uint id) {\n-  uint index = id - _start;\n-  assert(index < _size, \"invalid id %u\", id);\n-  assert(_next[index] == Claimed, \"precondition\");\n-  uintx old_head = AtomicAccess::load(&_head);\n-  while (true) {\n-    _next[index] = head_index(old_head);\n-    uintx new_head = make_head(index, old_head);\n-    new_head = AtomicAccess::cmpxchg(&_head, old_head, new_head);\n-    if (new_head == old_head) break;\n-    old_head = new_head;\n-  }\n-  \/\/ Now that id has been released, permit another thread through the gate.\n-  _sem.signal();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FreeIdSet.cpp","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1FREEIDSET_HPP\n-#define SHARE_GC_G1_G1FREEIDSET_HPP\n-\n-#include \"runtime\/semaphore.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/\/ Represents a set of small integer ids, from which elements can be\n-\/\/ temporarily allocated for exclusive use.  The ids are in a\n-\/\/ contiguous range from 'start' to 'start + size'.  Used to obtain a\n-\/\/ distinct worker_id value for a mutator thread that doesn't normally\n-\/\/ have such an id.\n-class G1FreeIdSet {\n-  Semaphore _sem;\n-  uint* _next;\n-  uint _start;\n-  uint _size;\n-  uintx _head_index_mask;\n-  volatile uintx _head;\n-\n-  uint head_index(uintx head) const;\n-  uintx make_head(uint index, uintx old_head) const;\n-\n-  NONCOPYABLE(G1FreeIdSet);\n-\n-public:\n-  G1FreeIdSet(uint start, uint size);\n-  ~G1FreeIdSet();\n-\n-  \/\/ Returns an unclaimed parallel id (waiting for one to be released if\n-  \/\/ necessary).  Must not safepoint while holding a claimed id.\n-  uint claim_par_id();\n-\n-  void release_par_id(uint id);\n-\n-  struct TestSupport;           \/\/ For unit test access.\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1FREEIDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FreeIdSet.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"}]}