{"files":[{"patch":"@@ -135,3 +135,0 @@\n-  assert(action != PlaceholderTable::LOAD_INSTANCE || !EnableWaitForParallelLoad || seen == nullptr,\n-         \"Only one LOAD_INSTANCE allowed at a time\");\n-\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -491,44 +491,0 @@\n-\/\/ We only get here if this thread finds that another thread\n-\/\/ has already claimed the placeholder token for the current operation,\n-\/\/ but that other thread either never owned or gave up the\n-\/\/ object lock\n-\/\/ Waits on SystemDictionary_lock to indicate placeholder table updated\n-\/\/ On return, caller must recheck placeholder table state\n-\/\/\n-\/\/ We only get here if\n-\/\/  1) custom classLoader, i.e. not bootstrap classloader\n-\/\/  2) custom classLoader has broken the class loader objectLock\n-\/\/     so another thread got here in parallel\n-\/\/\n-\/\/ lockObject must be held.\n-\/\/ Complicated dance due to lock ordering:\n-\/\/ Must first release the classloader object lock to\n-\/\/ allow initial definer to complete the class definition\n-\/\/ and to avoid deadlock\n-\/\/ Reclaim classloader lock object with same original recursion count\n-\/\/ Must release SystemDictionary_lock after notify, since\n-\/\/ class loader lock must be claimed before SystemDictionary_lock\n-\/\/ to prevent deadlocks\n-\/\/\n-\/\/ The notify allows applications that did an untimed wait() on\n-\/\/ the classloader object lock to not hang.\n-static void double_lock_wait(JavaThread* thread, Handle lockObject) {\n-  assert_lock_strong(SystemDictionary_lock);\n-\n-  assert(EnableWaitForParallelLoad,\n-         \"Only called when enabling legacy parallel class loading logic \"\n-         \"for non-parallel capable class loaders\");\n-  assert(lockObject() != nullptr, \"lockObject must be non-null\");\n-  bool calledholdinglock\n-      = ObjectSynchronizer::current_thread_holds_lock(thread, lockObject);\n-  assert(calledholdinglock, \"must hold lock for notify\");\n-  assert(!is_parallelCapable(lockObject), \"lockObject must not be parallelCapable\");\n-  \/\/ These don't throw exceptions.\n-  ObjectSynchronizer::notifyall(lockObject, thread);\n-  intx recursions = ObjectSynchronizer::complete_exit(lockObject, thread);\n-  SystemDictionary_lock->wait();\n-  SystemDictionary_lock->unlock();\n-  ObjectSynchronizer::reenter(lockObject, recursions, thread);\n-  SystemDictionary_lock->lock();\n-}\n-\n@@ -556,3 +512,1 @@\n-\/\/ wait for parallel class loading and to check for circularity error for Xcomp when loading\n-\/\/ signature classes.\n-\/\/ parallelCapable class loaders do NOT wait for parallel loads to complete\n+\/\/ wait for parallel class loading and\/or to check for circularity error for Xcomp when loading.\n@@ -563,7 +517,5 @@\n-\/\/ For bootstrap and non-parallelCapable class loaders, check and wait for\n-\/\/ another thread to complete loading this class.\n-InstanceKlass* SystemDictionary::handle_parallel_loading(JavaThread* current,\n-                                                         Symbol* name,\n-                                                         ClassLoaderData* loader_data,\n-                                                         Handle lockObject,\n-                                                         bool* throw_circularity_error) {\n+static InstanceKlass* handle_parallel_loading(JavaThread* current,\n+                                              Symbol* name,\n+                                              ClassLoaderData* loader_data,\n+                                              bool must_wait_for_class_loading,\n+                                              bool* throw_circularity_error) {\n@@ -579,1 +531,1 @@\n-    } else {\n+    } else if (must_wait_for_class_loading) {\n@@ -585,20 +537,3 @@\n-        \/\/ We only get here if the application has released the\n-        \/\/ classloader lock when another thread was in the middle of loading a\n-        \/\/ superclass\/superinterface for this class, and now\n-        \/\/ this thread is also trying to load this class.\n-        \/\/ To minimize surprises, the first thread that started to\n-        \/\/ load a class should be the one to complete the loading\n-        \/\/ with the classfile it initially expected.\n-        \/\/ This logic has the current thread wait once it has done\n-        \/\/ all the superclass\/superinterface loading it can, until\n-        \/\/ the original thread completes the class loading or fails\n-        \/\/ If it completes we will use the resulting InstanceKlass\n-        \/\/ which we will find below in the systemDictionary.\n-\n-        if (lockObject.is_null()) {\n-          SystemDictionary_lock->wait();\n-        } else if (EnableWaitForParallelLoad) {\n-          double_lock_wait(current, lockObject);\n-        } else {\n-          return nullptr;\n-        }\n+        \/\/ LOAD_INSTANCE placeholders are used to implement parallel capable class loading\n+        \/\/ for the bootclass loader.\n+        SystemDictionary_lock->wait();\n@@ -720,7 +655,3 @@\n-    \/\/    There should be no need for need for LOAD_INSTANCE, except:\n-    \/\/ case 4. traditional class loaders that break the classloader object lock\n-    \/\/    as a legacy deadlock workaround. Detection of this case requires that\n-    \/\/    this check is done while holding the classloader object lock,\n-    \/\/    and that lock is still held when calling classloader's loadClass.\n-    \/\/    For these classloaders, we ensure that the first requestor\n-    \/\/    completes the load and other requestors wait for completion.\n+    \/\/    There should be no need for need for LOAD_INSTANCE for mutual exclusion,\n+    \/\/    except the LOAD_INSTANCE placeholder is used to detect CCE for -Xcomp.\n+    \/\/    TODO: should also be used to detect CCE for parallel capable class loaders but it's not.\n@@ -733,1 +664,1 @@\n-                                               lockObject,\n+                                               class_loader.is_null(),\n@@ -744,2 +675,1 @@\n-          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread,\n-          \/\/ and check for ClassCircularityError with -Xcomp.\n+          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":15,"deletions":85,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -305,6 +305,0 @@\n-  static InstanceKlass* handle_parallel_loading(JavaThread* current,\n-                                                Symbol* name,\n-                                                ClassLoaderData* loader_data,\n-                                                Handle lockObject,\n-                                                bool* throw_circularity_error);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -542,1 +542,0 @@\n-  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -551,0 +550,1 @@\n+  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -691,4 +691,0 @@\n-  product(bool, EnableWaitForParallelLoad, false,                           \\\n-          \"(Deprecated) Enable legacy parallel classloading logic for \"     \\\n-          \"class loaders not registered as parallel capable\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1343,4 +1343,0 @@\n-\n-\/\/ -----------------------------------------------------------------------------\n-\/\/ Class Loader deadlock handling.\n-\/\/\n@@ -1348,1 +1344,0 @@\n-\/\/ complete_exit\/reenter operate as a wait without waiting\n@@ -1373,14 +1368,0 @@\n-\/\/ reenter() enters a lock and sets recursion count\n-\/\/ complete_exit\/reenter operate as a wait without waiting\n-bool ObjectMonitor::reenter(intx recursions, JavaThread* current) {\n-\n-  guarantee(owner_raw() != current, \"reenter already owner\");\n-  if (!enter(current)) {\n-    return false;\n-  }\n-  \/\/ Entered the monitor.\n-  guarantee(_recursions == 0, \"reenter recursion\");\n-  _recursions = recursions;\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -324,1 +324,0 @@\n-  bool      reenter(intx recursions, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -578,36 +578,0 @@\n-\/\/ -----------------------------------------------------------------------------\n-\/\/ Class Loader  support to workaround deadlocks on the class loader lock objects\n-\/\/ Also used by GC\n-\/\/ complete_exit()\/reenter() are used to wait on a nested lock\n-\/\/ i.e. to give up an outer lock completely and then re-enter\n-\/\/ Used when holding nested locks - lock acquisition order: lock1 then lock2\n-\/\/  1) complete_exit lock1 - saving recursion count\n-\/\/  2) wait on lock2\n-\/\/  3) when notified on lock2, unlock lock2\n-\/\/  4) reenter lock1 with original recursion count\n-\/\/  5) lock lock2\n-\/\/ NOTE: must use heavy weight monitor to handle complete_exit\/reenter()\n-intx ObjectSynchronizer::complete_exit(Handle obj, JavaThread* current) {\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n-  intx recur_count = monitor->complete_exit(current);\n-  current->dec_held_monitor_count(recur_count + 1);\n-  return recur_count;\n-}\n-\n-\/\/ NOTE: must use heavy weight monitor to handle complete_exit\/reenter()\n-void ObjectSynchronizer::reenter(Handle obj, intx recursions, JavaThread* current) {\n-  \/\/ An async deflation can race after the inflate() call and before\n-  \/\/ reenter() -> enter() can make the ObjectMonitor busy. reenter() ->\n-  \/\/ enter() returns false if we have lost the race to async deflation\n-  \/\/ and we simply try again.\n-  while (true) {\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n-    if (monitor->reenter(recursions, current)) {\n-      current->inc_held_monitor_count(recursions + 1);\n-      return;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -157,6 +157,0 @@\n-  \/\/ used by classloading to free classloader object lock,\n-  \/\/ wait on an internal lock, and reclaim original lock\n-  \/\/ with original recursion count\n-  static intx complete_exit(Handle obj, JavaThread* current);\n-  static void reenter (Handle obj, intx recursions, JavaThread* current);\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @run main\/othervm -XX:+EnableWaitForParallelLoad ParallelSuperTest -parallel\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/ParallelSuperTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}