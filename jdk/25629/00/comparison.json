{"files":[{"patch":"@@ -1,217 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package build.tools.commentchecker;\n-\n-import java.io.*;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * CommentChecker is a utility which verifies that there aren't\n- * \"\/*\" or \"\/**\" tokens inside any comment blocks in one or more\n- * Java source files.  Although it is legal to have beginning\n- * comment delimiters inside of a comment block (JLS 3.7), there\n- * have been errors where a dropped end-comment delimiter in a\n- * method'd doc-comment effectively \"erased\" that method.  We're\n- * therefore restricting beginning comment delimiters inside of\n- * JDK source (at least the Swing team is for their portion).\n- *\n- * To scan a few files, run CommentChecker as follows:\n- *\n- *     java CommentChecker file1.java file2.java ...\n- *\n- * There are too many Java files in the JDK base for most shells\n- * to support listing in a single command, so CommentChecker also\n- * supports cpio and tar-style filename passing, where \"-\"\n- * indicates that the list of files is read from stdin:\n- *\n- *     find . -name SCCS -prune -o -name '*.java' -print | \\\n- *        java CommentChecker -\n- *\n- * @author Thomas Ball\n- *\/\n-public class CommentChecker {\n-\n-    static int errors = 0;\n-\n-    \/\/ Turn on this flag and recompile to dump this tool's state changes.\n-    static final boolean verbose = false;\n-\n-    static void check(String fileName) {\n-        BufferedReader in = null;\n-        boolean inComment = false;\n-        boolean inLineComment = false;\n-        boolean inQuote = false;\n-        boolean inEscape = false;\n-        int lastChar = -1;\n-        int lineNumber = 1;\n-\n-        try {\n-            in = new BufferedReader(new FileReader(fileName));\n-            while (true) {\n-                int ch = in.read();\n-                if (ch == -1) {\n-                    if (inQuote || inComment) {\n-                        error(fileName + \": premature EOF.\");\n-                    }\n-                    return;\n-                }\n-\n-                if (verbose) {\n-                    System.out.print((char)ch);\n-                }\n-\n-                switch (ch) {\n-                  case '\\n':\n-                    if (inQuote && !inComment) {\n-                        error(fileName + \":\" + lineNumber +\n-                              \" dangling quote.\");\n-                        inQuote = false;\n-                    }\n-                    if (inLineComment) {\n-                        inLineComment = false;\n-                        if (verbose) {\n-                            System.out.println(\"\\ninLineComment=false\");\n-                        }\n-                    }\n-                    lineNumber++;\n-                    break;\n-\n-                  case '\\\"':\n-                    if (!inComment && !inLineComment && !inEscape &&\n-                        !(!inQuote && lastChar == '\\'')) {\n-                        inQuote = !inQuote;\n-                        if (verbose) {\n-                            System.out.println(\"\\ninQuote=\" + inQuote);\n-                        }\n-                    }\n-                    break;\n-\n-                  case '\/':\n-                    if (!inQuote && lastChar == '*') {\n-                        inComment = false;\n-                        if (verbose) {\n-                            System.out.println(\"\\ninComment=false\");\n-                        }\n-                    }\n-                    if (!inQuote && lastChar == '\/') {\n-                        inLineComment = true;\n-                        if (verbose) {\n-                            System.out.println(\"\\ninLineComment=true\");\n-                        }\n-                    }\n-                    break;\n-\n-                  case '*':\n-                    if (!inQuote && lastChar == '\/') {\n-                        if (inComment) {\n-                            error(fileName + \":\" + lineNumber +\n-                                  \" nested comment.\");\n-                        }\n-                        inComment = true;\n-                        if (verbose) {\n-                            System.out.println(\"\\ninComment=true\");\n-                        }\n-                    }\n-                    break;\n-                }\n-\n-                lastChar = ch;\n-\n-                \/\/ Watch for escaped characters, such as '\\\"'.\n-                if (ch == '\\\\' && !inEscape) {\n-                    inEscape = true;\n-                    if (verbose) {\n-                        System.out.println(\"\\ninEscape set\");\n-                    }\n-                } else {\n-                    inEscape = false;\n-                }\n-            }\n-        } catch (FileNotFoundException fnfe) {\n-            error(fileName + \" not found.\");\n-        } catch (IOException ioe) {\n-            error(fileName + \": \" + ioe);\n-        } finally {\n-            if (in != null) {\n-                try {\n-                    in.close();\n-                } catch (IOException e) {\n-                    error(fileName + \": \" + e);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void error(String description) {\n-        System.err.println(description);\n-        errors++;\n-    }\n-\n-    static void exit() {\n-        if (errors != 1) {\n-            System.out.println(\"There were \" + errors + \" errors.\");\n-        } else {\n-            System.out.println(\"There was 1 error.\");\n-        }\n-        System.exit(errors);\n-    }\n-\n-    public static void main(String[] args) {\n-        if (args.length == 0) {\n-            System.err.println(\"usage: java CommentChecker [-] file.java ...\");\n-            System.exit(1);\n-        }\n-\n-        if (args.length == 1 && args[0].equals(\"-\")) {\n-            \/* read filenames in one per line from stdin, ala cpio.\n-             * This is good for checking the whole JDK in one pass:\n-             *\n-             *    cpio . -name SCCS -prune -o -name '*.java' -print | \\\n-             *        java CommentChecker -\n-             *\/\n-            try {\n-                BufferedReader br =\n-                    new BufferedReader(new InputStreamReader(System.in));\n-                while (true) {\n-                    String fileName = br.readLine();\n-                    if (fileName == null) {\n-                        break;\n-                    }\n-                    check(fileName);\n-                }\n-                br.close();\n-            } catch (Exception e) {\n-                error(\"error reading System.in: \" + e);\n-            }\n-        } else {\n-            for (int i = 0; i < args.length; i++) {\n-                check(args[i]);\n-            }\n-        }\n-\n-        exit();\n-    }\n-}\n","filename":"src\/utils\/src\/build\/tools\/commentchecker\/CommentChecker.java","additions":0,"deletions":217,"binary":false,"changes":217,"status":"deleted"},{"patch":"@@ -1,275 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package build.tools.dirdiff;\n-\n-import java.io.File;\n-import java.util.TreeSet;\n-\n-public class DirDiff implements Runnable {\n-    private static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n-    private static final boolean traversSccsDirs;\n-    private static final boolean recurseExtraDirs;\n-    private static final boolean verboseMode;\n-    private static final boolean checkSizes;\n-    private static long SizeTolerance = 0;\n-    private File goldenDir = null;\n-    private File testDir = null;\n-\n-    \/\/ static initializer:\n-      static {\n-          String traversePropertyValue = System.getProperty(\"sccs\");\n-          traversSccsDirs = (traversePropertyValue != null &&\n-                              traversePropertyValue.toLowerCase().equals(\"true\"))? true : false;\n-          if (traversSccsDirs) {\n-              System.err.println(\"traversing SCCS directories...\");\n-          }\n-\n-          String verbosePropertyValue = System.getProperty(\"verbose\");\n-          verboseMode = (verbosePropertyValue != null &&\n-                              verbosePropertyValue.toLowerCase().equals(\"true\"))? true : false;\n-          if (verboseMode) {\n-              System.err.println(\"verbose mode truned on...\");\n-          }\n-\n-          String noRecurseExtraDirsPropertyValue = System.getProperty(\"recurse\");\n-          recurseExtraDirs = (noRecurseExtraDirsPropertyValue != null &&\n-                              noRecurseExtraDirsPropertyValue.toLowerCase().equals(\"true\"))? true : false;\n-          if (recurseExtraDirs) {\n-              System.err.println(\"recursing extra directories...\");\n-          }\n-\n-          String sizeToleranceValue = System.getProperty(\"sizeTolerance\");\n-          checkSizes = (sizeToleranceValue != null);\n-          if (checkSizes) {\n-              try {\n-                  SizeTolerance = Long.parseLong(sizeToleranceValue);\n-              }\n-              catch (NumberFormatException e) {\n-                  System.err.println(\"Invlalid sizeTolerance value: \" + sizeToleranceValue);\n-                  System.err.println(\"Expecting a long value.  Exiting.\");\n-                  System.exit(1);\n-              }\n-              System.err.println(\"checking matching files for size differences of at least \" + SizeTolerance);\n-          }\n-      }\n-\n-  public DirDiff(File inGoldenDir, File inTestDir) {\n-      goldenDir = inGoldenDir;\n-      testDir = inTestDir;\n-  }\n-\n-  private void whatToDoWithMatchingFiles(File goldenChild, File testChild) {\n-      if (verboseMode) {\n-          System.out.println(\"Files Match:\\t\" + goldenChild.getAbsolutePath() +\n-                             \" and \" + testChild.getAbsolutePath());\n-      }\n-      if (checkSizes) {\n-          \/\/ compare file sizes...\n-          long goldenLength = 0;\n-          long testLength = 0;\n-          try {\n-              goldenLength = goldenChild.length();\n-              testLength = testChild.length();\n-          }\n-          catch (Exception e) {\n-              System.err.println(\"Error: exception thrown and caught:\");\n-              e.printStackTrace();\n-          }\n-          if (java.lang.Math.abs(goldenLength - testLength) > SizeTolerance) {\n-              if (goldenLength > testLength) {\n-                  System.out.println(\"File short [\" + (testLength - goldenLength) + \"]:\\t\" + testChild.getAbsolutePath());\n-              } else {\n-                  System.out.println(\"File long [\" + (testLength - goldenLength) + \"]:\\t\" + testChild.getAbsolutePath());\n-              }\n-          }\n-      }\n-  }\n-\n-\n-  private void whatToDoWithMatchingDirs(File goldenChild, File testChild) {\n-      if (verboseMode) {\n-          System.out.println(\"Dirs Match:\\t\" + goldenChild.getAbsolutePath() +\n-                             \" and \" + testChild.getAbsolutePath());\n-      }\n-  }\n-\n-  private void whatToDoWithMissingFiles(File missingFile) {\n-      long length = 0;\n-      try {\n-          length = missingFile.length();\n-      }\n-      catch (Exception e) {\n-          System.err.println(\"Error: exception thrown and caught:\");\n-          e.printStackTrace();\n-      }\n-\n-      System.out.println(\"Missing File [\" + length + \"]:\\t\" + missingFile.getAbsolutePath());\n-  }\n-\n-  private void whatToDoWithExtraFiles(File extraFile) {\n-      long length = 0;\n-      try {\n-          length = extraFile.length();\n-      }\n-      catch (Exception e) {\n-          System.err.println(\"Error: exception thrown and caught:\");\n-          e.printStackTrace();\n-      }\n-\n-      System.out.println(\"Extra File [\" + length + \"]:\\t\" + extraFile.getAbsolutePath());\n-  }\n-\n-  private void whatToDoWithMissingDirs(File missingDir) {\n-      System.out.println(\"Missing Dir:\\t\" + missingDir.getAbsolutePath());\n-  }\n-\n-  private void whatToDoWithExtraDirs(File extraDir) {\n-      System.out.println(\"Extra Dir:\\t\" + extraDir.getAbsolutePath());\n-  }\n-\n-  private void whatToDoWithNonMatchingChildren(File goldenChild, File testChild) {\n-      System.out.println(\"Type Mismatch:\\t\" + goldenChild.getAbsolutePath() + \" is a \" +\n-                         (goldenChild.isDirectory()? \"directory\" : \"file\") +\n-                         \" and \" + testChild.getAbsolutePath() + \" is a \" +\n-                         (testChild.isDirectory()? \"directory\" : \"file\"));\n-  }\n-\n-  public void run() {\n-      File[] currentTestDirs = null;\n-      if (testDir != null) {\n-          currentTestDirs = testDir.listFiles();\n-      }\n-\n-      File[] currentGoldenDirs = null;\n-      TreeSet<String> goldDirSet = new TreeSet<>();\n-      if (goldenDir != null) {\n-          currentGoldenDirs = goldenDir.listFiles();\n-          for (int i=0; i<currentGoldenDirs.length; i++) {\n-              goldDirSet.add(currentGoldenDirs[i].getName());\n-          }\n-      }\n-\n-      \/\/ now go through the list of members\n-      if (currentGoldenDirs != null) {\n-          for (int i=0; i<currentGoldenDirs.length; i++) {\n-              File newGoldenDir = currentGoldenDirs[i];\n-\n-              \/\/ do not traverse SCCS directories...\n-              if (!(newGoldenDir.getAbsolutePath().endsWith(\"SCCS\")) || traversSccsDirs ) {\n-                  \/\/ start a compare of this child and the like-named test child...\n-                  File newTestDir = new File(testDir.getAbsolutePath() + FILE_SEPARATOR +\n-                                             newGoldenDir.getName());\n-\n-                  if (newTestDir.exists()) {\n-                      if (newGoldenDir.isDirectory()) {\n-                          if (newTestDir.isDirectory()) {\n-                              whatToDoWithMatchingDirs(newGoldenDir, newTestDir);\n-                              Thread t = new Thread( new DirDiff(newGoldenDir, newTestDir));\n-                              t.start();\n-                          } else {\n-                              whatToDoWithNonMatchingChildren(newGoldenDir, newTestDir);\n-                          }\n-                      } else { \/\/ of... newGoldenDir.isDirectory()...\n-                          if (newTestDir.isDirectory()) {\n-                              whatToDoWithNonMatchingChildren(newGoldenDir, newTestDir);\n-                          }\n-                           whatToDoWithMatchingFiles(newGoldenDir, newTestDir);\n-                      }\n-                  } else { \/\/ of... newTestDir.exists()...\n-                      if (newGoldenDir.isDirectory()) {\n-                          whatToDoWithMissingDirs(newTestDir);\n-                          Thread t = new Thread( new DirDiff(newGoldenDir, newTestDir));\n-                          t.start();\n-                      } else {\n-                          whatToDoWithMissingFiles(newTestDir);\n-                      }\n-                  }\n-              }\n-          }\n-      }\n-\n-      \/\/ look for extra test objs...\n-      if (currentTestDirs != null) {\n-          for (int i=0; i<currentTestDirs.length; i++) {\n-              \/\/ do not traverse SCCS directories...\n-              if (!(currentTestDirs[i].getAbsolutePath().endsWith(\"SCCS\")) || traversSccsDirs ) {\n-                  if (!goldDirSet.contains(currentTestDirs[i].getName())) {\n-                      if (currentTestDirs[i].isDirectory()) {\n-                          whatToDoWithExtraDirs(currentTestDirs[i]);\n-                          if (recurseExtraDirs) {\n-                              Thread t = new Thread( new DirDiff( null, currentTestDirs[i]));\n-                              t.start();\n-                          }\n-                      } else {\n-                          whatToDoWithExtraFiles(currentTestDirs[i]);\n-                      }\n-                  }\n-              }\n-          }\n-      }\n-  }\n-\n-  public static void main(String[] args) {\n-      if (args.length != 2) {\n-          System.err.println(\"You must provide two directory names on the command line.\");\n-          System.err.println(\"Usage:\\tDirDiff dir1 dir2\");\n-          System.err.println(\"\\tJava Runtime Properties (set to \\\"true\\\"):\");\n-          System.err.println(\"\\t\\tsccs\\trecurse SCCS directories\");\n-          System.err.println(\"\\t\\tverbose\\tprint verbose diagnostics\");\n-          System.err.println(\"\\t\\trecurse\\trecursing extra directories showing extra files\");\n-          System.err.println(\"\\t\\tsizeTolerance\\tset tolerance for size differences - default is infinite\");\n-\n-          System.exit(0);\n-      } else {\n-          File golden = new File(args[0]);\n-          File test = new File(args[1]);\n-\n-          if (!golden.exists()) {\n-              System.err.println(\"Error: path \" + golden.getAbsolutePath() +\n-                                 \" does not exist. Skipping.\");\n-              System.exit(0);\n-          }\n-          if (!golden.isDirectory()) {\n-              System.err.println(\"Error: path \" + golden.getAbsolutePath() +\n-                                 \" must be a directory. Skipping.\");\n-              System.exit(0);\n-          }\n-          if (!test.exists()) {\n-              System.err.println(\"Error: path \" + test.getAbsolutePath() +\n-                                 \" does not exist. Skipping.\");\n-              System.exit(0);\n-          }\n-          if (!test.isDirectory()) {\n-              System.err.println(\"Error: path \" + test.getAbsolutePath() +\n-                                 \" must be a directory. Skipping.\");\n-              System.exit(0);\n-          }\n-\n-          Thread t = new Thread( new DirDiff(golden, test));\n-          t.start();\n-      }\n-  }\n-}\n","filename":"src\/utils\/src\/build\/tools\/dirdiff\/DirDiff.java","additions":0,"deletions":275,"binary":false,"changes":275,"status":"deleted"}]}