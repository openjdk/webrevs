{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-#include \"gc\/shared\/blockOffsetTable.inline.hpp\"\n+#include \"gc\/serial\/serialBlockOffsetTable.inline.hpp\"\n+#include \"gc\/shared\/blockOffsetTable.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"logging\/log.hpp\"\n@@ -31,1 +33,0 @@\n-#include \"logging\/log.hpp\"\n@@ -36,12 +37,0 @@\n-uint BOTConstants::_log_card_size = 0;\n-uint BOTConstants::_log_card_size_in_words = 0;\n-uint BOTConstants::_card_size = 0;\n-uint BOTConstants::_card_size_in_words = 0;\n-\n-void BOTConstants::initialize_bot_size(uint card_shift) {\n-  _log_card_size =  card_shift;\n-  _log_card_size_in_words = _log_card_size - LogHeapWordSize;\n-  _card_size = 1 << _log_card_size;\n-  _card_size_in_words = 1 << _log_card_size_in_words;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"previous_filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.cpp","status":"copied"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_GC_SHARED_BLOCKOFFSETTABLE_HPP\n-#define SHARE_GC_SHARED_BLOCKOFFSETTABLE_HPP\n+#ifndef SHARE_GC_SERIAL_SERIALBLOCKOFFSETTABLE_HPP\n+#define SHARE_GC_SERIAL_SERIALBLOCKOFFSETTABLE_HPP\n@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/blockOffsetTable.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"gc\/shared\/cardTable.hpp\"\n@@ -51,38 +52,0 @@\n-class BOTConstants : public AllStatic {\n-  static uint _log_card_size;\n-  static uint _log_card_size_in_words;\n-  static uint _card_size;\n-  static uint _card_size_in_words;\n-\n-public:\n-  \/\/ entries \"e\" of at least N_words mean \"go back by Base^(e-N_words).\"\n-  \/\/ All entries are less than \"N_words + N_powers\".\n-  static const uint LogBase = 4;\n-  static const uint Base = (1 << LogBase);\n-  static const uint N_powers = 14;\n-\n-  \/\/ Initialize bot size based on card size\n-  static void initialize_bot_size(uint card_shift);\n-\n-  static size_t power_to_cards_back(uint i) {\n-    return (size_t)1 << (LogBase * i);\n-  }\n-\n-  static size_t entry_to_cards_back(u_char entry) {\n-    assert(entry >= _card_size_in_words, \"Precondition\");\n-    return power_to_cards_back(entry - _card_size_in_words);\n-  }\n-  static uint log_card_size() {\n-    return _log_card_size;\n-  }\n-  static uint log_card_size_in_words() {\n-    return _log_card_size_in_words;\n-  }\n-  static uint card_size() {\n-    return _card_size;\n-  }\n-  static uint card_size_in_words() {\n-    return _card_size_in_words;\n-  }\n-};\n-\n@@ -441,1 +404,1 @@\n-#endif \/\/ SHARE_GC_SHARED_BLOCKOFFSETTABLE_HPP\n+#endif \/\/ SHARE_GC_SERIAL_SERIALBLOCKOFFSETTABLE_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.hpp","additions":5,"deletions":42,"binary":false,"changes":47,"previous_filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_GC_SHARED_BLOCKOFFSETTABLE_INLINE_HPP\n-#define SHARE_GC_SHARED_BLOCKOFFSETTABLE_INLINE_HPP\n+#ifndef SHARE_GC_SERIAL_SERIALBLOCKOFFSETTABLE_INLINE_HPP\n+#define SHARE_GC_SERIAL_SERIALBLOCKOFFSETTABLE_INLINE_HPP\n@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/blockOffsetTable.hpp\"\n+#include \"gc\/serial\/serialBlockOffsetTable.hpp\"\n@@ -72,1 +72,1 @@\n-#endif \/\/ SHARE_GC_SHARED_BLOCKOFFSETTABLE_INLINE_HPP\n+#endif \/\/ SHARE_GC_SERIAL_SERIALBLOCKOFFSETTABLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.inline.hpp","status":"renamed"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/serial\/serialBlockOffsetTable.inline.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"gc\/shared\/blockOffsetTable.inline.hpp\"\n@@ -34,1 +34,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,12 +31,32 @@\n-#define VM_STRUCTS_SERIALGC(nonstatic_field,                                  \\\n-                            volatile_nonstatic_field,                         \\\n-                            static_field)                                     \\\n-  nonstatic_field(TenuredGeneration, _min_heap_delta_bytes, size_t)           \\\n-  nonstatic_field(TenuredGeneration, _the_space,            ContiguousSpace*) \\\n-                                                                              \\\n-  nonstatic_field(DefNewGeneration,  _old_gen,              Generation*)      \\\n-  nonstatic_field(DefNewGeneration,  _tenuring_threshold,   uint)             \\\n-  nonstatic_field(DefNewGeneration,  _age_table,            AgeTable)         \\\n-  nonstatic_field(DefNewGeneration,  _eden_space,           ContiguousSpace*) \\\n-  nonstatic_field(DefNewGeneration,  _from_space,           ContiguousSpace*) \\\n-  nonstatic_field(DefNewGeneration,  _to_space,             ContiguousSpace*)\n+#define VM_STRUCTS_SERIALGC(nonstatic_field,                                                    \\\n+                            volatile_nonstatic_field,                                           \\\n+                            static_field)                                                       \\\n+  nonstatic_field(TenuredGeneration,           _rs,                    CardTableRS*)            \\\n+  nonstatic_field(TenuredGeneration,           _bts,                   BlockOffsetSharedArray*) \\\n+  nonstatic_field(TenuredGeneration,           _shrink_factor,         size_t)                  \\\n+  nonstatic_field(TenuredGeneration,           _capacity_at_prologue,  size_t)                  \\\n+  nonstatic_field(TenuredGeneration,           _used_at_prologue,      size_t)                  \\\n+  nonstatic_field(TenuredGeneration,           _min_heap_delta_bytes,  size_t)                  \\\n+  nonstatic_field(TenuredGeneration,           _the_space,             ContiguousSpace*)        \\\n+                                                                                                \\\n+  nonstatic_field(DefNewGeneration,            _old_gen,               Generation*)             \\\n+  nonstatic_field(DefNewGeneration,            _tenuring_threshold,    uint)                    \\\n+  nonstatic_field(DefNewGeneration,            _age_table,             AgeTable)                \\\n+  nonstatic_field(DefNewGeneration,            _eden_space,            ContiguousSpace*)        \\\n+  nonstatic_field(DefNewGeneration,            _from_space,            ContiguousSpace*)        \\\n+  nonstatic_field(DefNewGeneration,            _to_space,              ContiguousSpace*)        \\\n+                                                                                                \\\n+  nonstatic_field(BlockOffsetTable,            _bottom,                HeapWord*)               \\\n+  nonstatic_field(BlockOffsetTable,            _end,                   HeapWord*)               \\\n+                                                                                                \\\n+  nonstatic_field(BlockOffsetSharedArray,      _reserved,              MemRegion)               \\\n+  nonstatic_field(BlockOffsetSharedArray,      _end,                   HeapWord*)               \\\n+  nonstatic_field(BlockOffsetSharedArray,      _vs,                    VirtualSpace)            \\\n+  nonstatic_field(BlockOffsetSharedArray,      _offset_array,          u_char*)                 \\\n+                                                                                                \\\n+  nonstatic_field(BlockOffsetArray,            _array,                 BlockOffsetSharedArray*) \\\n+  nonstatic_field(BlockOffsetArray,            _sp,                    Space*)                  \\\n+  nonstatic_field(BlockOffsetArrayContigSpace, _next_offset_threshold, HeapWord*)               \\\n+  nonstatic_field(BlockOffsetArrayContigSpace, _next_offset_index,     size_t)                  \\\n+                                                                                                \\\n+  nonstatic_field(OffsetTableContigSpace,      _offsets,               BlockOffsetArray)\n@@ -50,0 +70,1 @@\n+  declare_type(OffsetTableContigSpace,       ContiguousSpace)                 \\\n@@ -53,1 +74,7 @@\n-  declare_toplevel_type(TenuredGeneration*)\n+  declare_toplevel_type(TenuredGeneration*)                                   \\\n+  declare_toplevel_type(BlockOffsetSharedArray)                               \\\n+  declare_toplevel_type(BlockOffsetTable)                                     \\\n+           declare_type(BlockOffsetArray,             BlockOffsetTable)       \\\n+           declare_type(BlockOffsetArrayContigSpace,  BlockOffsetArray)       \\\n+  declare_toplevel_type(BlockOffsetSharedArray*)                              \\\n+  declare_toplevel_type(OffsetTableContigSpace*)\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":41,"deletions":14,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -26,9 +26,2 @@\n-#include \"gc\/shared\/blockOffsetTable.inline.hpp\"\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"services\/memTracker.hpp\"\n+#include \"gc\/shared\/blockOffsetTable.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -47,433 +40,0 @@\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetSharedArray\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-BlockOffsetSharedArray::BlockOffsetSharedArray(MemRegion reserved,\n-                                               size_t init_word_size):\n-  _reserved(reserved), _end(NULL)\n-{\n-  size_t size = compute_size(reserved.word_size());\n-  ReservedSpace rs(size);\n-  if (!rs.is_reserved()) {\n-    vm_exit_during_initialization(\"Could not reserve enough space for heap offset array\");\n-  }\n-\n-  MemTracker::record_virtual_memory_type((address)rs.base(), mtGC);\n-\n-  if (!_vs.initialize(rs, 0)) {\n-    vm_exit_during_initialization(\"Could not reserve enough space for heap offset array\");\n-  }\n-  _offset_array = (u_char*)_vs.low_boundary();\n-  resize(init_word_size);\n-  log_trace(gc, bot)(\"BlockOffsetSharedArray::BlockOffsetSharedArray: \");\n-  log_trace(gc, bot)(\"   rs.base(): \" INTPTR_FORMAT \" rs.size(): \" INTPTR_FORMAT \" rs end(): \" INTPTR_FORMAT,\n-                     p2i(rs.base()), rs.size(), p2i(rs.base() + rs.size()));\n-  log_trace(gc, bot)(\"   _vs.low_boundary(): \" INTPTR_FORMAT \"  _vs.high_boundary(): \" INTPTR_FORMAT,\n-                     p2i(_vs.low_boundary()), p2i(_vs.high_boundary()));\n-}\n-\n-void BlockOffsetSharedArray::resize(size_t new_word_size) {\n-  assert(new_word_size <= _reserved.word_size(), \"Resize larger than reserved\");\n-  size_t new_size = compute_size(new_word_size);\n-  size_t old_size = _vs.committed_size();\n-  size_t delta;\n-  char* high = _vs.high();\n-  _end = _reserved.start() + new_word_size;\n-  if (new_size > old_size) {\n-    delta = ReservedSpace::page_align_size_up(new_size - old_size);\n-    assert(delta > 0, \"just checking\");\n-    if (!_vs.expand_by(delta)) {\n-      \/\/ Do better than this for Merlin\n-      vm_exit_out_of_memory(delta, OOM_MMAP_ERROR, \"offset table expansion\");\n-    }\n-    assert(_vs.high() == high + delta, \"invalid expansion\");\n-  } else {\n-    delta = ReservedSpace::page_align_size_down(old_size - new_size);\n-    if (delta == 0) return;\n-    _vs.shrink_by(delta);\n-    assert(_vs.high() == high - delta, \"invalid expansion\");\n-  }\n-}\n-\n-bool BlockOffsetSharedArray::is_card_boundary(HeapWord* p) const {\n-  assert(p >= _reserved.start(), \"just checking\");\n-  size_t delta = pointer_delta(p, _reserved.start());\n-  return (delta & right_n_bits((int)BOTConstants::log_card_size_in_words())) == (size_t)NoBits;\n-}\n-\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetArray\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-BlockOffsetArray::BlockOffsetArray(BlockOffsetSharedArray* array,\n-                                   MemRegion mr, bool init_to_zero_) :\n-  BlockOffsetTable(mr.start(), mr.end()),\n-  _array(array)\n-{\n-  assert(_bottom <= _end, \"arguments out of order\");\n-  set_init_to_zero(init_to_zero_);\n-  if (!init_to_zero_) {\n-    \/\/ initialize cards to point back to mr.start()\n-    set_remainder_to_point_to_start(mr.start() + BOTConstants::card_size_in_words(), mr.end());\n-    _array->set_offset_array(0, 0);  \/\/ set first card to 0\n-  }\n-}\n-\n-\n-\/\/ The arguments follow the normal convention of denoting\n-\/\/ a right-open interval: [start, end)\n-void\n-BlockOffsetArray::\n-set_remainder_to_point_to_start(HeapWord* start, HeapWord* end, bool reducing) {\n-\n-  check_reducing_assertion(reducing);\n-  if (start >= end) {\n-    \/\/ The start address is equal to the end address (or to\n-    \/\/ the right of the end address) so there are not cards\n-    \/\/ that need to be updated..\n-    return;\n-  }\n-\n-  \/\/ Write the backskip value for each region.\n-  \/\/\n-  \/\/    offset\n-  \/\/    card             2nd                       3rd\n-  \/\/     | +- 1st        |                         |\n-  \/\/     v v             v                         v\n-  \/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n-  \/\/    |x|0|0|0|0|0|0|0|1|1|1|1|1|1| ... |1|1|1|1|2|2|2|2|2|2| ...\n-  \/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n-  \/\/    11              19                        75\n-  \/\/      12\n-  \/\/\n-  \/\/    offset card is the card that points to the start of an object\n-  \/\/      x - offset value of offset card\n-  \/\/    1st - start of first logarithmic region\n-  \/\/      0 corresponds to logarithmic value N_words + 0 and 2**(3 * 0) = 1\n-  \/\/    2nd - start of second logarithmic region\n-  \/\/      1 corresponds to logarithmic value N_words + 1 and 2**(3 * 1) = 8\n-  \/\/    3rd - start of third logarithmic region\n-  \/\/      2 corresponds to logarithmic value N_words + 2 and 2**(3 * 2) = 64\n-  \/\/\n-  \/\/    integer below the block offset entry is an example of\n-  \/\/    the index of the entry\n-  \/\/\n-  \/\/    Given an address,\n-  \/\/      Find the index for the address\n-  \/\/      Find the block offset table entry\n-  \/\/      Convert the entry to a back slide\n-  \/\/        (e.g., with today's, offset = 0x81 =>\n-  \/\/          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8\n-  \/\/      Move back N (e.g., 8) entries and repeat with the\n-  \/\/        value of the new entry\n-  \/\/\n-  size_t start_card = _array->index_for(start);\n-  size_t end_card = _array->index_for(end-1);\n-  assert(start ==_array->address_for_index(start_card), \"Precondition\");\n-  assert(end ==_array->address_for_index(end_card)+BOTConstants::card_size_in_words(), \"Precondition\");\n-  set_remainder_to_point_to_start_incl(start_card, end_card, reducing); \/\/ closed interval\n-}\n-\n-\n-\/\/ Unlike the normal convention in this code, the argument here denotes\n-\/\/ a closed, inclusive interval: [start_card, end_card], cf set_remainder_to_point_to_start()\n-\/\/ above.\n-void\n-BlockOffsetArray::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card, bool reducing) {\n-\n-  check_reducing_assertion(reducing);\n-  if (start_card > end_card) {\n-    return;\n-  }\n-  assert(start_card > _array->index_for(_bottom), \"Cannot be first card\");\n-  assert(_array->offset_array(start_card-1) <= BOTConstants::card_size_in_words(),\n-    \"Offset card has an unexpected value\");\n-  size_t start_card_for_region = start_card;\n-  u_char offset = max_jubyte;\n-  for (uint i = 0; i < BOTConstants::N_powers; i++) {\n-    \/\/ -1 so that the card with the actual offset is counted.  Another -1\n-    \/\/ so that the reach ends in this region and not at the start\n-    \/\/ of the next.\n-    size_t reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);\n-    offset = BOTConstants::card_size_in_words() + i;\n-    if (reach >= end_card) {\n-      _array->set_offset_array(start_card_for_region, end_card, offset, reducing);\n-      start_card_for_region = reach + 1;\n-      break;\n-    }\n-    _array->set_offset_array(start_card_for_region, reach, offset, reducing);\n-    start_card_for_region = reach + 1;\n-  }\n-  assert(start_card_for_region > end_card, \"Sanity check\");\n-  DEBUG_ONLY(check_all_cards(start_card, end_card);)\n-}\n-\n-\/\/ The card-interval [start_card, end_card] is a closed interval; this\n-\/\/ is an expensive check -- use with care and only under protection of\n-\/\/ suitable flag.\n-void BlockOffsetArray::check_all_cards(size_t start_card, size_t end_card) const {\n-\n-  if (end_card < start_card) {\n-    return;\n-  }\n-  guarantee(_array->offset_array(start_card) == BOTConstants::card_size_in_words(), \"Wrong value in second card\");\n-  u_char last_entry = BOTConstants::card_size_in_words();\n-  for (size_t c = start_card + 1; c <= end_card; c++ \/* yeah! *\/) {\n-    u_char entry = _array->offset_array(c);\n-    guarantee(entry >= last_entry, \"Monotonicity\");\n-    if (c - start_card > BOTConstants::power_to_cards_back(1)) {\n-      guarantee(entry > BOTConstants::card_size_in_words(), \"Should be in logarithmic region\");\n-    }\n-    size_t backskip = BOTConstants::entry_to_cards_back(entry);\n-    size_t landing_card = c - backskip;\n-    guarantee(landing_card >= (start_card - 1), \"Inv\");\n-    if (landing_card >= start_card) {\n-      guarantee(_array->offset_array(landing_card) <= entry, \"Monotonicity\");\n-    } else {\n-      guarantee(landing_card == (start_card - 1), \"Tautology\");\n-      \/\/ Note that N_words is the maximum offset value\n-      guarantee(_array->offset_array(landing_card) <= BOTConstants::card_size_in_words(), \"Offset value\");\n-    }\n-    last_entry = entry;  \/\/ remember for monotonicity test\n-  }\n-}\n-\n-\n-void\n-BlockOffsetArray::alloc_block(HeapWord* blk_start, HeapWord* blk_end) {\n-  assert(blk_start != NULL && blk_end > blk_start,\n-         \"phantom block\");\n-  single_block(blk_start, blk_end);\n-}\n-\n-void\n-BlockOffsetArray::do_block_internal(HeapWord* blk_start,\n-                                    HeapWord* blk_end,\n-                                    bool reducing) {\n-  assert(_sp->is_in_reserved(blk_start),\n-         \"reference must be into the space\");\n-  assert(_sp->is_in_reserved(blk_end-1),\n-         \"limit must be within the space\");\n-  \/\/ This is optimized to make the test fast, assuming we only rarely\n-  \/\/ cross boundaries.\n-  uintptr_t end_ui = (uintptr_t)(blk_end - 1);\n-  uintptr_t start_ui = (uintptr_t)blk_start;\n-  \/\/ Calculate the last card boundary preceding end of blk\n-  intptr_t boundary_before_end = (intptr_t)end_ui;\n-  clear_bits(boundary_before_end, right_n_bits((int)BOTConstants::log_card_size()));\n-  if (start_ui <= (uintptr_t)boundary_before_end) {\n-    \/\/ blk starts at or crosses a boundary\n-    \/\/ Calculate index of card on which blk begins\n-    size_t    start_index = _array->index_for(blk_start);\n-    \/\/ Index of card on which blk ends\n-    size_t    end_index   = _array->index_for(blk_end - 1);\n-    \/\/ Start address of card on which blk begins\n-    HeapWord* boundary    = _array->address_for_index(start_index);\n-    assert(boundary <= blk_start, \"blk should start at or after boundary\");\n-    if (blk_start != boundary) {\n-      \/\/ blk starts strictly after boundary\n-      \/\/ adjust card boundary and start_index forward to next card\n-      boundary += BOTConstants::card_size_in_words();\n-      start_index++;\n-    }\n-    assert(start_index <= end_index, \"monotonicity of index_for()\");\n-    assert(boundary <= (HeapWord*)boundary_before_end, \"tautology\");\n-    _array->set_offset_array(start_index, boundary, blk_start, reducing);\n-    \/\/ We have finished marking the \"offset card\". We need to now\n-    \/\/ mark the subsequent cards that this blk spans.\n-    if (start_index < end_index) {\n-      HeapWord* rem_st = _array->address_for_index(start_index) + BOTConstants::card_size_in_words();\n-      HeapWord* rem_end = _array->address_for_index(end_index) + BOTConstants::card_size_in_words();\n-      set_remainder_to_point_to_start(rem_st, rem_end, reducing);\n-    }\n-  }\n-}\n-\n-\/\/ The range [blk_start, blk_end) represents a single contiguous block\n-\/\/ of storage; modify the block offset table to represent this\n-\/\/ information; Right-open interval: [blk_start, blk_end)\n-\/\/ NOTE: this method does _not_ adjust _unallocated_block.\n-void\n-BlockOffsetArray::single_block(HeapWord* blk_start,\n-                               HeapWord* blk_end) {\n-  do_block_internal(blk_start, blk_end);\n-}\n-\n-void BlockOffsetArray::verify() const {\n-  \/\/ For each entry in the block offset table, verify that\n-  \/\/ the entry correctly finds the start of an object at the\n-  \/\/ first address covered by the block or to the left of that\n-  \/\/ first address.\n-\n-  size_t next_index = 1;\n-  size_t last_index = last_active_index();\n-\n-  \/\/ Use for debugging.  Initialize to NULL to distinguish the\n-  \/\/ first iteration through the while loop.\n-  HeapWord* last_p = NULL;\n-  HeapWord* last_start = NULL;\n-  oop last_o = NULL;\n-\n-  while (next_index <= last_index) {\n-    \/\/ Use an address past the start of the address for\n-    \/\/ the entry.\n-    HeapWord* p = _array->address_for_index(next_index) + 1;\n-    if (p >= _end) {\n-      \/\/ That's all of the allocated block table.\n-      return;\n-    }\n-    \/\/ block_start() asserts that start <= p.\n-    HeapWord* start = block_start(p);\n-    \/\/ First check if the start is an allocated block and only\n-    \/\/ then if it is a valid object.\n-    oop o = cast_to_oop(start);\n-    assert(!Universe::is_fully_initialized() ||\n-           _sp->is_free_block(start) ||\n-           oopDesc::is_oop_or_null(o), \"Bad object was found\");\n-    next_index++;\n-    last_p = p;\n-    last_start = start;\n-    last_o = o;\n-  }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetArrayContigSpace\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-HeapWord* BlockOffsetArrayContigSpace::block_start_unsafe(const void* addr) const {\n-  assert(_array->offset_array(0) == 0, \"objects can't cross covered areas\");\n-\n-  \/\/ Otherwise, find the block start using the table.\n-  assert(_bottom <= addr && addr < _end,\n-         \"addr must be covered by this Array\");\n-  size_t index = _array->index_for(addr);\n-  \/\/ We must make sure that the offset table entry we use is valid.  If\n-  \/\/ \"addr\" is past the end, start at the last known one and go forward.\n-  index = MIN2(index, _next_offset_index-1);\n-  HeapWord* q = _array->address_for_index(index);\n-\n-  uint offset = _array->offset_array(index);    \/\/ Extend u_char to uint.\n-  while (offset > BOTConstants::card_size_in_words()) {\n-    \/\/ The excess of the offset from N_words indicates a power of Base\n-    \/\/ to go back by.\n-    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n-    q -= (BOTConstants::card_size_in_words() * n_cards_back);\n-    assert(q >= _sp->bottom(), \"Went below bottom!\");\n-    index -= n_cards_back;\n-    offset = _array->offset_array(index);\n-  }\n-  while (offset == BOTConstants::card_size_in_words()) {\n-    assert(q >= _sp->bottom(), \"Went below bottom!\");\n-    q -= BOTConstants::card_size_in_words();\n-    index--;\n-    offset = _array->offset_array(index);\n-  }\n-  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n-  q -= offset;\n-  HeapWord* n = q;\n-\n-  while (n <= addr) {\n-    debug_only(HeapWord* last = q);   \/\/ for debugging\n-    q = n;\n-    n += _sp->block_size(n);\n-  }\n-  assert(q <= addr, \"wrong order for current and arg\");\n-  assert(addr <= n, \"wrong order for arg and next\");\n-  return q;\n-}\n-\n-\/\/\n-\/\/              _next_offset_threshold\n-\/\/              |   _next_offset_index\n-\/\/              v   v\n-\/\/      +-------+-------+-------+-------+-------+\n-\/\/      | i-1   |   i   | i+1   | i+2   | i+3   |\n-\/\/      +-------+-------+-------+-------+-------+\n-\/\/       ( ^    ]\n-\/\/         block-start\n-\/\/\n-\n-void BlockOffsetArrayContigSpace::alloc_block_work(HeapWord* blk_start,\n-                                        HeapWord* blk_end) {\n-  assert(blk_start != NULL && blk_end > blk_start,\n-         \"phantom block\");\n-  assert(blk_end > _next_offset_threshold,\n-         \"should be past threshold\");\n-  assert(blk_start <= _next_offset_threshold,\n-         \"blk_start should be at or before threshold\");\n-  assert(pointer_delta(_next_offset_threshold, blk_start) <= BOTConstants::card_size_in_words(),\n-         \"offset should be <= BlockOffsetSharedArray::N\");\n-  assert(_sp->is_in_reserved(blk_start),\n-         \"reference must be into the space\");\n-  assert(_sp->is_in_reserved(blk_end-1),\n-         \"limit must be within the space\");\n-  assert(_next_offset_threshold ==\n-         _array->_reserved.start() + _next_offset_index*BOTConstants::card_size_in_words(),\n-         \"index must agree with threshold\");\n-\n-  debug_only(size_t orig_next_offset_index = _next_offset_index;)\n-\n-  \/\/ Mark the card that holds the offset into the block.  Note\n-  \/\/ that _next_offset_index and _next_offset_threshold are not\n-  \/\/ updated until the end of this method.\n-  _array->set_offset_array(_next_offset_index,\n-                           _next_offset_threshold,\n-                           blk_start);\n-\n-  \/\/ We need to now mark the subsequent cards that this blk spans.\n-\n-  \/\/ Index of card on which blk ends.\n-  size_t end_index   = _array->index_for(blk_end - 1);\n-\n-  \/\/ Are there more cards left to be updated?\n-  if (_next_offset_index + 1 <= end_index) {\n-    HeapWord* rem_st  = _array->address_for_index(_next_offset_index + 1);\n-    \/\/ Calculate rem_end this way because end_index\n-    \/\/ may be the last valid index in the covered region.\n-    HeapWord* rem_end = _array->address_for_index(end_index) +  BOTConstants::card_size_in_words();\n-    set_remainder_to_point_to_start(rem_st, rem_end);\n-  }\n-\n-  \/\/ _next_offset_index and _next_offset_threshold updated here.\n-  _next_offset_index = end_index + 1;\n-  \/\/ Calculate _next_offset_threshold this way because end_index\n-  \/\/ may be the last valid index in the covered region.\n-  _next_offset_threshold = _array->address_for_index(end_index) + BOTConstants::card_size_in_words();\n-  assert(_next_offset_threshold >= blk_end, \"Incorrect offset threshold\");\n-\n-#ifdef ASSERT\n-  \/\/ The offset can be 0 if the block starts on a boundary.  That\n-  \/\/ is checked by an assertion above.\n-  size_t start_index = _array->index_for(blk_start);\n-  HeapWord* boundary    = _array->address_for_index(start_index);\n-  assert((_array->offset_array(orig_next_offset_index) == 0 &&\n-          blk_start == boundary) ||\n-          (_array->offset_array(orig_next_offset_index) > 0 &&\n-         _array->offset_array(orig_next_offset_index) <= BOTConstants::card_size_in_words()),\n-         \"offset array should have been set\");\n-  for (size_t j = orig_next_offset_index + 1; j <= end_index; j++) {\n-    assert(_array->offset_array(j) > 0 &&\n-           _array->offset_array(j) <= (u_char) (BOTConstants::card_size_in_words()+BOTConstants::N_powers-1),\n-           \"offset array should have been set\");\n-  }\n-#endif\n-}\n-\n-void BlockOffsetArrayContigSpace::initialize_threshold() {\n-  _next_offset_index = _array->index_for(_bottom);\n-  _next_offset_index++;\n-  _next_offset_threshold =\n-    _array->address_for_index(_next_offset_index);\n-}\n-\n-void BlockOffsetArrayContigSpace::zero_bottom_entry() {\n-  size_t bottom_index = _array->index_for(_bottom);\n-  _array->set_offset_array(bottom_index, 0);\n-}\n-\n-size_t BlockOffsetArrayContigSpace::last_active_index() const {\n-  return _next_offset_index == 0 ? 0 : _next_offset_index - 1;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.cpp","additions":2,"deletions":442,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shared\/memset_with_concurrent_readers.hpp\"\n-#include \"gc\/shared\/cardTable.hpp\"\n@@ -32,3 +29,0 @@\n-#include \"memory\/memRegion.hpp\"\n-#include \"memory\/virtualspace.hpp\"\n-#include \"runtime\/globals.hpp\"\n@@ -36,14 +30,0 @@\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/ The CollectedHeap type requires subtypes to implement a method\n-\/\/ \"block_start\".  For some subtypes, notably generational\n-\/\/ systems using card-table-based write barriers, the efficiency of this\n-\/\/ operation may be important.  Implementations of the \"BlockOffsetArray\"\n-\/\/ class may be useful in providing such efficient implementations.\n-\/\/\n-\/\/ BlockOffsetTable (abstract)\n-\/\/   - BlockOffsetArray (abstract)\n-\/\/     - BlockOffsetArrayContigSpace\n-\/\/\n-\n-class ContiguousSpace;\n@@ -89,352 +69,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ The BlockOffsetTable \"interface\"\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetTable {\n-  friend class VMStructs;\n-protected:\n-  \/\/ These members describe the region covered by the table.\n-\n-  \/\/ The space this table is covering.\n-  HeapWord* _bottom;    \/\/ == reserved.start\n-  HeapWord* _end;       \/\/ End of currently allocated region.\n-\n-public:\n-  \/\/ Initialize the table to cover the given space.\n-  \/\/ The contents of the initial table are undefined.\n-  BlockOffsetTable(HeapWord* bottom, HeapWord* end):\n-    _bottom(bottom), _end(end) {\n-    assert(_bottom <= _end, \"arguments out of order\");\n-    assert(BOTConstants::card_size() == CardTable::card_size(), \"sanity\");\n-  }\n-\n-  \/\/ Note that the committed size of the covered space may have changed,\n-  \/\/ so the table size might also wish to change.\n-  virtual void resize(size_t new_word_size) = 0;\n-\n-  virtual void set_bottom(HeapWord* new_bottom) {\n-    assert(new_bottom <= _end, \"new_bottom > _end\");\n-    _bottom = new_bottom;\n-    resize(pointer_delta(_end, _bottom));\n-  }\n-\n-  \/\/ Requires \"addr\" to be contained by a block, and returns the address of\n-  \/\/ the start of that block.\n-  virtual HeapWord* block_start_unsafe(const void* addr) const = 0;\n-\n-  \/\/ Returns the address of the start of the block containing \"addr\", or\n-  \/\/ else \"null\" if it is covered by no block.\n-  HeapWord* block_start(const void* addr) const;\n-};\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ One implementation of \"BlockOffsetTable,\" the BlockOffsetArray,\n-\/\/ divides the covered region into \"N\"-word subregions (where\n-\/\/ \"N\" = 2^\"LogN\".  An array with an entry for each such subregion\n-\/\/ indicates how far back one must go to find the start of the\n-\/\/ chunk that includes the first word of the subregion.\n-\/\/\n-\/\/ Each BlockOffsetArray is owned by a Space.  However, the actual array\n-\/\/ may be shared by several BlockOffsetArrays; this is useful\n-\/\/ when a single resizable area (such as a generation) is divided up into\n-\/\/ several spaces in which contiguous allocation takes place.  (Consider,\n-\/\/ for example, the garbage-first generation.)\n-\n-\/\/ Here is the shared array type.\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetSharedArray\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetSharedArray: public CHeapObj<mtGC> {\n-  friend class BlockOffsetArray;\n-  friend class BlockOffsetArrayNonContigSpace;\n-  friend class BlockOffsetArrayContigSpace;\n-  friend class VMStructs;\n-\n- private:\n-  bool _init_to_zero;\n-\n-  \/\/ The reserved region covered by the shared array.\n-  MemRegion _reserved;\n-\n-  \/\/ End of the current committed region.\n-  HeapWord* _end;\n-\n-  \/\/ Array for keeping offsets for retrieving object start fast given an\n-  \/\/ address.\n-  VirtualSpace _vs;\n-  u_char* _offset_array;          \/\/ byte array keeping backwards offsets\n-\n-  void fill_range(size_t start, size_t num_cards, u_char offset) {\n-    void* start_ptr = &_offset_array[start];\n-    \/\/ If collector is concurrent, special handling may be needed.\n-    G1GC_ONLY(assert(!UseG1GC, \"Shouldn't be here when using G1\");)\n-    memset(start_ptr, offset, num_cards);\n-  }\n-\n- protected:\n-  \/\/ Bounds checking accessors:\n-  \/\/ For performance these have to devolve to array accesses in product builds.\n-  u_char offset_array(size_t index) const {\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    return _offset_array[index];\n-  }\n-  \/\/ An assertion-checking helper method for the set_offset_array() methods below.\n-  void check_reducing_assertion(bool reducing);\n-\n-  void set_offset_array(size_t index, u_char offset, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    assert(!reducing || _offset_array[index] >= offset, \"Not reducing\");\n-    _offset_array[index] = offset;\n-  }\n-\n-  void set_offset_array(size_t index, HeapWord* high, HeapWord* low, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    assert(high >= low, \"addresses out of order\");\n-    assert(pointer_delta(high, low) <= BOTConstants::card_size_in_words(), \"offset too large\");\n-    assert(!reducing || _offset_array[index] >=  (u_char)pointer_delta(high, low),\n-           \"Not reducing\");\n-    _offset_array[index] = (u_char)pointer_delta(high, low);\n-  }\n-\n-  void set_offset_array(HeapWord* left, HeapWord* right, u_char offset, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(index_for(right - 1) < _vs.committed_size(),\n-           \"right address out of range\");\n-    assert(left  < right, \"Heap addresses out of order\");\n-    size_t num_cards = pointer_delta(right, left) >> BOTConstants::log_card_size_in_words();\n-\n-    fill_range(index_for(left), num_cards, offset);\n-  }\n-\n-  void set_offset_array(size_t left, size_t right, u_char offset, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(right < _vs.committed_size(), \"right address out of range\");\n-    assert(left  <= right, \"indexes out of order\");\n-    size_t num_cards = right - left + 1;\n-\n-    fill_range(left, num_cards, offset);\n-  }\n-\n-  void check_offset_array(size_t index, HeapWord* high, HeapWord* low) const {\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    assert(high >= low, \"addresses out of order\");\n-    assert(pointer_delta(high, low) <= BOTConstants::card_size_in_words(), \"offset too large\");\n-    assert(_offset_array[index] == pointer_delta(high, low),\n-           \"Wrong offset\");\n-  }\n-\n-  bool is_card_boundary(HeapWord* p) const;\n-\n-  \/\/ Return the number of slots needed for an offset array\n-  \/\/ that covers mem_region_words words.\n-  \/\/ We always add an extra slot because if an object\n-  \/\/ ends on a card boundary we put a 0 in the next\n-  \/\/ offset array slot, so we want that slot always\n-  \/\/ to be reserved.\n-\n-  size_t compute_size(size_t mem_region_words) {\n-    size_t number_of_slots = (mem_region_words \/ BOTConstants::card_size_in_words()) + 1;\n-    return ReservedSpace::allocation_align_size_up(number_of_slots);\n-  }\n-\n-public:\n-  \/\/ Initialize the table to cover from \"base\" to (at least)\n-  \/\/ \"base + init_word_size\".  In the future, the table may be expanded\n-  \/\/ (see \"resize\" below) up to the size of \"_reserved\" (which must be at\n-  \/\/ least \"init_word_size\".)  The contents of the initial table are\n-  \/\/ undefined; it is the responsibility of the constituent\n-  \/\/ BlockOffsetTable(s) to initialize cards.\n-  BlockOffsetSharedArray(MemRegion reserved, size_t init_word_size);\n-\n-  \/\/ Notes a change in the committed size of the region covered by the\n-  \/\/ table.  The \"new_word_size\" may not be larger than the size of the\n-  \/\/ reserved region this table covers.\n-  void resize(size_t new_word_size);\n-\n-  void set_bottom(HeapWord* new_bottom);\n-\n-  \/\/ Whether entries should be initialized to zero. Used currently only for\n-  \/\/ error checking.\n-  void set_init_to_zero(bool val) { _init_to_zero = val; }\n-  bool init_to_zero() { return _init_to_zero; }\n-\n-  \/\/ Updates all the BlockOffsetArray's sharing this shared array to\n-  \/\/ reflect the current \"top\"'s of their spaces.\n-  void update_offset_arrays();   \/\/ Not yet implemented!\n-\n-  \/\/ Return the appropriate index into \"_offset_array\" for \"p\".\n-  size_t index_for(const void* p) const;\n-\n-  \/\/ Return the address indicating the start of the region corresponding to\n-  \/\/ \"index\" in \"_offset_array\".\n-  HeapWord* address_for_index(size_t index) const;\n-};\n-\n-class Space;\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ The BlockOffsetArray whose subtypes use the BlockOffsetSharedArray.\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetArray: public BlockOffsetTable {\n-  friend class VMStructs;\n- protected:\n-  \/\/ The shared array, which is shared with other BlockOffsetArray's\n-  \/\/ corresponding to different spaces within a generation or span of\n-  \/\/ memory.\n-  BlockOffsetSharedArray* _array;\n-\n-  \/\/ The space that owns this subregion.\n-  Space* _sp;\n-\n-  \/\/ If true, array entries are initialized to 0; otherwise, they are\n-  \/\/ initialized to point backwards to the beginning of the covered region.\n-  bool _init_to_zero;\n-\n-  \/\/ An assertion-checking helper method for the set_remainder*() methods below.\n-  void check_reducing_assertion(bool reducing) { _array->check_reducing_assertion(reducing); }\n-\n-  \/\/ Sets the entries\n-  \/\/ corresponding to the cards starting at \"start\" and ending at \"end\"\n-  \/\/ to point back to the card before \"start\": the interval [start, end)\n-  \/\/ is right-open. The last parameter, reducing, indicates whether the\n-  \/\/ updates to individual entries always reduce the entry from a higher\n-  \/\/ to a lower value. (For example this would hold true during a temporal\n-  \/\/ regime during which only block splits were updating the BOT.\n-  void set_remainder_to_point_to_start(HeapWord* start, HeapWord* end, bool reducing = false);\n-  \/\/ Same as above, except that the args here are a card _index_ interval\n-  \/\/ that is closed: [start_index, end_index]\n-  void set_remainder_to_point_to_start_incl(size_t start, size_t end, bool reducing = false);\n-\n-  \/\/ A helper function for BOT adjustment\/verification work\n-  void do_block_internal(HeapWord* blk_start, HeapWord* blk_end, bool reducing = false);\n-\n- public:\n-  \/\/ The space may not have its bottom and top set yet, which is why the\n-  \/\/ region is passed as a parameter.  If \"init_to_zero\" is true, the\n-  \/\/ elements of the array are initialized to zero.  Otherwise, they are\n-  \/\/ initialized to point backwards to the beginning.\n-  BlockOffsetArray(BlockOffsetSharedArray* array, MemRegion mr,\n-                   bool init_to_zero_);\n-\n-  \/\/ Note: this ought to be part of the constructor, but that would require\n-  \/\/ \"this\" to be passed as a parameter to a member constructor for\n-  \/\/ the containing concrete subtype of Space.\n-  \/\/ This would be legal C++, but MS VC++ doesn't allow it.\n-  void set_space(Space* sp) { _sp = sp; }\n-\n-  \/\/ Resets the covered region to the given \"mr\".\n-  void set_region(MemRegion mr) {\n-    _bottom = mr.start();\n-    _end = mr.end();\n-  }\n-\n-  \/\/ Note that the committed size of the covered space may have changed,\n-  \/\/ so the table size might also wish to change.\n-  virtual void resize(size_t new_word_size) {\n-    HeapWord* new_end = _bottom + new_word_size;\n-    if (_end < new_end && !init_to_zero()) {\n-      \/\/ verify that the old and new boundaries are also card boundaries\n-      assert(_array->is_card_boundary(_end),\n-             \"_end not a card boundary\");\n-      assert(_array->is_card_boundary(new_end),\n-             \"new _end would not be a card boundary\");\n-      \/\/ set all the newly added cards\n-      _array->set_offset_array(_end, new_end, BOTConstants::card_size_in_words());\n-    }\n-    _end = new_end;  \/\/ update _end\n-  }\n-\n-  \/\/ Adjust the BOT to show that it has a single block in the\n-  \/\/ range [blk_start, blk_start + size). All necessary BOT\n-  \/\/ cards are adjusted, but _unallocated_block isn't.\n-  void single_block(HeapWord* blk_start, HeapWord* blk_end);\n-  void single_block(HeapWord* blk, size_t size) {\n-    single_block(blk, blk + size);\n-  }\n-\n-  \/\/ When the alloc_block() call returns, the block offset table should\n-  \/\/ have enough information such that any subsequent block_start() call\n-  \/\/ with an argument equal to an address that is within the range\n-  \/\/ [blk_start, blk_end) would return the value blk_start, provided\n-  \/\/ there have been no calls in between that reset this information\n-  \/\/ (e.g. see BlockOffsetArrayNonContigSpace::single_block() call\n-  \/\/ for an appropriate range covering the said interval).\n-  \/\/ These methods expect to be called with [blk_start, blk_end)\n-  \/\/ representing a block of memory in the heap.\n-  virtual void alloc_block(HeapWord* blk_start, HeapWord* blk_end);\n-  void alloc_block(HeapWord* blk, size_t size) {\n-    alloc_block(blk, blk + size);\n-  }\n-\n-  \/\/ If true, initialize array slots with no allocated blocks to zero.\n-  \/\/ Otherwise, make them point back to the front.\n-  bool init_to_zero() { return _init_to_zero; }\n-  \/\/ Corresponding setter\n-  void set_init_to_zero(bool val) {\n-    _init_to_zero = val;\n-    assert(_array != NULL, \"_array should be non-NULL\");\n-    _array->set_init_to_zero(val);\n-  }\n-\n-  \/\/ Debugging\n-  \/\/ Return the index of the last entry in the \"active\" region.\n-  virtual size_t last_active_index() const = 0;\n-  \/\/ Verify the block offset table\n-  void verify() const;\n-  void check_all_cards(size_t left_card, size_t right_card) const;\n-};\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ A subtype of BlockOffsetArray that takes advantage of the fact\n-\/\/ that its underlying space is a ContiguousSpace, so that its \"active\"\n-\/\/ region can be more efficiently tracked (than for a non-contiguous space).\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetArrayContigSpace: public BlockOffsetArray {\n-  friend class VMStructs;\n- private:\n-  \/\/ allocation boundary at which offset array must be updated\n-  HeapWord* _next_offset_threshold;\n-  size_t    _next_offset_index;      \/\/ index corresponding to that boundary\n-\n-  \/\/ Work function when allocation start crosses threshold.\n-  void alloc_block_work(HeapWord* blk_start, HeapWord* blk_end);\n-\n- public:\n-  BlockOffsetArrayContigSpace(BlockOffsetSharedArray* array, MemRegion mr):\n-    BlockOffsetArray(array, mr, true) {\n-    _next_offset_threshold = NULL;\n-    _next_offset_index = 0;\n-  }\n-\n-  void set_contig_space(ContiguousSpace* sp) { set_space((Space*)sp); }\n-\n-  \/\/ Initialize the threshold for an empty heap.\n-  void initialize_threshold();\n-  \/\/ Zero out the entry for _bottom (offset will be zero)\n-  void zero_bottom_entry();\n-\n-  \/\/ Return the next threshold, the point at which the table should be\n-  \/\/ updated.\n-  HeapWord* threshold() const { return _next_offset_threshold; }\n-\n-  \/\/ In general, these methods expect to be called with\n-  \/\/ [blk_start, blk_end) representing a block of memory in the heap.\n-  \/\/ In this implementation, however, we are OK even if blk_start and\/or\n-  \/\/ blk_end are NULL because NULL is represented as 0, and thus\n-  \/\/ never exceeds the \"_next_offset_threshold\".\n-  void alloc_block(HeapWord* blk_start, HeapWord* blk_end) {\n-    if (blk_end > _next_offset_threshold) {\n-      alloc_block_work(blk_start, blk_end);\n-    }\n-  }\n-  void alloc_block(HeapWord* blk, size_t size) {\n-    alloc_block(blk, blk + size);\n-  }\n-\n-  HeapWord* block_start_unsafe(const void* addr) const;\n-\n-  \/\/ Debugging support\n-  virtual size_t last_active_index() const;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","additions":0,"deletions":372,"binary":false,"changes":372,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/symbolTable.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -34,0 +34,1 @@\n+#include \"gc\/serial\/markSweep.hpp\"\n@@ -41,0 +42,1 @@\n+#include \"gc\/shared\/gcInitLogger.hpp\"\n@@ -45,1 +47,0 @@\n-#include \"gc\/shared\/genArguments.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"gc\/shared\/genArguments.hpp\"\n@@ -48,1 +50,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -50,1 +51,1 @@\n-#include \"gc\/shared\/gcInitLogger.hpp\"\n+#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"gc\/shared\/oopStorageSet.inline.hpp\"\n@@ -55,0 +55,1 @@\n+#include \"gc\/shared\/oopStorageSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/shared\/blockOffsetTable.inline.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -33,2 +33,0 @@\n-#include \"gc\/shared\/genOopClosures.hpp\"\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -37,0 +35,2 @@\n+#include \"gc\/shared\/genOopClosures.hpp\"\n+#include \"gc\/shared\/genOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/blockOffsetTable.inline.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"gc\/serial\/serialBlockOffsetTable.inline.hpp\"\n@@ -292,0 +292,1 @@\n+#if INCLUDE_SERIALGC\n@@ -308,0 +309,1 @@\n+#endif \/\/ INCLUDE_SERIALGC\n@@ -596,0 +598,1 @@\n+#if INCLUDE_SERIALGC\n@@ -602,0 +605,1 @@\n+#endif\n@@ -737,0 +741,1 @@\n+#if INCLUDE_SERIALGC\n@@ -795,0 +800,1 @@\n+#endif \/\/ INCLUDE_SERIALGC\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+#if INCLUDE_SERIALGC\n+#include \"gc\/serial\/serialBlockOffsetTable.hpp\"\n+#endif\n@@ -46,0 +49,2 @@\n+class ContiguousSpace;\n+#if INCLUDE_SERIALGC\n@@ -48,0 +53,2 @@\n+class BlockOffsetTable;\n+#endif\n@@ -50,1 +57,0 @@\n-class BlockOffsetTable;\n@@ -603,0 +609,1 @@\n+#if INCLUDE_SERIALGC\n@@ -649,0 +656,2 @@\n+#endif \/\/INCLUDE_SERIALGC\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/blockOffsetTable.inline.hpp\"\n@@ -34,1 +33,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -36,0 +34,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"gc\/serial\/serialBlockOffsetTable.inline.hpp\"\n@@ -46,0 +46,1 @@\n+#if INCLUDE_SERIALGC\n@@ -79,2 +80,0 @@\n-#if INCLUDE_SERIALGC\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,19 +90,0 @@\n-  nonstatic_field(BlockOffsetTable,            _bottom,                                       HeapWord*)                             \\\n-  nonstatic_field(BlockOffsetTable,            _end,                                          HeapWord*)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(BlockOffsetSharedArray,      _reserved,                                     MemRegion)                             \\\n-  nonstatic_field(BlockOffsetSharedArray,      _end,                                          HeapWord*)                             \\\n-  nonstatic_field(BlockOffsetSharedArray,      _vs,                                           VirtualSpace)                          \\\n-  nonstatic_field(BlockOffsetSharedArray,      _offset_array,                                 u_char*)                               \\\n-                                                                                                                                     \\\n-  nonstatic_field(BlockOffsetArray,            _array,                                        BlockOffsetSharedArray*)               \\\n-  nonstatic_field(BlockOffsetArray,            _sp,                                           Space*)                                \\\n-  nonstatic_field(BlockOffsetArrayContigSpace, _next_offset_threshold,                        HeapWord*)                             \\\n-  nonstatic_field(BlockOffsetArrayContigSpace, _next_offset_index,                            size_t)                                \\\n-                                                                                                                                     \\\n-  nonstatic_field(TenuredGeneration,           _rs,                                           CardTableRS*)                          \\\n-  nonstatic_field(TenuredGeneration,           _bts,                                          BlockOffsetSharedArray*)               \\\n-  nonstatic_field(TenuredGeneration,           _shrink_factor,                                size_t)                                \\\n-  nonstatic_field(TenuredGeneration,           _capacity_at_prologue,                         size_t)                                \\\n-  nonstatic_field(TenuredGeneration,           _used_at_prologue,                             size_t)                                \\\n-                                                                                                                                     \\\n@@ -153,2 +134,0 @@\n-  nonstatic_field(OffsetTableContigSpace,      _offsets,                                      BlockOffsetArray)                      \\\n-                                                                                                                                     \\\n@@ -191,1 +170,0 @@\n-           declare_type(OffsetTableContigSpace,       ContiguousSpace)    \\\n@@ -198,4 +176,0 @@\n-  declare_toplevel_type(BlockOffsetSharedArray)                           \\\n-  declare_toplevel_type(BlockOffsetTable)                                 \\\n-           declare_type(BlockOffsetArray,             BlockOffsetTable)   \\\n-           declare_type(BlockOffsetArrayContigSpace,  BlockOffsetArray)   \\\n@@ -217,1 +191,0 @@\n-  declare_toplevel_type(BlockOffsetSharedArray*)                          \\\n@@ -232,1 +205,0 @@\n-  declare_toplevel_type(OffsetTableContigSpace*)                          \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"}]}