{"files":[{"patch":"@@ -184,54 +184,1 @@\n-        \/\/ Optimistically try plain semantics first\n-        final V v = value;\n-        if (v != null) {\n-            \/\/ If we happen to see a non-null value under\n-            \/\/ plain semantics, we know a value is set.\n-            return v;\n-        }\n-        if (state == NULL) {\n-            \/\/ If we happen to see a state value of NULL under\n-            \/\/ plain semantics, we know a value is set to `null`.\n-            return null;\n-        }\n-        \/\/ Now, fall back to volatile semantics.\n-        return computeIfUnsetVolatile(supplier);\n-    }\n-\n-    @DontInline \/\/ Slow-path taken at most once per thread if set\n-    private V computeIfUnsetVolatile(Supplier<? extends V> supplier) {\n-        \/\/ This is intentionally an old switch statement as it generates\n-        \/\/ more compact byte code.\n-        switch (stateVolatile()) {\n-            case UNSET:    { return computeIfUnsetVolatile0(supplier); }\n-            case NON_NULL: { return valueVolatile(); }\n-            case NULL:     { return null; }\n-            case ERROR:    { throw StableUtil.error(this); }\n-        }\n-        throw shouldNotReachHere();\n-    }\n-\n-    private V computeIfUnsetVolatile0(Supplier<? extends V> supplier) {\n-        final var m = acquireMutex();\n-        if (isMutexNotNeeded(m)) {\n-            return orThrow();\n-        }\n-        synchronized (m) {\n-            \/\/ A value is already set\n-            if (state != UNSET) {\n-                return orThrow();\n-            }\n-            \/\/ A value is not set\n-            if (computeInvoked) {\n-                throw stackOverflow(supplier, null);\n-            }\n-            computeInvoked = true;\n-            try {\n-                V newValue = supplier.get();\n-                setValue(newValue);\n-                return newValue;\n-            } catch (Throwable t) {\n-                putState(ERROR);\n-                putMutex(t.getClass());\n-                throw t;\n-            }\n-        }\n+        return computeIfUnsetShared(supplier, null);\n@@ -306,0 +253,1 @@\n+                \/\/ For security reasons, we only store the exception type.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":2,"deletions":54,"binary":false,"changes":56,"status":"modified"}]}