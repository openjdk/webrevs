{"files":[{"patch":"@@ -112,0 +112,1 @@\n+        --add-exports java.base\/jdk.internal.lang=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -256,0 +256,16 @@\n+\/\/ Todo: Change to 'java\/lang\/StableValue' etc. once StableValue becomes a public API\n+const char* stable_value_klass_name = \"jdk\/internal\/lang\/StableValue\";\n+const char* stable_array_klass_name = \"jdk\/internal\/lang\/StableArray\";\n+const char* stable_array2d_klass_name = \"jdk\/internal\/lang\/StableArray2D\";\n+const char* stable_array3d_klass_name = \"jdk\/internal\/lang\/StableArray3D\";\n+\n+static bool trust_final_non_static_fields_of_type(Symbol* signature) {\n+  if (signature->equals(stable_value_klass_name) == 0 ||\n+      signature->equals(stable_array_klass_name) == 0 ||\n+      signature->equals(stable_array2d_klass_name) == 0 ||\n+      signature->equals(stable_array3d_klass_name) == 0) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -288,1 +304,3 @@\n-      _is_constant = is_stable_field || trust_final_non_static_fields(_holder);\n+      _is_constant = is_stable_field ||\n+                     trust_final_non_static_fields(_holder) ||\n+                     trust_final_non_static_fields_of_type(fd->signature());\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.lang.StableValue;\n@@ -388,0 +389,4 @@\n+        throw newInaccessibleObjectException(msg);\n+    }\n+\n+    static InaccessibleObjectException newInaccessibleObjectException(String msg) {\n@@ -392,1 +397,1 @@\n-        throw e;\n+        return e;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.lang.StableValue;\n+import jdk.internal.lang.stable.TrustedFieldType;\n@@ -177,1 +179,9 @@\n-        if (flag) checkCanSetAccessible(Reflection.getCallerClass());\n+        \/\/ Always check if the field is a final StableValue\n+        if (TrustedFieldType.class.isAssignableFrom(type) && Modifier.isFinal(modifiers)) {\n+            throw newInaccessibleObjectException(\n+                    \"Unable to make field \" + this + \" accessible: \" +\n+                            \"Fields declared to implement \" + TrustedFieldType.class.getName() + \" are trusted\");\n+        }\n+        if (flag) {\n+            checkCanSetAccessible(Reflection.getCallerClass());\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.IntPredicate;\n@@ -38,0 +40,1 @@\n+import java.util.function.Supplier;\n@@ -41,0 +44,3 @@\n+import jdk.internal.lang.StableValue;\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n@@ -42,0 +48,2 @@\n+import jdk.internal.util.ImmutableBitSetPredicate;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -120,1 +128,1 @@\n-    static class Access {\n+    static final class Access {\n@@ -129,0 +137,75 @@\n+                @Override\n+                public <V> List<StableValue<V>> stableList(int size) {\n+                    return StableList.create(size);\n+                }\n+\n+                @Override\n+                public <V> V computeIfUnset(List<StableValue<V>> list,\n+                                            int index,\n+                                            IntFunction<? extends V> mapper) {\n+                    if (list instanceof StableList<V> ll) {\n+                        return ll.computeIfUnset(index, mapper);\n+                    } else {\n+                        StableValue<V> stable = list.get(index);\n+                        if (stable.isSet()) {\n+                            return stable.orThrow();\n+                        }\n+                        synchronized (stable) {\n+                            if (stable.isSet()) {\n+                                return stable.orThrow();\n+                            }\n+                            \/\/ Captures\n+                            Supplier<V> supplier = new Supplier<>() {\n+                                @Override\n+                                public V get() {\n+                                    return mapper.apply(index);\n+                                }\n+                            };\n+                            return stable.computeIfUnset(supplier);\n+                        }\n+                    }\n+                }\n+\n+                @SuppressWarnings(\"unchecked\")\n+                @Override\n+                public <K, V> Map<K, StableValue<V>> stableMap(Set<? extends K> keys) {\n+                    if (keys instanceof EnumSet<?> enumSet) {\n+                        return StableEnumMap.create((Set<K>) enumSet);\n+                    } else {\n+                        K[] arr = (K[]) keys.stream()\n+                                .map(Objects::requireNonNull)\n+                                .distinct()\n+                                .toArray();\n+                        return StableMap.create(arr);\n+                    }\n+                }\n+\n+                @Override\n+                public <K, V> V computeIfUnset(Map<K, StableValue<V>> map,\n+                                               K key,\n+                                               Function<? super K, ? extends V> mapper) {\n+                    if (map instanceof ComputeIfUnsetMap<K, V> uc) {\n+                        return uc.computeIfUnset(key, mapper);\n+                    } else {\n+                        StableValue<V> stable = map.get(key);\n+                        if (stable == null) {\n+                            throw noKey(key);\n+                        }\n+                        if (stable.isSet()) {\n+                            return stable.orThrow();\n+                        }\n+                        synchronized (stable) {\n+                            if (stable.isSet()) {\n+                                return stable.orThrow();\n+                            }\n+                            \/\/ Captures\n+                            Supplier<V> supplier = new Supplier<>() {\n+                                @Override\n+                                public V get() {\n+                                    return mapper.apply(key);\n+                                }\n+                            };\n+                            return stable.computeIfUnset(supplier);\n+                        }\n+                    }\n+                }\n@@ -190,1 +273,1 @@\n-        E[] tmp = (E[])new Object[input.length]; \/\/ implicit nullcheck of input\n+        E[] tmp = newGenericArray(input.length); \/\/ implicit nullcheck of input\n@@ -800,1 +883,1 @@\n-                throw new IllegalArgumentException(\"duplicate element: \" + e0);\n+                throw duplicate(\"element\", e0);\n@@ -918,1 +1001,0 @@\n-        @SuppressWarnings(\"unchecked\")\n@@ -922,1 +1004,1 @@\n-            elements = (E[])new Object[EXPAND_FACTOR * input.length];\n+            elements = newGenericArray(EXPAND_FACTOR * input.length);\n@@ -927,1 +1009,1 @@\n-                    throw new IllegalArgumentException(\"duplicate element: \" + e);\n+                    throw duplicate(\"element\", e);\n@@ -1198,1 +1280,1 @@\n-                    throw new IllegalArgumentException(\"duplicate key: \" + k);\n+                    throw duplicate(\"key\", k);\n@@ -1363,0 +1445,451 @@\n+\n+    \/\/ Stable collections\n+\n+    @jdk.internal.ValueBased\n+    static final class StableList<V>\n+            extends AbstractImmutableList<StableValue<V>>\n+            implements List<StableValue<V>> {\n+\n+        @Stable\n+        private int size;\n+        @Stable\n+        private final StableValueImpl<V>[] elements;\n+\n+        private StableList(int size) {\n+            assert size > 0;\n+            this.size = size;\n+            this.elements = StableUtil.newStableValueArray(size);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public StableValueImpl<V> get(int index) {\n+            Objects.checkIndex(index, size);\n+            StableValueImpl<V> stable = elements[index];\n+            return stable == null\n+                    ? StableUtil.getOrSetVolatile(elements, index)\n+                    : stable;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            Objects.requireNonNull(o);\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> c) {\n+            Objects.requireNonNull(c);\n+            return c.isEmpty();\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            Objects.requireNonNull(o);\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            Objects.requireNonNull(o);\n+            return -1;\n+        }\n+\n+        V computeIfUnset(int index, IntFunction<? extends V> mapper) {\n+            StableValueImpl<V> stable = get(index);\n+            return stable.computeIfUnset(index, mapper);\n+        }\n+\n+        static <V> List<StableValue<V>> create(int size) {\n+            return new StableList<>(size);\n+        }\n+\n+    }\n+\n+    \/\/ Internal interface used to indicate the presence of\n+    \/\/ the computeIfUnset method that is unique to StableMap and StableEnumMap\n+    interface ComputeIfUnsetMap<K, V> extends Map<K, StableValue<V>> {\n+        V computeIfUnset(K key, Function<? super K, ? extends V> mapper);\n+    }\n+\n+    static final class StableMap<K, V>\n+            extends AbstractImmutableMap<K, StableValue<V>>\n+            implements Map<K, StableValue<V>>, ComputeIfUnsetMap<K, V> {\n+\n+        @Stable\n+        private final int size;\n+        @Stable\n+        private final K[] keys;\n+        @Stable\n+        private final StableValueImpl<V>[] elements;\n+\n+        StableMap(Object[] inKeys) {\n+            assert inKeys.length > 0;\n+            this.size = inKeys.length;\n+\n+            \/\/ Todo: Consider having a larger array\n+            int len = EXPAND_FACTOR * inKeys.length;\n+            len = (len + 1) & ~1; \/\/ ensure table is even length\n+\n+            K[] keys = newGenericArray(len);\n+\n+            for (Object key : inKeys) {\n+                @SuppressWarnings(\"unchecked\")\n+                K k = Objects.requireNonNull((K) key);\n+                int idx = probe(keys, k);\n+                if (idx >= 0) {\n+                    throw duplicate(\"key\", k);\n+                } else {\n+                    int dest = -(idx + 1);\n+                    keys[dest] = k;\n+                }\n+            }\n+            this.keys = keys;\n+            this.elements = StableUtil.newStableValueArray(len);\n+        }\n+\n+        \/\/ returns index at which the probe key is present; or if absent,\n+        \/\/ (-i - 1) where i is location where element should be inserted.\n+        \/\/ Callers are relying on this method to perform an implicit nullcheck\n+        \/\/ of pk.\n+        private int probe(Object pk) {\n+            return probe(keys, pk);\n+        }\n+\n+        private int probe(K[] keys, Object pk) {\n+            int idx = Math.floorMod(pk.hashCode(), keys.length);\n+            \/\/ Linear probing\n+            while (true) {\n+                K ek = keys[idx];\n+                if (ek == null) {\n+                    return -idx - 1;\n+                } else if (pk.equals(ek)) {\n+                    return idx;\n+                } else if ((idx += 1) == keys.length) {\n+                    idx = 0;\n+                }\n+            }\n+        }\n+\n+        @ForceInline\n+        private StableValue<V> value(int keyIndex) {\n+            StableValueImpl<V> stable = elements[keyIndex];\n+            return stable == null\n+                    ? StableUtil.getOrSetVolatile(elements, keyIndex)\n+                    : stable;\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object o) {\n+            Objects.requireNonNull(o);\n+            return probe(o) >= 0;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public StableValue<V> get(Object key) {\n+            int i = probe(key);\n+            if (i >= 0) {\n+                return value(i);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        final class StableMapIterator implements Iterator<Map.Entry<K, StableValue<V>>> {\n+\n+            private int remaining;\n+            private int idx;\n+\n+            StableMapIterator() {\n+                remaining = size;\n+                \/\/ pick an even starting index in the [0, keys.length)\n+                \/\/ range randomly based on SALT32L\n+                idx = (int) ((SALT32L * (keys.length)) >>> 32);\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return remaining > 0;\n+            }\n+\n+            private int nextIndex() {\n+                int idx = this.idx;\n+                if (REVERSE) {\n+                    if ((++idx) >= keys.length) {\n+                        idx = 0;\n+                    }\n+                } else {\n+                    if ((--idx) < 0) {\n+                        idx = keys.length - 1;\n+                    }\n+                }\n+                return this.idx = idx;\n+            }\n+\n+            @Override\n+            public Map.Entry<K, StableValue<V>> next() {\n+                if (remaining > 0) {\n+                    int idx;\n+                    while (keys[idx = nextIndex()] == null) {}\n+                    Map.Entry<K, StableValue<V>> e = new KeyValueHolder<>(keys[idx], value(idx));\n+                    remaining--;\n+                    return e;\n+                } else {\n+                    throw new NoSuchElementException();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, StableValue<V>>> entrySet() {\n+            return new AbstractImmutableSet<>() {\n+                @Override\n+                public int size() {\n+                    return StableMap.this.size;\n+                }\n+\n+                @Override\n+                public Iterator<Map.Entry<K, StableValue<V>>> iterator() {\n+                    return new StableMapIterator();\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    int h = 0;\n+                    for (Entry<K, StableValue<V>> e : this) {\n+                        if (e != null) {\n+                            h += e.hashCode();\n+                        }\n+                    }\n+                    return h;\n+                }\n+\n+            };\n+        }\n+\n+        @Override\n+        public V computeIfUnset(K key, Function<? super K, ? extends V> mapper) {\n+           StableValueImpl<V> element = (StableValueImpl<V>) get(key);\n+           if (element == null) {\n+               throw noKey(key);\n+           }\n+            return element.computeIfUnset(key, mapper);\n+        }\n+\n+        static <K, V> Map<K, StableValue<V>> create(K[] keys) {\n+            return new StableMap<>(keys);\n+        }\n+\n+    }\n+\n+    static final class StableEnumMap<K extends Enum<K>, V>\n+            extends AbstractImmutableMap<K, StableValue<V>>\n+            implements Map<K, StableValue<V>>, ComputeIfUnsetMap<K, V> {\n+\n+        @Stable\n+        private final int size;\n+        @Stable\n+        private final Class<K> enumType;\n+        @Stable\n+        private final int min;\n+        @Stable\n+        private final IntPredicate isPresent;\n+        @Stable\n+        private final StableValueImpl<V>[] elements;\n+\n+        private StableEnumMap(EnumSet<K> keys) {\n+            assert !keys.isEmpty();\n+\n+            \/\/ Establish the min and max value.\n+            \/\/ All indexing will then be translated by\n+            \/\/ subtracting the min ordinal from a key's ordinal\n+            int min = Integer.MAX_VALUE;\n+            int max = Integer.MIN_VALUE;\n+            for (K key : keys) {\n+                int ordinal = key.ordinal();\n+                min = Math.min(min, ordinal);\n+                max = Math.max(max, ordinal);\n+            }\n+            this.min = min;\n+            int elementCount = max - min + 1;\n+\n+            \/\/ Construct a translated bitset\n+            BitSet bs = new BitSet(elementCount);\n+            for (K key : keys) {\n+                bs.set(arrayIndex(key));\n+            }\n+            this.isPresent = ImmutableBitSetPredicate.of(bs);\n+\n+            this.elements = StableUtil.newStableValueArray(elementCount);\n+            this.size = keys.size();\n+            @SuppressWarnings(\"unchecked\")\n+            Class<K> enumType0 = (Class<K>)keys.iterator().next().getClass();\n+            this.enumType = enumType0;\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object o) {\n+            Objects.requireNonNull(o);\n+            int arrayIndex;\n+            return enumType.isInstance(o) &&\n+                    (arrayIndex = arrayIndex(o)) >= 0 && arrayIndex < size() &&\n+                    isPresent.test(arrayIndex);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public StableValueImpl<V> get(Object key) {\n+            return containsKey(key)\n+                    ? value(arrayIndex(key))\n+                    : null;\n+        }\n+\n+        @ForceInline\n+        private StableValueImpl<V> value(int index) {\n+            StableValueImpl<V> stable = elements[index];\n+            return stable == null\n+                    ? StableUtil.getOrSetVolatile(elements, index)\n+                    : stable;\n+        }\n+\n+        private K key(int arrayIndex) {\n+            return enumType.getEnumConstants()[enumIndex(arrayIndex)];\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private int arrayIndex(Object key) {\n+            return ((K) key).ordinal() - min;\n+        }\n+\n+        private int enumIndex(int arrayIndex) {\n+            return arrayIndex + min;\n+        }\n+\n+        final class StableEnumMapIterator implements Iterator<Map.Entry<K, StableValue<V>>> {\n+\n+            private int remaining;\n+            private int idx;\n+\n+            StableEnumMapIterator() {\n+                remaining = size;\n+                \/\/ pick an even starting index in the [0, keys.length)\n+                \/\/ range randomly based on SALT32L\n+                idx = (int) ((SALT32L * size) >>> 32);\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return remaining > 0;\n+            }\n+\n+            private int nextIndex() {\n+                int idx = this.idx;\n+                if (REVERSE) {\n+                    if ((++idx) >= size) {\n+                        idx = 0;\n+                    }\n+                } else {\n+                    if ((--idx) < 0) {\n+                        idx = size - 1;\n+                    }\n+                }\n+                return this.idx = idx;\n+            }\n+\n+            @Override\n+            public Map.Entry<K, StableValue<V>> next() {\n+                if (remaining > 0) {\n+                    int idx;\n+                    while (!isPresent.test(idx = nextIndex())) {}\n+                    Map.Entry<K, StableValue<V>> e = new KeyValueHolder<>(key(idx), value(idx));\n+                    remaining--;\n+                    return e;\n+                } else {\n+                    throw new NoSuchElementException();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, StableValue<V>>> entrySet() {\n+            return new AbstractImmutableSet<>() {\n+                @Override\n+                public int size() {\n+                    return StableEnumMap.this.size;\n+                }\n+\n+                @Override\n+                public Iterator<Map.Entry<K, StableValue<V>>> iterator() {\n+                    return new StableEnumMapIterator();\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    int h = 0;\n+                    for (Entry<K, StableValue<V>> e : this) {\n+                        if (e != null) {\n+                            h += e.hashCode();\n+                        }\n+                    }\n+                    return h;\n+                }\n+\n+            };\n+        }\n+\n+        @Override\n+        public V computeIfUnset(K key, Function<? super K, ? extends V> mapper) {\n+            StableValueImpl<V> element = get(key);\n+            if (element == null) {\n+                throw noKey(key);\n+            }\n+            return element.computeIfUnset(key, mapper);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static <K, KI extends Enum<KI>, V> Map<K, StableValue<V>> create(Set<K> keys) {\n+            Map<KI, StableValue<V>> map = new StableEnumMap<>((EnumSet<KI>) keys);\n+            return (Map<K, StableValue<V>>) map;\n+        }\n+\n+    }\n+\n+    private static NoSuchElementException noKey(Object key) {\n+        return new NoSuchElementException(\"No such key:\" + key);\n+    }\n+\n+    private static IllegalArgumentException duplicate(String type, Object element) {\n+        return new IllegalArgumentException(\"duplicate \" + type + \": \" + element);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <V> V[] newGenericArray(int length) {\n+        return (V[]) new Object[length];\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":540,"deletions":7,"binary":false,"changes":547,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.lang.StableValue;\n+\n@@ -29,0 +31,4 @@\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n@@ -33,0 +39,4 @@\n+    <V> List<StableValue<V>> stableList(int size);\n+    <V> V computeIfUnset(List<StableValue<V>> list, int index, IntFunction<? extends V> mapper);\n+    <K, V> Map<K, StableValue<V>> stableMap(Set<? extends K> keys);\n+    <K, V> V computeIfUnset(Map<K, StableValue<V>> map, K key, Function<? super K, ? extends V> mapper);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+package jdk.internal.lang;\n+\n+import jdk.internal.lang.stable.StableArrayImpl;\n+import jdk.internal.lang.stable.TrustedFieldType;\n+\n+\/**\n+ * An atomic, thread-safe, stable array holder for which components can be set at most once.\n+ * <p>\n+ * Stable arrays are eligible for certain optimizations by the JVM.\n+ * <p>\n+ * The total number of components ({@linkplain StableArray#length()}) in a stable array\n+ * can not exceed about 2<sup>31<\/sup>.\n+ *\n+ * @param <V> type of StableValue that this stable array holds\n+ * @since 23\n+ *\/\n+public sealed interface StableArray<V>\n+        extends TrustedFieldType\n+        permits StableArrayImpl {\n+\n+    \/**\n+     * {@return the {@code [index]} component of this stable array}\n+     *\n+     * @param index to use as a component index\n+     * @throws ArrayIndexOutOfBoundsException if {@code\n+     *         index < 0 || index >= size()}\n+     *\/\n+    StableValue<V> get(int index);\n+\n+    \/**\n+     * {@return the length of this stable array}\n+     *\/\n+    int length();\n+\n+    \/**\n+     * {@return a new StableArray with the provided length}\n+     *\n+     * @param <V> type of StableValue the stable array holds\n+     * @throws IllegalArgumentException if the provided {@code length} is {@code < 0}\n+     *\/\n+    static <V> StableArray<V> of(int length) {\n+        if (length < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return StableArrayImpl.of(length);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/StableArray.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+package jdk.internal.lang;\n+\n+import jdk.internal.lang.stable.StableArray2DImpl;\n+import jdk.internal.lang.stable.StableArrayImpl;\n+import jdk.internal.lang.stable.TrustedFieldType;\n+\n+\/**\n+ * An atomic, thread-safe, stable array holder for which components can be set at most once.\n+ * <p>\n+ * Stable arrays are eligible for certain optimizations by the JVM.\n+ * <p>\n+ * The total number of components in a stable array can not exceed about 2<sup>31<\/sup>.\n+ *\n+ * @param <V> type of StableValue that this stable array holds\n+ * @since 23\n+ *\/\n+public sealed interface StableArray2D<V>\n+        extends TrustedFieldType\n+        permits StableArray2DImpl {\n+\n+    \/**\n+     * {@return the {@code [i0][i1]} component of this stable array}\n+     *\n+     * @param i0 first index to use as a component index\n+     * @param i1 second index to use as a component index\n+     * @throws ArrayIndexOutOfBoundsException if {@code X \\u2208 [0, 1],\n+     *         iX < 0 || iX >= length(X)}\n+     *\/\n+    StableValue<V> get(int i0, int i1);\n+\n+    \/**\n+     * {@return the length of the provided {@code dimension}}\n+     *\n+     * @throws IllegalArgumentException if {@code dimension < 0 || dimension >= 2}\n+     *\/\n+    int length(int dimension);\n+\n+    \/**\n+     * {@return a new StableArray2D with the provided dimensions}\n+     * @param <V> type of StableValue the stable array holds\n+     * @throws IllegalArgumentException if either of the provided dimensions\n+     *         {@code dim0} or {@code dim1} are {@code < 0}\n+     *\/\n+    static <V> StableArray2D<V> of(int dim0, int dim1) {\n+        if (dim0 < 0 || dim1 < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return StableArray2DImpl.of(dim0, dim1);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/StableArray2D.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+package jdk.internal.lang;\n+\n+import jdk.internal.lang.stable.StableArray2DImpl;\n+import jdk.internal.lang.stable.StableArray3DImpl;\n+import jdk.internal.lang.stable.TrustedFieldType;\n+\n+\/**\n+ * An atomic, thread-safe, stable array holder for which components can be set at most once.\n+ * <p>\n+ * Stable arrays are eligible for certain optimizations by the JVM.\n+ * <p>\n+ * The total number of components in a stable array can not exceed about 2<sup>31<\/sup>.\n+ *\n+ * @param <V> type of StableValue that this stable array holds\n+ * @since 23\n+ *\/\n+public sealed interface StableArray3D<V>\n+        extends TrustedFieldType\n+        permits StableArray3DImpl {\n+\n+    \/**\n+     * {@return the {@code [i0][i1][i2} component of this stable array}\n+     *\n+     * @param i0 first index to use as a component index\n+     * @param i1 second index to use as a component index\n+     * @param i2 third index to use as a component index\n+     * @throws ArrayIndexOutOfBoundsException if {@code X \\u2208 [0, 2],\n+     *         iX < 0 || iX >= length(X)}\n+     *\/\n+    StableValue<V> get(int i0, int i1, int i2);\n+\n+    \/**\n+     * {@return the length of the provided {@code dimension}}\n+     *\n+     * @throws IllegalArgumentException if {@code dimension < 0 || dimension >= 3}\n+     *\/\n+    int length(int dimension);\n+\n+    \/**\n+     * {@return a new StableArray2D with the provided dimensions}\n+     * @param <V> type of StableValue the stable array holds\n+     * @throws IllegalArgumentException if either of the provided dimensions\n+     *         {@code dim0} or {@code dim1} are {@code < 0}\n+     *\/\n+    static <V> StableArray3D<V> of(int dim0, int dim1, int dim2) {\n+        if (dim0 < 0 || dim1 < 0 || dim2 < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return StableArray3DImpl.of(dim0, dim1, dim2);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/StableArray3D.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,442 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang;\n+\n+import jdk.internal.lang.stable.StableAccess;\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.lang.stable.TrustedFieldType;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * An atomic, thread-safe, stable value holder for which the value can be set at most once.\n+ * <p>\n+ * Stable values are eligible for certain optimizations by the JVM.\n+ * <p>\n+ * A stable value is said to be monotonic because the state of a stable value can only go\n+ * from <em>unset<\/em> to <em>set<\/em> and consequently, a value can only be set\n+ * at most once.\n+ <p>\n+ * To create a new fresh (unset) StableValue, use the {@linkplain StableValue#of()}\n+ * factory.\n+ * <p>\n+ * To create collections of <em>wrapped stable elements<\/em>, that, in turn, are also\n+ * eligible for certain JVM optimizations, the following factories can be used:\n+ * <ul>\n+ *     <li>{@linkplain StableValue#ofList(int)}<\/li>\n+ *     <li>{@linkplain StableValue#ofMap(Set)}<\/li>\n+ *<\/ul>\n+ * <p>\n+ * Except for a StableValue's value itself, all method parameters must be <em>non-null<\/em>\n+ * and all collections provided must only contain <em>non-null<\/em> elements or a\n+ * {@link NullPointerException} will be thrown.\n+ *\n+ * @param <V> value type\n+ * @since 23\n+ *\/\n+public sealed interface StableValue<V>\n+        extends TrustedFieldType\n+        permits StableValueImpl {\n+\n+    \/**\n+     * {@return the set value (nullable) if set, otherwise throws\n+     * {@code NoSuchElementException}}\n+     *\n+     * @throws NoSuchElementException if no value is set\n+     * @throws NoSuchElementException if {@linkplain #isError()} is {@code true}\n+     *\/\n+    V orThrow();\n+\n+    \/**\n+     * {@return {@code true} if a value is set, otherwise {@code false}}\n+     *\/\n+    boolean isSet();\n+\n+    \/**\n+     * {@return {@code true} if an error occurred during\n+     * {@linkplain #computeIfUnset(Supplier) computation} , otherwise {@code false}}\n+     *\/\n+    boolean isError();\n+\n+    \/**\n+     * {@return {@code true} if the stable value was previously unset and is now set\n+     * to the provided (nullable) {@code value}, otherwise returns {@code false}}\n+     * @param value to set (nullable)\n+     *\/\n+    boolean trySet(V value);\n+\n+    \/**\n+     * If no value is set, sets the stable value to the provided (nullable)\n+     * {@code value}, returning the (pre-existing or newly set) value.\n+     * <p>\n+     * If several threads invoke this method simultaneously, only one thread will succeed\n+     * in setting a value and that (witness) value will be returned to all threads.\n+     *\n+     * @param value to set (nullable)\n+     * @return the bound value\n+     * @throws NoSuchElementException if {@linkplain #isError()} is {@code true}\n+     *\/\n+    V setIfUnset(V value);\n+\n+    \/**\n+     * If no value {@linkplain #isSet() is set}, attempts to compute and set a\n+     * new (nullable) value using the provided {@code supplier}, returning the\n+     * (pre-existing or newly set) value.\n+     *\n+     * <p>\n+     * If the supplier throws an (unchecked) exception, the exception is rethrown, and no\n+     * value is set and {@linkplain #isError()} will return {@code true}. The most common\n+     * usage is to construct a new object serving as a lazily computed value or memoized\n+     * result, as in:\n+     *\n+     * <pre> {@code\n+     * Value witness = stable.computeIfUnset(Value::new);\n+     * }<\/pre>\n+     *\n+     * @implSpec The implementation logic is equivalent to the following steps for this\n+     * {@code stable}:\n+     *\n+     * <pre> {@code\n+     * if (stable.isSet()) {\n+     *     return stable.get();\n+     * } else {\n+     *     V newValue = supplier.get();\n+     *     stable.setOrThrow(newValue);\n+     *     return newValue;\n+     * }\n+     * }<\/pre>\n+     * Except it is atomic, thread-safe and will only return the same witness value\n+     * regardless if invoked by several threads. Also, the provided {@code supplier}\n+     * will only be invoked once even if invoked from several threads and if the\n+     * {@code supplier} throws an exception, the stable value will be in an error state.\n+     *\n+     * \/\/ Todo: Should we wrap supplier exceptions into a specific exception type?\n+     *\n+     * @param  supplier to be used for computing a value\n+     * @return the current (pre-existing or computed) value\n+     * @throws NoSuchElementException if {@linkplain #isError()} is {@code true}\n+     * @throws StackOverflowError if the provided {@code supplier} recursively\n+     *         invokes this method upon being invoked.\n+     *\/\n+    V computeIfUnset(Supplier<? extends V> supplier);\n+\n+    \/\/ Factories\n+\n+    \/**\n+     * {@return a fresh stable value with an unset value}\n+     *\n+     * @param <V> the value type to set\n+     *\/\n+    static <V> StableValue<V> of() {\n+        return StableValueImpl.of();\n+    }\n+\n+    \/**\n+     * {@return a fresh stable value with an unset value where its value is computed in\n+     * a separate background thread (created via the provided {@code threadFactory})\n+     * using the provided {@code supplier}}\n+     * <p>\n+     * If the supplier throws an (unchecked) exception, the exception is forwarded to\n+     * the thread's {@linkplain Thread#getUncaughtExceptionHandler()} (if any) and no\n+     * value is set.\n+     * <p>\n+     * Here is how a custom exception listener can be attached to the background thread:\n+     *\n+     * {@snippet lang=java :\n+     * AtomicReference<Throwable> holder = new AtomicReference<>();\n+     *\n+     * ThreadFactory factory =\n+     *         Thread.ofVirtual()\n+     *                 .uncaughtExceptionHandler((t, e) -> holder.set(e))\n+     *                 .factory();\n+     *\n+     * StableValue<V> stable = StableValue.ofBackground(factory, computeV());\n+     * }\n+     *\n+     * @param <V>               the value type to set\n+     * @param threadFactory     to use when creating the background thread\n+     * @param supplier          to be used for computing a value\n+     * @see StableValue#of\n+     *\/\n+    static <V> StableValue<V> ofBackground(ThreadFactory threadFactory,\n+                                           Supplier<? extends V> supplier) {\n+        Objects.requireNonNull(threadFactory);\n+        Objects.requireNonNull(supplier);\n+        return StableValueImpl.ofBackground(threadFactory, supplier);\n+    }\n+\n+    \/\/ Collection factories\n+\n+    \/**\n+     * {@return an unmodifiable, shallowly immutable, thread-safe, stable,\n+     * {@linkplain List} containing {@code size} {@linkplain StableValue } elements}\n+     * <p>\n+     * If non-empty, neither the returned list nor its elements are {@linkplain Serializable}.\n+     * <p>\n+     * The returned list and its elements are eligible for certain optimizations by\n+     * the JVM and is equivalent to:\n+     * {@snippet lang = java:\n+     * List<StableValue<V>> list = Stream.generate(StableValue::<V>of)\n+     *         .limit(size)\n+     *         .toList();\n+     *}\n+     * Except it requires less storage, does not return stable value instances with the\n+     * same identity, and is likely to exhibit better performance.\n+     * <p>\n+     * This static factory methods return list instances (and with all their elements)\n+     * that are <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>,\n+     * immutable and thread-safe. Programmers should not use list and element instances\n+     * for synchronization, or unpredictable behavior may occur. For example, in a\n+     * future release, synchronization may fail. Consequently,\n+     * query methods {@linkplain List#contains(Object)},\n+     * {@linkplain List#containsAll(Collection)} (if non-empty),\n+     * {@linkplain List#indexOf(Object)}, {@linkplain List#lastIndexOf(Object)}, and\n+     * methods that relies on these method or similar methods will always indicate\n+     * no match.\n+     *\n+     * @param <V>  the generic type of the stable value elements in the returned {@code List}\n+     * @param size the number of elements in the list\n+     * @throws IllegalArgumentException if the provided {@code size} is negative\n+     *\n+     * @since 23\n+     *\/\n+    static <V> List<StableValue<V>> ofList(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return StableAccess.ofList(size);\n+    }\n+\n+    \/**\n+     * {@return an unmodifiable, shallowly immutable, thread-safe, value-stable,\n+     * {@linkplain Map} where the {@linkplain java.util.Map#keySet() keys}\n+     * contains precisely the distinct provided set of {@code keys} and where the\n+     * stable values are, in turn, lazily computed upon being accessed\n+     * (e.g. via {@linkplain Map#get(Object) get(key)})}\n+     * <p>\n+     * If non-empty, neither the returned map nor its values are {@linkplain Serializable}.\n+     * <p>\n+     * The returned map and its values are eligible for certain optimizations by\n+     * the JVM and is equivalent to:\n+     * {@snippet lang = java:\n+     * Map<K, StableValue<V>> map = Map.copyOf(keys.stream()\n+     *         .distinct()\n+     *         .map(Objects::requireNonNull)\n+     *         .collect(Collectors.toMap(Function.identity(), _ -> StableValue.of())));\n+     * }\n+     * Except it requires less storage, does not return stable value instances with the\n+     * same identity, and is likely to exhibit better performance.\n+     * <p>\n+     * This static factory methods return map instances (and with all their values)\n+     * that are <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>,\n+     * immutable and thread-safe. Programmers should not use map and value instances for\n+     * synchronization, or unpredictable behavior may occur. For example, in a\n+     * future release, synchronization may fail. Consequently,\n+     * the query methods {@linkplain Map#containsValue(Object)} and methods that relies\n+     * on this and similar method will always indicate no match.\n+     * <p>\n+     * As an emerging property, providing an {@linkplain EnumSet} as {@code keys} will\n+     * make the returned Map eligible for certain additional optimizations.\n+     *\n+     * @param keys the keys in the map\n+     * @param <K>  the type of keys maintained by the returned map\n+     * @param <V>  the type of mapped StableValue values\n+     *\/\n+    static <K, V> Map<K, StableValue<V>> ofMap(Set<? extends K> keys) {\n+        Objects.requireNonNull(keys);\n+        return StableAccess.ofMap(keys);\n+    }\n+\n+    \/\/ Support functions for stable collections\n+\n+    \/**\n+     * If no value {@linkplain #isSet() is set} for the StableValue at the provided\n+     * {@code index}, attempts to compute and set it as per\n+     * {@linkplain StableValue#computeIfUnset(Supplier)} by applying the provided\n+     * {@code mapper}.\n+     * <p>\n+     * This is equivalent to:\n+     * {@snippet lang = java:\n+     * StableValue<V> stable = list.get(index);\n+     * if (stable.isSet()) {\n+     *     return stable.orThrow();\n+     * }\n+     * Supplier<V> supplier = () -> mapper.apply(index);\n+     * return stable.computeIfUnset(supplier);\n+     *}\n+     * Except it guarantees that the provided mapper is invoked at most once per distinct\n+     * index and might be more resource efficient and performant.\n+     *\n+     * @param list   from which to get a StableValue\n+     * @param index  for the StableValue\n+     * @param mapper to apply if the StableValue at the provided {@code index} is\n+     *               {@linkplain StableValue#isSet() not set}\n+     * @return the current (pre-existing or computed) value at the provided {@code index}\n+     * @param <V> the StableValue type to set\n+     * @throws NoSuchElementException if {@linkplain #isError()} is {@code true} for\n+     *         the provided {@code index}\n+     * @throws IndexOutOfBoundsException if the provided {@code index} is less than\n+     *         zero or {@code index >= list.size()}\n+     * @throws StackOverflowError if the provided {@code mapper} recursively invoke\n+     *         this method for the same {@code index}\n+     *\/\n+    static <V> V computeIfUnset(List<StableValue<V>> list,\n+                                int index,\n+                                IntFunction<? extends V> mapper) {\n+        Objects.requireNonNull(list);\n+        Objects.checkIndex(index, list.size());\n+        Objects.requireNonNull(mapper);\n+        return StableAccess.computeIfUnset(list, index, mapper);\n+    }\n+\n+    \/**\n+     * If no value {@linkplain #isSet() is set} for the StableValue for the provided\n+     * {@code key}, attempts to compute and set it as per\n+     * {@linkplain StableValue#computeIfUnset(Supplier)} by applying the provided\n+     * {@code mapper}.\n+     * <p>\n+     * This is equivalent to:\n+     * {@snippet lang = java:\n+     * StableValue<V> stable = map.get(key);\n+     * if (stable == null) {\n+     *      throw new NoSuchElementException(\"Unknown key: \"+key);\n+     * }\n+     * if (stable.isSet()) {\n+     *     return stable.orThrow();\n+     * }\n+     * Supplier<V> supplier = () -> mapper.apply(key);\n+     * return stable.computeIfUnset(supplier);\n+     *}\n+     * Except it guarantees that the provided mapper is invoked at most once per distinct\n+     * key and might be more resource efficient and performant.\n+     *\n+     * @param map    from which to get a Stab;eValue\n+     * @param key    associated with a StableValue\n+     * @param mapper to apply if the StableValue associated with the provided {@code key}\n+     *               is {@linkplain StableValue#isSet() not set}\n+     * @return the current (pre-existing or computed) value for the provided {@code key}\n+     * @param <K> the type of keys maintained by this map\n+     * @param <V> the StableValue value type to set\n+     * @throws NoSuchElementException if {@linkplain #isError()} is {@code true} for\n+     *         the provided {@code key}\n+     * @throws NoSuchElementException if the provided {@code map} does not\n+     *         {@linkplain Map#containsKey(Object) contain} the provided {@code key}\n+     * @throws StackOverflowError if the provided {@code mapper} recursively invoke\n+     *         this method for the same {@code key}\n+     *\/\n+    static <K, V> V computeIfUnset(Map<K, StableValue<V>> map,\n+                                   K key,\n+                                   Function<? super K, ? extends V> mapper) {\n+        Objects.requireNonNull(map);\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(mapper);\n+        return StableAccess.computeIfUnset(map, key, mapper);\n+    }\n+\n+    \/\/ Memoized factories\n+\n+    \/**\n+     * {@return a new <em>memoized<\/em> {@linkplain Supplier} backed by an internal\n+     * stable value where the provided {@code original} supplier will only be invoked\n+     * at most once}\n+     * <p>\n+     * If the {@code original} suppler invokes the returned supplier recursively,\n+     * a StackOverflowError will be thrown when the returned supplier's\n+     * {@linkplain Supplier#get()} method is invoked.\n+     *\n+     * @param original the original Suppler to convert to a memoized Supplier\n+     * @param <T>      the memoized type\n+     *\/\n+    static <T> Supplier<T> memoizedSupplier(Supplier<? extends T> original) {\n+        Objects.requireNonNull(original);\n+        StableValue<T> stable = StableValue.of();\n+        return StableAccess.ofSupplier(stable, original);\n+    }\n+\n+    \/**\n+     * {@return a new <em>memoized<\/em> {@linkplain IntFunction } backed by an internal\n+     * stable list of the provided {@code size} where the provided {@code original}\n+     * IntFunction will only be invoked at most once per distinct {@code int} value}\n+     * <p>\n+     * If the {@code original} IntFunction invokes the returned IntFunction recursively\n+     * for a specific input value, a StackOverflowError will be thrown when the returned\n+     * IntFunction's {@linkplain IntFunction#apply(int)} ()} method is invoked.\n+     * <p>\n+     * The returned IntFunction will throw {@linkplain IndexOutOfBoundsException} if\n+     * {@linkplain IntFunction#apply(int)} is invoked with a value {@code < 0 || > size}.\n+     *\n+     * @param size     the number of elements in the backing list\n+     * @param original the original IntFunction to convert to a memoized IntFunction\n+     * @param <R>      the return type of the IntFunction\n+     *\/\n+    static <R> IntFunction<R> memoizedIntFunction(int size,\n+                                                  IntFunction<? extends R> original) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        Objects.requireNonNull(original);\n+        List<StableValue<R>> stableList = StableValue.ofList(size);\n+        return StableAccess.ofIntFunction(stableList, original);\n+    }\n+\n+    \/**\n+     * {@return a new <em>memoized<\/em> {@linkplain Function } backed by an internal\n+     * stable map with the provided {@code inputs} keys where the provided\n+     * {@code original} Function will only be invoked at most once per distinct input}\n+     * <p>\n+     * If the {@code original} Function invokes the returned Function recursively\n+     * for a specific input value, a StackOverflowError will be thrown when the returned\n+     * Function's {@linkplain Function#apply(Object)}} method is invoked.\n+     * <p>\n+     * The returned Function will throw {@linkplain NoSuchElementException} if\n+     * {@linkplain Function#apply(Object)} is invoked with a value that is not in the\n+     * given {@code input} Set.\n+     *\n+     * @param original the original Function to convert to a memoized Function\n+     * @param inputs   the potential input values to the Function\n+     * @param <T>      the type of input values\n+     * @param <R>      the return type of the function\n+     *\/\n+    static <T, R> Function<T, R> memoizedFunction(Set<? extends T> inputs,\n+                                                  Function<? super T, ? extends R> original) {\n+        Objects.requireNonNull(inputs);\n+        Objects.requireNonNull(original);\n+        Map<T, StableValue<R>> stableMap = StableValue.ofMap(inputs);\n+        return StableAccess.ofFunction(stableMap, original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/StableValue.java","additions":442,"deletions":0,"binary":false,"changes":442,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.access.JavaUtilCollectionAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.lang.StableValue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+public final class StableAccess {\n+\n+    private StableAccess() {}\n+\n+    private static final JavaUtilCollectionAccess ACCESS =\n+            SharedSecrets.getJavaUtilCollectionAccess();\n+\n+    public static <V> List<StableValue<V>> ofList(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (size == 0) {\n+            return List.of();\n+        }\n+        return ACCESS.stableList(size);\n+    }\n+\n+    public static <V> V computeIfUnset(List<StableValue<V>> list,\n+                                       int index,\n+                                       IntFunction<? extends V> mapper) {\n+        return ACCESS.computeIfUnset(list, index, mapper);\n+    }\n+\n+    public static <K, V> Map<K, StableValue<V>> ofMap(Set<? extends K> keys) {\n+        if (keys.isEmpty()) {\n+            return Map.of();\n+        }\n+        return ACCESS.stableMap(keys);\n+    }\n+\n+    public static <K, V> V computeIfUnset(Map<K, StableValue<V>> map,\n+                                          K key,\n+                                          Function<? super K, ? extends V> mapper) {\n+        return ACCESS.computeIfUnset(map, key, mapper);\n+    }\n+\n+    public static <T> Supplier<T> memoizedSupplier(StableValue<T> stable,\n+                                                   Supplier<? extends T> original) {\n+        return new MemoizedSupplier<>(stable, original);\n+    }\n+\n+    public static <R> IntFunction<R> memoizedIntFunction(List<StableValue<R>> stableList,\n+                                                         IntFunction<? extends R> original) {\n+        return new MemoizedIntFunction<>(stableList, original);\n+    }\n+\n+    public static <T, R> Function<T, R> memoizedFunction(Map<T, StableValue<R>> stableMap,\n+                                                         Function<? super T, ? extends R> original) {\n+        return new MemoizedFunction<>(stableMap, original);\n+    }\n+\n+    private record MemoizedSupplier<T>(StableValue<T> stable,\n+                                       Supplier<? extends T> original) implements Supplier<T> {\n+\n+        @Override\n+        public T get() {\n+            return stable.computeIfUnset(original);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return this == obj;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(this);\n+        }\n+    }\n+\n+    private record MemoizedIntFunction<R>(List<StableValue<R>> stableList,\n+                                          IntFunction<? extends R> original) implements IntFunction<R> {\n+\n+        @Override\n+        public R apply(int value) {\n+            return StableValue.computeIfUnset(stableList, value, original);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return this == obj;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(this);\n+        }\n+\n+    }\n+\n+    private record MemoizedFunction<T, R>(Map<T, StableValue<R>> stableMap,\n+                                          Function<? super T, ? extends R> original) implements Function<T, R> {\n+\n+        @Override\n+        public R apply(T t) {\n+            return StableValue.computeIfUnset(stableMap, t, original);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return this == obj;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(this);\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableAccess.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.lang.StableArray2D;\n+import jdk.internal.lang.StableValue;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Objects;\n+\n+public record StableArray2DImpl<V>(\n+        @Stable int dim0,\n+        @Stable int dim1,\n+        @Stable StableValueImpl<V>[] elements\n+) implements StableArray2D<V> {\n+\n+    private StableArray2DImpl(int dim0, int dim1) {\n+        this(dim0, dim1, StableUtil.newStableValueArray(Math.multiplyExact(dim0, dim1)));\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public StableValue<V> get(int i0, int i1) {\n+        Objects.checkIndex(i0, dim0);\n+        Objects.checkIndex(i1, dim1);\n+        final int index = i0 * dim0 + i1;\n+        StableValueImpl<V> stable = elements[index];\n+        return stable == null\n+                ? StableUtil.getOrSetVolatile(elements, index)\n+                : stable;\n+    }\n+\n+    @Override\n+    public int length(int dimension) {\n+        return switch (dimension) {\n+            case  0 -> dim0;\n+            case  1 -> dim1;\n+            default -> throw new IllegalArgumentException();\n+        };\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (dim0 == 0 || dim1 == 0) {\n+            return \"[]\";\n+        }\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        final int dim0 = length(0);\n+        final int dim1 = length(1);\n+        for (int i = 0; i < dim0; i++) {\n+            if (i != 0) {\n+                sb.append(',').append(' ');\n+            }\n+            sb.append('[');\n+            for (int j = 0; j < dim1; j++) {\n+                if (j != 0) {\n+                    sb.append(',').append(' ');\n+                }\n+                final StableValue<V> stable = get(i, j);\n+                if (stable.isSet()) {\n+                    final V v = stable.orThrow();\n+                    sb.append(v == this ? \"(this StableArray)\" : stable);\n+                } else {\n+                    sb.append(stable);\n+                }\n+            }\n+            sb.append(']');\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    public static <V> StableArray2D<V> of(int dim0, int dim1) {\n+        return new StableArray2DImpl<>(dim0, dim1);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableArray2DImpl.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.lang.StableArray3D;\n+import jdk.internal.lang.StableValue;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Objects;\n+\n+public record StableArray3DImpl<V>(\n+        @Stable int dim0,\n+        @Stable int dim1,\n+        @Stable int dim2,\n+        @Stable StableValueImpl<V>[] elements\n+) implements StableArray3D<V> {\n+\n+    private StableArray3DImpl(int dim0, int dim1, int dim2) {\n+        this(dim0, dim1, dim2, StableUtil.newStableValueArray(Math.multiplyExact(Math.multiplyExact(dim0, dim1), dim2)));\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public StableValue<V> get(int i0, int i1, int i2) {\n+        Objects.checkIndex(i0, dim0);\n+        Objects.checkIndex(i1, dim1);\n+        Objects.checkIndex(i2, dim2);\n+        final int index = i0 * dim1 * dim2 + i1 * dim2 + i2;\n+        StableValueImpl<V> stable = elements[index];\n+        return stable == null\n+                ? StableUtil.getOrSetVolatile(elements, index)\n+                : stable;\n+    }\n+\n+    @Override\n+    public int length(int dimension) {\n+        return switch (dimension) {\n+            case  0 -> dim0;\n+            case  1 -> dim1;\n+            case  2 -> dim2;\n+            default -> throw new IllegalArgumentException();\n+        };\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (dim0 == 0 || dim1 == 0 || dim2 == 0) {\n+            return \"[]\";\n+        }\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        final int dim0 = length(0);\n+        final int dim1 = length(1);\n+        final int dim2 = length(2);\n+        for (int i0 = 0; i0 < dim0; i0++) {\n+            if (i0 != 0) {\n+                sb.append(',').append(' ');\n+            }\n+            sb.append('[');\n+            for (int i1 = 0; i1 < dim1; i1++) {\n+                if (i1 != 0) {\n+                    sb.append(',').append(' ');\n+                }\n+                sb.append('[');\n+                for (int i2 = 0; i2 < dim2; i2++) {\n+                    if (i2 != 0) {\n+                        sb.append(',').append(' ');\n+                    }\n+                    final StableValue<V> stable = get(i0, i1, i2);\n+                    if (stable.isSet()) {\n+                        final V v = stable.orThrow();\n+                        sb.append(v == this ? \"(this StableArray)\" : stable);\n+                    } else {\n+                        sb.append(stable);\n+                    }\n+                }\n+                sb.append(']');\n+            }\n+            sb.append(']');\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    public static <V> StableArray3D<V> of(int dim0, int dim1, int dim2) {\n+        return new StableArray3DImpl<>(dim0, dim1, dim2);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableArray3DImpl.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.lang.StableArray;\n+import jdk.internal.lang.StableValue;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Objects;\n+\n+public record StableArrayImpl<V>(\n+        @Stable StableValueImpl<V>[] elements\n+) implements StableArray<V> {\n+\n+    private StableArrayImpl(int length) {\n+        this(StableUtil.newStableValueArray(length));\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public StableValue<V> get(int firstIndex) {\n+        Objects.checkIndex(firstIndex, elements.length);\n+        StableValueImpl<V> stable = elements[firstIndex];\n+        return stable == null\n+                ? StableUtil.getOrSetVolatile(elements, firstIndex)\n+                : stable;\n+    }\n+\n+    @Override\n+    public int length() {\n+        return elements.length;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (length() == 0) {\n+            return \"[]\";\n+        }\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < length(); i++) {\n+            if (i != 0) {\n+                sb.append(',').append(' ');\n+            }\n+            final StableValue<V> stable = get(i);\n+            if (stable.isSet()) {\n+                V v = stable.orThrow();\n+                sb.append(v == this ? \"(this StableArray)\" : stable);\n+            } else {\n+                sb.append(stable);\n+            }\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    public static <V> StableArray<V> of(int length) {\n+        return new StableArrayImpl<>(length);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableArrayImpl.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+import static jdk.internal.misc.Unsafe.*;\n+\n+\/**\n+ * Package private utility class for stable values & collections.\n+ *\/\n+public final class StableUtil {\n+\n+    private StableUtil() {}\n+\n+    \/\/ Indicates a value is not set\n+    static final byte UNSET = 0;\n+    \/\/ Indicates a value is set to a `null` value\n+    static final byte NULL = 1;\n+    \/\/ Indicates a value is set to a non-null value\n+    static final byte NON_NULL = 2; \/\/ The middle value\n+    \/\/ Indicates there was an error when computing a value\n+    static final byte ERROR = 3;\n+    \/\/ Added to create an odd number of switch alternatives\n+    static final byte DUMMY = 4;\n+\n+    \/\/ Indicates a computation operation has been invoked.\n+    static final byte INVOKED = 1;\n+\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Sentinel value used to mark that a mutex will not be used anymore\n+    static final Object TOMBSTONE = new Object();\n+\n+    static IllegalStateException alreadySet(StableValue<?> stable) {\n+        return new IllegalStateException(\"A value is already set: \" + stable.orThrow());\n+    }\n+\n+    static NoSuchElementException notSet() {\n+        return new NoSuchElementException(\"No value set\");\n+    }\n+\n+    static NoSuchElementException error(StableValue<?> stable) {\n+        return new NoSuchElementException(\"An error occurred during computation\");\n+    }\n+\n+    static StackOverflowError stackOverflow(Object provider, Object key) {\n+        final String typeText = switch (provider) {\n+            case Supplier<?> _    -> \"Supplier.get()\";\n+            case IntFunction<?> _ -> \"IntFunction.apply(\" + key + \")\";\n+            case Function<?, ?> _ -> \"Function.apply(\" + key + \")\";\n+            default               -> throw shouldNotReachHere();\n+        };\n+        return new StackOverflowError(\n+                \"Recursive invocation of \" + typeText + \": \" + provider);\n+    }\n+\n+    \/**\n+     * {@return a String representation of the provided {@code stable}}\n+     * @param stable to extract a string representation from\n+     *\/\n+    static String toString(StableValue<?> stable,\n+                           Function<Object, String> errorMessageMapper) {\n+        return \"StableValue\" +\n+                (stable.isSet()\n+                        ? \"[\" + stable.orThrow() + \"]\"\n+                        : stable.isError() ? \".error(\" + errorMessageMapper.apply(stable) + \")\" : \".unset\");\n+    }\n+\n+    \/**\n+     * Performs a \"freeze\" operation, required to ensure safe publication under plain\n+     * memory read semantics.\n+     * <p>\n+     * This inserts a memory barrier, thereby establishing a happens-before constraint.\n+     * This prevents the reordering of store operations across the freeze boundary.\n+     *\/\n+    static void freeze() {\n+        \/\/ Issue a store fence, which is sufficient\n+        \/\/ to provide protection against store\/store reordering.\n+        \/\/ See VarHandle::releaseFence\n+        UNSAFE.storeStoreFence();\n+    }\n+\n+    static InternalError shouldNotReachHere() {\n+        return new InternalError(\"Should not reach here\");\n+    }\n+\n+    static boolean isMutexNotNeeded(Object mutex) {\n+        return mutex == TOMBSTONE || mutex instanceof Throwable;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <V> StableValueImpl<V>[] newStableValueArray(int length) {\n+        return (StableValueImpl<V>[]) new StableValueImpl<?>[length];\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @DontInline\n+    public static <V> StableValueImpl<V> getOrSetVolatile(StableValue<V>[] elements, int index) {\n+        final class Holder {\n+            private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+        }\n+        long offset = Unsafe.ARRAY_OBJECT_BASE_OFFSET + Unsafe.ARRAY_OBJECT_INDEX_SCALE * (long) index;\n+        StableValueImpl<V> stable = (StableValueImpl<V>)Holder.UNSAFE.getReferenceVolatile(elements, offset);\n+        if (stable == null) {\n+            stable = StableValueImpl.of();\n+            StableValueImpl<V> witness = (StableValueImpl<V>)\n+                    Holder.UNSAFE.compareAndExchangeReference(elements, offset, null, stable);\n+            return witness == null ? stable : witness;\n+        }\n+        return stable;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.concurrent.ThreadFactory;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+import static jdk.internal.lang.stable.StableUtil.*;\n+\n+public final class StableValueImpl<V> implements StableValue<V> {\n+\n+    private static final long MUTEX_OFFSET =\n+            UNSAFE.objectFieldOffset(StableValueImpl.class, \"mutex\");\n+\n+    private static final long VALUE_OFFSET =\n+            UNSAFE.objectFieldOffset(StableValueImpl.class, \"value\");\n+\n+    private static final long STATE_OFFSET =\n+            UNSAFE.objectFieldOffset(StableValueImpl.class, \"state\");\n+\n+    private static final long COMPUTE_INVOKED_OFFSET =\n+            UNSAFE.objectFieldOffset(StableValueImpl.class, \"computeInvoked\");\n+\n+    \/\/ The fields below are read and written using a combination of plain memory access\n+    \/\/ and Unsafe volatile memory access.\n+\n+    \/**\n+     * An internal mutex used rather than synchronizing on `this`. Lazily created.\n+     * If `null`    , we have not entered a mutex section yet\n+     * If TOMBSTONE , we do not need synchronization anymore (isSet() && isError() = true)\n+     * if instanceof Throwable , records a previous error and, we do not need synchronization anymore\n+     * otherwise    , a distinct synchronization object\n+     *\/\n+    private Object mutex;\n+\n+    \/**\n+     * If non-null, holds a set value\n+     * If `null`  , may be unset or hold a set `null` value\n+     *\/\n+    @Stable\n+    private V value;\n+\n+    \/**\n+     * If StableUtil.NOT_SET  , a value is not set\n+     * If StableUtil.NON_NULL , a non-null value is set\n+     * If StableUtil.NULL     , a `null` value is set\n+     *\/\n+    @Stable\n+    private byte state;\n+\n+    \/**\n+     * Indicates a computation operation has been invoked. Used to\n+     * detect circular computation invocations.\n+     * 0                  , not invoked\n+     * StableUtil.INVOKED , invoked\n+     *\/\n+    @Stable\n+    private byte computeInvoked;\n+\n+    private StableValueImpl() {}\n+\n+    @ForceInline\n+    @Override\n+    public boolean isSet() {\n+        int s;\n+        return (s = state) == NON_NULL || s == NULL ||\n+                (s = stateVolatile()) == NON_NULL || s == NULL;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean isError() {\n+        return state == ERROR || stateVolatile() == ERROR;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public V orThrow() {\n+        \/\/ Optimistically try plain semantics first\n+        final V v = value;\n+        if (v != null) {\n+            \/\/ If we happen to see a non-null value under\n+            \/\/ plain semantics, we know a value is set.\n+            return v;\n+        }\n+        if (state == NULL) {\n+            \/\/ If we happen to see a state value of NULL under\n+            \/\/ plain semantics, we know a value is set to `null`.\n+            return null;\n+        }\n+        \/\/ Now, fall back to volatile semantics.\n+        return orThrowVolatile();\n+\n+\/*        \/\/ This is intentionally an old switch statement as it generates\n+        \/\/ more compact byte code.\n+        switch (state) {\n+            case UNSET:    { throw StableUtil.notSet(); }\n+            case NULL:     { return null; }\n+            case NON_NULL: { return value; }\n+            case ERROR:    { throw StableUtil.error(this); }\n+            case DUMMY:    { throw shouldNotReachHere(); }\n+        }\n+        throw shouldNotReachHere();*\/\n+\n+    }\n+\n+    @DontInline \/\/ Slow-path taken at most once per thread if set\n+    private V orThrowVolatile() {\n+        \/\/ This is intentionally an old switch statement as it generates\n+        \/\/ more compact byte code.\n+        switch (stateVolatile()) {\n+            case UNSET:    { throw StableUtil.notSet(); }\n+            case NULL:     { return null; }\n+            case NON_NULL: { return valueVolatile(); }\n+            case ERROR:    { throw StableUtil.error(this); }\n+            case DUMMY:    { throw shouldNotReachHere(); }\n+        }\n+        throw shouldNotReachHere();\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public V setIfUnset(V value) {\n+        if (isSet() || isError()) {\n+           return orThrow();\n+        }\n+        final var m = acquireMutex();\n+        if (isMutexNotNeeded(m)) {\n+            return orThrow();\n+        }\n+        synchronized (m) {\n+            if (isSet() || isError()) {\n+                return orThrow();\n+            }\n+            setValue(value);\n+            return value;\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean trySet(V value) {\n+        if (isSet() || isError()) {\n+            return false;\n+        }\n+        final var m = acquireMutex();\n+        if (isMutexNotNeeded(m)) {\n+            return false;\n+        }\n+        synchronized (m) {\n+            if (isSet() || isError()) {\n+                return false;\n+            }\n+            setValue(value);\n+            return true;\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public V computeIfUnset(Supplier<? extends V> supplier) {\n+        return computeIfUnsetShared(supplier, null);\n+    }\n+\n+    @ForceInline\n+    public V computeIfUnset(int index, IntFunction<? extends V> mapper) {\n+        return computeIfUnsetShared(mapper, index);\n+    }\n+\n+    @ForceInline\n+    public <K> V computeIfUnset(K key, Function<? super K, ? extends V> mapper) {\n+        return computeIfUnsetShared(mapper, key);\n+    }\n+\n+    @ForceInline\n+    private <K> V computeIfUnsetShared(Object provider, K key) {\n+        \/\/ Optimistically try plain semantics first\n+        final V v = value;\n+        if (v != null) {\n+            \/\/ If we happen to see a non-null value under\n+            \/\/ plain semantics, we know a value is set.\n+            return v;\n+        }\n+        if (state == NULL) {\n+            return null;\n+        }\n+        \/\/ Now, fall back to volatile semantics.\n+        return computeIfUnsetVolatile(provider, key);\n+    }\n+\n+    @DontInline\n+    private <K> V computeIfUnsetVolatile(Object provider, K key) {\n+        \/\/ This is intentionally an old switch statement as it generates\n+        \/\/ more compact byte code.\n+        switch (stateVolatile()) {\n+            case UNSET:    { return computeIfUnsetVolatile0(provider, key); }\n+            case NON_NULL: { return valueVolatile(); }\n+            case NULL:     { return null; }\n+            case ERROR:    { throw StableUtil.error(this); }\n+        }\n+        throw shouldNotReachHere();\n+    }\n+\n+    private <K> V computeIfUnsetVolatile0(Object provider, K key) {\n+        final var m = acquireMutex();\n+        if (isMutexNotNeeded(m)) {\n+            return orThrow();\n+        }\n+        synchronized (m) {\n+            if (state != UNSET) {\n+                return orThrow();\n+            }\n+\n+            if (!UNSAFE.compareAndSetByte(this, COMPUTE_INVOKED_OFFSET, (byte) 0, INVOKED)) {\n+                throw stackOverflow(provider, key);\n+            }\n+\n+            try {\n+                @SuppressWarnings(\"unchecked\")\n+                V newValue = switch (provider) {\n+                    case Supplier<?> sup     -> (V) sup.get();\n+                    case IntFunction<?> iFun -> (V) iFun.apply((int) key);\n+                    case Function<?, ?> func -> ((Function<K, V>) func).apply(key);\n+                    default                  -> throw shouldNotReachHere();\n+                };\n+                setValue(newValue);\n+                return newValue;\n+            } catch (Throwable t) {\n+                putState(ERROR);\n+                \/\/ For security reasons, we only store the exception type.\n+                putMutex(t.getClass());\n+                throw t;\n+            }\n+        }\n+    }\n+\n+    private static final Function<Object, String> ERROR_MESSAGE_EXTRACTOR = new Function<Object, String>() {\n+        @Override\n+        public String apply(Object stableValue) {\n+            StableValueImpl<?> svi = (StableValueImpl<?>) stableValue;\n+            return ((Class<?>) svi.acquireMutex())\n+                    .getName();\n+        }\n+    };\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.toString(this, ERROR_MESSAGE_EXTRACTOR);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private V valueVolatile() {\n+        return (V)UNSAFE.getReferenceVolatile(this, VALUE_OFFSET);\n+    }\n+\n+    private void setValue(V value) {\n+        if (value != null) {\n+            putValue(value);\n+        }\n+        \/\/ Crucially, indicate a value is set _after_ it has actually been set.\n+        putState(value == null ? NULL : NON_NULL);\n+        putMutex(TOMBSTONE); \/\/ We do not need a mutex anymore\n+    }\n+\n+    private void putValue(V value) {\n+        \/\/ This prevents partially initialized objects to be observed\n+        \/\/ under normal memory semantics.\n+        freeze();\n+        UNSAFE.putReferenceVolatile(this, VALUE_OFFSET, value);\n+    }\n+\n+    private int stateVolatile() {\n+        return UNSAFE.getByteVolatile(this, STATE_OFFSET);\n+    }\n+\n+    private void putState(byte newValue) {\n+        \/\/ This prevents `this.value` to be seen before `this.state` is seen\n+        freeze();\n+        UNSAFE.putByteVolatile(this, STATE_OFFSET, newValue);\n+    }\n+\n+    private Object acquireMutex() {\n+        Object mutex = UNSAFE.getReferenceVolatile(this, MUTEX_OFFSET);\n+        if (mutex == null) {\n+            mutex = caeMutex();\n+        }\n+        return mutex;\n+    }\n+\n+    private Object caeMutex() {\n+        final var created = new Object();\n+        final var witness = UNSAFE.compareAndExchangeReference(this, MUTEX_OFFSET, null, created);\n+        return witness == null ? created : witness;\n+    }\n+\n+    private void putMutex(Object value) {\n+        UNSAFE.putReferenceVolatile(this, MUTEX_OFFSET, value);\n+    }\n+\n+    \/\/ Factories\n+\n+    public static <V> StableValueImpl<V> of() {\n+        return new StableValueImpl<>();\n+    }\n+\n+    public static <V> StableValue<V> ofBackground(ThreadFactory threadFactory,\n+                                                  Supplier<? extends V> supplier) {\n+        final StableValue<V> stable = StableValue.of();\n+\n+        final class BgRunnable implements Runnable {\n+\n+            volatile Thread thread;\n+\n+            @Override\n+            public void run() {\n+                stable.computeIfUnset(supplier);\n+                \/\/ Exceptions are implicitly captured by the tread's\n+                \/\/ uncaught exception handler.\n+            }\n+        }\n+\n+        final BgRunnable runnable = new BgRunnable();\n+        Thread bgThread = threadFactory.newThread(runnable);\n+        runnable.thread = bgThread;\n+        bgThread.start();\n+        return stable;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.lang.StableArray;\n+import jdk.internal.lang.StableArray2D;\n+import jdk.internal.lang.StableArray3D;\n+import jdk.internal.lang.StableValue;\n+\n+\/**\n+ * This sealed marker interface signals fields that are _declared_ as a class that\n+ * implements this interface is \"trusted\" and therefore somewhat protected from being\n+ * modified via {@linkplain sun.misc.Unsafe} and {@linkplain java.lang.reflect.Field#setAccessible(boolean)}\n+ * operations.\n+ *\/\n+public sealed interface TrustedFieldType\n+        permits StableArray,\n+        StableArray2D,\n+        StableArray3D,\n+        StableValue { }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/TrustedFieldType.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -651,7 +651,1 @@\n-        Class<?> declaringClass = f.getDeclaringClass();\n-        if (declaringClass.isHidden()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a hidden class: \" + f);\n-        }\n-        if (declaringClass.isRecord()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a record class: \" + f);\n-        }\n+        assertNotTrusted(f);\n@@ -690,7 +684,1 @@\n-        Class<?> declaringClass = f.getDeclaringClass();\n-        if (declaringClass.isHidden()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a hidden class: \" + f);\n-        }\n-        if (declaringClass.isRecord()) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a record class: \" + f);\n-        }\n+        assertNotTrusted(f);\n@@ -721,0 +709,5 @@\n+        assertNotTrusted(f);\n+        return theInternalUnsafe.staticFieldBase(f);\n+    }\n+\n+    private static void assertNotTrusted(Field f) {\n@@ -728,1 +721,9 @@\n-        return theInternalUnsafe.staticFieldBase(f);\n+        Class<?> fieldType = f.getType();\n+        Class<?>[] interfaces = fieldType.getInterfaces();\n+        if (interfaces != null) {\n+            for (Class<?> inter : interfaces) {\n+                if (inter.getName().equals(\"jdk.internal.lang.stable.TrustedFieldType\")) {\n+                    throw new UnsupportedOperationException(\"can't get field offset for a field of type \" + fieldType.getName() + \": \" + f);\n+                }\n+            }\n+        }\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableArray implementations\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} BasicStableArray2DTest.java\n+ * @run junit\/othervm --enable-preview BasicStableArray2DTest\n+ *\/\n+\n+import jdk.internal.lang.StableArray2D;\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicStableArray2DTest {\n+\n+    private static final int DIM0 = 2;\n+    private static final int DIM1 = 3;\n+    private static final int I0 = 1;\n+    private static final int I1 = 2;\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 13;\n+\n+    private StableArray2D<Integer> arr;\n+\n+    @BeforeEach\n+    void setup() {\n+        arr =  StableArray2D.of(DIM0, DIM1);\n+    }\n+\n+    @Test\n+    void empty() {\n+        StableArray2D<Integer> empty = StableArray2D.of(0, 0);\n+        assertEquals(\"[]\", empty.toString());\n+        assertThrows(IndexOutOfBoundsException.class, () -> empty.get(0, 0));\n+        assertEquals(0, empty.length(0));\n+        assertEquals(0, empty.length(1));\n+    }\n+\n+    @Test\n+    void length() {\n+        assertEquals(DIM0, arr.length(0));\n+        assertEquals(DIM1, arr.length(1));\n+        assertThrows(IllegalArgumentException.class, () -> arr.length(-1));\n+        assertThrows(IllegalArgumentException.class, () -> arr.length(2));\n+    }\n+\n+    @Test\n+    void basic() {\n+        StableValue<Integer> stableUnset = StableValue.of(); \/\/ Separate stable\n+        assertEquals(\"[[\" + stableUnset + \", \" + stableUnset + \", \" + stableUnset + \"], \" +\n+                \"[\" + stableUnset + \", \" + stableUnset + \", \" + stableUnset + \"]]\", arr.toString());\n+        assertTrue(arr.get(I0, I1).trySet(VALUE));\n+        StableValue<Integer> stable = StableValue.of(); \/\/ Separate stable\n+        stable.trySet(VALUE);\n+        assertEquals(\"[[\" + stableUnset + \", \" + stableUnset + \", \" + stableUnset + \"], \" +\n+                \"[\" + stableUnset + \", \" + stableUnset + \", \" + stable + \"]]\", arr.toString());\n+        assertTrue(arr.get(I0, I1).isSet());\n+        assertFalse(arr.get(I0, I1).isError());\n+\n+        assertEquals(VALUE, arr.get(I0, I1).orThrow());\n+\n+        assertFalse(arr.get(I0, I1).trySet(VALUE2));\n+\n+        \/\/ No change\n+        assertEquals(VALUE, arr.get(I0, I1).computeIfUnset(() -> VALUE2));\n+        assertEquals(VALUE, arr.get(I0, I1).orThrow());\n+    }\n+\n+    @Test\n+    void computeThrows() {\n+        Supplier<Integer> throwingSupplier = () -> {\n+            throw new UnsupportedOperationException();\n+        };\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arr.get(I0, I1).computeIfUnset(throwingSupplier));\n+        assertTrue(arr.get(I0, I1).isError());\n+        assertFalse(arr.get(I0, I1).isSet());\n+\n+        StableValue<Integer> stable = StableValue.of();\n+        try {\n+            stable.computeIfUnset(throwingSupplier);\n+        } catch (UnsupportedOperationException _) {\n+            \/\/ Happy path\n+        }\n+        StableValue<Integer> stableUnset = StableValue.of(); \/\/ Separate stable\n+\n+        assertEquals(\"[[\" + stableUnset + \", \" + stableUnset + \", \" + stableUnset + \"], \" +\n+                \"[\" + stableUnset + \", \" + stableUnset + \", \" + stable + \"]]\", arr.toString());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/BasicStableArray2DTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableArray implementations\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} BasicStableArray3DTest.java\n+ * @run junit\/othervm --enable-preview BasicStableArray3DTest\n+ *\/\n+\n+import jdk.internal.lang.StableArray3D;\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicStableArray3DTest {\n+\n+    private static final int DIM0 = 2;\n+    private static final int DIM1 = 3;\n+    private static final int DIM2 = 4;\n+    private static final int I0 = 1;\n+    private static final int I1 = 2;\n+    private static final int I2 = 3;\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 13;\n+\n+    private StableArray3D<Integer> arr;\n+\n+    @BeforeEach\n+    void setup() {\n+        arr =  StableArray3D.of(DIM0, DIM1, DIM2);\n+    }\n+\n+    @Test\n+    void empty() {\n+        StableArray3D<Integer> empty = StableArray3D.of(0, 0, 0);\n+        assertEquals(\"[]\", empty.toString());\n+        assertThrows(IndexOutOfBoundsException.class, () -> empty.get(0, 0, 0));\n+        assertEquals(0, empty.length(0));\n+        assertEquals(0, empty.length(1));\n+        assertEquals(0, empty.length(2));\n+    }\n+\n+    @Test\n+    void length() {\n+        assertEquals(DIM0, arr.length(0));\n+        assertEquals(DIM1, arr.length(1));\n+        assertEquals(DIM2, arr.length(2));\n+        assertThrows(IllegalArgumentException.class, () -> arr.length(-1));\n+        assertThrows(IllegalArgumentException.class, () -> arr.length(3));\n+    }\n+\n+    @Test\n+    void oneTimesTwoTimesThree() {\n+        assertEquals(\"[\" +\n+                        \"[\" +\n+                        \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                        \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                        \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset]\" +\n+                        \"], [\" +\n+                        \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                        \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                        \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset]\" +\n+                        \"]\" +\n+                        \"]\"\n+        , arr.toString());\n+        assertTrue(arr.get(I0, I1, I2).trySet(VALUE));\n+        StableValue<Integer> stable = StableValue.of(); \/\/ Separate stable\n+        stable.trySet(VALUE);\n+        assertEquals(\"[\" +\n+                \"[\" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset]\" +\n+                \"], [\" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, \" + stable + \"]\" +\n+                \"]\" +\n+                \"]\", arr.toString());\n+        assertTrue(arr.get(I0, I1, I2).isSet());\n+        assertFalse(arr.get(I0, I1, I2).isError());\n+\n+        assertEquals(VALUE, arr.get(I0, I1, I2).orThrow());\n+\n+        assertFalse(arr.get(I0, I1, I2).trySet(VALUE2));\n+\n+        \/\/ No change\n+        assertEquals(VALUE, arr.get(I0, I1, I2).computeIfUnset(() -> VALUE2));\n+        assertEquals(VALUE, arr.get(I0, I1, I2).orThrow());\n+    }\n+\n+    @Test\n+    void computeThrows() {\n+        Supplier<Integer> throwingSupplier = () -> {\n+            throw new UnsupportedOperationException();\n+        };\n+\n+        StableArray3D<Integer> arr = StableArray3D.of(2, 3, 4);\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arr.get(I0, I1, I2).computeIfUnset(throwingSupplier));\n+        assertTrue(arr.get(I0, I1, I2).isError());\n+        assertFalse(arr.get(I0, I1, I2).isSet());\n+\n+        StableValue<Integer> stable = StableValue.of();\n+        try {\n+            stable.computeIfUnset(throwingSupplier);\n+        } catch (UnsupportedOperationException _) {\n+            \/\/ Happy path\n+        }\n+\n+        assertEquals(\"[\" +\n+                \"[\" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset]\" +\n+                \"], [\" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, StableValue.unset], \" +\n+                \"[StableValue.unset, StableValue.unset, StableValue.unset, \" + stable + \"]\" +\n+                \"]\" +\n+                \"]\", arr.toString());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/BasicStableArray3DTest.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableArray implementations\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} BasicStableArrayTest.java\n+ * @run junit\/othervm --enable-preview BasicStableArrayTest\n+ *\/\n+\n+import jdk.internal.lang.StableArray;\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicStableArrayTest {\n+\n+    private static final int DIM0 = 2;\n+    private static final int I0 = 1;\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 13;\n+\n+    private StableArray<Integer> arr;\n+\n+    @BeforeEach\n+    void setup() {\n+         arr =  StableArray.of(DIM0);\n+    }\n+\n+    @Test\n+    void empty() {\n+        StableArray<Integer> empty = StableArray.of(0);\n+        assertEquals(\"[]\", empty.toString());\n+        assertThrows(IndexOutOfBoundsException.class, () -> empty.get(0));\n+        assertEquals(0, empty.length());\n+    }\n+\n+    @Test\n+    void length() {\n+        assertEquals(DIM0, arr.length());\n+    }\n+\n+    @Test\n+    void basic() {\n+        assertEquals(\"[StableValue.unset, StableValue.unset]\", arr.toString());\n+        assertTrue(arr.get(I0).trySet(VALUE));\n+        StableValue<Integer> stable = StableValue.of(); \/\/ Separate stable\n+        stable.trySet(VALUE);\n+        assertEquals(\"[StableValue.unset, \" + stable + \"]\", arr.toString());\n+        assertTrue(arr.get(I0).isSet());\n+        assertFalse(arr.get(I0).isError());\n+\n+        assertEquals(VALUE, arr.get(I0).orThrow());\n+\n+        assertFalse(arr.get(I0).trySet(VALUE2));\n+\n+        \/\/ No change\n+        assertEquals(VALUE, arr.get(I0).computeIfUnset(() -> VALUE2));\n+        assertEquals(VALUE, arr.get(I0).orThrow());\n+    }\n+\n+    @Test\n+    void computeThrows() {\n+        Supplier<Integer> throwingSupplier = () -> {\n+            throw new UnsupportedOperationException();\n+        };\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arr.get(I0).computeIfUnset(throwingSupplier));\n+        assertTrue(arr.get(I0).isError());\n+        assertFalse(arr.get(I0).isSet());\n+\n+        StableValue<Integer> stable = StableValue.of();\n+        try {\n+            stable.computeIfUnset(throwingSupplier);\n+        } catch (UnsupportedOperationException _) {\n+            \/\/ Happy path\n+        }\n+        assertEquals(\"[StableValue.unset, \" + stable + \"]\", arr.toString());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/BasicStableArrayTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for stable enum Map implementations\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} BasicStableEnumMapTest.java\n+ * @run junit\/othervm --enable-preview BasicStableEnumMapTest\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicStableEnumMapTest {\n+\n+    enum TestEnum {\n+        A, B, C, D, E, F, G;\n+    }\n+\n+    private static final TestEnum KEY = TestEnum.C;\n+\n+    @Test\n+    void basic() {\n+        for (var set : sets()) {\n+            Map<TestEnum, StableValue<Integer>> map = StableValue.ofMap(set);\n+            assertEquals(set.isEmpty(), map.isEmpty());\n+\n+            for (TestEnum key : set) {\n+                assertFalse(\n+                        map.get(key)\n+                        .isSet());\n+            }\n+\n+            for (TestEnum key : set) {\n+                assertNotNull(map.get(key));\n+                assertTrue(map.containsKey(key));\n+            }\n+\n+            assertEquals(expectedToString(map), map.toString());\n+        }\n+    }\n+\n+    @Test\n+    void entrySet() {\n+        for (var set : sets()) {\n+            Map<TestEnum, StableValue<Integer>> map = StableValue.ofMap(set);\n+            var es = map.entrySet();\n+            assertEquals(set.size(), es.size());\n+        }\n+    }\n+\n+    @Test\n+    void entrySetIterator() {\n+        for (var set : sets()) {\n+            Map<TestEnum, StableValue<Integer>> map = StableValue.ofMap(set);\n+            var i = map.entrySet().iterator();\n+\n+            Set<TestEnum> seen = new HashSet<>();\n+            while (i.hasNext()) {\n+                seen.add(i.next().getKey());\n+            }\n+            assertEquals(set, seen);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void uoe(String name, Consumer<Map<TestEnum, StableValue<Integer>>> op) {\n+        for (var map:maps()) {\n+            assertThrows(UnsupportedOperationException.class, () -> op.accept(map), name);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullOperations\")\n+    void npe(String name, Consumer<Map<TestEnum, StableValue<Integer>>> op) {\n+        for (var map:maps()) {\n+            assertThrows(NullPointerException.class, () -> op.accept(map), name);\n+        }\n+    }\n+\n+    private static List<EnumSet<TestEnum>> sets() {\n+        return IntStream.range(0, TestEnum.values().length)\n+                .mapToObj(i -> Arrays.copyOfRange(TestEnum.values(), 0, i))\n+                .map(a -> {\n+                    EnumSet<TestEnum> s = EnumSet.noneOf(TestEnum.class);\n+                    s.addAll(List.of(a));\n+                    return s;\n+                })\n+                .toList();\n+    }\n+\n+    private static List<Map<TestEnum, StableValue<Integer>>> maps() {\n+        return sets().stream()\n+                .map(StableValue::<TestEnum, Integer>ofMap)\n+                .toList();\n+    }\n+\n+    private static Stream<Arguments> unsupportedOperations() {\n+        return Stream.of(\n+                Arguments.of(\"clear\",            asConsumer(Map::clear)),\n+                Arguments.of(\"put\",              asConsumer(m -> m.put(KEY, StableValue.of()))),\n+                Arguments.of(\"remove(K)\",        asConsumer(m -> m.remove(KEY))),\n+                Arguments.of(\"remove(K, V)\",     asConsumer(m -> m.remove(KEY, StableValue.of()))),\n+                Arguments.of(\"putAll(K, V)\",     asConsumer(m -> m.putAll(new HashMap<>()))),\n+                Arguments.of(\"replaceAll\",       asConsumer(m -> m.replaceAll((_, _) -> null))),\n+                Arguments.of(\"putIfAbsent\",      asConsumer(m -> m.putIfAbsent(KEY, StableValue.of()))),\n+                Arguments.of(\"replace(K, V)\",    asConsumer(m -> m.replace(KEY, StableValue.of()))),\n+                Arguments.of(\"replace(K, V, V)\", asConsumer(m -> m.replace(KEY, StableValue.of(), StableValue.of()))),\n+                Arguments.of(\"computeIfAbsent\",  asConsumer(m -> m.computeIfAbsent(KEY, _ -> StableValue.of()))),\n+                Arguments.of(\"computeIfPresent\", asConsumer(m -> m.computeIfPresent(KEY, (_, _) -> StableValue.of()))),\n+                Arguments.of(\"compute\",          asConsumer(m -> m.compute(KEY, (_, _) -> StableValue.of()))),\n+                Arguments.of(\"merge\",            asConsumer(m -> m.merge(KEY, StableValue.of(), (_, _) -> StableValue.of()))),\n+                Arguments.of(\"es().it().remove\", asConsumer(m -> m.entrySet().iterator().remove()))\n+        );\n+    }\n+\n+    private static Stream<Arguments> nullOperations() {\n+        return Stream.of(\n+                Arguments.of(\"forEach\", asConsumer(m -> m.forEach(null)))\n+        );\n+    }\n+\n+    private static Consumer<Map<TestEnum, StableValue<Integer>>> asConsumer(Consumer<Map<TestEnum, StableValue<Integer>>> consumer) {\n+        return consumer;\n+    }\n+\n+    static String expectedToString(Map<TestEnum, StableValue<Integer>> map) {\n+        return \"{\" + map.entrySet()\n+                .stream().map(e -> e.getKey() + \"=\" + e.getValue())\n+                .collect(Collectors.joining(\", \")) + \"}\";\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/BasicStableEnumMapTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for stable lists\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} BasicStableListTest.java\n+ * @run junit\/othervm --enable-preview BasicStableListTest\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicStableListTest {\n+\n+    private static final int MAX_SIZE = 1_000;\n+    private static final int[] SIZES = new int[]{0, 1, 2, 7, MAX_SIZE};\n+    private static final IntFunction<Integer> FUNCTION = i -> i;\n+\n+    private List<StableValue<Integer>> list;\n+\n+    @BeforeEach\n+    void setup() {\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void size(int size) {\n+        newList(size);\n+        assertEquals(size, list.size());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void isEmpty(int size) {\n+        newList(size);\n+        assertEquals(size == 0, list.isEmpty());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void get(int size) {\n+        newList(size);\n+        for (int j = 0; j < 2; j++) {\n+            for (int i = 0; i < size; i++) {\n+                assertEquals(i, list.get(i).orThrow());\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void serializable(int size) {\n+        newList(size);\n+        if (size > 0) {\n+            assertFalse(list instanceof Serializable);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void toString(int size) {\n+        newList(size);\n+        String actual = list.toString();\n+        String expected = IntStream.range(0, size)\n+                .mapToObj(i -> {\n+                    StableValue<Integer> stable = StableValue.of();\n+                    stable.trySet(i);\n+                    return stable;\n+                })\n+                .toList()\n+                .toString();\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void computeIfUnsetError() {\n+        int index = 3;\n+        list = StableValue.ofList(index * 2);\n+        assertThrows(UnsupportedOperationException.class, () ->\n+            StableValue.computeIfUnset(list, index, _ -> {  throw new UnsupportedOperationException(); }\n+        ));\n+        assertFalse(list.get(index).isSet());\n+        assertTrue(list.get(index).isError());\n+        assertEquals(\"StableValue.error(\" + UnsupportedOperationException.class.getName() + \")\", list.get(index).toString());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void uoe(String name, Consumer<List<StableValue<Integer>>> op) {\n+        for (int size : SIZES) {\n+            newList(size);\n+            assertThrows(UnsupportedOperationException.class, () -> op.accept(list), name);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullOperations\")\n+    void npe(String name, Consumer<List<StableValue<Integer>>> op) {\n+        for (int size : SIZES) {\n+            newList(size);\n+            assertThrows(NullPointerException.class, () -> op.accept(list), name);\n+        }\n+    }\n+\n+    private void newList(int size) {\n+        list = StableValue.ofList(size);\n+        for (int i = 0; i<size; i++) {\n+            StableValue<Integer> stable = list.get(i);\n+            stable.trySet(FUNCTION.apply(i));\n+        }\n+    }\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(SIZES)\n+                .mapToObj(Arguments::of);\n+    }\n+\n+    private static Stream<Arguments> unsupportedOperations() {\n+        return Stream.of(\n+                Arguments.of(\"add\",          asConsumer(l -> l.add(StableValue.of()))),\n+                Arguments.of(\"remove\",       asConsumer(l -> l.remove(1))),\n+                Arguments.of(\"addAll(C)\",    asConsumer(l -> l.addAll(List.of()))),\n+                Arguments.of(\"addAll(i, C)\", asConsumer(l -> l.addAll(1, List.of()))),\n+                Arguments.of(\"removeAll\",    asConsumer(l -> l.removeAll(List.<StableValue<Integer>>of()))),\n+                Arguments.of(\"retainAll\",    asConsumer(l -> l.retainAll(List.<StableValue<Integer>>of()))),\n+                Arguments.of(\"replaceAll\",   asConsumer(l -> l.replaceAll(_ -> StableValue.of()))),\n+                Arguments.of(\"sort\",         asConsumer(l -> l.sort(null))),\n+                Arguments.of(\"clear\",        asConsumer(List::clear)),\n+                Arguments.of(\"set(i, E)\",    asConsumer(l -> l.set(1, StableValue.of()))),\n+                Arguments.of(\"add(i, E)\",    asConsumer(l -> l.add(1, StableValue.of()))),\n+                Arguments.of(\"remove(i)\",    asConsumer(l -> l.remove(1))),\n+                Arguments.of(\"removeIf\",     asConsumer(l -> l.removeIf(Objects::isNull))),\n+                Arguments.of(\"addFirst\",     asConsumer(l -> l.addFirst(StableValue.of()))),\n+                Arguments.of(\"addLast\",      asConsumer(l -> l.addLast(StableValue.of()))),\n+                Arguments.of(\"removeFirst\",  asConsumer(List::removeFirst)),\n+                Arguments.of(\"removeLast\",   asConsumer(List::removeLast))\n+        );\n+    }\n+\n+    private static Stream<Arguments> nullOperations() {\n+        return Stream.of(\n+                Arguments.of(\"toArray\",     asConsumer(l -> l.toArray((Object[]) null))),\n+                Arguments.of(\"toArray\",     asConsumer(l -> l.toArray((IntFunction<StableValue<Integer>[]>) null))),\n+                Arguments.of(\"containsAll\", asConsumer(l -> l.containsAll(null))),\n+                Arguments.of(\"forEach\",     asConsumer(l -> l.forEach(null))),\n+                Arguments.of(\"indexOf\",     asConsumer(l -> l.indexOf(null))),\n+                Arguments.of(\"lastIndexOf\", asConsumer(l -> l.lastIndexOf(null)))\n+        );\n+    }\n+\n+    private static Consumer<List<StableValue<Integer>>> asConsumer(Consumer<List<StableValue<Integer>>> consumer) {\n+        return consumer;\n+    }\n+\n+    private static final class CountingIntFunction<T> implements IntFunction<T> {\n+\n+        private final IntFunction<T> delegate;\n+        private final AtomicInteger[] counters;\n+\n+        public CountingIntFunction(IntFunction<T> delegate) {\n+            this.delegate = delegate;\n+            this.counters = new AtomicInteger[MAX_SIZE];\n+            for (int i = 0; i < MAX_SIZE; i++) {\n+                counters[i] = new AtomicInteger();\n+            }\n+        }\n+\n+        @Override\n+        public T apply(int value) {\n+            counters[value].incrementAndGet();\n+            return delegate.apply(value);\n+        }\n+\n+        int cnt(int i) {\n+            return counters[i].get();\n+        }\n+\n+        int sum() {\n+            return IntStream.range(0, MAX_SIZE)\n+                    .map(i -> counters[i].get())\n+                    .sum();\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/BasicStableListTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for stable Map implementations\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} BasicStableMapTest.java\n+ * @run junit\/othervm --enable-preview BasicStableMapTest\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicStableMapTest {\n+\n+    private static final String[] KEYS = \"A,B,C,D,E,F,G\".split(\",\");\n+    private static final String KEY = \"C\";\n+\n+    @Test\n+    void basic() {\n+        for (var set : sets()) {\n+            Map<String, StableValue<Integer>> map = StableValue.ofMap(set);\n+            assertEquals(set.isEmpty(), map.isEmpty());\n+\n+            for (String key : set) {\n+                assertFalse(map.get(key).isSet());\n+            }\n+\n+            for (String key : set) {\n+                assertNotNull(map.get(key));\n+                assertTrue(map.containsKey(key));\n+            }\n+\n+            assertEquals(expectedToString(map), map.toString());\n+\n+            if (!map.isEmpty()) {\n+                assertFalse(map instanceof Serializable);\n+            }\n+\n+        }\n+    }\n+\n+    @Test\n+    void entrySet() {\n+        for (var set : sets()) {\n+            Map<String, StableValue<Integer>> map = StableValue.ofMap(set);\n+            var es = map.entrySet();\n+            assertEquals(set.size(), es.size());\n+        }\n+    }\n+\n+    @Test\n+    void entrySetIterator() {\n+        for (var set : sets()) {\n+            Map<String, StableValue<Integer>> map = StableValue.ofMap(set);\n+            var i = map.entrySet().iterator();\n+\n+            Set<String> seen = new HashSet<>();\n+            while (i.hasNext()) {\n+                seen.add(i.next().getKey());\n+            }\n+            assertEquals(set, seen);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void uoe(String name, Consumer<Map<String, StableValue<Integer>>> op) {\n+        for (var map:maps()) {\n+            assertThrows(UnsupportedOperationException.class, () -> op.accept(map), name);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullOperations\")\n+    void npe(String name, Consumer<Map<String, StableValue<Integer>>> op) {\n+        for (var map:maps()) {\n+            assertThrows(NullPointerException.class, () -> op.accept(map), name);\n+        }\n+    }\n+\n+    private static List<Set<String>> sets() {\n+        return IntStream.range(0, KEY.length())\n+                .mapToObj(i -> Arrays.copyOfRange(KEYS, 0, i))\n+                .map(Set::of)\n+                .toList();\n+    }\n+\n+    private static List<Map<String, StableValue<Integer>>> maps() {\n+        return sets().stream()\n+                .map(StableValue::<String, Integer>ofMap)\n+                .toList();\n+    }\n+\n+    private static Stream<Arguments> unsupportedOperations() {\n+        return Stream.of(\n+                Arguments.of(\"clear\",            asConsumer(Map::clear)),\n+                Arguments.of(\"put\",              asConsumer(m -> m.put(KEY, StableValue.of()))),\n+                Arguments.of(\"remove(K)\",        asConsumer(m -> m.remove(KEY))),\n+                Arguments.of(\"remove(K, V)\",     asConsumer(m -> m.remove(KEY, StableValue.of()))),\n+                Arguments.of(\"putAll(K, V)\",     asConsumer(m -> m.putAll(new HashMap<>()))),\n+                Arguments.of(\"replaceAll\",       asConsumer(m -> m.replaceAll((_, _) -> null))),\n+                Arguments.of(\"putIfAbsent\",      asConsumer(m -> m.putIfAbsent(KEY, StableValue.of()))),\n+                Arguments.of(\"replace(K, V)\",    asConsumer(m -> m.replace(KEY, StableValue.of()))),\n+                Arguments.of(\"replace(K, V, V)\", asConsumer(m -> m.replace(KEY, StableValue.of(), StableValue.of()))),\n+                Arguments.of(\"computeIfAbsent\",  asConsumer(m -> m.computeIfAbsent(KEY, _ -> StableValue.of()))),\n+                Arguments.of(\"computeIfPresent\", asConsumer(m -> m.computeIfPresent(KEY, (_, _) -> StableValue.of()))),\n+                Arguments.of(\"compute\",          asConsumer(m -> m.compute(KEY, (_, _) -> StableValue.of()))),\n+                Arguments.of(\"merge\",            asConsumer(m -> m.merge(KEY, StableValue.of(), (_, _) -> StableValue.of()))),\n+                Arguments.of(\"es().it().remove\", asConsumer(m -> m.entrySet().iterator().remove()))\n+        );\n+    }\n+\n+    private static Stream<Arguments> nullOperations() {\n+        return Stream.of(\n+                Arguments.of(\"forEach\", asConsumer(m -> m.forEach(null)))\n+        );\n+    }\n+\n+    private static Consumer<Map<String, StableValue<Integer>>> asConsumer(Consumer<Map<String, StableValue<Integer>>> consumer) {\n+        return consumer;\n+    }\n+\n+    static String expectedToString(Map<String, StableValue<Integer>> map) {\n+        return \"{\" + map.entrySet()\n+                .stream().map(e -> e.getKey() + \"=\" + e.getValue())\n+                .collect(Collectors.joining(\", \")) + \"}\";\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/BasicStableMapTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableValue implementations\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} BasicStableTest.java\n+ * @compile StableTestUtil.java\n+ * @run junit\/othervm --enable-preview BasicStableTest\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InaccessibleObjectException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class BasicStableTest {\n+\n+    private static final int FIRST = 42;\n+    private static final int SECOND = 13;\n+\n+    private StableValue<Integer> stable;\n+\n+    @BeforeEach\n+    void setup() {\n+        stable = StableValue.of();\n+    }\n+\n+    @Test\n+    void unset() {\n+        assertFalse(stable.isSet());\n+        assertFalse(stable.isError());\n+        assertThrows(NoSuchElementException.class, stable::orThrow);\n+    }\n+\n+    @Test\n+    void trySet() {\n+        assertTrue(stable.trySet(FIRST));\n+        assertTrue(stable.isSet());\n+        assertFalse(stable.isError());\n+        assertEquals(FIRST, stable.orThrow());\n+        assertFalse(stable.trySet(SECOND));\n+        assertTrue(stable.isSet());\n+        assertEquals(FIRST, stable.orThrow());\n+    }\n+\n+    @Test\n+    void setIfUnset() {\n+        Integer i = stable.setIfUnset(FIRST);\n+        assertTrue(stable.isSet());\n+        assertFalse(stable.isError());\n+        assertEquals(FIRST, i);\n+        assertEquals(FIRST, stable.orThrow());\n+\n+        assertEquals(FIRST, stable.setIfUnset(FIRST));\n+        assertEquals(FIRST, stable.setIfUnset(SECOND));\n+        assertEquals(FIRST, stable.setIfUnset(null));\n+    }\n+\n+    @Test\n+    void setIfUnsetNull() {\n+        Integer i = stable.setIfUnset(null);\n+        assertTrue(stable.isSet());\n+        assertFalse(stable.isError());\n+        assertNull(i);\n+        assertNull(stable.orThrow());\n+\n+        assertNull(stable.setIfUnset(null));\n+        assertNull(stable.setIfUnset(FIRST));\n+        assertNull(stable.setIfUnset(SECOND));\n+    }\n+\n+    @Test\n+    void computeIfUnset() {\n+        stable.computeIfUnset(() -> FIRST);\n+        assertEquals(FIRST, stable.orThrow());\n+\n+        Supplier<Integer> throwingSupplier = () -> {\n+            throw new UnsupportedOperationException();\n+        };\n+        assertDoesNotThrow(() -> stable.computeIfUnset(throwingSupplier));\n+\n+        var m2 = StableValue.of();\n+        m2.computeIfUnset(() -> FIRST);\n+        assertEquals(FIRST, m2.orThrow());\n+    }\n+\n+    @Test\n+    void computeIfUnsetNull() {\n+        StableTestUtil.CountingSupplier<Integer> c = new StableTestUtil.CountingSupplier<>(() -> null);\n+        stable.computeIfUnset(c);\n+        assertNull(stable.orThrow());\n+        assertEquals(1, c.cnt());\n+        stable.computeIfUnset(c);\n+        assertEquals(1, c.cnt());\n+    }\n+\n+    @Test\n+    void computeIfUnsetRetry() {\n+        Supplier<Integer> failingSupplier = () -> {\n+            throw new UnsupportedOperationException();\n+        };\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> stable.computeIfUnset(failingSupplier));\n+        assertFalse(stable.isSet());\n+        assertTrue(stable.isError());\n+        assertEquals(\"StableValue.error(\" + UnsupportedOperationException.class.getName() + \")\", stable.toString());\n+\n+        assertThrows(NoSuchElementException.class,() ->\n+                stable.computeIfUnset(() -> FIRST));\n+        assertFalse(stable.isSet());\n+        assertTrue(stable.isError());\n+        assertThrows(NoSuchElementException.class,() ->\n+                stable.orThrow());\n+        assertFalse(stable.isSet());\n+        assertTrue(stable.isError());\n+    }\n+\n+    @Test\n+    void computeIfUnsetRecursive() {\n+        Supplier<Integer> initial = () -> FIRST;\n+        Supplier<Integer> recursive = () -> stable.computeIfUnset(initial);\n+        var e = assertThrows(StackOverflowError.class,\n+                () -> stable.computeIfUnset(recursive));\n+        var msg = e.getMessage();\n+        assertEquals(\"Recursive invocation of Supplier.get(): \" + initial, msg);\n+    }\n+\n+    @Test\n+    void testToString() {\n+        assertEquals(\"StableValue.unset\", stable.toString());\n+        stable.trySet(1);\n+        assertEquals(\"StableValue[1]\", stable.toString());\n+    }\n+\n+    @Test\n+    void reflection() throws NoSuchFieldException {\n+        final class Holder {\n+            private final StableValue<Integer> stable = StableValue.of();\n+        }\n+        final class HolderNonFinal {\n+            private StableValue<Integer> stable = StableValue.of();\n+        }\n+\n+        Field field = Holder.class.getDeclaredField(\"stable\");\n+        assertThrows(InaccessibleObjectException.class, () ->\n+                        field.setAccessible(true)\n+                );\n+\n+        Field fieldNonFinal = HolderNonFinal.class.getDeclaredField(\"stable\");\n+        assertDoesNotThrow(() -> fieldNonFinal.setAccessible(true));\n+    }\n+\n+    @Test\n+    void sunMiscUnsafe() throws NoSuchFieldException, IllegalAccessException {\n+        Field unsafeField = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n+        unsafeField.setAccessible(true);\n+        sun.misc.Unsafe unsafe = (sun.misc.Unsafe)unsafeField.get(null);\n+\n+        final class Holder {\n+            private final StableValue<Integer> stable = StableValue.of();\n+        }\n+        Field field = Holder.class.getDeclaredField(\"stable\");\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                unsafe.objectFieldOffset(field)\n+        );\n+\n+    }\n+\n+    @Test\n+    void varHandle() throws NoSuchFieldException, IllegalAccessException {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        StableValue<Integer> original = StableValue.of();\n+\n+        final class Holder {\n+            private final StableValue<Integer> stable = original;\n+        }\n+\n+        VarHandle varHandle = lookup.findVarHandle(Holder.class, \"stable\", StableValue.class);\n+        Holder holder = new Holder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                varHandle.set(holder, StableValue.of())\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                varHandle.compareAndSet(holder, original, StableValue.of())\n+        );\n+\n+    }\n+\n+    @Test\n+    void background() {\n+        StableValue<Integer> stable = StableValue.ofBackground(Thread.ofVirtual().factory(), () -> 42);\n+\n+        long deadline = deadlineS(2);\n+        while(!stable.isSet()) {\n+            Thread.onSpinWait();\n+            if (System.nanoTime() > deadline) {\n+                fail(\"No value was set within the stipulated time: \" + stable);\n+            }\n+        }\n+\n+        assertEquals(42, stable.orThrow());\n+    }\n+\n+    @Test\n+    void backgroundException() {\n+        String message = \"The background thread threw an exception\";\n+\n+        AtomicReference<Throwable> holder = new AtomicReference<>();\n+        ThreadFactory factory =\n+                Thread.ofVirtual()\n+                        .uncaughtExceptionHandler((t, e) -> holder.set(e))\n+                        .factory();\n+\n+        StableValue<Integer> stable = StableValue.ofBackground(\n+                factory,\n+                () -> { throw new UnsupportedOperationException(message); }\n+        );\n+\n+        long deadline = deadlineS(2);\n+        while (holder.get() == null) {\n+            Thread.onSpinWait();\n+            if (System.nanoTime() > deadline) {\n+                fail(\"No exception was received within the stipulated time: \" + stable);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nodes() {\n+        Node<Integer> c = Node.last(1)\n+                .prepend(2)\n+                .prepend(3);\n+\n+        List<Integer> actual = new ArrayList<>();\n+        for (;;) {\n+            actual.add(c.value());\n+            if (c.next().isEmpty()) {\n+                break;\n+            }\n+            c = c.next().orElseThrow();\n+        }\n+        assertEquals(List.of(3, 2, 1), actual);\n+    }\n+\n+    record Node<T>(StableValue<Node<T>> previous,\n+                   Optional<Node<T>> next,\n+                   T value) {\n+\n+        public Node<T> prepend(T newValue) {\n+            Node<T> newNode = new Node<>(StableValue.of(), Optional.of(this), newValue);\n+            this.previous.trySet(newNode);\n+            return newNode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return value.toString();\n+        }\n+\n+        static <T> Node<T> last(T value) {\n+            return new Node<>(StableValue.of(), Optional.empty(), value);\n+        }\n+\n+    }\n+\n+    private static long deadlineS(int seconds) {\n+        return System.nanoTime() + TimeUnit.SECONDS.toNanos(seconds);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/BasicStableTest.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -0,0 +1,485 @@\n+# Stable Values & Collections (Preview)\n+\n+## Summary\n+\n+Introduce a _Stable Values & Collections_ API, which provides immutable value holders where elements are initialized\n+_at most once_. Stable Values & Collections offer the performance and safety benefits of final fields, while offering\n+greater flexibility as to the timing of initialization. This is a [preview API](https:\/\/openjdk.org\/jeps\/12).\n+\n+## Goals\n+\n+- Provide an easy and intuitive API to describe value holders that can change at most once.\n+- Decouple declaration from initialization without significant footprint or performance penalties.\n+- Reduce the amount of static initializer and\/or field initialization code.\n+- Uphold integrity and consistency, even in a multi-threaded environment.\n+\n+## Non-goals\n+\n+- It is not a goal to provide additional language support for expressing lazy computation.\n+  This might be the subject of a future JEP.\n+- It is not a goal to prevent or deprecate existing idioms for expressing lazy initialization.\n+\n+## Motivation\n+\n+Most Java developers have heard the advice \"prefer immutability\" (Effective\n+Java, Item 17). Immutability confers many advantages including:\n+\n+* an immutable object can only be in one state\n+* the invariants of an immutable object can be enforced by its constructor\n+* immutable objects can be freely shared across threads\n+* immutability enables all manner of runtime optimizations.\n+\n+Java's main tool for managing immutability is `final` fields (and more recently, `record` classes).\n+Unfortunately, `final` fields come with restrictions. Final instance fields must be set by the end of\n+the constructor, and `static final` fields during class initialization. Moreover, the order in which `final`\n+field initializers are executed is determined by the [textual order](https:\/\/docs.oracle.com\/javase\/specs\/jls\/se7\/html\/jls-13.html#jls-12.4.1)\n+and is then made explicit in the resulting class file. As such, the initialization of a `final`\n+field is fixed in time; it cannot be arbitrarily moved forward. In other words, developers\n+cannot cause specific constants to be initialized after the class or object is initialized.\n+This means that developers are forced to choose between finality and all its\n+benefits, and flexibility over the timing of initialization. Developers have\n+devised several strategies to ameliorate this imbalance, but none are\n+ideal.\n+\n+For instance, monolithic class initializers can be broken up by leveraging the\n+laziness already built into class loading.  Often referred to as the\n+[_class-holder idiom_](https:\/\/en.wikipedia.org\/wiki\/Initialization-on-demand_holder_idiom),\n+this technique moves lazily initialized state into a helper class which is then\n+loaded on-demand, so its initialization is only performed when the data is\n+actually needed, rather than unconditionally initializing constants when a class\n+is first referenced:\n+```\n+\/\/ ordinary static initialization\n+private static final Logger LOGGER = Logger.getLogger(\"com.foo.Bar\");\n+...\n+LOGGER.log(Level.INFO, ...);\n+```\n+we can defer initialization until we actually need it:\n+```\n+\/\/ Initialization-on-demand holder idiom\n+Logger logger() {\n+    class Holder {\n+         static final Logger LOGGER = Logger.getLogger(\"com.foo.Bar\");\n+    }\n+    return Holder.LOGGER;\n+}\n+...\n+LOGGER.log(Level.INFO, ...);\n+```\n+The code above ensures that the `Logger` object is created only when actually\n+required. The (possibly expensive) initializer for the logger lives in the\n+nested `Holder` class, which will only be initialized when the `logger` method\n+accesses the `LOGGER` field.  While this idiom works well, its reliance on the\n+class loading process comes with significant drawbacks.  First, each constant\n+whose computation needs to be deferred generally requires its own holder\n+class, thus introducing a significant static footprint cost.  Second, this idiom\n+is only really applicable if the field initialization is suitably isolated, not\n+relying on any other parts of the object state.\n+\n+It should be noted that even though eventually outputting a message is slow compared to\n+obtaining the `Logger` instance itself, the `LOGGER::log`method starts with checking if\n+the selected `Level` is enabled or not. This latter check is a relatively fast operation\n+and so, in the case of disabled loggers, the `Logger` instance retrieval performance is\n+important. For example, logger output for `Level.INFO` is likely disabled in most production\n+environments.\n+\n+Alternatively, the [_double-checked locking idiom_](https:\/\/en.wikipedia.org\/wiki\/Double-checked_locking), can also be used\n+for deferring the evaluation of field initializers. The idea is to optimistically\n+check if the field's value is non-null and if so, use that value directly; but\n+if the value observed is null, then the field must be initialized, which, to be\n+safe under multi-threaded access, requires acquiring a lock to ensure\n+correctness:\n+```\n+\/\/ Double-checked locking idiom\n+class Foo {\n+    private volatile Logger logger;\n+    public Logger logger() {\n+        Logger v = logger;\n+        if (v == null) {\n+            synchronized (this) {\n+                v = logger;\n+                if (v == null) {\n+                    logger = v = Logger.getLogger(\"com.foo.Bar\");\n+                }\n+            }\n+        }\n+        return v;\n+    }\n+}\n+```\n+The double-checked locking idiom is brittle and easy to get\n+subtly wrong (see _Java Concurrency in Practice_, 16.2.4.) For example, a common error\n+is forgetting to declare the field `volatile` resulting in the risk of observing incomplete objects.\n+\n+While the double-checked locking idiom can be used for both class and instance\n+variables, its usage requires that the field subject to initialization is marked\n+as non-final. This is not ideal for several reasons:\n+\n+* it would be possible for code to accidentally modify the field value, thus violating\n+  the immutability assumption of the enclosing class.\n+* access to the field cannot be adequately optimized by just-in-time compilers, as they\n+  cannot reliably assume that the field value will, in fact, never change. An example of\n+  similar optimizations in existing Java implementations is when a `MethodHandle` is held\n+  in a `static final` field, allowing the runtime to generate machine code that is competitive\n+  with direct invocation of the corresponding method.\n+\n+Furthermore, the idiom shown above needs to be modified to properly handle `null` values, for example using\n+a [sentinel](https:\/\/en.wikipedia.org\/wiki\/Sentinel_value) value.\n+\n+The situation is even worse when clients need to operate on a _collection_ of immutable values.\n+\n+An example of this is an array that holds HTML pages that correspond to an error code in the range [0, 7]\n+ where each element is pulled in from the file system on-demand, once actually used:\n+\n+```\n+class ErrorMessages {\n+\n+    private static final int SIZE = 8;\n+\n+    \/\/ 1. Declare an array of error pages to serve up\n+    private static final String[] MESSAGES = new String[SIZE];\n+\n+    \/\/ 2. Define a function that is to be called the first\n+    \/\/    time a particular message number is referenced\n+    private static String readFromFile(int messageNumber) {\n+        try {\n+            return Files.readString(Path.of(\"message-\" + messageNumber + \".html\"));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    static synchronized String message(int messageNumber) {\n+        \/\/ 3. Access the memoized array element under synchronization\n+        \/\/    and compute-and-store if absent.\n+        String page = MESSAGES[messageNumber];\n+        if (page == null) {\n+            page = readFromFile(messageNumber);\n+            MESSAGES[messageNumber] = page;\n+        }\n+        return page;\n+    }\n+\n+ }\n+```\n+We can now retrieve an error page like so:\n+```\n+String errorPage = ErrorMessages.errorPage(2);\n+\n+\/\/ <!DOCTYPE html>\n+\/\/ <html lang=\"en\">\n+\/\/   <head><meta charset=\"utf-8\"><\/head>\n+\/\/   <body>Payment was denied: Insufficient funds.<\/body>\n+\/\/ <\/html>\n+```\n+\n+Unfortunately, this approach provides a plethora of challenges. First, retrieving the values\n+from a static array is slow, as said values cannot be [constant-folded](https:\/\/en.wikipedia.org\/wiki\/Constant_folding). Even worse, access to\n+the array is guarded by synchronization that is not only slow but will block access to the array for\n+all elements whenever one of the elements is under computation. Furthermore, the class holder idiom (see above)\n+is undoubtedly insufficient in this case, as the number of required holder classes is *statically unbounded* - it\n+depends on the value of the parameter `SIZE` which may change in future variants of the code.\n+\n+What we are missing -- in all cases -- is a way to *promise* that a constant will be initialized\n+by the time it is used, with a value that is computed at most once. Such a mechanism would give\n+the Java runtime maximum opportunity to stage and optimize its computation, thus avoiding the penalties\n+(static footprint, loss of runtime optimizations) that plague the workarounds shown above. Moreover,\n+such a mechanism should gracefully scale to handle collections of constant values, while retaining\n+efficient computer resource management.\n+\n+The attentive reader might have noticed the similarity between what is sought after here and the JDK internal\n+annotation`jdk.internal.vm.annotation.@Stable`. This annotation is used by *JDK code* to mark scalar and\n+array variables whose values or elements will change *at most once*. This annotation is powerful and often\n+crucial to achieving optimal performance, but it is also easy to misuse: further updating a `@Stable` field\n+after its initial update will result in undefined behavior, as the JIT compiler might have *already*\n+constant-folded the (now overwritten) field value. In other words, what we are after is a *safe* and *efficient*\n+wrapper around the `@Stable` mechanism - in the form of a new Java SE API that might be enjoyed by\n+_all_ client and 3rd-party Java code (and not the JDK alone).\n+\n+## Description\n+\n+### Preview feature\n+\n+Stable Values & Collections is a [preview API](https:\/\/openjdk.org\/jeps\/12), disabled by default.\n+To use the Stable Value and Collections APIs, the JVM flag `--enable-preview` must be passed in, as follows:\n+\n+- Compile the program with `javac --release 24 --enable-preview Main.java` and run it with `java --enable-preview Main`; or,\n+\n+- When using the source code launcher, run the program with `java --source 24 --enable-preview Main.java`; or,\n+\n+- When using `jshell`, start it with `jshell --enable-preview`.\n+\n+### Outline\n+\n+The Stable Values & Collections API defines functions and an interface so that client code in libraries and applications can\n+\n+- Define and use stable (scalar) values:\n+  - [`StableValue`](https:\/\/cr.openjdk.org\/~pminborg\/stable-values\/api\/java.base\/java\/lang\/StableValue.html)\n+- Define collections:\n+  - [`StableValue.ofList(int size)`](https:\/\/cr.openjdk.org\/~pminborg\/stable-values\/api\/java.base\/java\/lang\/StableValue.html#ofList(int)),\n+  - [`StableValue.ofMap(Set<K> keys)`](https:\/\/cr.openjdk.org\/~pminborg\/stable-values\/api\/java.base\/java\/lang\/StableValue.html#ofMap(java.util.Set))\n+\n+The Stable Values & Collections API resides in the [java.lang](https:\/\/cr.openjdk.org\/~pminborg\/stable-values\/api\/java.base\/java\/lang\/package-summary.html) package of the [java.base](https:\/\/cr.openjdk.org\/~pminborg\/stable-values\/api\/java.base\/module-summary.html) module.\n+\n+### Stable values\n+\n+A _stable value_ is a holder object that is set at most once whereby it\n+goes from \"unset\" to \"set\". It is expressed as an object of type `jdk.internal.lang.StableValue`,\n+which, like `Future`, is a holder for some computation that may or may not have occurred yet.\n+Fresh (unset) `StableValue` instances are created via the factory method `StableValue::of`:\n+\n+```\n+class Bar {\n+    \/\/ 1. Declare a Stable field\n+    private static final StableValue<Logger> LOGGER = StableValue.of();\n+\n+    static Logger logger() {\n+\n+        if (!LOGGER.isSet()) {\n+            \/\/ 2. Set the stable value _after_ the field was declared\n+            return LOGGER.setIfUnset(Logger.getLogger(\"com.foo.Bar\"));\n+        }\n+\n+        \/\/ 3. Access the stable value with as-declared-final performance\n+        return LOGGER.orThrow();\n+    }\n+}\n+```\n+Setting a stable value is an atomic, thread-safe operation, i.e. `StableValue::setIfUnset`,\n+either results in successfully initializing the `StableValue` to a value, or returns\n+an already set value. This is true regardless of whether the stable value is accessed by a single\n+thread, or concurrently, by multiple threads.\n+\n+A stable value may be set to `null` which then will be considered its set value.\n+Null-averse applications can also use `StableValue<Optional<V>>`.\n+\n+In many ways, this is similar to the holder-class idiom in the sense it offers the same\n+performance and constant-folding characteristics. It also incurs a lower static footprint\n+since no additional class is required.\n+\n+However, there is _an important distinction_; several threads may invoke the `Logger::getLogger`\n+method simultaneously if they call the `logger()` method at about the same time. Even though `StableValue` will guarantee, that only\n+one of these results will ever be exposed to the many competing threads, there might be applications where\n+it is a requirement, that a supplying method is only called once.\n+\n+In such cases, it is possible to compute and set an unset value on-demand as shown in this example in which case\n+`StableValue` will uphold the invoke-at-most-once invariant for the provided `Supplier`:\n+\n+```\n+class Bar {\n+    \/\/ 1. Declare a stable field\n+    private static final StableValue<Logger> LOGGER = StableValue.of();\n+\n+    static Logger logger() {\n+        \/\/ 2. Access the stable value with as-declared-final performance\n+        \/\/    (single evaluation made before the first access)\n+        return LOGGER.computeIfUnset( () -> Logger.getLogger(\"com.foo.Bar\") );\n+    }\n+}\n+```\n+\n+When retrieving values, `StableValue` instances holding reference values are faster\n+than reference values managed via double-checked-idiom constructs as stable values rely\n+on explicit memory barriers rather than performing volatile access on each retrieval\n+operation. In addition, stable values are eligible for constant folding optimizations.\n+\n+### Stable collections\n+\n+While initializing a single field of type `StableValue` is cheap (remember, creating a new `StableValue`\n+object only creates the *holder* for the value), this (small) initialization cost has\n+to be paid for each field of type `StableValue` declared by the class. As a result, the class static\n+and\/or instance initializer will keep growing with the number of `StableValue` fields, thus degrading performance.\n+\n+To handle these cases, the Stable Values & Collections API provides constructs that allow the creation and handling of a\n+*`List` of stable elements*. Such a `List` is a list whose stable-value elements are created lazily on-demand when a particular element is accessed. Lists of lazily computed values are objects of type `List<StableValue<V>>`.\n+Consequently, each element in the list enjoys the same properties as a `StableValue` but may require fewer resources.\n+\n+Like a `StableValue` object, a `List` of stable value elements is created via a factory method by providing the size\n+of the desired `List`:\n+\n+```\n+static <V> List<StableValue<V>> StableValue.ofList(int size) { ... }\n+```\n+\n+This allows for improving the handling of lists with stable values and enables a much better\n+implementation of the `ErrorMessages` class mentioned earlier. Here is an improved version\n+of the class which is now using the newly proposed API:\n+\n+```\n+class ErrorMessages {\n+\n+    private static final int SIZE = 8;\n+\n+    \/\/ 1. Declare a stable list of default error pages to serve up\n+    private static final List<StableValue<String>> MESSAGES = StableValue.ofList(SIZE);\n+\n+    \/\/ 2. Define a function that is to be called the first\n+    \/\/    time a particular message number is referenced\n+    private static String readFromFile(int messageNumber) {\n+        try {\n+            return Files.readString(Path.of(\"message-\" + messageNumber + \".html\"));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    static String errorPage(int messageNumber) {\n+        \/\/ 3. Access the stable list element with as-declared-final performance\n+        \/\/    (evaluation made before the first access)\n+        return StableValue.computeIfUnset(MESSAGES, messageNumber, ErrorMessages::readFromFile);\n+    }\n+\n+}\n+```\n+\n+Just like before, we can perform retrieval of error pages like this:\n+\n+```\n+String errorPage = ErrorMessages.errorPage(2);\n+\n+\/\/ <!DOCTYPE html>\n+\/\/ <html lang=\"en\">\n+\/\/   <head><meta charset=\"utf-8\"><\/head>\n+\/\/   <body>Payment was denied: Insufficient funds.<\/body>\n+\/\/ <\/html>\n+```\n+\n+Note how there's only one field of type `List<StableValue<String>>` to initialize even though every computation is\n+performed independently of the other element of the list when accessed (i.e. no blocking will occur across threads\n+computing distinct elements simultaneously). Also, the `IntSupplier` provided at computation is only invoked\n+at most once for each distinct index. The Stable Values & Collections API allows modeling this cleanly, while\n+still preserving good constant-folding guarantees and integrity of updates in the case of multi-threaded access.\n+\n+It should be noted that even though a lazily computed list of stable elements might mutate its internal state\n+upon external access, it is _still shallowly immutable_ because _no first-level change can ever be observed by\n+an external observer_. This is similar to other immutable classes, such as `String` (which internally caches its\n+`hash` value), where they might rely on mutable internal states that are carefully kept internally and that never\n+shine through to the outside world.\n+\n+Just as a `List` can be lazily computed, a `Map` of lazily computed stable values can also be defined and used similarly.\n+In the example below, we lazily compute a map's stable values for an enumerated collection of pre-defined keys:\n+\n+```\n+class MapDemo {\n+\n+    \/\/ 1. Declare a stable map of loggers with two allowable keys:\n+    \/\/    \"com.foo.Bar\" and \"com.foo.Baz\"\n+    static final Map<String, StableValue<Logger>> LOGGERS =\n+            StableValue.ofMap(Set.of(\"com.foo.Bar\", \"com.foo.Baz\"));\n+\n+    \/\/ 2. Access the memoized map with as-declared-final performance\n+    \/\/    (evaluation made before the first access)\n+    static Logger logger(String name) {\n+        return StableValue.computeIfUnset(LOGGERS, name, Logger::getLogger);\n+    }\n+}\n+```\n+\n+This concept allows declaring a large number of stable values which can be easily retrieved using arbitrarily, but\n+pre-specified, keys in a resource-efficient and performant way. For example, high-performance, non-evicting caches\n+may now be easily and reliably realized.\n+\n+Providing an `EnumSet<K>` to the `StableValue::ofMap` factory will unlock additional storage and performance\n+optimizations for the returned map with stable values.\n+\n+It is worth remembering, that the stable collections all promise the function provided at computation\n+(used to lazily compute elements or values) is invoked at most once per index or key; even\n+though used from several threads.\n+\n+### Memoized functions\n+\n+So far, we have talked about the fundamental features of Stable Values & Collections as securely\n+wrapped `@Stable` value holders. However, it has become apparent, stable primitives are amenable\n+to composition with other constructs in order to create more high-level and powerful features.\n+\n+[Memoized functions](https:\/\/en.wikipedia.org\/wiki\/Memoization) are functions where the output for a particular\n+input value is computed only once and is remembered such that remembered outputs can be reused for subsequent\n+calls with recurring input values. Here is how we could make sure `Logger.getLogger(\"com.foo.Bar\")`\n+in one of the first examples above is invoked at most once (provided it executes successfully)\n+in a multi-threaded environment:\n+\n+```\n+class Memoized {\n+\n+    \/\/ 1. Declare a map with stable values\n+    private static final Map<String, StableValue<Logger>> MAP =\n+            StableValue.ofMap(Set.of(\"com.foo.Bar\", \"com.foo.Baz\"));\n+\n+    \/\/ 2. Declare a memoized (cached) function backed by the stable map\n+    private static final Function<String, Logger> LOGGERS =\n+            n -> StableValue.computeIfUnset(MAP, n, Logger::getLogger);\n+\n+    ...\n+\n+    private static final String NAME = \"com.foo.Baz\";\n+\n+    \/\/ 3. Access the memoized value via the function with as-declared-final\n+    \/\/    performance (evaluation made before the first access)\n+    Logger logger = LOGGERS.apply(NAME);\n+}\n+```\n+\n+In the example above, for each key, the function is invoked at most once per\n+loading of the containing class `MapDemo` (`MapDemo`, in turn, can be loaded at\n+most once into any given `ClassLoader`) as it is backed by a `Map` with lazily\n+computed values which upholds the invoke-at-most-once-per-key invariant.\n+\n+It should be noted that the enumerated collection of keys given at creation time\n+constitutes the only valid input keys for the memoized function.\n+\n+Similarly to how a `Function` can be memoized using a backing lazily computed map, the same pattern\n+can be used for an `IntFunction` that will record its cached value in a backing _stable list_:\n+\n+```\n+\/\/ 1. Declare a stable list of default error pages to serve up\n+private static final List<StableValue<String>> ERROR_PAGES =\n+        StableValue.ofList(SIZE);\n+\n+\/\/ 2. Declare a memoized IntFunction backed by the stable list\n+private static final IntFunction<String> ERROR_FUNCTION =\n+        i -> StableValue.computeIfUnset(ERROR_PAGES, i, ListDemo::readFromFile);\n+\n+\/\/ 3. Define a function that is to be called the first\n+\/\/    time a particular message number is referenced\n+private static String readFromFile(int messageNumber) {\n+    try {\n+        return Files.readString(Path.of(\"message-\" + messageNumber + \".html\"));\n+    } catch (IOException e) {\n+        throw new UncheckedIOException(e);\n+    }\n+}\n+\n+\/\/ 4. Access the memoized list element with as-declared-final performance\n+\/\/    (evaluation made before the first access)\n+String msg =  ERROR_FUNCTION.apply(2);\n+\n+\/\/ <!DOCTYPE html>\n+\/\/ <html lang=\"en\">\n+\/\/   <head><meta charset=\"utf-8\"><\/head>\n+\/\/   <body>Payment was denied: Insufficient funds.<\/body>\n+\/\/ <\/html>\n+```\n+\n+The same paradigm can be used for creating a memoized `Supplier` (backed by a single `StableValue` instance) or\n+a memoized `Predicate`(backed by a lazily computed `Map<K, StableValue<Boolean>>`). An astute reader will be able to\n+write such constructs in a few lines.\n+\n+## Alternatives\n+\n+There are other classes in the JDK that support lazy computation including `Map`, `AtomicReference`, `ClassValue`,\n+and `ThreadLocal` all of which, unfortunately, support arbitrary mutation and thus, hinder the JVM from reasoning\n+about constantness thereby preventing constant folding and other optimizations.\n+\n+So, alternatives would be to keep using explicit double-checked locking, maps, holder classes, Atomic classes,\n+and third-party frameworks. Another alternative would be to add language support for immutable value holders.\n+\n+## Risks and assumptions\n+\n+Creating an API to provide thread-safe computed constant fields with an on-par performance with holder\n+classes efficiently is a non-trivial task. It is, however, assumed that the current JIT implementations\n+will likely suffice to reach the goals of this JEP.\n+\n+## Dependencies\n+\n+The work described here will likely enable subsequent work to provide pre-evaluated computed\n+constant fields at compile, condensation, and\/or runtime.\n","filename":"test\/jdk\/java\/lang\/StableValue\/Jep.md","additions":485,"deletions":0,"binary":false,"changes":485,"status":"added"},{"patch":"@@ -0,0 +1,558 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Demo of the JEP examples.\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} JepDemo.java\n+ * @run junit\/othervm --enable-preview JepDemo\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class JepDemo {\n+\n+    static class Foo {};\n+\n+\n+\n+    static\n+    class BarBefore {\n+        \/\/ ordinary static initialization\n+        private static final Logger LOGGER = Logger.getLogger(\"com.foo.Bar\");\n+\n+        public void handleRequest() {\n+            LOGGER.log(Level.INFO, \"Hello\");\n+        }\n+\n+    }\n+\n+    static\n+    class BarBefore2 {\n+        \/\/ Initialization-on-demand holder idiom\n+        Logger logger() {\n+            class Holder {\n+                static final Logger LOGGER = Logger.getLogger(\"com.foo.Bar\");\n+            }\n+            return Holder.LOGGER;\n+        }\n+\n+        public void handleRequest() {\n+            logger().log(Level.INFO, \"Hello\");\n+        }\n+\n+    }\n+\n+    static\n+    class Bar {\n+        \/\/ 1. Declare a stable value field\n+        private static final StableValue<Logger> LOGGER = StableValue.of();\n+\n+        static Logger logger() {\n+\n+            if (!LOGGER.isSet()) {\n+                \/\/ 2. Set the stable value _after_ the field was declared\n+                return LOGGER.setIfUnset(Logger.getLogger(\"com.foo.Bar\"));\n+            }\n+\n+            \/\/ 3. Access the stable value with as-declared-final performance\n+            return LOGGER.orThrow();\n+        }\n+\n+    }\n+\n+    static\n+    class Bar2 {\n+        \/\/ 1. Declare a stable value field\n+        private static final StableValue<Logger> LOGGER = StableValue.of();\n+\n+        static Logger logger() {\n+            \/\/ 2. Access the stable value with as-declared-final performance\n+            \/\/    (single evaluation made before the first access)\n+            return LOGGER.computeIfUnset( () -> Logger.getLogger(\"com.foo.Bar\") );\n+        }\n+    }\n+\n+    \/\/ Option: \"Type Escape Analysis\"\n+\n+    static\n+    class Bar3 {\n+        \/\/ 1. Declare a backing stable value\n+        private static final StableValue<Logger> STABLE = StableValue.of();\n+\n+        \/\/ 2. Declare a memoized (cached) Supplier backed by the stable value\n+        private static final Supplier<Logger> LOGGER = () -> STABLE\n+                .computeIfUnset( () -> Logger.getLogger(\"com.foo.Bar\") );\n+\n+        static Logger logger() {\n+            \/\/ 3. Access the memoized suppler with as-declared-final performance\n+            \/\/    (evaluation made before the first access)\n+            return LOGGER.get();\n+        }\n+    }\n+\n+    static\n+    class Bar4 {\n+\n+        \/\/ 1. Declare a memoized (cached) Supplier backed by a stable value\n+        private static final Supplier<Logger> LOGGER =\n+                StableValue.memoizedSupplier( () -> Logger.getLogger(\"com.foo.Bar\") );\n+\n+        static Logger logger() {\n+            \/\/ 2. Access the memoized suppler with as-declared-final performance\n+            \/\/    (evaluation made before the first access)\n+            return LOGGER.get();\n+        }\n+    }\n+\n+    \/\/ Instance context\n+\n+    \/\/ In user-land and if we want constant folding when using\n+    \/\/ the holder statically:\n+\n+    static\n+    class HolderImplementedByUser {\n+\n+        private static final LoggerHolder HOLDER = new LoggerHolder();\n+\n+        public static void main(String[] args) {\n+            HOLDER.logger().log(Level.INFO, \"Hello Holder\");\n+        }\n+\n+    }\n+\n+    \/\/ A field must be trusted recursively on order to be eligible for CF\n+    \/\/ Trick: Fields in a `record` class are trusted\n+\n+    record LoggerHolder(StableValue<Logger> loggerHolder) {\n+\n+        public LoggerHolder() {\n+            this(StableValue.of());\n+        }\n+\n+        Logger logger() {\n+            \/\/ 1. Access the logger holder with as-declared-final performance\n+            \/\/    (evaluation made before the first access)\n+            return loggerHolder.computeIfUnset(() -> Logger.getLogger(\"com.foo.Bar\") );\n+        }\n+    }\n+\n+    \/\/ StableValue fields has special VM treatment!\n+\n+    static\n+    class LoggerHolder2 {\n+\n+        \/\/ 1. Declare an instance field that holds the logger\n+        \/\/    This field gets special VM treatment as it is _of type_ StableValue\n+        \/\/    The field is resistant to updates via reflection and sun.misc.Unsafe\n+        private final StableValue<Logger> logger = StableValue.of();\n+\n+        Logger logger() {\n+            \/\/ 2. Access the logger with as-declared-final performance\n+            \/\/    (evaluation made before the first access)\n+            return logger.computeIfUnset(() -> Logger.getLogger(\"com.foo.Bar\") );\n+        }\n+    }\n+\n+    \/\/ This kind of special VM treatment is a new kid on the block.\n+\n+    \/\/ Stable Lists\n+\n+    static\n+    class ErrorMessages {\n+\n+        private static final int SIZE = 8;\n+\n+        \/\/ 1. Declare an array of error pages to serve up\n+        private static final String[] MESSAGES = new String[SIZE];\n+\n+        \/\/ 2. Define a function that is to be called the first\n+        \/\/    time a particular message number is referenced\n+        private static String readFromFile(int messageNumber) {\n+            try {\n+                return Files.readString(Path.of(\"message-\" + messageNumber + \".html\"));\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        static synchronized String message(int messageNumber) {\n+            \/\/ 3. Access the memoized array element under synchronization\n+            \/\/    and compute-and-store if absent.\n+            String page = MESSAGES[messageNumber];\n+            if (page == null) {\n+                page = readFromFile(messageNumber);\n+                MESSAGES[messageNumber] = page;\n+            }\n+            return page;\n+        }\n+\n+    }\n+\n+    static class Hide {\n+\n+        static\n+        class ErrorMessages {\n+\n+            private static final int SIZE = 8;\n+\n+            \/\/ 1. Declare a stable list of default error pages to serve up\n+            private static final List<StableValue<String>> MESSAGES = StableValue.ofList(SIZE);\n+\n+            \/\/ 2. Define a function that is to be called the first\n+            \/\/    time a particular message number is referenced\n+            private static String readFromFile(int messageNumber) {\n+                try {\n+                    return Files.readString(Path.of(\"message-\" + messageNumber + \".html\"));\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+\n+            static String errorPage(int messageNumber) {\n+                \/\/ 3. Access the memoized list element with as-declared-final performance\n+                \/\/    (evaluation made before the first access)\n+                return StableValue.computeIfUnset(MESSAGES, messageNumber, ErrorMessages::readFromFile);\n+            }\n+\n+            public static void main(String[] args) {\n+                String errorPage = ErrorMessages.errorPage(2);\n+\n+                \/\/ <!DOCTYPE html>\n+                \/\/ <html lang=\"en\">\n+                \/\/   <head><meta charset=\"utf-8\"><\/head>\n+                \/\/   <body>Payment was denied: Insufficient funds.<\/body>\n+                \/\/ <\/html>\n+            }\n+\n+        }\n+    }\n+\n+    static\n+    class ListDemo2 {\n+\n+        private static final int SIZE = 8;\n+\n+        \/\/ 1. Declare a stable list of default error pages to serve up\n+        private static final List<StableValue<String>> ERROR_PAGES =\n+                StableValue.ofList(SIZE);\n+\n+        \/\/ 2. Declare a memoized IntFunction backed by the stable list\n+        private static final IntFunction<String> ERROR_FUNCTION =\n+                i -> StableValue.computeIfUnset(ERROR_PAGES, i, ListDemo2::readFromFile);\n+\n+        \/\/ 3. Define a function that is to be called the first\n+        \/\/    time a particular message number is referenced\n+        private static String readFromFile(int messageNumber) {\n+            try {\n+                return Files.readString(Path.of(\"message-\" + messageNumber + \".html\"));\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+\n+        public static void main(String[] args) {\n+            \/\/ 4. Access the memoized list element with as-declared-final performance\n+            \/\/    (evaluation made before the first access)\n+            String msg =  ERROR_FUNCTION.apply(2);\n+        }\n+\n+    }\n+\n+    static\n+    class ListDemo3 {\n+\n+        private static final int SIZE = 8;\n+\n+        \/\/ 1. Declare a memoized IntFunction backed by the stable list\n+        private static final IntFunction<String> ERROR_FUNCTION =\n+                StableValue.memoizedIntFunction(SIZE, ListDemo3::readFromFile);\n+\n+        \/\/ 2. Define a function that is to be called the first\n+        \/\/    time a particular message number is referenced\n+        private static String readFromFile(int messageNumber) {\n+            try {\n+                return Files.readString(Path.of(\"message-\" + messageNumber + \".html\"));\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            \/\/ 3. Access the memoized list element with as-declared-final performance\n+            \/\/    (evaluation made before the first access)\n+            String msg =  ERROR_FUNCTION.apply(2);\n+        }\n+\n+    }\n+\n+    \/\/ Instance fields\n+\n+    interface Fibonacci {\n+        \/**\n+         * {@return the fibonacci number for the provided sequence number {@code n}}\n+         * @param n the (non-negative) sequence number\n+         *\/\n+        int fib(int n); \/\/ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n+    }\n+\n+    static\n+    class FibonacciNaive implements Fibonacci {\n+\n+        @Override\n+        public int fib(int n) {\n+            return (n < 2)\n+                    ? n\n+                    : fib(n - 1) + fib(n - 2);\n+        }\n+\n+    }\n+\n+    static\n+    class Fibonacci1 implements Fibonacci {\n+\n+        private final IntFunction<Integer> fibFunction;\n+\n+        public Fibonacci1(int upperBound) {\n+            fibFunction = StableValue.memoizedIntFunction(upperBound, this::fib);\n+        }\n+\n+        @Override\n+        public int fib(int n) {\n+            return (n < 2)\n+                    ? n\n+                    : fibFunction.apply(n - 1) + fibFunction.apply(n - 2);\n+        }\n+\n+    }\n+\n+    \/\/ No Constant folding if Fibonacci is used in a static context :-(\n+    \/\/ Let's do the `record` trick again!\n+\n+\/*\n+\n+    record Fibonacci2(IntFunction<Integer> fibFunction) implements Fibonacci {\n+\n+        public Fibonacci2(int upperBound) {\n+            this(StableValue.ofIntFunction(upperBound, this::number));\n+        }\n+\n+        @Override\n+        public int fib(int n) {\n+            return (n < 2)\n+                    ? n\n+                    : fibFunction.apply(n - 1) + fibFunction.apply(n - 2);\n+        }\n+\n+    }\n+*\/\n+\n+\n+    \/\/ Does not work as we cannot reference \"this\" before the constructor returns.\n+    \/\/ IF ONLY WE HAD \"greater flexibility as to the timing of initialization\" ;-)\n+\n+\n+\n+\n+\n+    record Fibonacci3(StableValue<IntFunction<Integer>> fibFunction) implements Fibonacci {\n+\n+        public Fibonacci3(int upperBound) {\n+            this(StableValue.of());\n+            fibFunction.trySet(\n+                    StableValue.memoizedIntFunction(upperBound, this::fib));\n+        }\n+\n+        @Override\n+        public int fib(int n) {\n+            return (n < 2)\n+                    ? n\n+                    : fibFunction.orThrow().apply(n - 1) +\n+                      fibFunction.orThrow().apply(n - 2);\n+        }\n+\n+    }\n+\n+    \/\/ Option: Make StableIntFunction, StableList, StableMap a part of the type system\n+    \/\/         and grant special VM treatment for these too, just like StableValue.\n+    \/\/ Pro:    Some static helper functions (StableValue::computeIfUnset) can be moved\n+    \/\/         to these types\n+    \/\/ Con:    StableList<StableValue<T>> list =\n+\n+\n+    \/\/ Stable Maps\n+\n+    static\n+    class MapDemo {\n+\n+        \/\/ 1. Declare a stable map of loggers with two allowable keys:\n+        \/\/    \"com.foo.Bar\" and \"com.foo.Baz\"\n+        static final Map<String, StableValue<Logger>> LOGGERS =\n+                StableValue.ofMap(Set.of(\"com.foo.Bar\", \"com.foo.Baz\"));\n+\n+        \/\/ 2. Access the memoized map with as-declared-final performance\n+        \/\/    (evaluation made before the first access)\n+        static Logger logger(String name) {\n+            return StableValue.computeIfUnset(LOGGERS, name, Logger::getLogger);\n+        }\n+    }\n+\n+\n+\n+    \/\/ It might be possible to provide:\n+    \/\/     Map<K, StableValue<V>> map = StableValue.ofMap(capacity); \/\/ Fixed capacity\n+    \/\/ But it would not be immutable and would be non-trivial to design.\n+    \/\/ Even this is theoretically possible:\n+    \/\/     Map<K, StableValue<V>> map = StableValue.ofMap(initialCapacity); \/\/ Variable capacity\n+\n+    static\n+    class LoggableDemo {\n+\n+        static final Map<String, StableValue<Boolean>> INFO_LOGGABLE =\n+                StableValue.ofMap(Set.of(\"com.foo.Bar\", \"com.foo.Baz\"));\n+\n+        static boolean isInfoLoggable(String name) {\n+            return StableValue.computeIfUnset(INFO_LOGGABLE, name, n -> MapDemo.logger(n).isLoggable(Level.INFO));\n+        }\n+\n+        private static final String NAME = \"com.foo.Bar\";\n+\n+        public static void main(String[] args) {\n+            if (isInfoLoggable(NAME)) {\n+                MapDemo.LOGGERS.get(NAME)\n+                        .orThrow()\n+                        .log(Level.INFO, \"This is fast...\");\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ For stable Enum Maps, see BasicStableEnumMapTest\n+    \/\/ Emerging property: faster and more dense as it is using a simple backing array\n+\n+    static\n+    class Memo {\n+\n+        static\n+        class Memoized {\n+\n+            \/\/ 1. Declare a lazily computed map\n+            private static final Map<String, StableValue<Logger>> MAP =\n+                    StableValue.ofMap(Set.of(\"com.foo.Bar\", \"com.foo.Baz\"));\n+\n+            \/\/ 2. Declare a memoized (cached) function backed by the lazily computed map\n+            private static final Function<String, Logger> LOGGERS =\n+                    n -> StableValue.computeIfUnset(MAP, n, Logger::getLogger);\n+\n+            private static final String NAME = \"com.foo.Baz\";\n+\n+            public static void main(String[] args) {\n+                \/\/ 3. Access the memoized value via the function with as-declared-final\n+                \/\/    performance (evaluation made before the first access)\n+                Logger logger = LOGGERS.apply(NAME);\n+            }\n+\n+        }\n+\n+        static\n+        class Memoized2 {\n+\n+            \/\/ 1. Declare a memoized (cached) function backed by a lazily computed map\n+            private static final Function<String, Logger> MAPPER =\n+                    StableValue.memoizedFunction(\n+                            Set.of(\"com.foo.Bar\", \"com.foo.Baz\"),\n+                            Logger::getLogger);\n+\n+            private static final String NAME = \"com.foo.Baz\";\n+\n+            public static void main(String[] args) {\n+                \/\/ 2. Access the memoized value via the function with as-declared-final\n+                \/\/    performance (evaluation made before the first access)\n+                Logger logger = MAPPER.apply(NAME);\n+            }\n+\n+        }\n+    }\n+\n+    @Test\n+    void fibDelta() {\n+        {\n+            long begin = System.nanoTime();\n+            Fibonacci fibonacci = new FibonacciNaive();\n+            int[] fibs = IntStream.range(0, 30)\n+                    .map(fibonacci::fib)\n+                    .toArray(); \/\/ { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }\n+            long duration = System.nanoTime() - begin;\n+            System.out.println(\"Naive = \" + duration \/ 1000);\n+        }\n+        {\n+            long begin = System.nanoTime();\n+            Fibonacci fibonacci = new Fibonacci1(31);\n+            int[] fibs = IntStream.range(0, 30)\n+                    .map(fibonacci::fib)\n+                    .toArray(); \/\/ { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }\n+            long duration = System.nanoTime() - begin;\n+            System.out.println(\"Stable = \" + duration \/ 1000);\n+        }\n+\n+    }\n+\n+    @Test\n+    void fib() {\n+        Fibonacci fibonacci = new Fibonacci1(20);\n+        int[] fibs = IntStream.range(0, 10)\n+                .map(fibonacci::fib)\n+                .toArray(); \/\/ { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }\n+\n+        assertArrayEquals(new int[]{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }, fibs);\n+    }\n+\n+    @Test\n+    void fib3() {\n+        Fibonacci fibonacci = new Fibonacci3(20);\n+        int[] fibs = IntStream.range(0, 10)\n+                .map(fibonacci::fib)\n+                .toArray(); \/\/ { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }\n+\n+        assertArrayEquals(new int[]{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }, fibs);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/JepDemo.java","additions":558,"deletions":0,"binary":false,"changes":558,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for memoized Supplier\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} MemoizedFunctionTest.java\n+ * @compile StableTestUtil.java\n+ * @run junit\/othervm --enable-preview MemoizedFunctionTest\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+final class MemoizedFunctionTest {\n+\n+    private static final int FIRST = 42;\n+\n+    @Test\n+    void memoized() {\n+        StableTestUtil.CountingFunction<Integer, Integer> counting = new StableTestUtil.CountingFunction<>(Function.identity());\n+        Function<Integer, Integer> memoized = StableValue.memoizedFunction(Set.of(0, 1, FIRST), counting);\n+        assertEquals(FIRST, memoized.apply(FIRST));\n+        assertEquals(1, counting.cnt());\n+        \/\/ Make sure the original supplier is not invoked more than once\n+        assertEquals(FIRST, memoized.apply(FIRST));\n+        assertEquals(1, counting.cnt());\n+\n+        assertThrows(NoSuchElementException.class, () -> memoized.apply(-1));\n+        assertThrows(NoSuchElementException.class, () -> memoized.apply(FIRST + 1));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/MemoizedFunctionTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for memoized Supplier\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} MemoizedIntFunctionTest.java\n+ * @compile StableTestUtil.java\n+ * @run junit\/othervm --enable-preview MemoizedIntFunctionTest\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.IntFunction;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+final class MemoizedIntFunctionTest {\n+\n+    private static final int FIRST = 42;\n+\n+    @Test\n+    void memoized() {\n+        StableTestUtil.CountingIntFunction<Integer> counting = new StableTestUtil.CountingIntFunction<>(i -> i);\n+        IntFunction<Integer> memoized = StableValue.memoizedIntFunction(FIRST + 1, counting);\n+        assertEquals(FIRST, memoized.apply(FIRST));\n+        assertEquals(1, counting.cnt());\n+        \/\/ Make sure the original supplier is not invoked more than once\n+        assertEquals(FIRST, memoized.apply(FIRST));\n+        assertEquals(1, counting.cnt());\n+\n+        assertThrows(IndexOutOfBoundsException.class, () -> memoized.apply(-1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> memoized.apply(FIRST + 1));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/MemoizedIntFunctionTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for memoized Supplier\n+ * @modules java.base\/jdk.internal.lang\n+ * @compile --enable-preview -source ${jdk.version} MemoizedSupplierTest.java\n+ * @compile StableTestUtil.java\n+ * @run junit\/othervm --enable-preview MemoizedSupplierTest\n+ *\/\n+\n+import jdk.internal.lang.StableValue;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class MemoizedSupplierTest {\n+\n+    private static final int FIRST = 42;\n+\n+    @Test\n+    void memoized() {\n+        StableTestUtil.CountingSupplier<Integer> counting = new StableTestUtil.CountingSupplier<>(() -> FIRST);\n+        Supplier<Integer> memoized = StableValue.memoizedSupplier(counting);\n+        assertEquals(FIRST, memoized.get());\n+        assertEquals(1, counting.cnt());\n+        \/\/ Make sure the original supplier is not invoked more than once\n+        assertEquals(FIRST, memoized.get());\n+        assertEquals(1, counting.cnt());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/MemoizedSupplierTest.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+public class StableTestUtil {\n+\n+    public static final class CountingSupplier<T>\n+            extends AbstractCounting<Supplier<T>>\n+            implements Supplier<T> {\n+\n+        public CountingSupplier(Supplier<T> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public T get() {\n+            incrementCounter();\n+            return delegate.get();\n+        }\n+\n+    }\n+\n+    public static final class CountingIntFunction<T>\n+            extends AbstractCounting<IntFunction<T>>\n+            implements IntFunction<T> {\n+\n+        public CountingIntFunction(IntFunction<T> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public T apply(int value) {\n+            incrementCounter();\n+            return delegate.apply(value);\n+        }\n+\n+    }\n+\n+    public static final class CountingFunction<T, R>\n+            extends AbstractCounting<Function<T, R>>\n+            implements Function<T, R> {\n+\n+        public CountingFunction(Function<T, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t) {\n+            incrementCounter();\n+            return delegate.apply(t);\n+        }\n+    }\n+\n+    abstract static class AbstractCounting<D> {\n+\n+        private final AtomicInteger cnt = new AtomicInteger();\n+        protected final D delegate;\n+\n+        protected AbstractCounting(D delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        protected final void incrementCounter() {\n+            cnt.incrementAndGet();\n+        }\n+\n+        public final int cnt() {\n+            return cnt.get();\n+        }\n+\n+        @Override\n+        public final String toString() {\n+            return cnt.toString();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableTestUtil.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance in instance contexts\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\",\n+\/*\"-XX:CompileCommand=dontinline,jdk.internal.lang.stable.StableValueImpl::orThrow\",\n+\"-XX:CompileCommand=dontinline,org.openjdk.bench.java.lang.stable.StableBenchmark$Dcl::get\",\n+\"-XX:CompileCommand=dontinline,java.util.concurrent.atomic.AtomicReference::get\",\n+\"-XX:-BackgroundCompilation\",\n+\"-XX:CompileCommand=print,jdk.internal.lang.stable.StableValueImpl::orThrow\",\n+\"-XX:CompileCommand=print,org.openjdk.bench.java.lang.stable.StableBenchmark$Dcl::get\",\n+\"-XX:CompileCommand=print,java.util.concurrent.atomic.AtomicReference::get\",\n+\"-XX:-TieredCompilation\"*\/\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableBenchmark {\n+\n+    private static final int ITERATIONS = 17;\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final StableValue<Integer> stableNull = StableValue.of();\n+    private final StableValue<Integer> stableNull2 = StableValue.of();\n+    private final StableValue<List<Integer>> stableHoldingList = StableValue.of();\n+    private final StableValue<List<Integer>> stableHoldingList2 = StableValue.of();\n+    private final Supplier<Integer> dcl = new Dcl<>(() -> VALUE);\n+    private final Supplier<Integer> dcl2 = new Dcl<>(() -> VALUE2);\n+    private final List<StableValue<Integer>> list = StableValue.ofList(2);\n+    private final List<StableValue<Integer>> listStored = List.of(StableValue.of(), StableValue.of());\n+    private final AtomicReference<Integer> atomic = new AtomicReference<>(VALUE);\n+    private final AtomicReference<Integer> atomic2 = new AtomicReference<>(VALUE2);\n+    private final Supplier<Integer> supplier = () -> VALUE;\n+    private final Supplier<Integer> supplier2 = () -> VALUE2;\n+\n+    @Setup\n+    public void setup() {\n+        stableNull.trySet(null);\n+        stableNull2.trySet(VALUE2);\n+        list.getFirst().trySet(VALUE);\n+        list.get(1).trySet(VALUE2);\n+        stableHoldingList.trySet(List.of(VALUE));\n+        stableHoldingList2.trySet(List.of(VALUE2));\n+        listStored.getFirst().trySet(VALUE);\n+        listStored.get(1).trySet(VALUE2);\n+    }\n+\n+    @Benchmark\n+    public int atomic() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += atomic.get() + atomic2.get();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int dcl() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += dcl.get() + dcl2.get();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int stable() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += stable.orThrow() + stable2.orThrow();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int stableNull() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += (stableNull.orThrow() == null ? 0 : 1) + (stableNull2.orThrow() == null ? 0 : 1);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int stableHoldingList() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += stableHoldingList.orThrow().get(0) + stableHoldingList2.orThrow().get(0);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int stableList() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += list.get(0).orThrow() + list.get(1).orThrow();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int stableListStored() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += listStored.get(0).orThrow() + listStored.get(1).orThrow();\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Reference case\n+    @Benchmark\n+    public int supplier() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += supplier.get() + supplier2.get();\n+        }\n+        return sum;\n+    }\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+    \/\/ Handles null values\n+    private static class Dcl<V> implements Supplier<V> {\n+\n+        private final Supplier<V> supplier;\n+\n+        private volatile V value;\n+        private boolean bound;\n+\n+        public Dcl(Supplier<V> supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        @Override\n+        public V get() {\n+            V v = value;\n+            if (v == null) {\n+                if (!bound) {\n+                    synchronized (this) {\n+                        v = value;\n+                        if (v == null) {\n+                            if (!bound) {\n+                                value = v = supplier.get();\n+                                bound = true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableBenchmark.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Benchmark measuring stable list performance\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableListElementBenchmark {\n+\n+    private static final IntFunction<Integer> FUNCTION = i -> i;\n+    private static final int SIZE = 100;\n+\n+    private static final List<StableValue<Integer>> STORED = Stream.generate(StableValue::<Integer>of)\n+            .limit(SIZE)\n+            .toList();\n+    private static final List<StableValue<Integer>> LIST = StableValue.ofList(SIZE);\n+\n+    static {\n+        initLazy(STORED);\n+        initLazy(LIST);\n+    }\n+\n+    private static final List<Integer> ARRAY_LIST = initList(new ArrayList<>(SIZE));\n+\n+    \/\/private final List<Monotonic<Integer>> referenceList = initMono(Monotonic.ofList(SIZE));\n+    private final List<Integer> arrayList = initList(new ArrayList<>(SIZE));\n+    private final List<StableValue<Integer>> storedList;\n+    private final List<StableValue<Integer>> list;\n+\n+\n+    public StableListElementBenchmark() {\n+        this.storedList = Stream.generate(StableValue::<Integer>of)\n+                .limit(SIZE)\n+                .toList();\n+        initLazy(storedList);\n+        list = StableValue.ofList(SIZE);\n+        initLazy(list);\n+    }\n+\n+    @Setup\n+    public void setup() {\n+    }\n+\n+    @Benchmark\n+    public int instanceArrayList() {\n+        return arrayList.get(8);\n+    }\n+\n+    @Benchmark\n+    public int instanceList() {\n+        return list.get(8).orThrow();\n+    }\n+\n+    @Benchmark\n+    public int instanceStored() {\n+        return storedList.get(8).orThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticArrayList() {\n+        return ARRAY_LIST.get(8);\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        return LIST.get(8).orThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticStored() {\n+        return STORED.get(8).orThrow();\n+    }\n+\n+    private static void initLazy(List<StableValue<Integer>> list) {\n+        int index = 8;\n+        var result = list.get(index).trySet(FUNCTION.apply(index));\n+        assert result;\n+    }\n+\n+    private static List<Integer> initList(List<Integer> list) {\n+        for (int i = 0; i < 9; i++) {\n+            list.add(FUNCTION.apply(i));\n+        }\n+        return list;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableListElementBenchmark.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Benchmark measuring stable list performance\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableListSumBenchmark {\n+\n+    private static final int SIZE = 1_000;\n+\n+    private static final List<StableValue<Integer>> STORED = randomStable(Stream.generate(StableValue::<Integer>of)\n+            .limit(SIZE)\n+            .toList());\n+\n+    private static final List<Integer> ARRAY_LIST = random(new ArrayList<>(SIZE));\n+    private static final List<StableValue<Integer>> LIST = randomStable(StableValue.ofList(SIZE));\n+\n+\n+    private final List<StableValue<Integer>> stored = randomStable(Stream.generate(StableValue::<Integer>of)\n+            .limit(SIZE)\n+            .toList());\n+    private final List<Integer> arrayList = random(new ArrayList<>(SIZE));\n+    private final List<StableValue<Integer>> list = randomStable(StableValue.ofList(SIZE));\n+\n+    @Setup\n+    public void setup() {\n+    }\n+\n+    @Benchmark\n+    public int instanceArrayList() {\n+        int sum = 0;\n+        for (int i = 0; i < arrayList.size(); i++) {\n+            sum += arrayList.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int instanceList() {\n+        int sum = 0;\n+        for (int i = 0; i < list.size(); i++) {\n+            sum += list.get(i).orThrow();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int instanceStored() {\n+        int sum = 0;\n+        for (int i = 0; i < stored.size(); i++) {\n+            sum += stored.get(i).orThrow();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticArrayList() {\n+        int sum = 0;\n+        for (int i = 0; i < ARRAY_LIST.size(); i++) {\n+            sum += ARRAY_LIST.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        int sum = 0;\n+        for (int i = 0; i < LIST.size(); i++) {\n+            sum += LIST.get(i).orThrow();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticStored() {\n+        int sum = 0;\n+        for (int i = 0; i < STORED.size(); i++) {\n+            sum += STORED.get(i).orThrow();\n+        }\n+        return sum;\n+    }\n+\n+    private static List<StableValue<Integer>> randomStable(List<StableValue<Integer>> list) {\n+        Random rnd = new Random();\n+        for (int i = 0; i < SIZE; i++) {\n+            list.get(i).trySet(rnd.nextInt(0, SIZE));\n+        }\n+        return list;\n+    }\n+\n+    private static List<Integer> random(List<Integer> list) {\n+        Random rnd = new Random();\n+        for (int i = 0; i < SIZE; i++) {\n+            list.add(rnd.nextInt(0, Integer.SIZE));\n+        }\n+        return list;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableListSumBenchmark.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StablePropertiesBenchmark {\n+\n+    private static final Function<String, String> FUNCTION = s -> switch (s) {\n+        case \"int\" -> \"1\";\n+        case \"long\" -> \"2\";\n+        case \"String\" -> \"Hello\";\n+        default -> throw new IllegalArgumentException();\n+    };\n+\n+    private static final String KEY = \"int\";\n+\n+    private static final Set<String> PROPERTY_KEYS = Set.of(\"int\", \"long\", \"String\");\n+\n+    private static final Map<String, StableValue<String>> STABLE_MAP = StableValue.ofMap(PROPERTY_KEYS);\n+    private static final Properties PROPERTIES;\n+    private static final Map<String, String> CHM;\n+    private static final Map<String, String> MAP;\n+\n+    static {\n+        PROPERTIES = new Properties();\n+        PROPERTY_KEYS.forEach(k -> PROPERTIES.setProperty(k, FUNCTION.apply(k)));\n+        CHM = new ConcurrentHashMap<>();\n+        PROPERTY_KEYS.forEach(k -> CHM.put(k, FUNCTION.apply(k)));\n+        MAP = Map.copyOf(PROPERTY_KEYS.stream()\n+                .collect(Collectors.toMap(Function.identity(), FUNCTION)));\n+    }\n+\n+    @Benchmark\n+    public int chm() {\n+        return Integer.valueOf(CHM.get(KEY));\n+    }\n+\n+    @Benchmark\n+    public int map() {\n+        return Integer.valueOf(MAP.get(KEY));\n+    }\n+\n+    @Benchmark\n+    public int prop() {\n+        return Integer.valueOf(PROPERTIES.getProperty(KEY));\n+    }\n+\n+    @Benchmark\n+    public int stable() {\n+        return Integer.valueOf(StableValue.computeIfUnset(STABLE_MAP, KEY, FUNCTION));\n+    }\n+\n+    @Benchmark\n+    public void chmRaw(Blackhole bh) {\n+        bh.consume(CHM.get(KEY));\n+    }\n+\n+    @Benchmark\n+    public void mapRaw(Blackhole bh) {\n+        bh.consume(MAP.get(KEY));\n+    }\n+\n+    @Benchmark\n+    public void propRaw(Blackhole bh) {\n+        bh.consume(PROPERTIES.getProperty(KEY));\n+    }\n+\n+    @Benchmark\n+    public void stableRaw(Blackhole bh) {\n+        bh.consume(StableValue.computeIfUnset(STABLE_MAP, KEY, FUNCTION));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StablePropertiesBenchmark.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue raw performance in instance contexts\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableRawBenchmark {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 13;\n+\n+    \/\/ Use two distinct values to prevent inlining of values\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final Supplier<Integer> dcl = new Dcl<>(() -> VALUE);\n+    private final Supplier<Integer> dcl2 = new Dcl<>(() -> VALUE2);\n+    private final AtomicReference<Integer> atomic = new AtomicReference<>(VALUE);\n+    private final AtomicReference<Integer> atomic2 = new AtomicReference<>(VALUE2);\n+\n+    @Benchmark\n+    public int atomic() {\n+        return atomic.get() + atomic2.get();\n+    }\n+\n+    @Benchmark\n+    public int dcl() {\n+        return dcl.get() + dcl2.get();\n+    }\n+\n+    @Benchmark\n+    public int stable() {\n+        return stable.orThrow() + stable2.orThrow();\n+    }\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+    \/\/ Handles null values\n+    private static class Dcl<V> implements Supplier<V> {\n+\n+        private final Supplier<V> supplier;\n+\n+        private volatile V value;\n+        private boolean bound;\n+\n+        public Dcl(Supplier<V> supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        @Override\n+        public V get() {\n+            V v = value;\n+            if (v == null) {\n+                if (!bound) {\n+                    synchronized (this) {\n+                        v = value;\n+                        if (v == null) {\n+                            if (!bound) {\n+                                value = v = supplier.get();\n+                                bound = true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableRawBenchmark.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance in a static context\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableStaticBenchmark {\n+\n+    private static final int VALUE = 42;\n+\n+    private static final StableValue<Integer> STABLE = init(StableValue.of());\n+    private static final StableValue<Integer> STABLE_NULL = StableValue.of();\n+    private static final Supplier<Integer> DCL = new Dcl<>(() -> VALUE);\n+    private static final List<StableValue<Integer>> LIST = StableValue.ofList(1);\n+    private static final AtomicReference<Integer> ATOMIC = new AtomicReference<>(VALUE);\n+    private static final DclHolder DCL_HOLDER = new DclHolder();\n+    private static final StableHolder STABLE_HOLDER = new StableHolder();\n+    private static final StableRecordHolder STABLE_RECORD_HOLDER = new StableRecordHolder();\n+\n+    static {\n+        LIST.getFirst().trySet(VALUE);\n+        STABLE_NULL.trySet(null);\n+    }\n+\n+    @Benchmark\n+    public int atomic() {\n+        return (int)ATOMIC.get();\n+    }\n+\n+    @Benchmark\n+    public int dcl() {\n+        return (int)DCL.get();\n+    }\n+\n+    @Benchmark\n+    public int dclHolder() {\n+        return (int)DCL_HOLDER.get();\n+    }\n+\n+    @Benchmark\n+    public int stable() {\n+        return (int)STABLE.orThrow();\n+    }\n+\n+    @Benchmark\n+    public int stableNull() {\n+        return STABLE_NULL.orThrow() == null ? 0 : 1;\n+    }\n+\n+    @Benchmark\n+    public int stableHolder() {\n+        return (int)STABLE_HOLDER.get();\n+    }\n+\n+    @Benchmark\n+    public int stableRecordHolder() {\n+        return (int)STABLE_RECORD_HOLDER.get();\n+    }\n+\n+    @Benchmark\n+    public int stableList() {\n+        return (int)LIST.get(0).orThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticCHI() {\n+        class Holder {\n+            static final int VALUE = 42;\n+        }\n+        return (int) Holder.VALUE;\n+    }\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m) {\n+        var result = m.trySet(VALUE);\n+        assert result;\n+        return m;\n+    }\n+\n+    \/\/ Handles null values\n+    private static class Dcl<V> implements Supplier<V> {\n+\n+        private final Supplier<V> supplier;\n+\n+        private volatile V value;\n+        private boolean bound;\n+\n+        public Dcl(Supplier<V> supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        @Override\n+        public V get() {\n+            V v = value;\n+            if (v == null) {\n+                if (!bound) {\n+                    synchronized (this) {\n+                        v = value;\n+                        if (v == null) {\n+                            if (!bound) {\n+                                value = v = supplier.get();\n+                                bound = true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private static final class DclHolder {\n+        private final Dcl<Integer> delegate = new Dcl<>(() -> VALUE);\n+\n+        public Integer get() {\n+            return delegate.get();\n+        }\n+    }\n+\n+    private static final class StableHolder {\n+        private final StableValue<Integer> delegate;\n+\n+        public StableHolder() {\n+            delegate = StableValue.of();\n+            var result = delegate.trySet(VALUE);\n+            assert result;\n+        }\n+\n+        public Integer get() {\n+            return delegate.orThrow();\n+        }\n+    }\n+\n+    private record StableRecordHolder(StableValue<Integer> delegate) {\n+\n+        public StableRecordHolder() {\n+            this(StableValue.of());\n+            var result = delegate.trySet(VALUE);\n+            assert result;\n+        }\n+\n+        public Integer get() {\n+            return delegate.orThrow();\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableStaticBenchmark.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"}]}