{"files":[{"patch":"@@ -45,2 +45,2 @@\n-import jdk.internal.lang.stable.AuxiliaryArrays;\n-import jdk.internal.lang.stable.StableValueElement;\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n@@ -49,0 +49,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -1455,3 +1456,1 @@\n-        private final V[] elements;\n-        @Stable\n-        private final AuxiliaryArrays aux;\n+        private final StableValueImpl<V>[] elements;\n@@ -1461,1 +1460,0 @@\n-            this.elements = newGenericArray(size);\n@@ -1463,1 +1461,1 @@\n-            this.aux = AuxiliaryArrays.create(size);\n+            this.elements = StableUtil.newStableValueArray(size);\n@@ -1466,0 +1464,1 @@\n+        @ForceInline\n@@ -1467,1 +1466,1 @@\n-        public StableValue<V> get(int index) {\n+        public StableValueImpl<V> get(int index) {\n@@ -1469,1 +1468,4 @@\n-            return new StableValueElement<>(elements, index, aux);\n+            StableValueImpl<V> stable = elements[index];\n+            return stable == null\n+                    ? StableUtil.getOrSetVolatile(elements, index)\n+                    : stable;\n@@ -1502,2 +1504,2 @@\n-            StableValueElement<V> element = new StableValueElement<>(elements, index, aux);\n-            return element.computeIfUnset(index, mapper);\n+            StableValueImpl<V> stable = get(index);\n+            return stable.computeIfUnset(index, mapper);\n@@ -1527,3 +1529,1 @@\n-        private final V[] values;\n-        @Stable\n-        private final AuxiliaryArrays aux;\n+        private final StableValueImpl<V>[] elements;\n@@ -1531,2 +1531,0 @@\n-        \/\/ keys array not trusted\n-        @SuppressWarnings(\"unchecked\")\n@@ -1555,2 +1553,1 @@\n-            this.values = newGenericArray(len);\n-            this.aux = AuxiliaryArrays.create(len);\n+            this.elements = StableUtil.newStableValueArray(len);\n@@ -1582,0 +1579,1 @@\n+        @ForceInline\n@@ -1583,1 +1581,4 @@\n-            return new StableValueElement<>(values, keyIndex, aux);\n+            StableValueImpl<V> stable = elements[keyIndex];\n+            return stable == null\n+                    ? StableUtil.getOrSetVolatile(elements, keyIndex)\n+                    : stable;\n@@ -1602,0 +1603,1 @@\n+        @ForceInline\n@@ -1686,1 +1688,1 @@\n-           StableValueElement<V> element = (StableValueElement<V>) get(key);\n+           StableValueImpl<V> element = (StableValueImpl<V>) get(key);\n@@ -1704,3 +1706,1 @@\n-        private int size;\n-        @Stable\n-        private final V[] elements;\n+        private final int size;\n@@ -1714,1 +1714,1 @@\n-        private final AuxiliaryArrays aux;\n+        private final StableValueImpl<V>[] elements;\n@@ -1716,1 +1716,0 @@\n-        @SuppressWarnings(\"unchecked\")\n@@ -1740,1 +1739,1 @@\n-            this.elements = newGenericArray(elementCount);\n+            this.elements = StableUtil.newStableValueArray(elementCount);\n@@ -1742,2 +1741,3 @@\n-            this.enumType = (Class<K>) keys.iterator().next().getClass();\n-            this.aux = AuxiliaryArrays.create(elementCount);\n+            @SuppressWarnings(\"unchecked\")\n+            Class<K> enumType0 = (Class<K>)keys.iterator().next().getClass();\n+            this.enumType = enumType0;\n@@ -1751,1 +1751,1 @@\n-                    (arrayIndex = arrayIndex(o)) >= 0 && arrayIndex < size &&\n+                    (arrayIndex = arrayIndex(o)) >= 0 && arrayIndex < size() &&\n@@ -1765,0 +1765,1 @@\n+        @ForceInline\n@@ -1766,1 +1767,1 @@\n-        public StableValue<V> get(Object key) {\n+        public StableValueImpl<V> get(Object key) {\n@@ -1772,2 +1773,6 @@\n-        private StableValue<V> value(int index) {\n-            return new StableValueElement<>(elements, index, aux);\n+        @ForceInline\n+        private StableValueImpl<V> value(int index) {\n+            StableValueImpl<V> stable = elements[index];\n+            return stable == null\n+                    ? StableUtil.getOrSetVolatile(elements, index)\n+                    : stable;\n@@ -1798,1 +1803,1 @@\n-                idx = (int) ((SALT32L * (elements.length)) >>> 32);\n+                idx = (int) ((SALT32L * size) >>> 32);\n@@ -1809,1 +1814,1 @@\n-                    if ((++idx) >= elements.length) {\n+                    if ((++idx) >= size) {\n@@ -1814,1 +1819,1 @@\n-                        idx = elements.length - 1;\n+                        idx = size - 1;\n@@ -1863,1 +1868,1 @@\n-            StableValueElement<V> element = (StableValueElement<V>) get(key);\n+            StableValueImpl<V> element = get(key);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":41,"deletions":36,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.lang.stable.StableValueElement;\n@@ -42,1 +41,0 @@\n-import java.util.function.Consumer;\n@@ -75,1 +73,1 @@\n-        permits StableValueElement, StableValueImpl {\n+        permits StableValueImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/StableValue.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-package jdk.internal.lang.stable;\n-\n-import jdk.internal.vm.annotation.Stable;\n-\n-import static jdk.internal.lang.stable.StableUtil.*;\n-\n-public record AuxiliaryArrays(@Stable int[] states,\n-                              Object[] mutexes,\n-                              boolean[] supplyings) { \/\/ Todo: make this array more dense\n-\n-    public static AuxiliaryArrays create(int size) {\n-        return new AuxiliaryArrays(new int[size], new Object[size], new boolean[size]);\n-    }\n-\n-    byte stateVolatile(int index) {\n-        return UNSAFE.getByteVolatile(states, StableUtil.intOffset(index));\n-    }\n-\n-    boolean supplying(int index) {\n-        return supplyings[index];\n-    }\n-\n-    void supplying(int index, boolean supplying) {\n-        supplyings[index] = supplying;\n-    }\n-\n-    void putState(int index, int newValue) {\n-        \/\/ This prevents `this.element[index]` to be seen\n-        \/\/ before `this.status[index]` is seen\n-        freeze();\n-        UNSAFE.putIntVolatile(states, StableUtil.intOffset(index), newValue);\n-    }\n-\n-    Object acquireMutex(int index) {\n-        Object mutex = UNSAFE.getReferenceVolatile(mutexes, StableUtil.objectOffset(index));\n-        if (mutex == null) {\n-            mutex = caeMutex(index);\n-        }\n-        return mutex;\n-    }\n-\n-    Object caeMutex(int index) {\n-        final var created = new Object();\n-        final var witness = UNSAFE.compareAndExchangeReference(mutexes, objectOffset(index), null, created);\n-        return witness == null ? created : witness;\n-    }\n-\n-    void putMutex(int index, Object value) {\n-        UNSAFE.putReferenceVolatile(mutexes, objectOffset(index), value);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/AuxiliaryArrays.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -5,0 +5,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -9,2 +10,0 @@\n-import static jdk.internal.lang.stable.StableUtil.newGenericArray;\n-\n@@ -14,2 +13,1 @@\n-        @Stable V[] elements,\n-        AuxiliaryArrays aux\n+        @Stable StableValueImpl<V>[] elements\n@@ -19,6 +17,1 @@\n-        this(dim0, dim1, Math.multiplyExact(dim0, dim1));\n-    }\n-\n-    \/\/ Todo: Remove when \"statements before super\" is a final feature\n-    private StableArray2DImpl(int dim0, int dim1, int length) {\n-        this(dim0, dim1, newGenericArray(length), AuxiliaryArrays.create(length));\n+        this(dim0, dim1, StableUtil.newStableValueArray(Math.multiplyExact(dim0, dim1)));\n@@ -27,0 +20,1 @@\n+    @ForceInline\n@@ -32,1 +26,4 @@\n-        return new StableValueElement<>(elements, index, aux);\n+        StableValueImpl<V> stable = elements[index];\n+        return stable == null\n+                ? StableUtil.getOrSetVolatile(elements, index)\n+                : stable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableArray2DImpl.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -9,2 +10,0 @@\n-import static jdk.internal.lang.stable.StableUtil.newGenericArray;\n-\n@@ -15,2 +14,1 @@\n-        @Stable V[] elements,\n-        AuxiliaryArrays aux\n+        @Stable StableValueImpl<V>[] elements\n@@ -20,6 +18,1 @@\n-        this(dim0, dim1, dim2, Math.multiplyExact(Math.multiplyExact(dim0, dim1), dim2));\n-    }\n-\n-    \/\/ Todo: Remove when \"statements before super\" is a final feature\n-    private StableArray3DImpl(int dim0, int dim1, int dim2, int length) {\n-        this(dim0, dim1, dim2, newGenericArray(length), AuxiliaryArrays.create(length));\n+        this(dim0, dim1, dim2, StableUtil.newStableValueArray(Math.multiplyExact(Math.multiplyExact(dim0, dim1), dim2)));\n@@ -28,0 +21,1 @@\n+    @ForceInline\n@@ -34,1 +28,4 @@\n-        return new StableValueElement<>(elements, index, aux);\n+        StableValueImpl<V> stable = elements[index];\n+        return stable == null\n+                ? StableUtil.getOrSetVolatile(elements, index)\n+                : stable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableArray3DImpl.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -9,2 +10,0 @@\n-import static jdk.internal.lang.stable.StableUtil.newGenericArray;\n-\n@@ -12,2 +11,1 @@\n-        @Stable V[] elements,\n-        AuxiliaryArrays aux\n+        @Stable StableValueImpl<V>[] elements\n@@ -17,1 +15,1 @@\n-        this(newGenericArray(length), AuxiliaryArrays.create(length));\n+        this(StableUtil.newStableValueArray(length));\n@@ -20,0 +18,1 @@\n+    @ForceInline\n@@ -23,1 +22,4 @@\n-        return new StableValueElement<>(elements, firstIndex, aux);\n+        StableValueImpl<V> stable = elements[firstIndex];\n+        return stable == null\n+                ? StableUtil.getOrSetVolatile(elements, firstIndex)\n+                : stable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableArrayImpl.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.DontInline;\n@@ -41,1 +42,1 @@\n-final class StableUtil {\n+public final class StableUtil {\n@@ -135,2 +136,19 @@\n-    static <V> V[] newGenericArray(int length) {\n-        return (V[]) new Object[length];\n+    public static <V> StableValueImpl<V>[] newStableValueArray(int length) {\n+        return (StableValueImpl<V>[]) new StableValueImpl<?>[length];\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @DontInline\n+    public static <V> StableValueImpl<V> getOrSetVolatile(StableValue<V>[] elements, int index) {\n+        final class Holder {\n+            private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+        }\n+        long offset = Unsafe.ARRAY_OBJECT_BASE_OFFSET + Unsafe.ARRAY_OBJECT_INDEX_SCALE * (long) index;\n+        StableValueImpl<V> stable = (StableValueImpl<V>)Holder.UNSAFE.getReferenceVolatile(elements, offset);\n+        if (stable == null) {\n+            stable = StableValueImpl.of();\n+            StableValueImpl<V> witness = (StableValueImpl<V>)\n+                    Holder.UNSAFE.compareAndExchangeReference(elements, offset, null, stable);\n+            return witness == null ? stable: witness;\n+        }\n+        return stable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,222 +0,0 @@\n-package jdk.internal.lang.stable;\n-\n-import jdk.internal.lang.StableValue;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.util.function.Function;\n-import java.util.function.IntFunction;\n-import java.util.function.Supplier;\n-\n-import static jdk.internal.lang.stable.StableUtil.*;\n-\n-\/\/ Records are ~10% faster than @ValueBased in JDK 23\n-public record StableValueElement<V>(\n-        @Stable V[] elements,\n-        @Stable int index,\n-        @Stable AuxiliaryArrays aux\n-) implements StableValue<V> {\n-\n-    @ForceInline\n-    @Override\n-    public boolean isSet() {\n-        int s;\n-        return (s = aux.states()[index]) == NON_NULL || s == NULL ||\n-                (s = aux.stateVolatile(index)) == NON_NULL || s == NULL;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public boolean isError() {\n-        return aux.states()[index] == ERROR || aux.stateVolatile(index) == ERROR;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public V orThrow() {\n-        \/\/ Todo: consider UNSAFE.getReference(elements, ...) as we have checked the index\n-        \/\/ @SuppressWarnings(\"unchecked\")\n-        \/\/ final V e = (V) UNSAFE.getReference(elements, objectOffset(index));\n-\n-        \/\/ Optimistically try plain semantics first\n-        final V e = elements[index];\n-        if (e != null) {\n-            \/\/ If we happen to see a non-null value under\n-            \/\/ plain semantics, we know a value is set.\n-            return e;\n-        }\n-        if (aux.states()[index] == NULL) {\n-            \/\/ If we happen to see a status value of NULL under\n-            \/\/ plain semantics, we know a value is set to `null`.\n-            return null;\n-        }\n-        \/\/ Now, fall back to volatile semantics.\n-        return orThrowVolatile();\n-    }\n-\n-    @DontInline \/\/ Slow-path taken at most once per thread if set\n-    private V orThrowVolatile() {\n-        \/\/ This is intentionally an old switch statement as it generates\n-        \/\/ more compact byte code.\n-        switch (aux.stateVolatile(index)) {\n-            case UNSET:    { throw StableUtil.notSet(); }\n-            case NON_NULL: { return elementVolatile(); }\n-            case NULL:     { return null; }\n-            case ERROR:    { throw StableUtil.error(this); }\n-        }\n-        throw shouldNotReachHere();\n-    }\n-\n-    @Override\n-    public V setIfUnset(V value) {\n-        if (isSet() || isError()) {\n-            return orThrow();\n-        }\n-        final var m = aux.acquireMutex(index);\n-        if (isMutexNotNeeded(m)) {\n-            return orThrow();\n-        }\n-        synchronized (m) {\n-            if (isSet()) {\n-                return orThrow();\n-            }\n-            if (isError()) {\n-                throw StableUtil.error(this);\n-            }\n-            setElement(value);\n-            return value;\n-        }\n-    }\n-\n-    @Override\n-    public boolean trySet(V value) {\n-        if (isSet() || isError()) {\n-            return false;\n-        }\n-        final var m = aux.acquireMutex(index);\n-        if (isMutexNotNeeded(m)) {\n-            return false;\n-        }\n-        synchronized (m) {\n-            if (isSet() || isError()) {\n-                return false;\n-            }\n-            setElement(value);\n-            return true;\n-        }\n-    }\n-\n-    private static final Function<Object, String> ERROR_MESSAGE_EXTRACTOR = new Function<Object, String>() {\n-        @Override\n-        public String apply(Object stableValue) {\n-            StableValueElement<?> sve = (StableValueElement<?>) stableValue;\n-            return ((Class<?>) sve.aux.acquireMutex(sve.index))\n-                    .getName();\n-        }\n-    };\n-\n-    @Override\n-    public String toString() {\n-        return StableUtil.toString(this, ERROR_MESSAGE_EXTRACTOR);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public V computeIfUnset(Supplier<? extends V> supplier) {\n-        return computeIfUnsetShared(supplier, null);\n-    }\n-\n-    @ForceInline\n-    public V computeIfUnset(int index, IntFunction<? extends V> mapper) {\n-        return computeIfUnsetShared(mapper, index);\n-    }\n-\n-    @ForceInline\n-    public <K> V computeIfUnset(K key, Function<? super K, ? extends V> mapper) {\n-        return computeIfUnsetShared(mapper, key);\n-    }\n-\n-    @ForceInline\n-    private <K> V computeIfUnsetShared(Object provider, K key) {\n-        \/\/ Optimistically try plain semantics first\n-        final V e = elements[index];\n-        if (e != null) {\n-            \/\/ If we happen to see a non-null value under\n-            \/\/ plain semantics, we know a value is set.\n-            return e;\n-        }\n-        if (aux.states()[index] == NULL) {\n-            return null;\n-        }\n-        \/\/ Now, fall back to volatile semantics.\n-        return computeIfUnsetVolatile(provider, key);\n-    }\n-\n-    @DontInline\n-    private <K> V computeIfUnsetVolatile(Object provider, K key) {\n-        \/\/ This is intentionally an old switch statement as it generates\n-        \/\/ more compact byte code.\n-        switch (aux.stateVolatile(index)) {\n-            case UNSET:    { return computeIfUnsetVolatile0(provider, key); }\n-            case NON_NULL: { return elementVolatile(); }\n-            case NULL:     { return null; }\n-            case ERROR:    { throw StableUtil.error(this); }\n-        }\n-        throw shouldNotReachHere();\n-    }\n-\n-    private <K> V computeIfUnsetVolatile0(Object provider, K key) {\n-        final var m = aux.acquireMutex(index);\n-        if (isMutexNotNeeded(m)) {\n-            return orThrow();\n-        }\n-        synchronized (m) {\n-            if (aux.states()[index] != UNSET) {\n-                return orThrow();\n-            }\n-\n-            \/\/ A value is not set\n-            if (aux.supplying(index)) {\n-                throw stackOverflow(provider, key);\n-            }\n-            try {\n-                aux.supplying(index,true);\n-                try {\n-                    @SuppressWarnings(\"unchecked\")\n-                    V newValue = switch (provider) {\n-                        case Supplier<?> sup     -> (V) sup.get();\n-                        case IntFunction<?> iFun -> (V) iFun.apply((int) key);\n-                        case Function<?, ?> func -> ((Function<K, V>) func).apply(key);\n-                        default                  -> throw shouldNotReachHere();\n-                    };\n-                    setElement(newValue);\n-                    return newValue;\n-                } catch (Throwable t) {\n-                    aux.putState(index, ERROR);\n-                    aux.putMutex(index, t.getClass());\n-                    throw t;\n-                }\n-            } finally {\n-                aux.supplying(index, false);\n-            }\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private V elementVolatile() {\n-        return (V) UNSAFE.getReferenceVolatile(elements, objectOffset(index));\n-    }\n-\n-    private void setElement(V value) {\n-        if (value != null) {\n-            \/\/ Make sure no reordering of store operations\n-            freeze();\n-            UNSAFE.putReferenceVolatile(elements, objectOffset(index), value);\n-        }\n-        \/\/ Crucially, indicate a value is set _after_ it has actually been set.\n-        aux.putState(index, value == null ? NULL : NON_NULL);\n-        aux.putMutex(index, TOMBSTONE); \/\/ We do not need a mutex anymore\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueElement.java","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.function.IntFunction;\n@@ -244,0 +245,76 @@\n+    @ForceInline\n+    public V computeIfUnset(int index, IntFunction<? extends V> mapper) {\n+        return computeIfUnsetShared(mapper, index);\n+    }\n+\n+    @ForceInline\n+    public <K> V computeIfUnset(K key, Function<? super K, ? extends V> mapper) {\n+        return computeIfUnsetShared(mapper, key);\n+    }\n+\n+    @ForceInline\n+    private <K> V computeIfUnsetShared(Object provider, K key) {\n+        \/\/ Optimistically try plain semantics first\n+        final V v = value;\n+        if (v != null) {\n+            \/\/ If we happen to see a non-null value under\n+            \/\/ plain semantics, we know a value is set.\n+            return v;\n+        }\n+        if (state == NULL) {\n+            return null;\n+        }\n+        \/\/ Now, fall back to volatile semantics.\n+        return computeIfUnsetVolatile(provider, key);\n+    }\n+\n+    @DontInline\n+    private <K> V computeIfUnsetVolatile(Object provider, K key) {\n+        \/\/ This is intentionally an old switch statement as it generates\n+        \/\/ more compact byte code.\n+        switch (stateVolatile()) {\n+            case UNSET:    { return computeIfUnsetVolatile0(provider, key); }\n+            case NON_NULL: { return valueVolatile(); }\n+            case NULL:     { return null; }\n+            case ERROR:    { throw StableUtil.error(this); }\n+        }\n+        throw shouldNotReachHere();\n+    }\n+\n+    private <K> V computeIfUnsetVolatile0(Object provider, K key) {\n+        final var m = acquireMutex();\n+        if (isMutexNotNeeded(m)) {\n+            return orThrow();\n+        }\n+        synchronized (m) {\n+            if (state != UNSET) {\n+                return orThrow();\n+            }\n+\n+            \/\/ A value is not set\n+            if (supplying) {\n+                throw stackOverflow(provider, key);\n+            }\n+            try {\n+                supplying = true;\n+                try {\n+                    @SuppressWarnings(\"unchecked\")\n+                    V newValue = switch (provider) {\n+                        case Supplier<?> sup     -> (V) sup.get();\n+                        case IntFunction<?> iFun -> (V) iFun.apply((int) key);\n+                        case Function<?, ?> func -> ((Function<K, V>) func).apply(key);\n+                        default                  -> throw shouldNotReachHere();\n+                    };\n+                    setValue(newValue);\n+                    return newValue;\n+                } catch (Throwable t) {\n+                    putState(ERROR);\n+                    putMutex(t.getClass());\n+                    throw t;\n+                }\n+            } finally {\n+                supplying = false;\n+            }\n+        }\n+    }\n+\n@@ -309,1 +386,1 @@\n-    public static <V> StableValue<V> of() {\n+    public static <V> StableValueImpl<V> of() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"}]}