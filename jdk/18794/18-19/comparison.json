{"files":[{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring memoized Function performance\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class MemoizedFunctionBenchmark {\n+\n+    private static final int ITERATIONS = 17;\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final Map<Integer, Integer> VALUES = Map.of(0, VALUE, 1, VALUE2);\n+\n+    private static final Function<Integer, Integer> F = VALUES::get;\n+    private final Function<Integer, Integer> f = VALUES::get;\n+\n+    private final Function<Integer, Integer> m = StableValue.memoizedFunction(Set.of(0, 1), VALUES::get);\n+    private static final Function<Integer, Integer> M = StableValue.memoizedFunction(Set.of(0, 1), VALUES::get);;\n+\n+    @Benchmark\n+    public int function() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += f.apply(0) + f.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int memoized() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += m.apply(0) + m.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += F.apply(0) + F.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sMemoized() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += M.apply(0) + M.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/MemoizedFunctionBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring memoized IntFunction performance\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class MemoizedIntFunctionBenchmark {\n+\n+    private static final int ITERATIONS = 17;\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final List<Integer> VALUES = List.of(VALUE, VALUE2);\n+\n+    private static final IntFunction<Integer> F = VALUES::get;\n+    private final IntFunction<Integer> f = VALUES::get;\n+\n+    private final IntFunction<Integer> m = StableValue.memoizedIntFunction(2, VALUES::get);\n+    private static final IntFunction<Integer> M = StableValue.memoizedIntFunction(2, VALUES::get);;\n+\n+    @Benchmark\n+    public int intFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += f.apply(0) + f.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int memoized() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += m.apply(0) + m.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += F.apply(0) + F.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sMemoized() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += M.apply(0) + M.apply(1);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/MemoizedIntFunctionBenchmark.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.StableValue;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring memoized supplier performance\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.lang=ALL-UNNAMED\", \"--enable-preview\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class MemoizedSupplierBenchmark {\n+\n+    private static final int ITERATIONS = 17;\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final Supplier<Integer> S = () -> VALUE;\n+    private static final Supplier<Integer> S2 = () -> VALUE2;\n+\n+    private final Supplier<Integer> m = StableValue.memoizedSupplier(S);\n+    private final Supplier<Integer> m2 = StableValue.memoizedSupplier(S2);\n+    private final Supplier<Integer> dcl = new Dcl<>(S);\n+    private final Supplier<Integer> dcl2 = new Dcl<>(S);\n+\n+    private static final Supplier<Integer> M = StableValue.memoizedSupplier(S);\n+    private static final Supplier<Integer> M2 = StableValue.memoizedSupplier(S2);\n+    private static final Supplier<Integer> DCL = new Dcl<>(S);\n+    private static final Supplier<Integer> DCL2 = new Dcl<>(S);\n+\n+    @Benchmark\n+    public int dcl() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += dcl.get() + dcl2.get();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int memoized() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += m.get() + m2.get();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sSupplier() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += S.get() + S2.get();\n+        }\n+        return sum;\n+    }\n+\n+\n+    @Benchmark\n+    public int sDcl() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += DCL.get() + DCL2.get();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sMemoized() {\n+        int sum = 0;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            sum += M.get() + M2.get();\n+        }\n+        return sum;\n+    }\n+\n+\n+    \/\/ Handles null values\n+    private static class Dcl<V> implements Supplier<V> {\n+\n+        private final Supplier<V> supplier;\n+\n+        private volatile V value;\n+        private boolean bound;\n+\n+        public Dcl(Supplier<V> supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        @Override\n+        public V get() {\n+            V v = value;\n+            if (v == null) {\n+                if (!bound) {\n+                    synchronized (this) {\n+                        v = value;\n+                        if (v == null) {\n+                            if (!bound) {\n+                                value = v = supplier.get();\n+                                bound = true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/MemoizedSupplierBenchmark.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"}]}