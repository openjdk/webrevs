{"files":[{"patch":"@@ -147,2 +147,0 @@\n-     * \/\/ Todo: Should we wrap supplier exceptions into a specific exception type?\n-     *\n@@ -387,1 +385,1 @@\n-        return StableAccess.ofSupplier(stable, original);\n+        return StableAccess.memoizedSupplier(stable, original);\n@@ -413,1 +411,1 @@\n-        return StableAccess.ofIntFunction(stableList, original);\n+        return StableAccess.memoizedIntFunction(stableList, original);\n@@ -439,1 +437,1 @@\n-        return StableAccess.ofFunction(stableMap, original);\n+        return StableAccess.memoizedFunction(stableMap, original);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/StableValue.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import static jdk.internal.misc.Unsafe.*;\n-\n@@ -46,0 +44,2 @@\n+    \/\/ State values\n+\n@@ -49,1 +49,1 @@\n-    static final byte NULL = 1;\n+    static final byte SET_NULL = 1;\n@@ -51,1 +51,1 @@\n-    static final byte NON_NULL = 2; \/\/ The middle value\n+    static final byte SET_NON_NULL = 2; \/\/ The middle value\n@@ -57,0 +57,4 @@\n+    \/\/ Computation values\n+\n+    \/\/ Indicates a computation operation has NOT been invoked.\n+    static final byte NOT_INVOKED = 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+     *\n@@ -60,2 +61,2 @@\n-     * If TOMBSTONE , we do not need synchronization anymore (isSet() && isError() = true)\n-     * if instanceof Throwable , records a previous error and, we do not need synchronization anymore\n+     * If TOMBSTONE , we do not need synchronization anymore (isSet() == true)\n+     * if instanceof Throwable , records a previous throwable class and, we do not need synchronization anymore\n@@ -67,0 +68,2 @@\n+     * The set value for this stable value\n+     *\n@@ -74,3 +77,6 @@\n-     * If StableUtil.NOT_SET  , a value is not set\n-     * If StableUtil.NON_NULL , a non-null value is set\n-     * If StableUtil.NULL     , a `null` value is set\n+     * Records the state of this stable value.\n+     *\n+     * If StableUtil.NOT_SET      , a value is not set\n+     * If StableUtil.SET_NON_NULL , a non-null value is set\n+     * If StableUtil.SET_NULL     , a `null` value is set\n+     * If StableUtil.ERROR        , a throwable was thrown during computation\n@@ -84,2 +90,3 @@\n-     * 0                  , not invoked\n-     * StableUtil.INVOKED , invoked\n+     *\n+     * StableUtil.NOT_INVOKED (0) , not invoked\n+     * StableUtil.INVOKED     (1) , invoked\n@@ -96,2 +103,2 @@\n-        return (s = state) == NON_NULL || s == NULL ||\n-                (s = stateVolatile()) == NON_NULL || s == NULL;\n+        return (s = state) == SET_NON_NULL || s == SET_NULL ||\n+                (s = stateVolatile()) == SET_NON_NULL || s == SET_NULL;\n@@ -116,1 +123,1 @@\n-        if (state == NULL) {\n+        if (state == SET_NULL) {\n@@ -123,12 +130,0 @@\n-\n-\/*        \/\/ This is intentionally an old switch statement as it generates\n-        \/\/ more compact byte code.\n-        switch (state) {\n-            case UNSET:    { throw StableUtil.notSet(); }\n-            case NULL:     { return null; }\n-            case NON_NULL: { return value; }\n-            case ERROR:    { throw StableUtil.error(this); }\n-            case DUMMY:    { throw shouldNotReachHere(); }\n-        }\n-        throw shouldNotReachHere();*\/\n-\n@@ -142,5 +137,5 @@\n-            case UNSET:    { throw StableUtil.notSet(); }\n-            case NULL:     { return null; }\n-            case NON_NULL: { return valueVolatile(); }\n-            case ERROR:    { throw StableUtil.error(this); }\n-            case DUMMY:    { throw shouldNotReachHere(); }\n+            case UNSET:        { throw notSet(); }\n+            case SET_NULL:     { return null; }\n+            case SET_NON_NULL: { return valueVolatile(); }\n+            case ERROR:        { throw error(this); }\n+            case DUMMY:        { throw shouldNotReachHere(); }\n@@ -214,1 +209,1 @@\n-        if (state == NULL) {\n+        if (state == SET_NULL) {\n@@ -226,4 +221,4 @@\n-            case UNSET:    { return computeIfUnsetVolatile0(provider, key); }\n-            case NON_NULL: { return valueVolatile(); }\n-            case NULL:     { return null; }\n-            case ERROR:    { throw StableUtil.error(this); }\n+            case UNSET:        { return computeIfUnsetVolatile0(provider, key); }\n+            case SET_NON_NULL: { return valueVolatile(); }\n+            case SET_NULL:     { return null; }\n+            case ERROR:        { throw error(this); }\n@@ -244,1 +239,1 @@\n-            if (!UNSAFE.compareAndSetByte(this, COMPUTE_INVOKED_OFFSET, (byte) 0, INVOKED)) {\n+            if (!UNSAFE.compareAndSetByte(this, COMPUTE_INVOKED_OFFSET, NOT_INVOKED, INVOKED)) {\n@@ -291,1 +286,1 @@\n-        putState(value == null ? NULL : NON_NULL);\n+        putState(value == null ? SET_NULL : SET_NON_NULL);\n@@ -338,1 +333,0 @@\n-        final StableValue<V> stable = StableValue.of();\n@@ -340,0 +334,1 @@\n+        final StableValue<V> stable = StableValue.of();\n@@ -342,3 +337,1 @@\n-            volatile Thread thread;\n-\n-            @Override\n+           @Override\n@@ -352,3 +345,1 @@\n-        final BgRunnable runnable = new BgRunnable();\n-        Thread bgThread = threadFactory.newThread(runnable);\n-        runnable.thread = bgThread;\n+        Thread bgThread = threadFactory.newThread(new BgRunnable());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":32,"deletions":41,"binary":false,"changes":73,"status":"modified"}]}