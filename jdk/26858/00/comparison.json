{"files":[{"patch":"@@ -584,0 +584,1 @@\n+    ObjectWaiter node(current);\n@@ -585,0 +586,3 @@\n+      enter_internal(current, &node);\n+      current->set_current_pending_monitor(nullptr);\n+\n@@ -588,2 +592,0 @@\n-        enter_internal(current);\n-        current->set_current_pending_monitor(nullptr);\n@@ -931,8 +933,7 @@\n-void ObjectMonitor::enter_internal(JavaThread* current) {\n-  assert(current->thread_state() == _thread_blocked, \"invariant\");\n-\n-  \/\/ Try the lock - TATAS\n-  if (try_lock(current) == TryLockResult::Success) {\n-    assert(!has_successor(current), \"invariant\");\n-    assert(has_owner(current), \"invariant\");\n-    return;\n+void ObjectMonitor::enter_internal(JavaThread* current, ObjectWaiter* current_node, bool do_reenter) {\n+  assert(current != nullptr, \"invariant\");\n+  assert(current_node != nullptr, \"invariant\");\n+  assert(current_node->_thread == current, \"invariant\");\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  if (do_reenter) {\n+    assert(_waiters > 0, \"invariant\");\n@@ -940,0 +941,1 @@\n+  assert_mark_word_consistency();\n@@ -941,1 +943,4 @@\n-  assert(InitDone, \"Unexpectedly not initialized\");\n+  if (!do_reenter) {\n+    \/\/ This is the fast track only allowed for the initial entrance to the monitor.\n+    \/\/ If a thread is re-entering it, it is already on the entry_list and has the\n+    \/\/ waiter's state is TS_ENTER.\n@@ -943,6 +948,6 @@\n-  \/\/ We try one round of spinning *before* enqueueing current.\n-  \/\/\n-  \/\/ If the _owner is ready but OFFPROC we could use a YieldTo()\n-  \/\/ operation to donate the remainder of this thread's quantum\n-  \/\/ to the owner.  This has subtle but beneficial affinity\n-  \/\/ effects.\n+    \/\/ Try the lock - TATAS\n+    if (try_lock(current) == TryLockResult::Success) {\n+      assert(!has_successor(current), \"invariant\");\n+      assert(has_owner(current), \"invariant\");\n+      return;\n+    }\n@@ -950,5 +955,1 @@\n-  if (try_spin(current)) {\n-    assert(has_owner(current), \"invariant\");\n-    assert(!has_successor(current), \"invariant\");\n-    return;\n-  }\n+    assert(InitDone, \"Unexpectedly not initialized\");\n@@ -956,3 +957,6 @@\n-  \/\/ The Spin failed -- Enqueue and park the thread ...\n-  assert(!has_successor(current), \"invariant\");\n-  assert(!has_owner(current), \"invariant\");\n+    \/\/ We try one round of spinning *before* enqueueing current.\n+    \/\/\n+    \/\/ If the _owner is ready but OFFPROC we could use a YieldTo()\n+    \/\/ operation to donate the remainder of this thread's quantum\n+    \/\/ to the owner.  This has subtle but beneficial affinity\n+    \/\/ effects.\n@@ -960,8 +964,5 @@\n-  \/\/ Enqueue \"current\" on ObjectMonitor's _entry_list.\n-  \/\/\n-  \/\/ Node acts as a proxy for current.\n-  \/\/ As an aside, if were to ever rewrite the synchronization code mostly\n-  \/\/ in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class\n-  \/\/ Java objects.  This would avoid awkward lifecycle and liveness issues,\n-  \/\/ as well as eliminate a subset of ABA issues.\n-  \/\/ TODO: eliminate ObjectWaiter and enqueue either Threads or Events.\n+    if (try_spin(current)) {\n+      assert(has_owner(current), \"invariant\");\n+      assert(!has_successor(current), \"invariant\");\n+      return;\n+    }\n@@ -969,2 +970,12 @@\n-  ObjectWaiter node(current);\n-  current->_ParkEvent->reset();\n+    \/\/ The Spin failed -- Enqueue and park the thread ...\n+    assert(!has_successor(current), \"invariant\");\n+    assert(!has_owner(current), \"invariant\");\n+\n+    \/\/ Enqueue \"current\" on ObjectMonitor's _entry_list.\n+    \/\/\n+    \/\/ Node acts as a proxy for current.\n+    \/\/ As an aside, if were to ever rewrite the synchronization code mostly\n+    \/\/ in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class\n+    \/\/ Java objects.  This would avoid awkward lifecycle and liveness issues,\n+    \/\/ as well as eliminate a subset of ABA issues.\n+    \/\/ TODO: eliminate ObjectWaiter and enqueue either Threads or Events.\n@@ -972,2 +983,6 @@\n-  if (try_lock_or_add_to_entry_list(current, &node)) {\n-    return; \/\/ We got the lock.\n+    current->_ParkEvent->reset();\n+\n+    if (try_lock_or_add_to_entry_list(current, current_node)) {\n+      return; \/\/ We got the lock.\n+    }\n+    \/\/ This thread is now added to the _entry_list.\n@@ -975,1 +990,0 @@\n-  \/\/ This thread is now added to the _entry_list.\n@@ -1007,0 +1021,1 @@\n+\n@@ -1008,0 +1023,4 @@\n+    {\n+      OSThreadContendState osts(current->osthread());\n+\n+      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n@@ -1009,7 +1028,18 @@\n-    \/\/ park self\n-    if (do_timed_parked) {\n-      current->_ParkEvent->park((jlong) recheck_interval);\n-      \/\/ Increase the recheck_interval, but clamp the value.\n-      recheck_interval *= 8;\n-      if (recheck_interval > MAX_RECHECK_INTERVAL) {\n-        recheck_interval = MAX_RECHECK_INTERVAL;\n+      ClearSuccOnSuspend csos(this);\n+      {\n+        \/\/ Suspension is not allowed on the initial entrance to the monitor, because it may lead to a deadlock:\n+        \/\/ If the entering thread is suspended after being unparked, and the resumer thread is parked, there\n+        \/\/ will be no progress, as the entering thread cannot exit the monitor and wake up the resumer thread.\n+        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, do_reenter \/* allow_suspend *\/);\n+        \/\/ park self\n+        if (do_timed_parked) {\n+          current->_ParkEvent->park((jlong)recheck_interval);\n+          \/\/ Increase the recheck_interval, but clamp the value.\n+          recheck_interval *= 8;\n+          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+            recheck_interval = MAX_RECHECK_INTERVAL;\n+          }\n+        }\n+        else {\n+          current->_ParkEvent->park();\n+        }\n@@ -1017,2 +1047,1 @@\n-    } else {\n-      current->_ParkEvent->park();\n+\n@@ -1049,1 +1078,3 @@\n-  unlink_after_acquire(current, &node);\n+  assert(has_owner(current), \"invariant\");\n+  assert_mark_word_consistency();\n+  unlink_after_acquire(current, current_node);\n@@ -1077,62 +1108,3 @@\n-\n-  return;\n-}\n-\n-\/\/ reenter_internal() is a specialized inline form of the latter half of the\n-\/\/ contended slow-path from enter_internal().  We use reenter_internal() only for\n-\/\/ monitor reentry in wait().\n-\/\/\n-\/\/ In the future we should reconcile enter_internal() and reenter_internal().\n-\n-void ObjectMonitor::reenter_internal(JavaThread* current, ObjectWaiter* currentNode) {\n-  assert(current != nullptr, \"invariant\");\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n-  assert(currentNode != nullptr, \"invariant\");\n-  assert(currentNode->_thread == current, \"invariant\");\n-  assert(_waiters > 0, \"invariant\");\n-  assert_mark_word_consistency();\n-\n-  for (;;) {\n-    ObjectWaiter::TStates v = currentNode->TState;\n-    guarantee(v == ObjectWaiter::TS_ENTER, \"invariant\");\n-    assert(!has_owner(current), \"invariant\");\n-\n-    \/\/ This thread has been notified so try to reacquire the lock.\n-    if (try_lock(current) == TryLockResult::Success) {\n-      break;\n-    }\n-\n-    \/\/ If that fails, spin again.  Note that spin count may be zero so the above TryLock\n-    \/\/ is necessary.\n-    if (try_spin(current)) {\n-        break;\n-    }\n-\n-    {\n-      OSThreadContendState osts(current->osthread());\n-\n-      assert(current->thread_state() == _thread_in_vm, \"invariant\");\n-\n-      {\n-        ClearSuccOnSuspend csos(this);\n-        ThreadBlockInVMPreprocess<ClearSuccOnSuspend> tbivs(current, csos, true \/* allow_suspend *\/);\n-        current->_ParkEvent->park();\n-      }\n-    }\n-\n-    \/\/ Try again, but just so we distinguish between futile wakeups and\n-    \/\/ successful wakeups.  The following test isn't algorithmically\n-    \/\/ necessary, but it helps us maintain sensible statistics.\n-    if (try_lock(current) == TryLockResult::Success) {\n-      break;\n-    }\n-\n-    \/\/ The lock is still contested.\n-\n-    \/\/ Assuming this is not a spurious wakeup we'll normally\n-    \/\/ find that _succ == current.\n-    if (has_successor(current)) clear_successor();\n-\n-    \/\/ Invariant: after clearing _succ a contending thread\n-    \/\/ *must* retry  _owner before parking.\n-    OrderAccess::fence();\n+  if (do_reenter) {\n+    current_node->TState = ObjectWaiter::TS_RUN;\n+    OrderAccess::fence();      \/\/ see comments above\n@@ -1141,8 +1113,1 @@\n-  \/\/ Current has acquired the lock -- Unlink current from the _entry_list.\n-  assert(has_owner(current), \"invariant\");\n-  assert_mark_word_consistency();\n-  unlink_after_acquire(current, currentNode);\n-  if (has_successor(current)) clear_successor();\n-  assert(!has_successor(current), \"invariant\");\n-  currentNode->TState = ObjectWaiter::TS_RUN;\n-  OrderAccess::fence();      \/\/ see comments at the end of enter_internal()\n+  return;\n@@ -1938,1 +1903,1 @@\n-      reenter_internal(current, &node);\n+      enter_internal(current, &node, true);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":84,"deletions":119,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -404,2 +404,1 @@\n-  void      enter_internal(JavaThread* current);\n-  void      reenter_internal(JavaThread* current, ObjectWaiter* current_node);\n+  void      enter_internal(JavaThread* current, ObjectWaiter* current_node, bool do_reenter = false);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}