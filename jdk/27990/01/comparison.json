{"files":[{"patch":"@@ -119,3 +119,2 @@\n-#if defined(IA32) || defined(AMD64) || defined(ARM) || \\\n-    defined(AARCH64) || defined(PPC) || defined(RISCV) || \\\n-    defined(S390)\n+#if defined(AMD64) || defined(ARM) || defined(AARCH64) || \\\n+    defined(PPC) || defined(RISCV) || defined(S390)\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -234,2 +234,0 @@\n-#elif defined(IA32)\n-static char cpu_arch[] = \"i386\";\n@@ -1014,1 +1012,0 @@\n-#ifndef IA32\n@@ -1037,4 +1034,0 @@\n-  \/\/ This workaround is ineffective on IA32 systems because the MXCSR\n-  \/\/ register (which controls flush-to-zero mode) is not stored in the\n-  \/\/ legacy fenv.\n-\n@@ -1044,1 +1037,0 @@\n-#endif \/\/ IA32\n@@ -1064,1 +1056,0 @@\n-#ifndef IA32\n@@ -1089,1 +1080,0 @@\n-#endif \/\/ IA32\n@@ -1198,3 +1188,1 @@\n-  #if  (defined IA32)\n-  static  Elf32_Half running_arch_code=EM_386;\n-  #elif   (defined AMD64)\n+  #if    (defined AMD64)\n@@ -1222,1 +1210,1 @@\n-         IA32, AMD64, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n+         AMD64, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1798,3 +1798,1 @@\n-#if  (defined IA32)\n-  static  Elf32_Half running_arch_code=EM_386;\n-#elif   (defined AMD64) || (defined X32)\n+#if    (defined AMD64)\n@@ -1834,1 +1832,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -1896,1 +1894,0 @@\n-#ifndef IA32\n@@ -1919,4 +1916,0 @@\n-  \/\/ This workaround is ineffective on IA32 systems because the MXCSR\n-  \/\/ register (which controls flush-to-zero mode) is not stored in the\n-  \/\/ legacy fenv.\n-\n@@ -1926,1 +1919,0 @@\n-#endif \/\/ IA32\n@@ -1946,1 +1938,0 @@\n-#ifndef IA32\n@@ -1972,1 +1963,0 @@\n-#endif \/\/ IA32\n@@ -2616,1 +2606,1 @@\n-#if defined(IA32) || defined(AMD64)\n+#if defined(AMD64)\n@@ -2675,1 +2665,1 @@\n-#if defined(IA32) || defined(AMD64)\n+#if defined(AMD64)\n@@ -2728,1 +2718,1 @@\n-#if defined(AMD64) || defined(IA32) || defined(X32)\n+#if defined(AMD64)\n@@ -2781,2 +2771,0 @@\n-#elif defined(IA32)\n-  strncpy(cpuinfo, \"x86_32\", length);\n@@ -3082,8 +3070,3 @@\n-#if defined(IA32)\n-  #ifndef SYS_getcpu\n-    #define SYS_getcpu 318\n-  #endif\n-  retval = syscall(SYS_getcpu, &cpu, nullptr, nullptr);\n-#elif defined(AMD64)\n-\/\/ Unfortunately we have to bring all these macros here from vsyscall.h\n-\/\/ to be able to compile on old linuxes.\n+#if defined(AMD64)\n+  \/\/ Unfortunately we have to bring all these macros here from vsyscall.h\n+  \/\/ to be able to compile on old linuxes.\n@@ -4462,81 +4445,0 @@\n-#if defined(IA32) && !defined(ZERO)\n-\/*\n- * Work-around (execute code at a high address) for broken NX emulation using CS limit,\n- * Red Hat patch \"Exec-Shield\" (IA32 only).\n- *\n- * Map and execute at a high VA to prevent CS lazy updates race with SMP MM\n- * invalidation.Further code generation by the JVM will no longer cause CS limit\n- * updates.\n- *\n- * Affects IA32: RHEL 5 & 6, Ubuntu 10.04 (LTS), 10.10, 11.04, 11.10, 12.04.\n- * @see JDK-8023956\n- *\/\n-static void workaround_expand_exec_shield_cs_limit() {\n-  assert(os::Linux::initial_thread_stack_bottom() != nullptr, \"sanity\");\n-  size_t page_size = os::vm_page_size();\n-\n-  \/*\n-   * JDK-8197429\n-   *\n-   * Expand the stack mapping to the end of the initial stack before\n-   * attempting to install the codebuf.  This is needed because newer\n-   * Linux kernels impose a distance of a megabyte between stack\n-   * memory and other memory regions.  If we try to install the\n-   * codebuf before expanding the stack the installation will appear\n-   * to succeed but we'll get a segfault later if we expand the stack\n-   * in Java code.\n-   *\n-   *\/\n-  if (os::is_primordial_thread()) {\n-    address limit = os::Linux::initial_thread_stack_bottom();\n-    if (! DisablePrimordialThreadGuardPages) {\n-      limit += StackOverflow::stack_red_zone_size() +\n-               StackOverflow::stack_yellow_zone_size();\n-    }\n-    os::Linux::expand_stack_to(limit);\n-  }\n-\n-  \/*\n-   * Take the highest VA the OS will give us and exec\n-   *\n-   * Although using -(pagesz) as mmap hint works on newer kernel as you would\n-   * think, older variants affected by this work-around don't (search forward only).\n-   *\n-   * On the affected distributions, we understand the memory layout to be:\n-   *\n-   *   TASK_LIMIT= 3G, main stack base close to TASK_LIMT.\n-   *\n-   * A few pages south main stack will do it.\n-   *\n-   * If we are embedded in an app other than launcher (initial != main stack),\n-   * we don't have much control or understanding of the address space, just let it slide.\n-   *\/\n-  char* hint = (char*)(os::Linux::initial_thread_stack_bottom() -\n-                       (StackOverflow::stack_guard_zone_size() + page_size));\n-  char* codebuf = os::attempt_reserve_memory_at(hint, page_size, mtThread);\n-\n-  if (codebuf == nullptr) {\n-    \/\/ JDK-8197429: There may be a stack gap of one megabyte between\n-    \/\/ the limit of the stack and the nearest memory region: this is a\n-    \/\/ Linux kernel workaround for CVE-2017-1000364.  If we failed to\n-    \/\/ map our codebuf, try again at an address one megabyte lower.\n-    hint -= 1 * M;\n-    codebuf = os::attempt_reserve_memory_at(hint, page_size, mtThread);\n-  }\n-\n-  if ((codebuf == nullptr) || (!os::commit_memory(codebuf, page_size, true))) {\n-    return; \/\/ No matter, we tried, best effort.\n-  }\n-\n-  log_info(os)(\"[CS limit NX emulation work-around, exec code at: %p]\", codebuf);\n-\n-  \/\/ Some code to exec: the 'ret' instruction\n-  codebuf[0] = 0xC3;\n-\n-  \/\/ Call the code in the codebuf\n-  __asm__ volatile(\"call *%0\" : : \"r\"(codebuf));\n-\n-  \/\/ keep the page mapped so CS limit isn't reduced.\n-}\n-#endif \/\/ defined(IA32) && !defined(ZERO)\n-\n@@ -4563,6 +4465,0 @@\n-#if defined(IA32) && !defined(ZERO)\n-  \/\/ Need to ensure we've determined the process's initial stack to\n-  \/\/ perform the workaround\n-  Linux::capture_initial_stack(JavaThread::stack_size_at_create());\n-  workaround_expand_exec_shield_cs_limit();\n-#else\n@@ -4573,1 +4469,0 @@\n-#endif\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":8,"deletions":113,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -3153,1 +3153,0 @@\n-#if !defined(IA32)\n@@ -3162,1 +3161,0 @@\n-#endif\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,3 +89,1 @@\n-#if defined(IA32)\n-    return (address)uc->uc_mcontext.gregs[REG_EIP];\n-#elif defined(AMD64)\n+#if defined(AMD64)\n@@ -120,3 +118,1 @@\n-#if defined(IA32)\n-    return (intptr_t*)uc->uc_mcontext.gregs[REG_UESP];\n-#elif defined(AMD64)\n+#if defined(AMD64)\n@@ -147,3 +143,1 @@\n-#if defined(IA32)\n-    return (intptr_t*)uc->uc_mcontext.gregs[REG_EBP];\n-#elif defined(AMD64)\n+#if defined(AMD64)\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2326,1 +2326,1 @@\n-#if defined(IA32) || defined(AMD64)\n+#if defined(AMD64)\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    NOT_IA32( ShouldNotReachHere(); ) \/\/ used only on x86-32\n+    ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -530,10 +530,0 @@\n-#ifdef IA32\n-    case lir_fxch:\n-      fxch(op->in_opr()->as_jint());\n-      break;\n-\n-    case lir_fld:\n-      fld(op->in_opr()->as_jint());\n-      break;\n-#endif \/\/ IA32\n-\n@@ -615,6 +605,0 @@\n-#ifdef IA32\n-    case lir_fpop_raw:\n-      fpop();\n-      break;\n-#endif \/\/ IA32\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64 || defined RISCV64)\n+#if !(defined AARCH64 || defined AMD64 || defined PPC64 || defined RISCV64)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64 || defined RISCV64)\n+#if !(defined AARCH64 || defined AMD64 || defined PPC64 || defined RISCV64)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-#if !defined(ZERO) && (defined(IA32) || defined(AMD64))\n+#if !defined(ZERO) && defined(AMD64)\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1462,1 +1462,1 @@\n-#if defined(IA32) || defined(AMD64) || defined(ARM)\n+#if defined(AMD64) || defined(ARM)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,2 +149,2 @@\n-#if defined(IA32) || defined(AMD64) || defined(ARM)\n-  \/\/ Popframe support (only needed on x86, AMD64 and ARM)\n+#if defined(AMD64) || defined(ARM)\n+  \/\/ Popframe support (only needed on AMD64 and ARM)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-#if defined(IA32) || defined(AMD64) || defined(PPC) || defined(S390)\n+#if defined(AMD64) || defined(PPC) || defined(S390)\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrBigEndian.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -978,1 +978,0 @@\n-          \/\/ IA32     2     1     1          1    1          6           6\n@@ -994,6 +993,0 @@\n-#elif defined(IA32)\n-          if( ireg == Op_RegL ) {\n-            lrg.set_reg_pressure(2);\n-          } else {\n-            lrg.set_reg_pressure(1);\n-          }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -941,3 +941,0 @@\n-  \/\/ IA32 would only execute this for non-strict FP, which is never the\n-  \/\/ case now.\n-#if ! defined(IA32)\n@@ -949,1 +946,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-#if defined(IA32) || defined(AMD64)\n+#if defined(AMD64)\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,8 +205,0 @@\n-#if defined(IA32)\n-  \/\/ Can't trust native compilers to properly fold strict double\n-  \/\/ multiplication with round-to-zero on this platform.\n-  if (op == Op_MulD) {\n-    return TypeD::DOUBLE;\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -207,1 +207,0 @@\n-                 IA32_ONLY(\"x86\")                \\\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -667,1 +667,0 @@\n-  IA32_ONLY(   tty->print_cr(\"                   pns($sp, $ebp, $pc) on Linux\/x86\"));\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-#if defined(IA32) || defined(AMD64)\n+#if defined(AMD64)\n@@ -465,8 +465,0 @@\n-#ifdef IA32\n-#define IA32_ONLY(code) code\n-#define NOT_IA32(code)\n-#else\n-#define IA32_ONLY(code)\n-#define NOT_IA32(code) code\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -759,1 +759,0 @@\n-#if !defined(IA32)\n@@ -776,1 +775,0 @@\n-#endif\n@@ -812,1 +810,1 @@\n-#if defined(IA32) || defined(AMD64)\n+#if defined(AMD64)\n@@ -816,1 +814,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n+    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 for large pages bigger than 4mb on AMD64\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}