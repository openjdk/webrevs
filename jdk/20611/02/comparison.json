{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n@@ -167,1 +168,1 @@\n-               ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n+               ? forPrimitiveType(descriptor, 0)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    public static final ClassDesc CD_int = new PrimitiveClassDescImpl(\"I\");\n+    public static final ClassDesc CD_int = PrimitiveClassDescImpl.CD_int;\n@@ -246,1 +246,1 @@\n-    public static final ClassDesc CD_long = new PrimitiveClassDescImpl(\"J\");\n+    public static final ClassDesc CD_long = PrimitiveClassDescImpl.CD_long;\n@@ -249,1 +249,1 @@\n-    public static final ClassDesc CD_float = new PrimitiveClassDescImpl(\"F\");\n+    public static final ClassDesc CD_float = PrimitiveClassDescImpl.CD_float;\n@@ -252,1 +252,1 @@\n-    public static final ClassDesc CD_double = new PrimitiveClassDescImpl(\"D\");\n+    public static final ClassDesc CD_double = PrimitiveClassDescImpl.CD_double;\n@@ -255,1 +255,1 @@\n-    public static final ClassDesc CD_short = new PrimitiveClassDescImpl(\"S\");\n+    public static final ClassDesc CD_short = PrimitiveClassDescImpl.CD_short;\n@@ -258,1 +258,1 @@\n-    public static final ClassDesc CD_byte = new PrimitiveClassDescImpl(\"B\");\n+    public static final ClassDesc CD_byte = PrimitiveClassDescImpl.CD_byte;\n@@ -261,1 +261,1 @@\n-    public static final ClassDesc CD_char = new PrimitiveClassDescImpl(\"C\");\n+    public static final ClassDesc CD_char = PrimitiveClassDescImpl.CD_char;\n@@ -264,1 +264,1 @@\n-    public static final ClassDesc CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+    public static final ClassDesc CD_boolean = PrimitiveClassDescImpl.CD_boolean;\n@@ -267,1 +267,1 @@\n-    public static final ClassDesc CD_void = new PrimitiveClassDescImpl(\"V\");\n+    public static final ClassDesc CD_void = PrimitiveClassDescImpl.CD_void;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -115,1 +116,1 @@\n-        return Wrapper.forPrimitiveType(name.charAt(0)).primitiveType();\n+        return ConstantUtils.forPrimitiveType(name, 0).resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import static jdk.internal.constant.PrimitiveClassDescImpl.*;\n+\n@@ -272,33 +274,13 @@\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    public static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/ placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(resolveClassDesc(descriptor, cur, len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n-        return ptypes;\n+    public static PrimitiveClassDescImpl forPrimitiveType(String descriptor, int offset) {\n+        return switch (descriptor.charAt(offset)) {\n+            case JVM_SIGNATURE_BYTE    -> CD_byte;\n+            case JVM_SIGNATURE_CHAR    -> CD_char;\n+            case JVM_SIGNATURE_FLOAT   -> CD_float;\n+            case JVM_SIGNATURE_DOUBLE  -> CD_double;\n+            case JVM_SIGNATURE_INT     -> CD_int;\n+            case JVM_SIGNATURE_LONG    -> CD_long;\n+            case JVM_SIGNATURE_SHORT   -> CD_short;\n+            case JVM_SIGNATURE_VOID    -> CD_void;\n+            case JVM_SIGNATURE_BOOLEAN -> CD_boolean;\n+            default -> throw badMethodDescriptor(descriptor);\n+        };\n@@ -307,1 +289,1 @@\n-    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+    static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n@@ -309,1 +291,1 @@\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).basicClassDescriptor();\n+            return forPrimitiveType(descriptor, start);\n@@ -311,1 +293,2 @@\n-        \/\/ Pre-verified in parseMethodDescriptor; avoid redundant verification\n+\n+        \/\/ Pre-verified in MethodTypeDescImpl#ofDescriptor; avoid redundant verification\n@@ -315,0 +298,4 @@\n+    static IllegalArgumentException badMethodDescriptor(String descriptor) {\n+        return new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -319,2 +306,0 @@\n-    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n-    private static final char JVM_SIGNATURE_ENUM = 'E';\n@@ -323,2 +308,0 @@\n-    private static final char JVM_SIGNATURE_FUNC = '(';\n-    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n@@ -337,1 +320,0 @@\n-     * @param voidOK is void acceptable?\n@@ -341,2 +323,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n+    static int skipOverFieldSignature(String descriptor, int start, int end) {\n@@ -345,3 +326,10 @@\n-        while (index < end) {\n-            switch (descriptor.charAt(index)) {\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n+        if (index < end) {\n+            char ch;\n+            while ((ch = descriptor.charAt(index++)) == JVM_SIGNATURE_ARRAY) {\n+                arrayDim++;\n+            }\n+            if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                throw maxArrayTypeDescDimensions();\n+            }\n+\n+            switch (ch) {\n@@ -356,1 +344,1 @@\n-                    return index - start + 1;\n+                    return index - start;\n@@ -361,2 +349,2 @@\n-                    while (++index < end) {\n-                        switch (descriptor.charAt(index)) {\n+                    while (index < end) {\n+                        switch (descriptor.charAt(index++)) {\n@@ -365,1 +353,1 @@\n-                                return legal ? index - start + 1 : 0;\n+                                return legal ? index - start : 0;\n@@ -380,10 +368,0 @@\n-                    return 0;\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    voidOK = false;\n@@ -392,1 +370,1 @@\n-                    return 0;\n+                    break;\n@@ -397,0 +375,6 @@\n+\n+    private static IllegalArgumentException maxArrayTypeDescDimensions() {\n+        return new IllegalArgumentException(String.format(\n+                        \"Cannot create an array type descriptor with more than %d dimensions\",\n+                        ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":45,"deletions":61,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -35,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -41,0 +44,6 @@\n+import static jdk.internal.constant.ConstantUtils.badMethodDescriptor;\n+import static jdk.internal.constant.ConstantUtils.resolveClassDesc;\n+import static jdk.internal.constant.ConstantUtils.skipOverFieldSignature;\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CLASSDESC;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n+\n@@ -94,1 +103,1 @@\n-            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n+            return new MethodTypeDescImpl(returnType, EMPTY_CLASSDESC);\n@@ -108,8 +117,17 @@\n-        \/\/ Implicit null-check of descriptor\n-        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n-        int args = ptypes.size() - 1;\n-        ClassDesc[] paramTypes = args > 0\n-                ? ptypes.subList(1, args + 1).toArray(ConstantUtils.EMPTY_CLASSDESC)\n-                : ConstantUtils.EMPTY_CLASSDESC;\n-\n-        MethodTypeDescImpl result = ofValidated(ptypes.get(0), paramTypes);\n+        int length = descriptor.length();\n+        int rightBracket, retTypeLength;\n+        if (descriptor.charAt(0) != '('\n+                || (rightBracket = (descriptor.charAt(1) == ')' ? 1 : descriptor.lastIndexOf(')'))) <= 0\n+                || (retTypeLength = length - rightBracket - 1) == 0\n+                || (retTypeLength != 1 \/\/ if retTypeLength == 1, check correctness in resolveClassDesc\n+                    && retTypeLength != skipOverFieldSignature(descriptor, rightBracket + 1, length))\n+        ) {\n+            throw badMethodDescriptor(descriptor);\n+        }\n+\n+        var returnType = resolveClassDesc(descriptor, rightBracket + 1, retTypeLength);\n+        if (length == 3 && returnType == CD_void) {\n+            return (MethodTypeDescImpl) ConstantDescs.MTD_void;\n+        }\n+        var paramTypes = paramTypes(descriptor, 1, rightBracket);\n+        var result = new MethodTypeDescImpl(returnType, paramTypes);\n@@ -120,0 +138,71 @@\n+    private static ClassDesc[] paramTypes(String descriptor, int start, int end) {\n+        if (start == end) {\n+            return EMPTY_CLASSDESC;\n+        }\n+\n+        \/*\n+         * If the length of the first 8 parameters is < 256, save them in lengths to avoid ArrayList allocation\n+         * Stop storing for the last parameter (we can compute length), or if too many parameters or too long.\n+         *\/\n+        \/\/ little endian storage - lowest byte is encoded length 0\n+        long packedLengths = 0;\n+        int packedCount = 0;\n+        int cur = start;\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0) {\n+                throw badMethodDescriptor(descriptor);\n+            }\n+            cur += len;\n+            if (len > 0xFF || packedCount >= Long.SIZE \/ Byte.SIZE || cur == end) {\n+                \/\/ Cannot or do not have to pack this item, but is already scanned and valid\n+                break;\n+            }\n+            packedLengths = packedLengths | (((long) len) << (Byte.SIZE * packedCount++));\n+        }\n+\n+        \/\/ Invariant: packedCount parameters encoded in packedLengths,\n+        \/\/ And another valid parameter pointed by cur\n+\n+        \/\/ Recover encoded elements\n+        ClassDesc[]     paramTypes    = null;\n+        List<ClassDesc> paramTypeList = null;\n+        if (cur == end) {\n+            paramTypes = new ClassDesc[packedCount + 1];\n+        } else {\n+            paramTypeList = new ArrayList<>(32);\n+        }\n+\n+        int last = start;\n+        for (int i = 0; i < packedCount; i++) {\n+            int len = Byte.toUnsignedInt((byte) (packedLengths >> (Byte.SIZE * i)));\n+            var cd = resolveClassDesc(descriptor, last, len);\n+            if (paramTypes != null) {\n+                paramTypes[i] = cd;\n+            } else {\n+                paramTypeList.add(cd);\n+            }\n+            last += len;\n+        }\n+        var lastCd = resolveClassDesc(descriptor, last, cur - last);\n+\n+        if (paramTypes != null) {\n+            paramTypes[packedCount] = lastCd;\n+            return paramTypes;\n+        }\n+        paramTypeList.add(lastCd);\n+        return buildParamTypes(descriptor, cur, end, paramTypeList);\n+    }\n+\n+    \/\/ slow path\n+    private static ClassDesc[] buildParamTypes(String descriptor, int cur, int end, List<ClassDesc> list) {\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0)\n+                throw badMethodDescriptor(descriptor);\n+            list.add(resolveClassDesc(descriptor, cur, len));\n+            cur += len;\n+        }\n+\n+        return list.toArray(EMPTY_CLASSDESC);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":98,"deletions":9,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +44,27 @@\n+    \/** {@link ClassDesc} representing the primitive type {@code int} *\/\n+    public static final PrimitiveClassDescImpl CD_int = new PrimitiveClassDescImpl(\"I\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code long} *\/\n+    public static final PrimitiveClassDescImpl CD_long = new PrimitiveClassDescImpl(\"J\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code float} *\/\n+    public static final PrimitiveClassDescImpl CD_float = new PrimitiveClassDescImpl(\"F\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code double} *\/\n+    public static final PrimitiveClassDescImpl CD_double = new PrimitiveClassDescImpl(\"D\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code short} *\/\n+    public static final PrimitiveClassDescImpl CD_short = new PrimitiveClassDescImpl(\"S\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code byte} *\/\n+    public static final PrimitiveClassDescImpl CD_byte = new PrimitiveClassDescImpl(\"B\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code char} *\/\n+    public static final PrimitiveClassDescImpl CD_char = new PrimitiveClassDescImpl(\"C\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code boolean} *\/\n+    public static final PrimitiveClassDescImpl CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code void} *\/\n+    public static final PrimitiveClassDescImpl CD_void = new PrimitiveClassDescImpl(\"V\");\n+\n@@ -44,0 +72,1 @@\n+    private @Stable Wrapper lazyWrapper; \/\/ initialized only after this\n@@ -55,1 +84,1 @@\n-    public PrimitiveClassDescImpl(String descriptor) {\n+    private PrimitiveClassDescImpl(String descriptor) {\n@@ -57,3 +86,0 @@\n-        if (descriptor.length() != 1\n-            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n-            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n@@ -63,0 +89,7 @@\n+    public Wrapper wrapper() {\n+        var wrapper = this.lazyWrapper;\n+        if (wrapper != null)\n+            return wrapper;\n+        return this.lazyWrapper = Wrapper.forBasicType(descriptorString().charAt(0));\n+    }\n+\n@@ -70,1 +103,1 @@\n-        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n+        return wrapper().primitiveType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n@@ -69,1 +69,1 @@\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,15 +307,0 @@\n-    \/** Return the wrapper that corresponds to the provided basic type char.\n-     *  The basic type char must be for one of the eight primitive types, or void.\n-     *  @throws IllegalArgumentException for unexpected types\n-     *\/\n-    public static Wrapper forPrimitiveType(char basicTypeChar) {\n-        Wrapper w = FROM_CHAR[(basicTypeChar + (basicTypeChar >> 1)) & 0xf];\n-        if (w == null || w.basicTypeChar != basicTypeChar) {\n-            throw basicTypeError(basicTypeChar);\n-        }\n-        if (w == OBJECT) {\n-            throw newIllegalArgumentException(\"not primitive: \" + basicTypeChar);\n-        }\n-        return w;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4, false);\n+       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4);\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+            \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+            \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\",\n+            \"(Ljava\/lang\/Integer;Ljava\/lang\/Integer;)Ljava\/lang\/Integer;\",\n+            \"()Ljava\/lang\/Object;\",\n@@ -64,0 +68,1 @@\n+            \"([III.Z[B..[.[B).\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescFactories.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,7 +115,0 @@\n-\n-    @Benchmark\n-    public void forPrimitiveType(Blackhole bh) throws Throwable {\n-        for (char c : PRIM_TYPES) {\n-            bh.consume(Wrapper.forPrimitiveType(c));\n-        }\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/Wrappers.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}