{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -342,2 +342,2 @@\n-    private short[] prefix  = new short[4096];\n-    private byte[]  suffix  = new byte[4096];\n+    private short[] prefix  = new short[4097];\n+    private byte[]  suffix  = new byte[4097];\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/GifImageDecoder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,2 +193,2 @@\n-    if (((*env)->GetArrayLength(env, prefixh) != 4096) ||\n-        ((*env)->GetArrayLength(env, suffixh) != 4096) ||\n+    if (((*env)->GetArrayLength(env, prefixh) != 4097) ||\n+        ((*env)->GetArrayLength(env, suffixh) != 4097) ||\n@@ -346,2 +346,5 @@\n-            curCode = oldCode;\n-            outCode[--outCount] = prevChar;\n+\n+        if (curCode != 4095) {\n+                curCode = oldCode;\n+                outCode[--outCount] = prevChar;\n+            }\n@@ -457,0 +460,2 @@\n+            } else if (codeSize == 12) {\n+                freeCode = 4096;\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/gif\/gifdecoder.c","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8351913\n+ * @summary Checks that sun.awt.image.GifImageDecoder decodes gifs like the\n+ *          ImageIO decoder does.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import javax.tools.Tool;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class GifDecodeTest {\n+\n+    \/**\n+     * This scans all folders in this directory and makes sure that the sun\/ImageToolkit decoder\n+     * resembles ImageIO's decoder. This test only focuses on the first frame of the gif.\n+     *\/\n+    public static void main(String[] args) throws IOException {\n+        File dir = new File(System.getProperty(\"test.src\", \".\"));\n+        boolean allTestsPassed = true;\n+        boolean anyTestsPassed = false;\n+        for (File gifFile : dir.listFiles((dir1, name) -> name.endsWith(\".gif\"))) {\n+            BufferedImage expectedFrame = ImageIO.read(gifFile);\n+            BufferedImage actualFrame = getFrame(gifFile, 0);\n+\n+            \/\/ If images are added to this test dir: you should also visually inspect\n+            \/\/ the expected\/actual results at least once. (That is: don't just assume\n+            \/\/ ImageIO is doing the correct thing; it's possible both implementations\n+            \/\/ are flawed.)\n+\n+            expectedFrame = trimTransparentEdges(expectedFrame);\n+            actualFrame = trimTransparentEdges(actualFrame);\n+\n+            boolean passed = testEquals(expectedFrame, actualFrame);\n+            if (!passed) {\n+                allTestsPassed = false;\n+                System.out.println(\"\\tfailed\");\n+            } else {\n+                anyTestsPassed = true;\n+                System.out.println(\"\\tpassed\");\n+            }\n+        }\n+\n+        if (!allTestsPassed) {\n+            throw new Error(\"One or more tests failed.\");\n+        } else  if (!anyTestsPassed) {\n+            throw new Error(\"This test did not identify any gif files to test in \" + dir.getAbsolutePath());\n+        }\n+    }\n+\n+    \/**\n+     * Return a subimage of the argument that strips away transparent edges.\n+     *\/\n+    private static BufferedImage trimTransparentEdges(BufferedImage bi) {\n+        Point topLeft = null;\n+        Point bottomRight = null;\n+        for (int y = 0; y < bi.getHeight(); y++) {\n+            for (int x = 0; x < bi.getWidth(); x++) {\n+                int argb = bi.getRGB(x, y);\n+                int alpha = (argb >> 24) & 0xff;\n+                if (alpha > 128) {\n+                    if (topLeft == null) {\n+                        topLeft = new Point(x, y);\n+                        bottomRight = new Point(x, y);\n+                    } else {\n+                        topLeft.x = Math.min(x, topLeft.x);\n+                        topLeft.y = Math.min(y, topLeft.y);\n+                        bottomRight.x = Math.max(x, bottomRight.x);\n+                        bottomRight.y = Math.max(y, bottomRight.y);\n+                    }\n+                }\n+            }\n+        }\n+        return bi.getSubimage(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n+    }\n+\n+    private static boolean testEquals(BufferedImage expectedImage, BufferedImage actualImage) {\n+        if (expectedImage.getWidth() != actualImage.getWidth()) {\n+            return false;\n+        }\n+        if (expectedImage.getHeight() != actualImage.getHeight()) {\n+            return false;\n+        }\n+        int tolerance = 0;\n+\n+        for (int y = 0; y < expectedImage.getHeight(); y++) {\n+            for (int x = 0; x < expectedImage.getWidth(); x++) {\n+                int argb1 = expectedImage.getRGB(x, y);\n+                int argb2 = actualImage.getRGB(x, y);\n+\n+                int a1 = (argb1 >> 24) & 0xff;\n+                int r1 = (argb1 >> 16) & 0xff;\n+                int g1 = (argb1 >> 8) & 0xff;\n+                int b1 = (argb1 >> 0) & 0xff;\n+\n+                int a2 = (argb2 >> 24) & 0xff;\n+                int r2 = (argb2 >> 16) & 0xff;\n+                int g2 = (argb2 >> 8) & 0xff;\n+                int b2 = (argb2 >> 0) & 0xff;\n+\n+                \/\/ transparency should be 0% or 100%\n+                if (a1 != a2) {\n+                    return false;\n+                }\n+\n+                if (a1 == 255) {\n+                    if (Math.abs(r1 - r2) > tolerance) {\n+                        return false;\n+                    }\n+                    if (Math.abs(g1 - g2) > tolerance) {\n+                        return false;\n+                    }\n+                    if (Math.abs(b1 - b2) > tolerance) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static BufferedImage getFrame(File gifFile, int frameIndex) throws IOException {\n+        Image image = Toolkit.getDefaultToolkit().createImage(gifFile.toURI().toURL());\n+        AtomicReference<BufferedImage> returnValue = new AtomicReference<>();\n+\n+        Semaphore semaphore = new Semaphore(1);\n+        semaphore.acquireUninterruptibly();\n+        image.getSource().startProduction(new ImageConsumer() {\n+            BufferedImage bi;\n+            int frameCtr = 0;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n+                returnValue.set(bi);\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {}\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {}\n+\n+            @Override\n+            public void setHints(int hintflags) {}\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model, byte[] pixels, int off, int scansize) {\n+                try {\n+                    final int yMax = y + h;\n+                    final int xMax = x + w;\n+\n+                    IndexColorModel icm = (IndexColorModel) model;\n+                    int[] colorModelRGBs = new int[icm.getMapSize()];\n+                    icm.getRGBs(colorModelRGBs);\n+                    int[] argbRow = new int[bi.getWidth()];\n+\n+                    for (int y_ = y; y_ < yMax; y_++) {\n+                        int i = y_ * scansize + off;\n+                        for (int x_ = x; x_ < xMax; x_++, i++) {\n+                            int pixel = pixels[i] & 0xff;\n+                            argbRow[x_ - x] = colorModelRGBs[pixel];\n+                        }\n+                        bi.getRaster().setDataElements(x, y_, w, 1, argbRow);\n+                    }\n+                } catch (RuntimeException e) {\n+                    \/\/ we don't expect this to happen, but if something goes wrong nobody else\n+                    \/\/ will print our stacktrace for us:\n+                    e.printStackTrace();\n+                    throw e;\n+                }\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model, int[] pixels, int off, int scansize) {}\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                try {\n+                    if (frameCtr++ == frameIndex) {\n+                        semaphore.release();\n+                        \/\/ if we don't detach this consumer the producer will loop forever\n+                        image.getSource().removeConsumer(this);\n+                        image.flush();\n+                    }\n+                } catch(Exception e) {\n+                    e.printStackTrace();\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+\n+        \/\/ wait for producer thread to finish:\n+        semaphore.acquireUninterruptibly();\n+\n+        return returnValue.get();\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/bug8351913\/GifDecodeTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"filename":"test\/jdk\/sun\/awt\/image\/bug8351913\/Scanner-abdominal-portal.gif-44.gif","binary":true,"status":"added"}]}