{"files":[{"patch":"@@ -505,15 +505,2 @@\n-  while (true) {\n-    VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n-    VMThread::execute(&op);\n-\n-    if (!GCCause::is_explicit_full_gc(cause)) {\n-      return;\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      if (full_gc_count != total_full_collections()) {\n-        return;\n-      }\n-    }\n-  }\n+  VM_ParallelGCCollect op(gc_count, full_gc_count, cause);\n+  VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -610,18 +610,5 @@\n-  while (true) {\n-    VM_SerialGCCollect op(!should_run_young_gc,\n-                          gc_count_before,\n-                          full_gc_count_before,\n-                          cause);\n-    VMThread::execute(&op);\n-    if (!GCCause::is_explicit_full_gc(cause)) {\n-      return;\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      \/\/ Read the GC count while holding the Heap_lock\n-      if (full_gc_count_before != total_full_collections()) {\n-        return;\n-      }\n-    }\n-  }\n+  VM_SerialGCCollect op(!should_run_young_gc,\n+                        gc_count_before,\n+                        full_gc_count_before,\n+                        cause);\n+  VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"}]}