{"files":[{"patch":"@@ -867,36 +867,27 @@\n-enum Aqrl {relaxed = 0b00, rl = 0b01, aq = 0b10, aqrl = 0b11};\n-\n-#define INSN(NAME, op, funct3, funct7)                                                  \\\n-  void NAME(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {        \\\n-    unsigned insn = 0;                                                                  \\\n-    patch((address)&insn, 6, 0, op);                                                    \\\n-    patch((address)&insn, 14, 12, funct3);                                              \\\n-    patch_reg((address)&insn, 7, Rd);                                                   \\\n-    patch_reg((address)&insn, 15, Rs1);                                                 \\\n-    patch_reg((address)&insn, 20, Rs2);                                                 \\\n-    patch((address)&insn, 31, 27, funct7);                                              \\\n-    patch((address)&insn, 26, 25, memory_order);                                        \\\n-    emit(insn);                                                                         \\\n-  }\n-\n-  INSN(amoswap_w, 0b0101111, 0b010, 0b00001);\n-  INSN(amoadd_w,  0b0101111, 0b010, 0b00000);\n-  INSN(amoxor_w,  0b0101111, 0b010, 0b00100);\n-  INSN(amoand_w,  0b0101111, 0b010, 0b01100);\n-  INSN(amoor_w,   0b0101111, 0b010, 0b01000);\n-  INSN(amomin_w,  0b0101111, 0b010, 0b10000);\n-  INSN(amomax_w,  0b0101111, 0b010, 0b10100);\n-  INSN(amominu_w, 0b0101111, 0b010, 0b11000);\n-  INSN(amomaxu_w, 0b0101111, 0b010, 0b11100);\n-  INSN(amoswap_d, 0b0101111, 0b011, 0b00001);\n-  INSN(amoadd_d,  0b0101111, 0b011, 0b00000);\n-  INSN(amoxor_d,  0b0101111, 0b011, 0b00100);\n-  INSN(amoand_d,  0b0101111, 0b011, 0b01100);\n-  INSN(amoor_d,   0b0101111, 0b011, 0b01000);\n-  INSN(amomin_d,  0b0101111, 0b011, 0b10000);\n-  INSN(amomax_d , 0b0101111, 0b011, 0b10100);\n-  INSN(amominu_d, 0b0101111, 0b011, 0b11000);\n-  INSN(amomaxu_d, 0b0101111, 0b011, 0b11100);\n-  INSN(amocas_w,  0b0101111, 0b010, 0b00101);\n-  INSN(amocas_d,  0b0101111, 0b011, 0b00101);\n-#undef INSN\n+  enum Aqrl {relaxed = 0b00, rl = 0b01, aq = 0b10, aqrl = 0b11};\n+\n+ private:\n+\n+  enum AmoWidthFunct3 : uint8_t {\n+    AMO_WIDTH_BYTE        = 0b000, \/\/ Zabha extension\n+    AMO_WIDTH_HALFWORD    = 0b001, \/\/ Zabha extension\n+    AMO_WIDTH_WORD        = 0b010,\n+    AMO_WIDTH_DOUBLEWORD  = 0b011,\n+    AMO_WIDTH_QUADWORD    = 0b100,\n+    \/\/ 0b101 to 0b111 are reserved\n+  };\n+\n+  enum AmoOperationFunct5 : uint8_t {\n+    AMO_ADD  = 0b00000,\n+    AMO_SWAP = 0b00001,\n+    AMO_LR   = 0b00010,\n+    AMO_SC   = 0b00011,\n+    AMO_XOR  = 0b00100,\n+    AMO_OR   = 0b01000,\n+    AMO_AND  = 0b01100,\n+    AMO_MIN  = 0b10000,\n+    AMO_MAX  = 0b10100,\n+    AMO_MINU = 0b11000,\n+    AMO_MAXU = 0b11100,\n+    AMO_CAS  = 0b00101 \/\/ Zacas\n+  };\n@@ -904,1 +895,1 @@\n-enum operand_size { int8, int16, int32, uint32, int64 };\n+  static constexpr uint32_t OP_AMO_MAJOR = 0b0101111;\n@@ -906,12 +897,13 @@\n-#define INSN(NAME, op, funct3, funct7)                                              \\\n-  void NAME(Register Rd, Register Rs1, Aqrl memory_order = relaxed) {               \\\n-    unsigned insn = 0;                                                              \\\n-    uint32_t val = memory_order & 0x3;                                              \\\n-    patch((address)&insn, 6, 0, op);                                                \\\n-    patch((address)&insn, 14, 12, funct3);                                          \\\n-    patch_reg((address)&insn, 7, Rd);                                               \\\n-    patch_reg((address)&insn, 15, Rs1);                                             \\\n-    patch((address)&insn, 25, 20, 0b00000);                                         \\\n-    patch((address)&insn, 31, 27, funct7);                                          \\\n-    patch((address)&insn, 26, 25, val);                                             \\\n-    emit(insn);                                                                     \\\n+  template <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\n+  void amo_base(Register Rd, Register Rs1, uint8_t Rs2, Aqrl memory_order = aqrl) {\n+    assert(width > AMO_WIDTH_HALFWORD || UseZabha, \"Must be\");\n+    assert(funct5 != AMO_CAS || UseZacas, \"Must be\");\n+    unsigned insn = 0;\n+    patch((address)&insn,  6,  0, OP_AMO_MAJOR);\n+    patch_reg((address)&insn,  7, Rd);\n+    patch((address)&insn, 14, 12, width);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch((address)&insn, 24, 20, Rs2);\n+    patch((address)&insn, 26, 25, memory_order);\n+    patch((address)&insn, 31, 27, funct5);\n+    emit(insn);\n@@ -920,2 +912,4 @@\n-  INSN(lr_w, 0b0101111, 0b010, 0b00010);\n-  INSN(lr_d, 0b0101111, 0b011, 0b00010);\n+  template <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\n+  void amo_base(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<funct5, width>(Rd, Rs1, Rs2->raw_encoding(), memory_order);\n+  }\n@@ -923,1 +917,1 @@\n-#undef INSN\n+ public:\n@@ -925,17 +919,181 @@\n-#define INSN(NAME, op, funct3, funct7)                                                      \\\n-  void NAME(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = relaxed) {         \\\n-    unsigned insn = 0;                                                                      \\\n-    uint32_t val = memory_order & 0x3;                                                      \\\n-    patch((address)&insn, 6, 0, op);                                                        \\\n-    patch((address)&insn, 14, 12, funct3);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                       \\\n-    patch_reg((address)&insn, 15, Rs2);                                                     \\\n-    patch_reg((address)&insn, 20, Rs1);                                                     \\\n-    patch((address)&insn, 31, 27, funct7);                                                  \\\n-    patch((address)&insn, 26, 25, val);                                                     \\\n-    emit(insn);                                                                             \\\n-  }\n-\n-  INSN(sc_w, 0b0101111, 0b010, 0b00011);\n-  INSN(sc_d, 0b0101111, 0b011, 0b00011);\n-#undef INSN\n+  void amoadd_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+ protected:\n+\n+  void lr_w(Register Rd, Register Rs1, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_LR, AMO_WIDTH_WORD>(Rd, Rs1, 0, memory_order);\n+  }\n+\n+  void lr_d(Register Rd, Register Rs1, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_LR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, 0, memory_order);\n+  }\n+\n+  void sc_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SC, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void sc_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SC, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+ public:\n+\n+  enum operand_size { int8, int16, int32, uint32, int64 };\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":227,"deletions":69,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+  product(bool, UseZabha, false, EXPERIMENTAL, \"Use UseZabha instructions\")      \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3801,1 +3801,1 @@\n-                                   enum operand_size size,\n+                                   Assembler::operand_size size,\n@@ -3822,1 +3822,1 @@\n-                                       enum operand_size size,\n+                                       Assembler::operand_size size,\n@@ -3826,1 +3826,1 @@\n-      sc_d(dst, new_val, addr, release);\n+      sc_d(dst, addr, new_val, release);\n@@ -3830,1 +3830,1 @@\n-      sc_w(dst, new_val, addr, release);\n+      sc_w(dst, addr, new_val, release);\n@@ -3839,1 +3839,1 @@\n-                                                 enum operand_size size,\n+                                                 Assembler::operand_size size,\n@@ -3869,1 +3869,1 @@\n-                                          enum operand_size size,\n+                                          Assembler::operand_size size,\n@@ -3873,0 +3873,1 @@\n+  assert(!(UseZacas && UseZabha), \"Use amocas\");\n@@ -3905,1 +3906,1 @@\n-    lr_w(result, aligned_addr, acquire);\n+    load_reserved(result, aligned_addr, operand_size::int32, acquire);\n@@ -3911,1 +3912,1 @@\n-    sc_w(scratch0, scratch0, aligned_addr, release);\n+    store_conditional(scratch0, scratch0, aligned_addr, operand_size::int32, release);\n@@ -3943,1 +3944,1 @@\n-                                               enum operand_size size,\n+                                               Assembler::operand_size size,\n@@ -3947,0 +3948,1 @@\n+  assert(!(UseZacas && UseZabha), \"Use amocas\");\n@@ -3977,1 +3979,1 @@\n-    lr_w(result, aligned_addr, acquire);\n+    load_reserved(result, aligned_addr, operand_size::int32, acquire);\n@@ -3983,1 +3985,1 @@\n-    sc_w(scratch0, scratch0, aligned_addr, release);\n+    store_conditional(scratch0, scratch0, aligned_addr, operand_size::int32, release);\n@@ -4000,1 +4002,1 @@\n-                             enum operand_size size,\n+                             Assembler::operand_size size,\n@@ -4003,1 +4005,1 @@\n-  assert(size != int8 && size != int16, \"unsupported operand size\");\n+  assert((UseZacas && UseZabha) || (size != int8 && size != int16), \"unsupported operand size\");\n@@ -4061,1 +4063,1 @@\n-                                  enum operand_size size,\n+                                  Assembler::operand_size size,\n@@ -4064,1 +4066,1 @@\n-\n+  assert((UseZacas && UseZabha) || (size != int8 && size != int16), \"unsupported operand size\");\n@@ -4137,1 +4139,1 @@\n-                                enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n+                                Assembler::operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n@@ -4149,0 +4151,6 @@\n+    case int16:\n+      amocas_h(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n+      break;\n+    case int8:\n+      amocas_b(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n+      break;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1190,1 +1190,1 @@\n-               enum operand_size size,\n+               Assembler::operand_size size,\n@@ -1195,1 +1195,1 @@\n-                    enum operand_size size,\n+                    Assembler::operand_size size,\n@@ -1199,1 +1199,1 @@\n-                                   enum operand_size size,\n+                                   Assembler::operand_size size,\n@@ -1203,1 +1203,1 @@\n-                            enum operand_size size,\n+                            Assembler::operand_size size,\n@@ -1209,1 +1209,1 @@\n-                                 enum operand_size size,\n+                                 Assembler::operand_size size,\n@@ -1226,1 +1226,1 @@\n-  void atomic_cas(Register prev, Register newv, Register addr, enum operand_size size,\n+  void atomic_cas(Register prev, Register newv, Register addr, Assembler::operand_size size,\n@@ -1639,2 +1639,2 @@\n-  void load_reserved(Register dst, Register addr, enum operand_size size, Assembler::Aqrl acquire);\n-  void store_conditional(Register dst, Register new_val, Register addr, enum operand_size size, Assembler::Aqrl release);\n+  void load_reserved(Register dst, Register addr, Assembler::operand_size size, Assembler::Aqrl acquire);\n+  void store_conditional(Register dst, Register new_val, Register addr, Assembler::operand_size size, Assembler::Aqrl release);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2322,36 +2322,0 @@\n-  enc_class riscv_enc_cmpxchgw(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgw_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg_acq(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n@@ -5268,2 +5232,2 @@\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                         iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5271,0 +5235,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5279,1 +5245,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB_narrow\"\n@@ -5291,2 +5257,24 @@\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                         iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5294,0 +5282,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5302,1 +5292,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS_narrow\"\n@@ -5314,0 +5304,22 @@\n+instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5325,1 +5337,5 @@\n-  ins_encode(riscv_enc_cmpxchgw(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5341,1 +5357,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5359,1 +5379,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5367,0 +5391,1 @@\n+\n@@ -5376,1 +5401,5 @@\n-  ins_encode(riscv_enc_cmpxchgn(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5382,2 +5411,2 @@\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                            iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                   iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5385,1 +5414,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5395,1 +5424,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq_narrow\"\n@@ -5407,2 +5436,1 @@\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                            iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n@@ -5410,1 +5438,24 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                   iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5420,1 +5471,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq_narrow\"\n@@ -5432,0 +5483,22 @@\n+instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5445,1 +5518,5 @@\n-  ins_encode(riscv_enc_cmpxchgw_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5463,1 +5540,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5481,1 +5562,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5499,1 +5584,5 @@\n-  ins_encode(riscv_enc_cmpxchgn_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5510,2 +5599,2 @@\n-instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5513,0 +5602,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5520,1 +5611,1 @@\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB\"\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB_narrow\"\n@@ -5532,2 +5623,1 @@\n-instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n@@ -5535,0 +5625,23 @@\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5542,1 +5655,1 @@\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS\"\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS_narrow\"\n@@ -5554,0 +5667,20 @@\n+instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5560,2 +5693,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5580,2 +5711,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5597,0 +5726,1 @@\n+\n@@ -5601,2 +5731,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5618,0 +5746,1 @@\n+\n@@ -5622,2 +5751,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5636,2 +5763,2 @@\n-instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5639,1 +5766,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5648,1 +5775,1 @@\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq\"\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq_narrow\"\n@@ -5660,2 +5787,1 @@\n-instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n@@ -5663,1 +5789,22 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5672,1 +5819,1 @@\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq\"\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq_narrow\"\n@@ -5684,0 +5831,20 @@\n+instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5692,2 +5859,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5714,2 +5879,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5736,2 +5899,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5758,2 +5919,0 @@\n-  effect(TEMP_DEF res);\n-\n@@ -5772,2 +5931,2 @@\n-instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5775,0 +5934,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5783,1 +5944,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapB\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapB_narrow\"\n@@ -5795,2 +5956,1 @@\n-instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n@@ -5798,0 +5958,24 @@\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5806,1 +5990,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapS\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapS_narrow\"\n@@ -5818,0 +6002,21 @@\n+instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5859,0 +6064,1 @@\n+\n@@ -5879,0 +6085,1 @@\n+\n@@ -5896,2 +6103,2 @@\n-instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5899,1 +6106,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5909,1 +6116,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapBAcq\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapBAcq_narrow\"\n@@ -5921,2 +6128,1 @@\n-instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n@@ -5924,1 +6130,23 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5934,1 +6162,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapSAcq\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapSAcq_narrow\"\n@@ -5946,0 +6174,21 @@\n+instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":351,"deletions":102,"binary":false,"changes":453,"status":"modified"},{"patch":"@@ -110,0 +110,8 @@\n+template <Assembler::operand_size ASMSIZE>\n+bool using_narrow() {\n+  if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    return !(UseZacas && UseZabha);\n+  }\n+  return false;\n+}\n+\n@@ -129,1 +137,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -179,1 +187,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -200,1 +208,1 @@\n-  TESTSIZE val[] = {1337, min, max};\n+  TESTSIZE val[] = {37, min, max};\n@@ -208,1 +216,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -216,1 +224,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -225,1 +233,1 @@\n-                                            1336 \/* expected *\/,      42 \/* new value *\/,\n+                                              36 \/* expected *\/,      42 \/* new value *\/,\n@@ -233,1 +241,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -242,1 +250,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -250,1 +258,1 @@\n-                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                             36 \/* expected *\/,     42 \/* new value *\/,\n@@ -259,1 +267,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -267,1 +275,1 @@\n-                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                             36 \/* expected *\/,     42 \/* new value *\/,\n@@ -311,0 +319,12 @@\n+TEST_VM(RiscV, cmpxchg_int16_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_plain_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_plain_cmpxchg_tests<int8_t, Assembler::int8>();\n+  }\n+}\n+\n@@ -323,1 +343,0 @@\n-      \/\/ printf(\"%lu %lX\\n\", (uint64_t)val[i], (uint64_t)val[i]);\n@@ -348,1 +367,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_lr_sc) {\n@@ -355,1 +374,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_maybe_zacas) {\n@@ -357,0 +376,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -358,0 +379,1 @@\n+    UseZabha = zabha;\n@@ -361,1 +383,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_lr_sc) {\n@@ -368,1 +390,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_maybe_zacas) {\n@@ -370,0 +392,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -371,0 +395,1 @@\n+    UseZabha = zabha;\n@@ -489,1 +514,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_concurrent_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_concurrent_lr_sc) {\n@@ -497,1 +522,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_concurrent_maybe_zacas) {\n@@ -499,0 +524,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -501,0 +528,1 @@\n+    UseZabha = zabha;\n@@ -504,1 +532,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_concurrent_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_concurrent_lr_sc) {\n@@ -512,1 +540,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_concurrent_maybe_zacas) {\n@@ -514,0 +542,17 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_concurrent_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int16_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_concurrent_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n@@ -537,1 +582,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -557,1 +602,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -627,1 +672,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_lr_sc) {\n@@ -634,1 +679,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_lr_sc) {\n@@ -641,1 +686,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_maybe_zacas) {\n@@ -643,0 +688,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -644,0 +691,1 @@\n+    UseZabha = zabha;\n@@ -647,1 +695,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_maybe_zacas) {\n@@ -649,0 +697,15 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n@@ -727,1 +790,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_concurrent_lr_sc) {\n@@ -735,1 +798,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_concurrent_maybe_zacas) {\n@@ -737,0 +800,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -739,0 +804,1 @@\n+    UseZabha = zabha;\n@@ -742,1 +808,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_concurrent_lr_sc) {\n@@ -750,1 +816,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_concurrent_maybe_zacas) {\n@@ -752,0 +818,17 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_concurrent_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_concurrent_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n","filename":"test\/hotspot\/gtest\/riscv\/test_assembler_riscv.cpp","additions":113,"deletions":30,"binary":false,"changes":143,"status":"modified"}]}