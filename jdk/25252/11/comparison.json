{"files":[{"patch":"@@ -964,36 +964,27 @@\n-enum Aqrl {relaxed = 0b00, rl = 0b01, aq = 0b10, aqrl = 0b11};\n-\n-#define INSN(NAME, op, funct3, funct7)                                                  \\\n-  void NAME(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {        \\\n-    unsigned insn = 0;                                                                  \\\n-    patch((address)&insn, 6, 0, op);                                                    \\\n-    patch((address)&insn, 14, 12, funct3);                                              \\\n-    patch_reg((address)&insn, 7, Rd);                                                   \\\n-    patch_reg((address)&insn, 15, Rs1);                                                 \\\n-    patch_reg((address)&insn, 20, Rs2);                                                 \\\n-    patch((address)&insn, 31, 27, funct7);                                              \\\n-    patch((address)&insn, 26, 25, memory_order);                                        \\\n-    emit(insn);                                                                         \\\n-  }\n-\n-  INSN(amoswap_w, 0b0101111, 0b010, 0b00001);\n-  INSN(amoadd_w,  0b0101111, 0b010, 0b00000);\n-  INSN(amoxor_w,  0b0101111, 0b010, 0b00100);\n-  INSN(amoand_w,  0b0101111, 0b010, 0b01100);\n-  INSN(amoor_w,   0b0101111, 0b010, 0b01000);\n-  INSN(amomin_w,  0b0101111, 0b010, 0b10000);\n-  INSN(amomax_w,  0b0101111, 0b010, 0b10100);\n-  INSN(amominu_w, 0b0101111, 0b010, 0b11000);\n-  INSN(amomaxu_w, 0b0101111, 0b010, 0b11100);\n-  INSN(amoswap_d, 0b0101111, 0b011, 0b00001);\n-  INSN(amoadd_d,  0b0101111, 0b011, 0b00000);\n-  INSN(amoxor_d,  0b0101111, 0b011, 0b00100);\n-  INSN(amoand_d,  0b0101111, 0b011, 0b01100);\n-  INSN(amoor_d,   0b0101111, 0b011, 0b01000);\n-  INSN(amomin_d,  0b0101111, 0b011, 0b10000);\n-  INSN(amomax_d , 0b0101111, 0b011, 0b10100);\n-  INSN(amominu_d, 0b0101111, 0b011, 0b11000);\n-  INSN(amomaxu_d, 0b0101111, 0b011, 0b11100);\n-  INSN(amocas_w,  0b0101111, 0b010, 0b00101);\n-  INSN(amocas_d,  0b0101111, 0b011, 0b00101);\n-#undef INSN\n+  enum Aqrl {relaxed = 0b00, rl = 0b01, aq = 0b10, aqrl = 0b11};\n+\n+ private:\n+\n+  enum AmoWidthFunct3 : uint8_t {\n+    AMO_WIDTH_BYTE        = 0b000, \/\/ Zabha extension\n+    AMO_WIDTH_HALFWORD    = 0b001, \/\/ Zabha extension\n+    AMO_WIDTH_WORD        = 0b010,\n+    AMO_WIDTH_DOUBLEWORD  = 0b011,\n+    AMO_WIDTH_QUADWORD    = 0b100,\n+    \/\/ 0b101 to 0b111 are reserved\n+  };\n+\n+  enum AmoOperationFunct5 : uint8_t {\n+    AMO_ADD  = 0b00000,\n+    AMO_SWAP = 0b00001,\n+    AMO_LR   = 0b00010,\n+    AMO_SC   = 0b00011,\n+    AMO_XOR  = 0b00100,\n+    AMO_OR   = 0b01000,\n+    AMO_AND  = 0b01100,\n+    AMO_MIN  = 0b10000,\n+    AMO_MAX  = 0b10100,\n+    AMO_MINU = 0b11000,\n+    AMO_MAXU = 0b11100,\n+    AMO_CAS  = 0b00101 \/\/ Zacas\n+  };\n@@ -1001,1 +992,1 @@\n-enum operand_size { int8, int16, int32, uint32, int64 };\n+  static constexpr uint32_t OP_AMO_MAJOR = 0b0101111;\n@@ -1003,12 +994,13 @@\n-#define INSN(NAME, op, funct3, funct7)                                              \\\n-  void NAME(Register Rd, Register Rs1, Aqrl memory_order = relaxed) {               \\\n-    unsigned insn = 0;                                                              \\\n-    uint32_t val = memory_order & 0x3;                                              \\\n-    patch((address)&insn, 6, 0, op);                                                \\\n-    patch((address)&insn, 14, 12, funct3);                                          \\\n-    patch_reg((address)&insn, 7, Rd);                                               \\\n-    patch_reg((address)&insn, 15, Rs1);                                             \\\n-    patch((address)&insn, 25, 20, 0b00000);                                         \\\n-    patch((address)&insn, 31, 27, funct7);                                          \\\n-    patch((address)&insn, 26, 25, val);                                             \\\n-    emit(insn);                                                                     \\\n+  template <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\n+  void amo_base(Register Rd, Register Rs1, uint8_t Rs2, Aqrl memory_order = aqrl) {\n+    assert(width > AMO_WIDTH_HALFWORD || UseZabha, \"Must be\");\n+    assert(funct5 != AMO_CAS || UseZacas, \"Must be\");\n+    unsigned insn = 0;\n+    patch((address)&insn,  6,  0, OP_AMO_MAJOR);\n+    patch_reg((address)&insn,  7, Rd);\n+    patch((address)&insn, 14, 12, width);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch((address)&insn, 24, 20, Rs2);\n+    patch((address)&insn, 26, 25, memory_order);\n+    patch((address)&insn, 31, 27, funct5);\n+    emit(insn);\n@@ -1017,2 +1009,4 @@\n-  INSN(lr_w, 0b0101111, 0b010, 0b00010);\n-  INSN(lr_d, 0b0101111, 0b011, 0b00010);\n+  template <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\n+  void amo_base(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<funct5, width>(Rd, Rs1, Rs2->raw_encoding(), memory_order);\n+  }\n@@ -1020,1 +1014,1 @@\n-#undef INSN\n+ public:\n@@ -1022,17 +1016,181 @@\n-#define INSN(NAME, op, funct3, funct7)                                                      \\\n-  void NAME(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = relaxed) {         \\\n-    unsigned insn = 0;                                                                      \\\n-    uint32_t val = memory_order & 0x3;                                                      \\\n-    patch((address)&insn, 6, 0, op);                                                        \\\n-    patch((address)&insn, 14, 12, funct3);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                       \\\n-    patch_reg((address)&insn, 15, Rs2);                                                     \\\n-    patch_reg((address)&insn, 20, Rs1);                                                     \\\n-    patch((address)&insn, 31, 27, funct7);                                                  \\\n-    patch((address)&insn, 26, 25, val);                                                     \\\n-    emit(insn);                                                                             \\\n-  }\n-\n-  INSN(sc_w, 0b0101111, 0b010, 0b00011);\n-  INSN(sc_d, 0b0101111, 0b011, 0b00011);\n-#undef INSN\n+  void amoadd_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+ protected:\n+\n+  void lr_w(Register Rd, Register Rs1, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_LR, AMO_WIDTH_WORD>(Rd, Rs1, 0, memory_order);\n+  }\n+\n+  void lr_d(Register Rd, Register Rs1, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_LR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, 0, memory_order);\n+  }\n+\n+  void sc_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SC, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void sc_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SC, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+ public:\n+\n+  enum operand_size { int8, int16, int32, uint32, int64 };\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":227,"deletions":69,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+  product(bool, UseZabha, false, EXPERIMENTAL, \"Use UseZabha instructions\")      \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3801,1 +3801,1 @@\n-                                   enum operand_size size,\n+                                   Assembler::operand_size size,\n@@ -3822,1 +3822,1 @@\n-                                       enum operand_size size,\n+                                       Assembler::operand_size size,\n@@ -3826,1 +3826,1 @@\n-      sc_d(dst, new_val, addr, release);\n+      sc_d(dst, addr, new_val, release);\n@@ -3830,1 +3830,1 @@\n-      sc_w(dst, new_val, addr, release);\n+      sc_w(dst, addr, new_val, release);\n@@ -3839,1 +3839,1 @@\n-                                                 enum operand_size size,\n+                                                 Assembler::operand_size size,\n@@ -3869,1 +3869,1 @@\n-                                          enum operand_size size,\n+                                          Assembler::operand_size size,\n@@ -3873,0 +3873,1 @@\n+  assert(!(UseZacas && UseZabha), \"Use amocas\");\n@@ -3905,1 +3906,1 @@\n-    lr_w(result, aligned_addr, acquire);\n+    load_reserved(result, aligned_addr, operand_size::int32, acquire);\n@@ -3911,1 +3912,1 @@\n-    sc_w(scratch0, scratch0, aligned_addr, release);\n+    store_conditional(scratch0, scratch0, aligned_addr, operand_size::int32, release);\n@@ -3943,1 +3944,1 @@\n-                                               enum operand_size size,\n+                                               Assembler::operand_size size,\n@@ -3947,0 +3948,1 @@\n+  assert(!(UseZacas && UseZabha), \"Use amocas\");\n@@ -3977,1 +3979,1 @@\n-    lr_w(result, aligned_addr, acquire);\n+    load_reserved(result, aligned_addr, operand_size::int32, acquire);\n@@ -3983,1 +3985,1 @@\n-    sc_w(scratch0, scratch0, aligned_addr, release);\n+    store_conditional(scratch0, scratch0, aligned_addr, operand_size::int32, release);\n@@ -4000,1 +4002,1 @@\n-                             enum operand_size size,\n+                             Assembler::operand_size size,\n@@ -4003,1 +4005,1 @@\n-  assert(size != int8 && size != int16, \"unsupported operand size\");\n+  assert((UseZacas && UseZabha) || (size != int8 && size != int16), \"unsupported operand size\");\n@@ -4061,1 +4063,1 @@\n-                                  enum operand_size size,\n+                                  Assembler::operand_size size,\n@@ -4064,1 +4066,1 @@\n-\n+  assert((UseZacas && UseZabha) || (size != int8 && size != int16), \"unsupported operand size\");\n@@ -4137,1 +4139,1 @@\n-                                enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n+                                Assembler::operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n@@ -4149,0 +4151,6 @@\n+    case int16:\n+      amocas_h(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n+      break;\n+    case int8:\n+      amocas_b(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n+      break;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1190,1 +1190,1 @@\n-               enum operand_size size,\n+               Assembler::operand_size size,\n@@ -1195,1 +1195,1 @@\n-                    enum operand_size size,\n+                    Assembler::operand_size size,\n@@ -1199,1 +1199,1 @@\n-                                   enum operand_size size,\n+                                   Assembler::operand_size size,\n@@ -1203,1 +1203,1 @@\n-                            enum operand_size size,\n+                            Assembler::operand_size size,\n@@ -1209,1 +1209,1 @@\n-                                 enum operand_size size,\n+                                 Assembler::operand_size size,\n@@ -1226,1 +1226,1 @@\n-  void atomic_cas(Register prev, Register newv, Register addr, enum operand_size size,\n+  void atomic_cas(Register prev, Register newv, Register addr, Assembler::operand_size size,\n@@ -1639,2 +1639,2 @@\n-  void load_reserved(Register dst, Register addr, enum operand_size size, Assembler::Aqrl acquire);\n-  void store_conditional(Register dst, Register new_val, Register addr, enum operand_size size, Assembler::Aqrl release);\n+  void load_reserved(Register dst, Register addr, Assembler::operand_size size, Assembler::Aqrl acquire);\n+  void store_conditional(Register dst, Register new_val, Register addr, Assembler::operand_size size, Assembler::Aqrl release);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2307,36 +2307,0 @@\n-  enc_class riscv_enc_cmpxchgw(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgw_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg_acq(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n@@ -5253,2 +5217,2 @@\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                         iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5256,0 +5220,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5258,1 +5224,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5264,1 +5230,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB_narrow\"\n@@ -5276,2 +5242,24 @@\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                         iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5279,0 +5267,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5281,1 +5271,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5287,1 +5277,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS_narrow\"\n@@ -5299,0 +5289,22 @@\n+instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5303,1 +5315,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5310,1 +5322,5 @@\n-  ins_encode(riscv_enc_cmpxchgw(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5319,1 +5335,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5326,1 +5342,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5337,1 +5357,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5344,1 +5364,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5352,0 +5376,1 @@\n+\n@@ -5354,1 +5379,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 8 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5361,1 +5386,5 @@\n-  ins_encode(riscv_enc_cmpxchgn(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5367,2 +5396,2 @@\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                            iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                   iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5370,1 +5399,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5374,1 +5403,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5380,1 +5409,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq_narrow\"\n@@ -5392,2 +5421,1 @@\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                            iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5395,1 +5423,24 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                   iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5399,1 +5450,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5405,1 +5456,1 @@\n-    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq_narrow\"\n@@ -5417,0 +5468,22 @@\n+instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5423,1 +5496,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5430,1 +5503,5 @@\n-  ins_encode(riscv_enc_cmpxchgw_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5441,1 +5518,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5448,1 +5525,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5459,1 +5540,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 6 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5466,1 +5547,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5477,1 +5562,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 8 + BRANCH_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5484,1 +5569,5 @@\n-  ins_encode(riscv_enc_cmpxchgn_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5495,2 +5584,2 @@\n-instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5498,0 +5587,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5500,1 +5591,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5505,1 +5596,1 @@\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB\"\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB_narrow\"\n@@ -5517,2 +5608,1 @@\n-instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5520,0 +5610,23 @@\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5522,1 +5635,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5527,1 +5640,1 @@\n-    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS\"\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS_narrow\"\n@@ -5539,0 +5652,20 @@\n+instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5543,3 +5676,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5563,3 +5694,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5582,1 +5711,0 @@\n-  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n@@ -5584,1 +5712,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 3);\n+  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));\n@@ -5586,1 +5714,1 @@\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5603,1 +5731,0 @@\n-  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n@@ -5605,1 +5732,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n+  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));\n@@ -5607,1 +5734,1 @@\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5621,2 +5748,2 @@\n-instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5624,1 +5751,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5628,1 +5755,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5633,1 +5760,1 @@\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq\"\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq_narrow\"\n@@ -5645,2 +5772,1 @@\n-instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5648,1 +5774,22 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5652,1 +5799,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5657,1 +5804,1 @@\n-    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq\"\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq_narrow\"\n@@ -5669,0 +5816,20 @@\n+instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5675,3 +5842,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5697,3 +5862,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5719,3 +5882,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5741,3 +5902,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST);\n-\n-  effect(TEMP_DEF res);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5757,2 +5916,2 @@\n-instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5760,0 +5919,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5762,1 +5923,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5768,1 +5929,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapB\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapB_narrow\"\n@@ -5780,2 +5941,23 @@\n-instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                             iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                    iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5783,0 +5965,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5785,1 +5969,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5791,1 +5975,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapS\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapS_narrow\"\n@@ -5803,0 +5987,21 @@\n+instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5807,1 +6012,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5826,1 +6031,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5844,0 +6049,1 @@\n+\n@@ -5846,1 +6052,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5864,0 +6070,1 @@\n+\n@@ -5866,1 +6073,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5881,2 +6088,2 @@\n-instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n@@ -5884,1 +6091,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5888,1 +6095,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5894,1 +6101,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapBAcq\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapBAcq_narrow\"\n@@ -5906,2 +6113,1 @@\n-instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                                iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n@@ -5909,1 +6115,23 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                                       iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5913,1 +6141,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5919,1 +6147,1 @@\n-    \"# $res == 1 when success, #@weakCompareAndSwapSAcq\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapSAcq_narrow\"\n@@ -5931,0 +6159,21 @@\n+instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5937,1 +6186,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5958,1 +6207,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -5979,1 +6228,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 4);\n+  ins_cost(2 * VOLATILE_REF_COST);\n@@ -6000,1 +6249,1 @@\n-  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 2);\n+  ins_cost(2 * VOLATILE_REF_COST);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":387,"deletions":138,"binary":false,"changes":525,"status":"modified"},{"patch":"@@ -110,0 +110,8 @@\n+template <Assembler::operand_size ASMSIZE>\n+bool using_narrow() {\n+  if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    return !(UseZacas && UseZabha);\n+  }\n+  return false;\n+}\n+\n@@ -129,1 +137,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -179,1 +187,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -200,1 +208,1 @@\n-  TESTSIZE val[] = {1337, min, max};\n+  TESTSIZE val[] = {37, min, max};\n@@ -208,1 +216,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -216,1 +224,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -225,1 +233,1 @@\n-                                            1336 \/* expected *\/,      42 \/* new value *\/,\n+                                              36 \/* expected *\/,      42 \/* new value *\/,\n@@ -233,1 +241,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -242,1 +250,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -250,1 +258,1 @@\n-                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                             36 \/* expected *\/,     42 \/* new value *\/,\n@@ -259,1 +267,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -267,1 +275,1 @@\n-                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                             36 \/* expected *\/,     42 \/* new value *\/,\n@@ -311,0 +319,12 @@\n+TEST_VM(RiscV, cmpxchg_int16_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_plain_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_plain_cmpxchg_tests<int8_t, Assembler::int8>();\n+  }\n+}\n+\n@@ -323,1 +343,0 @@\n-      \/\/ printf(\"%lu %lX\\n\", (uint64_t)val[i], (uint64_t)val[i]);\n@@ -348,1 +367,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_lr_sc) {\n@@ -355,1 +374,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_maybe_zacas) {\n@@ -357,0 +376,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -358,0 +379,1 @@\n+    UseZabha = zabha;\n@@ -361,1 +383,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_lr_sc) {\n@@ -368,1 +390,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_maybe_zacas) {\n@@ -370,0 +392,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -371,0 +395,1 @@\n+    UseZabha = zabha;\n@@ -489,1 +514,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_concurrent_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_concurrent_lr_sc) {\n@@ -497,1 +522,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_concurrent_maybe_zacas) {\n@@ -499,0 +524,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -501,0 +528,1 @@\n+    UseZabha = zabha;\n@@ -504,1 +532,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_concurrent_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_concurrent_lr_sc) {\n@@ -512,1 +540,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_concurrent_maybe_zacas) {\n@@ -514,0 +542,17 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_concurrent_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int16_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_concurrent_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n@@ -537,1 +582,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -557,1 +602,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -627,1 +672,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_lr_sc) {\n@@ -634,1 +679,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_lr_sc) {\n@@ -641,1 +686,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_maybe_zacas) {\n@@ -643,0 +688,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -644,0 +691,1 @@\n+    UseZabha = zabha;\n@@ -647,1 +695,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_maybe_zacas) {\n@@ -649,0 +697,15 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n@@ -727,1 +790,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_concurrent_lr_sc) {\n@@ -735,1 +798,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_concurrent_maybe_zacas) {\n@@ -737,0 +800,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -739,0 +804,1 @@\n+    UseZabha = zabha;\n@@ -742,1 +808,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_concurrent_lr_sc) {\n@@ -750,1 +816,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_concurrent_maybe_zacas) {\n@@ -752,0 +818,17 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_concurrent_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_concurrent_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n","filename":"test\/hotspot\/gtest\/riscv\/test_assembler_riscv.cpp","additions":113,"deletions":30,"binary":false,"changes":143,"status":"modified"}]}