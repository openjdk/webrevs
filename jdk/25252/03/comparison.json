{"files":[{"patch":"@@ -867,36 +867,27 @@\n-enum Aqrl {relaxed = 0b00, rl = 0b01, aq = 0b10, aqrl = 0b11};\n-\n-#define INSN(NAME, op, funct3, funct7)                                                  \\\n-  void NAME(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {        \\\n-    unsigned insn = 0;                                                                  \\\n-    patch((address)&insn, 6, 0, op);                                                    \\\n-    patch((address)&insn, 14, 12, funct3);                                              \\\n-    patch_reg((address)&insn, 7, Rd);                                                   \\\n-    patch_reg((address)&insn, 15, Rs1);                                                 \\\n-    patch_reg((address)&insn, 20, Rs2);                                                 \\\n-    patch((address)&insn, 31, 27, funct7);                                              \\\n-    patch((address)&insn, 26, 25, memory_order);                                        \\\n-    emit(insn);                                                                         \\\n-  }\n-\n-  INSN(amoswap_w, 0b0101111, 0b010, 0b00001);\n-  INSN(amoadd_w,  0b0101111, 0b010, 0b00000);\n-  INSN(amoxor_w,  0b0101111, 0b010, 0b00100);\n-  INSN(amoand_w,  0b0101111, 0b010, 0b01100);\n-  INSN(amoor_w,   0b0101111, 0b010, 0b01000);\n-  INSN(amomin_w,  0b0101111, 0b010, 0b10000);\n-  INSN(amomax_w,  0b0101111, 0b010, 0b10100);\n-  INSN(amominu_w, 0b0101111, 0b010, 0b11000);\n-  INSN(amomaxu_w, 0b0101111, 0b010, 0b11100);\n-  INSN(amoswap_d, 0b0101111, 0b011, 0b00001);\n-  INSN(amoadd_d,  0b0101111, 0b011, 0b00000);\n-  INSN(amoxor_d,  0b0101111, 0b011, 0b00100);\n-  INSN(amoand_d,  0b0101111, 0b011, 0b01100);\n-  INSN(amoor_d,   0b0101111, 0b011, 0b01000);\n-  INSN(amomin_d,  0b0101111, 0b011, 0b10000);\n-  INSN(amomax_d , 0b0101111, 0b011, 0b10100);\n-  INSN(amominu_d, 0b0101111, 0b011, 0b11000);\n-  INSN(amomaxu_d, 0b0101111, 0b011, 0b11100);\n-  INSN(amocas_w,  0b0101111, 0b010, 0b00101);\n-  INSN(amocas_d,  0b0101111, 0b011, 0b00101);\n-#undef INSN\n+  enum Aqrl {relaxed = 0b00, rl = 0b01, aq = 0b10, aqrl = 0b11};\n+\n+ private:\n+\n+  enum AmoWidthFunct3 : uint8_t {\n+    AMO_WIDTH_BYTE        = 0b000, \/\/ Zabha extension\n+    AMO_WIDTH_HALFWORD    = 0b001, \/\/ Zabha extension\n+    AMO_WIDTH_WORD        = 0b010,\n+    AMO_WIDTH_DOUBLEWORD  = 0b011,\n+    AMO_WIDTH_QUADWORD    = 0b100,\n+    \/\/ 0b101 to 0b111 are reserved\n+  };\n+\n+  enum AmoOperationFunct5 : uint8_t {\n+    AMO_ADD  = 0b00000,\n+    AMO_SWAP = 0b00001,\n+    AMO_LR   = 0b00010,\n+    AMO_SC   = 0b00011,\n+    AMO_XOR  = 0b00100,\n+    AMO_OR   = 0b01000,\n+    AMO_AND  = 0b01100,\n+    AMO_MIN  = 0b10000,\n+    AMO_MAX  = 0b10100,\n+    AMO_MINU = 0b11000,\n+    AMO_MAXU = 0b11100,\n+    AMO_CAS  = 0b00101 \/\/ Zacas\n+  };\n@@ -904,1 +895,1 @@\n-enum operand_size { int8, int16, int32, uint32, int64 };\n+  static constexpr uint32_t OP_AMO_MAJOR = 0b0101111;\n@@ -906,12 +897,13 @@\n-#define INSN(NAME, op, funct3, funct7)                                              \\\n-  void NAME(Register Rd, Register Rs1, Aqrl memory_order = relaxed) {               \\\n-    unsigned insn = 0;                                                              \\\n-    uint32_t val = memory_order & 0x3;                                              \\\n-    patch((address)&insn, 6, 0, op);                                                \\\n-    patch((address)&insn, 14, 12, funct3);                                          \\\n-    patch_reg((address)&insn, 7, Rd);                                               \\\n-    patch_reg((address)&insn, 15, Rs1);                                             \\\n-    patch((address)&insn, 25, 20, 0b00000);                                         \\\n-    patch((address)&insn, 31, 27, funct7);                                          \\\n-    patch((address)&insn, 26, 25, val);                                             \\\n-    emit(insn);                                                                     \\\n+  template <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\n+  void amo_base(Register Rd, Register Rs1, uint8_t Rs2, Aqrl memory_order = aqrl) {\n+    assert(width > AMO_WIDTH_HALFWORD || UseZabha, \"Must be\");\n+    assert(funct5 != AMO_CAS || UseZacas, \"Must be\");\n+    unsigned insn = 0;\n+    patch((address)&insn,  6,  0, OP_AMO_MAJOR);\n+    patch_reg((address)&insn,  7, Rd);\n+    patch((address)&insn, 14, 12, width);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch((address)&insn, 24, 20, Rs2);\n+    patch((address)&insn, 26, 25, memory_order);\n+    patch((address)&insn, 31, 27, funct5);\n+    emit(insn);\n@@ -920,2 +912,4 @@\n-  INSN(lr_w, 0b0101111, 0b010, 0b00010);\n-  INSN(lr_d, 0b0101111, 0b011, 0b00010);\n+  template <AmoOperationFunct5 funct5, AmoWidthFunct3 width>\n+  void amo_base(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<funct5, width>(Rd, Rs1, Rs2->raw_encoding(), memory_order);\n+  }\n@@ -923,1 +917,1 @@\n-#undef INSN\n+ public:\n@@ -925,17 +919,181 @@\n-#define INSN(NAME, op, funct3, funct7)                                                      \\\n-  void NAME(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = relaxed) {         \\\n-    unsigned insn = 0;                                                                      \\\n-    uint32_t val = memory_order & 0x3;                                                      \\\n-    patch((address)&insn, 6, 0, op);                                                        \\\n-    patch((address)&insn, 14, 12, funct3);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                       \\\n-    patch_reg((address)&insn, 15, Rs2);                                                     \\\n-    patch_reg((address)&insn, 20, Rs1);                                                     \\\n-    patch((address)&insn, 31, 27, funct7);                                                  \\\n-    patch((address)&insn, 26, 25, val);                                                     \\\n-    emit(insn);                                                                             \\\n-  }\n-\n-  INSN(sc_w, 0b0101111, 0b010, 0b00011);\n-  INSN(sc_d, 0b0101111, 0b011, 0b00011);\n-#undef INSN\n+  void amoadd_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoadd_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_ADD, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoswap_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SWAP, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoxor_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_XOR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoor_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_OR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amoand_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_AND, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomin_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MIN, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amominu_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MINU, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomax_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAX, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amomaxu_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_MAXU, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+ protected:\n+\n+  void lr_w(Register Rd, Register Rs1, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_LR, AMO_WIDTH_WORD>(Rd, Rs1, 0, memory_order);\n+  }\n+\n+  void lr_d(Register Rd, Register Rs1, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_LR, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, 0, memory_order);\n+  }\n+\n+  void sc_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SC, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void sc_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_SC, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_b(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_BYTE>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_h(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_HALFWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_w(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_WORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+  void amocas_d(Register Rd, Register Rs1, Register Rs2, Aqrl memory_order = aqrl) {\n+    amo_base<AMO_CAS, AMO_WIDTH_DOUBLEWORD>(Rd, Rs1, Rs2, memory_order);\n+  }\n+\n+ public:\n+\n+  enum operand_size { int8, int16, int32, uint32, int64 };\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":227,"deletions":69,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+  product(bool, UseZabha, false, EXPERIMENTAL, \"Use UseZabha instructions\")      \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3826,1 +3826,1 @@\n-      sc_d(dst, new_val, addr, release);\n+      sc_d(dst, addr, new_val, release);\n@@ -3830,1 +3830,1 @@\n-      sc_w(dst, new_val, addr, release);\n+      sc_w(dst, addr, new_val, release);\n@@ -3873,0 +3873,1 @@\n+  assert(!(UseZacas && UseZabha), \"Use amocas\");\n@@ -3905,1 +3906,1 @@\n-    lr_w(result, aligned_addr, acquire);\n+    load_reserved(result, aligned_addr, operand_size::int32, acquire);\n@@ -3911,1 +3912,1 @@\n-    sc_w(scratch0, scratch0, aligned_addr, release);\n+    store_conditional(scratch0, scratch0, aligned_addr, operand_size::int32, release);\n@@ -3947,0 +3948,1 @@\n+  assert(!(UseZacas && UseZabha), \"Use amocas\");\n@@ -3977,1 +3979,1 @@\n-    lr_w(result, aligned_addr, acquire);\n+    load_reserved(result, aligned_addr, operand_size::int32, acquire);\n@@ -3983,1 +3985,1 @@\n-    sc_w(scratch0, scratch0, aligned_addr, release);\n+    store_conditional(scratch0, scratch0, aligned_addr, operand_size::int32, release);\n@@ -4000,1 +4002,1 @@\n-                             enum operand_size size,\n+                             Assembler::operand_size size,\n@@ -4003,1 +4005,1 @@\n-  assert(size != int8 && size != int16, \"unsupported operand size\");\n+  assert((UseZacas && UseZabha) || (size != int8 && size != int16), \"unsupported operand size\");\n@@ -4061,1 +4063,1 @@\n-                                  enum operand_size size,\n+                                  Assembler::operand_size size,\n@@ -4064,1 +4066,1 @@\n-\n+  assert((UseZacas && UseZabha) || (size != int8 && size != int16), \"unsupported operand size\");\n@@ -4149,0 +4151,6 @@\n+    case int16:\n+      amocas_h(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n+      break;\n+    case int8:\n+      amocas_b(prev, addr, newv, (Assembler::Aqrl)(acquire | release));\n+      break;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2322,36 +2322,0 @@\n-  enc_class riscv_enc_cmpxchgw(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgw_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchgn_acq(iRegINoSp res, memory mem, iRegI oldval, iRegI newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n-  enc_class riscv_enc_cmpxchg_acq(iRegINoSp res, memory mem, iRegL oldval, iRegL newval) %{\n-    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n-               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n-               \/*result as bool*\/ true);\n-  %}\n-\n@@ -5268,1 +5232,1 @@\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct compareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5271,0 +5235,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5291,1 +5257,25 @@\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+\n+  effect(TEMP_DEF res, USE_KILL oldval, USE_KILL newval, KILL cr);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5294,0 +5284,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5314,0 +5306,24 @@\n+instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+\n+  effect(TEMP_DEF res, USE_KILL oldval, USE_KILL newval, KILL cr);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5325,1 +5341,5 @@\n-  ins_encode(riscv_enc_cmpxchgw(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5341,1 +5361,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5359,1 +5383,5 @@\n-  ins_encode(riscv_enc_cmpxchg(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5376,1 +5404,5 @@\n-  ins_encode(riscv_enc_cmpxchgn(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5382,1 +5414,1 @@\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct compareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5385,1 +5417,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5407,2 +5439,1 @@\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n-                            iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n@@ -5410,1 +5441,26 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 10 + BRANCH_COST * 4);\n+\n+  effect(TEMP_DEF res, USE_KILL oldval, USE_KILL newval, KILL cr);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (byte) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+                         iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5432,0 +5488,24 @@\n+instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + ALU_COST * 11 + BRANCH_COST * 4);\n+\n+  effect(TEMP_DEF res, USE_KILL oldval, USE_KILL newval, KILL cr);\n+\n+  format %{\n+    \"cmpxchg $mem, $oldval, $newval\\t# (short) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"mv $res, $res == $oldval\\t# $res <-- ($res == $oldval ? 1 : 0), #@compareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n+               true \/* result as bool *\/);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5445,1 +5525,5 @@\n-  ins_encode(riscv_enc_cmpxchgw_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5463,1 +5547,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5481,1 +5569,5 @@\n-  ins_encode(riscv_enc_cmpxchg_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int64,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5499,1 +5591,5 @@\n-  ins_encode(riscv_enc_cmpxchgn_acq(res, mem, oldval, newval));\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::uint32,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register,\n+               \/*result as bool*\/ true);\n+  %}\n@@ -5510,1 +5606,1 @@\n-instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct compareAndExchangeB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5513,0 +5609,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5532,1 +5630,23 @@\n-instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeB\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5535,0 +5655,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5554,0 +5676,22 @@\n+instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"cmpxchg $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeS\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5636,1 +5780,1 @@\n-instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct compareAndExchangeBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5639,1 +5783,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5660,1 +5804,23 @@\n-instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 5);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+              \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compareAndExchangeSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5663,1 +5829,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5684,0 +5850,22 @@\n+instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 3 + ALU_COST * 6);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"cmpxchg_acq $res = $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval, #@compareAndExchangeSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+               \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5772,1 +5960,1 @@\n-instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct weakCompareAndSwapB_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5775,0 +5963,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5795,1 +5985,24 @@\n-instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapB\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapS_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5798,0 +6011,2 @@\n+  predicate(!UseZabha || !UseZacas);\n+\n@@ -5818,0 +6033,23 @@\n+instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate(UseZabha && UseZacas);\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"weak_cmpxchg $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapS\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::relaxed, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5896,1 +6134,1 @@\n-instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct weakCompareAndSwapBAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5899,1 +6137,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5921,1 +6159,24 @@\n-instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n+instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 6);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (byte, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapBAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int8,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct weakCompareAndSwapSAcq_narrow(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval,\n@@ -5924,1 +6185,1 @@\n-  predicate(needs_acquiring_load_reserved(n));\n+  predicate((!UseZabha || !UseZacas) && needs_acquiring_load_reserved(n));\n@@ -5946,0 +6207,23 @@\n+instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI_R12 oldval, iRegI_R13 newval, rFlagsReg cr)\n+%{\n+  predicate((UseZabha && UseZacas) && needs_acquiring_load_reserved(n));\n+\n+  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));\n+\n+  ins_cost(LOAD_COST + STORE_COST + BRANCH_COST * 2 + ALU_COST * 7);\n+\n+  effect(TEMP_DEF res, KILL cr, USE_KILL oldval, USE_KILL newval);\n+\n+  format %{\n+    \"weak_cmpxchg_acq $mem, $oldval, $newval\\t# (short, weak) if $mem == $oldval then $mem <-- $newval\\n\\t\"\n+    \"# $res == 1 when success, #@weakCompareAndSwapSAcq\"\n+  %}\n+\n+  ins_encode %{\n+    __ weak_cmpxchg(as_Register($mem$$base), $oldval$$Register, $newval$$Register, Assembler::int16,\n+                    \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::rl, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":347,"deletions":63,"binary":false,"changes":410,"status":"modified"},{"patch":"@@ -110,0 +110,8 @@\n+template <Assembler::operand_size ASMSIZE>\n+bool using_narrow() {\n+  if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    return !(UseZacas && UseZabha);\n+  }\n+  return false;\n+}\n+\n@@ -129,1 +137,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -179,1 +187,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -200,1 +208,1 @@\n-  TESTSIZE val[] = {1337, min, max};\n+  TESTSIZE val[] = {37, min, max};\n@@ -208,1 +216,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -216,1 +224,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -225,1 +233,1 @@\n-                                            1336 \/* expected *\/,      42 \/* new value *\/,\n+                                              36 \/* expected *\/,      42 \/* new value *\/,\n@@ -233,1 +241,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -242,1 +250,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -250,1 +258,1 @@\n-                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                             36 \/* expected *\/,     42 \/* new value *\/,\n@@ -259,1 +267,1 @@\n-                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              36 \/* expected *\/,     42 \/* new value *\/,\n@@ -267,1 +275,1 @@\n-                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                             36 \/* expected *\/,     42 \/* new value *\/,\n@@ -311,0 +319,12 @@\n+TEST_VM(RiscV, cmpxchg_int16_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_plain_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_plain_cmpxchg_tests<int8_t, Assembler::int8>();\n+  }\n+}\n+\n@@ -323,1 +343,0 @@\n-      \/\/ printf(\"%lu %lX\\n\", (uint64_t)val[i], (uint64_t)val[i]);\n@@ -348,1 +367,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_lr_sc) {\n@@ -355,1 +374,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_maybe_zacas) {\n@@ -357,0 +376,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -358,0 +379,1 @@\n+    UseZabha = zabha;\n@@ -361,1 +383,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_lr_sc) {\n@@ -368,1 +390,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_maybe_zacas) {\n@@ -370,0 +392,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -371,0 +395,1 @@\n+    UseZabha = zabha;\n@@ -489,1 +514,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_concurrent_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_concurrent_lr_sc) {\n@@ -497,1 +522,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int16_concurrent_maybe_zacas) {\n@@ -499,0 +524,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -501,0 +528,1 @@\n+    UseZabha = zabha;\n@@ -504,1 +532,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_concurrent_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_concurrent_lr_sc) {\n@@ -512,1 +540,1 @@\n-TEST_VM(RiscV, cmpxchg_int8_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_narrow_int8_concurrent_maybe_zacas) {\n@@ -514,0 +542,17 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_concurrent_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int16_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_concurrent_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n@@ -537,1 +582,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -557,1 +602,1 @@\n-    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+    if (using_narrow<ASMSIZE>()) {\n@@ -627,1 +672,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_lr_sc) {\n@@ -634,1 +679,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_lr_sc) {\n@@ -641,1 +686,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_maybe_zacas) {\n@@ -643,0 +688,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -644,0 +691,1 @@\n+    UseZabha = zabha;\n@@ -647,1 +695,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_maybe_zacas) {\n@@ -649,0 +697,15 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n@@ -727,1 +790,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_concurrent_lr_sc) {\n@@ -735,1 +798,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int16_concurrent_maybe_zacas) {\n@@ -737,0 +800,2 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n@@ -739,0 +804,1 @@\n+    UseZabha = zabha;\n@@ -742,1 +808,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_concurrent_lr_sc) {\n@@ -750,1 +816,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_narrow_int8_concurrent_maybe_zacas) {\n@@ -752,0 +818,17 @@\n+    bool zabha = UseZabha;\n+    UseZabha = false;\n+    run_concurrent_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    UseZabha = zabha;\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n+    run_concurrent_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_maybe_zacas_zabha) {\n+  if (UseZacas && UseZabha) {\n","filename":"test\/hotspot\/gtest\/riscv\/test_assembler_riscv.cpp","additions":113,"deletions":30,"binary":false,"changes":143,"status":"modified"}]}