{"files":[{"patch":"@@ -225,0 +225,10 @@\n+    \/**\n+     * The overflow threshold (for round to nearest) is MAX_VALUE + 1\/2 ulp.\n+     *\/\n+    private static final double OVERFLOW_THRESH = 0x1.ffcp15 + 0x0.002p15;\n+\n+    \/**\n+     * The underflow threshold (for round to nearest) is MIN_VALUE * 0.5.\n+     *\/\n+    private static final double UNDERFLOW_THRESH = 0x1.0p-24d * 0.5d;\n+\n@@ -343,4 +353,0 @@\n-        long doppel = Double.doubleToRawLongBits(d);\n-\n-        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> 48);\n-\n@@ -353,0 +359,2 @@\n+        long doppel = Double.doubleToRawLongBits(d);\n+        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> (64 - 16));\n@@ -355,2 +363,1 @@\n-        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n-        if (abs_d >= (0x1.ffcp15 + 0x0.002p15) ) {\n+        if (abs_d >= OVERFLOW_THRESH) {\n@@ -361,4 +368,3 @@\n-        \/\/ Smallest magnitude nonzero representable binary16 value\n-        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n-        if (abs_d <= 0x1.0p-24d * 0.5d) { \/\/ Covers double zeros and subnormals.\n-            return new Float16(sign_bit); \/\/ Positive or negative zero\n+        if (abs_d <= UNDERFLOW_THRESH) { \/\/ Covers double zeros and subnormals.\n+            \/\/ positive or negative zero\n+            return new Float16(sign_bit);\n@@ -370,5 +376,8 @@\n-        assert -25 <= exp && exp <= 15;\n-\n-        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n-        \/\/ the difference expdelta = E_min - exp.  This is the excess\n-        \/\/ shift value, in addition to 42, to be used in the\n+        assert\n+            (MIN_EXPONENT - PRECISION) <= exp &&\n+            exp <= MAX_EXPONENT;\n+\n+        \/\/ For target format subnormals, beside forcing exp to\n+        \/\/ MIN_EXPONENT-1, retain the difference expdelta = E_min -\n+        \/\/ exp.  This is the excess shift value, in addition to the\n+        \/\/ difference in precision bits, to be used in the\n@@ -379,4 +388,4 @@\n-        if (exp < -14) {\n-            expdelta = -14 - exp; \/\/ FIXME?\n-            exp = -15;\n-            msb = 0x0010_0000_0000_0000L; \/\/ should be 0x0020_... ?\n+        if (exp < MIN_EXPONENT) {\n+            expdelta = MIN_EXPONENT - exp;\n+            exp = MIN_EXPONENT - 1;\n+            msb = 0x0010_0000_0000_0000L;\n@@ -386,0 +395,1 @@\n+        int PRECISION_DIFF = Double.PRECISION - PRECISION; \/\/ 42\n@@ -387,1 +397,1 @@\n-        short signif_bits = (short)(f_signif_bits >> (42 + expdelta));\n+        short signif_bits = (short)(f_signif_bits >> (PRECISION_DIFF + expdelta));\n@@ -402,3 +412,3 @@\n-        long lsb    = f_signif_bits & (1L << 42 + expdelta);\n-        long round  = f_signif_bits & (1L << 41 + expdelta);\n-        long sticky = f_signif_bits & ((1L << 41 + expdelta) - 1);\n+        long lsb    = f_signif_bits &  (1L << (PRECISION_DIFF      + expdelta));\n+        long round  = f_signif_bits &  (1L << (PRECISION_DIFF - 1) + expdelta);\n+        long sticky = f_signif_bits & ((1L << (PRECISION_DIFF - 1) + expdelta) - 1);\n@@ -415,1 +425,3 @@\n-        return new Float16((short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) ));\n+        \/\/ Exponent bias adjust in the representation is equal to MAX_EXPONENT.\n+        return new Float16((short)(sign_bit |\n+                                   ( ((exp + MAX_EXPONENT) << (PRECISION - 1)) + signif_bits ) ));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"}]}