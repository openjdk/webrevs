{"files":[{"patch":"@@ -38,0 +38,1 @@\n+include gensrc\/GensrcScopedMemoryAccess.gmk\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+SCOPED_MEMORY_ACCESS_GENSRC_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/misc\n+SCOPED_MEMORY_ACCESS_SRC_DIR := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\n+SCOPED_MEMORY_ACCESS_TEMPLATE := $(SCOPED_MEMORY_ACCESS_SRC_DIR)\/X-ScopedMemoryAccess.java.template\n+SCOPED_MEMORY_ACCESS_BIN_TEMPLATE := $(SCOPED_MEMORY_ACCESS_SRC_DIR)\/X-ScopedMemoryAccess-bin.java.template\n+SCOPED_MEMORY_ACCESS_DEST := $(SCOPED_MEMORY_ACCESS_GENSRC_DIR)\/ScopedMemoryAccess.java\n+\n+################################################################################\n+# Setup a rule for generating the ScopedMemoryAccess java class\n+# Param 1 - Variable declaration prefix\n+# Param 2 - Type with first letter capitalized\n+define GenerateScopedOp\n+\n+  $1_Type := $2\n+\n+  ifeq ($$($1_Type), Byte)\n+    $1_type := byte\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -Kbyte\n+  endif\n+\n+  ifeq ($$($1_Type), Short)\n+    $1_type := short\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Char)\n+    $1_type := char\n+    $1_BoxType := Character\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Int)\n+    $1_type := int\n+    $1_BoxType := Integer\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KAtomicAdd\n+    $1_ARGS += -KBitwise\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Long)\n+    $1_type := long\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KAtomicAdd\n+    $1_ARGS += -KBitwise\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Float)\n+    $1_type := float\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := int\n+    $1_RawType := Int\n+    $1_RawBoxType := Integer\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KfloatingPoint\n+  endif\n+\n+  ifeq ($$($1_Type), Double)\n+    $1_type := double\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := long\n+    $1_RawType := Long\n+    $1_RawBoxType := Long\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KfloatingPoint\n+  endif\n+\n+  ifneq ($$(findstring $$($1_Type), Byte Short Char Int Long Float Double), )\n+    $1_ARGS += -KAtomicAdd\n+  endif\n+\n+  ifneq ($$(findstring $$($1_Type), Boolean Byte Short Char Int Long), )\n+    $1_ARGS += -KBitwise\n+  endif\n+\n+  ifneq ($$(findstring $$($1_Type), Byte Short Char), )\n+    $1_ARGS += -KShorterThanInt\n+  endif\n+endef\n+\n+################################################################################\n+# Setup a rule for generating the ScopedMemoryAccess java class\n+\n+SCOPE_MEMORY_ACCESS_TYPES := Byte Short Char Int Long Float Double\n+$(foreach t, $(SCOPE_MEMORY_ACCESS_TYPES), \\\n+  $(eval $(call GenerateScopedOp,BIN_$t,$t)))\n+\t\n+$(SCOPED_MEMORY_ACCESS_DEST): $(BUILD_TOOLS_JDK) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE)\n+\t$(call MakeDir, $(SCOPED_MEMORY_ACCESS_GENSRC_DIR))\n+\t$(CP) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(SCOPED_MEMORY_ACCESS_DEST)\n+\t$(foreach t, $(SCOPE_MEMORY_ACCESS_TYPES), \\\n+\t  $(TOOL_SPP) -nel -K$(BIN_$t_type) -Dtype=$(BIN_$t_type) -DType=$(BIN_$t_Type) $(BIN_$t_ARGS) \\\n+\t  -i$(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE) -o$(SCOPED_MEMORY_ACCESS_DEST) ;)\n+\t$(PRINTF) \"}\\n\" >> $(SCOPED_MEMORY_ACCESS_DEST)\n+\t\n+TARGETS += $(SCOPED_MEMORY_ACCESS_DEST)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcScopedMemoryAccess.gmk","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -1089,0 +1089,1 @@\n+    _method_Scoped,\n@@ -2123,0 +2124,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_misc_Scoped_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_Scoped;\n+    }\n@@ -2180,0 +2186,2 @@\n+  if (has_annotation(_method_Scoped))\n+    m->set_scoped(true);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -305,0 +305,1 @@\n+  template(jdk_internal_misc_Scoped_signature,               \"Ljdk\/internal\/misc\/ScopedMemoryAccess$Scoped;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    _reserved_stack_access = 1 << 7\n+    _reserved_stack_access = 1 << 7,\n+    _scoped                = 1 << 8\n@@ -904,0 +905,8 @@\n+  bool is_scoped() const {\n+    return (_flags & _scoped) != 0;\n+  }\n+\n+  void set_scoped(bool x) {\n+    _flags = x ? (_flags | _scoped) : (_flags & ~_scoped);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"prims\/scopedMemoryAccess.hpp\"\n@@ -242,0 +243,1 @@\n+  { CC\"Java_jdk_internal_misc_ScopedMemoryAccess_registerNatives\", NULL, FN_PTR(JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods) },\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"prims\/stackwalk.hpp\"\n+\n+\n+class CloseScopedMemoryFindOopClosure : public OopClosure {\n+  oop _deopt;\n+  bool _found;\n+\n+public:\n+  CloseScopedMemoryFindOopClosure(jobject deopt) :\n+      _deopt(JNIHandles::resolve(deopt)),\n+      _found(false) {}\n+\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    if (_found) {\n+      return;\n+    }\n+    if (RawAccess<>::oop_load(p) == _deopt) {\n+      _found = true;\n+    }\n+  }\n+\n+  virtual void do_oop(oop* p) {\n+    do_oop_work(p);\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    do_oop_work(p);\n+  }\n+\n+  bool found() {\n+    return _found;\n+  }\n+};\n+\n+class CloseScopedMemoryClosure : public HandshakeClosure {\n+  jobject _deopt;\n+  jobject _exception;\n+\n+public:\n+  jboolean _found;\n+\n+  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+    : HandshakeClosure(\"CloseScopedMemory\")\n+    , _deopt(deopt)\n+    , _exception(exception)\n+    , _found(false) {}\n+\n+  void do_thread(Thread* thread) {\n+\n+    JavaThread* jt = (JavaThread*)thread;\n+\n+    if (!jt->has_last_Java_frame()) {\n+      return;\n+    }\n+\n+    frame last_frame = jt->last_frame();\n+    RegisterMap register_map(jt, true);\n+\n+    if (last_frame.is_safepoint_blob_frame()) {\n+      last_frame = last_frame.sender(&register_map);\n+    }\n+\n+    ResourceMark rm;\n+    if (_deopt != NULL && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      CloseScopedMemoryFindOopClosure cl(_deopt);\n+      CompiledMethod* cm = last_frame.cb()->as_compiled_method();\n+\n+      \/* FIXME: this doesn't work if reachability fences are violated by C2\n+      last_frame.oops_do(&cl, NULL, &register_map);\n+      if (cl.found()) {\n+           \/\/Found the deopt oop in a compiled method; deoptimize.\n+           Deoptimization::deoptimize(jt, last_frame);\n+      }\n+      so... we unconditionally deoptimize, for now: *\/\n+      Deoptimization::deoptimize(jt, last_frame);\n+    }\n+\n+    const int max_critical_stack_depth = 10;\n+    int depth = 0;\n+    for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n+      Method* m = stream.method();\n+      if (m->is_scoped()) {\n+        StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+        for (int i = 0; i < locals->size(); i++) {\n+          StackValue* var = locals->at(i);\n+          if (var->type() == T_OBJECT) {\n+            if (var->get_obj() == JNIHandles::resolve(_deopt)) {\n+              assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+              _found = true;\n+              return;\n+            }\n+          }\n+        }\n+        break;\n+      }\n+      depth++;\n+#ifndef ASSERT\n+      if (depth >= max_critical_stack_depth) {\n+        break;\n+      }\n+#endif\n+    }\n+  }\n+};\n+\n+\/*\n+ * This function issues a global handshake operation with all\n+ * Java threads. This is useful for implementing asymmetric\n+ * dekker synchronization schemes, where expensive synchronization\n+ * in performance sensitive common paths, may be shifted to\n+ * a less common slow path instead.\n+ * Top frames containg obj will be deoptimized.\n+ *\/\n+JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n+  CloseScopedMemoryClosure cl(deopt, exception);\n+  Handshake::execute(&cl);\n+  return !cl._found;\n+JVM_END\n+\n+\/\/\/ JVM_RegisterUnsafeMethods\n+\n+#define PKG \"Ljdk\/internal\/misc\/\"\n+\n+#define MEMACCESS \"ScopedMemoryAccess\"\n+#define SCOPE PKG MEMACCESS \"$Scope;\"\n+#define SCOPED_ERR PKG MEMACCESS \"$Scope$ScopedAccessError;\"\n+\n+#define CC (char*)  \/*cast a literal from (const char*)*\/\n+#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &f)\n+\n+static JNINativeMethod jdk_internal_misc_ScopedMemoryAccess_methods[] = {\n+    {CC \"closeScope0\",   CC \"(\" SCOPE SCOPED_ERR \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+};\n+\n+#undef CC\n+#undef FN_PTR\n+\n+#undef PKG\n+#undef MEMACCESS\n+#undef SCOPE\n+#undef SCOPED_EXC\n+\n+\/\/ This function is exported, used by NativeLookup.\n+\n+JVM_ENTRY(void, JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jclass scopedMemoryAccessClass))\n+  ThreadToNativeFromVM ttnfv(thread);\n+\n+  int ok = env->RegisterNatives(scopedMemoryAccessClass, jdk_internal_misc_ScopedMemoryAccess_methods, sizeof(jdk_internal_misc_ScopedMemoryAccess_methods)\/sizeof(JNINativeMethod));\n+  guarantee(ok == 0, \"register jdk.internal.misc.ScopedMemoryAccess natives\");\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#ifndef SHARE_PRIMS_SCOPED_MEMORY_ACCESS_HPP\n+#define SHARE_PRIMS_SCOPED_MEMORY_ACCESS_HPP\n+\n+#include \"jni.h\"\n+\n+extern \"C\" {\n+  void JNICALL JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jobject rec, jobject scope, jthrowable exception);\n+}\n+\n+#endif \/\/ SHARE_PRIMS_SCOPED_MEMORY_ACCESS_HPP\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -39,3 +39,0 @@\n-    \/** access offset (in bytes); must be compatible with {@code alignmentMask} **\/\n-    final long offset;\n-\n@@ -45,1 +42,4 @@\n-    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long offset, long alignmentMask) {\n+    \/** if true, only the base part of the address will be checked for alignment **\/\n+    final boolean skipAlignmentMaskCheck;\n+\n+    MemoryAccessVarHandleBase(VarForm form, boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {\n@@ -47,0 +47,1 @@\n+        this.skipAlignmentMaskCheck = skipAlignmentMaskCheck;\n@@ -49,1 +50,0 @@\n-        this.offset = offset;\n@@ -56,7 +56,0 @@\n-\n-    \/**\n-     * Strides used for multi-dimensional access; each stride must be compatible with {@code alignmentMask}.\n-     *\/\n-    abstract long[] strides();\n-\n-    abstract Class<?> carrier();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,510 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.invoke;\n-\n-import jdk.internal.access.foreign.MemoryAddressProxy;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ConstantDynamic;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.util.TraceClassVisitor;\n-import jdk.internal.vm.annotation.ForceInline;\n-import sun.security.action.GetBooleanAction;\n-import sun.security.action.GetPropertyAction;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-\n-import static jdk.internal.org.objectweb.asm.Opcodes.AALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.BIPUSH;\n-import static jdk.internal.org.objectweb.asm.Opcodes.CHECKCAST;\n-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_3;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ILOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.LALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.LASTORE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.LLOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.NEWARRAY;\n-import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.PUTSTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;\n-import static jdk.internal.org.objectweb.asm.Opcodes.SIPUSH;\n-import static jdk.internal.org.objectweb.asm.Opcodes.T_LONG;\n-import static jdk.internal.org.objectweb.asm.Opcodes.V14;\n-\n-class MemoryAccessVarHandleGenerator {\n-    private static final String DEBUG_DUMP_CLASSES_DIR_PROPERTY = \"jdk.internal.foreign.ClassGenerator.DEBUG_DUMP_CLASSES_DIR\";\n-\n-    private static final boolean DEBUG =\n-        GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.ClassGenerator.DEBUG\");\n-\n-    private static final Class<?> BASE_CLASS = MemoryAccessVarHandleBase.class;\n-\n-    private static final HashMap<Class<?>, Class<?>> helperClassCache;\n-\n-    private final static MethodType OFFSET_OP_TYPE;\n-\n-    private final static MethodHandle ADD_OFFSETS_HANDLE;\n-    private final static MethodHandle MUL_OFFSETS_HANDLE;\n-\n-    static {\n-        helperClassCache = new HashMap<>();\n-        helperClassCache.put(byte.class, MemoryAccessVarHandleByteHelper.class);\n-        helperClassCache.put(short.class, MemoryAccessVarHandleShortHelper.class);\n-        helperClassCache.put(char.class, MemoryAccessVarHandleCharHelper.class);\n-        helperClassCache.put(int.class, MemoryAccessVarHandleIntHelper.class);\n-        helperClassCache.put(long.class, MemoryAccessVarHandleLongHelper.class);\n-        helperClassCache.put(float.class, MemoryAccessVarHandleFloatHelper.class);\n-        helperClassCache.put(double.class, MemoryAccessVarHandleDoubleHelper.class);\n-\n-        OFFSET_OP_TYPE = MethodType.methodType(long.class, long.class, long.class, MemoryAddressProxy.class);\n-\n-        try {\n-            ADD_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, \"addOffsets\", OFFSET_OP_TYPE);\n-            MUL_OFFSETS_HANDLE = MethodHandles.Lookup.IMPL_LOOKUP.findStatic(MemoryAddressProxy.class, \"multiplyOffsets\", OFFSET_OP_TYPE);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    private static final File DEBUG_DUMP_CLASSES_DIR;\n-\n-    static {\n-        String path = GetPropertyAction.privilegedGetProperty(DEBUG_DUMP_CLASSES_DIR_PROPERTY);\n-        if (path == null) {\n-            DEBUG_DUMP_CLASSES_DIR = null;\n-        } else {\n-            DEBUG_DUMP_CLASSES_DIR = new File(path);\n-        }\n-    }\n-\n-    private final String implClassName;\n-    private final int dimensions;\n-    private final Class<?> carrier;\n-    private final Class<?> helperClass;\n-    private final VarForm form;\n-    private final Object[] classData;\n-\n-    MemoryAccessVarHandleGenerator(Class<?> carrier, int dims) {\n-        this.dimensions = dims;\n-        this.carrier = carrier;\n-        Class<?>[] components = new Class<?>[dimensions];\n-        Arrays.fill(components, long.class);\n-        this.form = new VarForm(BASE_CLASS, MemoryAddressProxy.class, carrier, components);\n-        this.helperClass = helperClassCache.get(carrier);\n-        this.implClassName = helperClass.getName().replace('.', '\/') + dimensions;\n-        \/\/ live constants\n-        Class<?>[] intermediate = new Class<?>[dimensions];\n-        Arrays.fill(intermediate, long.class);\n-        this.classData = new Object[] { carrier, intermediate, ADD_OFFSETS_HANDLE, MUL_OFFSETS_HANDLE };\n-    }\n-\n-    \/*\n-     * Generate a VarHandle memory access factory.\n-     * The factory has type (ZJJ[J)VarHandle.\n-     *\/\n-    MethodHandle generateHandleFactory() {\n-        byte[] classBytes = generateClassBytes();\n-        if (DEBUG_DUMP_CLASSES_DIR != null) {\n-            debugWriteClassToFile(classBytes);\n-        }\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClassWithClassData(classBytes, classData);\n-            Class<?> implCls = lookup.lookupClass();\n-            Class<?>[] components = new Class<?>[dimensions];\n-            Arrays.fill(components, long.class);\n-\n-            VarForm form = new VarForm(implCls, MemoryAddressProxy.class, carrier, components);\n-\n-            MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);\n-            MethodHandle constr = lookup.findConstructor(implCls, constrType);\n-            constr = MethodHandles.insertArguments(constr, 0, form);\n-            return constr;\n-        } catch (Throwable ex) {\n-            debugPrintClass(classBytes);\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    \/*\n-     * Generate a specialized VarHandle class for given carrier\n-     * and access coordinates.\n-     *\/\n-    byte[] generateClassBytes() {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n-\n-        if (DEBUG) {\n-            System.out.println(\"Generating header implementation class\");\n-        }\n-\n-        cw.visit(V14, ACC_PUBLIC | ACC_SUPER, implClassName, null, Type.getInternalName(BASE_CLASS), null);\n-\n-        \/\/add dimension fields\n-        for (int i = 0; i < dimensions; i++) {\n-            cw.visitField(ACC_PRIVATE | ACC_FINAL, \"dim\" + i, \"J\", null, null);\n-        }\n-\n-        addStaticInitializer(cw);\n-\n-        addConstructor(cw);\n-\n-        addAccessModeTypeMethod(cw);\n-\n-        addStridesAccessor(cw);\n-\n-        addCarrierAccessor(cw);\n-\n-        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {\n-            addAccessModeMethodIfNeeded(mode, cw);\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n-    }\n-\n-    void addStaticInitializer(ClassWriter cw) {\n-        \/\/ carrier and intermediate\n-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, \"carrier\", Class.class.descriptorString(), null, null);\n-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, \"intermediate\", Class[].class.descriptorString(), null, null);\n-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, \"addHandle\", MethodHandle.class.descriptorString(), null, null);\n-        cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, \"mulHandle\", MethodHandle.class.descriptorString(), null, null);\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        mv.visitCode();\n-        \/\/ extract class data in static final fields\n-        MethodType mtype = MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n-        Handle bsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n-                    mtype.descriptorString(), false);\n-        ConstantDynamic dynamic = new ConstantDynamic(\"classData\", Object[].class.descriptorString(), bsm);\n-        mv.visitLdcInsn(dynamic);\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Object[].class));\n-        mv.visitVarInsn(ASTORE, 0);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));\n-        mv.visitFieldInsn(PUTSTATIC, implClassName, \"carrier\", Class.class.descriptorString());\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_1);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class[].class));\n-        mv.visitFieldInsn(PUTSTATIC, implClassName, \"intermediate\", Class[].class.descriptorString());\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_2);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));\n-        mv.visitFieldInsn(PUTSTATIC, implClassName, \"addHandle\", MethodHandle.class.descriptorString());\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_3);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));\n-        mv.visitFieldInsn(PUTSTATIC, implClassName, \"mulHandle\", MethodHandle.class.descriptorString());\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    void addConstructor(ClassWriter cw) {\n-        MethodType constrType = MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class, long[].class);\n-        MethodVisitor mv = cw.visitMethod(0, \"<init>\", constrType.toMethodDescriptorString(), null, null);\n-        mv.visitCode();\n-        \/\/super call\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(VarForm.class));\n-        mv.visitVarInsn(ILOAD, 2);\n-        mv.visitVarInsn(LLOAD, 3);\n-        mv.visitVarInsn(LLOAD, 5);\n-        mv.visitVarInsn(LLOAD, 7);\n-        mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(BASE_CLASS), \"<init>\",\n-                MethodType.methodType(void.class, VarForm.class, boolean.class, long.class, long.class, long.class).toMethodDescriptorString(), false);\n-        \/\/init dimensions\n-        for (int i = 0 ; i < dimensions ; i++) {\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitVarInsn(ALOAD, 9);\n-            mv.visitLdcInsn(i);\n-            mv.visitInsn(LALOAD);\n-            mv.visitFieldInsn(PUTFIELD, implClassName, \"dim\" + i, \"J\");\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    void addAccessModeTypeMethod(ClassWriter cw) {\n-        MethodType modeMethType = MethodType.methodType(MethodType.class, VarHandle.AccessMode.class);\n-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, \"accessModeTypeUncached\", modeMethType.toMethodDescriptorString(), null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitFieldInsn(GETFIELD, Type.getInternalName(VarHandle.AccessMode.class), \"at\", VarHandle.AccessType.class.descriptorString());\n-        mv.visitLdcInsn(Type.getType(MemoryAddressProxy.class));\n-        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Class.class));\n-        mv.visitFieldInsn(GETSTATIC, implClassName, \"carrier\", Class.class.descriptorString());\n-        mv.visitFieldInsn(GETSTATIC, implClassName, \"intermediate\", Class[].class.descriptorString());\n-\n-        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(VarHandle.AccessType.class),\n-                \"accessModeType\", MethodType.methodType(MethodType.class, Class.class, Class.class, Class[].class).toMethodDescriptorString(), false);\n-\n-        mv.visitInsn(ARETURN);\n-\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    void addAccessModeMethodIfNeeded(VarHandle.AccessMode mode, ClassWriter cw) {\n-        String methName = mode.methodName();\n-        MethodType methType = form.getMethodType(mode.at.ordinal())\n-                .insertParameterTypes(0, VarHandle.class);\n-\n-        try {\n-            MethodType helperType = methType.insertParameterTypes(2, long.class);\n-            if (dimensions > 0) {\n-                helperType = helperType.dropParameterTypes(3, 3 + dimensions);\n-            }\n-            \/\/try to resolve...\n-            String helperMethodName = methName + \"0\";\n-            MethodHandles.Lookup.IMPL_LOOKUP\n-                    .findStatic(helperClass,\n-                            helperMethodName,\n-                            helperType);\n-\n-\n-            MethodVisitor mv = cw.visitMethod(ACC_STATIC, methName, methType.toMethodDescriptorString(), null, null);\n-            mv.visitAnnotation(Type.getDescriptor(ForceInline.class), true);\n-            mv.visitCode();\n-\n-            mv.visitVarInsn(ALOAD, 0); \/\/ handle impl\n-            mv.visitVarInsn(ALOAD, 1); \/\/ receiver\n-\n-            \/\/ offset calculation\n-            int slot = 2;\n-            mv.visitVarInsn(ALOAD, 0); \/\/ load recv\n-            mv.visitTypeInsn(CHECKCAST, Type.getInternalName(BASE_CLASS));\n-            mv.visitFieldInsn(GETFIELD, Type.getInternalName(BASE_CLASS), \"offset\", \"J\");\n-            for (int i = 0 ; i < dimensions ; i++) {\n-                \/\/ load ADD MH\n-                mv.visitFieldInsn(GETSTATIC, implClassName, \"addHandle\", MethodHandle.class.descriptorString());\n-\n-                \/\/fixup stack so that ADD MH ends up bottom\n-                mv.visitInsn(Opcodes.DUP_X2);\n-                mv.visitInsn(Opcodes.POP);\n-\n-                \/\/ load MUL MH\n-                mv.visitFieldInsn(GETSTATIC, implClassName, \"mulHandle\", MethodHandle.class.descriptorString());\n-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MethodHandle.class));\n-\n-                mv.visitVarInsn(ALOAD, 0); \/\/ load recv\n-                mv.visitTypeInsn(CHECKCAST, implClassName);\n-                mv.visitFieldInsn(GETFIELD, implClassName, \"dim\" + i, \"J\");\n-                mv.visitVarInsn(LLOAD, slot);\n-\n-                mv.visitVarInsn(ALOAD, 1); \/\/ receiver\n-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));\n-\n-                \/\/MUL\n-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), \"invokeExact\",\n-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);\n-\n-                mv.visitVarInsn(ALOAD, 1); \/\/ receiver\n-                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(MemoryAddressProxy.class));\n-\n-                \/\/ADD\n-                mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(MethodHandle.class), \"invokeExact\",\n-                        OFFSET_OP_TYPE.toMethodDescriptorString(), false);\n-                slot += 2;\n-            }\n-\n-            for (int i = 2 + dimensions; i < methType.parameterCount() ; i++) {\n-                Class<?> param = methType.parameterType(i);\n-                mv.visitVarInsn(loadInsn(param), slot); \/\/ load index\n-                slot += getSlotsForType(param);\n-            }\n-\n-            \/\/call helper\n-            mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(helperClass), helperMethodName,\n-                    helperType.toMethodDescriptorString(), false);\n-\n-            mv.visitInsn(returnInsn(helperType.returnType()));\n-\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-        } catch (ReflectiveOperationException ex) {\n-            \/\/not found, skip\n-        }\n-    }\n-\n-    void addStridesAccessor(ClassWriter cw) {\n-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, \"strides\", \"()[J\", null, null);\n-        mv.visitCode();\n-        iConstInsn(mv, dimensions);\n-        mv.visitIntInsn(NEWARRAY, T_LONG);\n-\n-        for (int i = 0 ; i < dimensions ; i++) {\n-            mv.visitInsn(DUP);\n-            iConstInsn(mv, i);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, implClassName, \"dim\" + i, \"J\");\n-            mv.visitInsn(LASTORE);\n-        }\n-\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    void addCarrierAccessor(ClassWriter cw) {\n-        MethodVisitor mv = cw.visitMethod(ACC_FINAL, \"carrier\", \"()Ljava\/lang\/Class;\", null, null);\n-        mv.visitCode();\n-        mv.visitFieldInsn(GETSTATIC, implClassName, \"carrier\", Class.class.descriptorString());\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    \/\/ shared code generation helpers\n-\n-    private static int getSlotsForType(Class<?> c) {\n-        if (c == long.class || c == double.class) {\n-            return 2;\n-        }\n-        return 1;\n-    }\n-\n-    \/**\n-     * Emits an actual return instruction conforming to the given return type.\n-     *\/\n-    private int returnInsn(Class<?> type) {\n-        return switch (LambdaForm.BasicType.basicType(type)) {\n-            case I_TYPE -> Opcodes.IRETURN;\n-            case J_TYPE -> Opcodes.LRETURN;\n-            case F_TYPE -> Opcodes.FRETURN;\n-            case D_TYPE -> Opcodes.DRETURN;\n-            case L_TYPE -> Opcodes.ARETURN;\n-            case V_TYPE -> RETURN;\n-        };\n-    }\n-\n-    private int loadInsn(Class<?> type) {\n-        return switch (LambdaForm.BasicType.basicType(type)) {\n-            case I_TYPE -> Opcodes.ILOAD;\n-            case J_TYPE -> LLOAD;\n-            case F_TYPE -> Opcodes.FLOAD;\n-            case D_TYPE -> Opcodes.DLOAD;\n-            case L_TYPE -> Opcodes.ALOAD;\n-            case V_TYPE -> throw new IllegalStateException(\"Cannot load void\");\n-        };\n-    }\n-\n-    private static void iConstInsn(MethodVisitor mv, int i) {\n-        switch (i) {\n-            case -1, 0, 1, 2, 3, 4, 5:\n-                mv.visitInsn(ICONST_0 + i);\n-                break;\n-            default:\n-                if(i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {\n-                    mv.visitIntInsn(BIPUSH, i);\n-                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {\n-                    mv.visitIntInsn(SIPUSH, i);\n-                } else {\n-                    mv.visitLdcInsn(i);\n-                }\n-        }\n-    }\n-\n-    \/\/ debug helpers\n-\n-    private static String debugPrintClass(byte[] classFile) {\n-        ClassReader cr = new ClassReader(classFile);\n-        StringWriter sw = new StringWriter();\n-        cr.accept(new TraceClassVisitor(new PrintWriter(sw)), 0);\n-        return sw.toString();\n-    }\n-\n-    private void debugWriteClassToFile(byte[] classFile) {\n-        File file = new File(DEBUG_DUMP_CLASSES_DIR, implClassName + \".class\");\n-\n-        if (DEBUG) {\n-            System.err.println(\"Dumping class \" + implClassName + \" to \" + file);\n-        }\n-\n-        try {\n-            debugWriteDataToFile(classFile, file);\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Failed to write class \" + implClassName + \" to file \" + file);\n-        }\n-    }\n-\n-    private void debugWriteDataToFile(byte[] data, File file) {\n-        if (file.exists()) {\n-            file.delete();\n-        }\n-        if (file.exists()) {\n-            throw new RuntimeException(\"Failed to remove pre-existing file \" + file);\n-        }\n-\n-        File parent = file.getParentFile();\n-        if (!parent.exists()) {\n-            parent.mkdirs();\n-        }\n-        if (!parent.exists()) {\n-            throw new RuntimeException(\"Failed to create \" + parent);\n-        }\n-        if (!parent.isDirectory()) {\n-            throw new RuntimeException(parent + \" is not a directory\");\n-        }\n-\n-        try (FileOutputStream fos = new FileOutputStream(file)) {\n-            fos.write(data);\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Failed to write class \" + implClassName + \" to file \" + file);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleGenerator.java","additions":0,"deletions":510,"binary":false,"changes":510,"status":"deleted"},{"patch":"@@ -1772,34 +1772,3 @@\n-            public VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,\n-                                                   ByteOrder order, long offset, long[] strides) {\n-                return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);\n-            }\n-\n-            @Override\n-            public Class<?> memoryAddressCarrier(VarHandle handle) {\n-                return checkMemoryAccessHandle(handle).carrier();\n-            }\n-\n-            @Override\n-            public long memoryAddressAlignmentMask(VarHandle handle) {\n-                return checkMemoryAccessHandle(handle).alignmentMask;\n-            }\n-\n-            @Override\n-            public ByteOrder memoryAddressByteOrder(VarHandle handle) {\n-                return checkMemoryAccessHandle(handle).be ?\n-                        ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n-            }\n-\n-            @Override\n-            public long memoryAddressOffset(VarHandle handle) {\n-                return checkMemoryAccessHandle(handle).offset;\n-            }\n-\n-            @Override\n-            public long[] memoryAddressStrides(VarHandle handle) {\n-                return checkMemoryAccessHandle(handle).strides();\n-            }\n-\n-            @Override\n-            public boolean isMemoryAccessVarHandle(VarHandle handle) {\n-                return asMemoryAccessVarHandle(handle) != null;\n+            public VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,\n+                                                   ByteOrder order) {\n+                return VarHandles.makeMemoryAddressViewHandle(carrier, skipAlignmentMaskCheck, alignmentMask, order);\n@@ -1837,20 +1806,0 @@\n-\n-            private MemoryAccessVarHandleBase asMemoryAccessVarHandle(VarHandle handle) {\n-                if (handle instanceof MemoryAccessVarHandleBase) {\n-                    return (MemoryAccessVarHandleBase)handle;\n-                } else if (handle.target() instanceof MemoryAccessVarHandleBase) {\n-                    \/\/ skip first adaptation, since we have to step over MemoryAddressProxy\n-                    \/\/ see JDK-8237349\n-                    return (MemoryAccessVarHandleBase)handle.target();\n-                } else {\n-                    return null;\n-                }\n-            }\n-\n-            private MemoryAccessVarHandleBase checkMemoryAccessHandle(VarHandle handle) {\n-                MemoryAccessVarHandleBase base = asMemoryAccessVarHandle(handle);\n-                if (base == null) {\n-                    throw new IllegalArgumentException(\"Not a memory access varhandle: \" + handle);\n-                }\n-                return base;\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":3,"deletions":54,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -314,0 +314,1 @@\n+     * @param skipAlignmentMaskCheck if true, only the base part of the address will be checked for alignment.\n@@ -316,2 +317,0 @@\n-     * @param offset a constant offset for the access.\n-     * @param strides the scale factors with which to multiply given access coordinates.\n@@ -320,2 +319,2 @@\n-    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, long alignmentMask,\n-                                                 ByteOrder byteOrder, long offset, long[] strides) {\n+    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,\n+                                                 ByteOrder byteOrder) {\n@@ -328,9 +327,16 @@\n-        Map<Integer, MethodHandle> carrierFactory = ADDRESS_FACTORIES.get(carrier);\n-        MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,\n-                dims -> new MemoryAccessVarHandleGenerator(carrier, dims)\n-                            .generateHandleFactory());\n-\n-        try {\n-            return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));\n-        } catch (Throwable ex) {\n-            throw new IllegalStateException(ex);\n+        if (carrier == byte.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleByteHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == char.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleCharHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == short.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleShortHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == int.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleIntHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == float.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleFloatHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == long.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleLongHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == double.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleDoubleHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -44,1 +46,1 @@\n-    static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n@@ -47,0 +49,2 @@\n+    \n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -568,4 +572,1 @@\n-            MemorySegmentProxy segmentProxy = nioAccess.bufferSegment(bb);\n-            if (segmentProxy != null) {\n-                segmentProxy.checkValidState();\n-            }\n+            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n@@ -575,0 +576,7 @@\n+        @ForceInline\n+        static Scope scope(ByteBuffer bb) {\n+            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n+            return segmentProxy != null ?\n+                    segmentProxy.scope() : null;\n+        }\n+\n@@ -595,1 +603,1 @@\n-            $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(\n+            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(scope(bb),\n@@ -601,1 +609,1 @@\n-            return UNSAFE.get$Type$Unaligned(\n+            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(scope(bb),\n@@ -613,1 +621,1 @@\n-            UNSAFE.put$RawType$Unaligned(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(scope(bb),\n@@ -619,1 +627,1 @@\n-            UNSAFE.put$Type$Unaligned(\n+            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(scope(bb),\n@@ -632,1 +640,1 @@\n-                              UNSAFE.get$RawType$Volatile(\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb),\n@@ -641,1 +649,1 @@\n-            UNSAFE.put$RawType$Volatile(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(scope(bb),\n@@ -652,1 +660,1 @@\n-                              UNSAFE.get$RawType$Acquire(\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(scope(bb),\n@@ -661,1 +669,1 @@\n-            UNSAFE.put$RawType$Release(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Release(scope(bb),\n@@ -672,1 +680,1 @@\n-                              UNSAFE.get$RawType$Opaque(\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(scope(bb),\n@@ -681,1 +689,1 @@\n-            UNSAFE.put$RawType$Opaque(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(scope(bb),\n@@ -693,1 +701,1 @@\n-            return UNSAFE.compareAndSetReference(\n+            return SCOPED_MEMORY_ACCESS.compareAndSetReference(scope(bb),\n@@ -698,1 +706,1 @@\n-            return UNSAFE.compareAndSet$RawType$(\n+            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(scope(bb),\n@@ -710,1 +718,1 @@\n-                              UNSAFE.compareAndExchange$RawType$(\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(scope(bb),\n@@ -721,1 +729,1 @@\n-                              UNSAFE.compareAndExchange$RawType$Acquire(\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(scope(bb),\n@@ -732,1 +740,1 @@\n-                              UNSAFE.compareAndExchange$RawType$Release(\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(scope(bb),\n@@ -742,1 +750,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$Plain(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(scope(bb),\n@@ -752,1 +760,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(scope(bb),\n@@ -762,1 +770,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(scope(bb),\n@@ -772,1 +780,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(scope(bb),\n@@ -784,1 +792,1 @@\n-                              UNSAFE.getAndSetReference(\n+                              SCOPED_MEMORY_ACCESS.getAndSetReference(scope(bb),\n@@ -790,1 +798,1 @@\n-                              UNSAFE.getAndSet$RawType$(\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(scope(bb),\n@@ -802,1 +810,1 @@\n-                              UNSAFE.getAndSet$RawType$Acquire(\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(scope(bb),\n@@ -813,1 +821,1 @@\n-                              UNSAFE.getAndSet$RawType$Release(\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(scope(bb),\n@@ -826,1 +834,1 @@\n-                return UNSAFE.getAndAdd$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(scope(bb),\n@@ -840,1 +848,1 @@\n-                return UNSAFE.getAndAdd$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(scope(bb),\n@@ -854,1 +862,1 @@\n-                return UNSAFE.getAndAdd$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(scope(bb),\n@@ -869,1 +877,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -883,1 +891,1 @@\n-                return UNSAFE.getAndBitwiseOr$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(scope(bb),\n@@ -897,1 +905,1 @@\n-                return UNSAFE.getAndBitwiseOr$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(scope(bb),\n@@ -911,1 +919,1 @@\n-                return UNSAFE.getAndBitwiseOr$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(scope(bb),\n@@ -926,1 +934,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -938,1 +946,1 @@\n-                return UNSAFE.getAndBitwiseAnd$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(scope(bb),\n@@ -952,1 +960,1 @@\n-                return UNSAFE.getAndBitwiseAnd$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(scope(bb),\n@@ -966,1 +974,1 @@\n-                return UNSAFE.getAndBitwiseAnd$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(scope(bb),\n@@ -981,1 +989,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -994,1 +1002,1 @@\n-                return UNSAFE.getAndBitwiseXor$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(scope(bb),\n@@ -1008,1 +1016,1 @@\n-                return UNSAFE.getAndBitwiseXor$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(scope(bb),\n@@ -1022,1 +1030,1 @@\n-                return UNSAFE.getAndBitwiseXor$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(scope(bb),\n@@ -1037,1 +1045,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":52,"deletions":44,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import jdk.internal.access.foreign.MemoryAddressProxy;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -30,0 +31,2 @@\n+import java.lang.ref.Reference;\n+\n@@ -36,1 +39,1 @@\n-final class MemoryAccessVarHandle$Type$Helper {\n+final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {\n@@ -39,0 +42,2 @@\n+    \n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -42,0 +47,11 @@\n+    static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);\n+\n+    MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {\n+        super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask);\n+    }\n+\n+    @Override\n+    final MethodType accessModeTypeUncached(AccessMode accessMode) {\n+        return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);\n+    }\n+\n@@ -69,2 +85,2 @@\n-    static MemoryAddressProxy checkAddress(Object obb, long offset, long length, boolean ro) {\n-        MemoryAddressProxy oo = (MemoryAddressProxy)Objects.requireNonNull(obb);\n+    static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {\n+        MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);\n@@ -74,1 +90,1 @@\n-    \n+\n@@ -76,2 +92,2 @@\n-    static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {\n-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n+    static long offset(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {\n+        long address = offsetNoVMAlignCheck(skipAlignmentMaskCheck, bb, offset, alignmentMask);\n@@ -85,1 +101,1 @@\n-    static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {\n+    static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {\n@@ -88,3 +104,9 @@\n-        \/\/note: the offset portion has already been aligned-checked, by construction\n-        if ((base & alignmentMask) != 0) {\n-            throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+        if (skipAlignmentMaskCheck) {\n+            \/\/note: the offset portion has already been aligned-checked, by construction\n+            if ((base & alignmentMask) != 0) {\n+                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            }\n+        } else {\n+            if ((address & alignmentMask) != 0) {\n+                throw MemoryAccessVarHandleBase.newIllegalStateExceptionForMisalignedAccess(address);\n+            }\n@@ -94,1 +116,1 @@\n-    \n+\n@@ -96,1 +118,1 @@\n-    static $type$ get0(VarHandle ob, Object obb, long base) {\n+    static $type$ get(VarHandle ob, Object obb, long base) {\n@@ -98,1 +120,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n@@ -100,1 +122,1 @@\n-        $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(\n+        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.scope(),\n@@ -102,1 +124,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -107,1 +129,1 @@\n-        return UNSAFE.get$Type$(\n+        return SCOPED_MEMORY_ACCESS.get$Type$(bb.scope(),\n@@ -109,1 +131,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask));\n@@ -111,1 +133,1 @@\n-        return UNSAFE.get$Type$Unaligned(\n+        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.scope(),\n@@ -113,1 +135,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -120,1 +142,1 @@\n-    static void set0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -122,1 +144,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -124,1 +146,1 @@\n-        UNSAFE.put$RawType$Unaligned(\n+        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.scope(),\n@@ -126,1 +148,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -131,1 +153,1 @@\n-        UNSAFE.put$Type$(\n+        SCOPED_MEMORY_ACCESS.put$Type$(bb.scope(),\n@@ -133,1 +155,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -136,1 +158,1 @@\n-        UNSAFE.put$Type$Unaligned(\n+        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.scope(),\n@@ -138,1 +160,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -146,1 +168,1 @@\n-    static $type$ getVolatile0(VarHandle ob, Object obb, long base) {\n+    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n@@ -148,1 +170,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n@@ -150,1 +172,1 @@\n-                          UNSAFE.get$RawType$Volatile(\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),\n@@ -152,1 +174,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));\n@@ -156,1 +178,1 @@\n-    static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -158,2 +180,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        UNSAFE.put$RawType$Volatile(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.scope(),\n@@ -161,1 +183,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -166,1 +188,1 @@\n-    static $type$ getAcquire0(VarHandle ob, Object obb, long base) {\n+    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n@@ -168,1 +190,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n@@ -170,1 +192,1 @@\n-                          UNSAFE.get$RawType$Acquire(\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.scope(),\n@@ -172,1 +194,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));\n@@ -176,1 +198,1 @@\n-    static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -178,2 +200,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        UNSAFE.put$RawType$Release(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.scope(),\n@@ -181,1 +203,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -186,1 +208,1 @@\n-    static $type$ getOpaque0(VarHandle ob, Object obb, long base) {\n+    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n@@ -188,1 +210,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n@@ -190,1 +212,1 @@\n-                          UNSAFE.get$RawType$Opaque(\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.scope(),\n@@ -192,1 +214,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));\n@@ -196,1 +218,1 @@\n-    static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -198,2 +220,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        UNSAFE.put$RawType$Opaque(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.scope(),\n@@ -201,1 +223,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -207,1 +229,1 @@\n-    static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -209,2 +231,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        return UNSAFE.compareAndSet$RawType$(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.scope(),\n@@ -212,1 +234,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -217,1 +239,1 @@\n-    static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -219,1 +241,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -221,1 +243,1 @@\n-                          UNSAFE.compareAndExchange$RawType$(\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.scope(),\n@@ -223,1 +245,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -228,1 +250,1 @@\n-    static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -230,1 +252,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -232,1 +254,1 @@\n-                          UNSAFE.compareAndExchange$RawType$Acquire(\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.scope(),\n@@ -234,1 +256,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -239,1 +261,1 @@\n-    static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -241,1 +263,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -243,1 +265,1 @@\n-                          UNSAFE.compareAndExchange$RawType$Release(\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.scope(),\n@@ -245,1 +267,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -250,1 +272,1 @@\n-    static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -252,2 +274,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        return UNSAFE.weakCompareAndSet$RawType$Plain(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.scope(),\n@@ -255,1 +277,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -260,1 +282,1 @@\n-    static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -262,2 +284,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        return UNSAFE.weakCompareAndSet$RawType$(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),\n@@ -265,1 +287,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -270,1 +292,1 @@\n-    static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -272,2 +294,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        return UNSAFE.weakCompareAndSet$RawType$Acquire(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.scope(),\n@@ -275,1 +297,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -280,1 +302,1 @@\n-    static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n@@ -282,2 +304,2 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n-        return UNSAFE.weakCompareAndSet$RawType$Release(\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.scope(),\n@@ -285,1 +307,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -290,1 +312,1 @@\n-    static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -292,1 +314,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -294,1 +316,1 @@\n-                          UNSAFE.getAndSet$RawType$(\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.scope(),\n@@ -296,1 +318,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -301,1 +323,1 @@\n-    static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -303,1 +325,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -305,1 +327,1 @@\n-                          UNSAFE.getAndSet$RawType$Acquire(\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.scope(),\n@@ -307,1 +329,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -312,1 +334,1 @@\n-    static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -314,1 +336,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -316,1 +338,1 @@\n-                          UNSAFE.getAndSet$RawType$Release(\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.scope(),\n@@ -318,1 +340,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -325,1 +347,1 @@\n-    static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n@@ -327,1 +349,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -329,1 +351,1 @@\n-            return UNSAFE.getAndAdd$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.scope(),\n@@ -331,1 +353,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -334,1 +356,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);\n@@ -339,1 +361,1 @@\n-    static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n@@ -341,1 +363,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -343,1 +365,1 @@\n-            return UNSAFE.getAndAdd$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.scope(),\n@@ -345,1 +367,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -348,1 +370,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);\n@@ -353,1 +375,1 @@\n-    static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n@@ -355,1 +377,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -357,1 +379,1 @@\n-            return UNSAFE.getAndAdd$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.scope(),\n@@ -359,1 +381,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -362,1 +384,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);\n@@ -367,1 +389,1 @@\n-    static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {\n+    static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {\n@@ -371,1 +393,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -373,1 +395,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n@@ -381,1 +403,1 @@\n-    static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -383,1 +405,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -385,1 +407,1 @@\n-            return UNSAFE.getAndBitwiseOr$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.scope(),\n@@ -387,1 +409,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -390,1 +412,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -395,1 +417,1 @@\n-    static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -397,1 +419,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -399,1 +421,1 @@\n-            return UNSAFE.getAndBitwiseOr$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.scope(),\n@@ -401,1 +423,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -404,1 +426,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -409,1 +431,1 @@\n-    static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -411,1 +433,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -413,1 +435,1 @@\n-            return UNSAFE.getAndBitwiseOr$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.scope(),\n@@ -415,1 +437,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -418,1 +440,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -423,1 +445,1 @@\n-    static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {\n+    static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {\n@@ -427,1 +449,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -429,1 +451,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n@@ -435,1 +457,1 @@\n-    static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -437,1 +459,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -439,1 +461,1 @@\n-            return UNSAFE.getAndBitwiseAnd$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.scope(),\n@@ -441,1 +463,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -444,1 +466,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -449,1 +471,1 @@\n-    static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -451,1 +473,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -453,1 +475,1 @@\n-            return UNSAFE.getAndBitwiseAnd$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.scope(),\n@@ -455,1 +477,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -458,1 +480,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -463,1 +485,1 @@\n-    static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -465,1 +487,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -467,1 +489,1 @@\n-            return UNSAFE.getAndBitwiseAnd$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.scope(),\n@@ -469,1 +491,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -472,1 +494,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -477,1 +499,1 @@\n-    static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {\n+    static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {\n@@ -481,1 +503,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -483,1 +505,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n@@ -490,1 +512,1 @@\n-    static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -492,1 +514,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -494,1 +516,1 @@\n-            return UNSAFE.getAndBitwiseXor$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.scope(),\n@@ -496,1 +518,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -499,1 +521,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -504,1 +526,1 @@\n-    static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -506,1 +528,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -508,1 +530,1 @@\n-            return UNSAFE.getAndBitwiseXor$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.scope(),\n@@ -510,1 +532,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -513,1 +535,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -518,1 +540,1 @@\n-    static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n@@ -520,1 +542,1 @@\n-        MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);\n+        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n@@ -522,1 +544,1 @@\n-            return UNSAFE.getAndBitwiseXor$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.scope(),\n@@ -524,1 +546,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n@@ -527,1 +549,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n@@ -532,1 +554,1 @@\n-    static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {\n+    static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {\n@@ -536,1 +558,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -538,1 +560,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":190,"deletions":168,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-    static void reserveMemory(long size, int cap) {\n+    static void reserveMemory(long size, long cap) {\n@@ -188,1 +188,1 @@\n-    private static boolean tryReserveMemory(long size, int cap) {\n+    private static boolean tryReserveMemory(long size, long cap) {\n@@ -206,1 +206,1 @@\n-    static void unreserveMemory(long size, int cap) {\n+    static void unreserveMemory(long size, long cap) {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -196,0 +197,2 @@\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -757,1 +760,1 @@\n-    final void checkSegment() {\n+    final ScopedMemoryAccess.Scope scope() {\n@@ -759,1 +762,10 @@\n-            segment.checkValidState();\n+            return segment.scope();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    final void checkScope() {\n+        ScopedMemoryAccess.Scope scope = scope();\n+        if (scope != null) {\n+            scope.checkValidState();\n@@ -830,0 +842,15 @@\n+\n+                @Override\n+                public void reserveMemory(long size, long cap) {\n+                    Bits.reserveMemory(size, cap);\n+                }\n+\n+                @Override\n+                public void unreserveMemory(long size, long cap) {\n+                    Bits.unreserveMemory(size, cap);\n+                }\n+\n+                @Override\n+                public int pageSize() {\n+                    return Bits.pageSize();\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -34,0 +35,2 @@\n+    final static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -39,1 +42,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -63,1 +66,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -83,1 +86,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -103,1 +106,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -122,1 +125,1 @@\n-                i = ArraysSupport.vectorizedMismatch(\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -161,1 +164,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -179,1 +182,1 @@\n-                i = ArraysSupport.vectorizedMismatch(\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferMismatch.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -133,2 +133,1 @@\n-        checkSegment();\n-        $memtype$ x = UNSAFE.get$Memtype$Unaligned(bb.hb, byteOffset(nextGetIndex()),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextGetIndex()),\n@@ -140,2 +139,1 @@\n-        checkSegment();\n-        $memtype$ x = UNSAFE.get$Memtype$Unaligned(bb.hb, byteOffset(checkIndex(i)),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)),\n@@ -148,1 +146,1 @@\n-        $memtype$ x = UNSAFE.get$Memtype$Unaligned(bb.hb, byteOffset(i),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(null, bb.hb, byteOffset(i),\n@@ -158,1 +156,0 @@\n-        checkSegment();\n@@ -160,1 +157,1 @@\n-        UNSAFE.put$Memtype$Unaligned(bb.hb, byteOffset(nextPutIndex()), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextPutIndex()), y,\n@@ -170,1 +167,0 @@\n-        checkSegment();\n@@ -172,1 +168,1 @@\n-        UNSAFE.put$Memtype$Unaligned(bb.hb, byteOffset(checkIndex(i)), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)), y,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteBufferAs-X-Buffer.java.template","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-            checkSegment();\n-            $memtype$ x = UNSAFE.get$Memtype$Unaligned(null, a, bigEndian);\n+            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), null, a, bigEndian);\n@@ -65,1 +64,0 @@\n-            checkSegment();\n@@ -67,1 +65,1 @@\n-            UNSAFE.put$Memtype$Unaligned(null, a, y, bigEndian);\n+            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), null, a, y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer-bin.java.template","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -267,0 +268,11 @@\n+        Scope scope = scope();\n+        if (scope != null) {\n+            if (scope.ownerThread() == null) {\n+                throw new UnsupportedOperationException(\"ByteBuffer derived from shared segments not supported\");\n+            }\n+            try {\n+                scope.checkValidState();\n+            } catch (Scope.ScopedAccessError e) {\n+                throw new IllegalStateException(\"This segment is already closed\");\n+            }\n+        }\n@@ -276,2 +288,1 @@\n-            checkSegment();\n-            return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(nextGetIndex()))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(nextGetIndex()))));\n@@ -285,2 +296,1 @@\n-            checkSegment();\n-            return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(checkIndex(i)))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(checkIndex(i)))));\n@@ -295,1 +305,1 @@\n-            return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(i))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(null, null, ix(i))));\n@@ -304,1 +314,0 @@\n-        checkSegment();\n@@ -318,1 +327,1 @@\n-                    UNSAFE.copySwapMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, null,\n@@ -326,1 +335,1 @@\n-                    UNSAFE.copyMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n@@ -346,1 +355,0 @@\n-        checkSegment();\n@@ -355,1 +363,1 @@\n-                    UNSAFE.copySwapMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, null,\n@@ -363,1 +371,1 @@\n-                    UNSAFE.copyMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n@@ -384,2 +392,1 @@\n-            checkSegment();\n-            UNSAFE.put$Swaptype$(ix(nextPutIndex()), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n@@ -398,2 +405,1 @@\n-            checkSegment();\n-            UNSAFE.put$Swaptype$(ix(checkIndex(i)), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n@@ -411,1 +417,0 @@\n-        checkSegment();\n@@ -421,1 +426,0 @@\n-        checkSegment();\n@@ -431,1 +435,0 @@\n-        checkSegment();\n@@ -445,1 +448,1 @@\n-                    UNSAFE.copySwapMemory(src,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, src,\n@@ -453,1 +456,1 @@\n-                    UNSAFE.copyMemory(src,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, src,\n@@ -473,1 +476,0 @@\n-        checkSegment();\n@@ -483,1 +485,1 @@\n-                    UNSAFE.copySwapMemory(src,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, src,\n@@ -491,5 +493,3 @@\n-                    UNSAFE.copyMemory(src,\n-                                      srcOffset,\n-                                      null,\n-                                      ix(index),\n-                                      (long)length << $LG_BYTES_PER_VALUE$);\n+                    SCOPED_MEMORY_ACCESS.copyMemory(\n+                            scope(), null, src,\n+                            srcOffset, null, ix(index), (long)length << $LG_BYTES_PER_VALUE$);\n@@ -515,1 +515,2 @@\n-            UNSAFE.copyMemory(ix(pos), ix(0), (long)rem << $LG_BYTES_PER_VALUE$);\n+            SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n+                    ix(pos), null, ix(0), (long)rem << $LG_BYTES_PER_VALUE$);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-        checkSegment();\n@@ -170,1 +169,0 @@\n-        checkSegment();\n@@ -181,1 +179,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -192,1 +190,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -211,1 +209,0 @@\n-        checkSegment();\n@@ -221,1 +218,0 @@\n-        checkSegment();\n@@ -231,1 +227,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -246,1 +242,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -256,1 +252,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -266,1 +262,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -279,1 +275,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -331,2 +327,1 @@\n-        checkSegment();\n-        return UNSAFE.getCharUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -336,1 +331,1 @@\n-        return UNSAFE.getCharUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -343,2 +338,1 @@\n-        checkSegment();\n-        UNSAFE.putCharUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -353,2 +347,1 @@\n-        checkSegment();\n-        UNSAFE.putCharUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -386,2 +379,1 @@\n-        checkSegment();\n-        return UNSAFE.getShortUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -391,2 +383,1 @@\n-        checkSegment();\n-        return UNSAFE.getShortUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -399,2 +390,1 @@\n-        checkSegment();\n-        UNSAFE.putShortUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -409,2 +399,1 @@\n-        checkSegment();\n-        UNSAFE.putShortUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -442,2 +431,1 @@\n-        checkSegment();\n-        return UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -447,2 +435,1 @@\n-        checkSegment();\n-        return UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -455,2 +442,1 @@\n-        checkSegment();\n-        UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n@@ -465,2 +451,1 @@\n-        checkSegment();\n-        UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n@@ -498,2 +483,1 @@\n-        checkSegment();\n-        return UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -503,2 +487,1 @@\n-        checkSegment();\n-        return UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -511,2 +494,1 @@\n-        checkSegment();\n-        UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n@@ -521,2 +503,1 @@\n-        checkSegment();\n-        UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n@@ -554,2 +535,1 @@\n-        checkSegment();\n-        int x = UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -560,2 +540,1 @@\n-        checkSegment();\n-        int x = UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -569,1 +548,0 @@\n-        checkSegment();\n@@ -571,1 +549,1 @@\n-        UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n@@ -580,1 +558,0 @@\n-        checkSegment();\n@@ -582,1 +559,1 @@\n-        UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n@@ -614,2 +591,1 @@\n-        checkSegment();\n-        long x = UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -620,2 +596,1 @@\n-        checkSegment();\n-        long x = UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -629,1 +604,0 @@\n-        checkSegment();\n@@ -631,1 +605,1 @@\n-        UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n@@ -640,1 +614,0 @@\n-        checkSegment();\n@@ -642,1 +615,1 @@\n-        UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":31,"deletions":58,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -90,0 +91,2 @@\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -176,1 +179,1 @@\n-        return MappedMemoryUtils.isLoaded(address, isSync, capacity());\n+        return SCOPED_MEMORY_ACCESS.isLoaded(scope(), address, isSync, capacity());\n@@ -194,1 +197,1 @@\n-            MappedMemoryUtils.load(address, isSync, capacity());\n+            SCOPED_MEMORY_ACCESS.load(scope(), address, isSync, capacity());\n@@ -283,1 +286,1 @@\n-            MappedMemoryUtils.force(fd, address, isSync, index, length);\n+            SCOPED_MEMORY_ACCESS.force(scope(), fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1048,5 +1048,3 @@\n-                    UNSAFE.copyMemory(srcBase,\n-                                      srcAddr,\n-                                      base,\n-                                      addr,\n-                                      len);\n+                    SCOPED_MEMORY_ACCESS.copyMemory(\n+                            scope(), src.scope(), srcBase,\n+                            srcAddr, base, addr, len);\n@@ -1060,6 +1058,3 @@\n-                    UNSAFE.copySwapMemory(srcBase,\n-                                          srcAddr,\n-                                          base,\n-                                          addr,\n-                                          len,\n-                                          (long)1 << $LG_BYTES_PER_VALUE$);\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(\n+                            scope(), src.scope(), srcBase,\n+                            srcAddr, base, addr, len, (long)1 << $LG_BYTES_PER_VALUE$);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -84,38 +84,2 @@\n-    VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask,\n-                                    ByteOrder order, long offset, long[] strides);\n-\n-    \/**\n-     * Is {@code handle} a memory access varhandle?\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n-     *\/\n-    boolean isMemoryAccessVarHandle(VarHandle handle);\n-\n-    \/**\n-     * Returns the carrier associated with a memory access var handle.\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n-     *\/\n-    Class<?> memoryAddressCarrier(VarHandle handle);\n-\n-    \/**\n-     * Returns the alignment mask associated with a memory access var handle.\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n-     *\/\n-    long memoryAddressAlignmentMask(VarHandle handle);\n-\n-    \/**\n-     * Returns the byte order associated with a memory access var handle.\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n-     *\/\n-    ByteOrder memoryAddressByteOrder(VarHandle handle);\n-\n-    \/**\n-     * Returns the offset associated with a memory access var handle.\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n-     *\/\n-    long memoryAddressOffset(VarHandle handle);\n-\n-    \/**\n-     * Returns the strides associated with a memory access var handle.\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n-     *\/\n-    long[] memoryAddressStrides(VarHandle handle);\n+    VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,\n+                                    ByteOrder order);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -107,0 +107,15 @@\n+\n+    \/**\n+     * Used by {@code jdk.internal.foreign.NativeMemorySegmentImpl}.\n+     *\/\n+    void reserveMemory(long size, long cap);\n+\n+    \/**\n+     * Used by {@code jdk.internal.foreign.NativeMemorySegmentImpl}.\n+     *\/\n+    void unreserveMemory(long size, long cap);\n+\n+    \/**\n+     * Used by {@code jdk.internal.foreign.NativeMemorySegmentImpl}.\n+     *\/\n+    int pageSize();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+\n@@ -34,1 +36,67 @@\n-    void checkValidState();\n+    \/**\n+     * Check that memory access is within spatial bounds and that access is compatible with segment access modes.\n+     * @throws UnsupportedOperationException if underlying segment has incompatible access modes (e.g. attempting to write\n+     * a read-only segment).\n+     * @throws IndexOutOfBoundsException if access is out-of-bounds.\n+     *\/\n+    void checkAccess(long offset, long length, boolean readOnly);\n+    long unsafeGetOffset();\n+    Object unsafeGetBase();\n+    boolean isSmall();\n+    ScopedMemoryAccess.Scope scope();\n+\n+    \/* Helper functions for offset computations. These are required so that we can avoid issuing long opcodes\n+     * (e.g. LMUL, LADD) when we're operating on 'small' segments (segments whose length can be expressed with an int).\n+     * C2 BCE code is very sensitive to the kind of opcode being emitted, and this workaround allows us to rescue\n+     * BCE when working with small segments. This workaround should be dropped when JDK-8223051 is resolved.\n+     *\/\n+\n+    static long addOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {\n+        if (segmentProxy.isSmall()) {\n+            \/\/ force ints for BCE\n+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+            int i1 = (int)op1;\n+            int i2 = (int)op2;\n+            try {\n+                return Math.addExact(i1, i2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+        } else {\n+            try {\n+                return Math.addExact(op1, op2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n+            }\n+        }\n+    }\n+\n+    static long multiplyOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {\n+        if (segmentProxy.isSmall()) {\n+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+            \/\/ force ints for BCE\n+            int i1 = (int)op1;\n+            int i2 = (int)op2;\n+            try {\n+                return Math.multiplyExact(i1, i2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+        } else {\n+            try {\n+                return Math.multiplyExact(op1, op2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n+            }\n+        }\n+    }\n+\n+    private static IndexOutOfBoundsException overflowException(long min, long max) {\n+        return new IndexOutOfBoundsException(String.format(\"Overflow occurred during offset computation ; offset exceeded range { %d .. %d }\", min, max));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/MemorySegmentProxy.java","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,698 @@\n+    @ForceInline\n+    public $type$ get$Type$(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$Internal(scope, base, offset);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$Internal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+#if[Unaligned]\n+    @ForceInline\n+    public $type$ get$Type$Unaligned(Scope scope, Object base, long offset, boolean be) {\n+        try {\n+            return get$Type$UnalignedInternal(scope, base, offset, be);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$UnalignedInternal(Scope scope, Object base, long offset, boolean be) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Unaligned(base, offset, be);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Unaligned(Scope scope, Object base, long offset, $type$ value, boolean be) {\n+        try {\n+            put$Type$UnalignedInternal(scope, base, offset, value, be);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$UnalignedInternal(Scope scope, Object base, long offset, $type$ value, boolean be) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Unaligned(base, offset, value, be);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[Unaligned]\n+\n+    @ForceInline\n+    public $type$ get$Type$Volatile(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$VolatileInternal(scope, base, offset);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$VolatileInternal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Volatile(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Volatile(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$VolatileInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$VolatileInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Volatile(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ get$Type$Acquire(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$AcquireInternal(scope, base, offset);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$AcquireInternal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Acquire(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ get$Type$Opaque(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$OpaqueInternal(scope, base, offset);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$OpaqueInternal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Opaque(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+    @ForceInline\n+    public void put$Type$Opaque(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$OpaqueInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$OpaqueInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Opaque(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#if[CAS]\n+    @ForceInline\n+    public boolean compareAndSet$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndSet$Type$Internal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean compareAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndSet$Type$(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ compareAndExchange$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndExchange$Type$Internal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ compareAndExchange$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndExchange$Type$(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ compareAndExchange$Type$Acquire(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndExchange$Type$AcquireInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ compareAndExchange$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndExchange$Type$Acquire(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ compareAndExchange$Type$Release(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndExchange$Type$ReleaseInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ compareAndExchange$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndExchange$Type$Release(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$Plain(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$PlainInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$PlainInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$Plain(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$Internal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$Acquire(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$AcquireInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$Acquire(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$Release(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$ReleaseInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$Release(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndSet$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndSet$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndSet$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndSet$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndSet$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndSet$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndSet$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndSet$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndSet$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndSet$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndSet$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[CAS]\n+\n+#if[AtomicAdd]\n+    @ForceInline\n+    public $type$ getAndAdd$Type$(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            return getAndAdd$Type$Internal(scope, base, offset, delta);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndAdd$Type$Internal(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndAdd$Type$(base, offset, delta);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndAdd$Type$Acquire(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            return getAndAdd$Type$AcquireInternal(scope, base, offset, delta);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndAdd$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndAdd$Type$Acquire(base, offset, delta);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndAdd$Type$Release(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            return getAndAdd$Type$ReleaseInternal(scope, base, offset, delta);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndAdd$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndAdd$Type$Release(base, offset, delta);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[AtomicAdd]\n+\n+#if[Bitwise]\n+    @ForceInline\n+    public $type$ getAndBitwiseOr$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseOr$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseOr$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseOr$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseOr$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseOr$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseOr$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseOr$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseOr$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseOr$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseOr$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseOr$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseAnd$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseAnd$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseAnd$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseAnd$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseAnd$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseAnd$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseAnd$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseAnd$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseAnd$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseAnd$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseAnd$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseXor$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseXor$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseXor$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseXor$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseXor$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseXor$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseXor$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseXor$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseXor$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseXor$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseXor$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseXor$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[Bitwise]\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":698,"deletions":0,"binary":false,"changes":698,"status":"added"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.ref.Reference;\n+import java.io.FileDescriptor;\n+\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ArraysSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\n+\/**\n+ * This class defines low-level methods to access on-heap and off-heap memory. The methods in this class\n+ * can be thought of as thin wrappers around methods provided in the {@link Unsafe} class. All the methods in this\n+ * class, accept one or more {@link Scope} parameter, which is used to validate as to whether access to memory\n+ * can be performed in a safe fashion - more specifically, to ensure that the memory being accessed has not\n+ * already been released (which would result in a hard VM crash).\n+ * <p>\n+ * Accessing and releasing memory from a single thread is not problematic - after all, a given thread cannot,\n+ * at the same time, access a memory region <em>and<\/em> free it. But ensuring correctness of memory access\n+ * when multiple threads are involved is much trickier, as there can be cases where a thread is accessing\n+ * a memory region while another thread is releasing it.\n+ * <p>\n+ * This class provides tools to manage races when multiple threads are accessing and\/or releasing the same memory\n+ * region concurrently. More specifically, when a thread wants to release a memory region, it should call the\n+ * {@link #closeScope(jdk.internal.misc.ScopedMemoryAccess.Scope)} method provided by this class. This method initiates\n+ * thread-local handshakes with all the other VM threads, which are then stopped one by one. If any thread is found\n+ * accessing memory that is associated to the very scope object being closed, that thread execution is asynchronously\n+ * interrupted with a {@link Scope.ScopedAccessError}.\n+ * <p>\n+ * This synchronization strategy relies on the idea that accessing memory is atomic with respect to checking the\n+ * validity of the scope associated with that memory region - that is, a thread that wants to perform memory access will be\n+ * suspended either <em>before<\/em> a scope check or <em>after<\/em> the memory access. To ensure this atomicity,\n+ * all methods in this class are marked with the special {@link Scoped} annotation, which is recognized by the VM,\n+ * and used during the thread-local handshake to detect (and stop) threads performing potentially problematic memory access\n+ * operations. Additionally, to make sure that the scope object(s) of the memory being accessed is always\n+ * reachable during an access operation, all the methods in this class add reachability fences around the underlying\n+ * unsafe access.\n+ * <p>\n+ * This form of synchronization allows APIs to use plain memory access without any other form of synchronization\n+ * which might be deemed to expensive; in other words, this approach prioritizes the performance of memory access over\n+ * that of releasing a shared memory resource.\n+ *\/\n+public class ScopedMemoryAccess {\n+\n+    private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    private static native void registerNatives();\n+    static {\n+        registerNatives();\n+    }\n+\n+    public boolean closeScope(Scope scope) {\n+        return closeScope0(scope, Scope.ScopedAccessError.INSTANCE);\n+    }\n+\n+    native boolean closeScope0(Scope scope, Scope.ScopedAccessError exception);\n+\n+    private ScopedMemoryAccess() {}\n+\n+    private static final ScopedMemoryAccess theScopedMemoryAccess = new ScopedMemoryAccess();\n+\n+    public static ScopedMemoryAccess getScopedMemoryAccess() {\n+        return theScopedMemoryAccess;\n+    }\n+\n+    \/**\n+     * Scope interface used during scoped memory access operations. A scope can be thought of as an object\n+     * which embodies the temporal checks associated with a given memory region.\n+     *\/\n+    public interface Scope {\n+        void checkValidState();\n+\n+        Thread ownerThread();\n+\n+        \/**\n+         * Error thrown when memory access fails because the memory has already been released.\n+         * Note: for performance reasons, this exception is never created by client; instead a shared instance\n+         * is thrown (sometimes, this instance can be thrown asynchronously inside VM code). For this reason,\n+         * it is important for clients to always catch this exception and throw a regular exception instead\n+         * (which contains full stack information).\n+         *\/\n+        final class ScopedAccessError extends Error {\n+            private ScopedAccessError() {\n+                super(\"Attempt to access an already released memory resource\", null, false, false);\n+            }\n+            static final long serialVersionUID = 1L;\n+\n+            public static final ScopedAccessError INSTANCE = new ScopedAccessError();\n+        }\n+    }\n+\n+    @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface Scoped { }\n+\n+    \/\/ bulk ops\n+\n+    @ForceInline\n+    public void copyMemory(Scope srcScope, Scope dstScope,\n+                                   Object srcBase, long srcOffset,\n+                                   Object destBase, long destOffset,\n+                                   long bytes) {\n+          try {\n+              copyMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes);\n+          } catch (Scope.ScopedAccessError ex) {\n+              throw new IllegalStateException(\"This segment is already closed\");\n+          }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void copyMemoryInternal(Scope srcScope, Scope dstScope,\n+                               Object srcBase, long srcOffset,\n+                               Object destBase, long destOffset,\n+                               long bytes) {\n+        try {\n+            if (srcScope != null) {\n+                srcScope.checkValidState();\n+            }\n+            if (dstScope != null) {\n+                dstScope.checkValidState();\n+            }\n+            UNSAFE.copyMemory(srcBase, srcOffset, destBase, destOffset, bytes);\n+        } finally {\n+            Reference.reachabilityFence(srcScope);\n+            Reference.reachabilityFence(dstScope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void copySwapMemory(Scope srcScope, Scope dstScope,\n+                                   Object srcBase, long srcOffset,\n+                                   Object destBase, long destOffset,\n+                                   long bytes, long elemSize) {\n+          try {\n+              copySwapMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+          } catch (Scope.ScopedAccessError ex) {\n+              throw new IllegalStateException(\"This segment is already closed\");\n+          }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void copySwapMemoryInternal(Scope srcScope, Scope dstScope,\n+                               Object srcBase, long srcOffset,\n+                               Object destBase, long destOffset,\n+                               long bytes, long elemSize) {\n+        try {\n+            if (srcScope != null) {\n+                srcScope.checkValidState();\n+            }\n+            if (dstScope != null) {\n+                dstScope.checkValidState();\n+            }\n+            UNSAFE.copySwapMemory(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+        } finally {\n+            Reference.reachabilityFence(srcScope);\n+            Reference.reachabilityFence(dstScope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void setMemory(Scope scope, Object o, long offset, long bytes, byte value) {\n+        try {\n+            setMemoryInternal(scope, o, offset, bytes, value);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void setMemoryInternal(Scope scope, Object o, long offset, long bytes, byte value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.setMemory(o, offset, bytes, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public int vectorizedMismatch(Scope aScope, Scope bScope,\n+                                             Object a, long aOffset,\n+                                             Object b, long bOffset,\n+                                             int length,\n+                                             int log2ArrayIndexScale) {\n+        try {\n+            return vectorizedMismatchInternal(aScope, bScope, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private int vectorizedMismatchInternal(Scope aScope, Scope bScope,\n+                                             Object a, long aOffset,\n+                                             Object b, long bOffset,\n+                                             int length,\n+                                             int log2ArrayIndexScale) {\n+        try {\n+            if (aScope != null) {\n+                aScope.checkValidState();\n+            }\n+            if (bScope != null) {\n+                bScope.checkValidState();\n+            }\n+            return ArraysSupport.vectorizedMismatch(a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+        } finally {\n+            Reference.reachabilityFence(aScope);\n+            Reference.reachabilityFence(bScope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean isLoaded(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            return isLoadedInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public boolean isLoadedInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return SharedSecrets.getJavaNioAccess().isLoaded(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void load(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            loadInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void loadInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().load(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void unload(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            unloadInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void unloadInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().unload(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void force(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+        try {\n+            forceInternal(scope, fd, address, isSync, index, length);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void forceInternal(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().force(fd, address, isSync, index, length);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+    \/\/ typed-ops here\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -163,31 +163,0 @@\n-    \/**\n-     * Mismatch over long lengths.\n-     *\/\n-    public static long vectorizedMismatchLargeForBytes(Object a, long aOffset,\n-                                                       Object b, long bOffset,\n-                                                       long length) {\n-        long off = 0;\n-        long remaining = length;\n-        int i, size;\n-        boolean lastSubRange = false;\n-        while (remaining > 7 && !lastSubRange) {\n-            if (remaining > Integer.MAX_VALUE) {\n-                size = Integer.MAX_VALUE;\n-            } else {\n-                size = (int) remaining;\n-                lastSubRange = true;\n-            }\n-            i = vectorizedMismatch(\n-                    a, aOffset + off,\n-                    b, bOffset + off,\n-                    size, LOG2_ARRAY_BYTE_INDEX_SCALE);\n-            if (i >= 0)\n-                return off + i;\n-\n-            i = size - ~i;\n-            off += i;\n-            remaining -= i;\n-        }\n-        return ~remaining;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -220,1 +220,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.foreign;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+\/**\n+ * Represents a type which is <em>addressable<\/em>. An addressable type is one which can be projected down to\n+ * a memory address instance (see {@link #address()}). Examples of addressable types are {@link MemorySegment},\n+ * and {@link MemoryAddress}.\n+ *\n+ * @apiNote In the future, if the Java language permits, {@link Addressable}\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by\n+ * explicitly permitted types, such as {@link MemorySegment} and {@link MemoryAddress}.\n+ *\n+ * @implSpec\n+ * Implementations of this interface <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public interface Addressable {\n+    \/**\n+     * Map this object into a {@link MemoryAddress} instance.\n+     * @return the {@link MemoryAddress} instance associated with this object.\n+     *\/\n+    MemoryAddress address();\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Path;\n-\n-\/**\n- * A mapped memory segment, that is, a memory segment backed by memory-mapped file.\n- *\n- * <p> Mapped memory segments are created via the {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}.\n- * Mapped memory segments behave like ordinary segments, but provide additional capabilities to manipulate memory-mapped\n- * memory regions, such as {@link #force()} and {@link #load()}.\n- * <p>\n- * All implementations of this interface must be <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>;\n- * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on\n- * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should\n- * be used for comparisons.\n- * <p>\n- * Non-platform classes should not implement {@linkplain MappedMemorySegment} directly.\n- *\n- * <p> The content of a mapped memory segment can change at any time, for example\n- * if the content of the corresponding region of the mapped file is changed by\n- * this (or another) program.  Whether or not such changes occur, and when they\n- * occur, is operating-system dependent and therefore unspecified.\n- *\n- * All or part of a mapped memory segment may become\n- * inaccessible at any time, for example if the backing mapped file is truncated.  An\n- * attempt to access an inaccessible region of a mapped memory segment will not\n- * change the segment's content and will cause an unspecified exception to be\n- * thrown either at the time of the access or at some later time.  It is\n- * therefore strongly recommended that appropriate precautions be taken to\n- * avoid the manipulation of a mapped file by this (or another) program, except to read or write\n- * the file's content.\n- *\n- * @apiNote In the future, if the Java language permits, {@link MemorySegment}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted subtypes.\n- *\/\n-public interface MappedMemorySegment extends MemorySegment {\n-\n-    @Override\n-    MappedMemorySegment withAccessModes(int accessModes);\n-\n-    @Override\n-    MappedMemorySegment asSlice(long offset, long newSize);\n-\n-    \/**\n-     * Forces any changes made to this segment's content to be written to the\n-     * storage device containing the mapped file.\n-     *\n-     * <p> If the file mapped into this segment resides on a local storage\n-     * device then when this method returns it is guaranteed that all changes\n-     * made to the segment since it was created, or since this method was last\n-     * invoked, will have been written to that device.\n-     *\n-     * <p> If the file does not reside on a local device then no such guarantee\n-     * is made.\n-     *\n-     * <p> If this segment was not mapped in read\/write mode ({@link\n-     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n-     * invoking this method may have no effect. In particular, the\n-     * method has no effect for segments mapped in read-only or private\n-     * mapping modes. This method may or may not have an effect for\n-     * implementation-specific mapping modes.\n-     * <\/p>\n-     *\/\n-    void force();\n-\n-    \/**\n-     * Loads this segment's content into physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that, when it returns,\n-     * this segment's contents is resident in physical memory.  Invoking this\n-     * method may cause some number of page faults and I\/O operations to\n-     * occur. <\/p>\n-     *\/\n-    void load();\n-\n-    \/**\n-     * Unloads this segment's content from physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that this segment's contents are\n-     * are no longer resident in physical memory. Accessing this segment's contents\n-     * after invoking this method may cause some number of page faults and I\/O operations to\n-     * occur (as this segment's contents might need to be paged back in). <\/p>\n-     *\/\n-    void unload();\n-\n-    \/**\n-     * Tells whether or not this segment's content is resident in physical\n-     * memory.\n-     *\n-     * <p> A return value of {@code true} implies that it is highly likely\n-     * that all of the data in this segment is resident in physical memory and\n-     * may therefore be accessed without incurring any virtual-memory page\n-     * faults or I\/O operations.  A return value of {@code false} does not\n-     * necessarily imply that the segment's content is not resident in physical\n-     * memory.\n-     *\n-     * <p> The returned value is a hint, rather than a guarantee, because the\n-     * underlying operating system may have paged out some of the segment's data\n-     * by the time that an invocation of this method returns.  <\/p>\n-     *\n-     * @return  {@code true} if it is likely that this segment's content\n-     *          is resident in physical memory\n-     *\/\n-    boolean isLoaded();\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegment.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.MappedMemorySegmentImpl;\n+\n+import java.nio.MappedByteBuffer;\n+\n+\/**\n+ * This class provides capabilities to manipulate mapped memory segments, such as {@link #force(MemorySegment)},\n+ * and {@link #load(MemorySegment)}. The methods in these class are suitable replacements for some of the\n+ * functionality in the {@link java.nio.MappedByteBuffer} class. Note that, while it is possible to map a segment\n+ * into a byte buffer (see {@link MemorySegment#asByteBuffer()}), and call e.g. {@link MappedByteBuffer#force()} that way,\n+ * this can only be done when the source segment is small enough, due to the size limitation inherent to the\n+ * ByteBuffer API.\n+ * <p>\n+ * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n+ * custom mapped memory segment factories; using JNI, e.g. on Linux, it is possible to call {@code mmap}\n+ * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)}.\n+ *\n+ * @implNote\n+ * The behavior of some the methods in this class (see {@link #load(MemorySegment)}, {@link #unload(MemorySegment)} and\n+ * {@link #isLoaded(MemorySegment)}) is highly platform-dependent; as a result, calling these methods might\n+ * be a no-op on certain platforms.\n+ *\/\n+public final class MappedMemorySegments {\n+    private MappedMemorySegments() {\n+        \/\/ no thanks\n+    }\n+\n+    \/**\n+     * Tells whether or not the contents of the given segment is resident in physical\n+     * memory.\n+     *\n+     * <p> A return value of {@code true} implies that it is highly likely\n+     * that all of the data in the given segment is resident in physical memory and\n+     * may therefore be accessed without incurring any virtual-memory page\n+     * faults or I\/O operations.  A return value of {@code false} does not\n+     * necessarily imply that the segment's content is not resident in physical\n+     * memory.\n+     *\n+     * <p> The returned value is a hint, rather than a guarantee, because the\n+     * underlying operating system may have paged out some of the segment's data\n+     * by the time that an invocation of this method returns.  <\/p>\n+     *\n+     * @param segment the segment whose contents are to be tested.\n+     * @return  {@code true} if it is likely that the contents of the given segment\n+     *          is resident in physical memory\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.isMapped() == false}.\n+     *\/\n+    public static boolean isLoaded(MemorySegment segment) {\n+        return toMappedSegment(segment).isLoaded();\n+    }\n+\n+    \/**\n+     * Loads the contents of the given segment into physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that, when it returns,\n+     * this contents of the given segment is resident in physical memory.  Invoking this\n+     * method may cause some number of page faults and I\/O operations to\n+     * occur. <\/p>\n+     *\n+     * @param segment the segment whose contents are to be loaded.\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.isMapped() == false}.\n+     *\/\n+    public static void load(MemorySegment segment) {\n+        toMappedSegment(segment).load();\n+    }\n+\n+    \/**\n+     * Unloads the contents of the given segment from physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that the contents of the given segment are\n+     * are no longer resident in physical memory. Accessing this segment's contents\n+     * after invoking this method may cause some number of page faults and I\/O operations to\n+     * occur (as this segment's contents might need to be paged back in). <\/p>\n+     *\n+     * @param segment the segment whose contents are to be unloaded.\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.isMapped() == false}.\n+     *\/\n+    public static void unload(MemorySegment segment) {\n+        toMappedSegment(segment).unload();\n+    }\n+\n+    \/**\n+     * Forces any changes made to the contents of the given segment to be written to the\n+     * storage device described by the mapped segment's file descriptor.\n+     *\n+     * <p> If this mapping's file descriptor resides on a local storage\n+     * device then when this method returns it is guaranteed that all changes\n+     * made to the segment since it was created, or since this method was last\n+     * invoked, will have been written to that device.\n+     *\n+     * <p> If this mapping's file descriptor does not reside on a local device then no such guarantee\n+     * is made.\n+     *\n+     * <p> If the given segment was not mapped in read\/write mode ({@link\n+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n+     * invoking this method may have no effect. In particular, the\n+     * method has no effect for segments mapped in read-only or private\n+     * mapping modes. This method may or may not have an effect for\n+     * implementation-specific mapping modes.\n+     * <\/p>\n+     *\n+     * @param segment the segment whose contents are to be written to the storage device described by the\n+     *                segment's file descriptor.\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.isMapped() == false}.\n+     *\/\n+    public static void force(MemorySegment segment) {\n+        toMappedSegment(segment).force();\n+    }\n+\n+    static MappedMemorySegmentImpl toMappedSegment(MemorySegment segment) {\n+        if (segment instanceof MappedMemorySegmentImpl) {\n+            return (MappedMemorySegmentImpl)segment;\n+        } else {\n+            throw new UnsupportedOperationException(\"Not a mapped memory segment\");\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,1336 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+\n+\/**\n+ * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.\n+ * <p>\n+ * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long, ByteOrder)}) take a segment, an offset\n+ * (expressed in bytes) and a byte order. The final address at which the dereference will occur will be computed by offsetting\n+ * the base address by the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n+ * <p>\n+ * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment, ByteOrder)}) so that\n+ * clients can omit the offset coordinate.\n+ * <p>\n+ * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n+ * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long, ByteOrder)}),\n+ * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n+ * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n+ * be dereferenced.\n+ * <p>\n+ * In cases where native byte order is preferred, overloads are provided (see {@link #getIntAtOffset(MemorySegment, long)})\n+ * so that clients can omit the byte order parameter.\n+ *\/\n+public final class MemoryAccess {\n+\n+    private MemoryAccess() {\n+        \/\/ just the one\n+    }\n+\n+    private static final VarHandle byte_handle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n+    private static final VarHandle char_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, char.class);\n+    private static final VarHandle short_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, short.class);\n+    private static final VarHandle int_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, int.class);\n+    private static final VarHandle float_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, float.class);\n+    private static final VarHandle long_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, long.class);\n+    private static final VarHandle double_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, double.class);\n+    private static final VarHandle char_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, char.class);\n+    private static final VarHandle short_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, short.class);\n+    private static final VarHandle int_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, int.class);\n+    private static final VarHandle float_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, float.class);\n+    private static final VarHandle long_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, long.class);\n+    private static final VarHandle double_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, double.class);\n+    private static final VarHandle address_handle;\n+\n+    static {\n+        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n+            case 4 -> int.class;\n+            case 8 -> long.class;\n+            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n+        };\n+        address_handle = MemoryHandles.asAddressVarHandle(unalignedHandle(MemoryLayouts.ADDRESS, carrier));\n+    }\n+\n+    private static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n+        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());\n+    }\n+\n+    \/**\n+     * Reads a byte from given segment and offset.\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a byte value read from {@code segment}.\n+     *\/\n+    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n+        return (byte)byte_handle.get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment and offset.\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n+        byte_handle.set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getCharAtOffset(MemorySegment segment, long offset) {\n+        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n+        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShortAtOffset(MemorySegment segment, long offset) {\n+        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n+        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getIntAtOffset(MemorySegment segment, long offset) {\n+        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n+        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n+        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n+        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLongAtOffset(MemorySegment segment, long offset) {\n+        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n+        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n+        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n+        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n+    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a memory address read from {@code segment}.\n+     *\/\n+    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n+        return (MemoryAddress)address_handle.get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n+    handle.set(segment, offset, value.address());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     *\/\n+    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n+        address_handle.set(segment, offset, value.address());\n+    }\n+\n+    \/**\n+     * Reads a char from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n+    char value = (char)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (char)((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n+    short value = (short)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (short)((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n+    int value = (int)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (int)((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n+    float value = (float)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (float)((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n+    long value = (long)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (long)((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n+    double value = (double)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (double)((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a byte from given segment.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    byte value = getByteAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @return a byte value read from {@code segment}.\n+     *\/\n+    public static byte getByte(MemorySegment segment) {\n+        return getByteAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setByteAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByte(MemorySegment segment, byte value) {\n+        setByteAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getChar(MemorySegment segment) {\n+        return getCharAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setChar(MemorySegment segment, char value) {\n+        setCharAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShort(MemorySegment segment) {\n+        return getShortAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShort(MemorySegment segment, short value) {\n+        setShortAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getInt(MemorySegment segment) {\n+        return getIntAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setInt(MemorySegment segment, int value) {\n+        setIntAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloat(MemorySegment segment) {\n+        return getFloatAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloat(MemorySegment segment, float value) {\n+        setFloatAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    long value = getLongAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLong(MemorySegment segment) {\n+        return getLongAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLong(MemorySegment segment, long value) {\n+        setLongAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    double value = getDoubleAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDouble(MemorySegment segment) {\n+        return getDoubleAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDouble(MemorySegment segment, double value) {\n+        setDoubleAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryAddress value = getAddressAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a memory address read from {@code segment}.\n+     *\/\n+    public static MemoryAddress getAddress(MemorySegment segment) {\n+        return getAddressAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setAddressAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     *\/\n+    public static void setAddress(MemorySegment segment, Addressable value) {\n+        setAddressAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Reads a char from given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset(segment, 0L, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getChar(MemorySegment segment, ByteOrder order) {\n+        return getCharAtOffset(segment, 0L, order);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, 0L, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setChar(MemorySegment segment, ByteOrder order, char value) {\n+        setCharAtOffset(segment, 0L, order, value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset(segment, 0L, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShort(MemorySegment segment, ByteOrder order) {\n+        return getShortAtOffset(segment, 0L, order);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, 0L, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShort(MemorySegment segment, ByteOrder order, short value) {\n+        setShortAtOffset(segment, 0L, order, value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset(segment, 0L, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getInt(MemorySegment segment, ByteOrder order) {\n+        return getIntAtOffset(segment, 0L, order);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, 0L, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setInt(MemorySegment segment, ByteOrder order, int value) {\n+        setIntAtOffset(segment, 0L, order, value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset(segment, 0L, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloat(MemorySegment segment, ByteOrder order) {\n+        return getFloatAtOffset(segment, 0L, order);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, 0L, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloat(MemorySegment segment, ByteOrder order, float value) {\n+        setFloatAtOffset(segment, 0L, order, value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    long value = getLongAtOffset(segment, 0L, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLong(MemorySegment segment, ByteOrder order) {\n+        return getLongAtOffset(segment, 0L, order);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset(segment, 0L, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLong(MemorySegment segment, ByteOrder order, long value) {\n+        setLongAtOffset(segment, 0L, order, value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    double value = getDoubleAtOffset(segment, 0L, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDouble(MemorySegment segment, ByteOrder order) {\n+        return getDoubleAtOffset(segment, 0L, order);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset(segment, 0L, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param order the specified byte order.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDouble(MemorySegment segment, ByteOrder order, double value) {\n+        setDoubleAtOffset(segment, 0L, order, value);\n+    }\n+\n+    \/**\n+     * Reads a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset(segment, 2 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static char getCharAtIndex(MemorySegment segment, long index) {\n+        return getCharAtOffset(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, 2 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n+        setCharAtOffset(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset(segment, 2 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static short getShortAtIndex(MemorySegment segment, long index) {\n+        return getShortAtOffset(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, 2 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n+        setShortAtOffset(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset(segment, 4 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static int getIntAtIndex(MemorySegment segment, long index) {\n+        return getIntAtOffset(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, 4 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n+        setIntAtOffset(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset(segment, 4 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static float getFloatAtIndex(MemorySegment segment, long index) {\n+        return getFloatAtOffset(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, 4 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n+        setFloatAtOffset(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getLongAtOffset(segment, 8 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static long getLongAtIndex(MemorySegment segment, long index) {\n+        return getLongAtOffset(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset(segment, 8 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n+        setLongAtOffset(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getDoubleAtOffset(segment, 8 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n+        return getDoubleAtOffset(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n+        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     *\/\n+    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n+        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset(segment, 8 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n+        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Reads a char from given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset(segment, 2 * index, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param order the specified byte order.\n+     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static char getCharAtIndex(MemorySegment segment, long index, ByteOrder order) {\n+        return getCharAtOffset(segment, scale(segment, index, 2), order);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, 2 * index, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param order the specified byte order.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtIndex(MemorySegment segment, long index, ByteOrder order, char value) {\n+        setCharAtOffset(segment, scale(segment, index, 2), order, value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset(segment, 2 * index, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param order the specified byte order.\n+     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static short getShortAtIndex(MemorySegment segment, long index, ByteOrder order) {\n+        return getShortAtOffset(segment, scale(segment, index, 2), order);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, 2 * index, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param order the specified byte order.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtIndex(MemorySegment segment, long index, ByteOrder order, short value) {\n+        setShortAtOffset(segment, scale(segment, index, 2), order, value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset(segment, 4 * index, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param order the specified byte order.\n+     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static int getIntAtIndex(MemorySegment segment, long index, ByteOrder order) {\n+        return getIntAtOffset(segment, scale(segment, index, 4), order);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, 4 * index, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param order the specified byte order.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtIndex(MemorySegment segment, long index, ByteOrder order, int value) {\n+        setIntAtOffset(segment, scale(segment, index, 4), order, value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset(segment, 4 * index, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param order the specified byte order.\n+     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static float getFloatAtIndex(MemorySegment segment, long index, ByteOrder order) {\n+        return getFloatAtOffset(segment, scale(segment, index, 4), order);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, 4 * index, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param order the specified byte order.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtIndex(MemorySegment segment, long index, ByteOrder order, float value) {\n+        setFloatAtOffset(segment, scale(segment, index, 4), order, value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getLongAtOffset(segment, 8 * index, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param order the specified byte order.\n+     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static long getLongAtIndex(MemorySegment segment, long index, ByteOrder order) {\n+        return getLongAtOffset(segment, scale(segment, index, 8), order);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset(segment, 8 * index, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param order the specified byte order.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtIndex(MemorySegment segment, long index, ByteOrder order, long value) {\n+        setLongAtOffset(segment, scale(segment, index, 8), order, value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getDoubleAtOffset(segment, 8 * index, order);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param order the specified byte order.\n+     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static double getDoubleAtIndex(MemorySegment segment, long index, ByteOrder order) {\n+        return getDoubleAtOffset(segment, scale(segment, index, 8), order);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and element index, with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset(segment, 8 * index, order, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param order the specified byte order.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtIndex(MemorySegment segment, long index, ByteOrder order, double value) {\n+        setDoubleAtOffset(segment, scale(segment, index, 8), order, value);\n+    }\n+\n+    @ForceInline\n+    private static long scale(MemorySegment address, long index, int size) {\n+        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":1336,"deletions":0,"binary":false,"changes":1336,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -30,0 +31,4 @@\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n+\n+import java.lang.ref.Cleaner;\n@@ -33,9 +38,3 @@\n- * {@link MemorySegment#baseAddress()} method; such addresses are said to be <em>checked<\/em>, and can be expressed\n- * as <em>offsets<\/em> into some underlying memory segment (see {@link #segment()} and {@link #segmentOffset()}).\n- * Since checked memory addresses feature both spatial and temporal bounds, these addresses can <em>safely<\/em> be\n- * dereferenced using a memory access var handle (see {@link MemoryHandles}).\n- * <p>\n- * If an address does not have any associated segment, it is said to be <em>unchecked<\/em>. Unchecked memory\n- * addresses do not feature known spatial or temporal bounds; as such, attempting a memory dereference operation\n- * using an unchecked memory address will result in a runtime exception. Unchecked addresses can be obtained\n- * e.g. by calling the {@link #ofLong(long)} method.\n+ * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory.\n+ * Given an address, it is possible to compute its offset relative to a given segment, which can be useful\n+ * when performing memory dereference operations using a memory access var handle (see {@link MemoryHandles}).\n@@ -57,1 +56,7 @@\n-public interface MemoryAddress {\n+public interface MemoryAddress extends Addressable {\n+\n+    @Override\n+    default MemoryAddress address() {\n+        return this;\n+    }\n+\n@@ -66,4 +71,16 @@\n-     * Returns the offset of this memory address into the underlying segment (if any).\n-     * @return the offset of this memory address into the underlying segment (if any).\n-     * @throws UnsupportedOperationException if no segment is associated with this memory address,\n-     * e.g. if {@code segment() == null}.\n+     * Returns the offset of this memory address into the given segment. More specifically, if both the segment's\n+     * base address and this address are off-heap addresses, the result is computed as\n+     * {@code this.toRawLongValue() - segment.address().toRawLongValue()}. Otherwise, if both addresses in the form\n+     * {@code (B, O1)}, {@code (B, O2)}, where {@code B} is the same base heap object and {@code O1}, {@code O2}\n+     * are byte offsets (relative to the base object) associated with this address and the segment's base address,\n+     * the result is computed as {@code O1 - O2}.\n+     * <p>\n+     * If the segment's base address and this address are both heap addresses, but with different base objects, the result is undefined\n+     * and an exception is thrown. Similarly, if the segment's base address is an heap address (resp. off-heap) and\n+     * this address is an off-heap (resp. heap) address, the result is undefined and an exception is thrown.\n+     * Otherwise, the result is a byte offset {@code SO}. If this address falls within the\n+     * spatial bounds of the given segment, then {@code 0 <= SO < segment.byteSize()}; otherwise, {@code SO < 0 || SO > segment.byteSize()}.\n+     * @return the offset of this memory address into the given segment.\n+     * @param segment the segment relative to which this address offset should be computed\n+     * @throws IllegalArgumentException if {@code segment} is not compatible with this address; this can happen, for instance,\n+     * when {@code segment} models an heap memory region, while this address models an off-heap memory address.\n@@ -71,1 +88,1 @@\n-    long segmentOffset();\n+    long segmentOffset(MemorySegment segment);\n@@ -74,3 +91,26 @@\n-     * Returns the raw long value associated to this memory address.\n-     * @return The raw long value associated to this memory address.\n-     * @throws UnsupportedOperationException if this memory address is associated with an heap segment.\n+     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n+     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * <p>\n+     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n+     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n+     * memory resources which might implicitly be associated with the segment. This method is equivalent to the following code:\n+     * <pre>{@code\n+    asSegmentRestricted(byteSize, null, null);\n+     * }<\/pre>\n+     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param bytesSize the desired size.\n+     * @return a new confined native memory segment with given base address and size.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n@@ -78,1 +118,3 @@\n-    long toRawLongValue();\n+    default MemorySegment asSegmentRestricted(long bytesSize) {\n+        return asSegmentRestricted(bytesSize, null, null);\n+    }\n@@ -81,2 +123,32 @@\n-     * Returns the memory segment (if any) this address belongs to.\n-     * @return The memory segment this address belongs to, or {@code null} if no such segment exists.\n+     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n+     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * Moreover, the returned segment will keep a strong reference to the supplied attachment object (if any), which can\n+     * be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n+     * <p>\n+     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n+     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n+     * memory resources which might implicitly be associated with the segment, but will result in calling the\n+     * provided cleanup action (if any).\n+     * <p>\n+     * Both the cleanup action and the attachment object (if any) will be preserved under terminal operations such as\n+     * {@link MemorySegment#handoff(Thread)}, {@link MemorySegment#share()} and {@link MemorySegment#registerCleaner(Cleaner)}.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param bytesSize the desired size.\n+     * @param cleanupAction the cleanup action; can be {@code null}.\n+     * @param attachment an attachment object that will be kept strongly reachable by the returned segment; can be {@code null}.\n+     * @return a new confined native memory segment with given base address and size.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n@@ -84,1 +156,1 @@\n-    MemorySegment segment();\n+    MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment);\n@@ -87,5 +159,3 @@\n-     * Reinterpret this address as an offset into the provided segment.\n-     * @param segment the segment to be rebased\n-     * @return a new address pointing to the same memory location through the provided segment\n-     * @throws IllegalArgumentException if the provided segment is not a valid rebase target for this address. This\n-     * can happen, for instance, if an heap-based addressed is rebased to an off-heap memory segment.\n+     * Returns the raw long value associated with this memory address.\n+     * @return The raw long value associated with this memory address.\n+     * @throws UnsupportedOperationException if this memory address is an heap address.\n@@ -93,1 +163,1 @@\n-    MemoryAddress rebase(MemorySegment segment);\n+    long toRawLongValue();\n@@ -119,2 +189,1 @@\n-     * The <em>unchecked<\/em> memory address instance modelling the {@code NULL} address. This address is <em>not<\/em> backed by\n-     * a memory segment and hence it cannot be dereferenced.\n+     * The off-heap memory address instance modelling the {@code NULL} address.\n@@ -122,1 +191,1 @@\n-    MemoryAddress NULL = new MemoryAddressImpl( 0L);\n+    MemoryAddress NULL = new MemoryAddressImpl(null,  0L);\n@@ -125,2 +194,1 @@\n-     * Obtain a new <em>unchecked<\/em> memory address instance from given long address. The returned address is <em>not<\/em> backed by\n-     * a memory segment and hence it cannot be dereferenced.\n+     * Obtain an off-heap memory address instance from given long address.\n@@ -133,1 +201,1 @@\n-                new MemoryAddressImpl(value);\n+                new MemoryAddressImpl(null, value);\n@@ -135,1 +203,0 @@\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":102,"deletions":35,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n- * (of type {@link MemoryAddress}), and zero or more {@code long} coordinate types, which can be used to emulate\n- * multi-dimensional array indexing.\n+ * (of type {@link MemorySegment}), and one {@code long} coordinate type, which represents the offset, in bytes, relative\n+ * to the segment, at which dereference should occur.\n@@ -52,1 +52,1 @@\n- * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:\n+ * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n@@ -54,2 +54,1 @@\n-SequenceLayout seq = MemoryLayout.ofSequence(5,\n-    MemoryLayout.ofStruct(\n+GroupLayout seq = MemoryLayout.ofStruct(\n@@ -58,1 +57,1 @@\n-    ));\n+);\n@@ -62,3 +61,2 @@\n-VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); \/\/(MemoryAddress) -> int\n-handle = MemoryHandles.withOffset(handle, 4); \/\/(MemoryAddress) -> int\n-handle = MemoryHandles.withStride(handle, 8); \/\/(MemoryAddress, long) -> int\n+VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); \/\/(MemorySegment, long) -> int\n+handle = MemoryHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n@@ -67,20 +65,0 @@\n- * <h2>Addressing mode<\/h2>\n- *\n- * The final memory location accessed by a memory access var handle can be computed as follows:\n- *\n- * <blockquote><pre>{@code\n-address = base + offset\n- * }<\/pre><\/blockquote>\n- *\n- * where {@code base} denotes the address expressed by the {@link MemoryAddress} access coordinate, and {@code offset}\n- * can be expressed in the following form:\n- *\n- * <blockquote><pre>{@code\n-offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n- * }<\/pre><\/blockquote>\n- *\n- * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as optional {@code long}\n- * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n- * <em>static<\/em> constants which are can be acquired through the {@link MemoryHandles#withOffset(VarHandle, long)}\n- * and the {@link MemoryHandles#withStride(VarHandle, long)} combinators, respectively.\n- *\n@@ -133,3 +111,0 @@\n-    private static final MethodHandle ADD_OFFSET;\n-    private static final MethodHandle ADD_STRIDE;\n-\n@@ -153,6 +128,0 @@\n-            ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, \"addOffset\",\n-                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));\n-\n-            ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, \"addStride\",\n-                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));\n-\n@@ -187,5 +156,6 @@\n-     * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,\n-     * and its variable type is set by the given carrier type.\n-     *\n-     * The alignment constraint for the resulting memory access var handle is the same as the in memory size of the\n-     * carrier type, and the accessed offset is set at zero.\n+     * The returned var handle's type is {@code carrier} and the list of coordinate types is\n+     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n+     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n+     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n+     * the alignment constraint (in bytes) for the resulting memory access var handle is the same as the size (in bytes) of the\n+     * carrier type {@code carrier}.\n@@ -212,4 +182,5 @@\n-     * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,\n-     * and its variable type is set by the given carrier type.\n-     *\n-     * The accessed offset is zero.\n+     * The returned var handle's type is {@code carrier} and the list of coordinate types is\n+     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n+     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n+     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n+     * the alignment constraint (in bytes) for the resulting memory access var handle is given by {@code alignmentBytes}.\n@@ -235,84 +206,1 @@\n-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, alignmentBytes - 1, byteOrder, 0, new long[]{}));\n-    }\n-\n-    \/**\n-     * Returns a var handle that adds a <em>fixed<\/em> offset to the incoming {@link MemoryAddress} coordinate\n-     * and then propagates such value to the target var handle. That is,\n-     * when the returned var handle receives a memory address coordinate pointing at a memory location at\n-     * offset <em>O<\/em>, a memory address coordinate pointing at a memory location at offset <em>O' + O<\/em>\n-     * is created, and then passed to the target var handle.\n-     *\n-     * The returned var handle will feature the same type and access coordinates as the target var handle.\n-     *\n-     * @param target the target memory access handle to access after the offset adjustment.\n-     * @param bytesOffset the offset, in bytes. Must be positive or zero.\n-     * @return the adapted var handle.\n-     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.\n-     *\/\n-    public static VarHandle withOffset(VarHandle target, long bytesOffset) {\n-        if (bytesOffset == 0) {\n-            return target; \/\/nothing to do\n-        }\n-\n-        checkAddressFirstCoordinate(target);\n-\n-        if (JLI.isMemoryAccessVarHandle(target) &&\n-                (bytesOffset & JLI.memoryAddressAlignmentMask(target)) == 0) {\n-            \/\/flatten\n-            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(\n-                    JLI.memoryAddressCarrier(target),\n-                    JLI.memoryAddressAlignmentMask(target),\n-                    JLI.memoryAddressByteOrder(target),\n-                    JLI.memoryAddressOffset(target) + bytesOffset,\n-                    JLI.memoryAddressStrides(target)));\n-        } else {\n-            \/\/slow path\n-            VarHandle res = collectCoordinates(target, 0, ADD_OFFSET);\n-            return insertCoordinates(res, 1, bytesOffset);\n-        }\n-    }\n-\n-    \/**\n-     * Returns a var handle which adds a <em>variable<\/em> offset to the incoming {@link MemoryAddress}\n-     * access coordinate value and then propagates such value to the target var handle.\n-     * That is, when the returned var handle receives a memory address coordinate pointing at a memory location at\n-     * offset <em>O<\/em>, a new memory address coordinate pointing at a memory location at offset <em>(S * X) + O<\/em>\n-     * is created, and then passed to the target var handle,\n-     * where <em>S<\/em> is a constant <em>stride<\/em>, whereas <em>X<\/em> is a dynamic value that will be\n-     * provided as an additional access coordinate (of type {@code long}).\n-     *\n-     * The returned var handle will feature the same type as the target var handle; an additional access coordinate\n-     * of type {@code long} will be added to the access coordinate types of the target var handle at the position\n-     * immediately following the leading access coordinate of type {@link MemoryAddress}.\n-     *\n-     * @param target the target memory access handle to access after the scale adjustment.\n-     * @param bytesStride the stride, in bytes, by which to multiply the coordinate value.\n-     * @return the adapted var handle.\n-     * @throws IllegalArgumentException if the first access coordinate type is not of type {@link MemoryAddress}.\n-     *\/\n-    public static VarHandle withStride(VarHandle target, long bytesStride) {\n-        if (bytesStride == 0) {\n-            return dropCoordinates(target, 1, long.class); \/\/ dummy coordinate\n-        }\n-\n-        checkAddressFirstCoordinate(target);\n-\n-        if (JLI.isMemoryAccessVarHandle(target) &&\n-                (bytesStride & JLI.memoryAddressAlignmentMask(target)) == 0) {\n-            \/\/flatten\n-            long[] strides = JLI.memoryAddressStrides(target);\n-            long[] newStrides = new long[strides.length + 1];\n-            System.arraycopy(strides, 0, newStrides, 1, strides.length);\n-            newStrides[0] = bytesStride;\n-\n-            return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(\n-                    JLI.memoryAddressCarrier(target),\n-                    JLI.memoryAddressAlignmentMask(target),\n-                    JLI.memoryAddressByteOrder(target),\n-                    JLI.memoryAddressOffset(target),\n-                    newStrides));\n-        } else {\n-            \/\/slow path\n-            VarHandle res = collectCoordinates(target, 0, ADD_STRIDE);\n-            return insertCoordinates(res, 2, bytesStride);\n-        }\n+        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder));\n@@ -322,1 +210,1 @@\n-     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemoryAddress}.\n+     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemorySegment}.\n@@ -365,2 +253,2 @@\n-    SHORT_VH.set(segment.baseAddress(), (short)-1);\n-    INT_VH.get(segment.baseAddress()); \/\/ returns 65535\n+    SHORT_VH.set(segment, (short)-1);\n+    INT_VH.get(segment); \/\/ returns 65535\n@@ -623,2 +511,2 @@\n-                handle.coordinateTypes().get(0) != MemoryAddress.class) {\n-            throw new IllegalArgumentException(\"Expected var handle with leading coordinate of type MemoryAddress\");\n+                handle.coordinateTypes().get(0) != MemorySegment.class) {\n+            throw new IllegalArgumentException(\"Expected var handle with leading coordinate of type MemorySegment\");\n@@ -665,8 +553,0 @@\n-\n-    private static MemoryAddress addOffset(MemoryAddress address, long offset) {\n-        return address.addOffset(offset);\n-    }\n-\n-    private static MemoryAddress addStride(MemoryAddress address, long index, long stride) {\n-        return address.addOffset(index * stride);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":24,"deletions":144,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        MemoryLayout.ofValueBits(8, ByteOrder.NATIVE_ORDER).withName(\"kind\"),\n+        MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n@@ -73,1 +73,1 @@\n-        MemoryLayout.ofValueBits(32, ByteOrder.NATIVE_ORDER).withName(\"value\")\n+        MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()).withName(\"value\")\n@@ -150,1 +150,1 @@\n-        MemoryLayout.ofValueBits(8, ByteOrder.NATIVE_ORDER).withName(\"kind\").\n+        MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder()).withName(\"kind\").\n@@ -373,0 +373,18 @@\n+     * <p>\n+     * The final memory location accessed by the returned memory access var handle can be computed as follows:\n+     *\n+     * <blockquote><pre>{@code\n+    address = base + offset\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code base} denotes the base address expressed by the {@link MemorySegment} access coordinate\n+     * (see {@link MemorySegment#address()} and {@link MemoryAddress#toRawLongValue()}) and {@code offset}\n+     * can be expressed in the following form:\n+     *\n+     * <blockquote><pre>{@code\n+    offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as optional {@code long}\n+     * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n+     * <em>static<\/em> stride constants which are derived from the layout path.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import jdk.internal.misc.Unsafe;\n+\n@@ -104,0 +106,5 @@\n+    \/**\n+     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}), and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final ValueLayout ADDRESS = MemoryLayout.ofValueBits(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n+\n@@ -126,0 +133,5 @@\n+     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n+     * invariant holds:\n+     * <blockquote><pre>{@code\n+    MemoryLayouts.JAVA_LONG.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n+     * }<\/pre><\/blockquote>\n@@ -127,1 +139,2 @@\n-    public static final ValueLayout JAVA_LONG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());\n+    public static final ValueLayout JAVA_LONG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder())\n+            .withBitAlignment(ADDRESS.bitSize());\n@@ -136,2 +149,8 @@\n-     *\/\n-    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());\n+     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n+     * invariant holds:\n+     * <blockquote><pre>{@code\n+    MemoryLayouts.JAVA_DOUBLE.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder())\n+            .withBitAlignment(ADDRESS.bitSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.io.FileDescriptor;\n+import java.lang.ref.Cleaner;\n@@ -41,0 +43,1 @@\n+import java.util.Optional;\n@@ -42,1 +45,0 @@\n-import java.util.function.Consumer;\n@@ -57,1 +59,1 @@\n- * <h2>Constructing memory segments from different sources<\/h2>\n+ * <h2>Constructing memory segments<\/h2>\n@@ -77,2 +79,3 @@\n- * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>\n- * (see {@link MappedMemorySegment}).\n+ * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n+ * mapped memory segments are associated with an underlying file descriptor. For more operations on mapped memory segments, please refer to the\n+ * {@link MappedMemorySegments} class.\n@@ -87,1 +90,1 @@\n- * <h2>Closing a memory segment<\/h2>\n+ * <h2>Explicit deallocation<\/h2>\n@@ -108,1 +111,1 @@\n- * {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n+ * {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n@@ -147,3 +150,4 @@\n- * Memory segments support <em>serial thread confinement<\/em>; that is, ownership of a memory segment can change (see\n- * {@link #withOwnerThread(Thread)}). This allows, for instance, for two threads {@code A} and {@code B} to share\n- * a segment in a controlled, cooperative and race-free fashion.\n+ * The {@link #handoff(Thread)} method can be used to change the thread-confinement properties of a memory segment.\n+ * This method is, like {@link #close()}, a <em>terminal operation<\/em> which marks the original segment as not alive\n+ * (see {@link #isAlive()}) and creates a <em>new<\/em> segment with the desired thread-confinement properties. Calling\n+ * {@link #handoff(Thread)} is only possible if the segment features the corresponding {@link #HANDOFF} access mode.\n@@ -151,5 +155,15 @@\n- * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently\n- * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible\n- * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to\n- * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).\n- * For instance, the following code can be used to sum all int values in a memory segment in parallel:\n+ * For instance, if a client wants to transfer ownership of a segment to another (known) thread, it can do so as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment aSegment = segment.handoff(threadA);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * By doing so, the original segment is marked as not alive, and a new segment is returned whose owner thread\n+ * is {@code threadA}; this allows, for instance, for two threads {@code A} and {@code B} to share\n+ * a segment in a controlled, cooperative and race-free fashion (also known as <em>serial thread confinement<\/em>).\n+ * <p>\n+ * Alternatively, the {@link #share()} method can be used to remove thread ownership altogether; this is only possible\n+ * if the segment features the corresponding {@link #SHARE} access mode. The following code shows how clients can\n+ * obtain a shared segment:\n+ *\n@@ -158,0 +172,10 @@\n+MemorySegment sharedSegment = segment.share();\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Again here, the original segment is marked as not alive, and a new <em>shared<\/em> segment is returned which features no owner\n+ * thread (e.g. {@link #ownerThread()} returns {@code null}). This might be useful when multiple threads need to process\n+ * the contents of the same memory segment concurrently (e.g. in the case of parallel processing). For instance, a client\n+ * might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the segment and allow multiple\n+ * threads to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:\n+ *\n+ * <blockquote><pre>{@code\n@@ -159,4 +183,27 @@\n-VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n-                       .mapToInt(s -> (int)VH_int.get(s.baseAddress()))\n-                       .sum();\n+try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).share()) {\n+    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n+    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n+                           .mapToInt(s -> (int)VH_int.get(s.address()))\n+                           .sum();\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(Thread)}); in fact, many threads\n+ * can attempt to gain ownership of the same segment, concurrently, and only one of them is guaranteed to succeed.\n+ * <p>\n+ * When using shared segments, clients should make sure that no other thread is accessing the segment while\n+ * the segment is being closed. If one or more threads attempts to access a segment concurrently while the\n+ * segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should\n+ * refrain from attempting to close a segment repeatedly (e.g. keep calling {@link #close()} until no exception is thrown);\n+ * such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads\n+ * accessing\/closing the segment.\n+ *\n+ * <h2>Implicit deallocation<\/h2>\n+ *\n+ * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n+ * that segment will be released when the segment becomes <em>unreachable<\/em>, which can be useful to prevent native memory\n+ * leaks. This can be achieved using the {@link #registerCleaner(Cleaner)} method, as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment gcSegment = segment.registerCleaner(cleaner);\n@@ -165,0 +212,5 @@\n+ * Here, the original segment is marked as not alive, and a new segment is returned (the owner thread of the returned\n+ * segment set is set to that of the current thread, see {@link #ownerThread()}); the new segment\n+ * will also be registered with the the {@link Cleaner} instance provided to the {@link #registerCleaner(Cleaner)} method;\n+ * as such, if not closed explicitly (see {@link #close()}), the new segment will be automatically closed by the cleaner.\n+ *\n@@ -166,2 +218,1 @@\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * {@link MappedMemorySegment} and other explicitly permitted subtypes.\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by other explicitly permitted subtypes.\n@@ -172,1 +223,1 @@\n-public interface MemorySegment extends AutoCloseable {\n+public interface MemorySegment extends Addressable, AutoCloseable {\n@@ -176,1 +227,1 @@\n-     * a <em>checked<\/em> memory address and can therefore be used in derefrence operations\n+     * a <em>checked<\/em> memory address and can therefore be used in dereference operations\n@@ -179,0 +230,2 @@\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment\n@@ -180,1 +233,2 @@\n-    MemoryAddress baseAddress();\n+    @Override\n+    MemoryAddress address();\n@@ -183,1 +237,1 @@\n-     * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},\n+     * Returns a spliterator for this memory segment. The returned spliterator reports {@link Spliterator#SIZED},\n@@ -187,1 +241,1 @@\n-     * The returned spliterator splits the segment according to the specified sequence layout; that is,\n+     * The returned spliterator splits this segment according to the specified sequence layout; that is,\n@@ -193,7 +247,3 @@\n-     * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then\n-     * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).\n-     * While closing the segment (see {@link #close()}) during pending concurrent execution will generally\n-     * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread\n-     * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call\n-     * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.\n-     * @param segment the segment to be used for splitting.\n+     * The returned spliterator effectively allows to slice this segment into disjoint sub-segments, which can then\n+     * be processed in parallel by multiple threads (if the segment is shared).\n+     *\n@@ -201,1 +251,0 @@\n-     * @param <S> the memory segment type\n@@ -206,3 +255,1 @@\n-    static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout layout) {\n-        return AbstractMemorySegmentImpl.spliterator(segment, layout);\n-    }\n+    Spliterator<MemorySegment> spliterator(SequenceLayout layout);\n@@ -216,21 +263,0 @@\n-    \/**\n-     * Obtains a new memory segment backed by the same underlying memory region as this segment,\n-     * but with different owner thread. As a side-effect, this segment will be marked as <em>not alive<\/em>,\n-     * and subsequent operations on this segment will result in runtime errors.\n-     * <p>\n-     * Write accesses to the segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses to the segment's contents on\n-     * the new owner thread.\n-     *\n-     * @param newOwner the new owner thread.\n-     * @return a new memory segment backed by the same underlying memory region as this segment,\n-     *      owned by {@code newOwner}.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different\n-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n-     * @throws NullPointerException if {@code newOwner == null}\n-     * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n-     *\/\n-    MemorySegment withOwnerThread(Thread newOwner);\n-\n@@ -245,1 +271,1 @@\n-     * {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n+     * {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n@@ -265,1 +291,1 @@\n-     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}.\n+     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}.\n@@ -273,0 +299,5 @@\n+     *\n+     * @see #asSlice(long)\n+     * @see #asSlice(MemoryAddress)\n+     * @see #asSlice(MemoryAddress, long)\n+     *\n@@ -280,0 +311,75 @@\n+    \/**\n+     * Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.\n+     * <p>\n+     * Equivalent to the following code:\n+     * <pre>{@code\n+    asSlice(newBase.segmentOffset(this), newSize);\n+     * }<\/pre>\n+     *\n+     * @see #asSlice(long)\n+     * @see #asSlice(MemoryAddress)\n+     * @see #asSlice(long, long)\n+     *\n+     * @param newBase The new segment base address.\n+     * @param newSize The new segment size, specified in bytes.\n+     * @return a new memory segment view with updated base\/limit addresses.\n+     * @throws NullPointerException if {@code newBase == null}.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n+     *\/\n+    default MemorySegment asSlice(MemoryAddress newBase, long newSize) {\n+        Objects.requireNonNull(newBase);\n+        return asSlice(newBase.segmentOffset(this), newSize);\n+    }\n+\n+    \/**\n+     * Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,\n+     * and whose new size is computed by subtracting the specified offset from this segment size.\n+     * <p>\n+     * Equivalent to the following code:\n+     * <pre>{@code\n+    asSlice(offset, byteSize() - offset);\n+     * }<\/pre>\n+     *\n+     * @see #asSlice(MemoryAddress)\n+     * @see #asSlice(MemoryAddress, long)\n+     * @see #asSlice(long, long)\n+     *\n+     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @return a new memory segment view with updated base\/limit addresses.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, or {@code offset > byteSize()}.\n+     *\/\n+    default MemorySegment asSlice(long offset) {\n+        return asSlice(offset, byteSize() - offset);\n+    }\n+\n+    \/**\n+     * Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting\n+     * the address offset relative to this segment (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.\n+     * <p>\n+     * Equivalent to the following code:\n+     * <pre>{@code\n+    asSlice(newBase.segmentOffset(this));\n+     * }<\/pre>\n+     *\n+     * @see #asSlice(long)\n+     * @see #asSlice(MemoryAddress, long)\n+     * @see #asSlice(long, long)\n+     *\n+     * @param newBase The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @return a new memory segment view with updated base\/limit addresses.\n+     * @throws NullPointerException if {@code newBase == null}.\n+     * @throws IndexOutOfBoundsException if {@code address.segmentOffset(this) < 0}, or {@code address.segmentOffset(this) > byteSize()}.\n+     *\/\n+    default MemorySegment asSlice(MemoryAddress newBase) {\n+        Objects.requireNonNull(newBase);\n+        return asSlice(newBase.segmentOffset(this));\n+    }\n+\n+    \/**\n+     * Is this a mapped segment? Returns true if this segment is a mapped memory segment,\n+     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * @return {@code true} if this segment is a mapped segment.\n+     *\/\n+    boolean isMapped();\n+\n@@ -288,2 +394,4 @@\n-     * Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,\n-     * or to access any {@link MemoryAddress} instance associated with it will fail with {@link IllegalStateException}.\n+     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n@@ -292,0 +400,8 @@\n+     *\n+     * @apiNote This operation is not idempotent; that is, closing an already closed segment <em>always<\/em> results in an\n+     * exception being thrown. This reflects a deliberate design choice: segment state transitions should be\n+     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n+     * logic. This is especially useful when reasoning about the lifecycle of dependent segment views (see {@link #asSlice(MemoryAddress)},\n+     * where closing one segment might side-effect multiple segments. In such cases it might in fact not be obvious, looking\n+     * at the code, as to whether a given segment is alive or not.\n+     *\n@@ -293,2 +409,2 @@\n-     * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different\n-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n+     * thread owning this segment, or if this segment is shared and the segment is concurrently accessed while this method is\n+     * called.\n@@ -299,0 +415,66 @@\n+    \/**\n+     * Obtains a new confined memory segment backed by the same underlying memory region as this segment. The returned segment will\n+     * be confined on the specified thread, and will feature the same spatial bounds and access modes (see {@link #accessModes()})\n+     * as this segment.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n+     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n+     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on the new owner thread.\n+     *\n+     * @param thread the new owner thread\n+     * @return a new confined memory segment whose owner thread is set to {@code thread}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n+     * @throws NullPointerException if {@code thread == null}\n+     *\/\n+    MemorySegment handoff(Thread thread);\n+\n+    \/**\n+     * Obtains a new shared memory segment backed by the same underlying memory region as this segment. The returned segment will\n+     * not be confined on any thread and can therefore be accessed concurrently from multiple threads; moreover, the\n+     * returned segment will feature the same spatial bounds and access modes (see {@link #accessModes()})\n+     * as this segment.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n+     * Write accesses to this segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on a new thread.\n+     *\n+     * @return a new memory shared segment backed by the same underlying memory region as this segment.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     *\/\n+    MemorySegment share();\n+\n+    \/**\n+     * Register this memory segment instance against a {@link Cleaner} object, by returning a new memory segment backed\n+     * by the same underlying memory region as this segment. The returned segment will feature the same confinement,\n+     * spatial bounds and access modes (see {@link #accessModes()}) as this segment. Moreover, the returned segment\n+     * will be associated with the specified {@link Cleaner} object; this allows for the segment to be closed\n+     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n+     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n+     * The implicit deallocation behavior associated with the returned segment will be preserved under terminal\n+     * operations such as {@link #handoff(Thread)} and {@link #share()}.\n+     *\n+     * @param cleaner the cleaner object, responsible for implicit deallocation of the returned segment.\n+     * @return a new memory segment backed by the same underlying memory region as this segment, which features\n+     * implicit deallocation.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment, or if this segment is already associated with a cleaner.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.\n+     *\/\n+    MemorySegment registerCleaner(Cleaner cleaner);\n+\n@@ -309,1 +491,1 @@\n-     byteHandle.set(segment.baseAddress(), l, value);\n+     byteHandle.set(segment.address(), l, value);\n@@ -337,1 +519,1 @@\n-     * For example, this may occur if the same file is {@link MemorySegment#mapFromPath mapped} to two segments.\n+     * For example, this may occur if the same file is {@link MemorySegment#mapFile mapped} to two segments.\n@@ -352,1 +534,1 @@\n-     * {@link #baseAddress() base address} of each segment and will be in the\n+     * {@link #address() base address} of each segment and will be in the\n@@ -382,0 +564,5 @@\n+     * The returned buffer's position (see {@link ByteBuffer#position()} is initially set to zero, while\n+     * the returned buffer's capacity and limit (see {@link ByteBuffer#capacity()} and {@link ByteBuffer#limit()}, respectively)\n+     * are set to this segment' size (see {@link MemorySegment#byteSize()}). For this reason, a byte buffer cannot be\n+     * returned if this segment' size is greater than {@link Integer#MAX_VALUE}.\n+     * <p>\n@@ -386,1 +573,6 @@\n-     * The resulting buffer's byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using\n+     * If this segment is <em>shared<\/em>, calling certain I\/O operations on the resulting buffer might result in\n+     * an unspecified exception being thrown. Examples of such problematic operations are {@link FileChannel#read(ByteBuffer)},\n+     * {@link FileChannel#write(ByteBuffer)}, {@link java.nio.channels.SocketChannel#read(ByteBuffer)} and\n+     * {@link java.nio.channels.SocketChannel#write(ByteBuffer)}.\n+     * <p>\n+     * Finally, the resulting buffer's byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using\n@@ -407,1 +599,67 @@\n-     * Creates a new buffer memory segment that models the memory associated with the given byte\n+     * Copy the contents of this memory segment into a fresh short array.\n+     * @return a fresh short array copy of this memory segment.\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n+     * segment's contents cannot be copied into a {@link short[]} instance, e.g. because {@code byteSize() % 2 != 0},\n+     * or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n+     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     *\/\n+    short[] toShortArray();\n+\n+    \/**\n+     * Copy the contents of this memory segment into a fresh char array.\n+     * @return a fresh char array copy of this memory segment.\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n+     * segment's contents cannot be copied into a {@link char[]} instance, e.g. because {@code byteSize() % 2 != 0},\n+     * or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n+     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     *\/\n+    char[] toCharArray();\n+\n+    \/**\n+     * Copy the contents of this memory segment into a fresh int array.\n+     * @return a fresh int array copy of this memory segment.\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n+     * segment's contents cannot be copied into a {@link int[]} instance, e.g. because {@code byteSize() % 4 != 0},\n+     * or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n+     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     *\/\n+    int[] toIntArray();\n+\n+    \/**\n+     * Copy the contents of this memory segment into a fresh float array.\n+     * @return a fresh float array copy of this memory segment.\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n+     * segment's contents cannot be copied into a {@link float[]} instance, e.g. because {@code byteSize() % 4 != 0},\n+     * or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n+     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     *\/\n+    float[] toFloatArray();\n+\n+    \/**\n+     * Copy the contents of this memory segment into a fresh long array.\n+     * @return a fresh long array copy of this memory segment.\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n+     * segment's contents cannot be copied into a {@link long[]} instance, e.g. because {@code byteSize() % 8 != 0},\n+     * or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n+     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     *\/\n+    long[] toLongArray();\n+\n+    \/**\n+     * Copy the contents of this memory segment into a fresh double array.\n+     * @return a fresh double array copy of this memory segment.\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n+     * segment's contents cannot be copied into a {@link double[]} instance, e.g. because {@code byteSize() % 8 != 0},\n+     * or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n+     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     *\/\n+    double[] toDoubleArray();\n+\n+    \/**\n+     * Creates a new confined buffer memory segment that models the memory associated with the given byte\n@@ -413,1 +671,1 @@\n-     * not feature the {@link #WRITE} access mode.\n+     * not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -419,1 +677,1 @@\n-     * @return a new buffer memory segment.\n+     * @return a new confined buffer memory segment.\n@@ -426,1 +684,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n@@ -430,1 +688,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -433,1 +691,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -440,1 +698,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n@@ -444,1 +702,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -447,1 +705,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -454,1 +712,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n@@ -458,1 +716,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -461,1 +719,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -468,1 +726,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n@@ -471,1 +729,2 @@\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>.\n+     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -474,1 +733,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -481,1 +740,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n@@ -485,1 +744,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -488,1 +747,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -495,1 +754,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n@@ -499,1 +758,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -502,1 +761,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -509,1 +768,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n@@ -516,1 +775,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -523,1 +782,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout.\n@@ -543,1 +802,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n@@ -555,1 +814,1 @@\n-     * @return a new native memory segment.\n+     * @return a new confined native memory segment.\n@@ -563,1 +822,1 @@\n-     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * Creates a new confined mapped memory segment that models a memory-mapped region of a file from a given path.\n@@ -567,1 +826,15 @@\n-     * the segment will not feature the {@link #WRITE} access mode.\n+     * the segment will not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * <p>\n+     * The content of a mapped memory segment can change at any time, for example\n+     * if the content of the corresponding region of the mapped file is changed by\n+     * this (or another) program.  Whether or not such changes occur, and when they\n+     * occur, is operating-system dependent and therefore unspecified.\n+     * <p>\n+     * All or part of a mapped memory segment may become\n+     * inaccessible at any time, for example if the backing mapped file is truncated.  An\n+     * attempt to access an inaccessible region of a mapped memory segment will not\n+     * change the segment's content and will cause an unspecified exception to be\n+     * thrown either at the time of the access or at some later time.  It is\n+     * therefore strongly recommended that appropriate precautions be taken to\n+     * avoid the manipulation of a mapped file by this (or another) program, except to read or write\n+     * the file's content.\n@@ -576,2 +849,2 @@\n-     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).\n-     * @return a new mapped memory segment.\n+     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegments#force(MemorySegment)}).\n+     * @return a new confined mapped memory segment.\n@@ -580,1 +853,2 @@\n-     * @throws UnsupportedOperationException if an unsupported map mode is specified.\n+     * @throws UnsupportedOperationException if an unsupported map mode is specified, or if the {@code path} is associated\n+     * with a provider that does not support creating file channels.\n@@ -582,0 +856,4 @@\n+     * @throws  SecurityException If a security manager is installed and it denies an unspecified permission required by the implementation.\n+     * In the case of the default provider, the {@link SecurityManager#checkRead(String)} method is invoked to check\n+     * read access if the file is opened for reading. The {@link SecurityManager#checkWrite(String)} method is invoked to check\n+     * write access if the file is opened for writing.\n@@ -583,1 +861,1 @@\n-    static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n@@ -588,1 +866,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size and\n@@ -590,1 +868,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -598,1 +876,1 @@\n-     * @return a new native memory segment.\n+     * @return a new confined native memory segment.\n@@ -616,6 +894,9 @@\n-     * Returns a new native memory segment with given base address and size; the returned segment has its own temporal\n-     * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup\n-     * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,\n-     * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code\n-     * (often as a plain {@code long} value). The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}).\n+     * Returns a shared native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n+     * This method can be very useful when dereferencing memory addresses obtained when interacting with native libraries.\n+     * The segment will feature the {@link #READ} and {@link #WRITE} <a href=\"#access-modes\">access modes<\/a>.\n+     * Equivalent to (but likely more efficient than) the following code:\n+     * <pre>{@code\n+    MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE)\n+                 .withOwnerThread(null)\n+                 .withAccessModes(READ | WRITE);\n+     * }<\/pre>\n@@ -627,11 +908,1 @@\n-     * @param addr the desired base address\n-     * @param bytesSize the desired size.\n-     * @param owner the desired owner thread. If {@code owner == null}, the returned segment is <em>not<\/em> confined.\n-     * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the\n-     *                returned segment. If {@code cleanup == null}, no cleanup action is executed.\n-     * @param attachment an object that must be kept alive by the returned segment; this can be useful when\n-     *                   the returned segment depends on memory which could be released if a certain object\n-     *                   is determined to be unreacheable. In most cases this will be set to {@code null}.\n-     * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.\n+     * @return a memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n@@ -640,1 +911,0 @@\n-     * @throws NullPointerException if {@code addr == null}.\n@@ -642,5 +912,1 @@\n-    static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {\n-        Objects.requireNonNull(addr);\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n+    static MemorySegment ofNativeRestricted() {\n@@ -648,1 +914,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);\n+        return NativeMemorySegmentImpl.EVERYTHING;\n@@ -675,2 +941,1 @@\n-     * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator\n-     * (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n+     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #share()}).\n@@ -680,1 +945,1 @@\n-    int ACQUIRE = CLOSE << 1;\n+    int SHARE = CLOSE << 1;\n@@ -684,1 +949,1 @@\n-     * (see {@link #withOwnerThread(Thread)}).\n+     * (see {@link #handoff(Thread)}).\n@@ -688,1 +953,1 @@\n-    int HANDOFF = ACQUIRE << 1;\n+    int HANDOFF = SHARE << 1;\n@@ -695,1 +960,1 @@\n-    int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;\n+    int ALL_ACCESS = READ | WRITE | CLOSE | SHARE | HANDOFF;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":397,"deletions":132,"binary":false,"changes":529,"status":"modified"},{"patch":"@@ -31,3 +31,6 @@\n- * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which can\n- * sometimes be expressed as an offset into a given segment. A memory address represents the main access coordinate of a memory access var handle, which can be obtained\n- * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class\n+ * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which also can\n+ * reside either inside or outside the Java heap (and can sometimes be expressed as an offset into a given segment).\n+ * A memory segment represents the main access coordinate of a memory access var handle, which can be obtained\n+ * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class; a set of\n+ * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * be useful for simple, non-structured access. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class\n@@ -42,2 +45,0 @@\n-static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n-\n@@ -45,3 +46,2 @@\n-    MemoryAddress base = segment.baseAddress();\n-    for (long i = 0 ; i < 10 ; i++) {\n-       intHandle.set(base.addOffset(i * 4), (int)i);\n+    for (int i = 0 ; i < 10 ; i++) {\n+       MemoryAccess.setIntAtIndex(segment, i);\n@@ -52,4 +52,1 @@\n- * Here we create a var handle, namely {@code intHandle}, to manipulate values of the primitive type {@code int}, at\n- * a given memory location. Also, {@code intHandle} is stored in a {@code static} and {@code final} field, to achieve\n- * better performance and allow for inlining of the memory access operation through the {@link java.lang.invoke.VarHandle}\n- * instance. We then create a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * Here create a <em>native<\/em> memory segment, that is, a memory segment backed by\n@@ -60,1 +57,3 @@\n- * the contents of the memory segment; more specifically, if we view the memory segment as a set of 10 adjacent slots,\n+ * the contents of the memory segment using the\n+ * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n+ * more specifically, if we view the memory segment as a set of 10 adjacent slots,\n@@ -80,3 +79,3 @@\n- * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment using\n- * a memory address, such an address is validated (upon access), to make sure that it does not point to a memory location\n- * which resides <em>outside<\/em> the boundaries of the memory segment it refers to. We call this guarantee <em>spatial safety<\/em>;\n+ * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment,\n+ * the access coordinates are validated (upon access), to make sure that access does not occur at an address which resides\n+ * <em>outside<\/em> the boundaries of the memory segment used by the dereference operation. We call this guarantee <em>spatial safety<\/em>;\n@@ -86,2 +85,2 @@\n- * Since memory segments can be closed (see above), a memory address is also validated (upon access) to make sure that\n- * the segment it belongs to has not been closed prematurely. We call this guarantee <em>temporal safety<\/em>. Note that,\n+ * Since memory segments can be closed (see above), segments are also validated (upon access) to make sure that\n+ * the segment being accessed has not been closed prematurely. We call this guarantee <em>temporal safety<\/em>. Note that,\n@@ -90,2 +89,2 @@\n- * <a href=\"MemorySegment.html#thread-confinement\"><em>thread-confinement<\/em><\/a> guarantees on memory segments: each\n- * memory segment is associated with an owner thread, which is the only thread that can either access or close the segment.\n+ * <em>thread-confinement<\/em> guarantees on memory segments: upon creation, a memory segment is associated with an owner thread,\n+ * which is the only thread that can either access or close the segment.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.*;\n@@ -37,1 +33,1 @@\n-import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -42,0 +38,1 @@\n+import java.io.FileDescriptor;\n@@ -43,0 +40,1 @@\n+import java.lang.ref.Cleaner;\n@@ -44,5 +42,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Random;\n-import java.util.Spliterator;\n+import java.util.*;\n@@ -50,0 +44,2 @@\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n@@ -62,1 +58,1 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -104,0 +100,6 @@\n+    @Override\n+    public AbstractMemorySegmentImpl asSlice(long offset) {\n+        checkBounds(offset, 0);\n+        return asSliceNoCheck(offset, length - offset);\n+    }\n+\n@@ -108,4 +110,4 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout sequenceLayout) {\n-        ((AbstractMemorySegmentImpl)segment).checkValidState();\n-        if (sequenceLayout.byteSize() != segment.byteSize()) {\n+    @Override\n+    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {\n+        checkValidState();\n+        if (sequenceLayout.byteSize() != byteSize()) {\n@@ -114,2 +116,2 @@\n-        return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n-                (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));\n+        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n+                withAccessModes(accessModes() & ~CLOSE));\n@@ -120,2 +122,2 @@\n-        checkRange(0, length, true);\n-        UNSAFE.setMemory(base(), min(), length, value);\n+        checkAccess(0, length, false);\n+        SCOPED_MEMORY_ACCESS.setMemory(scope, base(), min(), length, value);\n@@ -128,3 +130,3 @@\n-        checkRange(0, size, true);\n-        that.checkRange(0, size, false);\n-        UNSAFE.copyMemory(\n+        checkAccess(0, size, false);\n+        that.checkAccess(0, size, true);\n+        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n@@ -135,3 +137,0 @@\n-    private final static VarHandle BYTE_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n-            .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n-\n@@ -144,2 +143,2 @@\n-        this.checkRange(0, length, false);\n-        that.checkRange(0, length, false);\n+        this.checkAccess(0, length, true);\n+        that.checkAccess(0, length, true);\n@@ -147,0 +146,1 @@\n+            checkValidState();\n@@ -152,1 +152,1 @@\n-            if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {\n+            if (MemoryAccess.getByte(this) != MemoryAccess.getByte(that)) {\n@@ -155,1 +155,1 @@\n-            i = ArraysSupport.vectorizedMismatchLargeForBytes(\n+            i = vectorizedMismatchLargeForBytes(scope, that.scope,\n@@ -166,2 +166,0 @@\n-        MemoryAddress thisAddress = this.baseAddress();\n-        MemoryAddress thatAddress = that.baseAddress();\n@@ -169,1 +167,1 @@\n-            if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {\n+            if (MemoryAccess.getByteAtOffset(this, i) != MemoryAccess.getByteAtOffset(that, i)) {\n@@ -176,0 +174,32 @@\n+    \/**\n+     * Mismatch over long lengths.\n+     *\/\n+    private static long vectorizedMismatchLargeForBytes(MemoryScope aScope, MemoryScope bScope,\n+                                                       Object a, long aOffset,\n+                                                       Object b, long bOffset,\n+                                                       long length) {\n+        long off = 0;\n+        long remaining = length;\n+        int i, size;\n+        boolean lastSubRange = false;\n+        while (remaining > 7 && !lastSubRange) {\n+            if (remaining > Integer.MAX_VALUE) {\n+                size = Integer.MAX_VALUE;\n+            } else {\n+                size = (int) remaining;\n+                lastSubRange = true;\n+            }\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aScope, bScope,\n+                    a, aOffset + off,\n+                    b, bOffset + off,\n+                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n+            if (i >= 0)\n+                return off + i;\n+\n+            i = size - ~i;\n+            off += i;\n+            remaining -= i;\n+        }\n+        return ~remaining;\n+    }\n+\n@@ -178,2 +208,3 @@\n-    public final MemoryAddress baseAddress() {\n-        return new MemoryAddressImpl(this, 0);\n+    public final MemoryAddress address() {\n+        checkValidState();\n+        return new MemoryAddressImpl(base(), min());\n@@ -187,1 +218,1 @@\n-        checkIntSize(\"ByteBuffer\");\n+        checkArraySize(\"ByteBuffer\", 1);\n@@ -237,3 +268,3 @@\n-    @Override\n-    public MemorySegment withOwnerThread(Thread newOwner) {\n-        Objects.requireNonNull(newOwner);\n+    public MemorySegment handoff(Thread thread) {\n+        Objects.requireNonNull(thread);\n+        checkValidState();\n@@ -243,9 +274,5 @@\n-        if (scope.ownerThread() == newOwner) {\n-            throw new IllegalArgumentException(\"Segment already owned by thread: \" + newOwner);\n-        } else {\n-            try {\n-                return dup(0L, length, mask, scope.dup(newOwner));\n-            } finally {\n-                \/\/flush read\/writes to segment memory before returning the new segment\n-                VarHandle.fullFence();\n-            }\n+        try {\n+            return dup(0L, length, mask, scope.confineTo(thread));\n+        } finally {\n+            \/\/flush read\/writes to segment memory before returning the new segment\n+            VarHandle.fullFence();\n@@ -256,1 +283,17 @@\n-    public final void close() {\n+    public MemorySegment share() {\n+        checkValidState();\n+        if (!isSet(SHARE)) {\n+            throw unsupportedAccessMode(SHARE);\n+        }\n+        try {\n+            return dup(0L, length, mask, scope.share());\n+        } finally {\n+            \/\/flush read\/writes to segment memory before returning the new segment\n+            VarHandle.fullFence();\n+        }\n+    }\n+\n+    @Override\n+    public MemorySegment registerCleaner(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        checkValidState();\n@@ -260,1 +303,1 @@\n-        closeNoCheck();\n+        return dup(0L, length, mask, scope.cleanable(cleaner));\n@@ -263,1 +306,6 @@\n-    private final void closeNoCheck() {\n+    @Override\n+    public final void close() {\n+        checkValidState();\n+        if (!isSet(CLOSE)) {\n+            throw unsupportedAccessMode(CLOSE);\n+        }\n@@ -267,5 +315,3 @@\n-    final AbstractMemorySegmentImpl acquire() {\n-        if (Thread.currentThread() != ownerThread() && !isSet(ACQUIRE)) {\n-            throw unsupportedAccessMode(ACQUIRE);\n-        }\n-        return dup(0, length, mask, scope.acquire());\n+    @Override\n+    public boolean isMapped() {\n+        return false;\n@@ -276,3 +322,37 @@\n-        checkIntSize(\"byte[]\");\n-        byte[] arr = new byte[(int)length];\n-        MemorySegment arrSegment = MemorySegment.ofArray(arr);\n+        return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);\n+    }\n+\n+    @Override\n+    public final short[] toShortArray() {\n+        return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);\n+    }\n+\n+    @Override\n+    public final char[] toCharArray() {\n+        return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);\n+    }\n+\n+    @Override\n+    public final int[] toIntArray() {\n+        return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);\n+    }\n+\n+    @Override\n+    public final float[] toFloatArray() {\n+        return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);\n+    }\n+\n+    @Override\n+    public final long[] toLongArray() {\n+        return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);\n+    }\n+\n+    @Override\n+    public final double[] toDoubleArray() {\n+        return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);\n+    }\n+\n+    private <Z> Z toArray(Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n+        int size = checkArraySize(arrayClass.getSimpleName(), elemSize);\n+        Z arr = arrayFactory.apply(size);\n+        MemorySegment arrSegment = segmentFactory.apply(arr);\n@@ -283,1 +363,2 @@\n-    boolean isSmall() {\n+    @Override\n+    public boolean isSmall() {\n@@ -287,3 +368,3 @@\n-    void checkRange(long offset, long length, boolean writeAccess) {\n-        scope.checkValidState();\n-        if (writeAccess && !isSet(WRITE)) {\n+    @Override\n+    public void checkAccess(long offset, long length, boolean readOnly) {\n+        if (!readOnly && !isSet(WRITE)) {\n@@ -291,1 +372,1 @@\n-        } else if (!writeAccess && !isSet(READ)) {\n+        } else if (readOnly && !isSet(READ)) {\n@@ -297,0 +378,18 @@\n+    private void checkAccessAndScope(long offset, long length, boolean readOnly) {\n+        checkValidState();\n+        checkAccess(offset, length, readOnly);\n+    }\n+\n+    private void checkValidState() {\n+        try {\n+            scope.checkValidState();\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @Override\n+    public long unsafeGetOffset() {\n+        return min();\n+    }\n+\n@@ -298,2 +397,2 @@\n-    public final void checkValidState() {\n-        scope.checkValidState();\n+    public Object unsafeGetBase() {\n+        return base();\n@@ -308,2 +407,6 @@\n-    private void checkIntSize(String typeName) {\n-        if (length > (Integer.MAX_VALUE - 8)) { \/\/conservative check\n+    private int checkArraySize(String typeName, int elemSize) {\n+        if (length % elemSize != 0) {\n+            throw new UnsupportedOperationException(String.format(\"Segment size is not a multiple of %d. Size: %d\", elemSize, length));\n+        }\n+        long arraySize = length \/ elemSize;\n+        if (arraySize > (Integer.MAX_VALUE - 8)) { \/\/conservative check\n@@ -312,0 +415,1 @@\n+        return (int)arraySize;\n@@ -326,0 +430,5 @@\n+    @Override\n+    public MemoryScope scope() {\n+        return scope;\n+    }\n+\n@@ -350,2 +459,2 @@\n-        if ((mode & ACQUIRE) != 0) {\n-            modes.add(\"ACQUIRE\");\n+        if ((mode & SHARE) != 0) {\n+            modes.add(\"SHARE\");\n@@ -401,1 +510,1 @@\n-                AbstractMemorySegmentImpl acquired = segment.acquire();\n+                AbstractMemorySegmentImpl acquired = segment;\n@@ -405,1 +514,0 @@\n-                    acquired.closeNoCheck();\n@@ -421,1 +529,1 @@\n-                AbstractMemorySegmentImpl acquired = segment.acquire();\n+                AbstractMemorySegmentImpl acquired = segment;\n@@ -436,1 +544,0 @@\n-                    acquired.closeNoCheck();\n@@ -477,1 +584,1 @@\n-            bufferScope = MemoryScope.create(bb, null);\n+            bufferScope = MemoryScope.createConfined(bb, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n@@ -491,24 +598,0 @@\n-\n-    public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(\n-        0, 0, MemoryScope.createUnchecked(null, null, null)\n-    ) {\n-        @Override\n-        ByteBuffer makeByteBuffer() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        long min() {\n-            return 0;\n-        }\n-\n-        @Override\n-        Object base() {\n-            return null;\n-        }\n-\n-        @Override\n-        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {\n-            throw new UnsupportedOperationException();\n-        }\n-    };\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":182,"deletions":99,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        MemoryScope scope = MemoryScope.create(null, null);\n+        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryHandles;\n@@ -29,0 +30,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -31,1 +33,1 @@\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -36,0 +38,1 @@\n+import sun.invoke.util.Wrapper;\n@@ -37,0 +40,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -38,0 +44,1 @@\n+import java.util.ArrayDeque;\n@@ -39,0 +46,1 @@\n+import java.util.Deque;\n@@ -42,1 +50,0 @@\n-import java.util.stream.LongStream;\n@@ -56,0 +63,11 @@\n+    private static final MethodHandle ADD_STRIDE;\n+\n+    static {\n+        try {\n+            ADD_STRIDE = MethodHandles.lookup().findStatic(LayoutPath.class, \"addStride\",\n+                    MethodType.methodType(long.class, MemorySegment.class, long.class, long.class, long.class));\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -144,6 +162,24 @@\n-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(\n-                carrier,\n-                layout.byteAlignment() - 1, \/\/mask\n-                ((ValueLayout) layout).order(),\n-                Utils.bitsToBytesOrThrow(offset, IllegalStateException::new),\n-                LongStream.of(strides).map(s -> Utils.bitsToBytesOrThrow(s, IllegalStateException::new)).toArray()));\n+        List<Class<?>> expectedCoordinates = new ArrayList<>();\n+        Deque<Integer> perms = new ArrayDeque<>();\n+        perms.addFirst(0);\n+        expectedCoordinates.add(MemorySegment.class);\n+\n+        VarHandle handle = Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,\n+                ((ValueLayout)layout).order()));\n+\n+        for (int i = 0 ; i < strides.length ; i++) {\n+            expectedCoordinates.add(long.class);\n+            perms.addFirst(0);\n+            perms.addLast(i + 1);\n+            \/\/add stride\n+            handle = MemoryHandles.collectCoordinates(handle, 1 + i,\n+                    MethodHandles.insertArguments(ADD_STRIDE, 1, Utils.bitsToBytesOrThrow(strides[strides.length - 1 - i], IllegalStateException::new))); \/\/ MS, long, MS_n, long_n, long\n+        }\n+        \/\/add offset\n+        handle = MemoryHandles.insertCoordinates(handle, 1 + strides.length, Utils.bitsToBytesOrThrow(offset, IllegalStateException::new));\n+\n+        if (strides.length > 0) {\n+            \/\/ remove duplicate MS args\n+            handle = MemoryHandles.permuteCoordinates(handle, expectedCoordinates, perms.stream().mapToInt(i -> i).toArray());\n+        }\n+        return handle;\n@@ -287,0 +323,5 @@\n+\n+    private static long addStride(MemorySegment segment, long stride, long base, long index) {\n+        return MemorySegmentProxy.addOffsets(base,\n+                    MemorySegmentProxy.multiplyOffsets(stride, index, ((MemorySegmentProxy)segment)), (MemorySegmentProxy)segment);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import jdk.incubator.foreign.MappedMemorySegment;\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -32,0 +30,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -34,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -40,0 +40,1 @@\n+import java.util.Optional;\n@@ -47,1 +48,1 @@\n-public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl implements MappedMemorySegment {\n+public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n@@ -51,0 +52,2 @@\n+    static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -58,1 +61,0 @@\n-        JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n@@ -81,0 +83,10 @@\n+    public boolean isMapped() {\n+        return true;\n+    }\n+\n+    \/\/ support for mapped segments\n+\n+    public MemorySegment segment() {\n+        return MappedMemorySegmentImpl.this;\n+    }\n+\n@@ -82,1 +94,1 @@\n-        nioAccess.load(min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.load(scope, min, unmapper.isSync(), length);\n@@ -85,1 +97,0 @@\n-    @Override\n@@ -87,1 +98,1 @@\n-        nioAccess.unload(min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.unload(scope, min, unmapper.isSync(), length);\n@@ -90,1 +101,0 @@\n-    @Override\n@@ -92,1 +102,1 @@\n-        return nioAccess.isLoaded(min, unmapper.isSync(), length);\n+        return SCOPED_MEMORY_ACCESS.isLoaded(scope, min, unmapper.isSync(), length);\n@@ -95,1 +105,0 @@\n-    @Override\n@@ -97,1 +106,1 @@\n-        nioAccess.force(unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+        SCOPED_MEMORY_ACCESS.force(scope, unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n@@ -102,1 +111,1 @@\n-    public static MappedMemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n@@ -107,1 +116,1 @@\n-            MemoryScope scope = MemoryScope.create(null, unmapperProxy::unmap);\n+            MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap, null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.internal.access.foreign.MemoryAddressProxy;\n-import jdk.internal.misc.Unsafe;\n-\n@@ -40,3 +37,1 @@\n-public final class MemoryAddressImpl implements MemoryAddress, MemoryAddressProxy {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+public final class MemoryAddressImpl implements MemoryAddress {\n@@ -44,1 +39,1 @@\n-    private final AbstractMemorySegmentImpl segment;\n+    private final Object base;\n@@ -47,7 +42,2 @@\n-    public MemoryAddressImpl(long offset) {\n-        this.segment = AbstractMemorySegmentImpl.NOTHING;\n-        this.offset = offset;\n-    }\n-\n-    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {\n-        this.segment = Objects.requireNonNull(segment);\n+    public MemoryAddressImpl(Object base, long offset) {\n+        this.base = base;\n@@ -60,3 +50,5 @@\n-    public long segmentOffset() {\n-        if (segment() == null) {\n-            throw new UnsupportedOperationException(\"Address does not have a segment\");\n+    public long segmentOffset(MemorySegment segment) {\n+        Objects.requireNonNull(segment);\n+        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;\n+        if (segmentImpl.base() != base) {\n+            throw new IllegalArgumentException(\"Invalid segment: \" + segment);\n@@ -64,1 +56,1 @@\n-        return offset;\n+        return offset - segmentImpl.min();\n@@ -69,1 +61,1 @@\n-        if (unsafeGetBase() != null) {\n+        if (base != null) {\n@@ -72,7 +64,1 @@\n-        return unsafeGetOffset();\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        return segment != AbstractMemorySegmentImpl.NOTHING ?\n-                segment : null;\n+        return offset;\n@@ -83,1 +69,1 @@\n-        return new MemoryAddressImpl(segment, offset + bytes);\n+        return new MemoryAddressImpl(base, offset + bytes);\n@@ -86,28 +72,0 @@\n-    @Override\n-    public MemoryAddress rebase(MemorySegment segment) {\n-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;\n-        if (segmentImpl.base() != this.segment.base()) {\n-            throw new IllegalArgumentException(\"Invalid rebase target: \" + segment);\n-        }\n-        return new MemoryAddressImpl((AbstractMemorySegmentImpl)segment,\n-                unsafeGetOffset() - ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset());\n-    }\n-\n-    \/\/ MemoryAddressProxy methods\n-\n-    public void checkAccess(long offset, long length, boolean readOnly) {\n-        segment.checkRange(MemoryAddressProxy.addOffsets(this.offset, offset, this), length, !readOnly);\n-    }\n-\n-    public long unsafeGetOffset() {\n-        return segment.min() + offset;\n-    }\n-\n-    public Object unsafeGetBase() {\n-        return segment.base();\n-    }\n-\n-    @Override\n-    public boolean isSmall() {\n-        return segment.isSmall();\n-    }\n@@ -118,1 +76,1 @@\n-        return Objects.hash(unsafeGetBase(), unsafeGetOffset());\n+        return Objects.hash(base, offset);\n@@ -125,2 +83,2 @@\n-            return Objects.equals(unsafeGetBase(), ((MemoryAddressImpl) that).unsafeGetBase()) &&\n-                    unsafeGetOffset() == addr.unsafeGetOffset();\n+            return Objects.equals(base, addr.base) &&\n+                    offset == addr.offset;\n@@ -134,1 +92,10 @@\n-        return \"MemoryAddress{ region: \" + segment + \" offset=0x\" + Long.toHexString(offset) + \" }\";\n+        return \"MemoryAddress{ base: \" + base + \" offset=0x\" + Long.toHexString(offset) + \" }\";\n+    }\n+\n+    @Override\n+    public MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment) {\n+        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize, cleanupAction, attachment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":26,"deletions":59,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.ref.PhantomCleanable;\n@@ -33,0 +35,2 @@\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n@@ -34,2 +38,0 @@\n-import java.util.concurrent.atomic.LongAdder;\n-import java.util.concurrent.locks.StampedLock;\n@@ -39,18 +41,10 @@\n- * as thread confinement.\n- * A scope has a liveness bit, which is updated when the scope is closed\n- * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}).\n- * A scope may also have an associated \"owner\" thread that confines some operations to\n- * associated owner thread such as {@link #close()} or {@link #dup(Thread)}.\n- * Furthermore, a scope is either root scope ({@link #create(Object, Runnable) created}\n- * when memory segment is allocated) or child scope ({@link #acquire() acquired} from root scope).\n- * When a child scope is acquired from another child scope, it is actually acquired from\n- * the root scope. There is only a single level of children. All child scopes are peers.\n- * A child scope can be {@link #close() closed} at any time, but root scope can only\n- * be closed after all its children have been closed, at which time any associated\n- * cleanup action is executed (the associated memory segment is freed).\n- * Besides thread-confined checked scopes, {@linkplain #createUnchecked(Thread, Object, Runnable)}\n- * method may be used passing {@code null} as the \"owner\" thread to create a\n- * scope that doesn't check for thread-confinement while its temporal bounds are\n- * enforced reliably only under condition that thread that closes the scope is also\n- * the single thread performing the checked access or there is an external synchronization\n- * in place that prevents concurrent access and closing of the scope.\n+ * as thread confinement. A scope has a liveness bit, which is updated when the scope is closed\n+ * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}). This bit is consulted prior\n+ * to memory access (see {@link #checkValidState()}).\n+ * There are two kinds of memory scope: confined memory scope and shared memory scope.\n+ * A confined memory scope has an associated owner thread that confines some operations to\n+ * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n+ * Shared scopes do not feature an owner thread - meaning their operations can be called, in a racy\n+ * manner, by multiple threads. To guarantee temporal safety in the presence of concurrent thread,\n+ * shared scopes use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n+ * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n@@ -58,1 +52,12 @@\n-abstract class MemoryScope {\n+abstract class MemoryScope implements ScopedMemoryAccess.Scope {\n+\n+    static final Runnable DUMMY_CLEANUP_ACTION = () -> { };\n+\n+    private MemoryScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+        Objects.requireNonNull(cleanupAction);\n+        this.ref = ref;\n+        this.cleanupAction = cleanupAction;\n+        this.scopeCleanable = cleaner != null ?\n+                new ScopeCleanable(this, cleaner, cleanupAction) :\n+                null;\n+    }\n@@ -61,8 +66,2 @@\n-     * Creates a root MemoryScope with given ref, cleanupAction and current\n-     * thread as the \"owner\" thread.\n-     * This method may be called in any thread.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in the thread that created the scope\n-     * or else IllegalStateException is thrown.\n-     *\n+     * Creates a confined memory scope with given attachment and cleanup action. The returned scope\n+     * is assumed to be confined on the current thread.\n@@ -70,2 +69,2 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n-     * @return a root MemoryScope\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n+     * @return a confined memory scope\n@@ -73,2 +72,2 @@\n-    static MemoryScope create(Object ref, Runnable cleanupAction) {\n-        return new Root(Thread.currentThread(), ref, cleanupAction);\n+    static MemoryScope createConfined(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction, cleaner);\n@@ -78,11 +77,1 @@\n-     * Creates a root MemoryScope with given ref, cleanupAction and \"owner\" thread.\n-     * This method may be called in any thread.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in given owner thread or else IllegalStateException is thrown.\n-     * If given owner thread is null, the returned MemoryScope is unchecked, meaning\n-     * that all methods may be called in any thread and that {@link #checkValidState()}\n-     * does not check for temporal bounds.\n-     *\n-     * @param owner         the desired owner thread. If {@code owner == null},\n-     *                      the returned scope is <em>not<\/em> thread-confined and not checked.\n+     * Creates a shared memory scope with given attachment and cleanup action.\n@@ -90,2 +79,2 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n-     * @return a root MemoryScope\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n+     * @return a shared memory scope\n@@ -93,2 +82,2 @@\n-    static MemoryScope createUnchecked(Thread owner, Object ref, Runnable cleanupAction) {\n-        return new Root(owner, ref, cleanupAction);\n+    static MemoryScope createShared(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+        return new SharedScope(ref, cleanupAction, cleaner);\n@@ -97,3 +86,3 @@\n-    private final Thread owner;\n-    private boolean closed; \/\/ = false\n-    private static final VarHandle CLOSED;\n+    protected final Object ref;\n+    protected final ScopeCleanable scopeCleanable;\n+    protected final Runnable cleanupAction;\n@@ -101,1 +90,6 @@\n-    static {\n+    \/**\n+     * Closes this scope, executing any cleanup action (where provided).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n+     *\/\n+    final void close() {\n@@ -103,3 +97,7 @@\n-            CLOSED = MethodHandles.lookup().findVarHandle(MemoryScope.class, \"closed\", boolean.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n+            justClose();\n+            cleanupAction.run();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+        } finally {\n+            Reference.reachabilityFence(this);\n@@ -109,3 +107,1 @@\n-    private MemoryScope(Thread owner) {\n-        this.owner = owner;\n-    }\n+    abstract void justClose();\n@@ -114,18 +110,3 @@\n-     * Acquires a child scope (or peer scope if this is a child) with current\n-     * thread as the \"owner\" thread.\n-     * This method may be called in any thread.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in the thread that acquired the scope\n-     * or else IllegalStateException is thrown.\n-     *\n-     * @return a child (or peer) scope\n-     * @throws IllegalStateException if root scope is already closed\n-     *\/\n-    abstract MemoryScope acquire();\n-\n-    \/**\n-     * Closes this scope, executing any cleanup action if this is the root scope.\n-     * This method may only be called in the \"owner\" thread of this scope unless the\n-     * scope is a root scope with no owner thread - i.e. is not checked.\n-     *\n+     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n+     * @param newOwner new owner thread of the returned memory scope\n+     * @return a new confined scope, which is a duplicate of this scope, but with a new owner thread.\n@@ -133,3 +114,1 @@\n-     *                               a root scope and there is\/are still active child\n-     *                               scope(s) or if this method is called outside of\n-     *                               owner thread in checked scope\n+     * a confined scope and this method is called outside of the owner thread.\n@@ -137,1 +116,12 @@\n-    abstract void close();\n+    final MemoryScope confineTo(Thread newOwner) {\n+        try {\n+            justClose();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+            return new ConfinedScope(newOwner, ref, cleanupAction, scopeCleanable != null ?\n+                    scopeCleanable.cleaner : null);\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n@@ -141,13 +131,1 @@\n-     * If this is a root scope, a new root scope is returned; this root scope is closed, but\n-     * without executing the cleanup action, which is instead transferred to the duped scope.\n-     * If this is a child scope, a new child scope is returned.\n-     * This method may only be called in the \"owner\" thread of this scope unless the\n-     * scope is a root scope with no owner thread - i.e. is not checked.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in given new \"owner\" thread\n-     * or else IllegalStateException is thrown.\n-     *\n-     * @param newOwner new owner thread of the returned MemoryScope\n-     * @return a duplicate of this scope\n-     * @throws NullPointerException  if given owner thread is null\n+     * @return a new shared scope, which is a duplicate of this scope.\n@@ -155,3 +133,2 @@\n-     *                               a root scope and there is\/are still active child\n-     *                               scope(s) or if this method is called outside of\n-     *                               owner thread in checked scope\n+     * a confined scope and this method is called outside of the owner thread,\n+     * or if this is already a shared scope.\n@@ -159,1 +136,26 @@\n-    abstract MemoryScope dup(Thread newOwner);\n+    final MemoryScope share() {\n+        try {\n+            justClose();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+            return new SharedScope(ref, cleanupAction, scopeCleanable != null ?\n+                    scopeCleanable.cleaner : null);\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+    final MemoryScope cleanable(Cleaner cleaner) {\n+        if (scopeCleanable != null) {\n+            throw new IllegalStateException(\"Already registered with a cleaner\");\n+        }\n+        try {\n+            justClose();\n+            return ownerThread() == null ?\n+                    new SharedScope(ref, cleanupAction, cleaner) :\n+                    new ConfinedScope(ownerThread(), ref, cleanupAction, cleaner);\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n@@ -163,2 +165,1 @@\n-     *\n-     * @return owner thread (or null for unchecked scope)\n+     * @return owner thread (or null for a shared scope)\n@@ -166,3 +167,1 @@\n-    final Thread ownerThread() {\n-        return owner;\n-    }\n+    public abstract Thread ownerThread();\n@@ -171,2 +170,1 @@\n-     * This method may be called in any thread.\n-     *\n+     * Returns true, if this scope is still alive. This method may be called in any thread.\n@@ -175,3 +173,1 @@\n-    final boolean isAlive() {\n-        return !((boolean)CLOSED.getVolatile(this));\n-    }\n+    public abstract boolean isAlive();\n@@ -180,7 +176,3 @@\n-     * Checks that this scope is still alive and that this method is executed\n-     * in the \"owner\" thread of this scope or this scope is unchecked (not associated\n-     * with owner thread).\n-     *\n-     * @throws IllegalStateException if this scope is already closed or this\n-     *                               method is executed outside owning thread\n-     *                               in checked scope\n+     * Checks that this scope is still alive (see {@link #isAlive()}).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n@@ -188,6 +180,5 @@\n-    @ForceInline\n-    final void checkValidState() {\n-        if (owner != null && owner != Thread.currentThread()) {\n-            throw new IllegalStateException(\"Attempted access outside owning thread\");\n-        }\n-        checkAliveConfined(this);\n+    public abstract void checkValidState();\n+\n+    @Override\n+    protected Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n@@ -197,3 +188,4 @@\n-     * Checks that this scope is still alive.\n-     *\n-     * @throws IllegalStateException if this scope is already closed\n+     * A confined scope, which features an owner thread. The liveness check features an additional\n+     * confinement check - that is, calling any operation on this scope from a thread other than the\n+     * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n+     * can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}).\n@@ -201,6 +193,1 @@\n-    @ForceInline\n-    private static void checkAliveConfined(MemoryScope scope) {\n-        if (scope.closed) {\n-            throw new IllegalStateException(\"This segment is already closed\");\n-        }\n-    }\n+    static class ConfinedScope extends MemoryScope {\n@@ -208,5 +195,2 @@\n-    private static final class Root extends MemoryScope {\n-        private final StampedLock lock = new StampedLock();\n-        private final LongAdder acquired = new LongAdder();\n-        private final Object ref;\n-        private final Runnable cleanupAction;\n+        private boolean closed; \/\/ = false\n+        final Thread owner;\n@@ -214,4 +198,3 @@\n-        private Root(Thread owner, Object ref, Runnable cleanupAction) {\n-            super(owner);\n-            this.ref = ref;\n-            this.cleanupAction = cleanupAction;\n+        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+            super(ref, cleanupAction, cleaner);\n+            this.owner = owner;\n@@ -220,24 +203,7 @@\n-        @Override\n-        MemoryScope acquire() {\n-            \/\/ try to optimistically acquire the lock\n-            long stamp = lock.tryOptimisticRead();\n-            try {\n-                for (; ; stamp = lock.readLock()) {\n-                    if (stamp == 0L)\n-                        continue;\n-                    checkAliveConfined(this); \/\/ plain read is enough here (either successful optimistic read, or full read lock)\n-\n-                    \/\/ increment acquires\n-                    acquired.increment();\n-                    \/\/ did a call to close() occur since we acquired the lock?\n-                    if (lock.validate(stamp)) {\n-                        \/\/ no, just return the acquired scope\n-                        return new Child(Thread.currentThread());\n-                    } else {\n-                        \/\/ yes, just back off and retry (close might have failed, after all)\n-                        acquired.decrement();\n-                    }\n-                }\n-            } finally {\n-                if (StampedLock.isReadLockStamp(stamp))\n-                    lock.unlockRead(stamp);\n+        @ForceInline\n+        public final void checkValidState() {\n+            if (owner != Thread.currentThread()) {\n+                throw new IllegalStateException(\"Attempted access outside owning thread\");\n+            }\n+            if (closed) {\n+                throw ScopedAccessError.INSTANCE;\n@@ -248,6 +214,7 @@\n-        MemoryScope dup(Thread newOwner) {\n-            Objects.requireNonNull(newOwner, \"newOwner\");\n-            \/\/ pre-allocate duped scope so we don't get OOME later and be left with this scope closed\n-            var duped = new Root(newOwner, ref, cleanupAction);\n-            justClose();\n-            return duped;\n+        public boolean isAlive() {\n+            return !closed;\n+        }\n+\n+        void justClose() {\n+            checkValidState();\n+            closed = true;\n@@ -257,5 +224,2 @@\n-        void close() {\n-            justClose();\n-            if (cleanupAction != null) {\n-                cleanupAction.run();\n-            }\n+        public Thread ownerThread() {\n+            return owner;\n@@ -263,0 +227,1 @@\n+    }\n@@ -264,4 +229,23 @@\n-        @ForceInline\n-        private void justClose() {\n-            \/\/ enter critical section - no acquires are possible past this point\n-            long stamp = lock.writeLock();\n+    \/**\n+     * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n+     * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n+     * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n+     * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n+     * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+     * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n+     * checking the liveness bit upon access can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}),\n+     * as in the confined case.\n+     *\/\n+    static class SharedScope extends MemoryScope {\n+\n+        static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+        final static int ALIVE = 0;\n+        final static int CLOSING = 1;\n+        final static int CLOSED = 2;\n+\n+        int state = ALIVE;\n+\n+        private static final VarHandle STATE;\n+\n+        static {\n@@ -269,10 +253,3 @@\n-                checkValidState(); \/\/ plain read is enough here (full write lock)\n-                \/\/ check for absence of active acquired children\n-                if (acquired.sum() > 0) {\n-                    throw new IllegalStateException(\"Cannot close this scope as it has active acquired children\");\n-                }\n-                \/\/ now that we made sure there's no active acquired children, we can mark scope as closed\n-                CLOSED.set(this, true); \/\/ plain write is enough here (full write lock)\n-            } finally {\n-                \/\/ leave critical section\n-                lock.unlockWrite(stamp);\n+                STATE = MethodHandles.lookup().findVarHandle(SharedScope.class, \"state\", int.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n@@ -282,1 +259,3 @@\n-        private final class Child extends MemoryScope {\n+        SharedScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+            super(ref, cleanupAction, cleaner);\n+        }\n@@ -284,3 +263,4 @@\n-            private Child(Thread owner) {\n-                super(owner);\n-            }\n+        @Override\n+        public Thread ownerThread() {\n+            return null;\n+        }\n@@ -288,3 +268,4 @@\n-            @Override\n-            MemoryScope acquire() {\n-                return Root.this.acquire();\n+        @Override\n+        public void checkValidState() {\n+            if (state != ALIVE) {\n+                throw ScopedAccessError.INSTANCE;\n@@ -292,0 +273,1 @@\n+        }\n@@ -293,7 +275,3 @@\n-            @Override\n-            MemoryScope dup(Thread newOwner) {\n-                checkValidState(); \/\/ child scope is always checked\n-                \/\/ pre-allocate duped scope so we don't get OOME later and be left with this scope closed\n-                var duped = new Child(newOwner);\n-                CLOSED.setVolatile(this, true);\n-                return duped;\n+        void justClose() {\n+            if (!STATE.compareAndSet(this, ALIVE, CLOSING)) {\n+                throw new IllegalStateException(\"Already closed\");\n@@ -301,8 +279,4 @@\n-\n-            @Override\n-            void close() {\n-                checkValidState(); \/\/ child scope is always checked\n-                CLOSED.set(this, true);\n-                \/\/ following acts as a volatile write after plain write above so\n-                \/\/ plain write gets flushed too (which is important for isAliveThreadSafe())\n-                Root.this.acquired.decrement();\n+            boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+            STATE.setVolatile(this, success ? CLOSED : ALIVE);\n+            if (!success) {\n+                throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n@@ -311,0 +285,21 @@\n+\n+        @Override\n+        public boolean isAlive() {\n+            return (int)STATE.getVolatile(this) != CLOSED;\n+        }\n+    }\n+\n+    static class ScopeCleanable extends PhantomCleanable<MemoryScope> {\n+        final Cleaner cleaner;\n+        final Runnable cleanupAction;\n+\n+        public ScopeCleanable(MemoryScope referent, Cleaner cleaner, Runnable cleanupAction) {\n+            super(referent, cleaner);\n+            this.cleaner = cleaner;\n+            this.cleanupAction = cleanupAction;\n+        }\n+\n+        @Override\n+        protected void performCleanup() {\n+            cleanupAction.run();\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":205,"deletions":210,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -34,0 +32,1 @@\n+import jdk.internal.misc.VM;\n@@ -45,0 +44,4 @@\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, MemoryScope.DUMMY_CLEANUP_ACTION, null)\n+            .share()\n+            .withAccessModes(READ | WRITE);\n+\n@@ -49,1 +52,1 @@\n-    private final static long MAX_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n+    private final static long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n@@ -68,1 +71,0 @@\n-        JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n@@ -85,4 +87,2 @@\n-        long alignedSize = bytesSize;\n-\n-        if (alignmentBytes > MAX_ALIGN) {\n-            alignedSize = bytesSize + (alignmentBytes - 1);\n+        if (VM.isDirectMemoryPageAligned()) {\n+            alignmentBytes = Math.max(alignmentBytes, nioAccess.pageSize());\n@@ -90,0 +90,5 @@\n+        long alignedSize = alignmentBytes > MAX_MALLOC_ALIGN ?\n+                bytesSize + (alignmentBytes - 1) :\n+                bytesSize;\n+\n+        nioAccess.reserveMemory(alignedSize, bytesSize);\n@@ -96,1 +101,4 @@\n-        MemoryScope scope = MemoryScope.create(null, () -> unsafe.freeMemory(buf));\n+        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n+                unsafe.freeMemory(buf);\n+                nioAccess.unreserveMemory(alignedSize, bytesSize);\n+            }, null);\n@@ -106,3 +114,3 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {\n-        MemoryScope scope = MemoryScope.createUnchecked(owner, attachment, cleanup);\n-        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), scope);\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, Object ref) {\n+        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize),\n+                MemoryScope.createConfined(ref, cleanupAction == null ? MemoryScope.DUMMY_CLEANUP_ACTION : cleanupAction, null));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,1 +30,2 @@\n-import jdk.internal.access.foreign.MemoryAddressProxy;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -49,1 +49,1 @@\n-    private static final MethodHandle ADDRESS_FILTER;\n+    private static final MethodHandle SEGMENT_FILTER;\n@@ -53,2 +53,2 @@\n-            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, \"filterAddress\",\n-                    MethodType.methodType(MemoryAddressProxy.class, MemoryAddress.class));\n+            SEGMENT_FILTER = MethodHandles.lookup().findStatic(Utils.class, \"filterSegment\",\n+                    MethodType.methodType(MemorySegmentProxy.class, MemorySegment.class));\n@@ -73,3 +73,3 @@\n-        \/\/ This adaptation is required, otherwise the memory access var handle will have type MemoryAddressProxy,\n-        \/\/ and not MemoryAddress (which the user expects), which causes performance issues with asType() adaptations.\n-        return MemoryHandles.filterCoordinates(handle, 0, ADDRESS_FILTER);\n+        \/\/ This adaptation is required, otherwise the memory access var handle will have type MemorySegmentProxy,\n+        \/\/ and not MemorySegment (which the user expects), which causes performance issues with asType() adaptations.\n+        return MemoryHandles.filterCoordinates(handle, 0, SEGMENT_FILTER);\n@@ -78,2 +78,2 @@\n-    private static MemoryAddressProxy filterAddress(MemoryAddress addr) {\n-        return (MemoryAddressImpl)addr;\n+    private static MemorySegmentProxy filterSegment(MemorySegment segment) {\n+        return (AbstractMemorySegmentImpl)segment;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -562,1 +562,0 @@\n-java\/foreign\/TestMismatch.java 8255270 generic-i586\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -73,1 +74,1 @@\n-            BASE_ADDR = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, \"baseAddress\", MethodType.methodType(MemoryAddress.class, MemorySegment.class));\n+            BASE_ADDR = MethodHandles.lookup().findStatic(TestAdaptVarHandles.class, \"baseAddress\", MethodType.methodType(MemorySegment.class, MemorySegment.class));\n@@ -89,0 +90,7 @@\n+    static final VarHandle intHandleIndexed = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)\n+            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+\n+    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+\n+    static final VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n+\n@@ -95,2 +103,2 @@\n-        i2SHandle.set(segment.baseAddress(), \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), \"42\");\n+        i2SHandle.set(segment, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n@@ -98,1 +106,1 @@\n-        String value = (String)i2SHandle.get(segment.baseAddress());\n+        String value = (String)i2SHandle.get(segment);\n@@ -100,1 +108,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n@@ -102,1 +110,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n@@ -104,1 +112,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n@@ -116,2 +124,2 @@\n-        i2SHandle.set(segment.baseAddress(), \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), \"42\");\n+        i2SHandle.set(segment, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n@@ -119,1 +127,1 @@\n-        String value = (String)i2SHandle.get(segment.baseAddress());\n+        String value = (String)i2SHandle.get(segment);\n@@ -121,1 +129,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n@@ -123,1 +131,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n@@ -125,1 +133,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n@@ -135,2 +143,2 @@\n-        i2SHandle.set(segment.baseAddress(), \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), \"42\");\n+        i2SHandle.set(segment, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n@@ -138,1 +146,1 @@\n-        String value = (String)i2SHandle.get(segment.baseAddress());\n+        String value = (String)i2SHandle.get(segment);\n@@ -140,1 +148,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n@@ -142,1 +150,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n@@ -144,1 +152,1 @@\n-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());\n+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n@@ -155,1 +163,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -161,1 +168,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -167,1 +173,0 @@\n-        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n@@ -219,2 +224,1 @@\n-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);\n-        VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandle, 0, BASE_ADDR, S2L);\n+        VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandleIndexed, 0, BASE_ADDR, S2L);\n@@ -241,1 +245,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -247,1 +250,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -253,1 +255,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -259,2 +260,1 @@\n-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);\n-        MemoryHandles.filterCoordinates(intHandle, 1, S2I);\n+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2I);\n@@ -265,2 +265,1 @@\n-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);\n-        MemoryHandles.filterCoordinates(intHandle, 1, S2L_EX);\n+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L_EX);\n@@ -271,2 +270,1 @@\n-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);\n-        MemoryHandles.filterCoordinates(intHandle, 1, S2L, S2L);\n+        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L, S2L);\n@@ -279,2 +277,1 @@\n-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);\n-        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.baseAddress(), 0L);\n+        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandleIndexed, 0, segment, 0L);\n@@ -301,1 +298,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -307,1 +303,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -313,1 +308,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -319,2 +313,1 @@\n-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);\n-        MemoryHandles.insertCoordinates(intHandle, 1, \"Hello\");\n+        MemoryHandles.insertCoordinates(intHandleIndexed, 1, \"Hello\");\n@@ -325,2 +318,1 @@\n-        VarHandle intHandle = MemoryHandles.withStride(MemoryLayouts.JAVA_INT.varHandle(int.class), 4);\n-        MemoryHandles.insertCoordinates(intHandle, 1, 0L, 0L);\n+        MemoryHandles.insertCoordinates(intHandleIndexed, 1, 0L, 0L);\n@@ -333,5 +325,4 @@\n-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);\n-        VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandle,\n-                List.of(long.class, MemoryAddress.class), 1, 0);\n-        intHandle_swap.set(0L, segment.baseAddress(), 1);\n-        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.baseAddress(), 42);\n+        VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandleIndexed,\n+                List.of(long.class, MemorySegment.class), 1, 0);\n+        intHandle_swap.set(0L, segment, 1);\n+        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment, 42);\n@@ -339,1 +330,1 @@\n-        int value = (int)intHandle_swap.get(0L, segment.baseAddress());\n+        int value = (int)intHandle_swap.get(0L, segment);\n@@ -341,1 +332,1 @@\n-        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment.baseAddress(), 43, 12);\n+        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment, 43, 12);\n@@ -343,1 +334,1 @@\n-        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment.baseAddress(), 12, 42);\n+        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment, 12, 42);\n@@ -345,1 +336,1 @@\n-        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment.baseAddress());\n+        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment);\n@@ -356,1 +347,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -362,1 +352,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -368,1 +357,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -374,1 +362,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -380,1 +367,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -386,1 +372,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -394,4 +379,3 @@\n-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);\n-        VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);\n-        intHandle_sum.set(segment.baseAddress(), -2L, 2L, 1);\n-        int oldValue = (int)intHandle_sum.getAndAdd(segment.baseAddress(), -2L, 2L, 42);\n+        VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandleIndexed, 1, SUM_OFFSETS);\n+        intHandle_sum.set(segment, -2L, 2L, 1);\n+        int oldValue = (int)intHandle_sum.getAndAdd(segment, -2L, 2L, 42);\n@@ -399,1 +383,1 @@\n-        int value = (int)intHandle_sum.get(segment.baseAddress(), -2L, 2L);\n+        int value = (int)intHandle_sum.get(segment, -2L, 2L);\n@@ -401,1 +385,1 @@\n-        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment.baseAddress(), -2L, 2L, 43, 12);\n+        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment, -2L, 2L, 43, 12);\n@@ -403,1 +387,1 @@\n-        oldValue = (int)intHandle_sum.compareAndExchange(segment.baseAddress(), -2L, 2L, 12, 42);\n+        oldValue = (int)intHandle_sum.compareAndExchange(segment, -2L, 2L, 12, 42);\n@@ -405,1 +389,1 @@\n-        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), -2L, 2L);\n+        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, -2L, 2L);\n@@ -416,1 +400,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -422,1 +405,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -428,1 +410,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -434,1 +415,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -440,1 +420,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -446,1 +425,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -454,4 +432,3 @@\n-        VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);\n-        VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandle, 1, float.class, String.class);\n-        intHandle_dummy.set(segment.baseAddress(), 1f, \"hello\", 0L, 1);\n-        int oldValue = (int)intHandle_dummy.getAndAdd(segment.baseAddress(), 1f, \"hello\", 0L, 42);\n+        VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandleIndexed, 1, float.class, String.class);\n+        intHandle_dummy.set(segment, 1f, \"hello\", 0L, 1);\n+        int oldValue = (int)intHandle_dummy.getAndAdd(segment, 1f, \"hello\", 0L, 42);\n@@ -459,1 +436,1 @@\n-        int value = (int)intHandle_dummy.get(segment.baseAddress(), 1f, \"hello\", 0L);\n+        int value = (int)intHandle_dummy.get(segment, 1f, \"hello\", 0L);\n@@ -461,1 +438,1 @@\n-        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.baseAddress(), 1f, \"hello\", 0L, 43, 12);\n+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment, 1f, \"hello\", 0L, 43, 12);\n@@ -463,1 +440,1 @@\n-        oldValue = (int)intHandle_dummy.compareAndExchange(segment.baseAddress(), 1f, \"hello\", 0L, 12, 42);\n+        oldValue = (int)intHandle_dummy.compareAndExchange(segment, 1f, \"hello\", 0L, 12, 42);\n@@ -465,1 +442,1 @@\n-        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), 1f, \"hello\", 0L);\n+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 1f, \"hello\", 0L);\n@@ -471,1 +448,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -477,1 +453,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -483,1 +458,0 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -510,2 +484,2 @@\n-    static MemoryAddress baseAddress(MemorySegment segment) {\n-        return segment.baseAddress();\n+    static MemorySegment baseAddress(MemorySegment segment) {\n+        return segment;\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":58,"deletions":84,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());\n+        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n@@ -66,4 +66,4 @@\n-            MemoryAddress target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n-                    segment.baseAddress().addOffset(8 - byteSize) :\n-                    segment.baseAddress();\n-            longHandle.set(segment.baseAddress(), 42L);\n+            MemorySegment target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n+                    segment.asSlice(8 - byteSize) :\n+                    segment;\n+            longHandle.set(segment, 42L);\n@@ -72,6 +72,0 @@\n-            try {\n-                longHandle.get(address); \/\/ check that address cannot be de-referenced\n-                fail();\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(true);\n-            }\n@@ -79,1 +73,1 @@\n-            long result = (long)longHandle.get(segment.baseAddress());\n+            long result = (long)longHandle.get(segment);\n@@ -86,1 +80,1 @@\n-        VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());\n+        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n@@ -88,2 +82,2 @@\n-            longHandle.set(segment.baseAddress(), 0L);\n-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());\n+            longHandle.set(segment, 0L);\n+            MemoryAddress address = (MemoryAddress)addrHandle.get(segment);\n@@ -96,1 +90,1 @@\n-        VarHandle floatHandle = MemoryHandles.varHandle(float.class, ByteOrder.nativeOrder());\n+        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n@@ -102,1 +96,1 @@\n-        VarHandle doubleHandle = MemoryHandles.varHandle(double.class, ByteOrder.nativeOrder());\n+        VarHandle doubleHandle = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);\n@@ -108,1 +102,1 @@\n-        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -115,1 +109,1 @@\n-        VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n@@ -124,2 +118,1 @@\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder())), 8 },\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },\n+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },\n@@ -129,2 +122,1 @@\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())), 4 },\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },\n+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },\n@@ -134,2 +126,1 @@\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder())), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },\n+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },\n@@ -139,2 +130,1 @@\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder())), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },\n+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },\n@@ -144,2 +134,1 @@\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder())), 1 },\n-                { MemoryHandles.asAddressVarHandle(MemoryHandles.withOffset(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },\n+                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },\n@@ -150,0 +139,4 @@\n+    static VarHandle at(VarHandle handle, long offset) {\n+        return MemoryHandles.insertCoordinates(handle, 1, offset);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":22,"deletions":29,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -40,0 +41,1 @@\n+import java.util.function.Function;\n@@ -84,1 +86,1 @@\n-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {\n+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {\n@@ -90,6 +92,6 @@\n-    static void checkBytes(MemoryAddress base, SequenceLayout layout) {\n-        long nBytes = layout.elementCount().getAsLong() * layout.elementLayout().byteSize();\n-        byte[] arr = base.segment().toByteArray();\n-        for (long i = 0 ; i < nBytes ; i++) {\n-            byte expected = (byte)byteHandle.get(base, i);\n-            byte found = arr[(int)i];\n+    static void checkBytes(MemorySegment base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {\n+        int nelems = (int)layout.elementCount().getAsLong();\n+        Object arr = arrayFactory.apply(base);\n+        for (int i = 0; i < nelems; i++) {\n+            Object found = handleGetter.apply(base, (long) i);\n+            Object expected = java.lang.reflect.Array.get(arr, i);\n@@ -101,1 +103,1 @@\n-    public void testArrays(Consumer<MemoryAddress> init, SequenceLayout layout) {\n+    public void testArrays(Consumer<MemorySegment> init, Consumer<MemorySegment> checker, MemoryLayout layout) {\n@@ -103,2 +105,2 @@\n-            init.accept(segment.baseAddress());\n-            checkBytes(segment.baseAddress(), layout);\n+            init.accept(segment);\n+            checker.accept(segment);\n@@ -108,4 +110,7 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testTooBigForArray() {\n-        try (MemorySegment segment = MemorySegment.ofNativeRestricted(MemoryAddress.NULL, (long)Integer.MAX_VALUE + 10L, null, null, null)) {\n-            segment.toByteArray();\n+    @Test(dataProvider = \"elemLayouts\",\n+            expectedExceptions = UnsupportedOperationException.class)\n+    public void testTooBigForArray(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        MemoryLayout seq = MemoryLayout.ofSequence((Integer.MAX_VALUE * layout.byteSize()) + 1, layout);\n+        \/\/do not really allocate here, as it's way too much memory\n+        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize())) {\n+            arrayFactory.apply(segment);\n@@ -115,3 +120,13 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testArrayFromClosedSegment() {\n-        MemorySegment segment = MemorySegment.allocateNative(8);\n+    @Test(dataProvider = \"elemLayouts\",\n+            expectedExceptions = UnsupportedOperationException.class)\n+    public void testBadSize(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        if (layout.byteSize() == 1) throw new UnsupportedOperationException(); \/\/make it fail\n+        try (MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1)) {\n+            arrayFactory.apply(segment);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"elemLayouts\",\n+            expectedExceptions = IllegalStateException.class)\n+    public void testArrayFromClosedSegment(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        MemorySegment segment = MemorySegment.allocateNative(layout);\n@@ -119,1 +134,1 @@\n-        segment.toByteArray();\n+        arrayFactory.apply(segment);\n@@ -122,5 +137,6 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromHeapSegmentWithoutAccess() {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[8]);\n-        segment = segment.withAccessModes(segment.accessModes() & ~READ);\n-        segment.toByteArray();\n+    @Test(dataProvider = \"elemLayouts\",\n+            expectedExceptions = UnsupportedOperationException.class)\n+    public void testArrayFromHeapSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[(int)layout.byteSize()]);\n+        segment = segment.withAccessModes(MemorySegment.ALL_ACCESS & ~READ);\n+        arrayFactory.apply(segment);\n@@ -129,5 +145,6 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromNativeSegmentWithoutAccess() {\n-        MemorySegment segment = MemorySegment.allocateNative(8);\n-        segment = segment.withAccessModes(segment.accessModes() & ~READ);\n-        segment.toByteArray();\n+    @Test(dataProvider = \"elemLayouts\",\n+            expectedExceptions = UnsupportedOperationException.class)\n+    public void testArrayFromNativeSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n+        try (MemorySegment segment = MemorySegment.allocateNative(layout).withAccessModes(MemorySegment.ALL_ACCESS & ~READ)) {\n+            arrayFactory.apply(segment);\n+        }\n@@ -138,1 +155,1 @@\n-        Consumer<MemoryAddress> byteInitializer =\n+        Consumer<MemorySegment> byteInitializer =\n@@ -140,1 +157,1 @@\n-        Consumer<MemoryAddress> charInitializer =\n+        Consumer<MemorySegment> charInitializer =\n@@ -142,1 +159,1 @@\n-        Consumer<MemoryAddress> shortInitializer =\n+        Consumer<MemorySegment> shortInitializer =\n@@ -144,1 +161,1 @@\n-        Consumer<MemoryAddress> intInitializer =\n+        Consumer<MemorySegment> intInitializer =\n@@ -146,1 +163,1 @@\n-        Consumer<MemoryAddress> floatInitializer =\n+        Consumer<MemorySegment> floatInitializer =\n@@ -148,1 +165,1 @@\n-        Consumer<MemoryAddress> longInitializer =\n+        Consumer<MemorySegment> longInitializer =\n@@ -150,1 +167,1 @@\n-        Consumer<MemoryAddress> doubleInitializer =\n+        Consumer<MemorySegment> doubleInitializer =\n@@ -153,0 +170,15 @@\n+        Consumer<MemorySegment> byteChecker =\n+                (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+        Consumer<MemorySegment> shortChecker =\n+                (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));\n+        Consumer<MemorySegment> charChecker =\n+                (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));\n+        Consumer<MemorySegment> intChecker =\n+                (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));\n+        Consumer<MemorySegment> floatChecker =\n+                (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));\n+        Consumer<MemorySegment> longChecker =\n+                (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));\n+        Consumer<MemorySegment> doubleChecker =\n+                (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+\n@@ -154,7 +186,20 @@\n-                {byteInitializer, bytes},\n-                {charInitializer, chars},\n-                {shortInitializer, shorts},\n-                {intInitializer, ints},\n-                {floatInitializer, floats},\n-                {longInitializer, longs},\n-                {doubleInitializer, doubles}\n+                {byteInitializer, byteChecker, bytes},\n+                {charInitializer, charChecker, chars},\n+                {shortInitializer, shortChecker, shorts},\n+                {intInitializer, intChecker, ints},\n+                {floatInitializer, floatChecker, floats},\n+                {longInitializer, longChecker, longs},\n+                {doubleInitializer, doubleChecker, doubles}\n+        };\n+    }\n+\n+    @DataProvider(name = \"elemLayouts\")\n+    public Object[][] elemLayouts() {\n+        return new Object[][] {\n+                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegment::toByteArray },\n+                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegment::toShortArray },\n+                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegment::toCharArray },\n+                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegment::toIntArray },\n+                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegment::toFloatArray },\n+                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegment::toLongArray },\n+                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegment::toDoubleArray }\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":87,"deletions":42,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n@@ -34,1 +32,2 @@\n-import jdk.incubator.foreign.MappedMemorySegment;\n+import jdk.incubator.foreign.MappedMemorySegments;\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -65,0 +64,1 @@\n+import java.util.ArrayList;\n@@ -66,0 +66,1 @@\n+import java.util.List;\n@@ -76,1 +77,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -137,10 +137,1 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());\n-\n-\n-    static void initTuples(MemoryAddress base, long count) {\n+    static void initTuples(MemorySegment base, long count) {\n@@ -153,1 +144,1 @@\n-    static void checkTuples(MemoryAddress base, ByteBuffer bb, long count) {\n+    static void checkTuples(MemorySegment base, ByteBuffer bb, long count) {\n@@ -163,1 +154,1 @@\n-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {\n+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {\n@@ -169,1 +160,1 @@\n-    static <Z extends Buffer> void checkBytes(MemoryAddress base, SequenceLayout layout,\n+    static <Z extends Buffer> void checkBytes(MemorySegment base, SequenceLayout layout,\n@@ -171,1 +162,1 @@\n-                                              BiFunction<MemoryAddress, Long, Object> handleExtractor,\n+                                              BiFunction<MemorySegment, Long, Object> handleExtractor,\n@@ -177,1 +168,1 @@\n-            MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);\n+            MemorySegment resizedSegment = base.asSlice(i * elemSize, limit * elemSize);\n@@ -181,1 +172,1 @@\n-                Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);\n+                Object handleValue = handleExtractor.apply(resizedSegment, j - i);\n@@ -197,2 +188,1 @@\n-            MemoryAddress base = segment.baseAddress();\n-            initTuples(base, tuples.elementCount().getAsLong());\n+            initTuples(segment, tuples.elementCount().getAsLong());\n@@ -201,1 +191,1 @@\n-            checkTuples(base, bb, tuples.elementCount().getAsLong());\n+            checkTuples(segment, bb, tuples.elementCount().getAsLong());\n@@ -209,2 +199,1 @@\n-        MemoryAddress base = region.baseAddress();\n-        initTuples(base, tuples.elementCount().getAsLong());\n+        initTuples(region, tuples.elementCount().getAsLong());\n@@ -213,1 +202,1 @@\n-        checkTuples(base, bb, tuples.elementCount().getAsLong());\n+        checkTuples(region, bb, tuples.elementCount().getAsLong());\n@@ -226,2 +215,1 @@\n-                MemoryAddress base = segment.baseAddress();\n-                initTuples(base, tuples.elementCount().getAsLong());\n+                initTuples(segment, tuples.elementCount().getAsLong());\n@@ -236,2 +224,1 @@\n-                MemoryAddress base = segment.baseAddress();\n-                checkTuples(base, mbb, tuples.elementCount().getAsLong());\n+                checkTuples(segment, mbb, tuples.elementCount().getAsLong());\n@@ -244,1 +231,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n@@ -249,1 +236,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n@@ -262,4 +249,3 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n-            MemoryAddress base = segment.baseAddress();\n-            initTuples(base, tuples.elementCount().getAsLong());\n-            segment.force();\n+        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+            initTuples(segment, tuples.elementCount().getAsLong());\n+            MappedMemorySegments.force(segment);\n@@ -269,3 +255,2 @@\n-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n-            MemoryAddress base = segment.baseAddress();\n-            checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());\n+        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+            checkTuples(segment, segment.asByteBuffer(), tuples.elementCount().getAsLong());\n@@ -275,0 +260,12 @@\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n+    public void testMappedSegmentOperations(MappedSegmentOp mappedBufferOp) throws Throwable {\n+        File f = new File(\"test3.out\");\n+        f.createNewFile();\n+        f.deleteOnExit();\n+\n+        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n+        assertTrue(segment.isMapped());\n+        segment.close();\n+        mappedBufferOp.apply(segment);\n+    }\n+\n@@ -286,4 +283,3 @@\n-            try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n-                MemoryAddress base = segment.baseAddress();\n-                initTuples(base, 1);\n-                segment.force();\n+            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+                initTuples(segment, 1);\n+                MappedMemorySegments.force(segment);\n@@ -296,3 +292,2 @@\n-            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n-                MemoryAddress base = segment.baseAddress();\n-                checkTuples(base, segment.asByteBuffer(), 1);\n+            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+                checkTuples(segment, segment.asByteBuffer(), 1);\n@@ -323,1 +318,1 @@\n-    public void testScopedBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {\n+    public void testScopedBuffer(Function<ByteBuffer, Buffer> bufferFactory, @NoInjection Method method, Object[] args) {\n@@ -326,1 +321,0 @@\n-            MemoryAddress base = segment.baseAddress();\n@@ -330,21 +324,11 @@\n-        for (Map.Entry<Method, Object[]> e : members.entrySet()) {\n-            if (!e.getKey().getName().contains(\"get\") &&\n-                            !e.getKey().getName().contains(\"put\")) {\n-                \/\/skip\n-                return;\n-            }\n-            try {\n-                e.getKey().invoke(bb, e.getValue());\n-                assertTrue(false);\n-            } catch (InvocationTargetException ex) {\n-                Throwable cause = ex.getCause();\n-                if (cause instanceof IllegalStateException) {\n-                    \/\/all get\/set buffer operation should fail because of the scope check\n-                    assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n-                } else {\n-                    \/\/all other exceptions were unexpected - fail\n-                    assertTrue(false);\n-                }\n-            } catch (Throwable ex) {\n-                \/\/unexpected exception - fail\n-                assertTrue(false);\n+        try {\n+            method.invoke(bb, args);\n+            fail(\"Exception expected\");\n+        } catch (InvocationTargetException ex) {\n+            Throwable cause = ex.getCause();\n+            if (cause instanceof IllegalStateException) {\n+                \/\/all get\/set buffer operation should fail because of the scope check\n+                assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n+            } else {\n+                \/\/all other exceptions were unexpected - fail\n+                fail(\"Unexpected exception\", cause);\n@@ -352,0 +336,3 @@\n+        } catch (Throwable ex) {\n+            \/\/unexpected exception - fail\n+            fail(\"Unexpected exception\", ex);\n@@ -390,1 +377,1 @@\n-    public void testDirectBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {\n+    public void testDirectBuffer(Function<ByteBuffer, Buffer> bufferFactory, @NoInjection Method method, Object[] args) {\n@@ -392,1 +379,0 @@\n-            MemoryAddress base = segment.baseAddress();\n@@ -396,1 +382,1 @@\n-            assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());\n+            assertEquals(directBuffer.address(), segment.address().toRawLongValue());\n@@ -403,1 +389,1 @@\n-    public void testResizeOffheap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeOffheap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -405,3 +391,2 @@\n-            MemoryAddress base = segment.baseAddress();\n-            initializer.accept(base);\n-            checker.accept(base);\n+            initializer.accept(segment);\n+            checker.accept(segment);\n@@ -412,1 +397,1 @@\n-    public void testResizeHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -415,1 +400,1 @@\n-        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).baseAddress();\n+        MemorySegment base = MemorySegment.ofArray(new byte[capacity]);\n@@ -421,1 +406,1 @@\n-    public void testResizeBuffer(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeBuffer(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -424,1 +409,1 @@\n-        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();\n+        MemorySegment base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity]));\n@@ -430,1 +415,1 @@\n-    public void testResizeRoundtripHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeRoundtripHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -435,3 +420,2 @@\n-        MemoryAddress first = segment.baseAddress();\n-        initializer.accept(first);\n-        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();\n+        initializer.accept(segment);\n+        MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n@@ -442,1 +426,1 @@\n-    public void testResizeRoundtripNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testResizeRoundtripNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -444,3 +428,2 @@\n-            MemoryAddress first = segment.baseAddress();\n-            initializer.accept(first);\n-            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();\n+            initializer.accept(segment);\n+            MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n@@ -463,1 +446,1 @@\n-        try (MemorySegment segment = MemorySegment.ofNativeRestricted(MemoryAddress.NULL, (long)Integer.MAX_VALUE + 10L, null, null, null)) {\n+        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(Integer.MAX_VALUE + 10L)) {\n@@ -473,1 +456,1 @@\n-        MemorySegment.mapFromPath(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);\n@@ -481,1 +464,1 @@\n-        MemorySegment.mapFromPath(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);\n@@ -488,1 +471,1 @@\n-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {\n@@ -494,1 +477,1 @@\n-    public void testCopyHeapToNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testCopyHeapToNative(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -499,1 +482,1 @@\n-            initializer.accept(heapArray.baseAddress());\n+            initializer.accept(heapArray);\n@@ -501,1 +484,1 @@\n-            checker.accept(nativeArray.baseAddress());\n+            checker.accept(nativeArray);\n@@ -506,1 +489,1 @@\n-    public void testCopyNativeToHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testCopyNativeToHeap(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -511,1 +494,1 @@\n-            initializer.accept(nativeArray.baseAddress());\n+            initializer.accept(nativeArray);\n@@ -513,1 +496,1 @@\n-            checker.accept(heapArray.baseAddress());\n+            checker.accept(heapArray);\n@@ -549,0 +532,10 @@\n+    @Test(dataProvider=\"bufferSources\")\n+    public void bufferProperties(ByteBuffer bb, Predicate<MemorySegment> _unused) {\n+        try (MemorySegment segment = MemorySegment.ofByteBuffer(bb)) {\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            assertEquals(buffer.position(), 0);\n+            assertEquals(buffer.capacity(), segment.byteSize());\n+            assertEquals(buffer.limit(), segment.byteSize());\n+        }\n+    }\n+\n@@ -565,1 +558,1 @@\n-        intHandle.set(s2.baseAddress(), 0L, 10); \/\/ Dead access!\n+        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n@@ -568,11 +561,41 @@\n-    @DataProvider(name = \"bufferOps\")\n-    public static Object[][] bufferOps() throws Throwable {\n-        return new Object[][]{\n-                { (Function<ByteBuffer, Buffer>) bb -> bb, bufferMembers(ByteBuffer.class)},\n-                { (Function<ByteBuffer, Buffer>) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},\n-                { (Function<ByteBuffer, Buffer>) ByteBuffer::asShortBuffer, bufferMembers(ShortBuffer.class)},\n-                { (Function<ByteBuffer, Buffer>) ByteBuffer::asIntBuffer, bufferMembers(IntBuffer.class)},\n-                { (Function<ByteBuffer, Buffer>) ByteBuffer::asFloatBuffer, bufferMembers(FloatBuffer.class)},\n-                { (Function<ByteBuffer, Buffer>) ByteBuffer::asLongBuffer, bufferMembers(LongBuffer.class)},\n-                { (Function<ByteBuffer, Buffer>) ByteBuffer::asDoubleBuffer, bufferMembers(DoubleBuffer.class)},\n-        };\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testIOOnSharedSegmentBuffer() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        tmp.deleteOnExit();\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10).share();\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+            }\n+            ByteBuffer bb = segment.asByteBuffer();\n+            segment.close();\n+            channel.write(bb);\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testIOOnClosedConfinedSegmentBuffer() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        tmp.deleteOnExit();\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+            }\n+            ByteBuffer bb = segment.asByteBuffer();\n+            segment.close();\n+            channel.write(bb);\n+        }\n+    }\n+\n+    public void testIOOnClosedConfinedSegment() throws IOException {\n+        File tmp = File.createTempFile(\"tmp\", \"txt\");\n+        tmp.deleteOnExit();\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+            }\n+            ByteBuffer bb = segment.asByteBuffer();\n+            channel.write(bb);\n+        }\n@@ -581,2 +604,14 @@\n-    static Map<Method, Object[]> bufferMembers(Class<?> bufferClass) {\n-        Map<Method, Object[]> members = new HashMap<>();\n+    @DataProvider(name = \"bufferOps\")\n+    public static Object[][] bufferOps() throws Throwable {\n+        List<Object[]> args = new ArrayList<>();\n+        bufferOpsArgs(args, bb -> bb, ByteBuffer.class);\n+        bufferOpsArgs(args, ByteBuffer::asCharBuffer, CharBuffer.class);\n+        bufferOpsArgs(args, ByteBuffer::asShortBuffer, ShortBuffer.class);\n+        bufferOpsArgs(args, ByteBuffer::asIntBuffer, IntBuffer.class);\n+        bufferOpsArgs(args, ByteBuffer::asFloatBuffer, FloatBuffer.class);\n+        bufferOpsArgs(args, ByteBuffer::asLongBuffer, LongBuffer.class);\n+        bufferOpsArgs(args, ByteBuffer::asDoubleBuffer, DoubleBuffer.class);\n+        return args.toArray(Object[][]::new);\n+    }\n+\n+    static void bufferOpsArgs(List<Object[]> argsList, Function<ByteBuffer, Buffer> factory, Class<?> bufferClass) {\n@@ -585,2 +620,4 @@\n-            if (m.getDeclaringClass().equals(Object.class) ||\n-                    (m.getModifiers() & Modifier.STATIC) != 0) continue;\n+            if (m.getDeclaringClass().equals(Object.class)\n+                || ((m.getModifiers() & Modifier.STATIC) != 0)\n+                || (!m.getName().contains(\"get\") && !m.getName().contains(\"put\"))\n+                || m.getParameterCount() > 2) continue;\n@@ -590,1 +627,1 @@\n-            members.put(m, args);\n+            argsList.add(new Object[] { factory, m, args });\n@@ -592,1 +629,0 @@\n-        return members;\n@@ -625,29 +661,29 @@\n-        Consumer<MemoryAddress> byteInitializer =\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n-        Consumer<MemoryAddress> charInitializer =\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n-        Consumer<MemoryAddress> shortInitializer =\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n-        Consumer<MemoryAddress> intInitializer =\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n-        Consumer<MemoryAddress> floatInitializer =\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n-        Consumer<MemoryAddress> longInitializer =\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n-        Consumer<MemoryAddress> doubleInitializer =\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n-\n-        Consumer<MemoryAddress> byteChecker =\n-                (base) -> checkBytes(base, bytes, Function.identity(), byteHandle::get, ByteBuffer::get);\n-        Consumer<MemoryAddress> charChecker =\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, charHandle::get, CharBuffer::get);\n-        Consumer<MemoryAddress> shortChecker =\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, shortHandle::get, ShortBuffer::get);\n-        Consumer<MemoryAddress> intChecker =\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, intHandle::get, IntBuffer::get);\n-        Consumer<MemoryAddress> floatChecker =\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, floatHandle::get, FloatBuffer::get);\n-        Consumer<MemoryAddress> longChecker =\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, longHandle::get, LongBuffer::get);\n-        Consumer<MemoryAddress> doubleChecker =\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, doubleHandle::get, DoubleBuffer::get);\n+        Consumer<MemorySegment> byteInitializer =\n+                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtOffset(addr, pos, (byte)(long)pos));\n+        Consumer<MemorySegment> charInitializer =\n+                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n+        Consumer<MemorySegment> shortInitializer =\n+                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n+        Consumer<MemorySegment> intInitializer =\n+                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n+        Consumer<MemorySegment> floatInitializer =\n+                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n+        Consumer<MemorySegment> longInitializer =\n+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (long)pos));\n+        Consumer<MemorySegment> doubleInitializer =\n+                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n+\n+        Consumer<MemorySegment> byteChecker =\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtOffset(addr, pos), ByteBuffer::get);\n+        Consumer<MemorySegment> charChecker =\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n+        Consumer<MemorySegment> shortChecker =\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n+        Consumer<MemorySegment> intChecker =\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n+        Consumer<MemorySegment> floatChecker =\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n+        Consumer<MemorySegment> longChecker =\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n+        Consumer<MemorySegment> doubleChecker =\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n@@ -707,0 +743,16 @@\n+        } else if (c == String.class) {\n+            return \"asdf\";\n+        } else if (c == ByteBuffer.class) {\n+            return ByteBuffer.wrap(new byte[1]);\n+        } else if (c == CharBuffer.class) {\n+            return CharBuffer.wrap(new char[1]);\n+        } else if (c == ShortBuffer.class) {\n+            return ShortBuffer.wrap(new short[1]);\n+        } else if (c == IntBuffer.class) {\n+            return IntBuffer.wrap(new int[1]);\n+        } else if (c == FloatBuffer.class) {\n+            return FloatBuffer.wrap(new float[1]);\n+        } else if (c == LongBuffer.class) {\n+            return LongBuffer.wrap(new long[1]);\n+        } else if (c == DoubleBuffer.class) {\n+            return DoubleBuffer.wrap(new double[1]);\n@@ -734,0 +786,28 @@\n+\n+    enum MappedSegmentOp {\n+        LOAD(MappedMemorySegments::load),\n+        UNLOAD(MappedMemorySegments::unload),\n+        IS_LOADED(MappedMemorySegments::isLoaded),\n+        FORCE(MappedMemorySegments::force),\n+        BUFFER_LOAD(m -> ((MappedByteBuffer)m.asByteBuffer()).load()),\n+        BUFFER_IS_LOADED(m -> ((MappedByteBuffer)m.asByteBuffer()).isLoaded()),\n+        BUFFER_FORCE(m -> ((MappedByteBuffer)m.asByteBuffer()).force());\n+\n+\n+        private Consumer<MemorySegment> segmentOp;\n+\n+        MappedSegmentOp(Consumer<MemorySegment> segmentOp) {\n+            this.segmentOp = segmentOp;\n+        }\n+\n+        void apply(MemorySegment segment) {\n+            segmentOp.accept(segment);\n+        }\n+    }\n+\n+    @DataProvider(name = \"mappedOps\")\n+    public static Object[][] mappedOps() {\n+        return Stream.of(MappedSegmentOp.values())\n+                .map(op -> new Object[] { op })\n+                .toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":226,"deletions":146,"binary":false,"changes":372,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\/jdk.incubator.foreign\n+ * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import java.lang.ref.Cleaner;\n+import jdk.internal.ref.CleanerFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+public class TestCleaner {\n+\n+    static class SegmentState {\n+        private AtomicInteger cleanupCalls = new AtomicInteger(0);\n+\n+        void cleanup() {\n+            cleanupCalls.incrementAndGet();\n+        }\n+\n+        int cleanupCalls() {\n+            return cleanupCalls.get();\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testAtMostOnce(RegisterKind registerKind, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n+        SegmentState segmentState = new SegmentState();\n+        MemorySegment root = MemorySegment.allocateNative(10).share();\n+        MemorySegment segment = root.address().asSegmentRestricted(10, () -> {\n+            root.close();\n+            segmentState.cleanup();\n+        }, null);\n+\n+        if (registerKind == RegisterKind.BEFORE) {\n+            \/\/ register cleaners before\n+            segment = segment.registerCleaner(cleanerFactory.get());\n+        }\n+\n+        kickGCAndCheck(segmentState, segment);\n+\n+        segment = segmentFunction.apply(segment);\n+\n+        kickGCAndCheck(segmentState, segment);\n+\n+        if (segment.isAlive() && registerKind == RegisterKind.AFTER) {\n+            \/\/ register cleaners after\n+            segment = segment.registerCleaner(cleanerFactory.get());\n+        }\n+\n+        kickGCAndCheck(segmentState, segment);\n+        segment = null;\n+        while (segmentState.cleanupCalls() == 0) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        assertEquals(segmentState.cleanupCalls(), 1);\n+    }\n+\n+    private void kickGCAndCheck(SegmentState segmentState, MemorySegment segment) {\n+        for (int i = 0 ; i < 100 ; i++) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            Thread.onSpinWait();\n+        }\n+        \/\/check that cleanup has not been called by any cleaner yet!\n+        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n+    }\n+\n+    @Test(dataProvider = \"segmentFunctions\")\n+    public void testBadDoubleRegister(Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n+        MemorySegment segment = MemorySegment.allocateNative(10);\n+        segment = segment.registerCleaner(cleanerFactory.get());\n+        segment = segmentFunction.apply(segment);\n+        try {\n+            segment.registerCleaner(cleanerFactory.get()); \/\/ error here!\n+            fail();\n+        } catch (IllegalStateException ex) {\n+            if (!segment.isAlive()) {\n+                assertTrue(ex.getMessage().contains(\"This segment is already closed\"));\n+            } else {\n+                assertTrue(ex.getMessage().contains(\"Already registered with a cleaner\"));\n+            }\n+        }\n+    }\n+\n+    enum SegmentFunction implements Function<MemorySegment, MemorySegment> {\n+        IDENTITY(Function.identity()),\n+        CLOSE(s -> { s.close(); return s; }),\n+        SHARE(s -> { return s.share(); });\n+\n+        private final Function<MemorySegment, MemorySegment> segmentFunction;\n+\n+        SegmentFunction(Function<MemorySegment, MemorySegment> segmentFunction) {\n+            this.segmentFunction = segmentFunction;\n+        }\n+\n+        @Override\n+        public MemorySegment apply(MemorySegment segment) {\n+            return segmentFunction.apply(segment);\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] segmentFunctions() {\n+        Supplier<?>[] cleaners = {\n+                (Supplier<Cleaner>)Cleaner::create,\n+                (Supplier<Cleaner>)CleanerFactory::cleaner\n+        };\n+\n+        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n+        Object[][] data = new Object[cleaners.length * segmentFunctions.length][3];\n+\n+        for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n+            for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n+                data[cleaner + (cleaners.length * segmentFunction)] =\n+                        new Object[] { cleaners[cleaner], segmentFunctions[segmentFunction] };\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    enum RegisterKind {\n+        BEFORE,\n+        AFTER;\n+    }\n+\n+    @DataProvider\n+    static Object[][] cleaners() {\n+        Supplier<?>[] cleaners = {\n+                (Supplier<Cleaner>)Cleaner::create,\n+                (Supplier<Cleaner>)CleanerFactory::cleaner\n+        };\n+\n+        List<Object[]> data = new ArrayList<>();\n+        for (RegisterKind kind : RegisterKind.values()) {\n+            for (Object cleaner : cleaners) {\n+                for (SegmentFunction segmentFunction : SegmentFunction.values()) {\n+                    data.add(new Object[] {kind, cleaner, segmentFunction});\n+                }\n+            }\n+        }\n+        return data.toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.misc\n+ * @key randomness\n+ * @run testng\/othervm TestHandshake\n+ * @run testng\/othervm -Xint TestHandshake\n+ * @run testng\/othervm -XX:TieredStopAtLevel=1 TestHandshake\n+ * @run testng\/othervm -XX:-TieredCompilation TestHandshake\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class TestHandshake {\n+\n+    static final int ITERATIONS = 5;\n+    static final int SEGMENT_SIZE = 1_000_000;\n+    static final int MAX_DELAY_MILLIS = 500;\n+    static final int MAX_EXECUTOR_WAIT_SECONDS = 10;\n+    static final int MAX_THREAD_SPIN_WAIT_MILLIS = 200;\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testHandshake(Function<MemorySegment, Runnable> accessorFactory) throws InterruptedException {\n+        for (int it = 0 ; it < ITERATIONS ; it++) {\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            System.err.println(\"ITERATION \" + it);\n+            ExecutorService accessExecutor = Executors.newCachedThreadPool();\n+            for (int i = 0; i < Runtime.getRuntime().availableProcessors() ; i++) {\n+                accessExecutor.execute(accessorFactory.apply(segment));\n+            }\n+            Thread.sleep(ThreadLocalRandom.current().nextInt(MAX_DELAY_MILLIS));\n+            accessExecutor.execute(new Handshaker(segment));\n+            accessExecutor.shutdown();\n+            assertTrue(accessExecutor.awaitTermination(MAX_EXECUTOR_WAIT_SECONDS, TimeUnit.SECONDS));\n+            assertTrue(!segment.isAlive());\n+        }\n+    }\n+\n+    static abstract class AbstractSegmentAccessor implements Runnable {\n+        final MemorySegment segment;\n+\n+        AbstractSegmentAccessor(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public final void run() {\n+            outer: while (segment.isAlive()) {\n+                try {\n+                    doAccess();\n+                } catch (IllegalStateException ex) {\n+                    backoff();\n+                    continue outer;\n+                }\n+            }\n+        }\n+\n+        abstract void doAccess();\n+\n+        private void backoff() {\n+            try {\n+                Thread.sleep(ThreadLocalRandom.current().nextInt(MAX_THREAD_SPIN_WAIT_MILLIS));\n+            } catch (InterruptedException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+    }\n+\n+    static abstract class AbstractBufferAccessor extends AbstractSegmentAccessor {\n+        final ByteBuffer bb;\n+\n+        AbstractBufferAccessor(MemorySegment segment) {\n+            super(segment);\n+            this.bb = segment.asByteBuffer();\n+        }\n+    }\n+\n+    static class SegmentAccessor extends AbstractSegmentAccessor {\n+\n+        SegmentAccessor(MemorySegment segment) {\n+            super(segment);\n+        }\n+\n+        @Override\n+        void doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                sum += MemoryAccess.getByteAtOffset(segment, i);\n+            }\n+        }\n+    }\n+\n+    static class SegmentCopyAccessor extends AbstractSegmentAccessor {\n+\n+        MemorySegment first, second;\n+\n+\n+        SegmentCopyAccessor(MemorySegment segment) {\n+            super(segment);\n+            long split = segment.byteSize() \/ 2;\n+            first = segment.asSlice(0, split);\n+            second = segment.asSlice(split);\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            first.copyFrom(second);\n+        }\n+    }\n+\n+    static class SegmentFillAccessor extends AbstractSegmentAccessor {\n+\n+        SegmentFillAccessor(MemorySegment segment) {\n+            super(segment);\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            segment.fill((byte) ThreadLocalRandom.current().nextInt(10));\n+        }\n+    }\n+\n+    static class SegmentMismatchAccessor extends AbstractSegmentAccessor {\n+\n+        final MemorySegment copy;\n+\n+        SegmentMismatchAccessor(MemorySegment segment) {\n+            super(segment);\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            copy.copyFrom(segment);\n+            MemoryAccess.setByteAtOffset(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            segment.mismatch(copy);\n+        }\n+    }\n+\n+    static class BufferAccessor extends AbstractBufferAccessor {\n+\n+        BufferAccessor(MemorySegment segment) {\n+            super(segment);\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < bb.capacity(); i++) {\n+                sum += bb.get(i);\n+            }\n+        }\n+    }\n+\n+    static class BufferHandleAccessor extends AbstractBufferAccessor {\n+\n+        static VarHandle handle = MethodHandles.byteBufferViewVarHandle(short[].class, ByteOrder.nativeOrder());\n+\n+        public BufferHandleAccessor(MemorySegment segment) {\n+            super(segment);\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < bb.capacity() \/ 2; i++) {\n+                sum += (short) handle.get(bb, i);\n+            }\n+        }\n+    };\n+\n+    static class Handshaker implements Runnable {\n+\n+        final MemorySegment segment;\n+\n+        Handshaker(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public void run() {\n+            long prev = System.currentTimeMillis();\n+            while (true) {\n+                try {\n+                    segment.close();\n+                    break;\n+                } catch (IllegalStateException ex) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+            long delay = System.currentTimeMillis() - prev;\n+            System.out.println(\"Segment closed - delay (ms): \" + delay);\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] accessors() {\n+        return new Object[][] {\n+                { (Function<MemorySegment, Runnable>)SegmentAccessor::new },\n+                { (Function<MemorySegment, Runnable>)SegmentCopyAccessor::new },\n+                { (Function<MemorySegment, Runnable>)SegmentMismatchAccessor::new },\n+                { (Function<MemorySegment, Runnable>)SegmentFillAccessor::new },\n+                { (Function<MemorySegment, Runnable>)BufferAccessor::new },\n+                { (Function<MemorySegment, Runnable>)BufferHandleAccessor::new }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -29,2 +29,1 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.*;\n@@ -37,2 +36,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SequenceLayout;\n@@ -67,1 +64,1 @@\n-            size_handle.set(segment.baseAddress(), 4);\n+            size_handle.set(segment, 4);\n@@ -69,1 +66,1 @@\n-                array_elem_handle.set(segment.baseAddress(), i, (double)i);\n+                array_elem_handle.set(segment, i, (double)i);\n@@ -72,1 +69,1 @@\n-            assertEquals(4, (int)size_handle.get(segment.baseAddress()));\n+            assertEquals(4, (int)size_handle.get(segment));\n@@ -74,1 +71,1 @@\n-                assertEquals((double)i, (double)array_elem_handle.get(segment.baseAddress(), i));\n+                assertEquals((double)i, (double)array_elem_handle.get(segment, i));\n@@ -93,1 +90,1 @@\n-            size_handle.set(segment.baseAddress(), 4);\n+            size_handle.set(segment, 4);\n@@ -95,1 +92,1 @@\n-                array_elem_handle.set(segment.baseAddress(), i, (double)i);\n+                array_elem_handle.set(segment, i, (double)i);\n@@ -98,1 +95,1 @@\n-            assertEquals(4, (int)size_handle.get(segment.baseAddress()));\n+            assertEquals(4, (int)size_handle.get(segment));\n@@ -100,1 +97,1 @@\n-                assertEquals((double)i, (double)array_elem_handle.get(segment.baseAddress(), i));\n+                assertEquals((double)i, (double)array_elem_handle.get(segment, i));\n@@ -112,1 +109,1 @@\n-                indexHandle.set(segment.baseAddress(), (long)i, i);\n+                indexHandle.set(segment, (long)i, i);\n@@ -117,2 +114,2 @@\n-                int expected = (int)indexHandle.get(segment.baseAddress(), (long)i);\n-                int found = (int)preindexHandle.get(segment.baseAddress());\n+                int expected = (int)indexHandle.get(segment, (long)i);\n+                int found = (int)preindexHandle.get(segment);\n@@ -177,1 +174,1 @@\n-        assertEquals(struct.byteAlignment(), 8);\n+        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n@@ -208,1 +205,1 @@\n-        assertEquals(struct.byteAlignment(), 8);\n+        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n@@ -220,2 +217,4 @@\n-            assertFalse(layout.toString().contains(\"%\"));\n-            assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+            if (layout.bitAlignment() == layout.bitSize()) {\n+                assertFalse(layout.toString().contains(\"%\"));\n+                assertEquals(layout.withBitAlignment(a).toString().contains(\"%\"), a != bitAlign);\n+            }\n@@ -312,1 +311,1 @@\n-        Object[][] layoutsAndAlignments = new Object[basicLayouts.length * 5][];\n+        Object[][] layoutsAndAlignments = new Object[basicLayouts.length * 4][];\n@@ -317,4 +316,0 @@\n-        }\n-        \/\/add basic layouts wrapped in a sequence with unspecified size\n-        for (MemoryLayout l : basicLayouts) {\n-            layoutsAndAlignments[i++] = new Object[] { MemoryLayout.ofSequence(l), l.bitAlignment() };\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+\n@@ -85,1 +85,1 @@\n-        MemoryAddress outer_address;\n+        MemorySegment outer_segment;\n@@ -88,1 +88,0 @@\n-            MemoryAddress addr = segment.baseAddress();\n@@ -90,1 +89,1 @@\n-                checker.check(handle, addr);\n+                checker.check(handle, segment);\n@@ -101,1 +100,1 @@\n-                checker.check(handle, addr.addOffset(layout.byteSize()));\n+                checker.check(handle, segment.asSlice(layout.byteSize()));\n@@ -106,1 +105,1 @@\n-            outer_address = addr; \/\/leak!\n+            outer_segment = segment; \/\/leak!\n@@ -109,1 +108,1 @@\n-            checker.check(handle, outer_address);\n+            checker.check(handle, outer_segment);\n@@ -117,1 +116,1 @@\n-        MemoryAddress outer_address;\n+        MemorySegment outer_segment;\n@@ -120,1 +119,0 @@\n-            MemoryAddress addr = segment.baseAddress();\n@@ -123,1 +121,1 @@\n-                    checker.check(handle, addr, i);\n+                    checker.check(handle, segment, i);\n@@ -135,1 +133,1 @@\n-                checker.check(handle, addr, seq.elementCount().getAsLong());\n+                checker.check(handle, segment, seq.elementCount().getAsLong());\n@@ -140,1 +138,1 @@\n-            outer_address = addr; \/\/leak!\n+            outer_segment = segment; \/\/leak!\n@@ -143,1 +141,1 @@\n-            checker.check(handle, outer_address, 0);\n+            checker.check(handle, outer_segment, 0);\n@@ -186,1 +184,1 @@\n-        MemoryAddress outer_address;\n+        MemorySegment outer_segment;\n@@ -189,1 +187,0 @@\n-            MemoryAddress addr = segment.baseAddress();\n@@ -193,1 +190,1 @@\n-                        checker.check(handle, addr, i, j);\n+                        checker.check(handle, segment, i, j);\n@@ -206,1 +203,1 @@\n-                checker.check(handle, addr, seq.elementCount().getAsLong(),\n+                checker.check(handle, segment, seq.elementCount().getAsLong(),\n@@ -212,1 +209,1 @@\n-            outer_address = addr; \/\/leak!\n+            outer_segment = segment; \/\/leak!\n@@ -215,1 +212,1 @@\n-            checker.check(handle, outer_address, 0, 0);\n+            checker.check(handle, outer_segment, 0, 0);\n@@ -264,1 +261,1 @@\n-        void check(VarHandle handle, MemoryAddress addr);\n+        void check(VarHandle handle, MemorySegment segment);\n@@ -266,3 +263,3 @@\n-        Checker BYTE = (handle, addr) -> {\n-            handle.set(addr, (byte)42);\n-            assertEquals(42, (byte)handle.get(addr));\n+        Checker BYTE = (handle, segment) -> {\n+            handle.set(segment, (byte)42);\n+            assertEquals(42, (byte)handle.get(segment));\n@@ -271,3 +268,3 @@\n-        Checker SHORT = (handle, addr) -> {\n-            handle.set(addr, (short)42);\n-            assertEquals(42, (short)handle.get(addr));\n+        Checker SHORT = (handle, segment) -> {\n+            handle.set(segment, (short)42);\n+            assertEquals(42, (short)handle.get(segment));\n@@ -276,3 +273,3 @@\n-        Checker CHAR = (handle, addr) -> {\n-            handle.set(addr, (char)42);\n-            assertEquals(42, (char)handle.get(addr));\n+        Checker CHAR = (handle, segment) -> {\n+            handle.set(segment, (char)42);\n+            assertEquals(42, (char)handle.get(segment));\n@@ -281,3 +278,3 @@\n-        Checker INT = (handle, addr) -> {\n-            handle.set(addr, 42);\n-            assertEquals(42, (int)handle.get(addr));\n+        Checker INT = (handle, segment) -> {\n+            handle.set(segment, 42);\n+            assertEquals(42, (int)handle.get(segment));\n@@ -286,3 +283,3 @@\n-        Checker LONG = (handle, addr) -> {\n-            handle.set(addr, (long)42);\n-            assertEquals(42, (long)handle.get(addr));\n+        Checker LONG = (handle, segment) -> {\n+            handle.set(segment, (long)42);\n+            assertEquals(42, (long)handle.get(segment));\n@@ -291,3 +288,3 @@\n-        Checker FLOAT = (handle, addr) -> {\n-            handle.set(addr, (float)42);\n-            assertEquals((float)42, (float)handle.get(addr));\n+        Checker FLOAT = (handle, segment) -> {\n+            handle.set(segment, (float)42);\n+            assertEquals((float)42, (float)handle.get(segment));\n@@ -296,3 +293,3 @@\n-        Checker DOUBLE = (handle, addr) -> {\n-            handle.set(addr, (double)42);\n-            assertEquals((double)42, (double)handle.get(addr));\n+        Checker DOUBLE = (handle, segment) -> {\n+            handle.set(segment, (double)42);\n+            assertEquals((double)42, (double)handle.get(segment));\n@@ -341,1 +338,1 @@\n-        void check(VarHandle handle, MemoryAddress addr, long index);\n+        void check(VarHandle handle, MemorySegment segment, long index);\n@@ -343,3 +340,3 @@\n-        ArrayChecker BYTE = (handle, addr, i) -> {\n-            handle.set(addr, i, (byte)i);\n-            assertEquals(i, (byte)handle.get(addr, i));\n+        ArrayChecker BYTE = (handle, segment, i) -> {\n+            handle.set(segment, i, (byte)i);\n+            assertEquals(i, (byte)handle.get(segment, i));\n@@ -348,3 +345,3 @@\n-        ArrayChecker SHORT = (handle, addr, i) -> {\n-            handle.set(addr, i, (short)i);\n-            assertEquals(i, (short)handle.get(addr, i));\n+        ArrayChecker SHORT = (handle, segment, i) -> {\n+            handle.set(segment, i, (short)i);\n+            assertEquals(i, (short)handle.get(segment, i));\n@@ -353,3 +350,3 @@\n-        ArrayChecker CHAR = (handle, addr, i) -> {\n-            handle.set(addr, i, (char)i);\n-            assertEquals(i, (char)handle.get(addr, i));\n+        ArrayChecker CHAR = (handle, segment, i) -> {\n+            handle.set(segment, i, (char)i);\n+            assertEquals(i, (char)handle.get(segment, i));\n@@ -358,3 +355,3 @@\n-        ArrayChecker INT = (handle, addr, i) -> {\n-            handle.set(addr, i, (int)i);\n-            assertEquals(i, (int)handle.get(addr, i));\n+        ArrayChecker INT = (handle, segment, i) -> {\n+            handle.set(segment, i, (int)i);\n+            assertEquals(i, (int)handle.get(segment, i));\n@@ -363,3 +360,3 @@\n-        ArrayChecker LONG = (handle, addr, i) -> {\n-            handle.set(addr, i, (long)i);\n-            assertEquals(i, (long)handle.get(addr, i));\n+        ArrayChecker LONG = (handle, segment, i) -> {\n+            handle.set(segment, i, (long)i);\n+            assertEquals(i, (long)handle.get(segment, i));\n@@ -368,3 +365,3 @@\n-        ArrayChecker FLOAT = (handle, addr, i) -> {\n-            handle.set(addr, i, (float)i);\n-            assertEquals((float)i, (float)handle.get(addr, i));\n+        ArrayChecker FLOAT = (handle, segment, i) -> {\n+            handle.set(segment, i, (float)i);\n+            assertEquals((float)i, (float)handle.get(segment, i));\n@@ -373,3 +370,3 @@\n-        ArrayChecker DOUBLE = (handle, addr, i) -> {\n-            handle.set(addr, i, (double)i);\n-            assertEquals((double)i, (double)handle.get(addr, i));\n+        ArrayChecker DOUBLE = (handle, segment, i) -> {\n+            handle.set(segment, i, (double)i);\n+            assertEquals((double)i, (double)handle.get(segment, i));\n@@ -418,1 +415,1 @@\n-        void check(VarHandle handle, MemoryAddress addr, long row, long col);\n+        void check(VarHandle handle, MemorySegment segment, long row, long col);\n@@ -420,3 +417,3 @@\n-        MatrixChecker BYTE = (handle, addr, r, c) -> {\n-            handle.set(addr, r, c, (byte)(r + c));\n-            assertEquals(r + c, (byte)handle.get(addr, r, c));\n+        MatrixChecker BYTE = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (byte)(r + c));\n+            assertEquals(r + c, (byte)handle.get(segment, r, c));\n@@ -425,3 +422,3 @@\n-        MatrixChecker SHORT = (handle, addr, r, c) -> {\n-            handle.set(addr, r, c, (short)(r + c));\n-            assertEquals(r + c, (short)handle.get(addr, r, c));\n+        MatrixChecker SHORT = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (short)(r + c));\n+            assertEquals(r + c, (short)handle.get(segment, r, c));\n@@ -430,3 +427,3 @@\n-        MatrixChecker CHAR = (handle, addr, r, c) -> {\n-            handle.set(addr, r, c, (char)(r + c));\n-            assertEquals(r + c, (char)handle.get(addr, r, c));\n+        MatrixChecker CHAR = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (char)(r + c));\n+            assertEquals(r + c, (char)handle.get(segment, r, c));\n@@ -435,3 +432,3 @@\n-        MatrixChecker INT = (handle, addr, r, c) -> {\n-            handle.set(addr, r, c, (int)(r + c));\n-            assertEquals(r + c, (int)handle.get(addr, r, c));\n+        MatrixChecker INT = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (int)(r + c));\n+            assertEquals(r + c, (int)handle.get(segment, r, c));\n@@ -440,3 +437,3 @@\n-        MatrixChecker LONG = (handle, addr, r, c) -> {\n-            handle.set(addr, r, c, r + c);\n-            assertEquals(r + c, (long)handle.get(addr, r, c));\n+        MatrixChecker LONG = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, r + c);\n+            assertEquals(r + c, (long)handle.get(segment, r, c));\n@@ -445,3 +442,3 @@\n-        MatrixChecker FLOAT = (handle, addr, r, c) -> {\n-            handle.set(addr, r, c, (float)(r + c));\n-            assertEquals((float)(r + c), (float)handle.get(addr, r, c));\n+        MatrixChecker FLOAT = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (float)(r + c));\n+            assertEquals((float)(r + c), (float)handle.get(segment, r, c));\n@@ -450,3 +447,3 @@\n-        MatrixChecker DOUBLE = (handle, addr, r, c) -> {\n-            handle.set(addr, r, c, (double)(r + c));\n-            assertEquals((double)(r + c), (double)handle.get(addr, r, c));\n+        MatrixChecker DOUBLE = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (double)(r + c));\n+            assertEquals((double)(r + c), (double)handle.get(segment, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":82,"deletions":85,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -54,3 +53,2 @@\n-            MemoryAddress addr = segment.baseAddress();\n-            vh.set(addr, -42);\n-            int val = (int)vh.get(addr);\n+            vh.set(segment, -42);\n+            int val = (int)vh.get(segment);\n@@ -70,2 +68,1 @@\n-            MemoryAddress addr = segment.baseAddress();\n-            vh.set(addr.addOffset(1L), -42);\n+            vh.set(segment.asSlice(1L), -42);\n@@ -97,1 +94,0 @@\n-                MemoryAddress addr = segment.baseAddress();\n@@ -99,1 +95,1 @@\n-                    vh.set(addr, i, -42);\n+                    vh.set(segment, i, -42);\n@@ -121,7 +117,6 @@\n-            MemoryAddress addr = segment.baseAddress();\n-            vh_c.set(addr, Byte.MIN_VALUE);\n-            assertEquals(vh_c.get(addr), Byte.MIN_VALUE);\n-            vh_s.set(addr, Short.MIN_VALUE);\n-            assertEquals(vh_s.get(addr), Short.MIN_VALUE);\n-            vh_i.set(addr, Integer.MIN_VALUE);\n-            assertEquals(vh_i.get(addr), Integer.MIN_VALUE);\n+            vh_c.set(segment, Byte.MIN_VALUE);\n+            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);\n+            vh_s.set(segment, Short.MIN_VALUE);\n+            assertEquals(vh_s.get(segment), Short.MIN_VALUE);\n+            vh_i.set(segment, Integer.MIN_VALUE);\n+            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -49,2 +48,0 @@\n-        MemoryAddress addr1 = s1.segment.baseAddress();\n-        MemoryAddress addr2 = s2.segment.baseAddress();\n@@ -54,1 +51,1 @@\n-            BYTE_HANDLE.set(addr2.addOffset(i), (byte)0);\n+            BYTE_HANDLE.set(s2.segment.asSlice(i), (byte)0);\n@@ -57,1 +54,1 @@\n-            BYTE_HANDLE.set(addr1.addOffset(i), (byte) i);\n+            BYTE_HANDLE.set(s1.segment.asSlice(i), (byte) i);\n@@ -63,1 +60,1 @@\n-            assertEquals((byte)i, BYTE_HANDLE.get(addr2.addOffset(i)));\n+            assertEquals((byte)i, BYTE_HANDLE.get(s2.segment.asSlice(i)));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-            intHandle.set(segment.baseAddress(), intValue);\n+            intHandle.set(segment, intValue);\n@@ -64,2 +64,2 @@\n-            assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);\n-            assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);\n+            assertEquals((int) intHandle.get(segment), expectedIntValue);\n+            assertEquals((byte) byteHandle.get(segment), byteValue);\n@@ -84,1 +84,1 @@\n-            longHandle.set(segment.baseAddress(), longValue);\n+            longHandle.set(segment, longValue);\n@@ -86,2 +86,2 @@\n-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);\n-            assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);\n+            assertEquals((long) longHandle.get(segment), expectedLongValue);\n+            assertEquals((byte) byteHandle.get(segment), byteValue);\n@@ -106,1 +106,1 @@\n-            intHandle.set(segment.baseAddress(), intValue);\n+            intHandle.set(segment, intValue);\n@@ -108,2 +108,2 @@\n-            assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);\n-            assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);\n+            assertEquals((int) intHandle.get(segment), expectedIntValue);\n+            assertEquals((short) shortHandle.get(segment), shortValue);\n@@ -128,1 +128,1 @@\n-            longHandle.set(segment.baseAddress(), longValue);\n+            longHandle.set(segment, longValue);\n@@ -130,2 +130,2 @@\n-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);\n-            assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);\n+            assertEquals((long) longHandle.get(segment), expectedLongValue);\n+            assertEquals((short) shortHandle.get(segment), shortValue);\n@@ -154,1 +154,1 @@\n-            longHandle.set(segment.baseAddress(), longValue);\n+            longHandle.set(segment, longValue);\n@@ -156,2 +156,2 @@\n-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);\n-            assertEquals((int) intHandle.get(segment.baseAddress()), intValue);\n+            assertEquals((long) longHandle.get(segment), expectedLongValue);\n+            assertEquals((int) intHandle.get(segment), intValue);\n@@ -168,4 +168,4 @@\n-            intHandle.set(segment.baseAddress(), 0L, (int) -1);\n-            assertEquals((int) intHandle.get(segment.baseAddress(), 0L), 255);\n-            intHandle.set(segment.baseAddress(), 1L, (int) 200);\n-            assertEquals((int) intHandle.get(segment.baseAddress(), 1L), 200);\n+            intHandle.set(segment, 0L, (int) -1);\n+            assertEquals((int) intHandle.get(segment, 0L), 255);\n+            intHandle.set(segment, 1L, (int) 200);\n+            assertEquals((int) intHandle.get(segment, 1L), 200);\n@@ -179,1 +179,0 @@\n-        MemoryAddress addr = segment.baseAddress();\n@@ -182,1 +181,2 @@\n-            VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n+            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+                    .varHandle(byte.class, PathElement.sequenceElement());\n@@ -184,2 +184,1 @@\n-            VarHandle strideHandle = MemoryHandles.withStride(intHandle, 1);\n-            assertEquals((int) strideHandle.get(addr, 2L), 129);\n+            assertEquals((int) intHandle.get(segment, 2L), 129);\n@@ -188,4 +187,4 @@\n-            VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n-            VarHandle strideHandle = MemoryHandles.withStride(byteHandle, 1);\n-            VarHandle intHandle = MemoryHandles.asUnsigned(strideHandle, int.class);\n-            assertEquals((int) intHandle.get(addr, 2L), 129);\n+            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+                    .varHandle(byte.class, PathElement.sequenceElement());\n+            VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);\n+            assertEquals((int) intHandle.get(segment, 2L), 129);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryHandleAsUnsigned.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-        MemoryAddress addr = segment.baseAddress();\n@@ -52,1 +51,1 @@\n-            BYTE_HANDLE.set(addr.addOffset(i), (byte)i);\n+            BYTE_HANDLE.set(segment.asSlice(i), (byte)i);\n@@ -84,1 +83,1 @@\n-            BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);\n+            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n@@ -114,5 +113,7 @@\n-        try (var s1 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L);\n-             var s2 = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {\n-            assertEquals(s1.mismatch(s1), -1);\n-            assertEquals(s1.mismatch(s2), -1);\n-            assertEquals(s2.mismatch(s1), -1);\n+        \/\/ skip if not on 64 bits\n+        if (MemoryLayouts.ADDRESS.byteSize() > 32) {\n+            try (var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L);\n+                 var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L)) {\n+                assertEquals(s1.mismatch(s1), -1);\n+                assertEquals(s1.mismatch(s2), -1);\n+                assertEquals(s2.mismatch(s1), -1);\n@@ -120,1 +121,1 @@\n-            testLargeAcrossMaxBoundary(s1, s2);\n+                testLargeAcrossMaxBoundary(s1, s2);\n@@ -122,1 +123,2 @@\n-            testLargeMismatchAcrossMaxBoundary(s1, s2);\n+                testLargeMismatchAcrossMaxBoundary(s1, s2);\n+            }\n@@ -138,1 +140,1 @@\n-            BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);\n+            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n- * @modules java.base\/jdk.internal.misc\n- *          jdk.incubator.foreign\/jdk.internal.foreign\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -38,1 +38,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -61,6 +60,0 @@\n-    static Unsafe UNSAFE;\n-\n-    static {\n-        UNSAFE = Unsafe.getUnsafe();\n-    }\n-\n@@ -103,1 +96,1 @@\n-    static void initBytes(MemoryAddress base, SequenceLayout seq, BiConsumer<MemoryAddress, Long> handleSetter) {\n+    static void initBytes(MemorySegment base, SequenceLayout seq, BiConsumer<MemorySegment, Long> handleSetter) {\n@@ -109,2 +102,2 @@\n-    static <Z extends Buffer> void checkBytes(MemoryAddress base, SequenceLayout layout,\n-                                              BiFunction<MemoryAddress, Long, Object> handleExtractor,\n+    static <Z extends Buffer> void checkBytes(MemorySegment base, SequenceLayout layout,\n+                                              BiFunction<MemorySegment, Long, Object> handleExtractor,\n@@ -115,1 +108,1 @@\n-        ByteBuffer bb = base.segment().asSlice(base.segmentOffset(), (int)layout.byteSize()).asByteBuffer();\n+        ByteBuffer bb = base.asByteBuffer();\n@@ -120,1 +113,1 @@\n-            Object rawValue = nativeRawExtractor.apply(base.toRawLongValue(), (int)i);\n+            Object rawValue = nativeRawExtractor.apply(base.address().toRawLongValue(), (int)i);\n@@ -155,1 +148,1 @@\n-    public void testNativeAccess(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {\n+    public void testNativeAccess(Consumer<MemorySegment> checker, Consumer<MemorySegment> initializer, SequenceLayout seq) {\n@@ -157,3 +150,2 @@\n-            MemoryAddress address = segment.baseAddress();\n-            initializer.accept(address);\n-            checker.accept(address);\n+            initializer.accept(segment);\n+            checker.accept(segment);\n@@ -178,2 +170,1 @@\n-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,\n-                () -> free(addr.toRawLongValue()), null);\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr.toRawLongValue()), null);\n@@ -186,0 +177,7 @@\n+    @Test\n+    public void testDefaultAccessModesEverthing() {\n+        MemorySegment everything = MemorySegment.ofNativeRestricted();\n+        assertTrue(everything.hasAccessModes(READ | WRITE));\n+        assertEquals(everything.accessModes(), READ | WRITE);\n+    }\n+\n@@ -189,3 +187,1 @@\n-        assertNull(addr.segment());\n-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,\n-                () -> free(addr.toRawLongValue()), null);\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr.toRawLongValue()), null);\n@@ -197,0 +193,9 @@\n+    @Test\n+    public void testEverythingSegment() {\n+        MemoryAddress addr = MemoryAddress.ofLong(allocate(4));\n+        MemorySegment everything = MemorySegment.ofNativeRestricted();\n+        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);\n+        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);\n+        free(addr.toRawLongValue());\n+    }\n+\n@@ -200,1 +205,1 @@\n-            MemorySegment.ofNativeRestricted(segment.baseAddress(), 0, null, null, null);\n+            segment.address().asSegmentRestricted(0);\n@@ -204,5 +209,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullUnsafeSegment() {\n-        MemorySegment.ofNativeRestricted(null, 10, null, null, null);\n-    }\n-\n@@ -215,1 +215,1 @@\n-        Consumer<MemoryAddress> byteInitializer =\n+        Consumer<MemorySegment> byteInitializer =\n@@ -217,1 +217,1 @@\n-        Consumer<MemoryAddress> charInitializer =\n+        Consumer<MemorySegment> charInitializer =\n@@ -219,1 +219,1 @@\n-        Consumer<MemoryAddress> shortInitializer =\n+        Consumer<MemorySegment> shortInitializer =\n@@ -221,1 +221,1 @@\n-        Consumer<MemoryAddress> intInitializer =\n+        Consumer<MemorySegment> intInitializer =\n@@ -223,1 +223,1 @@\n-        Consumer<MemoryAddress> floatInitializer =\n+        Consumer<MemorySegment> floatInitializer =\n@@ -225,1 +225,1 @@\n-        Consumer<MemoryAddress> longInitializer =\n+        Consumer<MemorySegment> longInitializer =\n@@ -227,1 +227,1 @@\n-        Consumer<MemoryAddress> doubleInitializer =\n+        Consumer<MemorySegment> doubleInitializer =\n@@ -230,1 +230,1 @@\n-        Consumer<MemoryAddress> byteChecker =\n+        Consumer<MemorySegment> byteChecker =\n@@ -232,1 +232,1 @@\n-        Consumer<MemoryAddress> charChecker =\n+        Consumer<MemorySegment> charChecker =\n@@ -234,1 +234,1 @@\n-        Consumer<MemoryAddress> shortChecker =\n+        Consumer<MemorySegment> shortChecker =\n@@ -236,1 +236,1 @@\n-        Consumer<MemoryAddress> intChecker =\n+        Consumer<MemorySegment> intChecker =\n@@ -238,1 +238,1 @@\n-        Consumer<MemoryAddress> floatChecker =\n+        Consumer<MemorySegment> floatChecker =\n@@ -240,1 +240,1 @@\n-        Consumer<MemoryAddress> longChecker =\n+        Consumer<MemorySegment> longChecker =\n@@ -242,1 +242,1 @@\n-        Consumer<MemoryAddress> doubleChecker =\n+        Consumer<MemorySegment> doubleChecker =\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -43,1 +43,1 @@\n-        MemorySegment.ofNativeRestricted(MemoryAddress.ofLong(42), 10, null, null, null);\n+        MemorySegment.ofNativeRestricted();\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -47,2 +48,0 @@\n-    static VarHandle BYTE_VH = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n-\n@@ -53,2 +52,2 @@\n-            MemoryAddress base = s2.segment.baseAddress();\n-            MemoryAddress rebased = base.rebase(s1.segment);\n+            MemoryAddress base = s2.segment.address();\n+            long offset = base.segmentOffset(s1.segment);\n@@ -56,2 +55,2 @@\n-                int expected = (int) BYTE_VH.get(base.addOffset(i));\n-                int found = (int) BYTE_VH.get(rebased.addOffset(i));\n+                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);\n+                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n@@ -63,1 +62,1 @@\n-                s1.segment.baseAddress().rebase(s2.segment);\n+                s1.segment.address().segmentOffset(s2.segment);\n@@ -70,2 +69,2 @@\n-            MemoryAddress base = s2.segment.baseAddress();\n-            MemoryAddress rebased = base.rebase(s1.segment);\n+            MemoryAddress base = s2.segment.address();\n+            long offset = base.segmentOffset(s1.segment);\n@@ -73,1 +72,1 @@\n-                BYTE_VH.get(base.addOffset(i));\n+                MemoryAccess.getByteAtOffset(s2.segment, i);\n@@ -75,1 +74,1 @@\n-                    BYTE_VH.get(rebased.addOffset(i));\n+                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n@@ -132,1 +131,1 @@\n-                BYTE_VH.set(segment.baseAddress().addOffset(i), (byte)i);\n+                MemoryAccess.setByteAtOffset(segment, i, (byte)i);\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run testng TestSegments\n+ * @run testng\/othervm -XX:MaxDirectMemorySize=1M TestSegments\n@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -37,0 +36,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -43,1 +43,0 @@\n-import java.util.Spliterator;\n@@ -77,3 +76,0 @@\n-                    if (member.method.getName().equals(\"acquire\")) {\n-                        ((MemorySegment)o).close();\n-                    }\n@@ -91,0 +87,23 @@\n+    @Test(dataProvider = \"segmentOperations\")\n+    public void testOpAfterClose(SegmentMember member) throws Throwable {\n+        MemorySegment segment = MemorySegment.allocateNative(4);\n+        segment.close();\n+        try {\n+            Object o = member.method.invoke(segment, member.params);\n+            assertFalse(member.isConfined());\n+        } catch (InvocationTargetException ex) {\n+            assertTrue(member.isConfined());\n+            Throwable target = ex.getTargetException();\n+            assertTrue(target instanceof NullPointerException ||\n+                          target instanceof UnsupportedOperationException ||\n+                          target instanceof IllegalStateException);\n+        }\n+    }\n+\n+    @Test(expectedExceptions = OutOfMemoryError.class)\n+    public void testNativeAllocationTooBig() {\n+        try (MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2)) { \/\/ 2M\n+            \/\/ do nothing\n+        }\n+    }\n+\n@@ -97,15 +116,1 @@\n-                assertEquals(0, (byte)byteHandle.get(segment.baseAddress(), i));\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testNothingSegmentAccess() {\n-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n-        long[] values = { 0L, Integer.MAX_VALUE - 1, (long) Integer.MAX_VALUE + 1 };\n-        for (long value : values) {\n-            MemoryAddress addr = MemoryAddress.ofLong(value);\n-            try {\n-                longHandle.get(addr);\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(ex.getMessage().contains(\"Required access mode\"));\n+                assertEquals(0, (byte)byteHandle.get(segment, i));\n@@ -116,7 +121,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testNothingSegmentOffset() {\n-        MemoryAddress addr = MemoryAddress.ofLong(42);\n-        assertNull(addr.segment());\n-        addr.segmentOffset();\n-    }\n-\n@@ -130,1 +128,1 @@\n-                byteHandle.set(segment.baseAddress(), (long)i, i);\n+                byteHandle.set(segment, (long)i, i);\n@@ -132,6 +130,3 @@\n-            long start = 0;\n-            MemoryAddress base = segment.baseAddress();\n-            MemoryAddress last = base.addOffset(10);\n-            while (!base.equals(last)) {\n-                MemorySegment slice = segment.asSlice(base.segmentOffset(), 10 - start);\n-                for (long i = start ; i < 10 ; i++) {\n+            for (int offset = 0 ; offset < 10 ; offset++) {\n+                MemorySegment slice = segment.asSlice(offset);\n+                for (long i = offset ; i < 10 ; i++) {\n@@ -139,2 +134,2 @@\n-                            byteHandle.get(segment.baseAddress(), i),\n-                            byteHandle.get(slice.baseAddress(), i - start)\n+                            byteHandle.get(segment, i),\n+                            byteHandle.get(slice, i - offset)\n@@ -143,2 +138,0 @@\n-                base = base.addOffset(1);\n-                start++;\n@@ -200,1 +193,1 @@\n-                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), value);\n+                    assertEquals((byte) byteHandle.get(segment, l), value);\n@@ -206,1 +199,1 @@\n-                    assertEquals((byte) byteHandle.get(sliceSegment.baseAddress(), l), ~value);\n+                    assertEquals((byte) byteHandle.get(sliceSegment, l), ~value);\n@@ -209,1 +202,1 @@\n-                assertEquals((byte) byteHandle.get(segment.baseAddress(), 0L), value);\n+                assertEquals((byte) byteHandle.get(segment, 0L), value);\n@@ -211,1 +204,1 @@\n-                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), (byte) ~value);\n+                    assertEquals((byte) byteHandle.get(segment, l), (byte) ~value);\n@@ -213,1 +206,1 @@\n-                assertEquals((byte) byteHandle.get(segment.baseAddress(), segment.byteSize() - 1L), value);\n+                assertEquals((byte) byteHandle.get(segment, segment.byteSize() - 1L), value);\n@@ -322,2 +315,3 @@\n-            \/\/skip statics and method declared in j.l.Object\n-            if (m.getDeclaringClass().equals(Object.class) ||\n+            \/\/skip defaults, statics and method declared in j.l.Object\n+            if (m.isDefault() ||\n+                    m.getDeclaringClass().equals(Object.class) ||\n@@ -338,0 +332,1 @@\n+                \"address\",\n@@ -339,0 +334,3 @@\n+                \"share\",\n+                \"handoff\",\n+                \"registerCleaner\",\n@@ -340,0 +338,1 @@\n+                \"spliterator\",\n@@ -343,1 +342,6 @@\n-                \"withOwnerThread\"\n+                \"toCharArray\",\n+                \"toShortArray\",\n+                \"toIntArray\",\n+                \"toFloatArray\",\n+                \"toLongArray\",\n+                \"toDoubleArray\"\n@@ -398,1 +402,1 @@\n-        ACQUIRE(MemorySegment.ACQUIRE) {\n+        SHARE(MemorySegment.SHARE) {\n@@ -401,21 +405,1 @@\n-                Spliterator<MemorySegment> spliterator =\n-                        MemorySegment.spliterator(segment, MemoryLayout.ofSequence(segment.byteSize(), MemoryLayouts.JAVA_BYTE));\n-                AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-                Runnable action = () -> {\n-                    try {\n-                        spliterator.tryAdvance(s -> { });\n-                    } catch (RuntimeException e) {\n-                        exception.set(e);\n-                    }\n-                };\n-                Thread thread = new Thread(action);\n-                thread.start();\n-                try {\n-                    thread.join();\n-                } catch (InterruptedException ex) {\n-                    throw new AssertionError(ex);\n-                }\n-                RuntimeException e = exception.get();\n-                if (e != null) {\n-                    throw e;\n-                }\n+                segment.share();\n@@ -433,1 +417,1 @@\n-                INT_HANDLE.get(segment.baseAddress());\n+                INT_HANDLE.get(segment);\n@@ -439,1 +423,1 @@\n-                INT_HANDLE.set(segment.baseAddress(), 42);\n+                INT_HANDLE.set(segment, 42);\n@@ -445,1 +429,1 @@\n-                segment.withOwnerThread(new Thread());\n+                segment.handoff(new Thread());\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":56,"deletions":72,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -30,6 +30,2 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SequenceLayout;\n-import org.testng.annotations.Test;\n+import jdk.incubator.foreign.*;\n+import org.testng.annotations.*;\n@@ -44,1 +40,0 @@\n-import java.util.concurrent.ExecutionException;\n@@ -47,1 +42,0 @@\n-import java.util.function.Consumer;\n@@ -49,3 +43,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.testng.Assert.*;\n@@ -62,2 +54,2 @@\n-        setInt(s.baseAddress(), 42);\n-        assertEquals(getInt(s.baseAddress()), 42);\n+        setInt(s, 42);\n+        assertEquals(getInt(s), 42);\n@@ -67,2 +59,2 @@\n-                assertEquals(getInt(confined.get().baseAddress()), 42);\n-                confined.set(confined.get().withOwnerThread(owner));\n+                assertEquals(getInt(confined.get()), 42);\n+                confined.set(confined.get().handoff(owner));\n@@ -72,1 +64,1 @@\n-            confined.set(confined.get().withOwnerThread(t));\n+            confined.set(confined.get().handoff(t));\n@@ -86,1 +78,1 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(layout)) {\n+        try (MemorySegment s = MemorySegment.allocateNative(layout).share()) {\n@@ -88,1 +80,1 @@\n-                setInt(s.baseAddress().addOffset(i * 4), 42);\n+                setInt(s.asSlice(i * 4), 42);\n@@ -92,1 +84,1 @@\n-            spliterators.add(MemorySegment.spliterator(s, layout));\n+            spliterators.add(s.spliterator(layout));\n@@ -111,1 +103,1 @@\n-                        assertEquals(getInt(local.baseAddress()), 42);\n+                        assertEquals(getInt(local), 42);\n@@ -131,2 +123,2 @@\n-            setInt(s.baseAddress(), 42);\n-            assertEquals(getInt(s.baseAddress()), 42);\n+            setInt(s, 42);\n+            assertEquals(getInt(s), 42);\n@@ -134,2 +126,1 @@\n-            MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(\n-                    s.baseAddress(), s.byteSize(), null, null, null);\n+            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize()).share();\n@@ -138,1 +129,1 @@\n-                    assertEquals(getInt(sharedSegment.baseAddress()), 42);\n+                    assertEquals(getInt(sharedSegment), 42);\n@@ -152,24 +143,6 @@\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadCloseWithPendingAcquire() {\n-        withAcquired(MemorySegment::close);\n-    }\n-\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadCloseWithPendingAcquireBuffer() {\n-        withAcquired(segment -> {\n-            segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); \/\/ original segment is lost\n-            segment.close(); \/\/ this should still fail\n-        });\n-    }\n-\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadHandoffWithPendingAcquire() {\n-        withAcquired(segment -> segment.withOwnerThread(new Thread()));\n-    }\n-\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadHandoffWithPendingAcquireBuffer() {\n-        withAcquired(segment -> {\n-            segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); \/\/ original segment is lost\n-            segment.withOwnerThread(new Thread()); \/\/ this should still fail\n-        });\n+    @Test\n+    public void testHandoffToSelf() {\n+        MemorySegment s1 = MemorySegment.ofArray(new int[4]);\n+        MemorySegment s2 = s1.handoff(Thread.currentThread());\n+        assertFalse(s1.isAlive());\n+        assertTrue(s2.isAlive());\n@@ -178,3 +151,6 @@\n-    @Test(expectedExceptions=IllegalArgumentException.class)\n-    public void testBadHandoffSameThread() {\n-        MemorySegment.ofArray(new int[4]).withOwnerThread(Thread.currentThread());\n+    @Test\n+    public void testShareTwice() {\n+        MemorySegment s1 = MemorySegment.ofArray(new int[4]).share();\n+        MemorySegment s2 = s1.share();\n+        assertFalse(s1.isAlive());\n+        assertTrue(s2.isAlive());\n@@ -183,3 +159,4 @@\n-    @Test(expectedExceptions=NullPointerException.class)\n-    public void testBadHandoffNullThread() {\n-        MemorySegment.ofArray(new int[4]).withOwnerThread(null);\n+    @Test(expectedExceptions=UnsupportedOperationException.class)\n+    public void testBadHandoffNoAccess() {\n+        MemorySegment.ofArray(new int[4])\n+            .withAccessModes(MemorySegment.CLOSE).handoff(new Thread());\n@@ -188,23 +165,4 @@\n-    private void withAcquired(Consumer<MemorySegment> acquiredAction) {\n-        CountDownLatch holder = new CountDownLatch(1);\n-        MemorySegment segment = MemorySegment.allocateNative(16);\n-        Spliterator<MemorySegment> spliterator = MemorySegment.spliterator(segment,\n-                MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));\n-        CountDownLatch acquired = new CountDownLatch(1);\n-        Runnable r = () -> spliterator.tryAdvance(s -> {\n-            try {\n-                acquired.countDown();\n-                holder.await();\n-            } catch (InterruptedException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        });\n-        new Thread(r).start();\n-        try {\n-            acquired.await();\n-            acquiredAction.accept(segment);\n-        } catch (InterruptedException ex) {\n-            throw new AssertionError(ex);\n-        } finally {\n-            holder.countDown();\n-        }\n+    @Test(expectedExceptions=UnsupportedOperationException.class)\n+    public void testBadShareNoAccess() {\n+        MemorySegment.ofArray(new int[4])\n+                .withAccessModes(MemorySegment.CLOSE).share();\n@@ -231,2 +189,1 @@\n-                    MemoryAddress base = s2.baseAddress();\n-                    setInt(base.addOffset(4), -42);\n+                    setInt(s2.asSlice(4), -42);\n@@ -240,2 +197,1 @@\n-            MemoryAddress base = s1.baseAddress();\n-            setInt(base.addOffset(4), 42);\n+            setInt(s1.asSlice(4), 42);\n@@ -248,2 +204,2 @@\n-    static int getInt(MemoryAddress address) {\n-        return (int)intHandle.getVolatile(address);\n+    static int getInt(MemorySegment base) {\n+        return (int)intHandle.getVolatile(base);\n@@ -252,2 +208,2 @@\n-    static void setInt(MemoryAddress address, int value) {\n-        intHandle.setVolatile(address, value);\n+    static void setInt(MemorySegment base, int value) {\n+        intHandle.setVolatile(base, value);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":42,"deletions":86,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-    static VarHandle VH_INT = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-\n@@ -55,1 +53,1 @@\n-                    VH_ALL.set(segment.baseAddress(), i, j, (int)j + 1 + ((int)i * 5));\n+                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));\n@@ -67,1 +65,1 @@\n-                int x = (int) handle.get(segment.baseAddress(), i, j);\n+                int x = (int) handle.get(segment, i, j);\n@@ -82,1 +80,0 @@\n-                { MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, 8), 20), 2, 3, new int[] { 1, 3, 5, 6, 8, 10 } },\n@@ -86,1 +83,0 @@\n-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, 8), 20), 4), 2, 2, new int[] { 2, 4, 7, 9 } },\n@@ -90,1 +86,0 @@\n-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, -8), 20), 16), 2, 3, new int[] { 5, 3, 1, 10, 8, 6 } },\n@@ -94,1 +89,0 @@\n-                { MemoryHandles.withOffset(MemoryHandles.withStride(MemoryHandles.withStride(VH_INT, -8), 20), 12), 2, 2, new int[] { 4, 2, 9, 7 } },\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -64,1 +63,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout).share();\n@@ -66,1 +65,1 @@\n-            INT_HANDLE.set(segment.baseAddress(), (long) i, i);\n+            INT_HANDLE.set(segment, (long) i, i);\n@@ -73,1 +72,1 @@\n-        long parallelCounted = new SumSegmentCounted(null, MemorySegment.spliterator(segment, layout), threshold).invoke();\n+        long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();\n@@ -76,1 +75,1 @@\n-        long parallelRecursive = new SumSegmentRecursive(MemorySegment.spliterator(segment, layout), threshold).invoke();\n+        long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();\n@@ -79,1 +78,1 @@\n-        long streamParallel = StreamSupport.stream(MemorySegment.spliterator(segment, layout), true)\n+        long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)\n@@ -91,1 +90,1 @@\n-            INT_HANDLE.set(segment.baseAddress(), (long) i, i);\n+            INT_HANDLE.set(segment, (long) i, i);\n@@ -97,1 +96,1 @@\n-        spliterator(segment.withAccessModes(MemorySegment.READ), layout)\n+        segment.withAccessModes(MemorySegment.READ).spliterator(layout)\n@@ -103,1 +102,1 @@\n-        return acc + (int)INT_HANDLE.get(segment.baseAddress(), 0L);\n+        return acc + (int)INT_HANDLE.get(segment, 0L);\n@@ -108,1 +107,0 @@\n-        MemoryAddress base = segment.baseAddress();\n@@ -111,1 +109,1 @@\n-            sum += (int)INT_HANDLE.get(base, (long)i);\n+            sum += (int)INT_HANDLE.get(segment, (long)i);\n@@ -214,7 +212,7 @@\n-            () -> spliterator(mallocSegment.withAccessModes(ALL_ACCESS), layout), ALL_ACCESS,\n-            () -> spliterator(mallocSegment.withAccessModes(0), layout), 0,\n-            () -> spliterator(mallocSegment.withAccessModes(READ), layout), READ,\n-            () -> spliterator(mallocSegment.withAccessModes(CLOSE), layout), 0,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE), layout), READ|WRITE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE), layout), READ|WRITE|ACQUIRE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE|HANDOFF), layout), READ|WRITE|ACQUIRE|HANDOFF\n+            () -> mallocSegment.withAccessModes(ALL_ACCESS).spliterator(layout), ALL_ACCESS,\n+            () -> mallocSegment.withAccessModes(0).spliterator(layout), 0,\n+            () -> mallocSegment.withAccessModes(READ).spliterator(layout), READ,\n+            () -> mallocSegment.withAccessModes(CLOSE).spliterator(layout), 0,\n+            () -> mallocSegment.withAccessModes(READ|WRITE).spliterator(layout), READ|WRITE,\n+            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE).spliterator(layout), READ|WRITE| SHARE,\n+            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF).spliterator(layout), READ|WRITE| SHARE |HANDOFF\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -48,1 +47,0 @@\n-        vh = MemoryHandles.withStride(vh, 1);\n@@ -52,3 +50,1 @@\n-        MemoryAddress addr = segment.baseAddress();\n-\n-        assertEquals((byte) vh.get(addr, 2), (byte) -1);\n+        assertEquals((byte) vh.get(segment, 2), (byte) -1);\n@@ -60,1 +56,0 @@\n-        vh = MemoryHandles.withStride(vh, 2);\n@@ -62,16 +57,4 @@\n-        vh.get(segment.baseAddress(), 1L); \/\/should throw\n-    }\n-\n-    public void testZeroStrideElement() {\n-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n-        VarHandle strided_vh = MemoryHandles.withStride(vh, 0);\n-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });\n-        for (int i = 0 ; i < 100 ; i++) {\n-            assertEquals((int)vh.get(segment.baseAddress()), strided_vh.get(segment.baseAddress(), (long)i));\n-        }\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testStrideWrongHandle() {\n-        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());\n-        MemoryHandles.withStride(vh, 10);\n+        vh.get(segment, 2L); \/\/should throw\n+        \/\/FIXME: the VH only checks the alignment of the segment, which is fine if the VH is derived from layouts,\n+        \/\/FIXME: but not if the VH is just created from scratch - we need a VH variable to govern this property,\n+        \/\/FIXME: at least until the VM is fixed\n@@ -95,50 +78,2 @@\n-        MemoryAddress address = segment.baseAddress();\n-\n-        vh.set(address, (byte) 10); \/\/ fine, memory region is aligned\n-        assertEquals((byte) vh.get(address), (byte) 10);\n-    }\n-\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testAlignBadAccess() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());\n-        vh = MemoryHandles.withOffset(vh, 1); \/\/ offset by 1 byte\n-\n-        MemorySegment segment = MemorySegment.allocateNative(2, 2);\n-        MemoryAddress address = segment.baseAddress();\n-\n-        vh.set(address, (byte) 10); \/\/ should be bad align\n-    }\n-\n-    public void testZeroOffsetElement() {\n-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n-        VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);\n-        MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });\n-        for (int i = 0 ; i < 100 ; i++) {\n-            assertEquals((int)vh.get(segment.baseAddress()), offset_vh.get(segment.baseAddress(), (long)i));\n-        }\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testOffsetWrongHandle() {\n-        VarHandle vh = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());\n-        MemoryHandles.withOffset(vh, 1);\n-    }\n-\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testUnalignedOffset() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());\n-        vh = MemoryHandles.withOffset(vh, 2);\n-        MemorySegment segment = MemorySegment.ofArray(new byte[4]);\n-        vh.get(segment.baseAddress()); \/\/should throw\n-    }\n-\n-    @Test\n-    public void testOffset() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n-        vh = MemoryHandles.withOffset(vh, 1);\n-\n-        MemorySegment segment = MemorySegment.ofArray(new byte[2]);\n-        MemoryAddress address = segment.baseAddress();\n-\n-        vh.set(address, (byte) 10);\n-        assertEquals((byte) vh.get(address), (byte) 10);\n+        vh.set(segment, 0L, (byte) 10); \/\/ fine, memory region is aligned\n+        assertEquals((byte) vh.get(segment, 0L), (byte) 10);\n@@ -152,3 +87,1 @@\n-        MemoryAddress address = segment.baseAddress();\n-\n-        vh.set(address, (short) 0xFF);\n+        vh.set(segment, 0L, (short) 0xFF);\n@@ -164,3 +97,1 @@\n-        MemoryAddress address = segment.baseAddress();\n-\n-        vh.set(address, (short) 0xFF);\n+        vh.set(segment, 0L, (short) 0xFF);\n@@ -179,3 +110,0 @@\n-        vh = MemoryHandles.withOffset(vh, 4);\n-        VarHandle inner_vh = MemoryHandles.withStride(vh, 8);\n-        VarHandle outer_vh = MemoryHandles.withStride(inner_vh, 5 * 8);\n@@ -186,1 +114,1 @@\n-                    outer_vh.set(segment.baseAddress(), i, j, count);\n+                    vh.set(segment, i * 40 + j * 8, count);\n@@ -188,1 +116,1 @@\n-                            (int)inner_vh.get(segment.baseAddress().addOffset(i * inner_size * 8), j),\n+                            (int)vh.get(segment.asSlice(i * inner_size * 8), j * 8),\n@@ -208,1 +136,1 @@\n-                { MemoryAddress.class }\n+                { MemorySegment.class }\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":12,"deletions":84,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -42,8 +43,0 @@\n-    static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n-    static VarHandle CHAR_HANDLE = MemoryLayouts.JAVA_CHAR.withBitAlignment(8).varHandle(char.class);\n-    static VarHandle SHORT_HANDLE = MemoryLayouts.JAVA_SHORT.withBitAlignment(8).varHandle(short.class);\n-    static VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.withBitAlignment(8).varHandle(int.class);\n-    static VarHandle LONG_HANDLE = MemoryLayouts.JAVA_LONG.withBitAlignment(8).varHandle(long.class);\n-    static VarHandle FLOAT_HANDLE = MemoryLayouts.JAVA_FLOAT.withBitAlignment(8).varHandle(float.class);\n-    static VarHandle DOUBLE_HANDLE = MemoryLayouts.JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class);\n-\n@@ -51,1 +44,1 @@\n-        Function<MemorySegment, Byte> mapper = segment -> (byte)BYTE_HANDLE.get(segment.baseAddress());\n+        Function<MemorySegment, Byte> mapper = MemoryAccess::getByte;\n@@ -62,1 +55,1 @@\n-        Function<MemorySegment, Character> mapper = segment -> (char)CHAR_HANDLE.get(segment.baseAddress());\n+        Function<MemorySegment, Character> mapper = MemoryAccess::getChar;\n@@ -73,1 +66,1 @@\n-        Function<MemorySegment, Short> mapper = segment -> (short)SHORT_HANDLE.get(segment.baseAddress());\n+        Function<MemorySegment, Short> mapper = MemoryAccess::getShort;\n@@ -84,1 +77,1 @@\n-        Function<MemorySegment, Integer> mapper = segment -> (int)INT_HANDLE.get(segment.baseAddress());\n+        Function<MemorySegment, Integer> mapper = MemoryAccess::getInt;\n@@ -95,1 +88,1 @@\n-        Function<MemorySegment, Long> mapper = segment -> (long)LONG_HANDLE.get(segment.baseAddress());\n+        Function<MemorySegment, Long> mapper = MemoryAccess::getLong;\n@@ -106,1 +99,1 @@\n-        Function<MemorySegment, Float> mapper = segment -> (float)FLOAT_HANDLE.get(segment.baseAddress());\n+        Function<MemorySegment, Float> mapper = MemoryAccess::getFloat;\n@@ -125,1 +118,1 @@\n-        Function<MemorySegment, Double> mapper = segment -> (double)DOUBLE_HANDLE.get(segment.baseAddress());\n+        Function<MemorySegment, Double> mapper = MemoryAccess::getDouble;\n@@ -137,1 +130,1 @@\n-            BYTE_HANDLE.set(segment.baseAddress(), (byte)i);\n+            MemoryAccess.setByte(segment, (byte)i);\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-            SpliteratorTestHelper.testSpliterator(() -> MemorySegment.spliterator(segment, layout),\n+            SpliteratorTestHelper.testSpliterator(() -> segment.spliterator(layout),\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).baseAddress();\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);\n@@ -80,1 +80,1 @@\n-            VH_int.set(segment_addr, (long) i, i);\n+            VH_int.set(segment, (long) i, i);\n@@ -103,1 +103,1 @@\n-        return (int)VH_int.get(segment_addr, 0L);\n+        return (int)VH_int.get(segment, 0L);\n@@ -125,1 +125,1 @@\n-            res += (int) VH_int.get(segment_addr, (long)i);\n+            res += (int) VH_int.get(segment, (long)i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverConstant.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -77,1 +76,10 @@\n-            VH_int.set(segment.baseAddress(), (long) i, i);\n+            VH_int.set(segment, (long) i, i);\n+        }\n+        segment.close();\n+    }\n+\n+    @Benchmark\n+    public void segment_loop_shared() {\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -76,1 +77,1 @@\n-            VH_int.set(segment.baseAddress(), (long) i, i);\n+            VH_int.set(segment, (long) i, i);\n@@ -100,1 +101,1 @@\n-        return (int) VH_int.get(segment.baseAddress(), 0L);\n+        return (int) VH_int.get(segment, 0L);\n@@ -118,0 +119,9 @@\n+    @Benchmark\n+    public int segment_loop_static() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += MemoryAccess.getIntAtIndex(segment, i);\n+        }\n+        return res;\n+    }\n+\n@@ -121,1 +131,0 @@\n-        MemoryAddress base = segment.baseAddress();\n@@ -123,1 +132,1 @@\n-            sum += (int) VH_int.get(base, (long) i);\n+            sum += (int) VH_int.get(segment, (long) i);\n@@ -131,1 +140,1 @@\n-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();\n+        MemorySegment base = segment.asSlice(0, segment.byteSize());\n@@ -141,1 +150,1 @@\n-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();\n+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -93,1 +94,1 @@\n-        return (int) VH_int.get(segment.baseAddress(), 0L);\n+        return (int) VH_int.get(segment, 0L);\n@@ -114,1 +115,0 @@\n-        MemoryAddress base = segment.baseAddress();\n@@ -116,1 +116,1 @@\n-            sum += (int) VH_int.get(base, (long) i);\n+            sum += (int) VH_int.get(segment, (long) i);\n@@ -121,0 +121,9 @@\n+    @Benchmark\n+    public int segment_loop_static() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += MemoryAccess.getIntAtIndex(segment, i);\n+        }\n+        return res;\n+    }\n+\n@@ -124,1 +133,1 @@\n-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();\n+        MemorySegment base = segment.asSlice(0, segment.byteSize());\n@@ -134,1 +143,1 @@\n-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();\n+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -98,2 +98,2 @@\n-        segment = MemorySegment.mapFromPath(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);\n-        unsafe_addr = segment.baseAddress().toRawLongValue();\n+        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);\n+        unsafe_addr = segment.address().toRawLongValue();\n@@ -117,1 +117,1 @@\n-        return (int) VH_int.get(segment.baseAddress(), 0L);\n+        return (int) VH_int.get(segment, 0L);\n@@ -138,1 +138,0 @@\n-        MemoryAddress base = segment.baseAddress();\n@@ -140,1 +139,1 @@\n-            sum += (int) VH_int.get(base, (long) i);\n+            sum += (int) VH_int.get(segment, (long) i);\n@@ -145,0 +144,9 @@\n+    @Benchmark\n+    public int segment_loop_static() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += MemoryAccess.getIntAtIndex(segment, i);\n+        }\n+        return res;\n+    }\n+\n@@ -148,1 +156,1 @@\n-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();\n+        MemorySegment base = segment.asSlice(0, segment.byteSize());\n@@ -158,1 +166,1 @@\n-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();\n+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class LoopOverNonConstantShared {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n+\n+    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    MemorySegment segment;\n+    long unsafe_addr;\n+\n+    ByteBuffer byteBuffer;\n+\n+    @Setup\n+    public void setup() {\n+        unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);\n+        }\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+        byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            byteBuffer.putInt(i * CARRIER_SIZE , i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        segment.close();\n+        unsafe.invokeCleaner(byteBuffer);\n+        unsafe.freeMemory(unsafe_addr);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int unsafe_get() {\n+        return unsafe.getInt(unsafe_addr);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int segment_get() {\n+        return (int) VH_int.get(segment, 0L);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int BB_get() {\n+        return byteBuffer.getInt(0);\n+    }\n+\n+    @Benchmark\n+    public int unsafe_loop() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += unsafe.getInt(unsafe_addr + (i * CARRIER_SIZE));\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_static() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += MemoryAccess.getIntAtIndex(segment, i);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_slice() {\n+        int sum = 0;\n+        MemorySegment base = segment.asSlice(0, segment.byteSize());\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(base, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_readonly() {\n+        int sum = 0;\n+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(base, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int BB_loop() {\n+        int sum = 0;\n+        ByteBuffer bb = byteBuffer;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += bb.getInt(i * CARRIER_SIZE);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -88,1 +88,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n@@ -90,1 +90,1 @@\n-            VH_int.set(segment.baseAddress(), (long) i, i);\n+            VH_int.set(segment, (long) i, i);\n@@ -103,1 +103,0 @@\n-        MemoryAddress base = segment.baseAddress();\n@@ -105,1 +104,1 @@\n-            res += (int)VH_int.get(base, (long) i);\n+            res += (int)VH_int.get(segment, (long) i);\n@@ -121,1 +120,1 @@\n-        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();\n+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();\n@@ -126,1 +125,1 @@\n-        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n@@ -131,1 +130,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n@@ -137,1 +136,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n@@ -142,1 +141,1 @@\n-            (int) VH_int.get(slice.baseAddress(), 0L);\n+            (int) VH_int.get(slice, 0L);\n@@ -146,1 +145,0 @@\n-        MemoryAddress base = slice.baseAddress();\n@@ -148,1 +146,1 @@\n-            res += (int)VH_int.get(base, (long) i);\n+            res += (int)VH_int.get(slice, (long) i);\n@@ -155,1 +153,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), false)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), false)\n@@ -162,1 +160,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n@@ -169,1 +167,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), false)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), false)\n@@ -176,1 +174,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n@@ -182,1 +180,1 @@\n-            (int)VH_int.get(slice.baseAddress(), 0L) == (ELEM_SIZE - 1);\n+            (int)VH_int.get(slice, 0L) == (ELEM_SIZE - 1);\n@@ -185,1 +183,0 @@\n-        MemoryAddress base = slice.baseAddress();\n@@ -187,1 +184,1 @@\n-            if ((int)VH_int.get(base, (long)i) == (ELEM_SIZE - 1)) {\n+            if ((int)VH_int.get(slice, (long)i) == (ELEM_SIZE - 1)) {\n@@ -196,1 +193,1 @@\n-        return new SumUnsafe(address, 0, ALLOC_SIZE).invoke();\n+        return new SumUnsafe(address, 0, ALLOC_SIZE \/ CARRIER_SIZE).invoke();\n@@ -215,2 +212,6 @@\n-                SumUnsafe s1 = new SumUnsafe(address, start, length \/ 2);\n-                SumUnsafe s2 = new SumUnsafe(address, length \/ 2, length \/ 2);\n+                int rem = length % 2;\n+                int split = length \/ 2;\n+                int lobound = split;\n+                int hibound = lobound + rem;\n+                SumUnsafe s1 = new SumUnsafe(address, start, lobound);\n+                SumUnsafe s2 = new SumUnsafe(address, start + lobound, hibound);\n@@ -222,2 +223,2 @@\n-                for (int i = 0; i < length; i += CARRIER_SIZE) {\n-                    res += unsafe.getInt(start + address + i);\n+                for (int i = 0; i < length; i ++) {\n+                    res += unsafe.getInt(address + (start + i) * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-        MemoryAddress baseAddress = segment.baseAddress();\n@@ -149,1 +148,1 @@\n-            sum += (int)VH_addr_int.get(baseAddress, (long)i);\n+            sum += (int)VH_addr_int.get(segment, (long)i);\n@@ -157,1 +156,0 @@\n-        MemoryAddress baseAddress = segment.baseAddress();\n@@ -159,1 +157,1 @@\n-            sum += ((IntBox)VH_addr_box_int.get(baseAddress, (long)i)).intValue();\n+            sum += ((IntBox)VH_addr_box_int.get(segment, (long)i)).intValue();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestAdaptVarHandles.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        VH_x.set(segment.baseAddress(), x);\n+        VH_x.set(segment, x);\n@@ -65,1 +65,1 @@\n-        return (int) VH_x.get(segment.baseAddress());\n+        return (int) VH_x.get(segment);\n@@ -69,1 +69,1 @@\n-        VH_y.set(segment.baseAddress(), y);\n+        VH_y.set(segment, y);\n@@ -73,1 +73,1 @@\n-        return (int) VH_y.get(segment.baseAddress());\n+        return (int) VH_y.get(segment);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}