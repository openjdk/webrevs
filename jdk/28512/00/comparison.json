{"files":[{"patch":"@@ -43,29 +43,60 @@\n-\/\/ This is similar to IGVN optimization. But we are a bit lazy, and don't care about\n-\/\/ notification \/ worklist, since the list of nodes is rather small, and we don't\n-\/\/ expect optimizations that trickle over the whole graph.\n-void VTransformGraph::optimize(VTransform& vtransform) {\n-  TRACE_OPTIMIZE( tty->print_cr(\"\\nVTransformGraph::optimize\"); )\n-\n-  bool progress = true;\n-  DEBUG_ONLY(int pass_count = 0;)\n-  while (progress) {\n-    progress = false;\n-    assert(++pass_count < 10, \"ensure we do not have endless loops\");\n-    for (int i = 0; i < _vtnodes.length(); i++) {\n-      VTransformNode* vtn = _vtnodes.at(i);\n-      if (!vtn->is_alive()) { continue; }\n-      progress |= vtn->optimize(_vloop_analyzer, vtransform);\n-\n-      \/\/ Nodes that have no use any more are dead.\n-      if (vtn->out_strong_edges() == 0 &&\n-          \/\/ There are some exceptions:\n-          \/\/ 1. Memory phi uses are not modeled, so they appear to have no use here, but must be kept alive.\n-          \/\/ 2. Similarly, some stores may not have their memory uses modeled, but need to be kept alive.\n-          \/\/ 3. Outer node with strong inputs: is a use after the loop that we must keep alive.\n-          !(vtn->isa_PhiScalar() != nullptr ||\n-            vtn->is_load_or_store_in_loop() ||\n-            (vtn->isa_Outer() != nullptr && vtn->has_strong_in_edge()))) {\n-        vtn->mark_dead();\n-        progress = true;\n-      }\n-    }\n+void VTransformOptimize::worklist_push(VTransformNode* vtn) {\n+  if (_worklist_set.test_set(vtn->_idx)) { return; }\n+  _worklist.push(vtn);\n+}\n+\n+VTransformNode* VTransformOptimize::worklist_pop() {\n+  VTransformNode* vtn = _worklist.pop();\n+  _worklist_set.remove(vtn->_idx);\n+  return vtn;\n+}\n+\n+void VTransform::optimize() {\n+  NOT_PRODUCT( if (vloop().is_trace_optimization()) { tty->print_cr(\"\\nVTransform::optimize\"); } )\n+  ResourceMark rm;\n+  VTransformOptimize vtoptimize(_vloop_analyzer, *this);\n+  vtoptimize.optimize();\n+}\n+\n+void VTransformOptimize::optimize() {\n+  \/\/ Initialize: push all nodes to worklist.\n+  for (int i = 0; i < _vtransform.graph().vtnodes().length(); i++) {\n+    VTransformNode* vtn = _vtransform.graph().vtnodes().at(i);\n+    worklist_push(vtn);\n+  }\n+\n+  \/\/ Optimize iteratively.\n+  while (_worklist.is_nonempty()) {\n+    VTransformNode* vtn = worklist_pop();\n+    optimize_step(vtn);\n+  }\n+\n+  DEBUG_ONLY( verify(); )\n+}\n+\n+#ifdef ASSERT\n+void VTransformOptimize::verify() {\n+  for (int i = 0; i < _vtransform.graph().vtnodes().length(); i++) {\n+    VTransformNode* vtn = _vtransform.graph().vtnodes().at(i);\n+    assert(!optimize_step(vtn), \"Missed optimization during VTransform::optimize for %s\", vtn->name());\n+    assert(_worklist.is_empty(), \"vtnode on worklist despite no progress for %s\", vtn->name());\n+  }\n+}\n+#endif\n+\n+\/\/ Return true if (and only if) we made progress.\n+bool VTransformOptimize::optimize_step(VTransformNode* vtn) {\n+  if (!vtn->is_alive()) { return false; }\n+  bool progress = vtn->optimize(*this);\n+\n+  \/\/ Nodes that have no use any more are dead.\n+  if (vtn->out_strong_edges() == 0 &&\n+      \/\/ There are some exceptions:\n+      \/\/ 1. Memory phi uses are not modeled, so they appear to have no use here, but must be kept alive.\n+      \/\/ 2. Similarly, some stores may not have their memory uses modeled, but need to be kept alive.\n+      \/\/ 3. Outer node with strong inputs: is a use after the loop that we must keep alive.\n+      !(vtn->isa_PhiScalar() != nullptr ||\n+        vtn->is_load_or_store_in_loop() ||\n+        (vtn->isa_Outer() != nullptr && vtn->has_strong_in_edge()))) {\n+    vtn->mark_dead(*this);\n+    return true;\n@@ -73,0 +104,1 @@\n+  return progress;\n@@ -1144,2 +1176,2 @@\n-bool VTransformReductionVectorNode::optimize(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) {\n-  return optimize_move_non_strict_order_reductions_out_of_loop(vloop_analyzer, vtransform);\n+bool VTransformReductionVectorNode::optimize(VTransformOptimize& vtoptimize) {\n+  return optimize_move_non_strict_order_reductions_out_of_loop(vtoptimize);\n@@ -1216,1 +1248,1 @@\n-bool VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop_preconditions(VTransform& vtransform) {\n+bool VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop_preconditions(const VTransform& vtransform) {\n@@ -1263,1 +1295,1 @@\n-        tty->print(\"  Cannot move out of loop, other reduction node does not match:\");\n+        tty->print(\"  Cannot move out of loop, other reduction node does not match: \");\n@@ -1269,1 +1301,1 @@\n-          tty->print(\"nullptr\");\n+          tty->print_cr(\"nullptr\");\n@@ -1317,1 +1349,2 @@\n-bool VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) {\n+bool VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop(VTransformOptimize& vtoptimize) {\n+  VTransform& vtransform = vtoptimize.vtransform();\n@@ -1331,1 +1364,1 @@\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  PhaseIdealLoop* phase = vtoptimize.vloop_analyzer().vloop().phase();\n@@ -1344,0 +1377,1 @@\n+  vtoptimize.worklist_push(phi_scalar);\n@@ -1357,0 +1391,1 @@\n+  vtoptimize.worklist_push(phi_vector);\n@@ -1368,0 +1403,2 @@\n+    vtoptimize.worklist_push(current_red);\n+    vtoptimize.worklist_push(vector_accumulator);\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":73,"deletions":36,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"libadt\/vectset.hpp\"\n@@ -195,1 +196,0 @@\n-  void optimize(VTransform& vtransform);\n@@ -260,1 +260,1 @@\n-  void optimize() { return _graph.optimize(*this); }\n+  void optimize();\n@@ -294,0 +294,30 @@\n+\/\/ We keep track of the worklist during optimizations.\n+\/\/ The concept is somewhat parallel to IGVN: we keep on\n+\/\/ optimizing vtnodes on the worklist, which may in turn\n+\/\/ add more nodes to the list. We keep on optimizing until\n+\/\/ no more nodes are on the worklist.\n+class VTransformOptimize : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  VTransform& _vtransform;\n+\n+  GrowableArray<VTransformNode*> _worklist;\n+  VectorSet _worklist_set;\n+\n+public:\n+  VTransformOptimize(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vtransform(vtransform) {}\n+\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+  VTransform& vtransform() { return _vtransform; }\n+\n+  void worklist_push(VTransformNode* vtn);\n+  void optimize();\n+\n+private:\n+  VTransformNode* worklist_pop();\n+  bool optimize_step(VTransformNode* vtn);\n+  DEBUG_ONLY( void verify(); )\n+};\n+\n@@ -534,1 +564,1 @@\n-  void mark_dead() {\n+  void mark_dead(VTransformOptimize& vtoptimize) {\n@@ -536,1 +566,2 @@\n-    \/\/ Remove all inputs\n+    \/\/ Remove all inputs, and put inputs on worklist in\n+    \/\/ case they are also dead.\n@@ -538,0 +569,4 @@\n+      VTransformNode* in = in_req(i);\n+      if (in != nullptr) {\n+        vtoptimize.worklist_push(in);\n+      }\n@@ -561,1 +596,1 @@\n-  virtual bool optimize(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) { return false; }\n+  virtual bool optimize(VTransformOptimize& vtoptimize) { return false; }\n@@ -871,1 +906,1 @@\n-  virtual bool optimize(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) override;\n+  virtual bool optimize(VTransformOptimize& vtoptimize) override;\n@@ -879,2 +914,2 @@\n-  bool optimize_move_non_strict_order_reductions_out_of_loop_preconditions(VTransform& vtransform);\n-  bool optimize_move_non_strict_order_reductions_out_of_loop(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform);\n+  bool optimize_move_non_strict_order_reductions_out_of_loop_preconditions(const VTransform& vtransform);\n+  bool optimize_move_non_strict_order_reductions_out_of_loop(VTransformOptimize& vtoptimize);\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":43,"deletions":8,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8372451\n+ * @summary Test long reduction chain. Triggered bug with long chain of dead ReductionVector\n+ *          vtnodes after optimize_move_non_strict_order_reductions_out_of_loop.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=1000 -XX:MaxVectorSize=8 -Xbatch\n+ *                   -XX:CompileCommand=compileonly,${test.main.class}::test\n+ *                   ${test.main.class}\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+public class TestLongReductionChain {\n+    static int RANGE = 1024*8;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        int[] aI = generateI();\n+        int[] bI = generateI();\n+        int gold = test(aI, bI);\n+\n+        for (int i = 0; i < 1000; i++) {\n+            int result = test(aI, bI);\n+            if (result != gold) {\n+                throw new RuntimeException(\"wrong value\");\n+            }\n+        }\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    \/\/ Test creates a very long reduction chain, especially with -XX:LoopUnrollLimit=1000.\n+    \/\/ Limiting the reduction vectors to 2 elements gets us a very long chain -XX:MaxVectorSize=8.\n+    \/\/ During VTransform::optimize this means a long chain of nodes needs to be found as dead.\n+    \/\/ Before the fix, this took too many rounds, and we hit an assert.\n+    static int test(int[] a, int[] b) {\n+        int s = 0;\n+        for (int i = 0; i < RANGE; i+=8) {\n+            s += a[i+0] * b[i+0];\n+            s += a[i+1] * b[i+1];\n+            s += a[i+2] * b[i+2];\n+            s += a[i+3] * b[i+3];\n+\n+            s += a[i+4] & b[i+4];\n+            s += a[i+5] & b[i+5];\n+            s += a[i+6] & b[i+6];\n+            s += a[i+7] & b[i+7];\n+        }\n+        return s;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLongReductionChain.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}