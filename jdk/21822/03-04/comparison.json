{"files":[{"patch":"@@ -4222,0 +4222,1 @@\n+\n@@ -4223,2 +4224,1 @@\n-    int64_t distance = target - pc();\n-    assert(is_simm32(distance), \"Must be\");\n+    int64_t distance = 0;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1250,2 +1250,2 @@\n-  \/\/ For generated stubs the call will be:\n-  \/\/   auipc + ld + jalr\n+  \/\/ For address inside the code cache the call will be:\n+  \/\/   auipc + jalr\n@@ -1260,1 +1260,1 @@\n-    return 3 * NativeInstruction::instruction_size;\n+    return 2 * NativeInstruction::instruction_size;\n@@ -2476,4 +2476,4 @@\n-    \/\/ some calls to generated routines (arraycopy code) are scheduled\n-    \/\/ by C2 as runtime calls. if so we can call them using a jr (they\n-    \/\/ will be in a reachable segment) otherwise we have to use a jalr\n-    \/\/ which loads the absolute address into a register.\n+    \/\/ Some calls to generated routines (arraycopy code) are scheduled by C2\n+    \/\/ as runtime calls. if so we can call them using a far call (they will be\n+    \/\/ in the code cache, thus in a reachable segment) otherwise we have to use\n+    \/\/ a movptr+jalr pair which loads the absolute address into a register.\n@@ -2482,5 +2482,1 @@\n-      address call = __ reloc_call(Address(entry, relocInfo::runtime_call_type));\n-      if (call == nullptr) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        return;\n-      }\n+      __ far_call(Address(entry, relocInfo::runtime_call_type));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"}]}