{"files":[{"patch":"@@ -319,1 +319,1 @@\n-    ce->bailout(\"trampoline stub overflow\");\n+    ce->bailout(\"reloc call address stub overflow\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1349,1 +1349,1 @@\n-    bailout(\"trampoline stub overflow\");\n+    bailout(\"reloc call address stub overflow\");\n@@ -1359,1 +1359,1 @@\n-    bailout(\"trampoline stub overflow\");\n+    bailout(\"reloc call address stub overflow\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,4 +68,4 @@\n-    \/\/ See emit_static_call_stub for detail\n-    \/\/ CompiledDirectCall::to_interp_stub_size() (14) + CompiledDirectCall::to_trampoline_stub_size() (1 + 3 + address)\n-    _call_stub_size = 14 * MacroAssembler::instruction_size +\n-                      (MacroAssembler::instruction_size + MacroAssembler::NativeShortCall::trampoline_size),\n+    \/\/ call stub: CompiledDirectCall::to_interp_stub_size() +\n+    \/\/            CompiledDirectCall::to_trampoline_stub_size()\n+    _call_stub_size = 11 * MacroAssembler::instruction_size +\n+                      1 * MacroAssembler::instruction_size + wordSize,\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,54 +31,0 @@\n-void CodeBuffer::share_trampoline_for(address dest, int caller_offset) {\n-  if (_shared_trampoline_requests == nullptr) {\n-    constexpr unsigned init_size = 8;\n-    constexpr unsigned max_size  = 256;\n-    _shared_trampoline_requests = new (mtCompiler)SharedTrampolineRequests(init_size, max_size);\n-  }\n-\n-  bool created;\n-  Offsets* offsets = _shared_trampoline_requests->put_if_absent(dest, &created);\n-  if (created) {\n-    _shared_trampoline_requests->maybe_grow();\n-  }\n-  offsets->add(caller_offset);\n-  _finalize_stubs = true;\n-}\n-\n-#define __ masm.\n-\n-static bool emit_shared_trampolines(CodeBuffer* cb, CodeBuffer::SharedTrampolineRequests* requests) {\n-  if (requests == nullptr) {\n-    return true;\n-  }\n-  assert(UseTrampolines, \"We are not using trampolines\");\n-\n-  MacroAssembler masm(cb);\n-\n-  auto emit = [&](address dest, const CodeBuffer::Offsets &offsets) {\n-    assert(cb->stubs()->remaining() >= MacroAssembler::max_reloc_call_stub_size(), \"pre-allocated trampolines\");\n-    LinkedListIterator<int> it(offsets.head());\n-    int offset = *it.next();\n-    address stub = __ emit_trampoline_stub(offset, dest);\n-    assert(stub, \"pre-allocated trampolines\");\n-\n-    address reloc_pc = cb->stubs()->end() - MacroAssembler::NativeShortCall::trampoline_size;\n-    while (!it.is_empty()) {\n-      offset = *it.next();\n-      address caller_pc = cb->insts()->start() + offset;\n-      cb->stubs()->relocate(reloc_pc, trampoline_stub_Relocation::spec(caller_pc));\n-    }\n-    return true;\n-  };\n-\n-  assert(requests->number_of_entries() >= 1, \"at least one\");\n-  const int total_requested_size = MacroAssembler::max_reloc_call_stub_size() * requests->number_of_entries();\n-  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == nullptr) {\n-    return false;\n-  }\n-\n-  requests->iterate(emit);\n-  return true;\n-}\n-\n-#undef __\n-\n@@ -86,2 +32,1 @@\n-  return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests)\n-         && emit_shared_trampolines(this, _shared_trampoline_requests);\n+  return emit_shared_stubs_to_interp<MacroAssembler>(this, _shared_stub_to_interp_requests);\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -36,3 +36,1 @@\n-  static bool supports_shared_stubs() { return UseTrampolines; }\n-\n-  void share_trampoline_for(address dest, int caller_offset);\n+  static bool supports_shared_stubs() { return false; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,3 +72,3 @@\n-  \/\/ We count instructions and an additional alignment nop.\n-  \/\/ Trampoline stubs are always word aligned.\n-  return MacroAssembler::max_reloc_call_stub_size();\n+  \/\/ We count size of target address and an additional alignment nop.\n+  \/\/ Reloc call address stubs are always word aligned.\n+  return MacroAssembler::max_reloc_call_address_stub_size();\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,2 +122,0 @@\n-  product(bool, UseTrampolines, false, EXPERIMENTAL,                             \\\n-          \"Far calls uses jal to trampoline.\")                                   \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -930,20 +930,0 @@\n-void MacroAssembler::load_link_jump(const address source, Register temp) {\n-  assert(temp != noreg && temp != x0, \"expecting a register\");\n-  assert(temp != x5, \"temp register must not be x5.\");\n-  assert_cond(source != nullptr);\n-  int64_t distance = source - pc();\n-  assert(is_simm32(distance), \"Must be\");\n-  auipc(temp, (int32_t)distance + 0x800);\n-  ld(temp, Address(temp, ((int32_t)distance << 20) >> 20));\n-  jalr(temp);\n-}\n-\n-void MacroAssembler::jump_link(const address dest, Register temp) {\n-  assert(UseTrampolines, \"Must be\");\n-  assert_cond(dest != nullptr);\n-  int64_t distance = dest - pc();\n-  assert(is_simm21(distance), \"Must be\");\n-  assert((distance % 2) == 0, \"Must be\");\n-  jal(x1, distance);\n-}\n-\n@@ -4220,3 +4200,1 @@\n-\/\/ Maybe emit a call via a trampoline. If the code cache is small\n-\/\/ trampolines won't be emitted.\n-address MacroAssembler::trampoline_call(Address entry) {\n+address MacroAssembler::reloc_call(Address entry, Register tmp) {\n@@ -4230,1 +4208,0 @@\n-  \/\/ We need a trampoline if branches are far.\n@@ -4232,37 +4209,1 @@\n-    if (entry.rspec().type() == relocInfo::runtime_call_type) {\n-      assert(CodeBuffer::supports_shared_stubs(), \"must support shared stubs\");\n-      code()->share_trampoline_for(entry.target(), offset());\n-    } else {\n-      address stub = emit_trampoline_stub(offset(), target);\n-      if (stub == nullptr) {\n-        postcond(pc() == badAddress);\n-        return nullptr; \/\/ CodeCache is full\n-      }\n-    }\n-  }\n-  target = pc();\n-\n-  address call_pc = pc();\n-#ifdef ASSERT\n-  if (entry.rspec().type() != relocInfo::runtime_call_type) {\n-    assert_alignment(call_pc);\n-  }\n-#endif\n-  relocate(entry.rspec(), [&] {\n-    jump_link(target, t0);\n-  });\n-\n-  postcond(pc() != badAddress);\n-  return call_pc;\n-}\n-\n-address MacroAssembler::load_and_call(Address entry) {\n-  assert(entry.rspec().type() == relocInfo::runtime_call_type ||\n-         entry.rspec().type() == relocInfo::opt_virtual_call_type ||\n-         entry.rspec().type() == relocInfo::static_call_type ||\n-         entry.rspec().type() == relocInfo::virtual_call_type, \"wrong reloc type\");\n-\n-  address target = entry.target();\n-\n-  if (!in_scratch_emit_size()) {\n-    address stub = emit_address_stub(offset(), target);\n+    address stub = emit_reloc_call_address_stub(offset(), target);\n@@ -4281,0 +4222,1 @@\n+\n@@ -4282,1 +4224,4 @@\n-    load_link_jump(target, t1);\n+    int64_t distance = 0;\n+    auipc(tmp, (int32_t)distance + 0x800);\n+    ld(tmp, Address(tmp, ((int32_t)distance << 20) >> 20));\n+    jalr(tmp);\n@@ -4339,29 +4284,2 @@\n-address MacroAssembler::emit_address_stub(int insts_call_instruction_offset, address dest) {\n-  address stub = start_a_stub(max_reloc_call_stub_size());\n-  if (stub == nullptr) {\n-    return nullptr;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  \/\/ We are always 4-byte aligned here.\n-  assert_alignment(pc());\n-\n-  \/\/ Make sure the address of destination 8-byte aligned.\n-  align(wordSize, 0);\n-\n-  RelocationHolder rh = trampoline_stub_Relocation::spec(code()->insts()->start() +\n-                                                         insts_call_instruction_offset);\n-  const int stub_start_offset = offset();\n-  relocate(rh, [&] {\n-    assert(offset() - stub_start_offset == 0,\n-           \"%ld - %ld == %ld : should be\", (long)offset(), (long)stub_start_offset, (long)0);\n-    assert(offset() % wordSize == 0, \"bad alignment\");\n-    emit_int64((int64_t)dest);\n-  });\n-\n-  const address stub_start_addr = addr_at(stub_start_offset);\n-  end_a_stub();\n-\n-  return stub_start_addr;\n-}\n-\n-\/\/ Emit a trampoline stub for a call to a target which is too far away.\n+\/\/ Emit an address stub for a call to a target which is too far away.\n+\/\/ Note that we only put the target address of the call in the stub.\n@@ -4372,1 +4290,2 @@\n-\/\/   branch-and-link to <destination> or <trampoline stub>\n+\/\/   load target address from stub\n+\/\/   jump-and-link target address\n@@ -4374,8 +4293,6 @@\n-\/\/ Related trampoline stub for this call site in the stub section:\n-\/\/   load the call target from the constant pool\n-\/\/   branch (RA still points to the call site above)\n-\n-address MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset,\n-                                             address dest) {\n-  \/\/ Max stub size: alignment nop, TrampolineStub.\n-  address stub = start_a_stub(max_reloc_call_stub_size());\n+\/\/ Related address stub for this call site in the stub section:\n+\/\/   alignment nop\n+\/\/   target address\n+\n+address MacroAssembler::emit_reloc_call_address_stub(int insts_call_instruction_offset, address dest) {\n+  address stub = start_a_stub(max_reloc_call_address_stub_size());\n@@ -4386,2 +4303,0 @@\n-  assert(UseTrampolines, \"Must be using trampos.\");\n-\n@@ -4391,6 +4306,2 @@\n-  \/\/ Create a trampoline stub relocation which relates this trampoline stub\n-  \/\/ with the call instruction at insts_call_instruction_offset in the\n-  \/\/ instructions code-section.\n-\n-  \/\/ Make sure the address of destination 8-byte aligned after 3 instructions.\n-  align(wordSize, MacroAssembler::NativeShortCall::trampoline_data_offset);\n+  \/\/ Make sure the address of destination 8-byte aligned.\n+  align(wordSize, 0);\n@@ -4402,9 +4313,2 @@\n-    \/\/ Now, create the trampoline stub's code:\n-    \/\/ - load the call\n-    \/\/ - call\n-    Label target;\n-    ld(t1, target);  \/\/ auipc + ld\n-    jr(t1);          \/\/ jalr\n-    bind(target);\n-    assert(offset() - stub_start_offset == MacroAssembler::NativeShortCall::trampoline_data_offset,\n-           \"should be\");\n+    assert(offset() - stub_start_offset == 0,\n+           \"%ld - %ld == %ld : should be\", (long)offset(), (long)stub_start_offset, (long)0);\n@@ -4416,1 +4320,0 @@\n-\n@@ -4422,6 +4325,3 @@\n-int MacroAssembler::max_reloc_call_stub_size() {\n-  \/\/ Max stub size: alignment nop, TrampolineStub.\n-  if (UseTrampolines) {\n-    return instruction_size + MacroAssembler::NativeShortCall::trampoline_size;\n-  }\n-  return instruction_size + wordSize;\n+int MacroAssembler::max_reloc_call_address_stub_size() {\n+  \/\/ Max stub size: alignment nop, target address.\n+  return 1 * instruction_size + wordSize;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":24,"deletions":124,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -471,3 +471,2 @@\n-  address emit_address_stub(int insts_call_instruction_offset, address target);\n-  address emit_trampoline_stub(int insts_call_instruction_offset, address target);\n-  static int max_reloc_call_stub_size();\n+  address emit_reloc_call_address_stub(int insts_call_instruction_offset, address target);\n+  static int max_reloc_call_address_stub_size();\n@@ -629,3 +628,0 @@\n- private:\n-  void load_link_jump(const address source, Register temp);\n-  void jump_link(const address dest, Register temp);\n@@ -1230,3 +1226,1 @@\n-  \/\/ RISCV64 OpenJDK uses four different types of calls:\n-  \/\/   - direct call: jal pc_relative_offset\n-  \/\/     This is the shortest and the fastest, but the offset has the range: +\/-1MB.\n+  \/\/ RISCV64 OpenJDK uses three different types of calls:\n@@ -1235,5 +1229,4 @@\n-  \/\/     This is longer than a direct call. The offset has\n-  \/\/     the range [-(2G + 2K), 2G - 2K). Addresses out of the range in the code cache\n-  \/\/     requires indirect call.\n-  \/\/     If a jump is needed rather than a call, a far jump 'jalr x0, reg, offset' can\n-  \/\/     be used instead.\n+  \/\/     The offset has the range [-(2G + 2K), 2G - 2K). Addresses out of the\n+  \/\/     range in the code cache requires indirect call.\n+  \/\/     If a jump is needed rather than a call, a far jump 'jalr x0, reg, offset'\n+  \/\/     can be used instead.\n@@ -1243,4 +1236,4 @@\n-  \/\/     This too can reach anywhere in the address space, but it cannot be\n-  \/\/     patched while code is running, so it must only be modified at a safepoint.\n-  \/\/     This form of call is most suitable for targets at fixed addresses, which\n-  \/\/     will never be patched.\n+  \/\/     This can reach anywhere in the address space, but it cannot be patched\n+  \/\/     while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses,\n+  \/\/     which will never be patched.\n@@ -1249,1 +1242,2 @@\n-  \/\/     This is only available in C1\/C2-generated code (nmethod).\n+  \/\/     This too can reach anywhere in the address space but is only available\n+  \/\/     in C1\/C2-generated code (nmethod).\n@@ -1255,0 +1249,1 @@\n+  \/\/\n@@ -1256,1 +1251,1 @@\n-  \/\/     trampoline:\n+  \/\/     address stub:\n@@ -1261,41 +1256,6 @@\n-  \/\/\n-  \/\/ - trampoline call (old reloc call \/ -XX:+UseTrampolines):\n-  \/\/     This is only available in C1\/C2-generated code (nmethod). It is a combination\n-  \/\/     of a direct call, which is used if the destination of a call is in range,\n-  \/\/     and a register-indirect call. It has the advantages of reaching anywhere in\n-  \/\/     the RISCV address space and being patchable at runtime when the generated\n-  \/\/     code is being executed by other threads.\n-  \/\/\n-  \/\/     [Main code section]\n-  \/\/       jal trampoline\n-  \/\/     [Stub code section]\n-  \/\/     trampoline:\n-  \/\/       ld    reg, pc + 8 (auipc + ld)\n-  \/\/       jr    reg\n-  \/\/       <64-bit destination address>\n-  \/\/\n-  \/\/     If the destination is in range when the generated code is moved to the code\n-  \/\/     cache, 'jal trampoline' is replaced with 'jal destination' and the trampoline\n-  \/\/     is not used.\n-  \/\/     The optimization does not remove the trampoline from the stub section.\n-  \/\/\n-  \/\/     This is necessary because the trampoline may well be redirected later when\n-  \/\/     code is patched, and the new destination may not be reachable by a simple JAL\n-  \/\/     instruction.\n-  \/\/\n-  \/\/ To patch a trampoline call when the JAL can't reach, we first modify\n-  \/\/ the 64-bit destination address in the trampoline, then modify the\n-  \/\/ JAL to point to the trampoline, then flush the instruction cache to\n-  \/\/ broadcast the change to all executing threads. See\n-  \/\/ NativeCall::set_destination_mt_safe for the details.\n-  \/\/\n-  \/\/ There is a benign race in that the other thread might observe the\n-  \/\/ modified JAL before it observes the modified 64-bit destination\n-  \/\/ address. That does not matter because the destination method has been\n-  \/\/ invalidated, so there will be a trap at its start.\n-  \/\/ For this to work, the destination address in the trampoline is\n-  \/\/ always updated, even if we're not using the trampoline.\n-  \/\/ --\n-\n-  \/\/ Emit a direct call if the entry address will always be in range,\n-  \/\/ otherwise a reloc call.\n+  \/\/    There is a benign race in that the other thread might observe the old\n+  \/\/    64-bit destination address before it observes the new address. That does\n+  \/\/    not matter because the destination method has been invalidated, so there\n+  \/\/    will be a trap at its start.\n+\n+  \/\/ Emit a reloc call and create a stub to hold the entry point address.\n@@ -1308,8 +1268,2 @@\n-  \/\/ Return: the call PC or null if CodeCache is full.\n-  address reloc_call(Address entry) {\n-    return UseTrampolines ? trampoline_call(entry) : load_and_call(entry);\n-  }\n- private:\n-  address trampoline_call(Address entry);\n-  address load_and_call(Address entry);\n- public:\n+  \/\/ Return: the call PC or nullptr if CodeCache is full.\n+  address reloc_call(Address entry, Register tmp = t1);\n@@ -1639,5 +1593,0 @@\n-  enum NativeShortCall {\n-    trampoline_size        = 3 * instruction_size + wordSize,\n-    trampoline_data_offset = 3 * instruction_size\n-  };\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":23,"deletions":74,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -49,253 +49,0 @@\n-\/\/-----------------------------------------------------------------------------\n-\/\/ NativeShortCallTrampoline\n-\/\/\n-\/\/ Implements the trampoline part of reloc call - trampoline call.\n-\n-class NativeShortCall;\n-\n-class NativeShortCallTrampolineStub : public NativeInstruction {\n- private:\n-  friend NativeShortCall;\n-  enum RISCV_specific_constants {\n-    trampoline_data_offset = 3 * NativeInstruction::instruction_size \/\/ auipc + ld + jr\n-  };\n-\n-  address destination() const;\n-  void set_destination(address new_destination);\n-\n-  static bool is_at(address addr);\n-  static NativeShortCallTrampolineStub* at(address addr);\n-};\n-\n-address NativeShortCallTrampolineStub::destination() const {\n-  return ptr_at(trampoline_data_offset);\n-}\n-\n-void NativeShortCallTrampolineStub::set_destination(address new_destination) {\n-  set_ptr_at(trampoline_data_offset, new_destination);\n-  OrderAccess::release();\n-}\n-\n-bool NativeShortCallTrampolineStub::is_at(address addr) {\n-  \/\/ Ensure that the stub is exactly\n-  \/\/      ld   t0, L--->auipc + ld\n-  \/\/      jr   t0\n-  \/\/ L:\n-\n-  \/\/ judge inst + register + imm\n-  \/\/ 1). check the instructions: auipc + ld + jalr\n-  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n-  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n-  assert_cond(addr != nullptr);\n-  const int instr_size = NativeInstruction::instruction_size;\n-  if (MacroAssembler::is_auipc_at(addr) &&\n-      MacroAssembler::is_ld_at(addr + instr_size) &&\n-      MacroAssembler::is_jalr_at(addr + 2 * instr_size) &&\n-      (MacroAssembler::extract_rd(addr)                    == x6) &&\n-      (MacroAssembler::extract_rd(addr + instr_size)       == x6) &&\n-      (MacroAssembler::extract_rs1(addr + instr_size)      == x6) &&\n-      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x6) &&\n-      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_data_offset)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-NativeShortCallTrampolineStub* NativeShortCallTrampolineStub::at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(NativeShortCallTrampolineStub::is_at(addr), \"no call trampoline found\");\n-  return (NativeShortCallTrampolineStub*)addr;\n-}\n-\n-\/\/-----------------------------------------------------------------------------\n-\/\/ NativeShortCall\n-\/\/\n-\/\/ Implements the trampoline call, a short call with a trampoline, version of reloc call.\n-\/\/ Enabled by setting the experimental UseTrampolines to true.\n-\n-class NativeShortCall: private NativeInstruction {\n- public:\n-  enum RISCV_specific_constants {\n-    return_address_offset       =    1 * NativeInstruction::instruction_size \/\/ jal\n-  };\n-\n-  address instruction_address() const       { return addr_at(0); }\n-  address next_instruction_address() const  { return addr_at(return_address_offset); }\n-  address return_address() const            { return addr_at(return_address_offset); }\n-  address destination() const;\n-  address reloc_destination(address orig_address);\n-\n-  void set_destination(address dest);\n-  void verify();\n-  void print();\n-\n-  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n-  bool reloc_set_destination(address dest);\n-\n- private:\n-  address get_trampoline();\n-  bool has_trampoline();\n-  address trampoline_destination();\n- public:\n-\n-  static NativeShortCall* at(address addr);\n-  static bool is_at(address addr);\n-  static bool is_call_before(address return_address);\n-};\n-\n-address NativeShortCall::destination() const {\n-  address addr = instruction_address();\n-  assert(MacroAssembler::is_jal_at(instruction_address()), \"inst must be jal.\");\n-\n-  address destination = MacroAssembler::target_addr_for_insn(instruction_address());\n-\n-  \/\/ Do we use a trampoline stub for this call?\n-  CodeBlob* cb = CodeCache::find_blob(addr);\n-  assert(cb && cb->is_nmethod(), \"sanity\");\n-  nmethod *nm = (nmethod *)cb;\n-  if (nm != nullptr && nm->stub_contains(destination) && NativeShortCallTrampolineStub::is_at(destination)) {\n-    \/\/ Yes we do, so get the destination from the trampoline stub.\n-    const address trampoline_stub_addr = destination;\n-    destination = NativeShortCallTrampolineStub::at(trampoline_stub_addr)->destination();\n-  }\n-\n-  return destination;\n-}\n-\n-address NativeShortCall::reloc_destination(address orig_address) {\n-  address addr = instruction_address();\n-  if (NativeShortCall::is_at(addr)) {\n-    NativeShortCall* call = NativeShortCall::at(addr);\n-    if (call->has_trampoline()) {\n-      return call->trampoline_destination();\n-    }\n-  }\n-  if (orig_address != nullptr) {\n-    \/\/ the extracted address from the instructions in address orig_addr\n-    address new_addr = MacroAssembler::pd_call_destination(orig_address);\n-    \/\/ If call is branch to self, don't try to relocate it, just leave it\n-    \/\/ as branch to self. This happens during code generation if the code\n-    \/\/ buffer expands. It will be relocated to the trampoline above once\n-    \/\/ code generation is complete.\n-    new_addr = (new_addr == orig_address) ? addr : new_addr;\n-    return new_addr;\n-  }\n-  return MacroAssembler::pd_call_destination(addr);\n-}\n-\n-void NativeShortCall::set_destination(address dest) {\n-  assert(NativeShortCall::is_at(instruction_address()), \"unexpected code at call site\");\n-  assert(is_jal(), \"Should be jal instruction!\");\n-  intptr_t offset = (intptr_t)(dest - instruction_address());\n-  assert((offset & 0x1) == 0, \"bad alignment\");\n-  assert(Assembler::is_simm21(offset), \"encoding constraint\");\n-  unsigned int insn = 0b1101111; \/\/ jal\n-  address pInsn = (address)(&insn);\n-  Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n-  Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n-  Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n-  Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n-  Assembler::patch(pInsn, 11, 7, ra->encoding()); \/\/ Rd must be x1, need ra\n-  set_int_at(0, insn);\n-}\n-\n-void NativeShortCall::verify() {\n-  assert(NativeShortCall::is_at(instruction_address()),\n-         \"unexpected code at call site: %p\", instruction_address());\n-}\n-\n-void NativeShortCall::print() {\n-  assert(NativeShortCall::is_at(instruction_address()), \"unexpected code at call site\");\n-  tty->print_cr(PTR_FORMAT \": jal\/auipc,ld,jalr x1, offset\/reg\", p2i(instruction_address()));\n-}\n-\n-\/\/ The important thing is that threads are able to execute this\n-\/\/ call instruction at all times. (cmodx)\n-\/\/\n-\/\/ Used in the runtime linkage of calls; see class CompiledIC.\n-\/\/\n-\/\/ Add parameter assert_lock to switch off assertion\n-\/\/ during code generation, where no lock is needed.\n-bool NativeShortCall::set_destination_mt_safe(address dest, bool assert_lock) {\n-  assert(!assert_lock ||\n-         (CodeCache_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n-         CompiledICLocker::is_safe(instruction_address()),\n-         \"concurrent code patching\");\n-\n-  address call_addr = instruction_address();\n-  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n-\n-  reloc_set_destination(dest);\n-\n-  ICache::invalidate_range(call_addr, instruction_size);\n-  return true;\n-}\n-\n-bool NativeShortCall::reloc_set_destination(address dest) {\n-  address call_addr = instruction_address();\n-  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n-\n-  \/\/ Patch the constant in the call's trampoline stub.\n-  address trampoline_stub_addr = get_trampoline();\n-  if (trampoline_stub_addr != nullptr) {\n-    assert(!NativeShortCallTrampolineStub::is_at(dest), \"chained trampolines\");\n-    NativeShortCallTrampolineStub::at(trampoline_stub_addr)->set_destination(dest);\n-  }\n-\n-  \/\/ Patch the call.\n-  if (Assembler::reachable_from_branch_at(call_addr, dest)) {\n-    set_destination(dest);\n-  } else {\n-    assert (trampoline_stub_addr != nullptr, \"we need a trampoline\");\n-    set_destination(trampoline_stub_addr);\n-  }\n-\n-  return true;\n-}\n-\n-address NativeShortCall::get_trampoline() {\n-  address call_addr = instruction_address();\n-\n-  CodeBlob *code = CodeCache::find_blob(call_addr);\n-  assert(code != nullptr, \"Could not find the containing code blob\");\n-\n-  address jal_destination = MacroAssembler::pd_call_destination(call_addr);\n-  if (code != nullptr && code->contains(jal_destination) && NativeShortCallTrampolineStub::is_at(jal_destination)) {\n-    return jal_destination;\n-  }\n-\n-  if (code != nullptr && code->is_nmethod()) {\n-    return trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n-  }\n-\n-  return nullptr;\n-}\n-\n-bool NativeShortCall::has_trampoline() {\n-  return NativeShortCall::get_trampoline() != nullptr;\n-}\n-\n-address NativeShortCall::trampoline_destination() {\n-  return NativeShortCallTrampolineStub::at(get_trampoline())->destination();\n-}\n-\n-NativeShortCall* NativeShortCall::at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(NativeShortCall::is_at(addr), \"unexpected code at call site: %p\", addr);\n-  NativeShortCall* call = (NativeShortCall*)(addr);\n-  return call;\n-}\n-\n-bool NativeShortCall::is_at(address addr) {\n-  if (MacroAssembler::is_jal_at(addr)) {\n-    if (MacroAssembler::extract_rd(addr)  == x1) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool NativeShortCall::is_call_before(address return_address) {\n-  return NativeShortCall::is_at(return_address - instruction_size);\n-}\n-\n@@ -306,1 +53,0 @@\n-\/\/ This is the default (experimental flag UseTrampolines, default false).\n@@ -481,5 +227,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::at(addr_at(0))->instruction_address();\n-  } else {\n-    return NativeFarCall::at(addr_at(0))->instruction_address();\n-  }\n+  return NativeFarCall::at(addr_at(0))->instruction_address();\n@@ -489,5 +231,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::at(addr_at(0))->next_instruction_address();\n-  } else {\n-    return NativeFarCall::at(addr_at(0))->next_instruction_address();\n-  }\n+  return NativeFarCall::at(addr_at(0))->next_instruction_address();\n@@ -497,5 +235,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::at(addr_at(0))->return_address();\n-  } else {\n-    return NativeFarCall::at(addr_at(0))->return_address();\n-  }\n+  return NativeFarCall::at(addr_at(0))->return_address();\n@@ -505,5 +239,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::at(addr_at(0))->destination();\n-  } else {\n-    return NativeFarCall::at(addr_at(0))->destination();\n-  }\n+  return NativeFarCall::at(addr_at(0))->destination();\n@@ -513,5 +243,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::at(addr_at(0))->reloc_destination(orig_address);\n-  } else {\n-    return NativeFarCall::at(addr_at(0))->reloc_destination(orig_address);\n-  }\n+  return NativeFarCall::at(addr_at(0))->reloc_destination(orig_address);\n@@ -521,5 +247,1 @@\n-  if (UseTrampolines) {\n-    NativeShortCall::at(addr_at(0))->set_destination(dest);\n-  } else {\n-    NativeFarCall::at(addr_at(0))->set_destination(dest);\n-  }\n+  NativeFarCall::at(addr_at(0))->set_destination(dest);\n@@ -529,5 +251,1 @@\n-  if (UseTrampolines) {\n-    NativeShortCall::at(addr_at(0))->verify();\n-  } else {\n-    NativeFarCall::at(addr_at(0))->verify();;\n-  }\n+  NativeFarCall::at(addr_at(0))->verify();;\n@@ -537,5 +255,1 @@\n-  if (UseTrampolines) {\n-    NativeShortCall::at(addr_at(0))->print();\n-  } else {\n-    NativeFarCall::at(addr_at(0))->print();;\n-  }\n+  NativeFarCall::at(addr_at(0))->print();;\n@@ -545,5 +259,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n-  } else {\n-    return NativeFarCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n-  }\n+  return NativeFarCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n@@ -553,5 +263,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::at(addr_at(0))->reloc_set_destination(dest);\n-  } else {\n-    return NativeFarCall::at(addr_at(0))->reloc_set_destination(dest);\n-  }\n+  return NativeFarCall::at(addr_at(0))->reloc_set_destination(dest);\n@@ -561,5 +267,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::is_at(addr);\n-  } else {\n-    return NativeFarCall::is_at(addr);\n-  }\n+  return NativeFarCall::is_at(addr);\n@@ -569,5 +271,1 @@\n-  if (UseTrampolines) {\n-    return NativeShortCall::is_call_before(return_address);\n-  } else {\n-    return NativeFarCall::is_call_before(return_address);\n-  }\n+  return NativeFarCall::is_call_before(return_address);\n@@ -586,5 +284,1 @@\n-  if (UseTrampolines) {\n-    call = (NativeCall*)(return_address - NativeShortCall::return_address_offset);\n-  } else {\n-    call = (NativeCall*)(return_address - NativeFarCall::return_address_offset);\n-  }\n+  call = (NativeCall*)(return_address - NativeFarCall::return_address_offset);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":13,"deletions":319,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -127,5 +127,1 @@\n-    if (UseTrampolines) {\n-      return NativeInstruction::instruction_size; \/\/ jal\n-    } else {\n-      return 3 * NativeInstruction::instruction_size; \/\/ auipc + ld + jalr\n-    }\n+    return 3 * NativeInstruction::instruction_size; \/\/ auipc + ld + jalr\n@@ -133,0 +129,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1241,3 +1241,0 @@\n-  if (UseTrampolines) {\n-    return 1 * NativeInstruction::instruction_size; \/\/ jal\n-  }\n@@ -1249,3 +1246,0 @@\n-  if (UseTrampolines) {\n-    return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n-  }\n@@ -1256,7 +1250,3 @@\n-  \/\/ For generated stubs the call will be:\n-  \/\/   auipc + ld + jalr\n-  \/\/ Using trampos:\n-  \/\/   jal(addr)\n-  \/\/ or with far branches\n-  \/\/   jal(trampoline_stub)\n-  \/\/ for real runtime callouts it will be 9 instructions\n+  \/\/ For address inside the code cache the call will be:\n+  \/\/   auipc + jalr\n+  \/\/ For real runtime callouts it will be 9 instructions\n@@ -1270,4 +1260,1 @@\n-    if (UseTrampolines) {\n-      return 1 * NativeInstruction::instruction_size;\n-    }\n-    return 3 * NativeInstruction::instruction_size;\n+    return 2 * NativeInstruction::instruction_size;\n@@ -2437,4 +2424,2 @@\n-      if (!UseTrampolines) {\n-        __ nop();\n-        __ nop();\n-      }\n+      __ nop();\n+      __ nop();\n@@ -2491,4 +2476,4 @@\n-    \/\/ some calls to generated routines (arraycopy code) are scheduled\n-    \/\/ by C2 as runtime calls. if so we can call them using a jr (they\n-    \/\/ will be in a reachable segment) otherwise we have to use a jalr\n-    \/\/ which loads the absolute address into a register.\n+    \/\/ Some calls to generated routines (arraycopy code) are scheduled by C2\n+    \/\/ as runtime calls. if so we can call them using a far call (they will be\n+    \/\/ in the code cache, thus in a reachable segment) otherwise we have to use\n+    \/\/ a movptr+jalr pair which loads the absolute address into a register.\n@@ -2497,5 +2482,1 @@\n-      address call = __ reloc_call(Address(entry, relocInfo::runtime_call_type));\n-      if (call == nullptr) {\n-        ciEnv::current()->record_failure(\"CodeCache is full\");\n-        return;\n-      }\n+      __ far_call(Address(entry, relocInfo::runtime_call_type));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":11,"deletions":30,"binary":false,"changes":41,"status":"modified"}]}