{"files":[{"patch":"@@ -70,1 +70,2 @@\n-    _call_stub_size = 11 * MacroAssembler::instruction_size + MacroAssembler::NativeFarCall::trampoline_size,\n+    _call_stub_size = 11 * MacroAssembler::instruction_size +\n+                      1 * MacroAssembler::instruction_size + wordSize,\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  \/\/ Trampoline stubs are always word aligned.\n+  \/\/ Reloc call address stubs are always word aligned.\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4327,1 +4327,1 @@\n-  return instruction_size + wordSize;\n+  return 1 * instruction_size + wordSize;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1227,3 +1227,0 @@\n-  \/\/   - direct call: jal pc_relative_offset\n-  \/\/     This is the shortest and the fastest, but the offset has the range: +\/-1MB.\n-  \/\/\n@@ -1231,5 +1228,4 @@\n-  \/\/     This is longer than a direct call. The offset has\n-  \/\/     the range [-(2G + 2K), 2G - 2K). Addresses out of the range in the code cache\n-  \/\/     requires indirect call.\n-  \/\/     If a jump is needed rather than a call, a far jump 'jalr x0, reg, offset' can\n-  \/\/     be used instead.\n+  \/\/     The offset has the range [-(2G + 2K), 2G - 2K). Addresses out of the\n+  \/\/     range in the code cache requires indirect call.\n+  \/\/     If a jump is needed rather than a call, a far jump 'jalr x0, reg, offset'\n+  \/\/     can be used instead.\n@@ -1239,4 +1235,4 @@\n-  \/\/     This too can reach anywhere in the address space, but it cannot be\n-  \/\/     patched while code is running, so it must only be modified at a safepoint.\n-  \/\/     This form of call is most suitable for targets at fixed addresses, which\n-  \/\/     will never be patched.\n+  \/\/     This can reach anywhere in the address space, but it cannot be patched\n+  \/\/     while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses,\n+  \/\/     which will never be patched.\n@@ -1245,1 +1241,2 @@\n-  \/\/     This is only available in C1\/C2-generated code (nmethod).\n+  \/\/     This too can reach anywhere in the address space but is only available\n+  \/\/     in C1\/C2-generated code (nmethod).\n@@ -1251,0 +1248,1 @@\n+  \/\/\n@@ -1252,1 +1250,1 @@\n-  \/\/     trampoline:\n+  \/\/     address stub:\n@@ -1257,5 +1255,4 @@\n-  \/\/\n-  \/\/ There is a benign race in that the other thread might observe the old\n-  \/\/ 64-bit destination address before it observes the new address. That does\n-  \/\/ not matter because the destination method has been invalidated, so there\n-  \/\/ will be a trap at its start.\n+  \/\/    There is a benign race in that the other thread might observe the old\n+  \/\/    64-bit destination address before it observes the new address. That does\n+  \/\/    not matter because the destination method has been invalidated, so there\n+  \/\/    will be a trap at its start.\n@@ -1263,2 +1260,1 @@\n-  \/\/ Emit a direct call if the entry address will always be in range,\n-  \/\/ otherwise a reloc call.\n+  \/\/ Emit a reloc call and create a stub to hold the entry point address.\n@@ -1596,4 +1592,0 @@\n-  enum NativeFarCall {\n-    trampoline_size        = 1 * instruction_size + wordSize,\n-  };\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"}]}