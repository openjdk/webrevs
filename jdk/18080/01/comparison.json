{"files":[{"patch":"@@ -218,6 +218,8 @@\n-void PhaseIdealLoop::set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n-  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n-  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n-    Node* next = nodes_with_same_ctrl[j];\n-    if (next->in(0) == old_ctrl) {\n-      _igvn.replace_input_of(next, 0, new_ctrl);\n+void PhaseIdealLoop::set_ctrl_of_nodes_with_same_ctrl(Node* start_node, ProjNode* old_uncommon_proj,\n+                                                      Node* new_uncommon_proj) {\n+  ResourceMark rm;\n+  const Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(start_node, old_uncommon_proj);\n+  for (uint i = 0; i < nodes_with_same_ctrl.size(); i++) {\n+    Node* node = nodes_with_same_ctrl[i];\n+    if (node->in(0) == old_uncommon_proj) {\n+      _igvn.replace_input_of(node, 0, new_uncommon_proj);\n@@ -225,1 +227,1 @@\n-    set_ctrl(next, new_ctrl);\n+    set_ctrl(node, new_uncommon_proj);\n@@ -245,3 +247,4 @@\n-\/\/ Clone all nodes with the same ctrl as 'old_ctrl' starting from 'node' by following its inputs. Rewire the cloned nodes\n-\/\/ to 'new_ctrl'. Returns the clone of 'node'.\n-Node* PhaseIdealLoop::clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+\/\/ Clone all data nodes with a ctrl to the old uncommon projection from `start_node' by following its inputs. Rewire the\n+\/\/ cloned nodes to the new uncommon projection. Returns the clone of the `start_node`.\n+Node* PhaseIdealLoop::clone_nodes_with_same_ctrl(Node* start_node, ProjNode* old_uncommon_proj, Node* new_uncommon_proj) {\n+  ResourceMark rm;\n@@ -249,6 +252,7 @@\n-  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n-  Dict old_new_mapping = clone_nodes(nodes_with_same_ctrl); \/\/ Cloned but not rewired, yet\n-  rewire_cloned_nodes_to_ctrl(old_ctrl, new_ctrl, nodes_with_same_ctrl, old_new_mapping);\n-  Node* clone_phi_input = static_cast<Node*>(old_new_mapping[node]);\n-  assert(clone_phi_input != nullptr && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n-  return clone_phi_input;\n+  const Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(start_node, old_uncommon_proj);\n+  DataNodeGraph data_node_graph(nodes_with_same_ctrl, this);\n+  const OrigToNewHashtable& orig_to_clone = data_node_graph.clone(new_uncommon_proj);\n+  fix_cloned_data_node_controls(old_uncommon_proj, new_uncommon_proj, orig_to_clone);\n+  Node** cloned_node_ptr = orig_to_clone.get(start_node);\n+  assert(cloned_node_ptr != nullptr && (*cloned_node_ptr)->_idx >= last_idx, \"must exist and be a proper clone\");\n+  return *cloned_node_ptr;\n@@ -257,24 +261,8 @@\n-\/\/ Clone all the nodes on 'list_to_clone' and return an old->new mapping.\n-Dict PhaseIdealLoop::clone_nodes(const Node_List& list_to_clone) {\n-  Dict old_new_mapping(cmpkey, hashkey);\n-  for (uint i = 0; i < list_to_clone.size(); i++) {\n-    Node* next = list_to_clone[i];\n-    Node* clone = next->clone();\n-    _igvn.register_new_node_with_optimizer(clone);\n-    old_new_mapping.Insert(next, clone);\n-  }\n-  return old_new_mapping;\n-}\n-\n-\/\/ Rewire inputs of the unprocessed cloned nodes (inputs are not updated, yet, and still point to the old nodes) by\n-\/\/ using the old_new_mapping.\n-void PhaseIdealLoop::rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl,\n-                                                 const Node_List& nodes_with_same_ctrl, const Dict& old_new_mapping) {\n-  for (uint i = 0; i < nodes_with_same_ctrl.size(); i++) {\n-    Node* next = nodes_with_same_ctrl[i];\n-    Node* clone = static_cast<Node*>(old_new_mapping[next]);\n-    if (next->in(0) == old_ctrl) {\n-      \/\/ All data nodes with a control input to the uncommon projection in the chain need to be rewired to the new uncommon\n-      \/\/ projection (could not only be the last data node in the chain but also, for example, a DivNode within the chain).\n-      _igvn.replace_input_of(clone, 0, new_ctrl);\n-      set_ctrl(clone, new_ctrl);\n+\/\/ All data nodes with a control input to the uncommon projection in the chain need to be rewired to the new uncommon\n+\/\/ projection (could not only be the last data node in the chain but also, for example, a pinned DivNode within the chain).\n+void PhaseIdealLoop::fix_cloned_data_node_controls(const ProjNode* old_uncommon_proj, Node* new_uncommon_proj,\n+                                                   const OrigToNewHashtable& orig_to_clone) {\n+  auto orig_clone_action = [&](Node* orig, Node* clone) {\n+    if (orig->in(0) == old_uncommon_proj) {\n+      _igvn.replace_input_of(clone, 0, new_uncommon_proj);\n+      set_ctrl(clone, new_uncommon_proj);\n@@ -282,18 +270,2 @@\n-    rewire_inputs_of_clones_to_clones(new_ctrl, clone, old_new_mapping, next);\n-  }\n-}\n-\n-\/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n-void PhaseIdealLoop::rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping,\n-                                                       const Node* next) {\n-  for (uint i = 1; i < next->req(); i++) {\n-    Node* in = next->in(i);\n-    if (!in->is_Phi()) {\n-      assert(!in->is_CFG(), \"must be data node\");\n-      Node* in_clone = static_cast<Node*>(old_new_mapping[in]);\n-      if (in_clone != nullptr) {\n-        _igvn.replace_input_of(clone, i, in_clone);\n-        set_ctrl(clone, new_ctrl);\n-      }\n-    }\n-  }\n+  };\n+  orig_to_clone.iterate_all(orig_clone_action);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":30,"deletions":58,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+class DataInputGraph;\n@@ -1346,1 +1347,1 @@\n-  void set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  void set_ctrl_of_nodes_with_same_ctrl(Node* start_node, ProjNode* old_uncommon_proj, Node* new_uncommon_proj);\n@@ -1348,5 +1349,4 @@\n-  Node* clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n-  Dict clone_nodes(const Node_List& list_to_clone);\n-  void rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl, const Node_List& nodes_with_same_ctrl,\n-                                   const Dict& old_new_mapping);\n-  void rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping, const Node* next);\n+  const Unique_Node_List& find_nodes_with_same_ctrl(DataInputGraph& data_input_graph, const ProjNode* ctrl);\n+  Node* clone_nodes_with_same_ctrl(Node* start_node, ProjNode* old_uncommon_proj, Node* new_uncommon_proj);\n+  void fix_cloned_data_node_controls(const ProjNode* orig, Node* new_uncommon_proj,\n+                                     const OrigToNewHashtable& orig_to_clone);\n@@ -1885,0 +1885,37 @@\n+\/\/ Class to clone a data node graph by taking a list of data nodes. This is done in 2 steps:\n+\/\/   1. Clone the data nodes\n+\/\/   2. Fix the cloned data inputs pointing to the old nodes to the cloned inputs by using an old->new mapping.\n+class DataNodeGraph : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+  const Unique_Node_List& _data_nodes;\n+  OrigToNewHashtable _orig_to_new;\n+\n+ public:\n+  DataNodeGraph(const Unique_Node_List& data_nodes, PhaseIdealLoop* phase)\n+      : _phase(phase),\n+        _data_nodes(data_nodes),\n+        \/\/ Use 107 as best guess which is the first resize value in ResizeableResourceHashtable::large_table_sizes.\n+        _orig_to_new(107, MaxNodeLimit)\n+  {\n+#ifdef ASSERT\n+    for (uint i = 0; i < data_nodes.size(); i++) {\n+      assert(!data_nodes[i]->is_CFG(), \"only data nodes\");\n+    }\n+#endif\n+  }\n+  NONCOPYABLE(DataNodeGraph);\n+\n+ private:\n+  void clone(Node* node, Node* new_ctrl);\n+  void clone_nodes(Node* new_ctrl);\n+  void rewire_clones_to_cloned_inputs();\n+\n+ public:\n+  \/\/ Clone the provided data node collection and rewire the clones in such a way to create an identical graph copy.\n+  \/\/ Set `new_ctrl` as ctrl for the cloned nodes.\n+  const OrigToNewHashtable& clone(Node* new_ctrl) {\n+    clone_nodes(new_ctrl);\n+    rewire_clones_to_cloned_inputs();\n+    return _orig_to_new;\n+  }\n+};\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -4498,0 +4498,29 @@\n+\n+\/\/ Clone all nodes in _data_nodes.\n+void DataNodeGraph::clone_nodes(Node* new_ctrl) {\n+  for (uint i = 0; i < _data_nodes.size(); i++) {\n+    clone(_data_nodes[i], new_ctrl);\n+  }\n+}\n+\n+\/\/ Clone the given node and set it up properly. Set `new_ctrl` as ctrl.\n+void DataNodeGraph::clone(Node* node, Node* new_ctrl) {\n+  Node* clone = node->clone();\n+  _phase->igvn().register_new_node_with_optimizer(clone);\n+  _orig_to_new.put(node, clone);\n+  _phase->set_ctrl(clone, new_ctrl);\n+}\n+\n+\/\/ Rewire the data inputs of all (unprocessed) cloned nodes, whose inputs are still pointing to the same inputs as their\n+\/\/ corresponding orig nodes, to the newly cloned inputs to create a separate cloned graph.\n+void DataNodeGraph::rewire_clones_to_cloned_inputs() {\n+  _orig_to_new.iterate_all([&](Node* node, Node* clone) {\n+    for (uint i = 1; i < node->req(); i++) {\n+      Node** cloned_input = _orig_to_new.get(node->in(i));\n+      if (cloned_input != nullptr) {\n+        \/\/ Input was also cloned -> rewire clone to the cloned input.\n+        _phase->igvn().replace_input_of(clone, i, *cloned_input);\n+      }\n+    }\n+  });\n+}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -210,0 +210,2 @@\n+typedef ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-    ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> clones(hash_table_size, hash_table_size);\n+    OrigToNewHashtable clones(hash_table_size, hash_table_size);\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}