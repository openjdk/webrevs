{"files":[{"patch":"@@ -185,0 +185,1 @@\n+        \/\/ reads non-null due to StoreStore barrier in critical section in initializeMap\n@@ -222,1 +223,1 @@\n-        RemovalToken permission = (RemovalToken) accessed; \/\/ nullable\n+        RemovalToken token = (RemovalToken) accessed; \/\/ nullable\n@@ -244,1 +245,1 @@\n-            accessed = map.associateAccess(this, permission, value);\n+            accessed = map.associateAccess(this, token, value);\n@@ -250,1 +251,1 @@\n-                permission = (RemovalToken) accessed;\n+                token = (RemovalToken) accessed;\n@@ -327,0 +328,11 @@\n+    \/**\n+     * Besides a value (represented by an Entry), a \"removal token\" object,\n+     * including the value {@code null}, can be present at a ClassValue-Class\n+     * coordinate.  A removal token indicates whether the value from a\n+     * computation is up-to-date; the value is up-to-date if the token is the\n+     * same before and after computation (no removal during this period), or if\n+     * the token is from the same thread (removed during computeValue).\n+     * {@code null} is the initial state, meaning all computations are valid.\n+     * Later tokens are always non-null, no matter if they replace existing\n+     * entries or outdated tokens.\n+     *\/\n@@ -328,1 +340,2 @@\n-        private final WeakReference<Thread> actor;\n+        \/\/ Use thread ID, which presumably don't duplicate and is cheaper than WeakReference\n+        private final long actorId;\n@@ -331,1 +344,1 @@\n-            this.actor = new WeakReference<>(Thread.currentThread());\n+            this.actorId = Thread.currentThread().threadId();\n@@ -334,1 +347,1 @@\n-        \/\/ Arguments are nullable, intentionally\n+        \/\/ Arguments are nullable, intentionally to allow initial tokens\n@@ -336,0 +349,1 @@\n+            \/\/ No removal token after the initial can be null\n@@ -337,1 +351,1 @@\n-            return current == original || current.actor.refersTo(Thread.currentThread());\n+            return current == original || current.actorId == Thread.currentThread().threadId();\n@@ -349,2 +363,0 @@\n-     *  Promises are never put into the cache; they only live in the\n-     *  backing map while a computeValue call is in flight.\n@@ -399,5 +411,6 @@\n-                \/\/ Place a Store fence after construction and before publishing to emulate\n-                \/\/ ClassValueMap containing final fields. This ensures it can be\n-                \/\/ published safely in the non-volatile field Class.classValueMap,\n-                \/\/ since stores to the fields of ClassValueMap will not be reordered\n-                \/\/ to occur after the store to the field type.classValueMap\n+                \/\/ getCacheCarefully anticipates entry array to be non-null when\n+                \/\/ a ClassValueMap is published to it.  However, ClassValueMap\n+                \/\/ has no final field, so compiler does not emit a fence, and\n+                \/\/ we must manually issue a Store-Store barrier to prevent\n+                \/\/ the assignment below to be reordered with the store to\n+                \/\/ entry array in the constructor above\n@@ -455,0 +468,1 @@\n+        \/\/ This may refresh the entry for the cache, but the associated value always stays the same.\n@@ -470,1 +484,1 @@\n-        synchronized <T> Object associateAccess(ClassValue<T> classValue, RemovalToken computationalToken, T value) {\n+        synchronized <T> Object associateAccess(ClassValue<T> classValue, RemovalToken startToken, T value) {\n@@ -475,1 +489,1 @@\n-            if (RemovalToken.areCompatible(currentToken, computationalToken)) {\n+            if (RemovalToken.areCompatible(currentToken, startToken)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"}]}