{"files":[{"patch":"@@ -317,6 +317,2 @@\n-        void registerExtraThread() {\n-            var tracker = ((PromiseInfo) value);\n-            if (!tracker.add()) {\n-                \/\/ This is trivial: such a recursion already causes StackOverflowError\n-                throw new StackOverflowError(\"Recursive initialization of class value\");\n-            }\n+        void registerOwner() {\n+            ((PromiseInfo) value).add();\n@@ -325,5 +321,2 @@\n-        void checkReentrancy() {\n-            var tracker = ((PromiseInfo) value);\n-            if (tracker.contains()) {\n-                throw new StackOverflowError(\"Recursive initialization of class value\");\n-            }\n+        boolean hasOwnership() {\n+            return ((PromiseInfo) value).contains();\n@@ -481,1 +474,1 @@\n-                    e.registerExtraThread();\n+                    e.registerOwner();\n@@ -510,1 +503,1 @@\n-            } else if (e0 != null && e0.isPromise() && e0.version() == e.version()) {\n+            } else if (e0 != null && e0.isPromise() && e0.version() == e.version() && e0.hasOwnership()) {\n@@ -538,3 +531,4 @@\n-                    \/\/ Perform reentrancy checks so we fail if we are removing\n-                    \/\/ our own promise.\n-                    e.checkReentrancy();\n+                    if (e.hasOwnership()) {\n+                        \/\/ Notify myself that I am still up-to-date. All other guys are stale\n+                        put(classValue.identity, classValue.version().createPromise());\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-     * Tests that calling remove() from computeValue() is no-op.\n+     * Tests that calling get() from computeValue() terminates.\n@@ -215,1 +215,1 @@\n-    void testRemoveInCompute() {\n+    void testGetInCompute() {\n@@ -219,3 +219,3 @@\n-                remove(type);\n-                remove(type);\n-                remove(type);\n+                get(type);\n+                get(type);\n+                get(type);\n@@ -232,0 +232,18 @@\n+    \/**\n+     * Tests that calling remove() from computeValue() terminates.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveInCompute() {\n+        ClassValue<Boolean> cv = new ClassValue<>() {\n+            @Override\n+            protected Boolean computeValue(Class<?> type) {\n+                remove(type);\n+                remove(type);\n+                remove(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+        assertTrue(cv.get(int.class));\n+    }\n+\n@@ -320,0 +338,1 @@\n+                remove(type);\n@@ -330,3 +349,2 @@\n-        var threads = Arrays.stream(CLASSES).map(clz ->\n-                Thread.startVirtualThread(() ->\n-                        assertThrows(Throwable.class, () -> cv.get(clz))))\n+        var threads = Arrays.stream(CLASSES)\n+                .map(clz -> Thread.startVirtualThread(() -> cv.get(clz)))\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"}]}