{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import java.util.IdentityHashMap;\n-import java.util.Map;\n@@ -149,1 +147,1 @@\n-            return e.value();\n+            return e.value;\n@@ -169,1 +167,1 @@\n-        map.removeEntry(this);\n+        map.removeAccess(this);\n@@ -175,1 +173,1 @@\n-        map.changeEntry(this, value);\n+        map.setAccess(this, value);\n@@ -204,1 +202,1 @@\n-            return e.value();\n+            return e.value;\n@@ -217,1 +215,8 @@\n-        Throwable ex = null;\n+        var accessed = map.readAccess(this);\n+        if (accessed instanceof Entry) {\n+            @SuppressWarnings(\"unchecked\")\n+            var cast = (Entry<T>) accessed;\n+            return cast.value;\n+        }\n+\n+        RemovalToken permission = (RemovalToken) accessed; \/\/ nullable\n@@ -219,3 +224,1 @@\n-            Entry<T> e = map.startEntry(this);\n-            if (!e.isPromise())\n-                return e.value();\n+            T value;\n@@ -223,11 +226,14 @@\n-                \/\/ Try to make a real entry for the promised version.\n-                \/\/ e is real if computeValue finishes normally,\n-                \/\/ otherwise it is still the old promise\n-                e = makeEntry(e.version(), computeValue(type));\n-            } catch (Throwable problem) {\n-                ex = problem;\n-            } finally {\n-                \/\/ Whether computeValue throws or returns normally,\n-                \/\/ be sure to remove the empty entry.\n-                \/\/\n-                e = map.finishEntry(this, e);\n+                value = computeValue(type);\n+            } catch (Throwable ex) {\n+                accessed = map.readAccess(this);\n+                if (accessed instanceof Entry) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    var cast = (Entry<T>) accessed;\n+                    return cast.value;\n+                }\n+                \/\/ report failure here, but allow other callers to try again\n+                if (ex instanceof RuntimeException rte) {\n+                    throw rte;\n+                } else {\n+                    throw ex instanceof Error err ? err : new Error(ex);\n+                }\n@@ -235,7 +241,6 @@\n-            if (e != null)    \/\/ success, either here or in a racing thread\n-                return e.value();\n-            if (ex == null)   \/\/ a racing thread called remove, so try again\n-                continue;\n-            \/\/ report failure here, but allow other callers to try again\n-            if (ex instanceof RuntimeException rte) {\n-                throw rte;\n+            \/\/ computeValue succeed, proceed to install\n+            accessed = map.installAccess(this, permission, makeEntry(version(), value));\n+            if (accessed instanceof Entry) {\n+                @SuppressWarnings(\"unchecked\")\n+                var cast = (Entry<T>) accessed;\n+                return cast.value;\n@@ -243,1 +248,2 @@\n-                throw ex instanceof Error err ? err : new Error(ex);\n+                permission = (RemovalToken) accessed;\n+                \/\/ repeat\n@@ -252,1 +258,1 @@\n-        return (e != null && e.get() == this.version);\n+        return (e != null && e.version() == this.version);\n@@ -312,1 +318,1 @@\n-    static class Version<T> {\n+    static final class Version<T> {\n@@ -316,1 +322,0 @@\n-        Entry<T> createPromise() { return new Entry<>(this); }\n@@ -320,0 +325,14 @@\n+    private static final class RemovalToken {\n+        private final WeakReference<Thread> actor;\n+\n+        private RemovalToken() {\n+            this.actor = new WeakReference<>(Thread.currentThread());\n+        }\n+\n+        \/\/ Arguments are nullable, intentionally\n+        static boolean areCompatible(RemovalToken current, RemovalToken original) {\n+            assert current != null || original == null : current + \" : \" + original;\n+            return current == original || current.actor.refersTo(Thread.currentThread());\n+        }\n+    }\n+\n@@ -322,1 +341,1 @@\n-     *  The states are only meaningful for the cache array; whatever in the map\n+     *  The version is only meaningful for the cache array; whatever in the map\n@@ -325,3 +344,2 @@\n-     *  <li> promise if value == Entry.this\n-     *  <li> else dead if version == null\n-     *  <li> else stale if version != classValue.version\n+     *  <li> dead if version == null\n+     *  <li> stale if version != classValue.version\n@@ -334,33 +352,3 @@\n-    static class Entry<T> extends WeakReference<Version<T>> {\n-        final Object value;  \/\/ usually of type T, but sometimes (Entry)this\n-        Entry(Version<T> version, T value) {\n-            super(version);\n-            this.value = value;  \/\/ for a regular entry, value is of type T\n-        }\n-        private void assertNotPromise() { assert(!isPromise()); }\n-        \/** For creating a promise. *\/\n-        Entry(Version<T> version) {\n-            super(version);\n-            this.value = new PromiseInfo();  \/\/ for a promise, value is not of type T, but PromiseInfo!\n-        }\n-        \/** Fetch the value.  This entry must not be a promise. *\/\n-        @SuppressWarnings(\"unchecked\")  \/\/ if !isPromise, type is T\n-        T value() { assertNotPromise(); return (T) value; }\n-\n-        boolean isPromise() { return value instanceof PromiseInfo; }\n-\n-        boolean addPromiseByCurrentThread() {\n-            return ((PromiseInfo) value).addCurrentThread();\n-        }\n-\n-        boolean isPromisedByCurrentThread() {\n-            return ((PromiseInfo) value).containsCurrentThread();\n-        }\n-\n-        \/\/ The content of a promise is a non-empty set of threads working on that promise.\n-        \/\/ Must be accessed in synchronization blocks on the ClassValueMap (otherThreads).\n-        \/\/ Compared to ThreadTracker, this optimizes optimistically for\n-        \/\/ single-thread accessors and uses plain instead of concurrent data structures.\n-        static final class PromiseInfo {\n-            private final Thread initialThread;\n-            private Map<Thread, Object> otherThreads; \/\/ Must be identity\/thread ID-based\n+    static final class Entry<T> {\n+        final T value;\n+        final WeakReference<Version<T>> version; \/\/ The version exists only for cache invalidation\n@@ -368,25 +356,3 @@\n-            PromiseInfo() {\n-                initialThread = Thread.currentThread();\n-            }\n-\n-            boolean addCurrentThread() {\n-                Thread t = Thread.currentThread();\n-                if (initialThread == t) {\n-                    return false;\n-                }\n-\n-                var others = this.otherThreads;\n-                if (others == null) {\n-                    others = new IdentityHashMap<>();\n-                    this.otherThreads = others;\n-                }\n-                return others.put(t, int.class) == null;\n-            }\n-\n-            boolean containsCurrentThread() {\n-                Thread t = Thread.currentThread();\n-                if (initialThread == t)\n-                    return true;\n-                var map = otherThreads;\n-                return map != null && map.containsKey(t);\n-            }\n+        Entry(Version<T> version, T value) {\n+            this.value = value;\n+            this.version = new WeakReference<>(version);\n@@ -395,1 +361,1 @@\n-        Version<T> version() { return get(); }\n+        Version<T> version() { return version.get(); }\n@@ -404,1 +370,1 @@\n-            clear();\n+            version.clear();\n@@ -408,6 +374,4 @@\n-            assertNotPromise();\n-            @SuppressWarnings(\"unchecked\")  \/\/ if !isPromise, type is T\n-            Entry<T> e2 = new Entry<>(v2, (T) value);\n-            clear();\n-            \/\/ value = null -- caller must drop\n-            return e2;\n+            if (!version.refersTo(v2)) {\n+                return new Entry<>(v2, value);\n+            }\n+            return this;\n@@ -469,0 +433,1 @@\n+     *  The state may be assigned value or unassigned token.\n@@ -471,1 +436,1 @@\n-    static class ClassValueMap extends WeakHashMap<ClassValue.Identity, Entry<?>> {\n+    static final class ClassValueMap extends WeakHashMap<ClassValue.Identity, Object> {\n@@ -490,35 +455,10 @@\n-        \/** Initiate a query.  Store a promise (placeholder) if there is no value yet. *\/\n-        synchronized\n-        <T> Entry<T> startEntry(ClassValue<T> classValue) {\n-            @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all value types <T>\n-            Entry<T> e = (Entry<T>) get(classValue.identity);\n-            Version<T> v = classValue.version();\n-            if (e == null) {\n-                e = v.createPromise();\n-                \/\/ The presence of a promise means that a value is pending for v.\n-                \/\/ Eventually, finishEntry will overwrite the promise.\n-                put(classValue.identity, e);\n-                \/\/ Note that the promise is never entered into the cache!\n-                return e;\n-            } else if (e.isPromise()) {\n-                \/\/ Somebody else has asked the same question.\n-                \/\/ Let the races begin!\n-                \/\/\n-                \/\/ Anything in the map is authentic - even if this promise may\n-                \/\/ appear \"outdated\" by version, if it is truly outdated, it\n-                \/\/ would have been removed or replaced from the map.\n-                \/\/\n-                \/\/ Keep track of which threads observe this particular promise.\n-                \/\/ All of them are equally racing to fulfill the promise.\n-                e.addPromiseByCurrentThread();\n-                \/\/ Let the VM throw StackOverflowError: sometimes, a\n-                \/\/ computeValue can trigger class initialization, which\n-                \/\/ itself triggers another computeValue.\n-                return e;\n-            } else {\n-                \/\/ there is already a completed entry here; report it\n-                if (e.version() != v) {\n-                    \/\/ There is a stale but valid entry here; make it fresh again.\n-                    \/\/ Once an entry is in the hash table, we don't care what its version is.\n-                    e = e.refreshVersion(v);\n-                    put(classValue.identity, e);\n+        \/\/ A simple read access to this map, for the initial get access.\n+        synchronized <T> Object readAccess(ClassValue<T> classValue) {\n+            var item = get(classValue.identity);\n+            if (item instanceof Entry) {\n+                @SuppressWarnings(\"unchecked\")\n+                var entry = (Entry<T>) item;\n+                \/\/ cache refresh\n+                var updated = entry.refreshVersion(classValue.version());\n+                if (updated != entry) {\n+                    put(classValue.identity, updated);\n@@ -526,4 +466,0 @@\n-                \/\/ Add to the cache, to enable the fast path, next time.\n-                checkCacheLoad();\n-                addToCache(classValue, e);\n-                return e;\n@@ -531,0 +467,1 @@\n+            return item;\n@@ -533,22 +470,8 @@\n-        \/** Finish a query.  Overwrite a matching placeholder.  Drop stale incoming values. *\/\n-        synchronized\n-        <T> Entry<T> finishEntry(ClassValue<T> classValue, Entry<T> e) {\n-            @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all value types <T>\n-            Entry<T> e0 = (Entry<T>) get(classValue.identity);\n-            if (e == e0) {\n-                \/\/ We can get here during exception processing, unwinding from computeValue.\n-                assert(e.isPromise());\n-                \/\/ Other threads can retry if successful or just propagate their exceptions.\n-                remove(classValue.identity);\n-                return null;\n-            } else if (e0 != null && e0.isPromise()) {\n-                if (e0.version() != e.version() || !e0.isPromisedByCurrentThread()) {\n-                    \/\/ e0 is created after e, whether e failed (promise) or succeeded\n-                    return null;  \/\/ caller must try again\n-                }\n-                \/\/ If e0 matches the intended entry, there has not been a remove call\n-                \/\/ between the previous startEntry and now.  So now overwrite e0.\n-                Version<T> v = classValue.version();\n-                if (e.version() != v)  \/\/ removal in unrelated associations\n-                    e = e.refreshVersion(v);\n-                put(classValue.identity, e);\n+        \/\/ An installation attempt, for when a computeValue finishes.\n+        synchronized <T> Object installAccess(ClassValue<T> classValue, RemovalToken computationalToken, Entry<T> entry) {\n+            var item = readAccess(classValue);\n+            if (item instanceof Entry)\n+                return item; \/\/ somebody already installed\n+            var currentToken = (RemovalToken) item;\n+            if (RemovalToken.areCompatible(currentToken, computationalToken)) {\n+                put(classValue.identity, entry);\n@@ -557,8 +480,2 @@\n-                addToCache(classValue, e);\n-                return e;\n-            } else {\n-                \/\/ Some sort of mismatch; caller must try again if e0=null.\n-                \/\/ This can happen when:\n-                \/\/ 1. Another thread computes and finishes exceptionally.\n-                \/\/ 2. A remove() is issued after computation started.\n-                return e0;\n+                addToCache(classValue, entry);\n+                return entry;\n@@ -566,0 +483,1 @@\n+            return currentToken;\n@@ -568,22 +486,6 @@\n-        \/** Remove an entry. *\/\n-        synchronized\n-        void removeEntry(ClassValue<?> classValue) {\n-            Entry<?> e = remove(classValue.identity);\n-            \/\/ e == null: Uninitialized, and no pending calls to computeValue.\n-            \/\/ remove(identity) didn't change anything.  No change.\n-            if (e != null) {\n-                if (e.isPromise()) {\n-                    \/\/ Remove the outdated promise to force recomputation.\n-                    if (e.isPromisedByCurrentThread()) {\n-                        \/\/ Notify myself that I am still up-to-date. All other racers are stale.\n-                        \/\/ That is, the fresh promise contains only this thread as promiser.\n-                        put(classValue.identity, classValue.version().createPromise());\n-                    }\n-                } else {\n-                    \/\/ Initialized.\n-                    \/\/ Bump forward to invalidate racy-read cached entries.\n-                    classValue.bumpVersion();\n-                    \/\/ Make all cache elements for this guy go stale.\n-                    removeStaleEntries(classValue);\n-                }\n-            }\n+        \/\/ A removal, requiring subsequent installations to be up-to-date with it.\n+        synchronized void removeAccess(ClassValue<?> classValue) {\n+            \/\/ Always put in a token to invalidate ongoing computations\n+            put(classValue.identity, new RemovalToken());\n+            classValue.bumpVersion();\n+            removeStaleEntries(classValue);\n@@ -592,15 +494,6 @@\n-        \/** Change the value for an entry. *\/\n-        synchronized\n-        <T> void changeEntry(ClassValue<T> classValue, T value) {\n-            @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all value types <T>\n-            Entry<T> e0 = (Entry<T>) get(classValue.identity);\n-            Version<T> version = classValue.version();\n-            if (e0 != null) {\n-                if (e0.version() == version && e0.value() == value)\n-                    \/\/ no value change => no version change needed\n-                    return;\n-                classValue.bumpVersion();\n-                removeStaleEntries(classValue);\n-            }\n-            Entry<T> e = makeEntry(version, value);\n-            put(classValue.identity, e);\n+        \/\/ A set, requires cache to flush.\n+        synchronized <T> void setAccess(ClassValue<T> classValue, T value) {\n+            classValue.bumpVersion();\n+            removeStaleEntries();\n+            var entry = makeEntry(classValue.version(), value);\n+            put(classValue.identity, entry);\n@@ -609,1 +502,1 @@\n-            addToCache(classValue, e);\n+            addToCache(classValue, entry);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":103,"deletions":210,"binary":false,"changes":313,"status":"modified"}]}