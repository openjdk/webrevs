{"files":[{"patch":"@@ -533,13 +533,11 @@\n-                if (e.version() != v) {\n-                    \/\/ Somebody bumped the version, after resetting some state.\n-                    \/\/ This means we have to start fresh.\n-                    e = v.createPromise();\n-                    put(classValue.identity, e);\n-                } else {\n-                    \/\/ Keep track of which threads observe this particular version.\n-                    \/\/ All of them are equally racing to fulfill the promise.\n-                    e.addPromiseByCurrentThread();\n-                    \/\/ Let the VM throw StackOverflowError: sometimes, a\n-                    \/\/ computeValue can trigger class initialization, which\n-                    \/\/ itself triggers another computeValue.\n-                }\n+                \/\/\n+                \/\/ Anything in the map is authentic - even if this promise may\n+                \/\/ appear \"outdated\" by version, if it is truly outdated, it\n+                \/\/ would have been removed or replaced from the map.\n+                \/\/\n+                \/\/ Keep track of which threads observe this particular promise.\n+                \/\/ All of them are equally racing to fulfill the promise.\n+                e.addPromiseByCurrentThread();\n+                \/\/ Let the VM throw StackOverflowError: sometimes, a\n+                \/\/ computeValue can trigger class initialization, which\n+                \/\/ itself triggers another computeValue.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+ * @enablePreview\n+ * @comment Remove preview if ScopedValue is finalized\n@@ -36,0 +38,2 @@\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n@@ -39,0 +43,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -172,1 +177,0 @@\n-    private static final int RUNS = 16;\n@@ -174,0 +178,11 @@\n+    private static final Duration TIMEOUT = Duration.of(2, ChronoUnit.SECONDS);\n+\n+    private static void await(CountDownLatch latch) {\n+        try {\n+            if (!latch.await(2L, TimeUnit.SECONDS)) {\n+                fail(\"No signal received\");\n+            }\n+        } catch (InterruptedException e) {\n+            fail(e);\n+        }\n+    }\n@@ -179,2 +194,5 @@\n-    @RepeatedTest(value = RUNS)\n-    void testRemoveStale() {\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveStale() throws InterruptedException {\n+        CountDownLatch oldInputUsed = new CountDownLatch(1);\n+        CountDownLatch inputUpdated = new CountDownLatch(1);\n@@ -187,5 +205,3 @@\n-                try {\n-                    Thread.sleep(COMPUTE_TIME_MILLIS);\n-                } catch (InterruptedException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+                oldInputUsed.countDown();\n+                \/\/ ensure input is updated when we return\n+                await(inputUpdated);\n@@ -197,0 +213,1 @@\n+            await(oldInputUsed);\n@@ -199,0 +216,1 @@\n+            inputUpdated.countDown();\n@@ -200,6 +218,2 @@\n-        try {\n-            innocuous.join();\n-            refreshInput.join();\n-        } catch (InterruptedException ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        innocuous.join(TIMEOUT);\n+        refreshInput.join(TIMEOUT);\n@@ -293,1 +307,1 @@\n-    @RepeatedTest(4) \/\/ repeat 4 times\n+    @RepeatedTest(4)\n@@ -295,0 +309,1 @@\n+        CountDownLatch raceStart = new CountDownLatch(1);\n@@ -298,5 +313,1 @@\n-                try {\n-                    Thread.sleep(COMPUTE_TIME_MILLIS);\n-                } catch (InterruptedException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+                await(raceStart);\n@@ -322,0 +333,1 @@\n+        raceStart.countDown();\n@@ -324,1 +336,1 @@\n-                t.join();\n+                t.join(TIMEOUT);\n@@ -354,1 +366,1 @@\n-                t.join();\n+                t.join(TIMEOUT);\n@@ -381,0 +393,47 @@\n+\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testNoRecomputeOnUnrelatedRemoval() throws InterruptedException {\n+        CountDownLatch t1Started = new CountDownLatch(1);\n+        CountDownLatch removeTamper = new CountDownLatch(1);\n+        CountDownLatch t2Started = new CountDownLatch(1);\n+        CountDownLatch t1Returned = new CountDownLatch(1);\n+        ScopedValue<Integer> threadId = ScopedValue.newInstance();\n+        AtomicInteger t1Tries = new AtomicInteger();\n+        ClassValue<Object> clv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                int id = threadId.get();\n+                if (id == 1) {\n+                    t1Tries.incrementAndGet();\n+                    t1Started.countDown();\n+                    await(t2Started); \/\/ implies unrelated changes\n+                } else if (id == 2) {\n+                    t2Started.countDown();\n+                    \/\/ Don't race to install - we want to check computeValue tampers\n+                    await(t1Returned);\n+                } else if (id != -1) {\n+                    fail(\"Id: \" + id);\n+                }\n+                return \"\";\n+            }\n+        };\n+\n+        ScopedValue.where(threadId, -1).run(() -> clv.get(long.class)); \/\/ set up unrelated class\n+        var t1 = Thread.startVirtualThread(() ->\n+                ScopedValue.where(threadId, 1).run(() -> {\n+                    clv.get(int.class);\n+                    t1Returned.countDown(); \/\/ returned after x calls to computeValue\n+                }));\n+        var t2 = Thread.startVirtualThread(() ->\n+                ScopedValue.where(threadId, 2).run(() -> {\n+                    await(removeTamper);\n+                    clv.get(int.class); \/\/ clv version diff from that of promise\n+                }));\n+        await(t1Started);\n+        clv.remove(long.class);\n+        removeTamper.countDown(); \/\/ removed unrelated class\n+        t1.join(TIMEOUT);\n+        t2.join(TIMEOUT);\n+        assertEquals(1, t1Tries.get(), \"Redundant computeValue retries\");\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":81,"deletions":22,"binary":false,"changes":103,"status":"modified"}]}