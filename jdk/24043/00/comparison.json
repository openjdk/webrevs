{"files":[{"patch":"@@ -170,0 +170,31 @@\n+     * @apiNote\n+     * A single call to {@code remove} is not sufficient to prevent ongoing\n+     * computations from installing a stale value later, due to a compatibility\n+     * requirement to make calls from {@code computeValue} to {@code remove} to\n+     * return no-op.  In retrospect, this requirement to accommodate a niche\n+     * case complicated the usages of {@code remove} unfortunately.\n+     * <p>\n+     * Consider threads A and B:\n+     * {@snippet lang=java :\n+     * AtomicInteger input = new AtomicInteger(0);\n+     * ClassValue<Integer> cv = null; \/\/ @replace substring=\"null;\" replacement=\"...\"\n+     * Thread threadA = Thread.startVirtualThread(() -> {\n+     *     input.incrementAndGet(); \/\/ (a)\n+     *     \/\/ Insert a \"cv.get(int.class)\" call here to block stale values\n+     *     cv.remove(int.class); \/\/ (b) - no-op if B is computing\n+     * });\n+     * Thread threadB = Thread.startVirtualThread(() -> cv.get(int.class));\n+     * }\n+     * With this order of action:\n+     * <ol>\n+     * <li>B starts {@code get()} and {@code computeValue()}, but computation is slow\n+     * <li>(a) A updates input value to {@code 1} for {@code computeValue()}\n+     * <li>(b) A calls {@code remove} and returns, no-op as B is computing\n+     * <li>B finishes {@code computeValue()} and installs the outdated value {@code 0}\n+     * <\/ol>\n+     * To prevent observing such an outdated value after the removal, thread A\n+     * can call {@code get()} after it updates input and before it calls {@code\n+     * remove()}, at the location as shown in the snippet.  This way, thread B\n+     * will not be able to installation an outdated value that read input states\n+     * from before thread A's {@code get()}.\n+     *\n@@ -505,10 +536,18 @@\n-            \/\/ e.isPromise(): computeValue already used outdated values.\n-            \/\/ remove(identity) discarded the outdated computation promise.\n-            \/\/ finishEntry will retry when it discovers the promise is removed.\n-            \/\/ No cache invalidation.  No further action needed.\n-            if (e != null && !e.isPromise()) {\n-                \/\/ Initialized.\n-                \/\/ Bump forward to invalidate racy-read cached entries.\n-                classValue.bumpVersion();\n-                \/\/ Make all cache elements for this guy go stale.\n-                removeStaleEntries(classValue);\n+            if (e != null) {\n+                if (e.isPromise()) {\n+                    \/\/ Due to compatibility requirements (7153157), we have to\n+                    \/\/ reinstate an outdated promise that called computeValue\n+                    \/\/ with outdated values because the remove call may come\n+                    \/\/ from computeValue (Why Remi!)\n+                    \/\/ If users wish to avoid seeing outdated promises, they\n+                    \/\/ should call CV.get(clazz) before calling CV.remove(clazz).\n+                    \/\/ They may see a future value in the next get after remove,\n+                    \/\/ but never an outdated value.\n+                    put(classValue.identity, e);\n+                } else {\n+                    \/\/ Initialized.\n+                    \/\/ Bump forward to invalidate racy-read cached entries.\n+                    classValue.bumpVersion();\n+                    \/\/ Make all cache elements for this guy go stale.\n+                    removeStaleEntries(classValue);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +39,1 @@\n+import org.junit.jupiter.api.RepeatedTest;\n@@ -38,0 +41,1 @@\n+import org.junit.jupiter.api.Timeout;\n@@ -164,21 +168,6 @@\n-    @Test\n-    void testRemoveOnComputeCases() {\n-        try (var exec = Executors.newVirtualThreadPerTaskExecutor()) {\n-            var tasks = new ArrayList<Future<?>>(RUNS);\n-            for (int i = 0; i < RUNS; i++) {\n-                tasks.add(exec.submit(this::testRemoveOnCompute));\n-            }\n-            for (var task : tasks) {\n-                try {\n-                    task.get();\n-                } catch (InterruptedException | ExecutionException ex) {\n-                    var cause = ex.getCause();\n-                    if (cause instanceof AssertionError ae)\n-                        throw ae;\n-                    throw new RuntimeException(ex);\n-                }\n-            }\n-        }\n-    }\n-\n-    void testRemoveOnCompute() {\n+    \/**\n+     * Tests that get() + remove() can prevent stale value from being installed.\n+     * Uses junit to do basic stress.\n+     *\/\n+    @RepeatedTest(value = RUNS)\n+    void testRemoveStale() {\n@@ -202,0 +191,1 @@\n+            cv.get(int.class); \/\/ Invalidates ongoing computations using outdated input\n@@ -213,0 +203,18 @@\n+\n+    \/**\n+     * Tests that calling remove() from computeValue() is no-op.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveInCompute() {\n+        ClassValue<Object> cv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                remove(type);\n+                remove(type);\n+                remove(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+        assertEquals(Boolean.TRUE, cv.get(int.class));\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"}]}