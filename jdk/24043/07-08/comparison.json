{"files":[{"patch":"@@ -40,1 +40,1 @@\n- * Lazily associate a computed value with (potentially) every type.\n+ * Lazily associate a computed value with any {@code Class} object.\n@@ -46,4 +46,4 @@\n- * For any some specific pair of {@code ClassValue} and {@code Class}\n- * objects, there is an assignment state for the value accessed by\n- * {@code cv.get(c)}, and the state can be changed by method calls\n- * {@code get} and {@code remove}.\n+ * The basic operation of a {@code ClassValue} is {@link #get get}, which\n+ * returns an associated value, initially created by an invocation to {@link\n+ * #computeValue computeValue}; multiple invocations may happen under race, but\n+ * only one value is ever associated.\n@@ -51,3 +51,3 @@\n- * The {@code get} method assigns it a value if it as not assigned\n- * already, and otherwise returns the previously assigned value.  The\n- * {@code remove} method removes any assigned value.\n+ * Another operation is {@link #remove remove}: it clears an associated value,\n+ * and ensures subsequent associated values are computed with input states\n+ * up-to-date with the removal.\n@@ -55,38 +55,14 @@\n- * For any specific pair of {@code ClassValue} and {@code Class}\n- * objects, all state changes are serialized in a simple linear order,\n- * within the Java Memory Model.  The initial assignment state, and\n- * the state after a {@code remove} call, is unassigned.  A call to\n- * {@code get} on an assigned state returns the assigned value.\n- * Thus, consecutive calls to {@code get} will return the same\n- * value, until the next {@code remove}.\n- * <p>\n- * If a call to {@code get} occurs on an unassigned state, the {@code\n- * computeValue} method is invoked.  If {@code computeValue} returns a\n- * value normally, that value is the new assignment state.  If {@code\n- * computeValue} throws an exception, an {@code Error} or {@code\n- * RuntimeException} is thrown, either the thrown exception itself, or\n- * an {@code Error} wrapping that exception as a cause.  If {@code\n- * computeValue} make a recursive call to {@code get} (on the same\n- * {@code Class}), a {@code StackOverflowError} is thrown.\n- * <p>\n- * If two or more racing calls are made to {@code get} on an\n- * unassigned state, {@code computeValue} may be invoked on any or all\n- * of them.  If one of those {@code computeValue} invocations returns\n- * or throws, the {@code ClassValue} chooses the corresponding {@code\n- * get} call to be the first in the linear order.  If the chosen\n- * {@code computeValue} call returned normally, that value is\n- * assigned, and other racing {@code computeValue} results will\n- * be discarded when those invocations return or throw.  If the chosen\n- * {@code computeValue} throws, that exception is thrown to the thread\n- * making the {@code get} call, the binding state remains unbound, and\n- * the remaining threads (if any) race to produce the bound value.\n- * If all {@code computeValue} invocations throw, the value is not\n- * bound after all.\n- * <p>\n- * Any {@code remove} call is given a place among a matching sequence\n- * of {@code get} calls.  If a {@code remove} call is made recursively\n- * during a {@code computeValue} call (on the same pair of operands),\n- * it is regarded as having taken effect already (since the {@code\n- * get} in process must have been triggered by a missing assignment).\n- * In other words, a recursive call to {@code remove} from {@code\n- * computeValue} has no effect at all.\n+ * For a particular association, there is a total order for accesses to the\n+ * associated value.  Accesses are atomic; they include:\n+ * <ul>\n+ * <li>A read-only access by {@code get}<\/li>\n+ * <li>An attempt to associate the return value of a {@code computeValue} by\n+ * {@code get}<\/li>\n+ * <li>Clearing of an association by {@code remove}<\/li>\n+ * <\/ul>\n+ * A {@code get} call always include at least one access; a {@code remove} call\n+ * always has exactly one access; a {@code computeValue} call always happens\n+ * between two accesses.  This establishes the order of {@code computeValue}\n+ * calls with respect to {@code remove} calls and determines whether the\n+ * results of a {@code computeValue} can be successfully associated by a {@code\n+ * get}.\n@@ -94,1 +70,1 @@\n- * @param <T> the type of the derived value\n+ * @param <T> the type of the associated value\n@@ -107,1 +83,1 @@\n-     * Computes the given class's derived value for this {@code ClassValue}.\n+     * Computes the value to associate to the given {@code Class}.\n@@ -109,2 +85,2 @@\n-     * This method will be invoked within the first thread that accesses\n-     * the value with the {@link #get get} method.\n+     * This method is invoked when an initial read-only access by {@link #get\n+     * get} failed to find this association.\n@@ -112,3 +88,4 @@\n-     * Normally, this method is invoked at most once per class,\n-     * but it may be invoked again if there has been a call to\n-     * {@link #remove remove}.\n+     * If this method throws an exception, the initiating {@code get} call will\n+     * not attempt to associate a value, and may terminate either by returning\n+     * an observed associated value, if it exists, or by propagating that\n+     * exception.\n@@ -116,2 +93,22 @@\n-     * If this method throws an exception, the corresponding call to {@code get}\n-     * will terminate abnormally with that exception, and no class value will be recorded.\n+     * Otherwise, the value is computed and returned.  An attempt to install the\n+     * value happens, which can end up observing:\n+     * <ul>\n+     * <li>This association is already associated by another attempt. The\n+     * associated value is returned.<\/li>\n+     * <li>The most recent {@link #remove remove} call, if it exists, does not\n+     * happen-before (JLS {@jls 17.4.5}) the finish of the {@code computeValue}\n+     * that computed the value for this attempt.  A retry attempt, which that\n+     * {@code remove} call happens-before, happens to re-establish this\n+     * happens-before relationship.<\/li>\n+     * <li>Otherwise, this attempt successfully associates this value, and\n+     * returns the newly associated value.<\/li>\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * A {@code computeValue} call may, due to class loading or other\n+     * circumstances, recursively call {@code get} or {@code remove} for the\n+     * same association.  The recursive {@code get}, if the recursion stops,\n+     * successfully finishes and this initiating {@code get} observes the\n+     * associated value from recursion.  The recursive {@code remove} is no-op,\n+     * since being on the same thread, the {@code remove} already happens-before\n+     * the finish of this {@code computeValue}.\n@@ -119,2 +116,2 @@\n-     * @param type the type whose class value must be computed\n-     * @return the newly computed value associated with this {@code ClassValue}, for the given class or interface\n+     * @param type the {@code Class} to associate a value to\n+     * @return the newly computed value to associate\n@@ -127,3 +124,1 @@\n-     * Returns the value for the given class.\n-     * If no value has yet been computed, it is obtained by\n-     * an invocation of the {@link #computeValue computeValue} method.\n+     * {@return the value associated to the given {@code Class}}\n@@ -131,5 +126,4 @@\n-     * The actual installation of the value on the class\n-     * is performed atomically.\n-     * At that point, if several racing threads have\n-     * computed values, one is chosen, and returned to\n-     * all the racing threads.\n+     * This method first performs a read-only access, and returns the associated\n+     * value if it exists.  Otherwise, this method tries to associate a value\n+     * from a {@link #computeValue computeValue} invocation until a value is\n+     * successfully associated.\n@@ -137,8 +131,2 @@\n-     * The {@code type} parameter is typically a class, but it may be any type,\n-     * such as an interface, a primitive type (like {@code int.class}), or {@code void.class}.\n-     * <p>\n-     * In the absence of {@code remove} calls, a class value has a simple\n-     * state diagram:  uninitialized and initialized.\n-     * When {@code remove} calls are made,\n-     * the rules for value observation are more complex.\n-     * See the documentation for {@link #remove remove} for more information.\n+     * This method may throw an exception from a {@code computeValue} invocation.\n+     * In this case, no value is associated.\n@@ -146,3 +134,2 @@\n-     * @param type the type whose class value must be computed or retrieved\n-     * @return the current value associated with this {@code ClassValue}, for the given class or interface\n-     * @throws NullPointerException if the argument is null\n+     * @param type the {@code Class} to retrieve the associated value for\n+     * @throws NullPointerException if the argument is {@code null}\n@@ -172,18 +159,4 @@\n-     * Removes the associated value for the given class.\n-     * If this value is subsequently {@linkplain #get read} for the same class,\n-     * its value will be reinitialized by invoking its {@link #computeValue computeValue} method.\n-     * This may result in an additional invocation of the\n-     * {@code computeValue} method for the given class.\n-     * <p>\n-     * For a particular association, a {@code remove} call happens-before (JLS\n-     * {@jls 17.4.5}) any subsequent {@code get}, including any contingent {@code\n-     * computeValue} invocation that computed the associated value.  Naturally,\n-     * any {@code computeValue} that began before the {@code remove} call must\n-     * have its result discarded, because the removal must happen-before the\n-     * computation of the associated value.  The {@code get} call that invoked\n-     * the stale {@code computeValue} may retry to re-establish this\n-     * happens-before relationship.\n-     * <p>\n-     * If this is invoked through {@code computeValue}, which can happen due to\n-     * side effects like class initialization, this will be no-op to the caller\n-     * thread.\n+     * Removes the associated value for the given {@code Class}.  If this\n+     * association is subsequently {@linkplain #get accessed}, this removal\n+     * happens-before (JLS {@jls 17.4.5}) the finish of the {@link #computeValue\n+     * computeValue} call that returned the associated value.\n@@ -192,1 +165,1 @@\n-     * @throws NullPointerException if the argument is null\n+     * @throws NullPointerException if the argument is {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":68,"deletions":95,"binary":false,"changes":163,"status":"modified"}]}