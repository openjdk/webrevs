{"files":[{"patch":"@@ -38,1 +38,1 @@\n- * Lazily associate a computed value with (potentially) every type.\n+ * Lazily associate a computed value with any {@code Class} object.\n@@ -43,1 +43,26 @@\n- * @param <T> the type of the derived value\n+ * <p>\n+ * The basic operation of a {@code ClassValue} is {@link #get get}, which\n+ * returns the associated value, initially created by an invocation to {@link\n+ * #computeValue computeValue}; multiple invocations may happen under race, but\n+ * exactly one value is associated to a {@code Class} and returned.\n+ * <p>\n+ * Another operation is {@link #remove remove}: it clears the associated value\n+ * (if it exists), and ensures the next associated value is computed with input\n+ * states up-to-date with the removal.\n+ * <p>\n+ * For a particular association, there is a total order for accesses to the\n+ * associated value.  Accesses are atomic; they include:\n+ * <ul>\n+ * <li>A read-only access by {@code get}<\/li>\n+ * <li>An attempt to associate the return value of a {@code computeValue} by\n+ * {@code get}<\/li>\n+ * <li>Clearing of an association by {@code remove}<\/li>\n+ * <\/ul>\n+ * A {@code get} call always include at least one access; a {@code remove} call\n+ * always has exactly one access; a {@code computeValue} call always happens\n+ * between two accesses.  This establishes the order of {@code computeValue}\n+ * calls with respect to {@code remove} calls and determines whether the\n+ * results of a {@code computeValue} can be successfully associated by a {@code\n+ * get}.\n+ *\n+ * @param <T> the type of the associated value\n@@ -56,1 +81,1 @@\n-     * Computes the given class's derived value for this {@code ClassValue}.\n+     * Computes the value to associate to the given {@code Class}.\n@@ -58,2 +83,2 @@\n-     * This method will be invoked within the first thread that accesses\n-     * the value with the {@link #get get} method.\n+     * This method is invoked when the initial read-only access by {@link #get\n+     * get} finds no associated value.\n@@ -61,3 +86,3 @@\n-     * Normally, this method is invoked at most once per class,\n-     * but it may be invoked again if there has been a call to\n-     * {@link #remove remove}.\n+     * If this method throws an exception, the initiating {@code get} call will\n+     * not attempt to associate a value, and may terminate by returning the\n+     * associated value if it exists, or by propagating that exception otherwise.\n@@ -65,2 +90,12 @@\n-     * If this method throws an exception, the corresponding call to {@code get}\n-     * will terminate abnormally with that exception, and no class value will be recorded.\n+     * Otherwise, the value is computed and returned.  An attempt to associate\n+     * the return value happens, with one of the following outcomes:\n+     * <ul>\n+     * <li>The associated value is present; it is returned and no association\n+     * is done.<\/li>\n+     * <li>The most recent {@link #remove remove} call, if it exists, does not\n+     * happen-before (JLS {@jls 17.4.5}) the finish of the {@code computeValue}\n+     * that computed the value to associate.  A new invocation to {@code\n+     * computeValue}, which that {@code remove} call happens-before, happens to\n+     * re-establish this happens-before relationship.<\/li>\n+     * <li>Otherwise, this value is successfully associated and returned.<\/li>\n+     * <\/ul>\n@@ -68,2 +103,12 @@\n-     * @param type the type whose class value must be computed\n-     * @return the newly computed value associated with this {@code ClassValue}, for the given class or interface\n+     * @apiNote\n+     * A {@code computeValue} call may, due to class loading or other\n+     * circumstances, recursively call {@code get} or {@code remove} for the\n+     * same {@code type}.  The recursive {@code get}, if the recursion stops,\n+     * successfully finishes and this initiating {@code get} observes the\n+     * associated value from recursion.  The recursive {@code remove} is no-op,\n+     * since being on the same thread, the {@code remove} already happens-before\n+     * the finish of this {@code computeValue}; the result from this {@code\n+     * computeValue} still may be associated.\n+     *\n+     * @param type the {@code Class} to associate a value to\n+     * @return the newly computed value to associate\n@@ -76,9 +121,1 @@\n-     * Returns the value for the given class.\n-     * If no value has yet been computed, it is obtained by\n-     * an invocation of the {@link #computeValue computeValue} method.\n-     * <p>\n-     * The actual installation of the value on the class\n-     * is performed atomically.\n-     * At that point, if several racing threads have\n-     * computed values, one is chosen, and returned to\n-     * all the racing threads.\n+     * {@return the value associated to the given {@code Class}}\n@@ -86,2 +123,4 @@\n-     * The {@code type} parameter is typically a class, but it may be any type,\n-     * such as an interface, a primitive type (like {@code int.class}), or {@code void.class}.\n+     * This method first performs a read-only access, and returns the associated\n+     * value if it exists.  Otherwise, this method tries to associate a value\n+     * from a {@link #computeValue computeValue} invocation until the associated\n+     * value exists, which could be associated by a competing thread.\n@@ -89,5 +128,2 @@\n-     * In the absence of {@code remove} calls, a class value has a simple\n-     * state diagram:  uninitialized and initialized.\n-     * When {@code remove} calls are made,\n-     * the rules for value observation are more complex.\n-     * See the documentation for {@link #remove remove} for more information.\n+     * This method may throw an exception from a {@code computeValue} invocation.\n+     * In this case, no association happens.\n@@ -95,3 +131,2 @@\n-     * @param type the type whose class value must be computed or retrieved\n-     * @return the current value associated with this {@code ClassValue}, for the given class or interface\n-     * @throws NullPointerException if the argument is null\n+     * @param type the {@code Class} to retrieve the associated value for\n+     * @throws NullPointerException if the argument is {@code null}\n@@ -111,1 +146,1 @@\n-            return e.value();\n+            return e.value;\n@@ -121,48 +156,5 @@\n-     * Removes the associated value for the given class.\n-     * If this value is subsequently {@linkplain #get read} for the same class,\n-     * its value will be reinitialized by invoking its {@link #computeValue computeValue} method.\n-     * This may result in an additional invocation of the\n-     * {@code computeValue} method for the given class.\n-     * <p>\n-     * In order to explain the interaction between {@code get} and {@code remove} calls,\n-     * we must model the state transitions of a class value to take into account\n-     * the alternation between uninitialized and initialized states.\n-     * To do this, number these states sequentially from zero, and note that\n-     * uninitialized (or removed) states are numbered with even numbers,\n-     * while initialized (or re-initialized) states have odd numbers.\n-     * <p>\n-     * When a thread {@code T} removes a class value in state {@code 2N},\n-     * nothing happens, since the class value is already uninitialized.\n-     * Otherwise, the state is advanced atomically to {@code 2N+1}.\n-     * <p>\n-     * When a thread {@code T} queries a class value in state {@code 2N},\n-     * the thread first attempts to initialize the class value to state {@code 2N+1}\n-     * by invoking {@code computeValue} and installing the resulting value.\n-     * <p>\n-     * When {@code T} attempts to install the newly computed value,\n-     * if the state is still at {@code 2N}, the class value will be initialized\n-     * with the computed value, advancing it to state {@code 2N+1}.\n-     * <p>\n-     * Otherwise, whether the new state is even or odd,\n-     * {@code T} will discard the newly computed value\n-     * and retry the {@code get} operation.\n-     * <p>\n-     * Discarding and retrying is an important proviso,\n-     * since otherwise {@code T} could potentially install\n-     * a disastrously stale value.  For example:\n-     * <ul>\n-     * <li>{@code T} calls {@code CV.get(C)} and sees state {@code 2N}\n-     * <li>{@code T} quickly computes a time-dependent value {@code V0} and gets ready to install it\n-     * <li>{@code T} is hit by an unlucky paging or scheduling event, and goes to sleep for a long time\n-     * <li>...meanwhile, {@code T2} also calls {@code CV.get(C)} and sees state {@code 2N}\n-     * <li>{@code T2} quickly computes a similar time-dependent value {@code V1} and installs it on {@code CV.get(C)}\n-     * <li>{@code T2} (or a third thread) then calls {@code CV.remove(C)}, undoing {@code T2}'s work\n-     * <li> the previous actions of {@code T2} are repeated several times\n-     * <li> also, the relevant computed values change over time: {@code V1}, {@code V2}, ...\n-     * <li>...meanwhile, {@code T} wakes up and attempts to install {@code V0}; <em>this must fail<\/em>\n-     * <\/ul>\n-     * We can assume in the above scenario that {@code CV.computeValue} uses locks to properly\n-     * observe the time-dependent states as it computes {@code V1}, etc.\n-     * This does not remove the threat of a stale value, since there is a window of time\n-     * between the return of {@code computeValue} in {@code T} and the installation\n-     * of the new value.  No user synchronization is possible during this time.\n+     * Removes the associated value for the given {@code Class} and invalidates\n+     * all out-of-date computations.  If this association is subsequently\n+     * {@linkplain #get accessed}, this removal happens-before (JLS {@jls\n+     * 17.4.5}) the finish of the {@link #computeValue computeValue} call that\n+     * returned the associated value.\n@@ -171,1 +163,1 @@\n-     * @throws NullPointerException if the argument is null\n+     * @throws NullPointerException if the argument is {@code null}\n@@ -175,1 +167,1 @@\n-        map.removeEntry(this);\n+        map.removeAccess(this);\n@@ -181,1 +173,1 @@\n-        map.changeEntry(this, value);\n+        map.forcedAssociateAccess(this, value);\n@@ -193,0 +185,1 @@\n+        \/\/ reads non-null due to StoreStore barrier in critical section in initializeMap\n@@ -210,1 +203,1 @@\n-            return e.value();\n+            return e.value;\n@@ -223,4 +216,10 @@\n-        for (;;) {\n-            Entry<T> e = map.startEntry(this);\n-            if (!e.isPromise())\n-                return e.value();\n+        var accessed = map.readAccess(this);\n+        if (accessed instanceof Entry) {\n+            @SuppressWarnings(\"unchecked\")\n+            var cast = (Entry<T>) accessed;\n+            return cast.value;\n+        }\n+\n+        RemovalToken token = (RemovalToken) accessed; \/\/ nullable\n+        for (; ; ) {\n+            T value;\n@@ -228,6 +227,26 @@\n-                \/\/ Try to make a real entry for the promised version.\n-                e = makeEntry(e.version(), computeValue(type));\n-            } finally {\n-                \/\/ Whether computeValue throws or returns normally,\n-                \/\/ be sure to remove the empty entry.\n-                e = map.finishEntry(this, e);\n+                value = computeValue(type);\n+            } catch (Throwable ex) {\n+                \/\/ no value is associated, but there may be already associated\n+                \/\/ value. Return that if it exists.\n+                accessed = map.readAccess(this);\n+                if (accessed instanceof Entry) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    var cast = (Entry<T>) accessed;\n+                    return cast.value;\n+                }\n+                \/\/ report failure here, but allow other callers to try again\n+                if (ex instanceof RuntimeException rte) {\n+                    throw rte;\n+                } else {\n+                    throw ex instanceof Error err ? err : new Error(ex);\n+                }\n+            }\n+            \/\/ computeValue succeed, proceed to associate\n+            accessed = map.associateAccess(this, token, value);\n+            if (accessed instanceof Entry) {\n+                @SuppressWarnings(\"unchecked\")\n+                var cast = (Entry<T>) accessed;\n+                return cast.value;\n+            } else {\n+                token = (RemovalToken) accessed;\n+                \/\/ repeat\n@@ -235,3 +254,0 @@\n-            if (e != null)\n-                return e.value();\n-            \/\/ else try again, in case a racing thread called remove (so e == null)\n@@ -245,1 +261,1 @@\n-        return (e != null && e.get() == this.version);\n+        return (e != null && e.version() == this.version);\n@@ -303,1 +319,1 @@\n-    Version<T> version() { return version; }\n+\n@@ -305,7 +321,32 @@\n-    static class Version<T> {\n-        private final ClassValue<T> classValue;\n-        private final Entry<T> promise = new Entry<>(this);\n-        Version(ClassValue<T> classValue) { this.classValue = classValue; }\n-        ClassValue<T> classValue() { return classValue; }\n-        Entry<T> promise() { return promise; }\n-        boolean isLive() { return classValue.version() == this; }\n+\n+    record Version<T>(\/* Object identity, *\/ClassValue<T> classValue) {\n+        boolean isLive() {\n+            return classValue.version == this;\n+        }\n+    }\n+\n+    \/**\n+     * Besides a value (represented by an Entry), a \"removal token\" object,\n+     * including the value {@code null}, can be present at a ClassValue-Class\n+     * coordinate.  A removal token indicates whether the value from a\n+     * computation is up-to-date; the value is up-to-date if the token is the\n+     * same before and after computation (no removal during this period), or if\n+     * the token is from the same thread (removed during computeValue).\n+     * {@code null} is the initial state, meaning all computations are valid.\n+     * Later tokens are always non-null, no matter if they replace existing\n+     * entries or outdated tokens.\n+     *\/\n+    private static final class RemovalToken {\n+        \/\/ Use thread ID, which presumably don't duplicate and is cheaper than WeakReference\n+        private final long actorId;\n+\n+        private RemovalToken() {\n+            this.actorId = Thread.currentThread().threadId();\n+        }\n+\n+        \/\/ Arguments are intentionally nullable, to allow initial tokens\n+        static boolean areCompatible(RemovalToken current, RemovalToken original) {\n+            \/\/ No removal token after the initial can be null\n+            assert current != null || original == null : current + \" : \" + original;\n+            return current == original || current.actorId == Thread.currentThread().threadId();\n+        }\n@@ -315,0 +356,3 @@\n+     *  Shared for the map and the cache array.\n+     *  The version is only meaningful for the cache array; whatever in the map\n+     *  is authentic, but state informs the cache an entry may be out-of-date.\n@@ -316,3 +360,2 @@\n-     *  <li> promise if value == Entry.this\n-     *  <li> else dead if version == null\n-     *  <li> else stale if version != classValue.version\n+     *  <li> dead if version == null\n+     *  <li> stale if version != classValue.version\n@@ -320,2 +363,0 @@\n-     *  Promises are never put into the cache; they only live in the\n-     *  backing map while a computeValue call is in flight.\n@@ -325,2 +366,4 @@\n-    static class Entry<T> extends WeakReference<Version<T>> {\n-        final Object value;  \/\/ usually of type T, but sometimes (Entry)this\n+    static final class Entry<T> {\n+        final T value;\n+        final WeakReference<Version<T>> version; \/\/ The version exists only for cache invalidation\n+\n@@ -328,8 +371,2 @@\n-            super(version);\n-            this.value = value;  \/\/ for a regular entry, value is of type T\n-        }\n-        private void assertNotPromise() { assert(!isPromise()); }\n-        \/** For creating a promise. *\/\n-        Entry(Version<T> version) {\n-            super(version);\n-            this.value = this;  \/\/ for a promise, value is not of type T, but Entry!\n+            this.value = value;\n+            this.version = new WeakReference<>(version);\n@@ -337,5 +374,2 @@\n-        \/** Fetch the value.  This entry must not be a promise. *\/\n-        @SuppressWarnings(\"unchecked\")  \/\/ if !isPromise, type is T\n-        T value() { assertNotPromise(); return (T) value; }\n-        boolean isPromise() { return value == this; }\n-        Version<T> version() { return get(); }\n+\n+        Version<T> version() { return version.get(); }\n@@ -349,2 +383,2 @@\n-            if (v.isLive())  return true;\n-            clear();\n+            if (v.isLive()) return true;\n+            version.clear();\n@@ -354,6 +388,1 @@\n-            assertNotPromise();\n-            @SuppressWarnings(\"unchecked\")  \/\/ if !isPromise, type is T\n-            Entry<T> e2 = new Entry<>(v2, (T) value);\n-            clear();\n-            \/\/ value = null -- caller must drop\n-            return e2;\n+            return version.refersTo(v2) ? this : new Entry<>(v2, value);\n@@ -382,5 +411,6 @@\n-                \/\/ Place a Store fence after construction and before publishing to emulate\n-                \/\/ ClassValueMap containing final fields. This ensures it can be\n-                \/\/ published safely in the non-volatile field Class.classValueMap,\n-                \/\/ since stores to the fields of ClassValueMap will not be reordered\n-                \/\/ to occur after the store to the field type.classValueMap\n+                \/\/ getCacheCarefully anticipates entry array to be non-null when\n+                \/\/ a ClassValueMap is published to it.  However, ClassValueMap\n+                \/\/ has no final field, so compiler does not emit a fence, and\n+                \/\/ we must manually issue a Store-Store barrier to prevent\n+                \/\/ the assignment below to be reordered with the store to\n+                \/\/ entry array in the constructor above\n@@ -415,0 +445,1 @@\n+     *  The state may be assigned value or unassigned token.\n@@ -417,1 +448,1 @@\n-    static class ClassValueMap extends WeakHashMap<ClassValue.Identity, Entry<?>> {\n+    static final class ClassValueMap extends WeakHashMap<ClassValue.Identity, Object> {\n@@ -436,28 +467,11 @@\n-        \/** Initiate a query.  Store a promise (placeholder) if there is no value yet. *\/\n-        synchronized\n-        <T> Entry<T> startEntry(ClassValue<T> classValue) {\n-            @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all value types <T>\n-            Entry<T> e = (Entry<T>) get(classValue.identity);\n-            Version<T> v = classValue.version();\n-            if (e == null) {\n-                e = v.promise();\n-                \/\/ The presence of a promise means that a value is pending for v.\n-                \/\/ Eventually, finishEntry will overwrite the promise.\n-                put(classValue.identity, e);\n-                \/\/ Note that the promise is never entered into the cache!\n-                return e;\n-            } else if (e.isPromise()) {\n-                \/\/ Somebody else has asked the same question.\n-                \/\/ Let the races begin!\n-                if (e.version() != v) {\n-                    e = v.promise();\n-                    put(classValue.identity, e);\n-                }\n-                return e;\n-            } else {\n-                \/\/ there is already a completed entry here; report it\n-                if (e.version() != v) {\n-                    \/\/ There is a stale but valid entry here; make it fresh again.\n-                    \/\/ Once an entry is in the hash table, we don't care what its version is.\n-                    e = e.refreshVersion(v);\n-                    put(classValue.identity, e);\n+        \/\/ A simple read access to this map, for the initial step of get or failure recovery.\n+        \/\/ This may refresh the entry for the cache, but the associated value always stays the same.\n+        synchronized <T> Object readAccess(ClassValue<T> classValue) {\n+            var item = get(classValue.identity);\n+            if (item instanceof Entry) {\n+                @SuppressWarnings(\"unchecked\")\n+                var entry = (Entry<T>) item;\n+                \/\/ cache refresh\n+                var updated = entry.refreshVersion(classValue.version);\n+                if (updated != entry) {\n+                    put(classValue.identity, updated);\n@@ -465,4 +479,0 @@\n-                \/\/ Add to the cache, to enable the fast path, next time.\n-                checkCacheLoad();\n-                addToCache(classValue, e);\n-                return e;\n@@ -470,0 +480,1 @@\n+            return item;\n@@ -472,17 +483,9 @@\n-        \/** Finish a query.  Overwrite a matching placeholder.  Drop stale incoming values. *\/\n-        synchronized\n-        <T> Entry<T> finishEntry(ClassValue<T> classValue, Entry<T> e) {\n-            @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all value types <T>\n-            Entry<T> e0 = (Entry<T>) get(classValue.identity);\n-            if (e == e0) {\n-                \/\/ We can get here during exception processing, unwinding from computeValue.\n-                assert(e.isPromise());\n-                remove(classValue.identity);\n-                return null;\n-            } else if (e0 != null && e0.isPromise() && e0.version() == e.version()) {\n-                \/\/ If e0 matches the intended entry, there has not been a remove call\n-                \/\/ between the previous startEntry and now.  So now overwrite e0.\n-                Version<T> v = classValue.version();\n-                if (e.version() != v)\n-                    e = e.refreshVersion(v);\n-                put(classValue.identity, e);\n+        \/\/ An association attempt, for when a computeValue returns a value.\n+        synchronized <T> Object associateAccess(ClassValue<T> classValue, RemovalToken startToken, T value) {\n+            var item = readAccess(classValue);\n+            if (item instanceof Entry)\n+                return item; \/\/ value already associated\n+            var currentToken = (RemovalToken) item;\n+            if (RemovalToken.areCompatible(currentToken, startToken)) {\n+                var entry = makeEntry(classValue.version, value);\n+                put(classValue.identity, entry);\n@@ -491,5 +494,2 @@\n-                addToCache(classValue, e);\n-                return e;\n-            } else {\n-                \/\/ Some sort of mismatch; caller must try again.\n-                return null;\n+                addToCache(classValue, entry);\n+                return entry;\n@@ -497,0 +497,1 @@\n+            return currentToken;\n@@ -499,17 +500,6 @@\n-        \/** Remove an entry. *\/\n-        synchronized\n-        void removeEntry(ClassValue<?> classValue) {\n-            Entry<?> e = remove(classValue.identity);\n-            \/\/ e == null: Uninitialized, and no pending calls to computeValue.\n-            \/\/ remove(identity) didn't change anything.  No change.\n-            \/\/ e.isPromise(): computeValue already used outdated values.\n-            \/\/ remove(identity) discarded the outdated computation promise.\n-            \/\/ finishEntry will retry when it discovers the promise is removed.\n-            \/\/ No cache invalidation.  No further action needed.\n-            if (e != null && !e.isPromise()) {\n-                \/\/ Initialized.\n-                \/\/ Bump forward to invalidate racy-read cached entries.\n-                classValue.bumpVersion();\n-                \/\/ Make all cache elements for this guy go stale.\n-                removeStaleEntries(classValue);\n-            }\n+        \/\/ A removal, requiring subsequent associations to be up-to-date with it.\n+        synchronized void removeAccess(ClassValue<?> classValue) {\n+            \/\/ Always put in a token to invalidate ongoing computations\n+            put(classValue.identity, new RemovalToken());\n+            classValue.bumpVersion();\n+            removeStaleEntries(classValue);\n@@ -518,15 +508,6 @@\n-        \/** Change the value for an entry. *\/\n-        synchronized\n-        <T> void changeEntry(ClassValue<T> classValue, T value) {\n-            @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all value types <T>\n-            Entry<T> e0 = (Entry<T>) get(classValue.identity);\n-            Version<T> version = classValue.version();\n-            if (e0 != null) {\n-                if (e0.version() == version && e0.value() == value)\n-                    \/\/ no value change => no version change needed\n-                    return;\n-                classValue.bumpVersion();\n-                removeStaleEntries(classValue);\n-            }\n-            Entry<T> e = makeEntry(version, value);\n-            put(classValue.identity, e);\n+        \/\/ A forced association, requires cache to flush.\n+        synchronized <T> void forcedAssociateAccess(ClassValue<T> classValue, T value) {\n+            classValue.bumpVersion();\n+            removeStaleEntries();\n+            var entry = makeEntry(classValue.version, value);\n+            put(classValue.identity, entry);\n@@ -535,1 +516,1 @@\n-            addToCache(classValue, e);\n+            addToCache(classValue, entry);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":208,"deletions":227,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -26,1 +26,3 @@\n- * @bug 8351045\n+ * @bug 8351045 8351996\n+ * @enablePreview\n+ * @comment Remove preview if ScopedValue is finalized\n@@ -28,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -31,0 +34,6 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.ref.WeakReference;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n@@ -32,3 +41,6 @@\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n@@ -36,0 +48,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -37,0 +50,3 @@\n+import jdk.test.lib.util.ForceGC;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.RepeatedTest;\n@@ -38,0 +54,1 @@\n+import org.junit.jupiter.api.Timeout;\n@@ -39,1 +56,1 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -161,1 +178,0 @@\n-    private static final int RUNS = 16;\n@@ -163,0 +179,1 @@\n+    private static final Duration TIMEOUT = Duration.of(2, ChronoUnit.SECONDS);\n@@ -164,6 +181,4 @@\n-    @Test\n-    void testRemoveOnComputeCases() {\n-        try (var exec = Executors.newVirtualThreadPerTaskExecutor()) {\n-            var tasks = new ArrayList<Future<?>>(RUNS);\n-            for (int i = 0; i < RUNS; i++) {\n-                tasks.add(exec.submit(this::testRemoveOnCompute));\n+    private static void await(CountDownLatch latch) {\n+        try {\n+            if (!latch.await(2L, TimeUnit.SECONDS)) {\n+                fail(\"No signal received\");\n@@ -171,8 +186,14 @@\n-            for (var task : tasks) {\n-                try {\n-                    task.get();\n-                } catch (InterruptedException | ExecutionException ex) {\n-                    var cause = ex.getCause();\n-                    if (cause instanceof AssertionError ae)\n-                        throw ae;\n-                    throw new RuntimeException(ex);\n+        } catch (InterruptedException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    private static void awaitThreads(Thread... threads) {\n+        awaitThreads(Arrays.asList(threads));\n+    }\n+\n+    private static void awaitThreads(Iterable<Thread> threads) {\n+        for (var t : threads) {\n+            try {\n+                if (!t.join(TIMEOUT)) {\n+                    fail(\"Thread not stopping \" + t);\n@@ -180,0 +201,2 @@\n+            } catch (InterruptedException ex) {\n+                fail(ex);\n@@ -184,1 +207,9 @@\n-    void testRemoveOnCompute() {\n+    \/**\n+     * Tests that get() + remove() can prevent stale value from being installed.\n+     * Uses junit to do basic stress.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveStale() throws InterruptedException {\n+        CountDownLatch oldInputUsed = new CountDownLatch(1);\n+        CountDownLatch inputUpdated = new CountDownLatch(1);\n@@ -191,5 +222,3 @@\n-                try {\n-                    Thread.sleep(COMPUTE_TIME_MILLIS);\n-                } catch (InterruptedException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+                oldInputUsed.countDown();\n+                \/\/ ensure input is updated when we return\n+                await(inputUpdated);\n@@ -201,0 +230,1 @@\n+            await(oldInputUsed);\n@@ -203,0 +233,1 @@\n+            inputUpdated.countDown();\n@@ -204,6 +235,1 @@\n-        try {\n-            innocuous.join();\n-            refreshInput.join();\n-        } catch (InterruptedException ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        awaitThreads(innocuous, refreshInput);\n@@ -213,0 +239,243 @@\n+\n+    \/**\n+     * Tests that calling get() from computeValue() terminates.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testGetInCompute() {\n+        ClassValue<Object> cv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                get(type);\n+                get(type);\n+                get(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+        try {\n+            cv.get(int.class);\n+        } catch (Throwable ex) {\n+            \/\/ swallow if any\n+        }\n+    }\n+\n+    \/**\n+     * Tests that calling remove() from computeValue() terminates.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveInCompute() {\n+        ClassValue<Boolean> cv = new ClassValue<>() {\n+            @Override\n+            protected Boolean computeValue(Class<?> type) {\n+                remove(type);\n+                remove(type);\n+                remove(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+        assertTrue(cv.get(int.class));\n+    }\n+\n+    private static Class<?> createWeakClass() {\n+        var bytes = ClassFile.of().build(ClassDesc.of(\"WeakTest\"), _ -> {});\n+        try {\n+            return MethodHandles.lookup().defineHiddenClass(bytes, true).lookupClass();\n+        } catch (IllegalAccessException ex) {\n+            return fail(ex);\n+        }\n+    }\n+\n+    @Test\n+    void testWeakAgainstClass() {\n+        Class<?> hidden = createWeakClass();\n+        ClassValue<int[]> cv = new ClassValue<>() {\n+            @Override\n+            protected int[] computeValue(Class<?> type) {\n+                return new int[23];\n+            }\n+        };\n+\n+        WeakReference<?> ref = new WeakReference<>(cv.get(hidden));\n+        hidden = null; \/\/ Remove reference for interpreter\n+        if (!ForceGC.wait(() -> ref.refersTo(null))) {\n+            fail(\"Timeout\");\n+        }\n+    }\n+\n+    @Test\n+    @Disabled \/\/ JDK-8352622\n+    void testWeakAgainstClassValue() {\n+        ClassValue<int[]> cv = new ClassValue<>() {\n+            @Override\n+            protected int[] computeValue(Class<?> type) {\n+                return new int[23];\n+            }\n+        };\n+\n+        WeakReference<?> ref = new WeakReference<>(cv.get(int.class));\n+        cv = null; \/\/ Remove reference for interpreter\n+        if (!ForceGC.wait(() -> ref.refersTo(null))) {\n+            fail(\"Timeout\");\n+        }\n+    }\n+\n+    @Test\n+    void testSingletonWinner() {\n+        CountDownLatch raceStart = new CountDownLatch(1);\n+        ClassValue<int[]> cv = new ClassValue<>() {\n+            @Override\n+            protected int[] computeValue(Class<?> type) {\n+                await(raceStart);\n+                return new int[] {ThreadLocalRandom.current().nextInt()};\n+            }\n+        };\n+        AtomicReference<int[]> truth = new AtomicReference<>(null);\n+        AtomicInteger truthSwapCount = new AtomicInteger(0);\n+\n+        List<Thread> threads = new ArrayList<>(100);\n+        Runnable job = () -> {\n+            var res = cv.get(ClassValueTest.class);\n+            var item = truth.compareAndExchange(null, res);\n+            if (item != null) {\n+                assertSame(item, res);\n+            } else {\n+                truthSwapCount.incrementAndGet();\n+            }\n+        };\n+        for (int i = 0; i < 100; i++) {\n+            threads.add(Thread.startVirtualThread(job));\n+        }\n+        raceStart.countDown();\n+        awaitThreads(threads);\n+        assertEquals(1, truthSwapCount.get());\n+    }\n+\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRacyRemoveInCompute() {\n+        ClassValue<Object> cv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                remove(type);\n+                try {\n+                    Thread.sleep(COMPUTE_TIME_MILLIS);\n+                } catch (InterruptedException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+                remove(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+\n+        var threads = Arrays.stream(CLASSES)\n+                .map(clz -> Thread.startVirtualThread(() -> cv.get(clz)))\n+                .toList();\n+        awaitThreads(threads);\n+    }\n+\n+    @Test\n+    void testRecursiveInitialization() {\n+        record Holder() {\n+            static final ClassValue<Object> clv = new ClassValue<>() {\n+                @Override\n+                protected Object computeValue(Class<?> type) {\n+                    return new One();\n+                }\n+            };\n+\n+            record One() {\n+                static {\n+                    Holder.clv.get(One.class);\n+                }\n+            }\n+\n+        }\n+\n+        Holder.clv.get(Holder.One.class);\n+    }\n+\n+    private static final ScopedValue<Integer> THREAD_ID = ScopedValue.newInstance();\n+\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testNoRecomputeOnUnrelatedRemoval() throws InterruptedException {\n+        CountDownLatch t1Started = new CountDownLatch(1);\n+        CountDownLatch removeTamper = new CountDownLatch(1);\n+        CountDownLatch t2Started = new CountDownLatch(1);\n+        CountDownLatch t1Returned = new CountDownLatch(1);\n+        AtomicInteger t1Tries = new AtomicInteger();\n+        ClassValue<Object> clv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                int id = THREAD_ID.get();\n+                if (id == 1) {\n+                    t1Tries.incrementAndGet();\n+                    t1Started.countDown();\n+                    await(t2Started); \/\/ implies unrelated changes\n+                } else if (id == 2) {\n+                    t2Started.countDown();\n+                    \/\/ Don't race to install - we want to check computeValue tampers\n+                    await(t1Returned);\n+                } else if (id != -1) {\n+                    fail(\"Id: \" + id);\n+                }\n+                return \"\";\n+            }\n+        };\n+\n+        ScopedValue.where(THREAD_ID, -1).run(() -> clv.get(long.class)); \/\/ set up unrelated class\n+        var t1 = Thread.startVirtualThread(() ->\n+                ScopedValue.where(THREAD_ID, 1).run(() -> {\n+                    clv.get(int.class);\n+                    t1Returned.countDown(); \/\/ returned after x calls to computeValue\n+                }));\n+        var t2 = Thread.startVirtualThread(() ->\n+                ScopedValue.where(THREAD_ID, 2).run(() -> {\n+                    await(removeTamper);\n+                    clv.get(int.class); \/\/ clv version diff from that of promise\n+                }));\n+        await(t1Started);\n+        clv.remove(long.class);\n+        removeTamper.countDown(); \/\/ removed unrelated class\n+        awaitThreads(t1, t2);\n+        assertEquals(1, t1Tries.get(), \"Redundant computeValue retries\");\n+    }\n+\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testNoObsoleteInstallation() throws InterruptedException {\n+        CountDownLatch slowComputationStart = new CountDownLatch(1);\n+        CountDownLatch slowComputationContinue = new CountDownLatch(1);\n+        ClassValue<Integer> clv = new ClassValue<>() {\n+            @Override\n+            protected Integer computeValue(Class<?> type) {\n+                if (!THREAD_ID.isBound()) {\n+                    return 5;\n+                }\n+                int threadId = THREAD_ID.get();\n+                if (threadId == 1) {\n+                    if (slowComputationContinue.getCount() == 0) {\n+                        return 42;\n+                    } else {\n+                        \/\/ First invocation\n+                        slowComputationStart.countDown();\n+                        await(slowComputationContinue);\n+                        return -1;\n+                    }\n+                } else {\n+                    return fail(\"Unknown thread \" + threadId);\n+                }\n+            }\n+        };\n+        var t = Thread.startVirtualThread(() -> ScopedValue.where(THREAD_ID, 1).run(() -> {\n+            int v = clv.get(int.class);\n+            assertEquals(42, v, \"recomputed value\");\n+        }));\n+        await(slowComputationStart);\n+        assertEquals(5, clv.get(int.class), \"fast computation installed value\");\n+        clv.remove(int.class);\n+        slowComputationContinue.countDown();\n+        awaitThreads(t);\n+        assertEquals(42, clv.get(int.class), \"slow computation reinstalled value\");\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":301,"deletions":32,"binary":false,"changes":333,"status":"modified"}]}