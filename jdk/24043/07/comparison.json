{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n@@ -43,0 +45,49 @@\n+ * <p>\n+ * For any some specific pair of {@code ClassValue} and {@code Class}\n+ * objects, there is an assignment state for the value accessed by\n+ * {@code cv.get(c)}, and the state can be changed by method calls\n+ * {@code get} and {@code remove}.\n+ * <p>\n+ * The {@code get} method assigns it a value if it as not assigned\n+ * already, and otherwise returns the previously assigned value.  The\n+ * {@code remove} method removes any assigned value.\n+ * <p>\n+ * For any specific pair of {@code ClassValue} and {@code Class}\n+ * objects, all state changes are serialized in a simple linear order,\n+ * within the Java Memory Model.  The initial assignment state, and\n+ * the state after a {@code remove} call, is unassigned.  A call to\n+ * {@code get} on an assigned state returns the assigned value.\n+ * Thus, consecutive calls to {@code get} will return the same\n+ * value, until the next {@code remove}.\n+ * <p>\n+ * If a call to {@code get} occurs on an unassigned state, the {@code\n+ * computeValue} method is invoked.  If {@code computeValue} returns a\n+ * value normally, that value is the new assignment state.  If {@code\n+ * computeValue} throws an exception, an {@code Error} or {@code\n+ * RuntimeException} is thrown, either the thrown exception itself, or\n+ * an {@code Error} wrapping that exception as a cause.  If {@code\n+ * computeValue} make a recursive call to {@code get} (on the same\n+ * {@code Class}), a {@code StackOverflowError} is thrown.\n+ * <p>\n+ * If two or more racing calls are made to {@code get} on an\n+ * unassigned state, {@code computeValue} may be invoked on any or all\n+ * of them.  If one of those {@code computeValue} invocations returns\n+ * or throws, the {@code ClassValue} chooses the corresponding {@code\n+ * get} call to be the first in the linear order.  If the chosen\n+ * {@code computeValue} call returned normally, that value is\n+ * assigned, and other racing {@code computeValue} results will\n+ * be discarded when those invocations return or throw.  If the chosen\n+ * {@code computeValue} throws, that exception is thrown to the thread\n+ * making the {@code get} call, the binding state remains unbound, and\n+ * the remaining threads (if any) race to produce the bound value.\n+ * If all {@code computeValue} invocations throw, the value is not\n+ * bound after all.\n+ * <p>\n+ * Any {@code remove} call is given a place among a matching sequence\n+ * of {@code get} calls.  If a {@code remove} call is made recursively\n+ * during a {@code computeValue} call (on the same pair of operands),\n+ * it is regarded as having taken effect already (since the {@code\n+ * get} in process must have been triggered by a missing assignment).\n+ * In other words, a recursive call to {@code remove} from {@code\n+ * computeValue} has no effect at all.\n+ *\n@@ -127,18 +178,8 @@\n-     * In order to explain the interaction between {@code get} and {@code remove} calls,\n-     * we must model the state transitions of a class value to take into account\n-     * the alternation between uninitialized and initialized states.\n-     * To do this, number these states sequentially from zero, and note that\n-     * uninitialized (or removed) states are numbered with even numbers,\n-     * while initialized (or re-initialized) states have odd numbers.\n-     * <p>\n-     * When a thread {@code T} removes a class value in state {@code 2N},\n-     * nothing happens, since the class value is already uninitialized.\n-     * Otherwise, the state is advanced atomically to {@code 2N+1}.\n-     * <p>\n-     * When a thread {@code T} queries a class value in state {@code 2N},\n-     * the thread first attempts to initialize the class value to state {@code 2N+1}\n-     * by invoking {@code computeValue} and installing the resulting value.\n-     * <p>\n-     * When {@code T} attempts to install the newly computed value,\n-     * if the state is still at {@code 2N}, the class value will be initialized\n-     * with the computed value, advancing it to state {@code 2N+1}.\n+     * For a particular association, a {@code remove} call happens-before (JLS\n+     * {@jls 17.4.5}) any subsequent {@code get}, including any contingent {@code\n+     * computeValue} invocation that computed the associated value.  Naturally,\n+     * any {@code computeValue} that began before the {@code remove} call must\n+     * have its result discarded, because the removal must happen-before the\n+     * computation of the associated value.  The {@code get} call that invoked\n+     * the stale {@code computeValue} may retry to re-establish this\n+     * happens-before relationship.\n@@ -146,23 +187,3 @@\n-     * Otherwise, whether the new state is even or odd,\n-     * {@code T} will discard the newly computed value\n-     * and retry the {@code get} operation.\n-     * <p>\n-     * Discarding and retrying is an important proviso,\n-     * since otherwise {@code T} could potentially install\n-     * a disastrously stale value.  For example:\n-     * <ul>\n-     * <li>{@code T} calls {@code CV.get(C)} and sees state {@code 2N}\n-     * <li>{@code T} quickly computes a time-dependent value {@code V0} and gets ready to install it\n-     * <li>{@code T} is hit by an unlucky paging or scheduling event, and goes to sleep for a long time\n-     * <li>...meanwhile, {@code T2} also calls {@code CV.get(C)} and sees state {@code 2N}\n-     * <li>{@code T2} quickly computes a similar time-dependent value {@code V1} and installs it on {@code CV.get(C)}\n-     * <li>{@code T2} (or a third thread) then calls {@code CV.remove(C)}, undoing {@code T2}'s work\n-     * <li> the previous actions of {@code T2} are repeated several times\n-     * <li> also, the relevant computed values change over time: {@code V1}, {@code V2}, ...\n-     * <li>...meanwhile, {@code T} wakes up and attempts to install {@code V0}; <em>this must fail<\/em>\n-     * <\/ul>\n-     * We can assume in the above scenario that {@code CV.computeValue} uses locks to properly\n-     * observe the time-dependent states as it computes {@code V1}, etc.\n-     * This does not remove the threat of a stale value, since there is a window of time\n-     * between the return of {@code computeValue} in {@code T} and the installation\n-     * of the new value.  No user synchronization is possible during this time.\n+     * If this is invoked through {@code computeValue}, which can happen due to\n+     * side effects like class initialization, this will be no-op to the caller\n+     * thread.\n@@ -223,1 +244,2 @@\n-        for (;;) {\n+        Throwable ex = null;\n+        for (; ; ) {\n@@ -229,0 +251,2 @@\n+                \/\/ e is real if computeValue finishes normally,\n+                \/\/ otherwise it is still the old promise\n@@ -230,0 +254,2 @@\n+            } catch (Throwable problem) {\n+                ex = problem;\n@@ -233,0 +259,1 @@\n+                \/\/\n@@ -235,1 +262,1 @@\n-            if (e != null)\n+            if (e != null)    \/\/ success, either here or in a racing thread\n@@ -237,1 +264,8 @@\n-            \/\/ else try again, in case a racing thread called remove (so e == null)\n+            if (ex == null)   \/\/ a racing thread called remove, so try again\n+                continue;\n+            \/\/ report failure here, but allow other callers to try again\n+            if (ex instanceof RuntimeException rte) {\n+                throw rte;\n+            } else {\n+                throw ex instanceof Error err ? err : new Error(ex);\n+            }\n@@ -307,1 +341,0 @@\n-        private final Entry<T> promise = new Entry<>(this);\n@@ -310,1 +343,1 @@\n-        Entry<T> promise() { return promise; }\n+        Entry<T> createPromise() { return new Entry<>(this); }\n@@ -315,0 +348,3 @@\n+     *  Shared for the map and the cache array.\n+     *  The states are only meaningful for the cache array; whatever in the map\n+     *  is authentic, but state informs the cache an entry may be out-of-date.\n@@ -335,1 +371,1 @@\n-            this.value = this;  \/\/ for a promise, value is not of type T, but Entry!\n+            this.value = new PromiseInfo();  \/\/ for a promise, value is not of type T, but PromiseInfo!\n@@ -340,1 +376,46 @@\n-        boolean isPromise() { return value == this; }\n+\n+        boolean isPromise() { return value instanceof PromiseInfo; }\n+\n+        boolean addPromiseByCurrentThread() {\n+            return ((PromiseInfo) value).addCurrentThread();\n+        }\n+\n+        boolean isPromisedByCurrentThread() {\n+            return ((PromiseInfo) value).containsCurrentThread();\n+        }\n+\n+        \/\/ The content of a promise is a non-empty set of threads working on that promise.\n+        \/\/ Must be accessed in synchronization blocks on the ClassValueMap (otherThreads).\n+        \/\/ Compared to ThreadTracker, this optimizes optimistically for\n+        \/\/ single-thread accessors and uses plain instead of concurrent data structures.\n+        static final class PromiseInfo {\n+            private final Thread initialThread;\n+            private Map<Thread, Object> otherThreads; \/\/ Must be identity\/thread ID-based\n+\n+            PromiseInfo() {\n+                initialThread = Thread.currentThread();\n+            }\n+\n+            boolean addCurrentThread() {\n+                Thread t = Thread.currentThread();\n+                if (initialThread == t) {\n+                    return false;\n+                }\n+\n+                var others = this.otherThreads;\n+                if (others == null) {\n+                    others = new IdentityHashMap<>();\n+                    this.otherThreads = others;\n+                }\n+                return others.put(t, int.class) == null;\n+            }\n+\n+            boolean containsCurrentThread() {\n+                Thread t = Thread.currentThread();\n+                if (initialThread == t)\n+                    return true;\n+                var map = otherThreads;\n+                return map != null && map.containsKey(t);\n+            }\n+        }\n+\n@@ -443,1 +524,1 @@\n-                e = v.promise();\n+                e = v.createPromise();\n@@ -452,4 +533,11 @@\n-                if (e.version() != v) {\n-                    e = v.promise();\n-                    put(classValue.identity, e);\n-                }\n+                \/\/\n+                \/\/ Anything in the map is authentic - even if this promise may\n+                \/\/ appear \"outdated\" by version, if it is truly outdated, it\n+                \/\/ would have been removed or replaced from the map.\n+                \/\/\n+                \/\/ Keep track of which threads observe this particular promise.\n+                \/\/ All of them are equally racing to fulfill the promise.\n+                e.addPromiseByCurrentThread();\n+                \/\/ Let the VM throw StackOverflowError: sometimes, a\n+                \/\/ computeValue can trigger class initialization, which\n+                \/\/ itself triggers another computeValue.\n@@ -480,0 +568,1 @@\n+                \/\/ Other threads can retry if successful or just propagate their exceptions.\n@@ -482,1 +571,5 @@\n-            } else if (e0 != null && e0.isPromise() && e0.version() == e.version()) {\n+            } else if (e0 != null && e0.isPromise()) {\n+                if (e0.version() != e.version() || !e0.isPromisedByCurrentThread()) {\n+                    \/\/ e0 is created after e, whether e failed (promise) or succeeded\n+                    return null;  \/\/ caller must try again\n+                }\n@@ -486,1 +579,1 @@\n-                if (e.version() != v)\n+                if (e.version() != v)  \/\/ removal in unrelated associations\n@@ -494,2 +587,5 @@\n-                \/\/ Some sort of mismatch; caller must try again.\n-                return null;\n+                \/\/ Some sort of mismatch; caller must try again if e0=null.\n+                \/\/ This can happen when:\n+                \/\/ 1. Another thread computes and finishes exceptionally.\n+                \/\/ 2. A remove() is issued after computation started.\n+                return e0;\n@@ -505,10 +601,15 @@\n-            \/\/ e.isPromise(): computeValue already used outdated values.\n-            \/\/ remove(identity) discarded the outdated computation promise.\n-            \/\/ finishEntry will retry when it discovers the promise is removed.\n-            \/\/ No cache invalidation.  No further action needed.\n-            if (e != null && !e.isPromise()) {\n-                \/\/ Initialized.\n-                \/\/ Bump forward to invalidate racy-read cached entries.\n-                classValue.bumpVersion();\n-                \/\/ Make all cache elements for this guy go stale.\n-                removeStaleEntries(classValue);\n+            if (e != null) {\n+                if (e.isPromise()) {\n+                    \/\/ Remove the outdated promise to force recomputation.\n+                    if (e.isPromisedByCurrentThread()) {\n+                        \/\/ Notify myself that I am still up-to-date. All other racers are stale.\n+                        \/\/ That is, the fresh promise contains only this thread as promiser.\n+                        put(classValue.identity, classValue.version().createPromise());\n+                    }\n+                } else {\n+                    \/\/ Initialized.\n+                    \/\/ Bump forward to invalidate racy-read cached entries.\n+                    classValue.bumpVersion();\n+                    \/\/ Make all cache elements for this guy go stale.\n+                    removeStaleEntries(classValue);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":168,"deletions":67,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -26,1 +26,3 @@\n- * @bug 8351045\n+ * @bug 8351045 8351996\n+ * @enablePreview\n+ * @comment Remove preview if ScopedValue is finalized\n@@ -28,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -31,0 +34,6 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.ref.WeakReference;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n@@ -32,3 +41,6 @@\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n@@ -36,0 +48,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -37,0 +50,3 @@\n+import jdk.test.lib.util.ForceGC;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.RepeatedTest;\n@@ -38,0 +54,1 @@\n+import org.junit.jupiter.api.Timeout;\n@@ -39,1 +56,1 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -161,1 +178,0 @@\n-    private static final int RUNS = 16;\n@@ -163,0 +179,1 @@\n+    private static final Duration TIMEOUT = Duration.of(2, ChronoUnit.SECONDS);\n@@ -164,6 +181,4 @@\n-    @Test\n-    void testRemoveOnComputeCases() {\n-        try (var exec = Executors.newVirtualThreadPerTaskExecutor()) {\n-            var tasks = new ArrayList<Future<?>>(RUNS);\n-            for (int i = 0; i < RUNS; i++) {\n-                tasks.add(exec.submit(this::testRemoveOnCompute));\n+    private static void await(CountDownLatch latch) {\n+        try {\n+            if (!latch.await(2L, TimeUnit.SECONDS)) {\n+                fail(\"No signal received\");\n@@ -171,8 +186,14 @@\n-            for (var task : tasks) {\n-                try {\n-                    task.get();\n-                } catch (InterruptedException | ExecutionException ex) {\n-                    var cause = ex.getCause();\n-                    if (cause instanceof AssertionError ae)\n-                        throw ae;\n-                    throw new RuntimeException(ex);\n+        } catch (InterruptedException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    private static void awaitThreads(Thread... threads) {\n+        awaitThreads(Arrays.asList(threads));\n+    }\n+\n+    private static void awaitThreads(Iterable<Thread> threads) {\n+        for (var t : threads) {\n+            try {\n+                if (!t.join(TIMEOUT)) {\n+                    fail(\"Thread not stopping \" + t);\n@@ -180,0 +201,2 @@\n+            } catch (InterruptedException ex) {\n+                fail(ex);\n@@ -184,1 +207,9 @@\n-    void testRemoveOnCompute() {\n+    \/**\n+     * Tests that get() + remove() can prevent stale value from being installed.\n+     * Uses junit to do basic stress.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveStale() throws InterruptedException {\n+        CountDownLatch oldInputUsed = new CountDownLatch(1);\n+        CountDownLatch inputUpdated = new CountDownLatch(1);\n@@ -191,5 +222,3 @@\n-                try {\n-                    Thread.sleep(COMPUTE_TIME_MILLIS);\n-                } catch (InterruptedException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+                oldInputUsed.countDown();\n+                \/\/ ensure input is updated when we return\n+                await(inputUpdated);\n@@ -201,0 +230,1 @@\n+            await(oldInputUsed);\n@@ -203,0 +233,1 @@\n+            inputUpdated.countDown();\n@@ -204,6 +235,1 @@\n-        try {\n-            innocuous.join();\n-            refreshInput.join();\n-        } catch (InterruptedException ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        awaitThreads(innocuous, refreshInput);\n@@ -213,0 +239,243 @@\n+\n+    \/**\n+     * Tests that calling get() from computeValue() terminates.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testGetInCompute() {\n+        ClassValue<Object> cv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                get(type);\n+                get(type);\n+                get(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+        try {\n+            cv.get(int.class);\n+        } catch (Throwable ex) {\n+            \/\/ swallow if any\n+        }\n+    }\n+\n+    \/**\n+     * Tests that calling remove() from computeValue() terminates.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveInCompute() {\n+        ClassValue<Boolean> cv = new ClassValue<>() {\n+            @Override\n+            protected Boolean computeValue(Class<?> type) {\n+                remove(type);\n+                remove(type);\n+                remove(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+        assertTrue(cv.get(int.class));\n+    }\n+\n+    private static Class<?> createWeakClass() {\n+        var bytes = ClassFile.of().build(ClassDesc.of(\"WeakTest\"), _ -> {});\n+        try {\n+            return MethodHandles.lookup().defineHiddenClass(bytes, true).lookupClass();\n+        } catch (IllegalAccessException ex) {\n+            return fail(ex);\n+        }\n+    }\n+\n+    @Test\n+    void testWeakAgainstClass() {\n+        Class<?> hidden = createWeakClass();\n+        ClassValue<int[]> cv = new ClassValue<>() {\n+            @Override\n+            protected int[] computeValue(Class<?> type) {\n+                return new int[23];\n+            }\n+        };\n+\n+        WeakReference<?> ref = new WeakReference<>(cv.get(hidden));\n+        hidden = null; \/\/ Remove reference for interpreter\n+        if (!ForceGC.wait(() -> ref.refersTo(null))) {\n+            fail(\"Timeout\");\n+        }\n+    }\n+\n+    @Test\n+    @Disabled \/\/ JDK-8352622\n+    void testWeakAgainstClassValue() {\n+        ClassValue<int[]> cv = new ClassValue<>() {\n+            @Override\n+            protected int[] computeValue(Class<?> type) {\n+                return new int[23];\n+            }\n+        };\n+\n+        WeakReference<?> ref = new WeakReference<>(cv.get(int.class));\n+        cv = null; \/\/ Remove reference for interpreter\n+        if (!ForceGC.wait(() -> ref.refersTo(null))) {\n+            fail(\"Timeout\");\n+        }\n+    }\n+\n+    @Test\n+    void testSingletonWinner() {\n+        CountDownLatch raceStart = new CountDownLatch(1);\n+        ClassValue<int[]> cv = new ClassValue<>() {\n+            @Override\n+            protected int[] computeValue(Class<?> type) {\n+                await(raceStart);\n+                return new int[] {ThreadLocalRandom.current().nextInt()};\n+            }\n+        };\n+        AtomicReference<int[]> truth = new AtomicReference<>(null);\n+        AtomicInteger truthSwapCount = new AtomicInteger(0);\n+\n+        List<Thread> threads = new ArrayList<>(100);\n+        Runnable job = () -> {\n+            var res = cv.get(ClassValueTest.class);\n+            var item = truth.compareAndExchange(null, res);\n+            if (item != null) {\n+                assertSame(item, res);\n+            } else {\n+                truthSwapCount.incrementAndGet();\n+            }\n+        };\n+        for (int i = 0; i < 100; i++) {\n+            threads.add(Thread.startVirtualThread(job));\n+        }\n+        raceStart.countDown();\n+        awaitThreads(threads);\n+        assertEquals(1, truthSwapCount.get());\n+    }\n+\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRacyRemoveInCompute() {\n+        ClassValue<Object> cv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                remove(type);\n+                try {\n+                    Thread.sleep(COMPUTE_TIME_MILLIS);\n+                } catch (InterruptedException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+                remove(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+\n+        var threads = Arrays.stream(CLASSES)\n+                .map(clz -> Thread.startVirtualThread(() -> cv.get(clz)))\n+                .toList();\n+        awaitThreads(threads);\n+    }\n+\n+    @Test\n+    void testRecursiveInitialization() {\n+        record Holder() {\n+            static final ClassValue<Object> clv = new ClassValue<>() {\n+                @Override\n+                protected Object computeValue(Class<?> type) {\n+                    return new One();\n+                }\n+            };\n+\n+            record One() {\n+                static {\n+                    Holder.clv.get(One.class);\n+                }\n+            }\n+\n+        }\n+\n+        Holder.clv.get(Holder.One.class);\n+    }\n+\n+    private static final ScopedValue<Integer> THREAD_ID = ScopedValue.newInstance();\n+\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testNoRecomputeOnUnrelatedRemoval() throws InterruptedException {\n+        CountDownLatch t1Started = new CountDownLatch(1);\n+        CountDownLatch removeTamper = new CountDownLatch(1);\n+        CountDownLatch t2Started = new CountDownLatch(1);\n+        CountDownLatch t1Returned = new CountDownLatch(1);\n+        AtomicInteger t1Tries = new AtomicInteger();\n+        ClassValue<Object> clv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                int id = THREAD_ID.get();\n+                if (id == 1) {\n+                    t1Tries.incrementAndGet();\n+                    t1Started.countDown();\n+                    await(t2Started); \/\/ implies unrelated changes\n+                } else if (id == 2) {\n+                    t2Started.countDown();\n+                    \/\/ Don't race to install - we want to check computeValue tampers\n+                    await(t1Returned);\n+                } else if (id != -1) {\n+                    fail(\"Id: \" + id);\n+                }\n+                return \"\";\n+            }\n+        };\n+\n+        ScopedValue.where(THREAD_ID, -1).run(() -> clv.get(long.class)); \/\/ set up unrelated class\n+        var t1 = Thread.startVirtualThread(() ->\n+                ScopedValue.where(THREAD_ID, 1).run(() -> {\n+                    clv.get(int.class);\n+                    t1Returned.countDown(); \/\/ returned after x calls to computeValue\n+                }));\n+        var t2 = Thread.startVirtualThread(() ->\n+                ScopedValue.where(THREAD_ID, 2).run(() -> {\n+                    await(removeTamper);\n+                    clv.get(int.class); \/\/ clv version diff from that of promise\n+                }));\n+        await(t1Started);\n+        clv.remove(long.class);\n+        removeTamper.countDown(); \/\/ removed unrelated class\n+        awaitThreads(t1, t2);\n+        assertEquals(1, t1Tries.get(), \"Redundant computeValue retries\");\n+    }\n+\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testNoObsoleteInstallation() throws InterruptedException {\n+        CountDownLatch slowComputationStart = new CountDownLatch(1);\n+        CountDownLatch slowComputationContinue = new CountDownLatch(1);\n+        ClassValue<Integer> clv = new ClassValue<>() {\n+            @Override\n+            protected Integer computeValue(Class<?> type) {\n+                if (!THREAD_ID.isBound()) {\n+                    return 5;\n+                }\n+                int threadId = THREAD_ID.get();\n+                if (threadId == 1) {\n+                    if (slowComputationContinue.getCount() == 0) {\n+                        return 42;\n+                    } else {\n+                        \/\/ First invocation\n+                        slowComputationStart.countDown();\n+                        await(slowComputationContinue);\n+                        return -1;\n+                    }\n+                } else {\n+                    return fail(\"Unknown thread \" + threadId);\n+                }\n+            }\n+        };\n+        var t = Thread.startVirtualThread(() -> ScopedValue.where(THREAD_ID, 1).run(() -> {\n+            int v = clv.get(int.class);\n+            assertEquals(42, v, \"recomputed value\");\n+        }));\n+        await(slowComputationStart);\n+        assertEquals(5, clv.get(int.class), \"fast computation installed value\");\n+        clv.remove(int.class);\n+        slowComputationContinue.countDown();\n+        awaitThreads(t);\n+        assertEquals(42, clv.get(int.class), \"slow computation reinstalled value\");\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":301,"deletions":32,"binary":false,"changes":333,"status":"modified"}]}