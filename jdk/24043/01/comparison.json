{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n@@ -127,6 +129,8 @@\n-     * In order to explain the interaction between {@code get} and {@code remove} calls,\n-     * we must model the state transitions of a class value to take into account\n-     * the alternation between uninitialized and initialized states.\n-     * To do this, number these states sequentially from zero, and note that\n-     * uninitialized (or removed) states are numbered with even numbers,\n-     * while initialized (or re-initialized) states have odd numbers.\n+     * For a particular association, a {@code remove} call happens-before (JLS\n+     * {@jls 17.4.5}) any subsequent {@code get}, including any contingent {@code\n+     * computeValue} invocation that computed the associated value.  Naturally,\n+     * any {@code computeValue} that began before the {@code remove} call must\n+     * have its result discarded, because the removal must happen-before the\n+     * computation of the associated value.  The {@code get} call that invoked\n+     * the stale {@code computeValue} may retry to re-establish this\n+     * happens-before relationship.\n@@ -134,35 +138,3 @@\n-     * When a thread {@code T} removes a class value in state {@code 2N},\n-     * nothing happens, since the class value is already uninitialized.\n-     * Otherwise, the state is advanced atomically to {@code 2N+1}.\n-     * <p>\n-     * When a thread {@code T} queries a class value in state {@code 2N},\n-     * the thread first attempts to initialize the class value to state {@code 2N+1}\n-     * by invoking {@code computeValue} and installing the resulting value.\n-     * <p>\n-     * When {@code T} attempts to install the newly computed value,\n-     * if the state is still at {@code 2N}, the class value will be initialized\n-     * with the computed value, advancing it to state {@code 2N+1}.\n-     * <p>\n-     * Otherwise, whether the new state is even or odd,\n-     * {@code T} will discard the newly computed value\n-     * and retry the {@code get} operation.\n-     * <p>\n-     * Discarding and retrying is an important proviso,\n-     * since otherwise {@code T} could potentially install\n-     * a disastrously stale value.  For example:\n-     * <ul>\n-     * <li>{@code T} calls {@code CV.get(C)} and sees state {@code 2N}\n-     * <li>{@code T} quickly computes a time-dependent value {@code V0} and gets ready to install it\n-     * <li>{@code T} is hit by an unlucky paging or scheduling event, and goes to sleep for a long time\n-     * <li>...meanwhile, {@code T2} also calls {@code CV.get(C)} and sees state {@code 2N}\n-     * <li>{@code T2} quickly computes a similar time-dependent value {@code V1} and installs it on {@code CV.get(C)}\n-     * <li>{@code T2} (or a third thread) then calls {@code CV.remove(C)}, undoing {@code T2}'s work\n-     * <li> the previous actions of {@code T2} are repeated several times\n-     * <li> also, the relevant computed values change over time: {@code V1}, {@code V2}, ...\n-     * <li>...meanwhile, {@code T} wakes up and attempts to install {@code V0}; <em>this must fail<\/em>\n-     * <\/ul>\n-     * We can assume in the above scenario that {@code CV.computeValue} uses locks to properly\n-     * observe the time-dependent states as it computes {@code V1}, etc.\n-     * This does not remove the threat of a stale value, since there is a window of time\n-     * between the return of {@code computeValue} in {@code T} and the installation\n-     * of the new value.  No user synchronization is possible during this time.\n+     * This relationship also means that a {@code computeValue} cannot invoke\n+     * {@code remove}: a step in a computation cannot happen-before the start\n+     * of that computation.\n@@ -307,1 +279,0 @@\n-        private final Entry<T> promise = new Entry<>(this);\n@@ -310,1 +281,1 @@\n-        Entry<T> promise() { return promise; }\n+        Entry<T> createPromise() { return new Entry<>(this); }\n@@ -315,0 +286,3 @@\n+     *  Shared for the map and the cache array.\n+     *  The states are only meaningful for the cache array; whatever in the map\n+     *  is authentic, but state informs the cache an entry may be out-of-date.\n@@ -335,1 +309,1 @@\n-            this.value = this;  \/\/ for a promise, value is not of type T, but Entry!\n+            this.value = new PromiseInfo();  \/\/ for a promise, value is not of type T, but PromiseInfo!\n@@ -340,1 +314,52 @@\n-        boolean isPromise() { return value == this; }\n+\n+        boolean isPromise() { return value instanceof PromiseInfo; }\n+\n+        void registerExtraThread() {\n+            var tracker = ((PromiseInfo) value);\n+            if (!tracker.add()) {\n+                \/\/ This is trivial: such a recursion already causes StackOverflowError\n+                throw new StackOverflowError(\"Recursive initialization of class value\");\n+            }\n+        }\n+\n+        void checkReentrancy() {\n+            var tracker = ((PromiseInfo) value);\n+            if (tracker.contains()) {\n+                throw new StackOverflowError(\"Recursive initialization of class value\");\n+            }\n+        }\n+\n+        \/\/ Must be accessed in synchronization blocks on the ClassValueMap (otherThreads)\n+        \/\/ Compared to ThreadTracker, this optimizes optimistically for\n+        \/\/ single-thread accessors and uses plain instead of concurrent data structures.\n+        static final class PromiseInfo {\n+            private final Thread initialThread;\n+            private Map<Thread, Object> otherThreads; \/\/ Must be identity\/thread ID-based\n+\n+            PromiseInfo() {\n+                initialThread = Thread.currentThread();\n+            }\n+\n+            boolean add() {\n+                Thread t = Thread.currentThread();\n+                if (initialThread == t) {\n+                    return false;\n+                }\n+\n+                var others = this.otherThreads;\n+                if (others == null) {\n+                    others = new IdentityHashMap<>();\n+                    this.otherThreads = others;\n+                }\n+                return others.put(t, int.class) != null;\n+            }\n+\n+            boolean contains() {\n+                Thread t = Thread.currentThread();\n+                if (initialThread == t)\n+                    return true;\n+                var map = otherThreads;\n+                return map != null && map.containsKey(t);\n+            }\n+        }\n+\n@@ -443,1 +468,1 @@\n-                e = v.promise();\n+                e = v.createPromise();\n@@ -453,1 +478,1 @@\n-                    e = v.promise();\n+                    e = v.createPromise();\n@@ -455,0 +480,2 @@\n+                } else {\n+                    e.registerExtraThread();\n@@ -480,0 +507,1 @@\n+                \/\/ Other threads can retry if successful or just propagate their exceptions.\n@@ -494,1 +522,3 @@\n-                \/\/ Some sort of mismatch; caller must try again.\n+                \/\/ Some sort of mismatch; caller must try again. This can happen when:\n+                \/\/ 1. Another thread computes and finishes exceptionally.\n+                \/\/ 2. A remove() is issued after computation started.\n@@ -505,10 +535,13 @@\n-            \/\/ e.isPromise(): computeValue already used outdated values.\n-            \/\/ remove(identity) discarded the outdated computation promise.\n-            \/\/ finishEntry will retry when it discovers the promise is removed.\n-            \/\/ No cache invalidation.  No further action needed.\n-            if (e != null && !e.isPromise()) {\n-                \/\/ Initialized.\n-                \/\/ Bump forward to invalidate racy-read cached entries.\n-                classValue.bumpVersion();\n-                \/\/ Make all cache elements for this guy go stale.\n-                removeStaleEntries(classValue);\n+            if (e != null) {\n+                if (e.isPromise()) {\n+                    \/\/ Remove the outdated promise to force recomputation.\n+                    \/\/ Perform reentrancy checks so we fail if we are removing\n+                    \/\/ our own promise.\n+                    e.checkReentrancy();\n+                } else {\n+                    \/\/ Initialized.\n+                    \/\/ Bump forward to invalidate racy-read cached entries.\n+                    classValue.bumpVersion();\n+                    \/\/ Make all cache elements for this guy go stale.\n+                    removeStaleEntries(classValue);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":91,"deletions":58,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8351045\n+ * @bug 8351045 8351996\n@@ -35,0 +35,2 @@\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +39,1 @@\n+import org.junit.jupiter.api.RepeatedTest;\n@@ -38,0 +41,1 @@\n+import org.junit.jupiter.api.Timeout;\n@@ -164,21 +168,6 @@\n-    @Test\n-    void testRemoveOnComputeCases() {\n-        try (var exec = Executors.newVirtualThreadPerTaskExecutor()) {\n-            var tasks = new ArrayList<Future<?>>(RUNS);\n-            for (int i = 0; i < RUNS; i++) {\n-                tasks.add(exec.submit(this::testRemoveOnCompute));\n-            }\n-            for (var task : tasks) {\n-                try {\n-                    task.get();\n-                } catch (InterruptedException | ExecutionException ex) {\n-                    var cause = ex.getCause();\n-                    if (cause instanceof AssertionError ae)\n-                        throw ae;\n-                    throw new RuntimeException(ex);\n-                }\n-            }\n-        }\n-    }\n-\n-    void testRemoveOnCompute() {\n+    \/**\n+     * Tests that get() + remove() can prevent stale value from being installed.\n+     * Uses junit to do basic stress.\n+     *\/\n+    @RepeatedTest(value = RUNS)\n+    void testRemoveStale() {\n@@ -213,0 +202,22 @@\n+\n+    \/**\n+     * Tests that calling remove() from computeValue() is no-op.\n+     *\/\n+    @Test\n+    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n+    void testRemoveInCompute() {\n+        ClassValue<Object> cv = new ClassValue<>() {\n+            @Override\n+            protected Object computeValue(Class<?> type) {\n+                remove(type);\n+                remove(type);\n+                remove(type);\n+                return Boolean.TRUE;\n+            }\n+        };\n+        try {\n+            cv.get(int.class);\n+        } catch (Throwable ex) {\n+            \/\/ swallow if any\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":33,"deletions":22,"binary":false,"changes":55,"status":"modified"}]}