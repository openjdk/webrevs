{"files":[{"patch":"@@ -45,0 +45,49 @@\n+ * <p>\n+ * For any some specific pair of {@code ClassValue} and {@code Class}\n+ * objects, there is an assignment state for the value accessed by\n+ * {@code cv.get(c)}, and the state can be changed by method calls\n+ * {@code get} and {@code remove}.\n+ * <p>\n+ * The {@code get} method assigns it a value if it as not assigned\n+ * already, and otherwise returns the previously assigned value.  The\n+ * {@code remove} method removes any assigned value.\n+ * <p>\n+ * For any specific pair of {@code ClassValue} and {@code Class}\n+ * objects, all state changes are serialized in a simple linear order,\n+ * within the Java Memory Model.  The initial assignment state, and\n+ * the state after a {@code remove} call, is unassigned.  A call to\n+ * {@code get} on an assigned state returns the assigned value.\n+ * Thus, consecutive calls to {@code get} will return the same\n+ * value, until the next {@code remove}.\n+ * <p>\n+ * If a call to {@code get} occurs on an unassigned state, the {@code\n+ * computeValue} method is invoked.  If {@code computeValue} returns a\n+ * value normally, that value is the new assignment state.  If {@code\n+ * computeValue} throws an exception, an {@code Error} or {@code\n+ * RuntimeException} is thrown, either the thrown exception itself, or\n+ * an {@code Error} wrapping that exception as a cause.  If {@code\n+ * computeValue} make a recursive call to {@code get} (on the same\n+ * {@code Class}), a {@code StackOverflowError} is thrown.\n+ * <p>\n+ * If two or more racing calls are made to {@code get} on an\n+ * unassigned state, {@code computeValue} may be invoked on any or all\n+ * of them.  If one of those {@code computeValue} invocations returns\n+ * or throws, the {@code ClassValue} chooses the corresponding {@code\n+ * get} call to be the first in the linear order.  If the chosen\n+ * {@code computeValue} call returned normally, that value is\n+ * assigned, and other racing {@code computeValue} results will\n+ * be discarded when those invocations return or throw.  If the chosen\n+ * {@code computeValue} throws, that exception is thrown to the thread\n+ * making the {@code get} call, the binding state remains unbound, and\n+ * the remaining threads (if any) race to produce the bound value.\n+ * If all {@code computeValue} invocations throw, the value is not\n+ * bound after all.\n+ * <p>\n+ * Any {@code remove} call is given a place among a matching sequence\n+ * of {@code get} calls.  If a {@code remove} call is made recursively\n+ * during a {@code computeValue} call (on the same pair of operands),\n+ * it is regarded as having taken effect already (since the {@code\n+ * get} in process must have been triggered by a missing assignment).\n+ * In other words, a recursive call to {@code remove} from {@code\n+ * computeValue} has no effect at all.\n+ *\n@@ -195,1 +244,2 @@\n-        for (;;) {\n+        Throwable ex = null;\n+        for (; ; ) {\n@@ -201,0 +251,2 @@\n+                \/\/ e is real if computeValue finishes normally,\n+                \/\/ otherwise it is still the old promise\n@@ -202,0 +254,2 @@\n+            } catch (Throwable problem) {\n+                ex = problem;\n@@ -205,0 +259,1 @@\n+                \/\/\n@@ -207,1 +262,1 @@\n-            if (e != null)\n+            if (e != null)    \/\/ success, either here or in a racing thread\n@@ -209,1 +264,8 @@\n-            \/\/ else try again, in case a racing thread called remove (so e == null)\n+            if (ex == null)   \/\/ a racing thread called remove, so try again\n+                continue;\n+            \/\/ report failure here, but allow other callers to try again\n+            if (ex instanceof RuntimeException rte) {\n+                throw rte;\n+            } else {\n+                throw ex instanceof Error err ? err : new Error(ex);\n+            }\n@@ -317,2 +379,2 @@\n-        void registerOwner() {\n-            ((PromiseInfo) value).add();\n+        boolean addPromiseByCurrentThread() {\n+            return ((PromiseInfo) value).addCurrentThread();\n@@ -321,2 +383,2 @@\n-        boolean hasOwnership() {\n-            return ((PromiseInfo) value).contains();\n+        boolean isPromisedByCurrentThread() {\n+            return ((PromiseInfo) value).containsCurrentThread();\n@@ -325,1 +387,2 @@\n-        \/\/ Must be accessed in synchronization blocks on the ClassValueMap (otherThreads)\n+        \/\/ The content of a promise is a non-empty set of threads working on that promise.\n+        \/\/ Must be accessed in synchronization blocks on the ClassValueMap (otherThreads).\n@@ -336,1 +399,1 @@\n-            boolean add() {\n+            boolean addCurrentThread() {\n@@ -350,1 +413,1 @@\n-            boolean contains() {\n+            boolean containsCurrentThread() {\n@@ -471,0 +534,2 @@\n+                    \/\/ Somebody bumped the version, after resetting some state.\n+                    \/\/ This means we have to start fresh.\n@@ -474,1 +539,6 @@\n-                    e.registerOwner();\n+                    \/\/ Keep track of which threads observe this particular version.\n+                    \/\/ All of them are equally racing to fulfill the promise.\n+                    e.addPromiseByCurrentThread();\n+                    \/\/ Let the VM throw StackOverflowError: sometimes, a\n+                    \/\/ computeValue can trigger class initialization, which\n+                    \/\/ itself triggers another computeValue.\n@@ -503,1 +573,5 @@\n-            } else if (e0 != null && e0.isPromise() && e0.version() == e.version() && e0.hasOwnership()) {\n+            } else if (e0 != null && e0.isPromise()) {\n+                if (e0.version() != e.version() || !e0.isPromisedByCurrentThread()) {\n+                    \/\/ e0 is created after e, whether e failed (promise) or succeeded\n+                    return null;  \/\/ caller must try again\n+                }\n@@ -507,1 +581,1 @@\n-                if (e.version() != v)\n+                if (e.version() != v)  \/\/ removal in unrelated associations\n@@ -515,1 +589,2 @@\n-                \/\/ Some sort of mismatch; caller must try again. This can happen when:\n+                \/\/ Some sort of mismatch; caller must try again if e0=null.\n+                \/\/ This can happen when:\n@@ -518,1 +593,1 @@\n-                return null;\n+                return e0;\n@@ -531,2 +606,3 @@\n-                    if (e.hasOwnership()) {\n-                        \/\/ Notify myself that I am still up-to-date. All other guys are stale\n+                    if (e.isPromisedByCurrentThread()) {\n+                        \/\/ Notify myself that I am still up-to-date. All other racers are stale.\n+                        \/\/ That is, the fresh promise contains only this thread as promiser.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassValue.java","additions":93,"deletions":17,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -360,0 +360,21 @@\n+\n+    @Test\n+    void testRecursiveInitialization() {\n+        record Holder() {\n+            static final ClassValue<Object> clv = new ClassValue<>() {\n+                @Override\n+                protected Object computeValue(Class<?> type) {\n+                    return new One();\n+                }\n+            };\n+\n+            record One() {\n+                static {\n+                    Holder.clv.get(One.class);\n+                }\n+            }\n+\n+        }\n+\n+        Holder.clv.get(Holder.One.class);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}