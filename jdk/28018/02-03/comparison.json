{"files":[{"patch":"@@ -59,0 +59,1 @@\n+import com.sun.tools.javac.comp.Check;\n@@ -2312,1 +2313,7 @@\n-                addTypeAnnotationsToSymbol(sym, newList);\n+                if (sym.completer != Completer.NULL_COMPLETER) {\n+                    Assert.check(sym.completer instanceof TypeAnnotationsSymbolCompleter);\n+                    TypeAnnotationsSymbolCompleter completer = (TypeAnnotationsSymbolCompleter) sym.completer;\n+                    completer.attributes = newList.prependList(completer.attributes);\n+                } else {\n+                    sym.completer = new TypeAnnotationsSymbolCompleter(newList);\n+                }\n@@ -2319,0 +2326,16 @@\n+    private class TypeAnnotationsSymbolCompleter implements Completer {\n+\n+        List<Attribute.TypeCompound> attributes;\n+\n+        private TypeAnnotationsSymbolCompleter(List<Attribute.TypeCompound> attributes) {\n+            this.attributes = attributes;\n+        }\n+\n+        @Override\n+        public void complete(Symbol sym) throws CompletionFailure {\n+            Assert.checkNonNull(attributes);\n+            addTypeAnnotationsToSymbol(sym, attributes);\n+            attributes = null;\n+        }\n+    }\n+\n@@ -2334,1 +2357,1 @@\n-                log.warning(Warnings.CantAttachTypeAnnotations(attributes, s.owner, s.name, ex.getDetailValue()));\n+                log.error(Errors.CantAttachTypeAnnotations(attributes, s.owner, s.name, ex.getDetailValue()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2468,1 +2468,1 @@\n-compiler.warn.cant.attach.type.annotations=\\\n+compiler.err.cant.attach.type.annotations=\\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,11 @@\n+import java.util.Set;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.tools.Diagnostic;\n@@ -46,0 +57,1 @@\n+        t.testAnnotationProcessing();\n@@ -48,1 +60,4 @@\n-    void testMissingEnclosingType() throws Exception {\n+    Path src;\n+    Path out;\n+\n+    void setup() throws Exception {\n@@ -59,1 +74,1 @@\n-                  public @Anno A<String> a;\n+                  private @Anno A<String> a;\n@@ -66,3 +81,0 @@\n-                  public void test() {\n-                    b.a.toString();\n-                  }\n@@ -73,1 +85,1 @@\n-        Path src = base.resolve(\"src\");\n+        src = base.resolve(\"src\");\n@@ -76,1 +88,1 @@\n-        Path out = base.resolve(\"out\");\n+        out = base.resolve(\"out\");\n@@ -79,0 +91,4 @@\n+    }\n+\n+    void testMissingEnclosingType() throws Exception {\n+        setup();\n@@ -80,1 +96,1 @@\n-        \/\/ now if we remove A.class javac should not crash\n+        \/\/ now if we remove A.class there will be an error but javac should not crash\n@@ -82,0 +98,42 @@\n+        List<String> log =\n+                new JavacTask(tb)\n+                        .outdir(out)\n+                        .classpath(out)\n+                        .options(\"-XDrawDiagnostics\")\n+                        .files(src.resolve(\"C.java\"))\n+                        .run(Expect.SUCCESS)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static class Processor extends AbstractProcessor {\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+        boolean first = true;\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!first) {\n+                return false;\n+            }\n+            Element te = processingEnv.getElementUtils().getTypeElement(\"B\");\n+            for (var f : ElementFilter.fieldsIn(te.getEnclosedElements())) {\n+                TypeMirror t = f.asType();\n+                processingEnv\n+                        .getMessager()\n+                        .printMessage(\n+                                Diagnostic.Kind.NOTE,\n+                                \"%s (%s) has annotations [%s]\"\n+                                        .formatted(f, t, t.getAnnotationMirrors()));\n+            }\n+            first = false;\n+            return false;\n+        }\n+    }\n+\n+    void testAnnotationProcessing() throws Exception {\n+        setup();\n@@ -87,2 +145,1 @@\n-                        \/\/ DO NOT SUBMIT - this is a draft, see discussion in PR\n-                        .options(\/*\"-Werror\",*\/ \"-XDrawDiagnostics\")\n+                        .options(\"-XDrawDiagnostics\")\n@@ -90,1 +147,2 @@\n-                        .run(Expect.FAIL)\n+                        .processors(new Processor())\n+                        .run(Expect.SUCCESS)\n@@ -96,4 +154,27 @@\n-\"B.class:-:-: compiler.warn.cant.attach.type.annotations: @Anno, B, a, (compiler.misc.class.file.not.found: A)\",\n-\"C.java:4:8: compiler.err.cant.access: A, (compiler.misc.class.file.not.found: A)\",\n-\"1 error\",\n-\"1 warning\");\n+                        \"- compiler.note.proc.messager: a (@Anno A<java.lang.String>) has\"\n+                            + \" annotations [@Anno]\");\n+        if (!expectedOutput.equals(log)) {\n+            throw new Exception(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/ now if we remove A.class there will be an error and the annotations won't be available\n+        \/\/ but javac should not crash\n+        tb.deleteFiles(out.resolve(\"A.class\"));\n+\n+        log =\n+                new JavacTask(tb)\n+                        .outdir(out)\n+                        .classpath(out)\n+                        .options(\"-XDrawDiagnostics\")\n+                        .files(src.resolve(\"C.java\"))\n+                        .processors(new Processor())\n+                        .run(Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedOutput =\n+                List.of(\n+                        \"B.class:-:-: compiler.err.cant.attach.type.annotations: @Anno, B, a,\"\n+                                + \" (compiler.misc.class.file.not.found: A)\",\n+                        \"- compiler.note.proc.messager: a (A<java.lang.String>) has annotations []\",\n+                        \"1 error\");\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/CompletionErrorOnEnclosingType.java","additions":96,"deletions":15,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-compiler.warn.cant.attach.type.annotations              # bad class file\n+compiler.err.cant.attach.type.annotations               # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}