{"files":[{"patch":"@@ -1148,1 +1148,0 @@\n-                                        bool blocking,\n@@ -1212,0 +1211,1 @@\n+  bool blocking = false;\n@@ -1240,0 +1240,4 @@\n+    \/\/ This directive will be owned by a compile task.\n+    DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler(comp_level));\n+    blocking = !directive->BackgroundCompilationOption || ReplayCompiles;\n+\n@@ -1318,1 +1322,1 @@\n-                               blocking);\n+                               directive, blocking);\n@@ -1326,0 +1330,43 @@\n+static void apply_directive_exclude_option(const methodHandle& method, int comp_level) {\n+  if (method->is_always_compilable()) {\n+    return;\n+  }\n+\n+  \/\/ Compiler directives can be updated.\n+  \/\/ We need to guarantee that the directive is not changed while we are using it.\n+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+\n+  if (method->is_not_compilable(comp_level) && !method->is_excluded_from_compilation(comp_level)) {\n+    \/\/ The method is already not compilable, no need to exclude it.\n+    return;\n+  }\n+\n+  assert(method->is_not_compilable(comp_level) == method->is_excluded_from_compilation(comp_level),\n+         \"Excluded status must be aligned with compilable status\");\n+\n+  AbstractCompiler *comp = CompileBroker::compiler(comp_level);\n+  assert(comp != nullptr, \"Ensure we have a compiler\");\n+\n+  DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, comp);\n+  const bool excluded_new_value = directive->ExcludeOption;\n+  DirectivesStack::release(directive);\n+  const bool not_compilable = method->is_not_compilable(comp_level);\n+  const bool excluded_old_value = method->is_excluded_from_compilation(comp_level);\n+  if (excluded_new_value == excluded_old_value) {\n+    return;\n+  }\n+\n+  if (comp->is_c1()) {\n+    method->set_is_c1_excluded(excluded_new_value);\n+    method->set_is_not_c1_compilable(excluded_new_value);\n+  } else if (comp->is_c2()) {\n+    method->set_is_c2_excluded(excluded_new_value);\n+    method->set_is_not_c2_compilable(excluded_new_value);\n+  }\n+  if (excluded_new_value) {\n+    method->print_made_not_compilable(comp_level, \/*is_osr*\/ false, \/*report*\/ true, \"excluded by CompilerDirective\");\n+  } else {\n+    method->print_made_compilable(comp_level, \"included by CompilerDirective\");\n+  }\n+}\n+\n@@ -1336,1 +1383,1 @@\n-  AbstractCompiler *comp = CompileBroker::compiler(comp_level);\n+  AbstractCompiler *comp = compiler(comp_level);\n@@ -1346,14 +1393,0 @@\n-  DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, comp);\n-  \/\/ CompileBroker::compile_method can trap and can have pending async exception.\n-  nmethod* nm = CompileBroker::compile_method(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, directive, THREAD);\n-  DirectivesStack::release(directive);\n-  return nm;\n-}\n-\n-nmethod* CompileBroker::compile_method(const methodHandle& method, int osr_bci,\n-                                         int comp_level,\n-                                         const methodHandle& hot_method, int hot_count,\n-                                         CompileTask::CompileReason compile_reason,\n-                                         DirectiveSet* directive,\n-                                         TRAPS) {\n-\n@@ -1365,1 +1398,0 @@\n-  \/\/ return quickly if possible\n@@ -1367,4 +1399,1 @@\n-  \/\/ lock, make sure that the compilation\n-  \/\/ isn't prohibited in a straightforward way.\n-  AbstractCompiler* comp = CompileBroker::compiler(comp_level);\n-  if (comp == nullptr || compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n+  if (compilation_is_prohibited(method, osr_bci, comp_level)) {\n@@ -1374,0 +1403,2 @@\n+  apply_directive_exclude_option(method, comp_level);\n+\n@@ -1474,2 +1505,1 @@\n-    bool is_blocking = !directive->BackgroundCompilationOption || ReplayCompiles;\n-    compile_method_base(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, is_blocking, THREAD);\n+    compile_method_base(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, THREAD);\n@@ -1532,1 +1562,3 @@\n-bool CompileBroker::compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level, bool excluded) {\n+bool CompileBroker::compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level) {\n+  assert(compiler(comp_level) != nullptr, \"Ensure we have a compiler\");\n+\n@@ -1535,2 +1567,1 @@\n-  AbstractCompiler *comp = compiler(comp_level);\n-  if (is_native && (!CICompileNatives || comp == nullptr)) {\n+  if (is_native && !CICompileNatives) {\n@@ -1543,1 +1574,1 @@\n-  if (is_osr && (!CICompileOSR || comp == nullptr)) {\n+  if (is_osr && !CICompileOSR) {\n@@ -1550,1 +1581,1 @@\n-  if (excluded || (CompilerOracle::has_option_value(method, CompileCommandEnum::CompileThresholdScaling, scale) && scale == 0)) {\n+  if (CompilerOracle::has_option_value(method, CompileCommandEnum::CompileThresholdScaling, scale) && scale == 0) {\n@@ -1625,0 +1656,1 @@\n+                                                DirectiveSet*       directive,\n@@ -1629,1 +1661,1 @@\n-                       blocking);\n+                       directive, blocking);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":62,"deletions":30,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  static bool compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level, bool excluded);\n+  static bool compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level);\n@@ -257,0 +257,1 @@\n+                                          DirectiveSet*       directive,\n@@ -278,1 +279,0 @@\n-                                  bool blocking,\n@@ -316,11 +316,0 @@\n-private:\n-  static nmethod* compile_method(const methodHandle& method,\n-                                   int osr_bci,\n-                                   int comp_level,\n-                                   const methodHandle& hot_method,\n-                                   int hot_count,\n-                                   CompileTask::CompileReason compile_reason,\n-                                   DirectiveSet* directive,\n-                                   TRAPS);\n-\n-public:\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+                             DirectiveSet* directive,\n@@ -120,2 +121,1 @@\n-  AbstractCompiler* comp = compiler();\n-  _directive = DirectivesStack::getMatchingDirective(method, comp);\n+  _directive = directive;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                  CompileTask::CompileReason compile_reason, bool is_blocking);\n+                  CompileTask::CompileReason compile_reason, DirectiveSet* directive, bool is_blocking);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker locker(DirectivesStack_lock, !DirectivesStack_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -755,1 +755,1 @@\n-    MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+    ConditionalMutexLocker locker(DirectivesStack_lock, !DirectivesStack_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1031,0 +1031,28 @@\n+void Method::print_made_compilable(int comp_level, const char* reason) {\n+  assert(reason != nullptr, \"must provide a reason\");\n+  if (PrintCompilation) {\n+    ttyLocker ttyl;\n+    tty->print(\"made compilable on \");\n+    if (comp_level == CompLevel_all) {\n+      tty->print(\"all levels \");\n+    } else {\n+      tty->print(\"level %d \", comp_level);\n+    }\n+    this->print_short_name(tty);\n+    int size = this->code_size();\n+    if (size > 0) {\n+      tty->print(\" (%d bytes)\", size);\n+    }\n+    tty->print_cr(\"   %s\", reason);\n+  }\n+  if ((TraceDeoptimization || LogCompilation) && (xtty != nullptr)) {\n+    ttyLocker ttyl;\n+    xtty->begin_elem(\"make_compilable thread='\" UINTX_FORMAT \"' level='%d'\",\n+                     os::current_thread_id(), comp_level);\n+    xtty->print(\" reason=\\'%s\\'\", reason);\n+    xtty->method(this);\n+    xtty->stamp();\n+    xtty->end_elem();\n+  }\n+}\n+\n@@ -1101,0 +1129,10 @@\n+bool Method::is_excluded_from_compilation(int comp_level) const {\n+  if (comp_level == CompLevel_any)\n+    return is_c1_excluded() && is_c2_excluded();\n+  if (is_c1_compile(comp_level))\n+    return is_c1_excluded();\n+  if (is_c2_compile(comp_level))\n+    return is_c2_excluded();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -804,0 +804,1 @@\n+  bool is_excluded_from_compilation(int comp_level) const;\n@@ -805,1 +806,0 @@\n- private:\n@@ -807,0 +807,1 @@\n+  void print_made_compilable(int comp_level, const char* reason);\n@@ -808,1 +809,0 @@\n- public:\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+   status(is_c1_excluded              , 1 << 16) \/* Method is excluded from C1 compilation with a directive *\/ \\\n+   status(is_c2_excluded              , 1 << 17) \/* Method is excluded from C2 compilation with a directive *\/ \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test ClearDirectivesTest\n+ * @bug 8333891\n+ * @summary Test Java methods with a directive disabling compilation can get\n+ *          compilable if the directive is removed.\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   serviceability.dcmd.compiler.ClearDirectivesTest\n+ *\/\n+\n+package serviceability.dcmd.compiler;\n+\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+\n+import static jdk.test.lib.Asserts.assertEQ;\n+\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_NONE;\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE;\n+\n+public class ClearDirectivesTest {\n+\n+    static int calc(int v) {\n+        int result = 0;\n+        for (int i = 0; i < v; ++i) {\n+          result += result * v + i;\n+        }\n+        return result;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Method method = ClearDirectivesTest.class.getDeclaredMethod(\"calc\", int.class);\n+        String dirs = \"\"\"\n+        [{\n+           match: \"*::calc\",\n+           Exclude: true\n+        }]\"\"\";\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        wb.addCompilerDirective(dirs);\n+        new JMXExecutor().execute(\"Compiler.directives_print\");\n+\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        while (wb.isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+        assertEQ(COMP_LEVEL_NONE, wb.getMethodCompilationLevel(method), \"Compilation level\");\n+\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_SIMPLE);\n+        while (wb.isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+        assertEQ(COMP_LEVEL_NONE, wb.getMethodCompilationLevel(method), \"Compilation level\");\n+\n+        new JMXExecutor().execute(\"Compiler.directives_clear\");\n+        new JMXExecutor().execute(\"Compiler.directives_print\");\n+\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        while (wb.isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+        assertEQ(COMP_LEVEL_FULL_OPTIMIZATION, wb.getMethodCompilationLevel(method), \"Compilation level\");\n+\n+        wb.deoptimizeMethod(method);\n+        assertEQ(COMP_LEVEL_NONE, wb.getMethodCompilationLevel(method), \"Compilation level\");\n+\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_SIMPLE);\n+        while (wb.isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+        assertEQ(COMP_LEVEL_SIMPLE, wb.getMethodCompilationLevel(method), \"Compilation level\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/ClearDirectivesTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}