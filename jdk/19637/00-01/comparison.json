{"files":[{"patch":"@@ -1148,1 +1148,0 @@\n-                                        bool blocking,\n@@ -1212,0 +1211,1 @@\n+  bool blocking = false;\n@@ -1240,0 +1240,4 @@\n+    \/\/ This directive will be owned by a compile task.\n+    DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler(comp_level));\n+    blocking = !directive->BackgroundCompilationOption || ReplayCompiles;\n+\n@@ -1318,1 +1322,1 @@\n-                               blocking);\n+                               directive, blocking);\n@@ -1326,0 +1330,43 @@\n+static void apply_directive_exclude_option(const methodHandle& method, int comp_level) {\n+  if (method->is_always_compilable()) {\n+    return;\n+  }\n+\n+  \/\/ Compiler directives can be updated.\n+  \/\/ We need to guarantee that the directive is not changed while we are using it.\n+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+\n+  if (method->is_not_compilable(comp_level) && !method->is_excluded_from_compilation(comp_level)) {\n+    \/\/ The method is already not compilable, no need to exclude it.\n+    return;\n+  }\n+\n+  assert(method->is_not_compilable(comp_level) == method->is_excluded_from_compilation(comp_level),\n+         \"Excluded status must be aligned with compilable status\");\n+\n+  AbstractCompiler *comp = CompileBroker::compiler(comp_level);\n+  assert(comp != nullptr, \"Ensure we have a compiler\");\n+\n+  DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, comp);\n+  const bool excluded_new_value = directive->ExcludeOption;\n+  DirectivesStack::release(directive);\n+  const bool not_compilable = method->is_not_compilable(comp_level);\n+  const bool excluded_old_value = method->is_excluded_from_compilation(comp_level);\n+  if (excluded_new_value == excluded_old_value) {\n+    return;\n+  }\n+\n+  if (comp->is_c1()) {\n+    method->set_is_c1_excluded(excluded_new_value);\n+    method->set_is_not_c1_compilable(excluded_new_value);\n+  } else if (comp->is_c2()) {\n+    method->set_is_c2_excluded(excluded_new_value);\n+    method->set_is_not_c2_compilable(excluded_new_value);\n+  }\n+  if (excluded_new_value) {\n+    method->print_made_not_compilable(comp_level, \/*is_osr*\/ false, \/*report*\/ true, \"excluded by CompilerDirective\");\n+  } else {\n+    method->print_made_compilable(comp_level, \"included by CompilerDirective\");\n+  }\n+}\n+\n@@ -1336,1 +1383,1 @@\n-  AbstractCompiler *comp = CompileBroker::compiler(comp_level);\n+  AbstractCompiler *comp = compiler(comp_level);\n@@ -1346,26 +1393,0 @@\n-  DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, comp);\n-  \/\/ CompileBroker::compile_method can trap and can have pending async exception.\n-  nmethod* nm = CompileBroker::compile_method(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, directive, THREAD);\n-  DirectivesStack::release(directive);\n-  return nm;\n-}\n-\n-static void clear_is_not_compilable_by(const methodHandle& method, AbstractCompiler* comp) {\n-  if (comp == nullptr) {\n-    return;\n-  }\n-\n-  if (comp->is_c1()) {\n-    method->clear_is_not_c1_compilable();\n-  } else if (comp->is_c2()) {\n-    method->clear_is_not_c2_compilable();\n-  }\n-}\n-\n-nmethod* CompileBroker::compile_method(const methodHandle& method, int osr_bci,\n-                                         int comp_level,\n-                                         const methodHandle& hot_method, int hot_count,\n-                                         CompileTask::CompileReason compile_reason,\n-                                         DirectiveSet* directive,\n-                                         TRAPS) {\n-\n@@ -1377,5 +1398,0 @@\n-  \/\/ return quickly if possible\n-\n-  \/\/ lock, make sure that the compilation\n-  \/\/ isn't prohibited in a straightforward way.\n-  AbstractCompiler* comp = CompileBroker::compiler(comp_level);\n@@ -1383,5 +1399,1 @@\n-  \/\/ Compilation of a method not being compilable can be requested.\n-  \/\/ We clear its not compilable status. The status will be updated\n-  \/\/ as a result of the compilation.\n-  clear_is_not_compilable_by(method, comp);\n-  if (comp == nullptr || compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n+  if (compilation_is_prohibited(method, osr_bci, comp_level)) {\n@@ -1391,0 +1403,2 @@\n+  apply_directive_exclude_option(method, comp_level);\n+\n@@ -1491,2 +1505,1 @@\n-    bool is_blocking = !directive->BackgroundCompilationOption || ReplayCompiles;\n-    compile_method_base(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, is_blocking, THREAD);\n+    compile_method_base(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, THREAD);\n@@ -1549,1 +1562,3 @@\n-bool CompileBroker::compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level, bool excluded) {\n+bool CompileBroker::compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level) {\n+  assert(compiler(comp_level) != nullptr, \"Ensure we have a compiler\");\n+\n@@ -1552,2 +1567,1 @@\n-  AbstractCompiler *comp = compiler(comp_level);\n-  if (is_native && (!CICompileNatives || comp == nullptr)) {\n+  if (is_native && !CICompileNatives) {\n@@ -1560,1 +1574,1 @@\n-  if (is_osr && (!CICompileOSR || comp == nullptr)) {\n+  if (is_osr && !CICompileOSR) {\n@@ -1567,1 +1581,1 @@\n-  if (excluded || (CompilerOracle::has_option_value(method, CompileCommandEnum::CompileThresholdScaling, scale) && scale == 0)) {\n+  if (CompilerOracle::has_option_value(method, CompileCommandEnum::CompileThresholdScaling, scale) && scale == 0) {\n@@ -1642,0 +1656,1 @@\n+                                                DirectiveSet*       directive,\n@@ -1646,1 +1661,1 @@\n-                       blocking);\n+                       directive, blocking);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":62,"deletions":47,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  static bool compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level, bool excluded);\n+  static bool compilation_is_prohibited(const methodHandle& method, int osr_bci, int comp_level);\n@@ -257,0 +257,1 @@\n+                                          DirectiveSet*       directive,\n@@ -278,1 +279,0 @@\n-                                  bool blocking,\n@@ -316,11 +316,0 @@\n-private:\n-  static nmethod* compile_method(const methodHandle& method,\n-                                   int osr_bci,\n-                                   int comp_level,\n-                                   const methodHandle& hot_method,\n-                                   int hot_count,\n-                                   CompileTask::CompileReason compile_reason,\n-                                   DirectiveSet* directive,\n-                                   TRAPS);\n-\n-public:\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+                             DirectiveSet* directive,\n@@ -120,2 +121,1 @@\n-  AbstractCompiler* comp = compiler();\n-  _directive = DirectivesStack::getMatchingDirective(method, comp);\n+  _directive = directive;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                  CompileTask::CompileReason compile_reason, bool is_blocking);\n+                  CompileTask::CompileReason compile_reason, DirectiveSet* directive, bool is_blocking);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+  ConditionalMutexLocker locker(DirectivesStack_lock, !DirectivesStack_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -755,1 +755,1 @@\n-    MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+    ConditionalMutexLocker locker(DirectivesStack_lock, !DirectivesStack_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1031,0 +1031,28 @@\n+void Method::print_made_compilable(int comp_level, const char* reason) {\n+  assert(reason != nullptr, \"must provide a reason\");\n+  if (PrintCompilation) {\n+    ttyLocker ttyl;\n+    tty->print(\"made compilable on \");\n+    if (comp_level == CompLevel_all) {\n+      tty->print(\"all levels \");\n+    } else {\n+      tty->print(\"level %d \", comp_level);\n+    }\n+    this->print_short_name(tty);\n+    int size = this->code_size();\n+    if (size > 0) {\n+      tty->print(\" (%d bytes)\", size);\n+    }\n+    tty->print_cr(\"   %s\", reason);\n+  }\n+  if ((TraceDeoptimization || LogCompilation) && (xtty != nullptr)) {\n+    ttyLocker ttyl;\n+    xtty->begin_elem(\"make_compilable thread='\" UINTX_FORMAT \"' level='%d'\",\n+                     os::current_thread_id(), comp_level);\n+    xtty->print(\" reason=\\'%s\\'\", reason);\n+    xtty->method(this);\n+    xtty->stamp();\n+    xtty->end_elem();\n+  }\n+}\n+\n@@ -1101,0 +1129,10 @@\n+bool Method::is_excluded_from_compilation(int comp_level) const {\n+  if (comp_level == CompLevel_any)\n+    return is_c1_excluded() && is_c2_excluded();\n+  if (is_c1_compile(comp_level))\n+    return is_c1_excluded();\n+  if (is_c2_compile(comp_level))\n+    return is_c2_excluded();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -804,0 +804,1 @@\n+  bool is_excluded_from_compilation(int comp_level) const;\n@@ -805,1 +806,0 @@\n- private:\n@@ -807,0 +807,1 @@\n+  void print_made_compilable(int comp_level, const char* reason);\n@@ -808,1 +809,0 @@\n- public:\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+   status(is_c1_excluded              , 1 << 16) \/* Method is excluded from C1 compilation with a directive *\/ \\\n+   status(is_c2_excluded              , 1 << 17) \/* Method is excluded from C2 compilation with a directive *\/ \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}