{"files":[{"patch":"@@ -85,1 +85,1 @@\n-        segment.set(JAVA_SHORT, offset + bytes, (short)0);\n+        segment.set(JAVA_SHORT_UNALIGNED, offset + bytes, (short)0);\n@@ -97,1 +97,1 @@\n-        segment.set(JAVA_INT, offset + bytes, 0);\n+        segment.set(JAVA_INT_UNALIGNED, offset + bytes, 0);\n@@ -225,1 +225,1 @@\n-            short curr = segment.get(JAVA_SHORT, start + offset);\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n@@ -36,1 +34,0 @@\n-import java.nio.channels.FileChannel;\n@@ -39,3 +36,1 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.util.ArrayList;\n@@ -45,1 +40,0 @@\n-import java.util.function.Consumer;\n@@ -336,0 +330,21 @@\n+    @Test(dataProvider = \"charsetsAndSegments\")\n+    public void testStringGetWithCharset(SupportedCharset charset, HeapSegment segment) {\n+        for (int offset = 0 ; offset <= charset.align ; offset++) {\n+            segment.segment.getString(offset, charset.charset);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charsetsAndSegments\")\n+    public void testStringSetWithCharset(SupportedCharset charset, HeapSegment segment) {\n+        for (int offset = 0 ; offset <= charset.align ; offset++) {\n+            segment.segment.setString(offset, \"H\", charset.charset);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charsetsAndSegments\")\n+    public void testStringAllocateFromWithCharset(SupportedCharset charset, HeapSegment segment) {\n+        for (int offset = 0 ; offset <= charset.align ; offset++) {\n+            SegmentAllocator.prefixAllocator(segment.segment.asSlice(offset)).allocateFrom(\"H\", charset.charset);\n+        }\n+    }\n+\n@@ -459,0 +474,48 @@\n+    enum SupportedCharset {\n+        ISO_8859_1(StandardCharsets.ISO_8859_1, 1),\n+        US_ASCII(StandardCharsets.US_ASCII, 1),\n+        UTF_8(StandardCharsets.UTF_8, 1),\n+        UTF_16(StandardCharsets.UTF_16, 2),\n+        UTF_16BE(StandardCharsets.UTF_16BE, 2),\n+        UTF_16LE(StandardCharsets.UTF_16LE, 2),\n+        UTF_32(StandardCharsets.UTF_32, 4),\n+        UTF_32BE(StandardCharsets.UTF_32BE, 4),\n+        UTF_32LE(StandardCharsets.UTF_32LE, 4);\n+\n+        final Charset charset;\n+        final long align;\n+\n+        SupportedCharset(Charset charset, long align) {\n+            this.charset = charset;\n+            this.align = align;\n+        }\n+    }\n+\n+    enum HeapSegment {\n+        BYTE(MemorySegment.ofArray(new byte[80]), 1),\n+        CHAR(MemorySegment.ofArray(new char[40]), 2),\n+        SHORT(MemorySegment.ofArray(new short[40]), 2),\n+        INT(MemorySegment.ofArray(new int[20]), 4),\n+        FLOAT(MemorySegment.ofArray(new float[20]), 4),\n+        LONG(MemorySegment.ofArray(new long[10]), 8),\n+        DOUBLE(MemorySegment.ofArray(new double[10]), 8);\n+\n+        final MemorySegment segment;\n+        final long maxAlign;\n+\n+        HeapSegment(MemorySegment segment, long maxAlign) {\n+            this.segment = segment;\n+            this.maxAlign = maxAlign;\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] charsetsAndSegments() {\n+        List<Object[]> values = new ArrayList<>();\n+        for (SupportedCharset charset : SupportedCharset.values()) {\n+            for (HeapSegment heapSegments : HeapSegment.values()) {\n+                values.add(new Object[] { charset, heapSegments });\n+            }\n+        }\n+        return values.toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":70,"deletions":7,"binary":false,"changes":77,"status":"modified"}]}