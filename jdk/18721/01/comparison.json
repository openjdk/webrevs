{"files":[{"patch":"@@ -52,13 +52,0 @@\n-  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n-\n-  \/\/ Clear leading 32 bits, if necessary.\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n-  if (!is_aligned(base_offset, HeapWordSize)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n-    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n-    base_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n-\n-  const size_t header = heap_word_size(base_offset);\n-  const size_t payload_size = _word_size - header;\n@@ -66,1 +53,1 @@\n-  if (payload_size <= segment_max) {\n+  if (_word_size <= segment_max) {\n@@ -91,0 +78,16 @@\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t process_start_offset_in_bytes = align_up(base_offset_in_bytes, BytesPerWord);\n+\n+  if (process_start_offset_in_bytes != base_offset_in_bytes) {\n+    \/\/ initialize_memory can only fill word aligned memory,\n+    \/\/ fill the first 4 bytes here.\n+    assert(process_start_offset_in_bytes - base_offset_in_bytes == 4, \"Must be 4-byte aligned\");\n+    assert(!is_reference_type(element_type), \"Only TypeArrays can be 4-byte aligned\");\n+    *reinterpret_cast<int*>(reinterpret_cast<char*>(mem) + base_offset_in_bytes) = 0;\n+  }\n+\n+  \/\/ Note: initialize_memory may clear padding bytes at the end\n+  const size_t process_start_offset = ZUtils::bytes_to_words(process_start_offset_in_bytes);\n+  const size_t process_size = _word_size - process_start_offset;\n+\n@@ -103,1 +106,1 @@\n-    for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    for (size_t processed = 0; processed < process_size; processed += segment_max) {\n@@ -105,2 +108,2 @@\n-      uintptr_t* const start = (uintptr_t*)(mem + header + processed);\n-      const size_t remaining = payload_size - processed;\n+      uintptr_t* const start = (uintptr_t*)(mem + process_start_offset + processed);\n+      const size_t remaining = process_size - processed;\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"}]}