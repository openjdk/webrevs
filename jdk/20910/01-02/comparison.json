{"files":[{"patch":"@@ -1457,0 +1457,7 @@\n+\n+\/\/ This improvement (vectorization) is based on java.base\/share\/native\/libzip\/zlib\/zcrc32.c.\n+\/\/ To make it, following steps are taken:\n+\/\/  1. in zcrc32.c, modify N to 16 and related code,\n+\/\/  2. re-generate the tables needed, we use tables of (N == 16, W == 4)\n+\/\/  3. finally vectorize the code (original implementation in zcrc32.c is just scalar code).\n+\/\/ New tables for vector version is after table3.\n@@ -1459,2 +1466,1 @@\n-                                         Register table0, Register table3) {\n-\n+                                         Register table0, Register table3, const int64_t single_talbe_size) {\n@@ -1468,2 +1474,1 @@\n-    \/\/ prepare\n-    add(tableN16, table3, 1*256*sizeof(juint), tmp1);\n+    add(tableN16, table3, 1*single_talbe_size*sizeof(juint), tmp1);\n@@ -1481,2 +1486,1 @@\n-    slli(crc, crc, 32);\n-    srli(crc, crc, 32);\n+    zext_w(crc, crc);\n@@ -1485,0 +1489,1 @@\n+    \/\/ multiple of 64\n@@ -1507,1 +1512,1 @@\n-        addi(tmpTable, tmpTable, 256*4);\n+        addi(tmpTable, tmpTable, single_talbe_size*4);\n@@ -1562,0 +1567,1 @@\n+  const int64_t single_talbe_size = 256;\n@@ -1570,3 +1576,3 @@\n-  add(table1, table0, 1*256*sizeof(juint), tmp1);\n-  add(table2, table0, 2*256*sizeof(juint), tmp1);\n-  add(table3, table2, 1*256*sizeof(juint), tmp1);\n+  add(table1, table0, 1*single_talbe_size*sizeof(juint), tmp1);\n+  add(table2, table0, 2*single_talbe_size*sizeof(juint), tmp1);\n+  add(table3, table2, 1*single_talbe_size*sizeof(juint), tmp1);\n@@ -1589,1 +1595,1 @@\n-    vector_update_crc32(crc, buf, len, unroll_words, tmp1, tmp2, tmp3, tmp4, table0, table3);\n+    vector_update_crc32(crc, buf, len, unroll_words, tmp1, tmp2, tmp3, tmp4, table0, table3, single_talbe_size);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-                           Register table0, Register table3);\n+                           Register table0, Register table3, const int64_t single_talbe_size);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,1 +280,6 @@\n-    \/\/ tables for vector version\n+    \/\/ Tables for vector version\n+    \/\/ This improvement (vectorization) is based on java.base\/share\/native\/libzip\/zlib\/zcrc32.c.\n+    \/\/ To make it, following steps are taken:\n+    \/\/  1. in zcrc32.c, modify N to 16 and related code,\n+    \/\/  2. re-generate the tables needed, we use tables of (N == 16, W == 4)\n+    \/\/  3. finally vectorize the code (original implementation in zcrc32.c is just scalar code).\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}