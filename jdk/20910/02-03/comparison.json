{"files":[{"patch":"@@ -1482,1 +1482,1 @@\n-      assert(MaxVectorSize > 32);\n+      assert(MaxVectorSize > 32, \"sanity\");\n@@ -1565,1 +1565,1 @@\n-  Label L_by16_loop, L_unroll_loop, L_vector_or_unroll_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+  Label L_by16_loop, L_vector_entry, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n@@ -1581,4 +1581,3 @@\n-    sub(tmp1, len, unroll_words);\n-    bge(tmp1, zr, L_vector_or_unroll_entry);\n-  } else {\n-    bge(len, zr, L_vector_or_unroll_entry);\n+    const int64_t tmp_limit = MaxVectorSize >= 32 ? unroll_words*2 : unroll_words*4;\n+    sub(tmp1, len, tmp_limit);\n+    bge(tmp1, zr, L_vector_entry);\n@@ -1586,0 +1585,2 @@\n+  bge(len, zr, L_unroll_loop_entry);\n+\n@@ -1593,3 +1594,11 @@\n-  bind(L_vector_or_unroll_entry);\n-  if (UseRVV) {\n-    vector_update_crc32(crc, buf, len, unroll_words, tmp1, tmp2, tmp3, tmp4, table0, table3, single_talbe_size);\n+  bind(L_unroll_loop_entry);\n+    const Register buf_end = tmp3;\n+    add(buf_end, buf, len); \/\/ buf_end will be used as endpoint for loop below\n+    andi(len, len, unroll_words-1); \/\/ len = (len % unroll_words)\n+    sub(len, len, unroll_words); \/\/ Length after all iterations\n+  bind(L_unroll_loop);\n+    for (int i = 0; i < unroll; i++) {\n+      ld(tmp1, Address(buf, i*wordSize));\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, false);\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, true);\n+    }\n@@ -1597,1 +1606,3 @@\n-    addiw(len, len, -4);\n+    addi(buf, buf, unroll_words);\n+    ble(buf, buf_end, L_unroll_loop);\n+    addiw(len, len, unroll_words-4);\n@@ -1602,21 +1613,0 @@\n-  } else {\n-      const Register buf_end = tmp3;\n-      add(buf_end, buf, len); \/\/ buf_end will be used as endpoint for loop below\n-      andi(len, len, unroll_words-1); \/\/ len = (len % unroll_words)\n-      sub(len, len, unroll_words); \/\/ Length after all iterations\n-    bind(L_unroll_loop);\n-      for (int i = 0; i < unroll; i++) {\n-        ld(tmp1, Address(buf, i*wordSize));\n-        update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, false);\n-        update_word_crc32(crc, tmp1, tmp2, tmp4, tmp6, table0, table1, table2, table3, true);\n-      }\n-\n-      addi(buf, buf, unroll_words);\n-      ble(buf, buf_end, L_unroll_loop);\n-\n-      addiw(len, len, unroll_words-4);\n-      bge(len, zr, L_by4_loop);\n-      addiw(len, len, 4);\n-      bgt(len, zr, L_by1_loop);\n-      j(L_exit);\n-  }\n@@ -1655,0 +1645,13 @@\n+    j(L_exit);\n+\n+  \/\/ put vector code here, otherwise \"offset is too large\" error occurs.\n+  if (UseRVV) {\n+    bind(L_vector_entry);\n+    vector_update_crc32(crc, buf, len, unroll_words, tmp1, tmp2, tmp3, tmp4, table0, table3, single_talbe_size);\n+\n+    addiw(len, len, -4);\n+    bge(len, zr, L_by4_loop);\n+    addiw(len, len, 4);\n+    bgt(len, zr, L_by1_loop);\n+    j(L_exit);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":34,"deletions":31,"binary":false,"changes":65,"status":"modified"}]}