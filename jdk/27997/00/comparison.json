{"files":[{"patch":"@@ -598,0 +598,5 @@\n+          if (n->is_Mem() && n->as_Mem()->is_mismatched_access()) {\n+            DEBUG_ONLY(disq_node = n);\n+            NOT_PRODUCT(fail_eliminate = \"Mismatched access\");\n+            can_eliminate = false;\n+          }\n@@ -851,0 +856,19 @@\n+#ifdef ASSERT\n+    const Type* t = field_val->bottom_type();\n+    if (t != field_type->filter(t) &&\n+        t->basic_type() != field_type->basic_type() &&\n+        !(t->isa_oopptr() != nullptr && field_type->isa_narrowoop())) {\n+      tty->print_cr(\"field_val does not fit field_type: %s vs %s\",\n+                    type2name(t->basic_type()),\n+                    type2name(field_type->basic_type()));\n+      tty->print(\"field_val:\");\n+      field_val->dump();\n+      tty->print(\"field_val type: \");\n+      t->dump();\n+      tty->cr();\n+      tty->print(\"field_type: \");\n+      field_type->dump();\n+      tty->cr();\n+      assert(false, \"field_val does not fit field_type\");\n+    }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1390,0 +1390,5 @@\n+#ifdef ASSERT\n+            tty->print_cr(\"Deopt rematerialization found [int, long] in a int\/flat array.\");\n+            sv->print_fields_on(tty);\n+            assert(false, \"never hit this case in testing, seems to be a strange case\");\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+\/*\n+ * @test\n+ * @bug 8370405\n+ * @summary Test case where we had escape analysis tell us that we can possibly eliminate\n+ *          the array allocation, then MergeStores introduces a mismatched store, which\n+ *          the actual elimination does not verify for. That led to wrong results.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresAndAllocationElimination::test\n+ *                   -XX:CompileCommand=exclude,compiler.c2.TestMergeStoresAndAllocationElimination::dontinline\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-CICompileOSR\n+ *                   compiler.c2.TestMergeStoresAndAllocationElimination\n+ * @run main compiler.c2.TestMergeStoresAndAllocationElimination\n+ *\/\n+\n+public class TestMergeStoresAndAllocationElimination {\n+    static void dontinline() {}\n+\n+    static int test(boolean flag) {\n+        int[] arr = new int[4];\n+        \/\/ The values below will be caputured as \"raw stores\" in the Initialize\n+        \/\/ of the array allocation above.\n+        \/\/ These stores are for cosmetics only, we set the \"1\" bits so that it is\n+        \/\/ simple to track where values are coming from.\n+        arr[0] = 0x0001_0000;\n+        arr[1] = 0x0010_0000;\n+        arr[2] = 0x0000_0100;\n+        arr[3] = 0x0100_0000;\n+        \/\/ So far, the result should be:\n+        \/\/ 0x421_0300\n+\n+        \/\/ The call below prevents further assignments from being captured into\n+        \/\/ the Initialize above.\n+        dontinline();\n+        \/\/ The follwoing stores are eventually optimized by MergeStores, and create\n+        \/\/ a mismatched StoreL.\n+        arr[0] = 0x0000_0001;\n+        arr[1] = 0x0000_0010;\n+        \/\/ Now, the result should be:\n+        \/\/ 0x400_0321\n+\n+        \/\/ We create an uncommon trap because of an \"unstable if\".\n+        \/\/ If Escape Analysis were to work, it would try to capture the values\n+        \/\/ from the StoreL above. But because it is mismatched, it should fail.\n+        \/\/ What happened before that verification: we would take the ConL, and\n+        \/\/ insert it in a list of ConI. That meant that we eventually applied\n+        \/\/ that value wrong if the deopt was taken (flag = true).\n+        \/\/\n+        \/\/ What happened when the deopt got the wrong values: It got these values:\n+        \/\/ [0]=68719476737 = 0x10_0000_0001 -> long value, not correct\n+        \/\/ [1]=1048576     =      0x10_0000 -> this entry is not updated!\n+        \/\/ [2]=256         =          0x100\n+        \/\/ [3]=16777216    =     0x100_0000\n+        \/\/\n+        \/\/ This is serialized as a long and 3 ints, and that looks like 5 ints.\n+        \/\/ This creates an array of 5 elements (and not 4):\n+        \/\/ [0]             =            0x1\n+        \/\/ [1]             =           0x10\n+        \/\/ [2]             =      0x10_0000 -> this entry is \"inserted\"\n+        \/\/ [3]             =          0x100\n+        \/\/ [4]             =     0x100_0000\n+        \/\/\n+        \/\/ This creates the wrong state:\n+        \/\/ 0x30_0421\n+        \/\/ And we can actually read that the arr.length is 5, below.\n+        if (flag) { System.out.println(\"unstable if: \" + arr.length); }\n+\n+        \/\/ Delay the allocation elimination until after loop opts, so that it\n+        \/\/ happens after MergeStores. Without this, we would immediately\n+        \/\/ eliminate the allocation during Escape Analysis, and then MergeStores\n+        \/\/ would not find the stores that would be removed with the allocation.\n+        for (int i = 0; i < 10_000; i++) {\n+            arr[3] = 0x0000_1000;\n+        }\n+        \/\/ Coming from the correct value, we should have transition of state:\n+        \/\/ 0x400_0321 -> 0x4321\n+        \/\/ But coming from the bad (rematerialized) state, we transition:\n+        \/\/ 0x30_0421 -> 0x30_4021\n+\n+        \/\/ Tag each entry with an index number\n+        \/\/ We expect: 0x4321\n+        return 1 * arr[0] + 2 * arr[1] + 3 * arr[2] + 4 * arr[3];\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Capture interpreter result.\n+        int gold = test(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test(false);\n+        int res1 = test(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" + Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresAndAllocationElimination.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=yEA\n+ * @bug 8370405\n+ * @summary Test elimination of array allocation, and the rematerialization.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.escapeAnalysis.TestRematerializeObjects yEA\n+ *\/\n+\n+\/*\n+ * @test id=nEA\n+ * @library \/test\/lib \/\n+ * @run driver compiler.escapeAnalysis.TestRematerializeObjects nEA\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+\n+public class TestRematerializeObjects {\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestRematerializeObjects.class);\n+        switch (args[0]) {\n+            case \"yEA\" -> { framework.addFlags(\"-XX:+EliminateAllocations\"); }\n+            case \"nEA\" -> { framework.addFlags(\"-XX:-EliminateAllocations\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n+    }\n+\n+    @DontInline\n+    static void dontinline() {}\n+\n+    @Run(test = \"test1\", mode = RunMode.STANDALONE)\n+    public void runTest1() {\n+        \/\/ Capture interpreter result.\n+        int gold = test1(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test1(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test1(false);\n+        int res1 = test1(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\[int:4\\\\]\", \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\[int:4\\\\]\", \"0\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test1(boolean flag) {\n+        int[] arr = new int[4];\n+        arr[0] = 0x0001_0000; \/\/ these slip into Initialize\n+        arr[1] = 0x0010_0000;\n+        arr[2] = 0x0000_0100;\n+        arr[3] = 0x0100_0000;\n+        dontinline();\n+        arr[0] = 0x0000_0001; \/\/ MergeStores -> StoreL\n+        arr[1] = 0x0000_0010;\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 0x0000_1000;\n+        return 1 * arr[0] + 2 * arr[1] + 3 * arr[2] + 4 * arr[3];\n+    }\n+\n+    @Run(test = \"test2\", mode = RunMode.STANDALONE)\n+    public void runTest2() {\n+        \/\/ Capture interpreter result.\n+        int gold = test2(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test2(false);\n+        int res1 = test2(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\[int:4\\\\]\", \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\[int:4\\\\]\", \"0\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test2(boolean flag) {\n+        short[] arr = new short[4];\n+        arr[0] = 1;\n+        arr[1] = 2;\n+        arr[2] = 4;\n+        arr[3] = 8;\n+        dontinline();\n+        \/\/ Seems we detect that this is a short value passed into the short field.\n+        arr[0] = 16;\n+        arr[1] = 32;\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 64;\n+        return 0x1 * arr[0] + 0x100 * arr[1] + 0x1_0000 * arr[2] + 0x100_0000 * arr[3];\n+    }\n+\n+    @Run(test = \"test3\", mode = RunMode.STANDALONE)\n+    public void runTest3() {\n+        \/\/ Capture interpreter result.\n+        int gold = test3(false, 42);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test3(false, 42);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test3(false, 42);\n+        int res1 = test3(true, 42);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test3(boolean flag, int x) {\n+        short[] arr = new short[4];\n+        arr[0] = 1;\n+        arr[1] = 2;\n+        arr[2] = 4;\n+        arr[3] = 8;\n+        dontinline();\n+        \/\/ Here, we don't get ConI, but instead AddI, which means we are\n+        \/\/ serializing an int value, for a short slot.\n+        arr[0] = (short)(x + 1);\n+        arr[1] = (short)(x + 2);\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 64;\n+        return 0x1 * arr[0] + 0x100 * arr[1] + 0x1_0000 * arr[2] + 0x100_0000 * arr[3];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestRematerializeObjects.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -1907,0 +1907,5 @@\n+    public static final String SAFEPOINT_SCALAROBJECT_OF = COMPOSITE_PREFIX + \"SAFEPOINT_SCALAROBJECT_OF\" + POSTFIX;\n+    static {\n+        safepointScalarobjectOfNodes(SAFEPOINT_SCALAROBJECT_OF, \"SafePointScalarObject\");\n+    }\n+\n@@ -3217,0 +3222,5 @@\n+    private static void safepointScalarobjectOfNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + \".*\" + IS_REPLACED + \".*\" + END;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}