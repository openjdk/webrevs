{"files":[{"patch":"@@ -233,0 +233,1 @@\n+    public final Type ioType;\n@@ -619,0 +620,1 @@\n+        ioType = enterClass(\"java.io.IO\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final DeferredAttr deferredAttr;\n@@ -132,0 +133,1 @@\n+        deferredAttr = DeferredAttr.instance(context);\n@@ -326,1 +328,1 @@\n-        private void importJavaLang(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter typeImportFilter) {\n+        private void implicitImports(JCCompilationUnit tree, Env<AttrContext> env) {\n@@ -335,0 +337,20 @@\n+\n+            List<JCTree> defs = tree.defs;\n+            boolean isImplicitClass = !defs.isEmpty() &&\n+                    defs.head instanceof JCClassDecl cls &&\n+                    (cls.mods.flags & IMPLICIT_CLASS) != 0;\n+            if (isImplicitClass) {\n+                doModuleImport(make.ModuleImport(make.QualIdent(syms.java_base)));\n+                if (peekTypeExists(env, syms.ioType.tsym)) {\n+                    doImport(make.Import(make.Select(make.QualIdent(syms.ioType.tsym),\n+                            names.asterisk), true));\n+                }\n+            }\n+        }\n+\n+        \/\/check if the given class exists, without producing side-effects:\n+        private boolean peekTypeExists(Env<AttrContext> env, TypeSymbol type) {\n+            JCExpression expr = make.Select(make.QualIdent(type), names._class);\n+            return !deferredAttr.attribSpeculative(expr, env, attr.unknownExprInfo)\n+                                .type\n+                                .isErroneous();\n@@ -359,1 +381,1 @@\n-                importJavaLang(tree, env, typeImportFilter);\n+                implicitImports(tree, env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325324\n+ * @summary Verify behavior w.r.t. implicit imports\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ImplicitImports\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+\n+public class ImplicitImports extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ImplicitImports().runTests();\n+    }\n+\n+    ImplicitImports() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testImplicitJavaBaseImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     public static void main(String... args) {\n+                         List<String> l = new ArrayList<>();\n+                         System.out.println(l.getClass().getName());\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\/\/with --release:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+\n+        {\/\/with --source:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--source\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testImplicitSimpleIOImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+\n+        Path patchClasses = prepareIOPatch(current);\n+\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     public static void main(String... args) {\n+                         println(\"Hello, World!\");\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                     \"--patch-module\", \"java.base=\" + patchClasses)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        var out = new JavaTask(tb)\n+                .classpath(classes.toString())\n+                .className(\"Test\")\n+                .vmOptions(\"--enable-preview\",\n+                           \"--patch-module\", \"java.base=\" + patchClasses)\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        var expectedOut = List.of(\"Hello, World!\");\n+\n+        if (!Objects.equals(expectedOut, out)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testNoImplicitImportsForOrdinaryClasses(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+\n+        Path patchClasses = prepareIOPatch(current);\n+\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     public class Test {\n+                         public static void main(String... args) {\n+                             List<String> l = new ArrayList<>();\n+                             println(\"Hello, World!\");\n+                         }\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        var log = new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                        \"--patch-module\", \"java.base=\" + patchClasses,\n+                        \"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        var expectedLog = List.of(\n+            \"Test.java:3:9: compiler.err.cant.resolve.location: kindname.class, List, , , (compiler.misc.location: kindname.class, Test, null)\",\n+            \"Test.java:3:30: compiler.err.cant.resolve.location: kindname.class, ArrayList, , , (compiler.misc.location: kindname.class, Test, null)\",\n+            \"Test.java:4:9: compiler.err.cant.resolve.location.args: kindname.method, println, , java.lang.String, (compiler.misc.location: kindname.class, Test, null)\",\n+            \"3 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedLog, log)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedLog +\n+                                      \", actual: \" + log);\n+\n+        }\n+    }\n+\n+    private Path prepareIOPatch(Path base) throws IOException {\n+        Path patchSrc = base.resolve(\"patch-src\");\n+        Path patchClasses = base.resolve(\"patch-classes\");\n+        tb.writeJavaFiles(patchSrc,\n+                          \"\"\"\n+                          package java.io;\n+                          public class IO {\n+                              public static void println(Object o) {\n+                                  System.out.println(o);\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(patchClasses);\n+\n+        new JavacTask(tb)\n+            .options(\"--patch-module\", \"java.base=\" + patchSrc)\n+            .outdir(patchClasses)\n+            .files(tb.findJavaFiles(patchSrc))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        return patchClasses;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitImports.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -88,0 +88,4 @@\n+            \/\/ Temporarily ignore java.io.IO:\n+            if (f.getName().equals(\"ioType\"))\n+                continue;\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/TestSymtabItems.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}