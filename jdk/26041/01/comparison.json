{"files":[{"patch":"@@ -44,1 +44,1 @@\n-import static jdk.internal.net.http.common.Utils.ServerName;\n+import sun.net.util.IPAddressUtil;\n@@ -66,0 +66,4 @@\n+\n+    private record ServerName(String name, boolean isLiteral) {\n+    }\n+\n@@ -74,1 +78,2 @@\n-    AbstractAsyncSSLConnection(InetSocketAddress addr,\n+    AbstractAsyncSSLConnection(Origin originServer,\n+                               InetSocketAddress addr,\n@@ -76,1 +81,0 @@\n-                               ServerName serverName, int port,\n@@ -79,1 +83,3 @@\n-        super(addr, client, label);\n+        super(originServer, addr, client, label);\n+        assert originServer != null : \"origin server is null\";\n+        final ServerName serverName = getServerName(originServer);\n@@ -84,1 +90,1 @@\n-        engine = createEngine(context, serverName.name(), port, sslParameters);\n+        engine = createEngine(context, serverName.name(), originServer.port(), sslParameters);\n@@ -190,0 +196,17 @@\n+    \/**\n+     * Analyse the given {@linkplain Origin origin server} and determine\n+     * if the origin server's host is a literal or not, returning the server's\n+     * address in String form.\n+     *\/\n+    private static ServerName getServerName(final Origin originServer) {\n+        final String host = originServer.host();\n+        byte[] literal = IPAddressUtil.textToNumericFormatV4(host);\n+        if (literal == null) {\n+            \/\/ not IPv4 literal. Check IPv6\n+            literal = IPAddressUtil.textToNumericFormatV6(host);\n+            return new ServerName(host, literal != null);\n+        } else {\n+            return new ServerName(host, true);\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AbstractAsyncSSLConnection.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-    AsyncSSLConnection(InetSocketAddress addr,\n+    AsyncSSLConnection(Origin originServer,\n+                       InetSocketAddress addr,\n@@ -49,2 +50,2 @@\n-        super(addr, client, Utils.getServerName(addr), addr.getPort(), alpn, label);\n-        plainConnection = new PlainHttpConnection(addr, client, label);\n+        super(originServer, addr, client, alpn, label);\n+        plainConnection = new PlainHttpConnection(originServer, addr, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLConnection.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-    AsyncSSLTunnelConnection(InetSocketAddress addr,\n+    AsyncSSLTunnelConnection(Origin originServer,\n+                             InetSocketAddress addr,\n@@ -53,2 +54,3 @@\n-        super(addr, client, Utils.getServerName(addr), addr.getPort(), alpn, label);\n-        this.plainConnection = new PlainTunnelingConnection(addr, proxy, client, proxyHeaders, label);\n+        super(originServer, addr, client, alpn, label);\n+        this.plainConnection = new PlainTunnelingConnection(originServer, addr, proxy, client,\n+                proxyHeaders, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLTunnelConnection.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,5 @@\n-    HttpConnection(InetSocketAddress address, HttpClientImpl client, String label) {\n+    private final Origin originServer;\n+\n+    HttpConnection(Origin originServer, InetSocketAddress address, HttpClientImpl client,\n+                   String label) {\n+        this.originServer = originServer;\n@@ -247,0 +251,8 @@\n+    \/**\n+     * {@return the {@link Origin} server against which this connection communicates.\n+     * Returns {@code null} if the connection is a plain connection to a proxy}\n+     *\/\n+    final Origin getOriginServer() {\n+        return this.originServer;\n+    }\n+\n@@ -337,1 +349,8 @@\n-        String label = nextLabel();\n+        final String label = nextLabel();\n+        final Origin originServer;\n+        try {\n+            originServer = Origin.from(request.uri());\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ should never happen\n+            throw new AssertionError(\"failed to determine origin server from request URI\", iae);\n+        }\n@@ -339,1 +358,1 @@\n-            return new AsyncSSLTunnelConnection(addr, client, alpn, proxy,\n+            return new AsyncSSLTunnelConnection(originServer, addr, client, alpn, proxy,\n@@ -343,1 +362,1 @@\n-            return new AsyncSSLConnection(addr, client, alpn, label);\n+            return new AsyncSSLConnection(originServer, addr, client, alpn, label);\n@@ -417,1 +436,8 @@\n-        String label = nextLabel();\n+        final String label = nextLabel();\n+        final Origin originServer;\n+        try {\n+            originServer = Origin.from(request.uri());\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ should never happen\n+            throw new AssertionError(\"failed to determine origin server from request URI\", iae);\n+        }\n@@ -419,1 +445,1 @@\n-            return new PlainTunnelingConnection(addr, proxy, client,\n+            return new PlainTunnelingConnection(originServer, addr, proxy, client,\n@@ -424,1 +450,1 @@\n-            return new PlainHttpConnection(addr, client, label);\n+            return new PlainHttpConnection(originServer, addr, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http;\n+\n+import java.net.URI;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+\/**\n+ * Represents an origin server to which a HTTP request is targeted.\n+ *\n+ * @param scheme The scheme of the origin (for example: https). Unlike the application layer\n+ *               protocol (which can be a finer grained protocol like h2, h3 etc...),\n+ *               this is actually a scheme. Only {@code http} and {@code https} literals are\n+ *               supported. Cannot be null.\n+ * @param host   The host of the origin. If the host is an IPv6 address, then it must not be\n+ *               enclosed in square brackets ({@code '['} and {@code ']'}). Cannot be null.\n+ * @param port   The port of the origin. Must be greater than 0.\n+ *\/\n+public record Origin(String scheme, String host, int port) {\n+    public Origin {\n+        Objects.requireNonNull(scheme);\n+        Objects.requireNonNull(host);\n+        if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\n+            throw new IllegalArgumentException(\"Invalid host: \" + host);\n+        }\n+        if (port <= 0) {\n+            throw new IllegalArgumentException(\"Invalid port: \" + port);\n+        }\n+        if (!isValidScheme(scheme)) {\n+            throw new IllegalArgumentException(\"Unsupported scheme: \" + scheme);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return scheme + \":\/\/\" + toAuthority(host, port);\n+    }\n+\n+    \/**\n+     * {@return Creates and returns an Origin from an URI}\n+     *\n+     * @param uri The URI of the origin\n+     * @throws IllegalArgumentException if a Origin cannot be constructed from\n+     *                                  the given {@code uri}\n+     *\/\n+    public static Origin from(final URI uri) throws IllegalArgumentException {\n+        Objects.requireNonNull(uri);\n+        final String scheme = uri.getScheme();\n+        if (scheme == null) {\n+            throw new IllegalArgumentException(\"missing scheme in URI\");\n+        }\n+        final String lcaseScheme = scheme.toLowerCase(Locale.ROOT);\n+        if (!isValidScheme(lcaseScheme)) {\n+            throw new IllegalArgumentException(\"Unsupported scheme: \" + scheme);\n+        }\n+        final String host = uri.getHost();\n+        if (host == null) {\n+            throw new IllegalArgumentException(\"missing host in URI\");\n+        }\n+        final String effectiveHost;\n+        if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\n+            \/\/ strip the square brackets from IPv6 host\n+            effectiveHost = host.substring(1, host.length() - 1);\n+        } else {\n+            effectiveHost = host;\n+        }\n+        assert !effectiveHost.isEmpty() : \"unexpected URI host: \" + host;\n+        int port = uri.getPort();\n+        if (port == -1) {\n+            port = switch (lcaseScheme) {\n+                case \"http\" -> 80;\n+                case \"https\" -> 443;\n+                \/\/ we have already verified that this is a valid scheme, so this\n+                \/\/ should never happen\n+                default -> throw new AssertionError(\"Unsupported scheme: \" + scheme);\n+            };\n+        }\n+        return new Origin(lcaseScheme, effectiveHost, port);\n+    }\n+\n+    static String toAuthority(final String host, final int port) {\n+        assert port > 0 : \"invalid port: \" + port;\n+        \/\/ borrowed from code in java.net.URI\n+        final boolean needBrackets = host.indexOf(':') >= 0\n+                && !host.startsWith(\"[\")\n+                && !host.endsWith(\"]\");\n+        if (needBrackets) {\n+            return \"[\" + host + \"]:\" + port;\n+        }\n+        return host + \":\" + port;\n+    }\n+\n+    private static boolean isValidScheme(final String scheme) {\n+        \/\/ only \"http\" and \"https\" literals allowed\n+        return \"http\".equals(scheme) || \"https\".equals(scheme);\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Origin.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -313,2 +313,3 @@\n-    PlainHttpConnection(InetSocketAddress addr, HttpClientImpl client, String label) {\n-        super(addr, client, label);\n+    PlainHttpConnection(Origin originServer, InetSocketAddress addr, HttpClientImpl client,\n+                        String label) {\n+        super(originServer, addr, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n-        super(proxy, client, label);\n+        \/\/ we don't track the origin server for a plain proxy connection, since it\n+        \/\/ can be used to serve requests against several different origin servers.\n+        super(null, proxy, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainProxyConnection.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-    protected PlainTunnelingConnection(InetSocketAddress addr,\n+    protected PlainTunnelingConnection(Origin originServer,\n+                                       InetSocketAddress addr,\n@@ -59,1 +60,1 @@\n-        super(addr, client, label);\n+        super(originServer, addr, client, label);\n@@ -62,1 +63,1 @@\n-        delegate = new PlainHttpConnection(proxy, client, label);\n+        delegate = new PlainHttpConnection(originServer, proxy, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.net.URI;\n@@ -76,1 +75,0 @@\n-import sun.net.util.IPAddressUtil;\n@@ -81,1 +79,0 @@\n-import static java.util.stream.Collectors.joining;\n@@ -490,33 +487,0 @@\n-    public record ServerName (String name, boolean isLiteral) {\n-    }\n-\n-    \/**\n-     * Analyse the given address and determine if it is literal or not,\n-     * returning the address in String form.\n-     *\/\n-    public static ServerName getServerName(InetSocketAddress addr) {\n-        String host = addr.getHostString();\n-        byte[] literal = IPAddressUtil.textToNumericFormatV4(host);\n-        if (literal == null) {\n-            \/\/ not IPv4 literal. Check IPv6\n-            literal = IPAddressUtil.textToNumericFormatV6(host);\n-            return new ServerName(host, literal != null);\n-        } else {\n-            return new ServerName(host, true);\n-        }\n-    }\n-\n-    private static boolean isLoopbackLiteral(byte[] bytes) {\n-        if (bytes.length == 4) {\n-            return bytes[0] == 127;\n-        } else if (bytes.length == 16) {\n-            for (int i=0; i<14; i++)\n-                if (bytes[i] != 0)\n-                    return false;\n-            if (bytes[15] != 1)\n-                return false;\n-            return true;\n-        } else\n-            throw new InternalError();\n-    }\n-\n@@ -898,27 +862,0 @@\n-    \/**\n-     * Return the host string from a HttpRequestImpl\n-     *\n-     * @param request\n-     * @return\n-     *\/\n-    public static String hostString(HttpRequestImpl request) {\n-        URI uri = request.uri();\n-        int port = uri.getPort();\n-        String host = uri.getHost();\n-\n-        boolean defaultPort;\n-        if (port == -1) {\n-            defaultPort = true;\n-        } else if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n-            defaultPort = port == 443;\n-        } else {\n-            defaultPort = port == 80;\n-        }\n-\n-        if (defaultPort) {\n-            return host;\n-        } else {\n-            return host + \":\" + port;\n-        }\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":1,"deletions":64,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.net.URI;\n@@ -462,1 +463,3 @@\n-            super(address, impl, \"testConn-\" + IDS.incrementAndGet());\n+            final Origin originServer = Origin.from(\n+                    URI.create(\"http:\/\/\"+ address.getHostString() + \":\" + address.getPort()));\n+            super(originServer, address, impl, \"testConn-\" + IDS.incrementAndGet());\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/ConnectionPoolTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}