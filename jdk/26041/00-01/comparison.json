{"files":[{"patch":"@@ -44,1 +44,1 @@\n-import static jdk.internal.net.http.common.Utils.ServerName;\n+import sun.net.util.IPAddressUtil;\n@@ -66,0 +66,4 @@\n+\n+    private record ServerName(String name, boolean isLiteral) {\n+    }\n+\n@@ -77,1 +81,0 @@\n-                               ServerName serverName, int port,\n@@ -81,0 +84,2 @@\n+        assert originServer != null : \"origin server is null\";\n+        final ServerName serverName = getServerName(originServer);\n@@ -85,1 +90,1 @@\n-        engine = createEngine(context, serverName.name(), port, sslParameters);\n+        engine = createEngine(context, serverName.name(), originServer.port(), sslParameters);\n@@ -191,0 +196,17 @@\n+    \/**\n+     * Analyse the given {@linkplain Origin origin server} and determine\n+     * if the origin server's host is a literal or not, returning the server's\n+     * address in String form.\n+     *\/\n+    private static ServerName getServerName(final Origin originServer) {\n+        final String host = originServer.host();\n+        byte[] literal = IPAddressUtil.textToNumericFormatV4(host);\n+        if (literal == null) {\n+            \/\/ not IPv4 literal. Check IPv6\n+            literal = IPAddressUtil.textToNumericFormatV6(host);\n+            return new ServerName(host, literal != null);\n+        } else {\n+            return new ServerName(host, true);\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AbstractAsyncSSLConnection.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        super(originServer, addr, client, Utils.getServerName(addr), addr.getPort(), alpn, label);\n+        super(originServer, addr, client, alpn, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        super(originServer, addr, client, Utils.getServerName(addr), addr.getPort(), alpn, label);\n+        super(originServer, addr, client, alpn, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLTunnelConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,3 +37,5 @@\n- *               this is actually a scheme.\n- * @param host   The host of the origin\n- * @param port   The port of the origin\n+ *               this is actually a scheme. Only {@code http} and {@code https} literals are\n+ *               supported. Cannot be null.\n+ * @param host   The host of the origin. If the host is an IPv6 address, then it must not be\n+ *               enclosed in square brackets ({@code '['} and {@code ']'}). Cannot be null.\n+ * @param port   The port of the origin. Must be greater than 0.\n@@ -45,0 +47,3 @@\n+        if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\n+            throw new IllegalArgumentException(\"Invalid host: \" + host);\n+        }\n@@ -46,1 +51,4 @@\n-            throw new IllegalArgumentException(\"Invalid port\");\n+            throw new IllegalArgumentException(\"Invalid port: \" + port);\n+        }\n+        if (!isValidScheme(scheme)) {\n+            throw new IllegalArgumentException(\"Unsupported scheme: \" + scheme);\n@@ -68,0 +76,4 @@\n+        final String lcaseScheme = scheme.toLowerCase(Locale.ROOT);\n+        if (!isValidScheme(lcaseScheme)) {\n+            throw new IllegalArgumentException(\"Unsupported scheme: \" + scheme);\n+        }\n@@ -72,0 +84,8 @@\n+        final String effectiveHost;\n+        if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\n+            \/\/ strip the square brackets from IPv6 host\n+            effectiveHost = host.substring(1, host.length() - 1);\n+        } else {\n+            effectiveHost = host;\n+        }\n+        assert !effectiveHost.isEmpty() : \"unexpected URI host: \" + host;\n@@ -74,1 +94,1 @@\n-            port = switch (scheme.toLowerCase(Locale.ROOT)) {\n+            port = switch (lcaseScheme) {\n@@ -77,1 +97,3 @@\n-                default -> throw new IllegalArgumentException(\"Unsupported scheme: \" + scheme);\n+                \/\/ we have already verified that this is a valid scheme, so this\n+                \/\/ should never happen\n+                default -> throw new AssertionError(\"Unsupported scheme: \" + scheme);\n@@ -80,1 +102,1 @@\n-        return new Origin(scheme, host, port);\n+        return new Origin(lcaseScheme, effectiveHost, port);\n@@ -94,1 +116,6 @@\n-}\n\\ No newline at end of file\n+\n+    private static boolean isValidScheme(final String scheme) {\n+        \/\/ only \"http\" and \"https\" literals allowed\n+        return \"http\".equals(scheme) || \"https\".equals(scheme);\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Origin.java","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.net.URI;\n@@ -76,1 +75,0 @@\n-import sun.net.util.IPAddressUtil;\n@@ -81,1 +79,0 @@\n-import static java.util.stream.Collectors.joining;\n@@ -490,33 +487,0 @@\n-    public record ServerName (String name, boolean isLiteral) {\n-    }\n-\n-    \/**\n-     * Analyse the given address and determine if it is literal or not,\n-     * returning the address in String form.\n-     *\/\n-    public static ServerName getServerName(InetSocketAddress addr) {\n-        String host = addr.getHostString();\n-        byte[] literal = IPAddressUtil.textToNumericFormatV4(host);\n-        if (literal == null) {\n-            \/\/ not IPv4 literal. Check IPv6\n-            literal = IPAddressUtil.textToNumericFormatV6(host);\n-            return new ServerName(host, literal != null);\n-        } else {\n-            return new ServerName(host, true);\n-        }\n-    }\n-\n-    private static boolean isLoopbackLiteral(byte[] bytes) {\n-        if (bytes.length == 4) {\n-            return bytes[0] == 127;\n-        } else if (bytes.length == 16) {\n-            for (int i=0; i<14; i++)\n-                if (bytes[i] != 0)\n-                    return false;\n-            if (bytes[15] != 1)\n-                return false;\n-            return true;\n-        } else\n-            throw new InternalError();\n-    }\n-\n@@ -898,27 +862,0 @@\n-    \/**\n-     * Return the host string from a HttpRequestImpl\n-     *\n-     * @param request\n-     * @return\n-     *\/\n-    public static String hostString(HttpRequestImpl request) {\n-        URI uri = request.uri();\n-        int port = uri.getPort();\n-        String host = uri.getHost();\n-\n-        boolean defaultPort;\n-        if (port == -1) {\n-            defaultPort = true;\n-        } else if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n-            defaultPort = port == 443;\n-        } else {\n-            defaultPort = port == 80;\n-        }\n-\n-        if (defaultPort) {\n-            return host;\n-        } else {\n-            return host + \":\" + port;\n-        }\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":1,"deletions":64,"binary":false,"changes":65,"status":"modified"}]}