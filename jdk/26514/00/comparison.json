{"files":[{"patch":"@@ -0,0 +1,931 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotMapLogger.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+bool AOTMapLogger::_is_logging_at_bootstrap;\n+bool AOTMapLogger::_is_runtime_logging;\n+intx AOTMapLogger::_buffer_to_requested_delta;\n+intx AOTMapLogger::_requested_to_mapped_metadata_delta;\n+size_t AOTMapLogger::_num_root_segments;\n+size_t AOTMapLogger::_num_obj_arrays_logged;\n+GrowableArrayCHeap<AOTMapLogger::FakeOop, mtClass>* AOTMapLogger::_roots;\n+ArchiveHeapInfo* AOTMapLogger::_dumptime_heap_info;\n+\n+class AOTMapLogger::RequestedMetadataAddr {\n+  address _raw_addr;\n+\n+public:\n+  RequestedMetadataAddr(address raw_addr) : _raw_addr(raw_addr) {}\n+\n+  address raw_addr() const { return _raw_addr; }\n+\n+  Klass* to_real_klass() const {\n+    if (_raw_addr == nullptr) {\n+      return nullptr;\n+    }\n+\n+    if (_is_runtime_logging) {\n+      return (Klass*)(_raw_addr + _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      address buffered_addr = builder->requested_to_buffered(_raw_addr);\n+      address klass = builder->get_source_addr(buffered_addr);\n+      return (Klass*)klass;\n+    }\n+  }\n+}; \/\/ AOTMapLogger::RequestedMetadataAddr\n+\n+void AOTMapLogger::ergo_initialize() {\n+  if (!CDSConfig::is_dumping_archive() && CDSConfig::is_using_archive() && log_is_enabled(Info, aot, map)) {\n+    _is_logging_at_bootstrap = true;\n+    if (FLAG_IS_DEFAULT(ArchiveRelocationMode)) {\n+      FLAG_SET_ERGO(ArchiveRelocationMode, 0);\n+    } else if (ArchiveRelocationMode != 0) {\n+      log_warning(aot, map)(\"Addresses in the AOT map may be incorrect for -XX:ArchiveRelocationMode=%d.\", ArchiveRelocationMode);\n+    }\n+  }\n+}\n+\n+void AOTMapLogger::dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                                ArchiveHeapInfo* heap_info,\n+                                char* bitmap, size_t bitmap_size_in_bytes) {\n+  _is_runtime_logging = false;\n+  _buffer_to_requested_delta =  ArchiveBuilder::current()->buffer_to_requested_delta();\n+  _num_root_segments = mapinfo->heap_root_segments().count();\n+  _dumptime_heap_info = heap_info;\n+\n+  log_file_header(mapinfo);\n+\n+  DumpRegion* rw_region = &builder->_rw_region;\n+  DumpRegion* ro_region = &builder->_ro_region;\n+\n+  dumptime_log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n+  dumptime_log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n+\n+  address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n+  log_region_range(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n+  log_as_hex((address)bitmap, bitmap_end, nullptr);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (heap_info->is_used()) {\n+    dumptime_log_heap_region(heap_info);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of AOT cache map]\");\n+}\n+\n+\/\/ This class is used to find the location and type of all the\n+\/\/ archived metaspace objects.\n+class AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs : public UniqueMetaspaceClosure {\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass> _objs;\n+\n+  static int compare_objs_by_addr(ArchivedObjInfo* a, ArchivedObjInfo* b) {\n+    intx diff = a->_src_addr - b->_src_addr;\n+    if (diff < 0) {\n+      return -1;\n+    } else if (diff == 0) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  }\n+\n+public:\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs() { return &_objs; }\n+\n+  virtual bool do_unique_ref(Ref* ref, bool read_only) {\n+    ArchivedObjInfo info;\n+    info._src_addr = ref->obj();\n+    info._buffered_addr = ref->obj();\n+    info._requested_addr = ref->obj();\n+    info._bytes = ref->size() * BytesPerWord;\n+    info._type = ref->msotype();\n+    _objs.append(info);\n+\n+    return true; \/\/ keep iterating\n+  }\n+\n+  void finish() {\n+    UniqueMetaspaceClosure::finish();\n+    _objs.sort(compare_objs_by_addr);\n+  }\n+}; \/\/ AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo) {\n+  _is_runtime_logging = true;\n+  _requested_to_mapped_metadata_delta = static_mapinfo->relocation_delta();\n+\n+  ResourceMark rm;\n+  RuntimeGatherArchivedMetaspaceObjs gatherer;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    \/\/ The metaspace objects in the AOT cache are stored as a stream of bytes. For space\n+    \/\/ saving, we don't store a complete index that tells us where one object ends and\n+    \/\/ another object starts. There's also no type information.\n+    \/\/\n+    \/\/ However, we can rebuild our index by iterating over all the objects using\n+    \/\/ MetaspaceClosure, starting from the dictionary of Klasses in SystemDictionaryShared.\n+    GrowableArray<Klass*> klasses;\n+    SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/true, &klasses);\n+    if (dynamic_mapinfo != nullptr) {\n+      SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/false, &klasses);\n+    }\n+\n+    for (int i = 0; i < klasses.length(); i++) {\n+      gatherer.push(klasses.adr_at(i));\n+    }\n+    gatherer.finish();\n+  }\n+\n+  runtime_log(static_mapinfo, gatherer.objs());\n+  if (dynamic_mapinfo != nullptr) {\n+    runtime_log(dynamic_mapinfo, gatherer.objs());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  log_file_header(mapinfo);\n+\n+  runtime_log_metaspace_regions(mapinfo, objs);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (mapinfo->has_heap_region()) {\n+    _num_root_segments = mapinfo->heap_root_segments().count();\n+    runtime_log_heap_region(mapinfo);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of map]\");\n+}\n+\n+void AOTMapLogger::dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                                 const ArchiveBuilder::SourceObjList* src_objs) {\n+  address region_base = address(region->base());\n+  address region_top  = address(region->top());\n+  log_region_range(name, region_base, region_top, region_base + _buffer_to_requested_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    GrowableArrayCHeap<ArchivedObjInfo, mtClass> objs;\n+    for (int i = 0; i < src_objs->objs()->length(); i++) {\n+      ArchiveBuilder::SourceObjInfo* src_info = src_objs->at(i);\n+      ArchivedObjInfo info;\n+      info._src_addr = src_info->source_addr();\n+      info._buffered_addr = src_info->buffered_addr();\n+      info._requested_addr = info._buffered_addr + _buffer_to_requested_delta;\n+      info._bytes = src_info->size_in_bytes();\n+      info._type = src_info->msotype();\n+      objs.append(info);\n+    }\n+\n+    log_metaspace_objects_impl(address(region->base()), address(region->end()), &objs, 0, objs.length());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  FileMapRegion* rw = mapinfo->region_at(MetaspaceShared::rw);\n+  FileMapRegion* ro = mapinfo->region_at(MetaspaceShared::ro);\n+\n+  address rw_base = address(rw->mapped_base());\n+  address rw_end  = address(rw->mapped_end());\n+  address ro_base = address(ro->mapped_base());\n+  address ro_end  = address(ro->mapped_end());\n+\n+  int first_rw_index = -1;\n+  int first_ro_index = -1;\n+  int last_ro_index = -1;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    int i = 0;\n+    for (; i < objs->length(); i++) {\n+      address p = objs->at(i)._src_addr;\n+      if (p < rw_base) {\n+        \/\/ We are printing the dynamic archive but found an object in the static archive\n+        precond(!mapinfo->is_static());\n+        continue;\n+      }\n+      if (first_rw_index < 0) {\n+        first_rw_index = i;\n+        continue;\n+      }\n+      if (p < ro_base) {\n+        continue;\n+      }\n+      if (first_ro_index < 0) {\n+        first_ro_index = i;\n+        continue;\n+      }\n+      if (p < ro_end) {\n+        continue;\n+      } else {\n+        precond(mapinfo->is_static());\n+        last_ro_index = i;\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (last_ro_index < 0) {\n+    last_ro_index = objs->length();\n+  }\n+\n+  log_region_range(\"rw\", rw_base, rw_end, rw_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(rw_base, rw_end, objs, first_rw_index, first_ro_index);\n+  }\n+\n+  log_region_range(\"ro\", ro_base, ro_end, ro_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(ro_base, ro_end, objs, first_ro_index, last_ro_index);\n+  }\n+}\n+\n+void AOTMapLogger::log_file_header(FileMapInfo* mapinfo) {\n+  const char* type;\n+  if (mapinfo->is_static()) {\n+    if (CDSConfig::new_aot_flags_used()) {\n+      type = \"AOT cache\";\n+    } else {\n+      type = \"Static CDS archive\";\n+    }\n+  } else {\n+    type = \"Dynamic CDS archive\";\n+  }\n+\n+  log_info(aot, map)(\"%s map for %s\", type, mapinfo->full_path());\n+\n+  address header = address(mapinfo->header());\n+  address header_end = header + mapinfo->header()->header_size();\n+\n+  log_region_range(\"header\", header, header_end, nullptr);\n+  LogStreamHandle(Info, aot, map) lsh;\n+  mapinfo->print(&lsh);\n+  log_as_hex(header, header_end, nullptr);\n+}\n+\n+\/\/ Log information about a region, whose address at dump time is [base .. top). At\n+\/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n+\/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n+\/\/ be accessed with os::read (the header).\n+void AOTMapLogger::log_region_range(const char* name, address base, address top, address requested_base) {\n+  size_t size = top - base;\n+  base = requested_base;\n+  if (requested_base == nullptr) {\n+    top = (address)size;\n+  } else {\n+    top = requested_base + size;\n+  }\n+  log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n+                     name, p2i(base), p2i(top), size);\n+}\n+\n+#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n+\n+void AOTMapLogger::log_metaspace_objects_impl(address region_base, address region_end, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs,\n+                                              int start_idx, int end_idx) {\n+  address last_obj_base = region_base;\n+  address last_obj_end  = region_base;\n+  Thread* current = Thread::current();\n+\n+  for (int i = start_idx; i < end_idx; i++) {\n+    ArchivedObjInfo& info = objs->at(i);\n+    address src = info._src_addr;\n+    address buffered_addr = info._buffered_addr;\n+    address requested_addr = info._requested_addr;\n+    int bytes = info._bytes;\n+    MetaspaceObj::Type type = info._type;\n+    const char* type_name = MetaspaceObj::type_name(type);\n+\n+    log_as_hex(last_obj_base, buffered_addr, last_obj_base + _buffer_to_requested_delta);\n+\n+    switch (type) {\n+    case MetaspaceObj::ClassType:\n+      log_klass((Klass*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolType:\n+      log_constant_pool((ConstantPool*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolCacheType:\n+      log_constant_pool_cache((ConstantPoolCache*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstMethodType:\n+      log_const_method((ConstMethod*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::MethodType:\n+      log_method((Method*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::SymbolType:\n+      log_symbol((Symbol*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    default:\n+      log_debug(aot, map)(_LOG_PREFIX, p2i(requested_addr), type_name, bytes);\n+      break;\n+    }\n+\n+    last_obj_base = buffered_addr;\n+    last_obj_end  = buffered_addr + bytes;\n+  }\n+\n+  log_as_hex(last_obj_base, last_obj_end, last_obj_base + _buffer_to_requested_delta);\n+  if (last_obj_end < region_end) {\n+    log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n+                        p2i(last_obj_end + _buffer_to_requested_delta),\n+                        size_t(region_end - last_obj_end));\n+    log_as_hex(last_obj_end, region_end, last_obj_end + _buffer_to_requested_delta);\n+  }\n+}\n+\n+void AOTMapLogger::log_constant_pool(ConstantPool* cp, address requested_addr,\n+                                     const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cp->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                           const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cpc->constant_pool()->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_const_method(ConstMethod* cm, address requested_addr, const char* type_name,\n+                                    int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  cm->method()->external_name());\n+}\n+\n+void AOTMapLogger::log_klass(Klass* k, address requested_addr, const char* type_name,\n+                             int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes, k->external_name());\n+}\n+\n+void AOTMapLogger::log_method(Method* m, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  m->external_name());\n+}\n+\n+void AOTMapLogger::log_symbol(Symbol* s, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      s->as_quoted_ascii());\n+}\n+\n+#undef _LOG_PREFIX\n+\n+\/\/ Log all the data [base...top). Pretend that the base address\n+\/\/ will be mapped to requested_base at run-time.\n+void AOTMapLogger::log_as_hex(address base, address top, address requested_base, bool is_heap) {\n+  assert(top >= base, \"must be\");\n+\n+  LogStreamHandle(Trace, aot, map) lsh;\n+  if (lsh.is_enabled()) {\n+    int unitsize = sizeof(address);\n+    if (is_heap && UseCompressedOops) {\n+      \/\/ This makes the compressed oop pointers easier to read, but\n+      \/\/ longs and doubles will be split into two words.\n+      unitsize = sizeof(narrowOop);\n+    }\n+    os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n+  }\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\/\/ FakeOop (and subclasses FakeMirror, FakeString, FakeObjArray, FakeTypeArray) are used to traverse\n+\/\/ and print the (image of) heap objects stored in the AOT cache. These objects are different than regular oops:\n+\/\/ - They do not reside inside the range of the heap.\n+\/\/ - For +UseCompressedOops: pointers may use a different narrowOop encoding: see FakeOop::read_oop_at(narrowOop*)\n+\/\/ - For -UseCompressedOops: pointers are not direct: see FakeOop::read_oop_at(oop*)\n+\/\/\n+\/\/ Hence, in general, we cannot use regular oop API (such as oopDesc::obj_field()) on these objects. There\n+\/\/ are a few rare case where regular oop API work, but these are all guarded with the raw_oop() method and\n+\/\/ should be used with care.\n+class AOTMapLogger::FakeOop {\n+  static int _requested_shift;\n+  static intx _buffer_to_requested_delta;\n+  static address _buffer_start;\n+  static address _buffer_end;\n+  static uint64_t _buffer_start_narrow_oop; \/\/ The encoded narrow oop for the objects at _buffer_start\n+\n+  address _buffer_addr;\n+\n+  static void assert_range(address buffer_addr) {\n+    assert(_buffer_start <= buffer_addr && buffer_addr < _buffer_end, \"range check\");\n+  }\n+\n+  address* field_addr(int field_offset) {\n+    return (address*)(_buffer_addr + field_offset);\n+  }\n+\n+protected:\n+  RequestedMetadataAddr metadata_field(int field_offset) {\n+    return RequestedMetadataAddr(*(address*)(field_addr(field_offset)));\n+  }\n+\n+  \/\/ Return an \"oop\" pointer so we can use APIs that accept regular oops. This\n+  \/\/ must be used with care, as only a limited number of APIs can work with oops that\n+  \/\/ live outside of the range of the heap.\n+  oop raw_oop() { return cast_to_oop(_buffer_addr); }\n+\n+public:\n+  static void init_globals(address requested_base, address requested_start, int requested_shift,\n+                           address buffer_start, address buffer_end) {\n+    _requested_shift = requested_shift;\n+    _buffer_to_requested_delta = requested_start - buffer_start;\n+    _buffer_start = buffer_start;\n+    _buffer_end = buffer_end;\n+\n+    precond(requested_start >= requested_base);\n+    if (UseCompressedOops) {\n+      _buffer_start_narrow_oop = (uint64_t)(pointer_delta(requested_start, requested_base, 1)) >> _requested_shift;\n+      assert(_buffer_start_narrow_oop < 0xffffffff, \"sanity\");\n+    } else {\n+      _buffer_start_narrow_oop = 0xdeadbeed;\n+    }\n+  }\n+\n+  FakeOop() : _buffer_addr(nullptr) {}\n+\n+  FakeOop(address buffer_addr) : _buffer_addr(buffer_addr) {\n+    if (_buffer_addr != nullptr) {\n+      assert_range(_buffer_addr);\n+    }\n+  }\n+\n+  FakeMirror& as_mirror();\n+  FakeObjArray& as_obj_array();\n+  FakeString& as_string();\n+  FakeTypeArray& as_type_array();\n+\n+  RequestedMetadataAddr klass() {\n+    address rk = (address)real_klass();\n+    if (_is_runtime_logging) {\n+      return RequestedMetadataAddr(rk - _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      return builder->to_requested(builder->get_buffered_addr(rk));\n+    }\n+  }\n+\n+  Klass* real_klass() {\n+    assert(UseCompressedClassPointers, \"heap archiving requires UseCompressedClassPointers\");\n+    if (_is_runtime_logging) {\n+      return raw_oop()->klass();\n+    } else {\n+      return ArchiveHeapWriter::real_klass_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  \/\/ in heap words\n+  size_t size() {\n+    if (_is_runtime_logging) {\n+      return raw_oop()->size_given_klass(real_klass());\n+    } else {\n+      return ArchiveHeapWriter::size_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  bool is_array() { return real_klass()->is_array_klass(); }\n+  bool is_null() { return _buffer_addr == nullptr; }\n+\n+  int array_length() {\n+    precond(is_array());\n+    return arrayOop(raw_oop())->length();\n+  }\n+\n+  address requested_addr() {\n+    return _buffer_addr + _buffer_to_requested_delta;\n+  }\n+\n+  uint32_t as_narrow_oop_value() {\n+    precond(UseCompressedOops);\n+    if (_buffer_addr == nullptr) {\n+      return 0;\n+    }\n+    uint64_t pd = (uint64_t)(pointer_delta(_buffer_addr, _buffer_start, 1));\n+    return checked_cast<uint32_t>(_buffer_start_narrow_oop + (pd >> _requested_shift));\n+  }\n+\n+  FakeOop read_oop_at(narrowOop* addr) { \/\/ +UseCompressedOops\n+    uint64_t n = (uint64_t)(*addr);\n+    if (n == 0) {\n+      return FakeOop(nullptr);\n+    } else {\n+      precond(n >= _buffer_start_narrow_oop);\n+      address value = _buffer_start + ((n - _buffer_start_narrow_oop) << _requested_shift);\n+      return FakeOop(value);\n+    }\n+  }\n+\n+  FakeOop read_oop_at(oop* addr) { \/\/ -UseCompressedOops\n+    address requested_value = cast_from_oop<address>(*addr);\n+    if (requested_value == nullptr) {\n+      return FakeOop(nullptr);\n+    } else {\n+      return FakeOop(requested_value - _buffer_to_requested_delta);\n+    }\n+  }\n+\n+  FakeOop obj_field(int field_offset) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_oop()->field_addr<narrowOop>(field_offset));\n+    } else {\n+      return read_oop_at(raw_oop()->field_addr<oop>(field_offset));\n+    }\n+  }\n+\n+  void print_non_oop_field(outputStream* st, fieldDescriptor* fd) {\n+    \/\/ fd->print_on_for() works for non-oop fields in fake oops\n+    precond(fd->field_type() != T_ARRAY && fd->field_type() != T_OBJECT);\n+    fd->print_on_for(st, raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeOop\n+\n+class AOTMapLogger::FakeMirror : public AOTMapLogger::FakeOop {\n+public:\n+  void print_class_signature_on(outputStream* st);\n+\n+  Klass* real_mirrored_klass() {\n+    RequestedMetadataAddr mirrored_klass = metadata_field(java_lang_Class::klass_offset());\n+    return mirrored_klass.to_real_klass();\n+  }\n+\n+  int static_oop_field_count() {\n+    return java_lang_Class::static_oop_field_count(raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeMirror\n+\n+class AOTMapLogger::FakeObjArray : public AOTMapLogger::FakeOop {\n+  objArrayOop raw_objArrayOop() {\n+    return (objArrayOop)raw_oop();\n+  }\n+\n+public:\n+  int length() {\n+    return raw_objArrayOop()->length();\n+  }\n+  FakeOop obj_at(int i) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<narrowOop>(i));\n+    } else {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<oop>(i));\n+    }\n+  }\n+}; \/\/ AOTMapLogger::FakeObjArray\n+\n+class AOTMapLogger::FakeString : public AOTMapLogger::FakeOop {\n+public:\n+  bool is_latin1() {\n+    jbyte coder = raw_oop()->byte_field(java_lang_String::coder_offset());\n+    assert(CompactStrings || coder == java_lang_String::CODER_UTF16, \"Must be UTF16 without CompactStrings\");\n+    return coder == java_lang_String::CODER_LATIN1;\n+  }\n+\n+  FakeTypeArray value();\n+\n+  int length();\n+  void print_on(outputStream* st, int max_length = MaxStringPrintSize);\n+}; \/\/ AOTMapLogger::FakeString\n+\n+class AOTMapLogger::FakeTypeArray : public AOTMapLogger::FakeOop {\n+  typeArrayOop raw_typeArrayOop() {\n+    return (typeArrayOop)raw_oop();\n+  }\n+\n+public:\n+  void print_elements_on(outputStream* st) {\n+    TypeArrayKlass::cast(real_klass())->oop_print_elements_on(raw_typeArrayOop(), st);\n+  }\n+\n+  int length() { return raw_typeArrayOop()->length(); }\n+  jbyte byte_at(int i) { return raw_typeArrayOop()->byte_at(i); }\n+  jchar char_at(int i) { return raw_typeArrayOop()->char_at(i); }\n+}; \/\/ AOTMapLogger::FakeTypeArray\n+\n+AOTMapLogger::FakeMirror& AOTMapLogger::FakeOop::as_mirror() {\n+  precond(real_klass() == vmClasses::Class_klass());\n+  return (FakeMirror&)*this;\n+}\n+\n+AOTMapLogger::FakeObjArray& AOTMapLogger::FakeOop::as_obj_array() {\n+  precond(real_klass()->is_objArray_klass());\n+  return (FakeObjArray&)*this;\n+}\n+\n+AOTMapLogger::FakeTypeArray& AOTMapLogger::FakeOop::as_type_array() {\n+  precond(real_klass()->is_typeArray_klass());\n+  return (FakeTypeArray&)*this;\n+}\n+\n+AOTMapLogger::FakeString& AOTMapLogger::FakeOop::as_string() {\n+  precond(real_klass() == vmClasses::String_klass());\n+  return (FakeString&)*this;\n+}\n+\n+void AOTMapLogger::FakeMirror::print_class_signature_on(outputStream* st) {\n+  ResourceMark rm;\n+  RequestedMetadataAddr requested_klass = metadata_field(java_lang_Class::klass_offset());\n+  Klass* real_klass = requested_klass.to_real_klass();\n+\n+  if (real_klass == nullptr) {\n+    \/\/ This is a primitive mirror (Java expressions of int.class, long.class, void.class, etc);\n+    RequestedMetadataAddr requested_array_klass = metadata_field(java_lang_Class::array_klass_offset());\n+    Klass* real_array_klass = requested_array_klass.to_real_klass();\n+    if (real_array_klass == nullptr) {\n+      st->print(\" V\"); \/\/ The special mirror for void.class that doesn't have any representation in C++\n+    } else {\n+      precond(real_array_klass->is_typeArray_klass());\n+      st->print(\" %c\", real_array_klass->name()->char_at(1));\n+    }\n+  } else {\n+    const char* class_name = real_klass->name()->as_C_string();\n+    if (real_klass->is_instance_klass()) {\n+      st->print(\" L%s;\", class_name);\n+    } else {\n+      st->print(\" %s\", class_name);\n+    }\n+    if (real_klass->has_aot_initialized_mirror()) {\n+      st->print(\" (aot-inited)\");\n+    }\n+  }\n+}\n+\n+AOTMapLogger::FakeTypeArray AOTMapLogger::FakeString::value() {\n+  return obj_field(java_lang_String::value_offset()).as_type_array();\n+}\n+\n+int AOTMapLogger::FakeString::length() {\n+  FakeTypeArray v = value();\n+  if (v.is_null()) {\n+    return 0;\n+  }\n+  int arr_length = v.length();\n+  if (!is_latin1()) {\n+    assert((arr_length & 1) == 0, \"should be even for UTF16 string\");\n+    arr_length >>= 1; \/\/ convert number of bytes to number of elements\n+  }\n+  return arr_length;\n+}\n+\n+void AOTMapLogger::FakeString::print_on(outputStream* st, int max_length) {\n+  FakeTypeArray v = value();\n+  int length = this->length();\n+  bool is_latin1 = this->is_latin1();\n+  bool abridge = length > max_length;\n+\n+  st->print(\"\\\"\");\n+  for (int index = 0; index < length; index++) {\n+    \/\/ If we need to abridge and we've printed half the allowed characters\n+    \/\/ then jump to the tail of the string.\n+    if (abridge && index >= max_length \/ 2) {\n+      st->print(\" ... (%d characters ommitted) ... \", length - 2 * (max_length \/ 2));\n+      index = length - (max_length \/ 2);\n+      abridge = false; \/\/ only do this once\n+    }\n+    jchar c = (!is_latin1) ?  v.char_at(index) :\n+                             ((jchar) v.byte_at(index)) & 0xff;\n+    if (c < ' ') {\n+      st->print(\"\\\\x%02X\", c); \/\/ print control characters e.g. \\x0A\n+    } else {\n+      st->print(\"%c\", c);\n+    }\n+  }\n+  st->print(\"\\\"\");\n+\n+  if (length > max_length) {\n+    st->print(\" (abridged) \");\n+  }\n+}\n+\n+class AOTMapLogger::ArchivedFieldPrinter : public FieldClosure {\n+  FakeOop _fake_oop;\n+  outputStream* _st;\n+public:\n+  ArchivedFieldPrinter(FakeOop fake_oop, outputStream* st) : _fake_oop(fake_oop), _st(st) {}\n+\n+  void do_field(fieldDescriptor* fd) {\n+    _st->print(\" - \");\n+    BasicType ft = fd->field_type();\n+    switch (ft) {\n+    case T_ARRAY:\n+    case T_OBJECT:\n+      {\n+        fd->print_on(_st); \/\/ print just the name and offset\n+        FakeOop field_value = _fake_oop.obj_field(fd->offset());\n+        print_oop_info_cr(_st, field_value);\n+      }\n+      break;\n+    default:\n+      _fake_oop.print_non_oop_field(_st, fd); \/\/ name, offset, value\n+      _st->cr();\n+    }\n+  }\n+}; \/\/ AOTMapLogger::ArchivedFieldPrinter\n+\n+int AOTMapLogger::FakeOop::_requested_shift;\n+intx AOTMapLogger::FakeOop::_buffer_to_requested_delta;\n+address AOTMapLogger::FakeOop::_buffer_start;\n+address AOTMapLogger::FakeOop::_buffer_end;\n+uint64_t AOTMapLogger::FakeOop::_buffer_start_narrow_oop;\n+\n+void AOTMapLogger::dumptime_log_heap_region(ArchiveHeapInfo* heap_info) {\n+  MemRegion r = heap_info->buffer_region();\n+  address buffer_start = address(r.start()); \/\/ start of the current oop inside the buffer\n+  address buffer_end = address(r.end());\n+\n+  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)ArchiveHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_start = UseCompressedOops ? ArchiveHeapWriter::buffered_addr_to_requested_addr(buffer_start) : requested_base;\n+  int requested_shift =  CompressedOops::shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::runtime_log_heap_region(FileMapInfo* mapinfo) {\n+  ResourceMark rm;\n+  int heap_region_index = MetaspaceShared::hp;\n+  FileMapRegion* r = mapinfo->region_at(heap_region_index);\n+  size_t alignment = ObjectAlignmentInBytes;\n+\n+  \/\/ Allocate a buffer and read the image of the archived heap region. This buffer is outside\n+  \/\/ of the real Java heap, so we must use FakeOop to access the contents of the archived heap objects.\n+  char* buffer = resource_allocate_bytes(r->used() + alignment);\n+  address buffer_start = (address)align_up(buffer, alignment);\n+  address buffer_end = buffer_start + r->used();\n+  if (!mapinfo->read_region(heap_region_index, (char*)buffer_start, r->used(), \/* do_commit = *\/ false)) {\n+    log_error(aot)(\"Cannot read heap region; AOT map logging of heap objects failed\");\n+    return;\n+  }\n+\n+  address requested_base = UseCompressedOops ? (address)mapinfo->narrow_oop_base() : mapinfo->heap_region_requested_address();\n+  address requested_start = requested_base + r->mapping_offset();\n+  int requested_shift = mapinfo->narrow_oop_shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::log_oops(address buffer_start, address buffer_end) {\n+  LogStreamHandle(Debug, aot, map) st;\n+  if (!st.is_enabled()) {\n+    return;\n+  }\n+\n+  _roots = new GrowableArrayCHeap<FakeOop, mtClass>();\n+  _num_obj_arrays_logged = 0;\n+\n+  for (address fop = buffer_start; fop < buffer_end; ) {\n+    FakeOop fake_oop(fop);\n+    st.print(PTR_FORMAT \": @@ Object \", p2i(fake_oop.requested_addr()));\n+    print_oop_info_cr(&st, fake_oop, \/*print_requested_addr=*\/false);\n+\n+    LogStreamHandle(Trace, aot, map, oops) trace_st;\n+    if (trace_st.is_enabled()) {\n+      print_oop_details(fake_oop, &trace_st);\n+    }\n+\n+    address next_fop = fop + fake_oop.size() * BytesPerWord;\n+    log_as_hex(fop, next_fop, fake_oop.requested_addr(), \/*is_heap=*\/true);\n+\n+    fop = next_fop;\n+  }\n+\n+  delete _roots;\n+}\n+\n+void AOTMapLogger::print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr) {\n+  if (fake_oop.is_null()) {\n+    st->print_cr(\"null\");\n+  } else {\n+    ResourceMark rm;\n+    Klass* real_klass = fake_oop.real_klass();\n+    address requested_addr = fake_oop.requested_addr();\n+    if (print_requested_addr) {\n+      st->print(PTR_FORMAT \" \", p2i(requested_addr));\n+    }\n+    if (UseCompressedOops) {\n+      st->print(\"(0x%08x) \", fake_oop.as_narrow_oop_value());\n+    }\n+    if (fake_oop.is_array()) {\n+      int array_len = fake_oop.array_length();\n+      st->print_cr(\"%s length: %d\", real_klass->external_name(), array_len);\n+    } else {\n+      st->print(\"%s\", real_klass->external_name());\n+\n+      if (real_klass == vmClasses::String_klass()) {\n+        st->print(\" \");\n+        fake_oop.as_string().print_on(st);\n+      } else if (real_klass == vmClasses::Class_klass()) {\n+        fake_oop.as_mirror().print_class_signature_on(st);\n+      }\n+\n+      st->cr();\n+    }\n+  }\n+}\n+\n+\/\/ Print the fields of instanceOops, or the elements of arrayOops\n+void AOTMapLogger::print_oop_details(FakeOop fake_oop, outputStream* st) {\n+  Klass* real_klass = fake_oop.real_klass();\n+\n+  st->print(\" - klass: \");\n+  real_klass->print_value_on(st);\n+  st->print(\" \" PTR_FORMAT, p2i(fake_oop.klass().raw_addr()));\n+  st->cr();\n+\n+  if (real_klass->is_typeArray_klass()) {\n+    fake_oop.as_type_array().print_elements_on(st);\n+  } else if (real_klass->is_objArray_klass()) {\n+    FakeObjArray fake_obj_array = fake_oop.as_obj_array();\n+    bool is_logging_root_segment = _num_obj_arrays_logged < _num_root_segments;\n+\n+    for (int i = 0; i < fake_obj_array.length(); i++) {\n+      FakeOop elm = fake_obj_array.obj_at(i);\n+      if (is_logging_root_segment) {\n+        st->print(\" root[%4d]: \", _roots->length());\n+        _roots->append(elm);\n+      } else {\n+        st->print(\" -%4d: \", i);\n+      }\n+      print_oop_info_cr(st, elm);\n+    }\n+    _num_obj_arrays_logged ++;\n+  } else {\n+    st->print_cr(\" - fields (%zu words):\", fake_oop.size());\n+\n+    ArchivedFieldPrinter print_field(fake_oop, st);\n+    InstanceKlass::cast(real_klass)->print_nonstatic_fields(&print_field);\n+\n+    if (real_klass == vmClasses::Class_klass()) {\n+      FakeMirror fake_mirror = fake_oop.as_mirror();\n+\n+      st->print(\" - signature: \");\n+      fake_mirror.print_class_signature_on(st);\n+      st->cr();\n+\n+      Klass* real_mirrored_klass = fake_mirror.real_mirrored_klass();\n+      if (real_mirrored_klass != nullptr && real_mirrored_klass->is_instance_klass()) {\n+        InstanceKlass* real_mirrored_ik = InstanceKlass::cast(real_mirrored_klass);\n+\n+        ConstantPoolCache* cp_cache = real_mirrored_ik->constants()->cache();\n+        if (!_is_runtime_logging) {\n+          cp_cache = ArchiveBuilder::current()->get_buffered_addr(cp_cache);\n+        }\n+        int rr_root_index = cp_cache->archived_references_index();\n+        st->print(\" - resolved_references: \");\n+        if (rr_root_index >= 0) {\n+          FakeOop resolved_references = _roots->at(rr_root_index);\n+          print_oop_info_cr(st, resolved_references);\n+        } else {\n+          st->print(\"null\");\n+        }\n+\n+        st->print_cr(\"- ---- static fields (%d):\", fake_mirror.static_oop_field_count());\n+        real_mirrored_ik->do_local_static_fields(&print_field);\n+      }\n+    }\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":931,"deletions":0,"binary":false,"changes":931,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTMAPLOGGER_HPP\n+#define SHARE_CDS_AOTMAPLOGGER_HPP\n+\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ArchiveHeapInfo;\n+class DumpRegion;\n+class FileMapInfo;\n+class outputStream;\n+\n+\/\/ Write detailed info to a mapfile to analyze contents of the AOT cache\/CDS archive.\n+\/\/ -Xlog:aot+map* can be used both when creating an AOT cache, or when using an AOT cache.\n+\/\/\n+\/\/ Creating cache:\n+\/\/     java -XX:AOTCacheOutput=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ Using cache:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ You can also print the map of a cache without executing the application by using the\n+\/\/ --version flag:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace --version\n+\/\/\n+\/\/ Because the output can be large, it's best to save it to a file\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace:file=aot.map:none:filesize=0 --version\n+class AOTMapLogger : AllStatic {\n+  struct ArchivedObjInfo {\n+    address _src_addr;\n+    address _buffered_addr;\n+    address _requested_addr;\n+    int _bytes;\n+    MetaspaceObj::Type _type;\n+  };\n+\n+  \/\/ FakeOop and subtypes\n+  class FakeOop;\n+  class   FakeMirror;\n+  class   FakeObjArray;\n+  class   FakeString;\n+  class   FakeTypeArray;\n+\n+  class RequestedMetadataAddr;\n+  class RuntimeGatherArchivedMetaspaceObjs;\n+\n+  static bool _is_logging_at_bootstrap;\n+  static bool _is_runtime_logging;\n+  static size_t _num_root_segments;\n+  static size_t _num_obj_arrays_logged;\n+  static GrowableArrayCHeap<FakeOop, mtClass>* _roots;\n+  static ArchiveHeapInfo* _dumptime_heap_info;\n+\n+  static intx _buffer_to_requested_delta;\n+  static intx _requested_to_mapped_metadata_delta;\n+\n+  static void runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                            const ArchiveBuilder::SourceObjList* src_objs);\n+\n+  \/\/ Common code for dumptime\/runtime\n+  static void log_file_header(FileMapInfo* mapinfo);\n+  static void log_region_range(const char* name, address base, address top, address requested_base);\n+  static void log_metaspace_objects_impl(address region_base, address region_end,\n+                                         GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs, int start_idx, int end_idx);\n+  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false);\n+\n+  \/\/ Metaspace object: type-specific logging\n+  static void log_constant_pool(ConstantPool* cp, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                      const char* type_name, int bytes, Thread* current);\n+  static void log_const_method(ConstMethod* cm, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_klass(Klass* k, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_method(Method* m, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_symbol(Symbol* s, address requested_addr, const char* type_name, int bytes, Thread* current);\n+\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static void dumptime_log_heap_region(ArchiveHeapInfo* heap_info);\n+  static void runtime_log_heap_region(FileMapInfo* mapinfo);\n+\n+  static void print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr = true);\n+  static void print_oop_details(FakeOop fake_oop, outputStream* st);\n+  static void log_oops(address buf_start, address buf_end);\n+  class ArchivedFieldPrinter; \/\/ to be replaced by ArchivedFieldPrinter2\n+#endif\n+\n+public:\n+  static void ergo_initialize();\n+  static bool is_logging_at_bootstrap() { return _is_logging_at_bootstrap; }\n+\n+  static void dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                           ArchiveHeapInfo* heap_info,\n+                           char* bitmap, size_t bitmap_size_in_bytes);\n+  static void runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTMAPLOGGER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.hpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -63,1 +63,0 @@\n-#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -1179,418 +1178,0 @@\n-\/\/ Write detailed info to a mapfile to analyze contents of the archive.\n-\/\/ static dump:\n-\/\/   java -Xshare:dump -Xlog:cds+map=trace:file=cds.map:none:filesize=0\n-\/\/ dynamic dump:\n-\/\/   java -cp MyApp.jar -XX:ArchiveClassesAtExit=MyApp.jsa \\\n-\/\/        -Xlog:cds+map=trace:file=cds.map:none:filesize=0 MyApp\n-\/\/\n-\/\/ We need to do some address translation because the buffers used at dump time may be mapped to\n-\/\/ a different location at runtime. At dump time, the buffers may be at arbitrary locations\n-\/\/ picked by the OS. At runtime, we try to map at a fixed location (SharedBaseAddress). For\n-\/\/ consistency, we log everything using runtime addresses.\n-class ArchiveBuilder::CDSMapLogger : AllStatic {\n-  static intx buffer_to_runtime_delta() {\n-    \/\/ Translate the buffers used by the RW\/RO regions to their eventual (requested) locations\n-    \/\/ at runtime.\n-    return ArchiveBuilder::current()->buffer_to_requested_delta();\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_region(const char* name, DumpRegion* region,\n-                                   const ArchiveBuilder::SourceObjList* src_objs) {\n-    address region_base = address(region->base());\n-    address region_top  = address(region->top());\n-    log_region(name, region_base, region_top, region_base + buffer_to_runtime_delta());\n-    log_metaspace_objects(region, src_objs);\n-  }\n-\n-#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n-\n-  static void log_klass(Klass* k, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes, k->external_name());\n-  }\n-  static void log_method(Method* m, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes,  m->external_name());\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_objects(DumpRegion* region, const ArchiveBuilder::SourceObjList* src_objs) {\n-    address last_obj_base = address(region->base());\n-    address last_obj_end  = address(region->base());\n-    address region_end    = address(region->end());\n-    Thread* current = Thread::current();\n-    for (int i = 0; i < src_objs->objs()->length(); i++) {\n-      SourceObjInfo* src_info = src_objs->at(i);\n-      address src = src_info->source_addr();\n-      address dest = src_info->buffered_addr();\n-      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n-      address runtime_dest = dest + buffer_to_runtime_delta();\n-      int bytes = src_info->size_in_bytes();\n-\n-      MetaspaceObj::Type type = src_info->msotype();\n-      const char* type_name = MetaspaceObj::type_name(type);\n-\n-      switch (type) {\n-      case MetaspaceObj::ClassType:\n-        log_klass((Klass*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolType:\n-        log_klass(((ConstantPool*)src)->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolCacheType:\n-        log_klass(((ConstantPoolCache*)src)->constant_pool()->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::MethodType:\n-        log_method((Method*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstMethodType:\n-        log_method(((ConstMethod*)src)->method(), runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::SymbolType:\n-        {\n-          ResourceMark rm(current);\n-          Symbol* s = (Symbol*)src;\n-          log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(runtime_dest), type_name, bytes,\n-                              s->as_quoted_ascii());\n-        }\n-        break;\n-      default:\n-        log_debug(aot, map)(_LOG_PREFIX, p2i(runtime_dest), type_name, bytes);\n-        break;\n-      }\n-\n-      last_obj_base = dest;\n-      last_obj_end  = dest + bytes;\n-    }\n-\n-    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n-    if (last_obj_end < region_end) {\n-      log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n-                          p2i(last_obj_end + buffer_to_runtime_delta()),\n-                          size_t(region_end - last_obj_end));\n-      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n-    }\n-  }\n-\n-#undef _LOG_PREFIX\n-\n-  \/\/ Log information about a region, whose address at dump time is [base .. top). At\n-  \/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n-  \/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n-  \/\/ be accessed with os::read (the header).\n-  \/\/\n-  \/\/ Note: across -Xshare:dump runs, base may be different, but requested_base should\n-  \/\/ be the same as the archive contents should be deterministic.\n-  static void log_region(const char* name, address base, address top, address requested_base) {\n-    size_t size = top - base;\n-    base = requested_base;\n-    if (requested_base == nullptr) {\n-      top = (address)size;\n-    } else {\n-      top = requested_base + size;\n-    }\n-    log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n-                       name, p2i(base), p2i(top), size);\n-  }\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static void log_heap_region(ArchiveHeapInfo* heap_info) {\n-    MemRegion r = heap_info->buffer_region();\n-    address start = address(r.start()); \/\/ start of the current oop inside the buffer\n-    address end = address(r.end());\n-    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n-\n-    LogStreamHandle(Info, aot, map) st;\n-\n-    HeapRootSegments segments = heap_info->heap_root_segments();\n-    assert(segments.base_offset() == 0, \"Sanity\");\n-\n-    for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print_cr(PTR_FORMAT \": Heap roots segment [%d]\",\n-                  p2i(requested_start), segments.size_in_elems(seg_idx));\n-      start += segments.size_in_bytes(seg_idx);\n-    }\n-    log_heap_roots();\n-\n-    while (start < end) {\n-      size_t byte_size;\n-      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n-\n-      if (source_oop != nullptr) {\n-        \/\/ This is a regular oop that got archived.\n-        \/\/ Don't print the requested addr again as we have just printed it at the beginning of the line.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffd27938: @@ Object (0xfffa4f27) java.util.HashMap\n-        print_oop_info_cr(&st, source_oop, \/*print_requested_addr=*\/false);\n-        byte_size = source_oop->size() * BytesPerWord;\n-      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n-        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffc3ffd8: @@ Object filler 40 bytes\n-        st.print_cr(\"filler %zu bytes\", byte_size);\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-\n-      address oop_end = start + byte_size;\n-      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n-\n-      if (source_oop != nullptr) {\n-        log_oop_details(heap_info, source_oop, \/*buffered_addr=*\/start);\n-      }\n-      start = oop_end;\n-    }\n-  }\n-\n-  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n-  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n-  \/\/ in _source_obj with their requested addresses using print_oop_info_cr().\n-  class ArchivedFieldPrinter : public FieldClosure {\n-    ArchiveHeapInfo* _heap_info;\n-    outputStream* _st;\n-    oop _source_obj;\n-    address _buffered_addr;\n-  public:\n-    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj, address buffered_addr) :\n-      _heap_info(heap_info), _st(st), _source_obj(src_obj), _buffered_addr(buffered_addr) {}\n-\n-    void do_field(fieldDescriptor* fd) {\n-      _st->print(\" - \");\n-      BasicType ft = fd->field_type();\n-      switch (ft) {\n-      case T_ARRAY:\n-      case T_OBJECT:\n-        {\n-          fd->print_on(_st); \/\/ print just the name and offset\n-          oop obj = _source_obj->obj_field(fd->offset());\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(_st, obj);\n-        }\n-        break;\n-      default:\n-        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n-          print_as_native_pointer(fd);\n-        } else {\n-          fd->print_on_for(_st, cast_to_oop(_buffered_addr)); \/\/ name, offset, value\n-          _st->cr();\n-        }\n-      }\n-    }\n-\n-    void print_as_native_pointer(fieldDescriptor* fd) {\n-      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n-      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n-\n-      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n-      address source_native_ptr = (address)\n-          LP64_ONLY(_source_obj->long_field(fd->offset()))\n-          NOT_LP64( _source_obj->int_field (fd->offset()));\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-\n-      \/\/ The value of the native pointer at runtime.\n-      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n-\n-      \/\/ The address of _source_obj at runtime\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n-      \/\/ The address of this field in the requested space\n-      assert(requested_obj != nullptr, \"Attempting to load field from null oop\");\n-      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n-\n-      fd->print_on(_st);\n-      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n-                    p2i(requested_native_ptr), p2i(requested_field_addr));\n-    }\n-  };\n-\n-  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n-  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop, address buffered_addr) {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      Klass* source_klass = source_oop->klass();\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n-\n-      st.print(\" - klass: \");\n-      source_klass->print_value_on(&st);\n-      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n-      st.cr();\n-\n-      if (source_oop->is_typeArray()) {\n-        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n-      } else if (source_oop->is_objArray()) {\n-        objArrayOop source_obj_array = objArrayOop(source_oop);\n-        for (int i = 0; i < source_obj_array->length(); i++) {\n-          st.print(\" -%4d: \", i);\n-          oop obj = source_obj_array->obj_at(i);\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(&st, obj);\n-        }\n-      } else {\n-        st.print_cr(\" - fields (%zu words):\", source_oop->size());\n-        ArchivedFieldPrinter print_field(heap_info, &st, source_oop, buffered_addr);\n-        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n-\n-        if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-          st.print(\" - signature: \");\n-          print_class_signature_for_mirror(&st, scratch_mirror);\n-          st.cr();\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            oop rr = HeapShared::scratch_resolved_references(InstanceKlass::cast(src_klass)->constants());\n-            st.print(\" - archived_resolved_references: \");\n-            print_oop_info_cr(&st, rr);\n-\n-            \/\/ We need to print the fields in the scratch_mirror, not the original mirror.\n-            \/\/ (if a class is not aot-initialized, static fields in its scratch mirror will be cleared).\n-            assert(scratch_mirror == HeapShared::scratch_java_mirror(src_klass->java_mirror()), \"sanity\");\n-            st.print_cr(\"- ---- static fields (%d):\", java_lang_Class::static_oop_field_count(scratch_mirror));\n-            InstanceKlass::cast(src_klass)->do_local_static_fields(&print_field);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static void print_class_signature_for_mirror(outputStream* st, oop scratch_mirror) {\n-    assert(java_lang_Class::is_instance(scratch_mirror), \"sanity\");\n-    if (java_lang_Class::is_primitive(scratch_mirror)) {\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        BasicType bt = (BasicType)i;\n-        if (!is_reference_type(bt) && scratch_mirror == HeapShared::scratch_java_mirror(bt)) {\n-          oop orig_mirror = Universe::java_mirror(bt);\n-          java_lang_Class::print_signature(orig_mirror, st);\n-          return;\n-        }\n-      }\n-      ShouldNotReachHere();\n-    }\n-    java_lang_Class::print_signature(scratch_mirror, st);\n-  }\n-\n-  static void log_heap_roots() {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n-        st.print(\"roots[%4d]: \", i);\n-        print_oop_info_cr(&st, HeapShared::pending_roots()->at(i));\n-      }\n-    }\n-  }\n-\n-  \/\/ Example output:\n-  \/\/ - The first number is the requested address (if print_requested_addr == true)\n-  \/\/ - The second number is the narrowOop version of the requested address (if UseCompressedOops == true)\n-  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class Ljava\/util\/Array;\n-  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n-  static void print_oop_info_cr(outputStream* st, oop source_oop, bool print_requested_addr = true) {\n-    if (source_oop == nullptr) {\n-      st->print_cr(\"null\");\n-    } else {\n-      ResourceMark rm;\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n-      if (print_requested_addr) {\n-        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n-      }\n-      if (UseCompressedOops) {\n-        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n-      }\n-      if (source_oop->is_array()) {\n-        int array_len = arrayOop(source_oop)->length();\n-        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n-      } else {\n-        st->print(\"%s\", source_oop->klass()->external_name());\n-\n-        if (java_lang_String::is_instance(source_oop)) {\n-          st->print(\" \");\n-          java_lang_String::print(source_oop, st);\n-        } else if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-\n-          st->print(\" \");\n-          print_class_signature_for_mirror(st, scratch_mirror);\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            InstanceKlass* buffered_klass =\n-              ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_klass));\n-            if (buffered_klass->has_aot_initialized_mirror()) {\n-              st->print(\" (aot-inited)\");\n-            }\n-          }\n-        }\n-        st->cr();\n-      }\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-\n-  \/\/ Log all the data [base...top). Pretend that the base address\n-  \/\/ will be mapped to requested_base at run-time.\n-  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n-    assert(top >= base, \"must be\");\n-\n-    LogStreamHandle(Trace, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      int unitsize = sizeof(address);\n-      if (is_heap && UseCompressedOops) {\n-        \/\/ This makes the compressed oop pointers easier to read, but\n-        \/\/ longs and doubles will be split into two words.\n-        unitsize = sizeof(narrowOop);\n-      }\n-      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n-    }\n-  }\n-\n-  static void log_header(FileMapInfo* mapinfo) {\n-    LogStreamHandle(Info, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      mapinfo->print(&lsh);\n-    }\n-  }\n-\n-public:\n-  static void log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n-                  ArchiveHeapInfo* heap_info,\n-                  char* bitmap, size_t bitmap_size_in_bytes) {\n-    log_info(aot, map)(\"%s CDS archive map for %s\", CDSConfig::is_dumping_static_archive() ? \"Static\" : \"Dynamic\", mapinfo->full_path());\n-\n-    address header = address(mapinfo->header());\n-    address header_end = header + mapinfo->header()->header_size();\n-    log_region(\"header\", header, header_end, nullptr);\n-    log_header(mapinfo);\n-    log_as_hex(header, header_end, nullptr);\n-\n-    DumpRegion* rw_region = &builder->_rw_region;\n-    DumpRegion* ro_region = &builder->_ro_region;\n-\n-    log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n-    log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n-\n-    address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n-    log_region(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n-    log_as_hex((address)bitmap, bitmap_end, nullptr);\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (heap_info->is_used()) {\n-      log_heap_region(heap_info);\n-    }\n-#endif\n-\n-    log_info(aot, map)(\"[End of CDS archive map]\");\n-  }\n-}; \/\/ end ArchiveBuilder::CDSMapLogger\n-\n@@ -1636,2 +1217,1 @@\n-    CDSMapLogger::log(this, mapinfo, heap_info,\n-                      bitmap, bitmap_size_in_bytes);\n+    AOTMapLogger::dumptime_log(this, mapinfo, heap_info, bitmap, bitmap_size_in_bytes);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":2,"deletions":422,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  friend class AOTMapLogger;\n+\n@@ -204,2 +206,0 @@\n-  class CDSMapLogger;\n-\n@@ -318,0 +318,6 @@\n+  template <typename T> T requested_to_buffered(T obj) const {\n+    T b = (T)(address(obj) - _buffer_to_requested_delta);\n+    assert(is_in_buffer_space(b), \"must be\");\n+    return b;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -165,0 +165,38 @@\n+Klass* ArchiveHeapWriter::real_klass_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->klass();\n+  } else if (get_filler_size_at(buffered_addr) > 0) {\n+    return Universe::fillerArrayKlass();\n+  } else {\n+    \/\/ This is one of the root segments\n+    return Universe::objectArrayKlass();\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::size_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->size();\n+  }\n+\n+  size_t nbytes = get_filler_size_at(buffered_addr);\n+  if (nbytes > 0) {\n+    assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+    return nbytes \/ BytesPerWord;\n+  }\n+\n+  address hrs = buffer_bottom();\n+  for (size_t seg_idx = 0; seg_idx < _heap_root_segments.count(); seg_idx++) {\n+    nbytes = _heap_root_segments.size_in_bytes(seg_idx);\n+    if (hrs == buffered_addr) {\n+      assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+      return nbytes \/ BytesPerWord;\n+    }\n+    hrs += nbytes;\n+  }\n+\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n@@ -712,21 +750,0 @@\n-\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n-bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n-  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n-  assert(p != nullptr, \"must be\");\n-\n-  \/\/ requested_field_addr = the address of this field in the requested space\n-  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n-  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n-  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n-\n-  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n-  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n-  size_t start_pos = FileMapInfo::current_info()->heap_ptrmap_start_pos();\n-  if (idx < start_pos) {\n-    return false;\n-  } else {\n-    idx -= start_pos;\n-  }\n-  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":38,"deletions":21,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -239,1 +239,0 @@\n-  static bool is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset);\n@@ -243,1 +242,2 @@\n-\n+  static Klass* real_klass_of_buffered_oop(address buffered_addr);\n+  static size_t size_of_buffered_oop(address buffered_addr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -107,0 +108,2 @@\n+\n+  AOTMapLogger::ergo_initialize();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -1957,0 +1958,1 @@\n+  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1972,6 +1974,0 @@\n-  \/\/ Close the mapinfo file\n-  static_mapinfo->close();\n-\n-  static_mapinfo->unmap_region(MetaspaceShared::bm);\n-\n-  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1983,0 +1979,10 @@\n+  }\n+\n+  if (AOTMapLogger::is_logging_at_bootstrap()) {\n+    AOTMapLogger::runtime_log(static_mapinfo, dynamic_mapinfo);\n+  }\n+\n+  static_mapinfo->close();\n+  static_mapinfo->unmap_region(MetaspaceShared::bm);\n+\n+  if (dynamic_mapinfo != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1182,0 +1182,6 @@\n+void SystemDictionaryShared::get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes) {\n+  get_archive(is_static_archive)->_builtin_dictionary.iterate([&] (const RunTimeClassInfo* record) {\n+      classes->append(record->klass());\n+    });\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+template <typename E> class GrowableArray;\n+\n@@ -272,0 +274,1 @@\n+  static void get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  CDS_JAVA_HEAP_ONLY(int archived_references_index() { return _archived_references_index; })\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  friend class AOTMapLogger;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -49,1 +51,1 @@\n-        ArrayList<String> dumpArgs = new ArrayList<>();\n+        ArrayList<String> vmArgs = new ArrayList<>();\n@@ -52,1 +54,1 @@\n-        dumpArgs.add(\"-Xmx128M\");\n+        vmArgs.add(\"-Xmx128M\");\n@@ -57,1 +59,1 @@\n-            dumpArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+            vmArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n@@ -60,1 +62,3 @@\n-        dump(dumpArgs);\n+        String archiveFile = dump(vmArgs);\n+        exec(vmArgs, archiveFile);\n+\n@@ -64,1 +68,3 @@\n-    static void dump(ArrayList<String> args, String... more) throws Exception {\n+\n+    \/\/ Create a map file when creating the archive\n+    static String dump(ArrayList<String> args) throws Exception {\n@@ -72,2 +78,1 @@\n-            .addSuffix(args)\n-            .addSuffix(more);\n+            .addSuffix(args);\n@@ -78,0 +83,19 @@\n+\n+        return archiveName;\n+    }\n+\n+    \/\/ Create a map file when using the archive\n+    static void exec(ArrayList<String> vmArgs, String archiveFile) throws Exception {\n+        String mapName = archiveFile + \".exec.map\";\n+        vmArgs.add(\"-XX:SharedArchiveFile=\" + archiveFile);\n+        vmArgs.add(\"-Xlog:cds=debug\");\n+        vmArgs.add(\"-Xshare:on\");\n+        vmArgs.add(\"-Xlog:aot+map=debug,aot+map+oops=trace:file=\" + mapName + \":none:filesize=0\");\n+        vmArgs.add(\"--version\");\n+        String[] cmdLine = vmArgs.toArray(new String[vmArgs.size()]);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        OutputAnalyzer out = CDSTestUtils.executeAndLog(pb, \"exec\");\n+        out.shouldHaveExitValue(0);\n+\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        CDSMapReader.validate(mapFile);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"}]}