{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import java.util.Iterator;\n@@ -46,1 +45,0 @@\n-import java.util.NoSuchElementException;\n@@ -48,0 +46,1 @@\n+import java.util.function.Consumer;\n@@ -105,0 +104,4 @@\n+    protected void skipEntry(Throwable ex, String entryPath) {\n+        skippedEntries.add(String.format(\"%s: %s\", ex.toString(), entryPath));\n+    }\n+\n@@ -138,2 +141,9 @@\n-    public Iterable<ClassModel> getClassFiles() throws IOException {\n-        return FileIterator::new;\n+    public void forEachClassFile(Consumer<ClassModel> handler) throws IOException {\n+        if (baseFileName.endsWith(\".class\")) {\n+            \/\/ propagate ClassFileError for single file\n+            try {\n+                handler.accept(readClassFile(path));\n+            } catch (ClassFileError ex) {\n+                skipEntry(ex, path.toString());\n+            }\n+        }\n@@ -170,27 +180,0 @@\n-    class FileIterator implements Iterator<ClassModel> {\n-        int count;\n-        FileIterator() {\n-            this.count = 0;\n-        }\n-        public boolean hasNext() {\n-            return count == 0 && baseFileName.endsWith(\".class\");\n-        }\n-\n-        public ClassModel next() {\n-            if (!hasNext()) {\n-                throw new NoSuchElementException();\n-            }\n-            try {\n-                ClassModel cf = readClassFile(path);\n-                count++;\n-                return cf;\n-            } catch (IOException e) {\n-                throw new ClassFileError(e);\n-            }\n-        }\n-\n-        public void remove() {\n-            throw new UnsupportedOperationException(\"Not supported yet.\");\n-        }\n-    }\n-\n@@ -244,36 +227,11 @@\n-        public Iterable<ClassModel> getClassFiles() throws IOException {\n-            final Iterator<ClassModel> iter = new DirectoryIterator();\n-            return () -> iter;\n-        }\n-\n-        class DirectoryIterator implements Iterator<ClassModel> {\n-            private final List<Path> entries;\n-            private int index = 0;\n-            DirectoryIterator() throws IOException {\n-                List<Path> paths = null;\n-                try (Stream<Path> stream = Files.walk(path, Integer.MAX_VALUE)) {\n-                    paths = stream.filter(ClassFileReader::isClass).toList();\n-\n-                }\n-                this.entries = paths;\n-                this.index = 0;\n-            }\n-\n-            public boolean hasNext() {\n-                return index != entries.size();\n-            }\n-\n-            public ClassModel next() {\n-                if (!hasNext()) {\n-                    throw new NoSuchElementException();\n-                }\n-                Path path = entries.get(index++);\n-                try {\n-                    return readClassFile(path);\n-                } catch (IOException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            public void remove() {\n-                throw new UnsupportedOperationException(\"Not supported yet.\");\n+        @Override\n+        public void forEachClassFile(Consumer<ClassModel> handler) throws IOException {\n+            try (Stream<Path> stream = Files.walk(path, Integer.MAX_VALUE)) {\n+                stream.filter(ClassFileReader::isClass)\n+                      .forEach(e -> {\n+                          try {\n+                              handler.accept(readClassFile(e));\n+                          } catch (ClassFileError | IOException ex) {\n+                              skipEntry(ex, e.toString());\n+                          }\n+                      });\n@@ -317,0 +275,4 @@\n+        private static boolean isJarEntryClass(JarEntry e) {\n+            return e.getName().endsWith(\".class\");\n+        }\n+\n@@ -318,7 +280,4 @@\n-            try (JarFile jf = openJarFile(path.toFile(), version)) {\n-                return jf.versionedStream().map(JarEntry::getName)\n-                         .filter(n -> n.endsWith(\".class\"))\n-                         .collect(Collectors.toSet());\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n+            return jarfile.versionedStream()\n+                          .filter(JarFileReader::isJarEntryClass)\n+                          .map(JarEntry::getName)\n+                          .collect(Collectors.toSet());\n@@ -361,70 +320,11 @@\n-        public Iterable<ClassModel> getClassFiles() throws IOException {\n-            final Iterator<ClassModel> iter = new JarFileIterator(this, jarfile);\n-            return () -> iter;\n-        }\n-    }\n-\n-    class JarFileIterator implements Iterator<ClassModel> {\n-        protected final JarFileReader reader;\n-        protected Iterator<JarEntry> entries;\n-        protected JarFile jf;\n-        protected JarEntry nextEntry;\n-        protected ClassModel cf;\n-        JarFileIterator(JarFileReader reader) {\n-            this(reader, null);\n-        }\n-        JarFileIterator(JarFileReader reader, JarFile jarfile) {\n-            this.reader = reader;\n-            setJarFile(jarfile);\n-        }\n-\n-        void setJarFile(JarFile jarfile) {\n-            if (jarfile == null) return;\n-\n-            this.jf = jarfile;\n-            this.entries = jarfile.versionedStream().iterator();\n-            this.nextEntry = nextEntry();\n-        }\n-\n-        public boolean hasNext() {\n-            if (nextEntry != null && cf != null) {\n-                return true;\n-            }\n-            while (nextEntry != null) {\n-                try {\n-                    cf = reader.readClassFile(jf, nextEntry);\n-                    return true;\n-                } catch (ClassFileError | IOException ex) {\n-                    skippedEntries.add(String.format(\"%s: %s (%s)\",\n-                                                     ex.getMessage(),\n-                                                     nextEntry.getName(),\n-                                                     jf.getName()));\n-                }\n-                nextEntry = nextEntry();\n-            }\n-            return false;\n-        }\n-\n-        public ClassModel next() {\n-            if (!hasNext()) {\n-                throw new NoSuchElementException();\n-            }\n-            ClassModel classFile = cf;\n-            cf = null;\n-            nextEntry = nextEntry();\n-            return classFile;\n-        }\n-\n-        protected JarEntry nextEntry() {\n-            while (entries.hasNext()) {\n-                JarEntry e = entries.next();\n-                String name = e.getName();\n-                if (name.endsWith(\".class\")) {\n-                    return e;\n-                }\n-            }\n-            return null;\n-        }\n-\n-        public void remove() {\n-            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        @Override\n+        public void forEachClassFile(Consumer<ClassModel> handler) throws IOException {\n+            jarfile.versionedStream()\n+                   .filter(JarFileReader::isJarEntryClass)\n+                   .forEach(e -> {\n+                       try {\n+                           handler.accept(readClassFile(jarfile, e));\n+                       } catch (ClassFileError | IOException ex) {\n+                           skipEntry(ex, e.getName() + \" (\" + jarfile.getName() + \")\");\n+                       }\n+                   });\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ClassFileReader.java","additions":45,"deletions":145,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-            initCause(cause);\n+            super(cause.getMessage(), cause);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Dependencies.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,1 +176,1 @@\n-            for (var cf : archive.reader().getClassFiles()) {\n+            archive.reader().forEachClassFile(cf -> {\n@@ -178,1 +178,1 @@\n-                    continue;\n+                    return;\n@@ -190,1 +190,1 @@\n-                    continue;\n+                    return;\n@@ -194,1 +194,1 @@\n-                    continue;\n+                    return;\n@@ -206,1 +206,1 @@\n-            }\n+            });\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DependencyFinder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341608\n+ * @summary Tests for jdeps tool with jar files with malformed classes\n+ * @library lib \/test\/lib\n+ * @build jdk.jdeps\/com.sun.tools.jdeps.*\n+ * @run junit MalformedClassesTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import com.sun.tools.jdeps.JdepsAccess;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class MalformedClassesTest {\n+\n+    static Stream<Arguments> invalidArchives() throws Exception {\n+        var jarPath = Path.of(\"malformed-signature.jar\");\n+        var compiledClasses = InMemoryJavaCompiler.compile(Map.ofEntries(\n+                Map.entry(\"one.One\", \"\"\"\n+                          package one;\n+\n+                          import java.util.Optional;\n+\n+                          class One {\n+                              Optional<String> st = Optional.empty();\n+                          }\n+                          \"\"\"),\n+                Map.entry(\"two.Two\", \"\"\"\n+                          package two;\n+\n+                          import java.lang.invoke.*;\n+\n+                          class Two {\n+                              int i;\n+                              static final VarHandle I;\n+\n+                              static {\n+                                  try {\n+                                      I = MethodHandles.lookup().findVarHandle(Two.class, \"i\", int.class);\n+                                  } catch (ReflectiveOperationException ex) {\n+                                      throw new ExceptionInInitializerError(ex);\n+                                  }\n+                              }\n+                          }\n+                          \"\"\")\n+        ));\n+        var updated = ClassFile.of().transformClass(ClassFile.of().parse(compiledClasses.get(\"one.One\")),\n+                ClassTransform.transformingFields((fb, fe) -> {\n+                    if (fe instanceof SignatureAttribute) {\n+                        fb.with(SignatureAttribute.of(fb.constantPool().utf8Entry(\"Invalid string\")));\n+                    } else {\n+                        fb.with(fe);\n+                    }\n+                }));\n+        var classes = new HashMap<>(compiledClasses);\n+        classes.put(\"one.One\", updated);\n+        JarUtils.createJarFromClasses(jarPath, classes);\n+\n+        Path flatDir = Path.of(\"flatDir\");\n+        Files.createDirectories(flatDir);\n+        for (var entry : classes.entrySet()) {\n+            ClassFileInstaller.writeClassToDisk(entry.getKey(), entry.getValue(), flatDir.toString());\n+        }\n+\n+        return Stream.of(\n+                Arguments.of(\"directory\", flatDir, \"one\/One.class\"),\n+                Arguments.of(\"jar\", jarPath, \"one\/One.class (malformed-signature.jar)\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"invalidArchives\")\n+    public void testMalformedSignature(String kind, Path path, String entryName) throws IOException {\n+        try (var jdeps = JdepsUtil.newCommand(\"jdeps\")) {\n+            jdeps.addRoot(path);\n+            var analyzer = jdeps.getDepsAnalyzer();\n+            analyzer.run();\n+            var archives = JdepsAccess.depsAnalyzerArchives(analyzer);\n+            assertEquals(1, archives.size(), archives::toString);\n+            var archive = archives.iterator().next();\n+            var skippedEntries = archive.reader().skippedEntries();\n+            assertEquals(1, skippedEntries.size(), skippedEntries::toString);\n+            var message = skippedEntries.getFirst();\n+            assertTrue(message.contains(\"ClassFileError\"), message);\n+            assertTrue(message.contains(\"Invalid string\"), message);\n+            assertTrue(message.contains(entryName), \"\\\"\" + message + \"\\\" does not contain \\\"\" + entryName + \"\\\"\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/jdeps\/MalformedClassesTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+modules = \\\n+    jdk.jdeps\/com.sun.tools.jdeps\n","filename":"test\/langtools\/tools\/jdeps\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.jdeps;\n+\n+import java.util.Set;\n+\n+public final class JdepsAccess {\n+    public static Set<Archive> depsAnalyzerArchives(DepsAnalyzer analyzer) {\n+        return analyzer.archives;\n+    }\n+\n+    private JdepsAccess() {}\n+}\n","filename":"test\/langtools\/tools\/jdeps\/jdk.jdeps\/com\/sun\/tools\/jdeps\/JdepsAccess.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,2 +211,4 @@\n-     * Compiles the list of classes with the given map of name and source code.\n-     * This overloaded version of compile is useful for batch compile use cases.\n+     * Compiles the list of classes with the given map of binary name and source code.\n+     * This overloaded version of compile is useful for batch compile use cases, or\n+     * if a compilation unit produces multiple class files. Returns a map from\n+     * class binary names to class file content.\n","filename":"test\/lib\/jdk\/test\/lib\/compiler\/InMemoryJavaCompiler.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,0 +134,18 @@\n+\n+    \/**\n+     * Creates a JAR file from a map of class binary name to class bytes.\n+     *\n+     * @see jdk.test.lib.compiler.InMemoryJavaCompiler#compile(Map)\n+     *\/\n+    public static void createJarFromClasses(Path jarfile, Map<String, byte[]> classes) throws IOException {\n+        try (OutputStream out = Files.newOutputStream(jarfile);\n+             JarOutputStream jos = new JarOutputStream(out)) {\n+            for (var entry : classes.entrySet()) {\n+                String name = entry.getKey().replace('.', '\/') + \".class\";\n+                jos.putNextEntry(new JarEntry(name));\n+                jos.write(entry.getValue());\n+                jos.closeEntry();\n+            }\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/JarUtils.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}