{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -144,1 +143,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,5 @@\n+Node* ConstraintCastNode::pin_node_under_control_impl() const {\n+  assert(_dependency.is_floating(), \"already pinned\");\n+  return make_cast_for_type(in(0), in(1), bottom_type(), _dependency.with_pinned_dependency(), _extra_types);\n+}\n+\n@@ -280,1 +285,1 @@\n-CastIINode* CastIINode::pin_array_access_node() const {\n+CastIINode* CastIINode::pin_node_under_control_impl() const {\n@@ -282,4 +287,1 @@\n-  if (has_range_check()) {\n-    return new CastIINode(in(0), in(1), bottom_type(), _dependency.with_pinned_dependency(), has_range_check());\n-  }\n-  return nullptr;\n+  return new CastIINode(in(0), in(1), bottom_type(), _dependency.with_pinned_dependency(), _range_check_dependency, _extra_types);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,2 +169,0 @@\n-  \/\/ A cast node depends_only_on_test if and only if it is floating\n-  virtual bool depends_only_on_test() const { return _dependency.is_floating(); }\n@@ -194,0 +192,6 @@\n+\n+protected:\n+  virtual bool depends_only_on_test_impl() const { return _dependency.is_floating(); }\n+\n+private:\n+  virtual Node* pin_node_under_control_impl() const;\n@@ -225,1 +229,0 @@\n-  CastIINode* pin_array_access_node() const;\n@@ -232,0 +235,3 @@\n+\n+private:\n+  virtual CastIINode* pin_node_under_control_impl() const;\n@@ -323,2 +329,4 @@\n-  bool depends_only_on_test() const { return !type()->isa_rawptr() && ConstraintCastNode::depends_only_on_test(); }\n- };\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return !type()->isa_rawptr() && ConstraintCastNode::depends_only_on_test_impl(); }\n+};\n@@ -352,0 +360,2 @@\n+\n+private:\n@@ -353,1 +363,1 @@\n-  virtual bool depends_only_on_test() const { return false; }\n+  virtual bool depends_only_on_test_impl() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -290,1 +289,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -465,1 +463,1 @@\n-  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_access_nodes);\n+  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool prev_dom_not_imply_this);\n@@ -568,1 +566,1 @@\n-  void pin_array_access_nodes(PhaseIterGVN* igvn);\n+  void pin_dependent_nodes(PhaseIterGVN* igvn);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,18 @@\n+class DivModIntegerNode : public Node {\n+private:\n+  bool _pinned;\n+\n+protected:\n+  DivModIntegerNode(Node* c, Node* dividend, Node* divisor) : Node(c, dividend, divisor), _pinned(false) {}\n+\n+private:\n+  virtual uint size_of() const override { return sizeof(DivModIntegerNode); }\n+  virtual uint hash() const override { return Node::hash() + _pinned; }\n+  virtual bool cmp(const Node& o) const override { return Node::cmp(o) && _pinned == static_cast<const DivModIntegerNode&>(o)._pinned; }\n+  virtual bool depends_only_on_test_impl() const override { return !_pinned; }\n+  virtual DivModIntegerNode* pin_node_under_control_impl() const override {\n+    DivModIntegerNode* res = static_cast<DivModIntegerNode*>(clone());\n+    res->_pinned = true;\n+    return res;\n+  }\n+};\n@@ -44,1 +62,1 @@\n-class DivINode : public Node {\n+class DivINode : public DivModIntegerNode {\n@@ -46,1 +64,1 @@\n-  DivINode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  DivINode(Node* c, Node* dividend, Node* divisor) : DivModIntegerNode(c, dividend, divisor) {}\n@@ -57,1 +75,1 @@\n-class DivLNode : public Node {\n+class DivLNode : public DivModIntegerNode {\n@@ -59,1 +77,1 @@\n-  DivLNode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  DivLNode(Node* c, Node* dividend, Node* divisor) : DivModIntegerNode(c, dividend, divisor) {}\n@@ -110,1 +128,1 @@\n-class UDivINode : public Node {\n+class UDivINode : public DivModIntegerNode {\n@@ -112,1 +130,1 @@\n-  UDivINode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  UDivINode(Node* c, Node* dividend, Node* divisor) : DivModIntegerNode(c, dividend, divisor) {}\n@@ -123,1 +141,1 @@\n-class UDivLNode : public Node {\n+class UDivLNode : public DivModIntegerNode {\n@@ -125,1 +143,1 @@\n-  UDivLNode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  UDivLNode(Node* c, Node* dividend, Node* divisor) : DivModIntegerNode(c, dividend, divisor) {}\n@@ -136,1 +154,1 @@\n-class ModINode : public Node {\n+class ModINode : public DivModIntegerNode {\n@@ -138,1 +156,1 @@\n-  ModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  ModINode(Node* c, Node* in1, Node* in2) : DivModIntegerNode(c, in1, in2) {}\n@@ -148,1 +166,1 @@\n-class ModLNode : public Node {\n+class ModLNode : public DivModIntegerNode {\n@@ -150,1 +168,1 @@\n-  ModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  ModLNode(Node* c, Node* in1, Node* in2) : DivModIntegerNode(c, in1, in2) {}\n@@ -202,1 +220,1 @@\n-class UModINode : public Node {\n+class UModINode : public DivModIntegerNode {\n@@ -204,1 +222,1 @@\n-  UModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModINode(Node* c, Node* in1, Node* in2) : DivModIntegerNode(c, in1, in2) {}\n@@ -214,1 +232,1 @@\n-class UModLNode : public Node {\n+class UModLNode : public DivModIntegerNode {\n@@ -216,1 +234,1 @@\n-  UModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModLNode(Node* c, Node* in1, Node* in2) : DivModIntegerNode(c, in1, in2) {}\n@@ -246,0 +264,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -607,1 +607,1 @@\n-  proj->pin_array_access_nodes(igvn);\n+  proj->pin_dependent_nodes(igvn);\n@@ -1542,1 +1542,1 @@\n-Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_access_nodes) {\n+Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool prev_dom_not_imply_this) {\n@@ -1573,3 +1573,2 @@\n-      if (s->depends_only_on_test() && igvn->no_dependent_zero_check(s)) {\n-        \/\/ For control producers.\n-        \/\/ Do not rewire Div and Mod nodes which could have a zero divisor to avoid skipping their zero check.\n+      if (s->depends_only_on_test()) {\n+        \/\/ For control producers\n@@ -1577,12 +1576,7 @@\n-        if (pin_array_access_nodes && data_target != top) {\n-          \/\/ As a result of range check smearing, Loads and range check Cast nodes that are control dependent on this\n-          \/\/ range check (that is about to be removed) now depend on multiple dominating range checks. After the removal\n-          \/\/ of this range check, these control dependent nodes end up at the lowest\/nearest dominating check in the\n-          \/\/ graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n-          \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the\n-          \/\/ lowest dominating check.\n-          Node* clone = s->pin_array_access_node();\n-          if (clone != nullptr) {\n-            clone = igvn->transform(clone);\n-            igvn->replace_node(s, clone);\n-          }\n+        if (prev_dom_not_imply_this && data_target != top) {\n+          \/\/ If prev_dom_not_imply_this, s now depends on multiple tests with prev_dom being the\n+          \/\/ lowest dominating one. As a result, it must be pinned there. Otherwise, it can be\n+          \/\/ incorrectly moved to a dominating test equivalent to the lowest one here.\n+          Node* clone = s->pin_node_under_control();\n+          igvn->register_new_node_with_optimizer(clone);\n+          igvn->replace_node(s, clone);\n@@ -1834,1 +1828,1 @@\n-void IfProjNode::pin_array_access_nodes(PhaseIterGVN* igvn) {\n+void IfProjNode::pin_dependent_nodes(PhaseIterGVN* igvn) {\n@@ -1840,7 +1834,4 @@\n-    Node* clone = u->pin_array_access_node();\n-    if (clone != nullptr) {\n-      clone = igvn->transform(clone);\n-      assert(clone != u, \"shouldn't common\");\n-      igvn->replace_node(u, clone);\n-      --i;\n-    }\n+    Node* clone = u->pin_node_under_control();\n+    igvn->register_new_node_with_optimizer(clone);\n+    igvn->replace_node(u, clone);\n+    --i;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -77,1 +80,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -84,0 +86,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -175,1 +180,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -182,0 +186,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -194,1 +201,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -206,0 +212,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -150,0 +150,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -172,0 +175,2 @@\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,1 @@\n-          if (n->is_CFG() || (n->depends_only_on_test() && _phase->igvn().no_dependent_zero_check(n)) || n->in(0) == nullptr || !_phase->is_member(_lpt, n->in(0))) {\n+          if (n->is_CFG() || n->in(0) == nullptr || n->depends_only_on_test() || !_phase->is_member(_lpt, n->in(0))) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1684,2 +1684,2 @@\n-  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool pin_array_access_nodes = false);\n-  void rewire_safe_outputs_to_dominator(Node* source, Node* dominator, bool pin_array_access_nodes);\n+  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool prev_dom_not_imply_this = false);\n+  void rewire_safe_outputs_to_dominator(Node* source, Node* dominator, bool dominator_not_imply_source);\n@@ -1968,1 +1968,1 @@\n-  void pin_array_access_nodes_dependent_on(Node* ctrl);\n+  void pin_nodes_dependent_on(Node* ctrl);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,1 +348,1 @@\n-void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool pin_array_access_nodes) {\n+void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool prevdom_not_imply_this) {\n@@ -389,1 +389,1 @@\n-  rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n+  rewire_safe_outputs_to_dominator(dp, prevdom, prevdom_not_imply_this);\n@@ -392,1 +392,1 @@\n-void PhaseIdealLoop::rewire_safe_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n+void PhaseIdealLoop::rewire_safe_outputs_to_dominator(Node* source, Node* dominator, const bool dominator_not_imply_source) {\n@@ -397,2 +397,1 @@\n-    \/\/ Do not rewire Div and Mod nodes which could have a zero divisor to avoid skipping their zero check.\n-    if (out->depends_only_on_test() && _igvn.no_dependent_zero_check(out)) {\n+    if (out->depends_only_on_test()) {\n@@ -401,1 +400,1 @@\n-      if (pin_array_access_nodes) {\n+      if (dominator_not_imply_source) {\n@@ -408,6 +407,4 @@\n-        Node* clone = out->pin_array_access_node();\n-        if (clone != nullptr) {\n-          clone = _igvn.register_new_node_with_optimizer(clone, out);\n-          _igvn.replace_node(out, clone);\n-          out = clone;\n-        }\n+        Node* clone = out->pin_node_under_control();\n+        clone = _igvn.register_new_node_with_optimizer(clone, out);\n+        _igvn.replace_node(out, clone);\n+        out = clone;\n@@ -1647,1 +1644,1 @@\n-    if (!has_ctrl(u) || u->is_Phi() || !u->depends_only_on_test() || !_igvn.no_dependent_zero_check(u)) {\n+    if (!has_ctrl(u) || u->is_Phi() || !u->depends_only_on_test()) {\n@@ -1727,9 +1724,7 @@\n-            Node* pinned_clone = n->pin_array_access_node();\n-            if (pinned_clone != nullptr) {\n-              \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n-              \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n-              \/\/ unpinned load would risk floating above its range check.\n-              register_new_node(pinned_clone, n_ctrl);\n-              maybe_pinned_n = pinned_clone;\n-              _igvn.replace_node(n, pinned_clone);\n-            }\n+            \/\/ If this node depends_only_on_test, it will be rewired to a control input that is not\n+            \/\/ the correct test. As a result, it must be pinned otherwise it can be incorrectly\n+            \/\/ rewired to a dominating test equivalent to the new control.\n+            Node* pinned_clone = n->pin_node_under_control();\n+            register_new_node(pinned_clone, n_ctrl);\n+            maybe_pinned_n = pinned_clone;\n+            _igvn.replace_node(n, pinned_clone);\n@@ -1757,5 +1752,5 @@\n-          if (n->depends_only_on_test()) {\n-            \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n-            \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n-            \/\/ unpinned load would risk floating above its range check.\n-            x = n->pin_array_access_node();\n+          if (n->in(0) != nullptr && n->depends_only_on_test()) {\n+            \/\/ If this node depends_only_on_test, it will be rewired to a control input that is not\n+            \/\/ the correct test. As a result, it must be pinned otherwise it can be incorrectly\n+            \/\/ rewired to a dominating test equivalent to the new control.\n+            x = n->pin_node_under_control();\n@@ -2331,13 +2326,9 @@\n-      if (idx == 0 &&\n-          use->depends_only_on_test()) {\n-        Node* pinned_clone = use->pin_array_access_node();\n-        if (pinned_clone != nullptr) {\n-          \/\/ Pin array access nodes: control is updated here to a region. If, after some transformations, only one path\n-          \/\/ into the region is left, an array load could become dependent on a condition that's not a range check for\n-          \/\/ that access. If that condition is replaced by an identical dominating one, then an unpinned load would risk\n-          \/\/ floating above its range check.\n-          pinned_clone->set_req(0, phi);\n-          register_new_node_with_ctrl_of(pinned_clone, use);\n-          _igvn.replace_node(use, pinned_clone);\n-          continue;\n-        }\n+      if (idx == 0 && use->depends_only_on_test()) {\n+        \/\/ If this node depends_only_on_test, it will be rewired to a control input that is not the\n+        \/\/ correct test. As a result, it must be pinned otherwise it can be incorrectly rewired to\n+        \/\/ a dominating test equivalent to the new control.\n+        Node* pinned_clone = use->pin_node_under_control();\n+        pinned_clone->set_req(0, phi);\n+        register_new_node_with_ctrl_of(pinned_clone, use);\n+        _igvn.replace_node(use, pinned_clone);\n+        continue;\n@@ -4105,11 +4096,7 @@\n-        \/\/ Pin array access nodes: control is updated here to the loop head. If, after some transformations, the\n-        \/\/ backedge is removed, an array load could become dependent on a condition that's not a range check for that\n-        \/\/ access. If that condition is replaced by an identical dominating one, then an unpinned load would risk\n-        \/\/ floating above its range check.\n-        Node* pinned_clone = n_clone->pin_array_access_node();\n-        if (pinned_clone != nullptr) {\n-          register_new_node_with_ctrl_of(pinned_clone, n_clone);\n-          old_new.map(n->_idx, pinned_clone);\n-          _igvn.replace_node(n_clone, pinned_clone);\n-          n_clone = pinned_clone;\n-        }\n+        \/\/ If this node depends_only_on_test, it will be rewire to the loop head, which is not the\n+        \/\/ correct test\n+        Node* pinned_clone = n_clone->pin_node_under_control();\n+        register_new_node_with_ctrl_of(pinned_clone, n_clone);\n+        old_new.map(n->_idx, pinned_clone);\n+        _igvn.replace_node(n_clone, pinned_clone);\n+        n_clone = pinned_clone;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":39,"deletions":52,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -903,1 +903,1 @@\n-  if (!depends_only_on_test()) {\n+  if (in(0) != nullptr && !depends_only_on_test()) {\n@@ -1028,8 +1028,0 @@\n-LoadNode* LoadNode::pin_array_access_node() const {\n-  const TypePtr* adr_type = this->adr_type();\n-  if (adr_type != nullptr && adr_type->isa_aryptr()) {\n-    return clone_pinned();\n-  }\n-  return nullptr;\n-}\n-\n@@ -2582,1 +2574,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -302,2 +302,0 @@\n-  LoadNode* pin_array_access_node() const;\n-\n@@ -317,0 +315,1 @@\n+private:\n@@ -326,1 +325,1 @@\n-  virtual bool depends_only_on_test() const {\n+  virtual bool depends_only_on_test_impl() const {\n@@ -331,0 +330,1 @@\n+  virtual LoadNode* pin_node_under_control_impl() const { return clone_pinned(); }\n@@ -537,1 +537,0 @@\n-  virtual bool depends_only_on_test() const { return true; }\n@@ -566,1 +565,0 @@\n-  virtual bool depends_only_on_test() const { return true; }\n@@ -583,1 +581,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -663,0 +660,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -822,1 +822,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -835,0 +834,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -1117,0 +1119,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -1679,0 +1684,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -1691,0 +1699,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -1703,0 +1714,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -1715,0 +1729,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n@@ -179,2 +178,1 @@\n-  virtual bool      is_CFG() const;\n-  virtual bool depends_only_on_test() const { return false; }\n+  virtual bool is_CFG() const;\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1058,7 +1058,44 @@\n-  \/\/ If this node is control-dependent on a test, can it be\n-  \/\/ rerouted to a dominating equivalent test?  This is usually\n-  \/\/ true of non-CFG nodes, but can be false for operations which\n-  \/\/ depend for their correct sequencing on more than one test.\n-  \/\/ (In that case, hoisting to a dominating test may silently\n-  \/\/ skip some other important test.)\n-  virtual bool depends_only_on_test() const { assert(!is_CFG(), \"\"); return true; };\n+  \/\/ If this node is control-dependent on a test, can it be rerouted to a dominating equivalent\n+  \/\/ test? This means that the node can be executed safely as long as it happens after the test\n+  \/\/ that is its control input without worrying about the whole control flow. On the contrary, if\n+  \/\/ the node depends on a test that is not its control input, or if it depends on more than one\n+  \/\/ tests, then this method must return false.\n+  \/\/\n+  \/\/ Pseudocode examples:\n+  \/\/ 1. if (y != 0) {\n+  \/\/      x \/ y;\n+  \/\/    }\n+  \/\/ The division depends only on the test y != 0 and can be executed anywhere y != 0 holds true.\n+  \/\/ As a result, depends_only_on_test returns true.\n+  \/\/ 2. if (y != 0) {\n+  \/\/      if (x > 1) {\n+  \/\/        x \/ y;\n+  \/\/      }\n+  \/\/    }\n+  \/\/ If the division x \/ y has its control input being the IfTrueNode of the test y != 0, then\n+  \/\/ depends_only_on_test returns true. Otherwise, if the division has its control input being the\n+  \/\/ IfTrueNode of the test x > 1, then depends_only_on_test returns false.\n+  \/\/ 3. if (y > z) {\n+  \/\/      if (z > 0) {\n+  \/\/        x \/ y\n+  \/\/      }\n+  \/\/    }\n+  \/\/ The division depends on both tests y > z and z > 0. As a result, depends_only_on_test returns\n+  \/\/ false.\n+  \/\/\n+  \/\/ This method allows more freedom in certain nodes with regards to scheduling, for example it\n+  \/\/ allows nodes to float out of loops together with its test.\n+  \/\/\n+  \/\/ This method is pessimistic, this means that it may return false even if the node satisfy the\n+  \/\/ requirements. However, it must return false if the node does not satisfy the requirements.\n+  \/\/ When a test is decomposed into multiple tests, all nodes that depend on the decomposed test\n+  \/\/ must be pinned at the lowest dominating test of those. For example, when a zero check of a\n+  \/\/ division is split through a region but the division itself is not, it must be pinned at the\n+  \/\/ merge point by returning false when calling this method.\n+  bool depends_only_on_test() const {\n+    if (is_CFG() || pinned()) {\n+      return false;\n+    }\n+    assert(in(0) != nullptr, \"must have a control input\");\n+    return depends_only_on_test_impl();\n+  }\n@@ -1066,0 +1103,74 @@\n+  \/\/ Return a clone of the current node that's pinned. The current node must return true for\n+  \/\/ depends_only_on_test, and the retuned node must return false. This method is called when the\n+  \/\/ node is disconnected from its test.\n+  \/\/\n+  \/\/ Examples:\n+  \/\/ 1. for (int i = start; i <= limit; i++) {\n+  \/\/      if (!rangecheck(i, a)) {\n+  \/\/        trap;\n+  \/\/      }\n+  \/\/      a[i];\n+  \/\/    }\n+  \/\/ Loop predication can then hoist the range check out of the loop:\n+  \/\/    if (!rangecheck(start, a)) {\n+  \/\/      trap;\n+  \/\/    }\n+  \/\/    if (!rangecheck(limit, a)) {\n+  \/\/      trap;\n+  \/\/    }\n+  \/\/    for (int i = start; i <= limit; i++) {\n+  \/\/      a[i];\n+  \/\/    }\n+  \/\/ As the load a[i] now depends on both tests rangecheck(start, a) and rangecheck(limit, a), it\n+  \/\/ must be pinned at the lowest dominating test of those.\n+  \/\/\n+  \/\/ 2. if (y > x) {\n+  \/\/      if (x >= 0) {\n+  \/\/        if (y != 0) {\n+  \/\/          x \/ y;\n+  \/\/        }\n+  \/\/      }\n+  \/\/    }\n+  \/\/ The test (y != 0) == true can be deduced from (y > x) == true and (x >= 0) == true, so we may\n+  \/\/ choose to elide it. In such cases, the division x \/ y now depends on both tests\n+  \/\/ (y > x) == true and (x >= 0) == true, so it must be pinned at the lowest dominating test of\n+  \/\/ those.\n+  \/\/\n+  \/\/ 3. if (b) {\n+  \/\/      ...\n+  \/\/    } else {\n+  \/\/      ...\n+  \/\/    }\n+  \/\/    if (y == 0) {\n+  \/\/      trap;\n+  \/\/    }\n+  \/\/    x \/ y;\n+  \/\/ The division x \/ y depends only on the test (y == 0) == false, but if we split the test\n+  \/\/ through the merge point but not the division:\n+  \/\/    if (b) {\n+  \/\/      ...\n+  \/\/      if (y == 0) {\n+  \/\/        trap;\n+  \/\/      }\n+  \/\/    } else {\n+  \/\/      ...\n+  \/\/      if (y == 0) {\n+  \/\/        trap;\n+  \/\/      }\n+  \/\/    }\n+  \/\/    x \/ y;\n+  \/\/ The division now has the control input being the RegionNode merge the branches of if(b)\n+  \/\/ instead of a test that proves y != 0. As a result, it must be pinned at that node.\n+  Node* pin_node_under_control() const {\n+    assert(depends_only_on_test(), \"must be a depends_only_on_test node\");\n+    Node* res = pin_node_under_control_impl();\n+    assert(res != nullptr, \"must not return null\");\n+    assert(!res->depends_only_on_test(), \"the result must not depends_only_on_test\");\n+    return res;\n+  }\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { assert(false, \"%s\", Name()); return false; }\n+  virtual Node* pin_node_under_control_impl() const { assert(false, \"%s\", Name()); return nullptr; }\n+\n+public:\n@@ -1200,7 +1311,0 @@\n-  \/\/ Returns a clone of the current node that's pinned (if the current node is not) for nodes found in array accesses\n-  \/\/ (Load and range check CastII nodes).\n-  \/\/ This is used when an array access is made dependent on 2 or more range checks (range check smearing or Loop Predication).\n-  virtual Node* pin_array_access_node() const {\n-    return nullptr;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":119,"deletions":15,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2737,31 +2737,0 @@\n-\/\/ Check if the type of a divisor of a Div or Mod node includes zero.\n-bool PhaseIterGVN::no_dependent_zero_check(Node* n) const {\n-  switch (n->Opcode()) {\n-    case Op_DivI:\n-    case Op_ModI:\n-    case Op_UDivI:\n-    case Op_UModI: {\n-      \/\/ Type of divisor includes 0?\n-      if (type(n->in(2)) == Type::TOP) {\n-        \/\/ 'n' is dead. Treat as if zero check is still there to avoid any further optimizations.\n-        return false;\n-      }\n-      const TypeInt* type_divisor = type(n->in(2))->is_int();\n-      return (type_divisor->_hi < 0 || type_divisor->_lo > 0);\n-    }\n-    case Op_DivL:\n-    case Op_ModL:\n-    case Op_UDivL:\n-    case Op_UModL: {\n-      \/\/ Type of divisor includes 0?\n-      if (type(n->in(2)) == Type::TOP) {\n-        \/\/ 'n' is dead. Treat as if zero check is still there to avoid any further optimizations.\n-        return false;\n-      }\n-      const TypeLong* type_divisor = type(n->in(2))->is_long();\n-      return (type_divisor->_hi < 0 || type_divisor->_lo > 0);\n-    }\n-  }\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -601,1 +601,0 @@\n-  bool no_dependent_zero_check(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-  virtual bool depends_only_on_test() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/rootnode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -719,8 +719,5 @@\n-  if (iff->Opcode() == Op_RangeCheck) {\n-    \/\/ Pin array access nodes: control is updated here to a region. If, after some transformations, only one path\n-    \/\/ into the region is left, an array load could become dependent on a condition that's not a range check for\n-    \/\/ that access. If that condition is replaced by an identical dominating one, then an unpinned load would risk\n-    \/\/ floating above its range check.\n-    pin_array_access_nodes_dependent_on(new_true);\n-    pin_array_access_nodes_dependent_on(new_false);\n-  }\n+\n+  \/\/ Control is updated here to a region, which is not a test, so any node that\n+  \/\/ depends_only_on_test must be pinned\n+  pin_nodes_dependent_on(new_true);\n+  pin_nodes_dependent_on(new_false);\n@@ -738,1 +735,1 @@\n-void PhaseIdealLoop::pin_array_access_nodes_dependent_on(Node* ctrl) {\n+void PhaseIdealLoop::pin_nodes_dependent_on(Node* ctrl) {\n@@ -744,6 +741,4 @@\n-    Node* pinned_clone = use->pin_array_access_node();\n-    if (pinned_clone != nullptr) {\n-      register_new_node_with_ctrl_of(pinned_clone, use);\n-      _igvn.replace_node(use, pinned_clone);\n-      --i;\n-    }\n+    Node* pinned_clone = use->pin_node_under_control();\n+    register_new_node_with_ctrl_of(pinned_clone, use);\n+    _igvn.replace_node(use, pinned_clone);\n+    --i;\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -510,0 +510,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -525,0 +528,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n@@ -544,0 +550,3 @@\n+\n+private:\n+  virtual bool depends_only_on_test_impl() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-  bool depends_only_on_test() const { return false; }\n@@ -74,0 +73,2 @@\n+\n+  virtual bool depends_only_on_test_impl() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/subtypenode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    @IR(phase = CompilePhase.OPTIMIZE_FINISHED, counts = { IRNode.CAST_II, \"2\" })\n+    @IR(phase = CompilePhase.OPTIMIZE_FINISHED, counts = { IRNode.CAST_II, \"3\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPushAddThruCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}