{"files":[{"patch":"@@ -786,0 +786,1 @@\n+  TempNewSymbol::drain_cleanup_delay_queue();\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -46,0 +47,4 @@\n+  static Symbol* volatile _cleanup_delay_queue[];\n+  static volatile uint _cleanup_delay_index;\n+  static volatile bool _cleanup_delay_enabled;\n+\n@@ -49,0 +54,2 @@\n+  static const uint CLEANUP_DELAY_MAX_ENTRIES = 128;\n+\n@@ -56,0 +63,8 @@\n+      return;\n+    }\n+\n+    \/\/ Delay cleanup for temp symbols. Refcount is incremented while in\n+    \/\/ queue. But don't requeue existing entries, or entries that are held\n+    \/\/ elsewhere - it's a waste of effort.\n+    if (s != nullptr && s->refcount() == 1) {\n+      add_to_cleanup_delay_queue(s);\n@@ -79,0 +94,13 @@\n+  \/\/ Keep this symbol alive for some time to allow for reuse.\n+  \/\/ Temp symbols for the same string can often be created in quick succession,\n+  \/\/ and this queue allows them to be reused instead of churning.\n+  void add_to_cleanup_delay_queue(Symbol* sym) {\n+    if (!_cleanup_delay_enabled) return;\n+    sym->increment_refcount();\n+    uint i = Atomic::add(&_cleanup_delay_index, 1u) % CLEANUP_DELAY_MAX_ENTRIES;\n+    Symbol* old = Atomic::xchg(&_cleanup_delay_queue[i], sym);\n+    if (old != nullptr) {\n+        old->decrement_refcount();\n+    }\n+  }\n+\n@@ -87,0 +115,16 @@\n+\n+  static void drain_cleanup_delay_queue() {\n+    if (!_cleanup_delay_enabled) return;\n+    for (uint i = 0; i < CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+      Symbol* sym = Atomic::xchg(&_cleanup_delay_queue[i], (Symbol*) nullptr);\n+      if (sym != nullptr) {\n+          sym->decrement_refcount();\n+      }\n+    }\n+  }\n+\n+  \/\/ Useful for testing.\n+  static void set_cleanup_delay_enabled(bool enabled) {\n+    if (_cleanup_delay_enabled && !enabled) drain_cleanup_delay_queue();\n+    _cleanup_delay_enabled = enabled;\n+  }\n@@ -89,0 +133,7 @@\n+template<bool TEMP>\n+Symbol* volatile SymbolHandleBase<TEMP>::_cleanup_delay_queue[CLEANUP_DELAY_MAX_ENTRIES] = {};\n+template<bool TEMP>\n+volatile uint SymbolHandleBase<TEMP>::_cleanup_delay_index = 0;\n+template<bool TEMP>\n+volatile bool SymbolHandleBase<TEMP>::_cleanup_delay_enabled = true;\n+\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  TempNewSymbol A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n-  TempNewSymbol D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  Symbol* A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n+  Symbol* D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n@@ -45,1 +45,1 @@\n-  TempNewSymbol interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+  Symbol* interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+  \/\/ Disable the temp symbol cleanup delay queue because it increases refcounts.\n+  TempNewSymbol::set_cleanup_delay_enabled(false);\n@@ -91,0 +93,3 @@\n+\n+  \/\/ Reset for other tests\n+  TempNewSymbol::set_cleanup_delay_enabled(true);\n@@ -142,0 +147,24 @@\n+\n+TEST_VM(SymbolTable, test_cleanup_delay) {\n+  \/\/ Check that new temp symbols have an extra refcount increment, which is then\n+  \/\/ decremented when the queue spills over.\n+\n+  TempNewSymbol s1 = SymbolTable::new_symbol(\"temp-s1\");\n+  ASSERT_EQ(s1->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ Fill up the queue\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[symbol_name_length];\n+  for (uint i = 1; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n+    TempNewSymbol s = SymbolTable::new_symbol(symbol_name);\n+    ASSERT_EQ(s->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  }\n+\n+  \/\/ Add one more\n+  TempNewSymbol spillover = SymbolTable::new_symbol(\"temp-spillover\");\n+  ASSERT_EQ(spillover->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ The first symbol should have been removed from the queue and decremented\n+  ASSERT_EQ(s1->refcount(), 1) << \"TempNewSymbol off queue refcount is 1\";\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}