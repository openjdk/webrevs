{"files":[{"patch":"@@ -30,22 +30,0 @@\n-#include \"utilities\/nonblockingQueue.inline.hpp\"\n-\n-class TempSymbolDelayQueueNode : public CHeapObj<mtSymbol> {\n-private:\n-  Symbol* const _val;\n-  TempSymbolDelayQueueNode* volatile _next;\n-\n-public:\n-  static TempSymbolDelayQueueNode* volatile* next(TempSymbolDelayQueueNode& node) {\n-    return &node._next;\n-  }\n-\n-  TempSymbolDelayQueueNode(Symbol* val) : _val(val), _next(nullptr) {\n-    _val->increment_refcount();\n-  }\n-\n-  ~TempSymbolDelayQueueNode() {\n-    _val->decrement_refcount();\n-  }\n-};\n-\n-typedef NonblockingQueue<TempSymbolDelayQueueNode, &TempSymbolDelayQueueNode::next> TempSymbolDelayQueue;\n@@ -68,3 +46,4 @@\n-  static TempSymbolDelayQueue _cleanup_delay;\n-  static volatile int32_t _cleanup_delay_len;\n-  static volatile int32_t _cleanup_delay_max_entries;\n+  static const uint CLEANUP_DELAY_MAX_ENTRIES;\n+  static Symbol* volatile _cleanup_delay_queue[];\n+  static volatile uint _cleanup_delay_index;\n+  static volatile bool _cleanup_delay_enabled;\n@@ -117,10 +96,6 @@\n-    TempSymbolDelayQueueNode* node = new TempSymbolDelayQueueNode(sym);\n-    _cleanup_delay.push(*node);\n-\n-    \/\/ If the queue is now full, implement a one-in, one-out policy.\n-    if (Atomic::add(&_cleanup_delay_len, 1, memory_order_relaxed) > _cleanup_delay_max_entries) {\n-      TempSymbolDelayQueueNode* result = _cleanup_delay.pop();\n-      if (result != nullptr) {\n-        delete result;\n-        Atomic::dec(&_cleanup_delay_len);\n-      }\n+    if (!_cleanup_delay_enabled) return;\n+    sym->increment_refcount();\n+    uint i = Atomic::add(&_cleanup_delay_index, 1u) % CLEANUP_DELAY_MAX_ENTRIES;\n+    Symbol* old = Atomic::xchg(&_cleanup_delay_queue[i], sym);\n+    if (old != nullptr) {\n+        old->decrement_refcount();\n@@ -140,4 +115,6 @@\n-    TempSymbolDelayQueueNode* curr;\n-    while ((curr = _cleanup_delay.pop()) != nullptr) {\n-      delete curr;\n-      Atomic::dec(&_cleanup_delay_len);\n+    if (!_cleanup_delay_enabled) return;\n+    for (uint i = 0; i < CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+      Symbol* sym = Atomic::xchg(&_cleanup_delay_queue[i], (Symbol*) nullptr);\n+      if (sym != nullptr) {\n+          sym->decrement_refcount();\n+      }\n@@ -148,3 +125,3 @@\n-  static void set_cleanup_delay_max_entries(int32_t val) {\n-    _cleanup_delay_max_entries = val;\n-    drain_cleanup_delay_queue();\n+  static void set_cleanup_delay_enabled(bool enabled) {\n+    if (_cleanup_delay_enabled && !enabled) drain_cleanup_delay_queue();\n+    _cleanup_delay_enabled = enabled;\n@@ -155,1 +132,3 @@\n-TempSymbolDelayQueue SymbolHandleBase<TEMP>::_cleanup_delay;\n+const uint SymbolHandleBase<TEMP>::CLEANUP_DELAY_MAX_ENTRIES = 100;\n+template<bool TEMP>\n+Symbol* volatile SymbolHandleBase<TEMP>::_cleanup_delay_queue[CLEANUP_DELAY_MAX_ENTRIES] = {};\n@@ -157,1 +136,1 @@\n-volatile int32_t SymbolHandleBase<TEMP>::_cleanup_delay_len = 0;\n+volatile uint SymbolHandleBase<TEMP>::_cleanup_delay_index = 0;\n@@ -159,1 +138,1 @@\n-volatile int32_t SymbolHandleBase<TEMP>::_cleanup_delay_max_entries = 100;\n+volatile bool SymbolHandleBase<TEMP>::_cleanup_delay_enabled = true;\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":24,"deletions":45,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  inline ~NonblockingQueue() = default;\n+  inline ~NonblockingQueue() NOT_DEBUG(= default);\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,8 @@\n+#ifdef ASSERT\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+NonblockingQueue<T, next_ptr>::~NonblockingQueue() {\n+  assert(_head == nullptr, \"precondition\");\n+  assert(_tail == nullptr, \"precondition\");\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  TempNewSymbol::set_cleanup_delay_max_entries(0);\n+  TempNewSymbol::set_cleanup_delay_enabled(false);\n@@ -93,0 +93,3 @@\n+\n+  \/\/ Reset for other tests\n+  TempNewSymbol::set_cleanup_delay_enabled(true);\n@@ -149,2 +152,0 @@\n-  \/\/ Fill up the queue\n-  TempNewSymbol::set_cleanup_delay_max_entries(3);\n@@ -153,4 +154,9 @@\n-  TempNewSymbol s2 = SymbolTable::new_symbol(\"temp-s2\");\n-  ASSERT_EQ(s2->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n-  TempNewSymbol s3 = SymbolTable::new_symbol(\"temp-s3\");\n-  ASSERT_EQ(s3->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ Fill up the queue\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[symbol_name_length];\n+  for (int i = 1; i < 100; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n+    TempNewSymbol s = SymbolTable::new_symbol(symbol_name);\n+    ASSERT_EQ(s->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  }\n@@ -159,2 +165,2 @@\n-  TempNewSymbol s4 = SymbolTable::new_symbol(\"temp-s4-spillover\");\n-  ASSERT_EQ(s4->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  TempNewSymbol spillover = SymbolTable::new_symbol(\"temp-spillover\");\n+  ASSERT_EQ(spillover->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"}]}