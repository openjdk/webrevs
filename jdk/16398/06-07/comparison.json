{"files":[{"patch":"@@ -49,1 +49,0 @@\n-  static volatile bool _cleanup_delay_enabled;\n@@ -54,1 +53,1 @@\n-  static const uint CLEANUP_DELAY_MAX_ENTRIES = 128;\n+  static constexpr uint CLEANUP_DELAY_MAX_ENTRIES = 128;\n@@ -98,1 +97,0 @@\n-    if (!_cleanup_delay_enabled) return;\n@@ -100,1 +98,2 @@\n-    uint i = Atomic::add(&_cleanup_delay_index, 1u) % CLEANUP_DELAY_MAX_ENTRIES;\n+    STATIC_ASSERT(is_power_of_2(CLEANUP_DELAY_MAX_ENTRIES)); \/\/ allow modulo shortcut\n+    uint i = Atomic::add(&_cleanup_delay_index, 1u) & (CLEANUP_DELAY_MAX_ENTRIES - 1);\n@@ -117,1 +116,0 @@\n-    if (!_cleanup_delay_enabled) return;\n@@ -125,6 +123,0 @@\n-\n-  \/\/ Useful for testing.\n-  static void set_cleanup_delay_enabled(bool enabled) {\n-    if (_cleanup_delay_enabled && !enabled) drain_cleanup_delay_queue();\n-    _cleanup_delay_enabled = enabled;\n-  }\n@@ -137,2 +129,0 @@\n-template<bool TEMP>\n-volatile bool SymbolHandleBase<TEMP>::_cleanup_delay_enabled = true;\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,0 +30,8 @@\n+\/\/ Helper to avoid interference from the cleanup delay queue by draining it \n+\/\/ immediately after creation.\n+TempNewSymbol tmp(Symbol* sym) {\n+  TempNewSymbol t = sym;\n+  TempNewSymbol::drain_cleanup_delay_queue();\n+  return t;\n+}\n+\n@@ -36,2 +44,0 @@\n-  \/\/ Disable the temp symbol cleanup delay queue because it increases refcounts.\n-  TempNewSymbol::set_cleanup_delay_enabled(false);\n@@ -41,1 +47,1 @@\n-  TempNewSymbol ss = abc;\n+  TempNewSymbol ss = tmp(abc);\n@@ -50,2 +56,2 @@\n-  TempNewSymbol s1 = efg;\n-  TempNewSymbol s2 = hij;\n+  TempNewSymbol s1 = tmp(efg);\n+  TempNewSymbol s2 = tmp(hij);\n@@ -70,1 +76,1 @@\n-  s3 = klm; \/\/ assignment\n+  s3 = tmp(klm); \/\/ assignment\n@@ -76,1 +82,1 @@\n-    TempNewSymbol s_inner = xyz;\n+    TempNewSymbol s_inner = tmp(xyz);\n@@ -93,3 +99,0 @@\n-\n-  \/\/ Reset for other tests\n-  TempNewSymbol::set_cleanup_delay_enabled(true);\n@@ -171,0 +174,23 @@\n+\n+TEST_VM(SymbolTable, test_cleanup_delay_drain) {\n+  \/\/ Fill up the queue\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[symbol_name_length];\n+  TempNewSymbol symbols[TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES] = {};\n+  for (uint i = 0; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"temp-%d\", i);\n+    TempNewSymbol s = SymbolTable::new_symbol(symbol_name);\n+    symbols[i] = s;\n+  }\n+\n+  \/\/ While in the queue refcounts are incremented\n+  for (uint i = 0; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+    ASSERT_EQ(symbols[i]->refcount(), 2) << \"TempNewSymbol refcount in queue is 2\";\n+  }\n+\n+  \/\/ Draining the queue should decrement the refcounts\n+  TempNewSymbol::drain_cleanup_delay_queue();\n+  for (uint i = 0; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+    ASSERT_EQ(symbols[i]->refcount(), 1) << \"TempNewSymbol refcount after drain is 1\";\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":36,"deletions":10,"binary":false,"changes":46,"status":"modified"}]}