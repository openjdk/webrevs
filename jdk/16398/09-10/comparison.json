{"files":[{"patch":"@@ -789,1 +789,1 @@\n-  TempNewSymbol::drain_cleanup_delay_queue();\n+  TempSymbolCleanupDelayer::drain_queue();\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+#include \"oops\/symbolHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+Symbol* volatile TempSymbolCleanupDelayer::_queue[QueueSize] = {};\n+volatile uint TempSymbolCleanupDelayer::_index = 0;\n+\n+\/\/ Keep this symbol alive for some time to allow for reuse.\n+\/\/ Temp symbols for the same string can often be created in quick succession,\n+\/\/ and this queue allows them to be reused instead of churning.\n+void TempSymbolCleanupDelayer::delay_cleanup(Symbol* sym) {\n+  assert(sym != nullptr, \"precondition\");\n+  sym->increment_refcount();\n+  uint i = Atomic::add(&_index, 1u) % QueueSize;\n+  Symbol* old = Atomic::xchg(&_queue[i], sym);\n+  Symbol::maybe_decrement_refcount(old);\n+}\n+\n+void TempSymbolCleanupDelayer::drain_queue() {\n+  for (uint i = 0; i < QueueSize; i++) {\n+    Symbol* sym = Atomic::xchg(&_queue[i], (Symbol*) nullptr);\n+    Symbol::maybe_decrement_refcount(sym);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -30,1 +30,10 @@\n-#include \"runtime\/atomic.hpp\"\n+\n+class TempSymbolCleanupDelayer : AllStatic {\n+  static Symbol* volatile _queue[];\n+  static volatile uint _index;\n+\n+public:\n+  static const uint QueueSize = 128;\n+  static void delay_cleanup(Symbol* s);\n+  static void drain_queue();\n+};\n@@ -47,3 +56,0 @@\n-  static Symbol* volatile _cleanup_delay_queue[];\n-  static volatile uint _cleanup_delay_index;\n-\n@@ -53,2 +59,0 @@\n-  static constexpr uint CLEANUP_DELAY_MAX_ENTRIES = 128;\n-\n@@ -58,1 +62,0 @@\n-  \/\/ Does not increment the current reference count if temporary.\n@@ -69,1 +72,1 @@\n-      add_to_cleanup_delay_queue(s);\n+      TempSymbolCleanupDelayer::delay_cleanup(s);\n@@ -93,13 +96,0 @@\n-  \/\/ Keep this symbol alive for some time to allow for reuse.\n-  \/\/ Temp symbols for the same string can often be created in quick succession,\n-  \/\/ and this queue allows them to be reused instead of churning.\n-  void add_to_cleanup_delay_queue(Symbol* sym) {\n-    sym->increment_refcount();\n-    STATIC_ASSERT(is_power_of_2(CLEANUP_DELAY_MAX_ENTRIES)); \/\/ allow modulo shortcut\n-    uint i = Atomic::add(&_cleanup_delay_index, 1u) & (CLEANUP_DELAY_MAX_ENTRIES - 1);\n-    Symbol* old = Atomic::xchg(&_cleanup_delay_queue[i], sym);\n-    if (old != nullptr) {\n-      old->decrement_refcount();\n-    }\n-  }\n-\n@@ -114,9 +104,0 @@\n-\n-  static void drain_cleanup_delay_queue() {\n-    for (uint i = 0; i < CLEANUP_DELAY_MAX_ENTRIES; i++) {\n-      Symbol* sym = Atomic::xchg(&_cleanup_delay_queue[i], (Symbol*) nullptr);\n-      if (sym != nullptr) {\n-        sym->decrement_refcount();\n-      }\n-    }\n-  }\n@@ -125,5 +106,0 @@\n-template<bool TEMP>\n-Symbol* volatile SymbolHandleBase<TEMP>::_cleanup_delay_queue[CLEANUP_DELAY_MAX_ENTRIES] = {};\n-template<bool TEMP>\n-volatile uint SymbolHandleBase<TEMP>::_cleanup_delay_index = 0;\n-\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":11,"deletions":35,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -34,0 +34,8 @@\n+\/\/ Helper to avoid interference from the cleanup delay queue by draining it\n+\/\/ immediately after creation.\n+TempNewSymbol new_stable_temp_symbol(const char* name) {\n+  TempNewSymbol t = SymbolTable::new_symbol(name);\n+  TempSymbolCleanupDelayer::drain_queue();\n+  return t;\n+}\n+\n@@ -42,2 +50,2 @@\n-  Symbol* A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n-  Symbol* D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  TempNewSymbol A = new_stable_temp_symbol(\"abc2_8_2023_class\");\n+  TempNewSymbol D = new_stable_temp_symbol(\"def2_8_2023_class\");\n@@ -45,1 +53,1 @@\n-  Symbol* interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+  TempNewSymbol interf = new_stable_temp_symbol(\"interface2_8_2023_supername\");\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  TempNewSymbol::drain_cleanup_delay_queue();\n+  TempSymbolCleanupDelayer::drain_queue();\n@@ -161,1 +161,1 @@\n-  for (uint i = 1; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+  for (uint i = 1; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n@@ -179,2 +179,2 @@\n-  TempNewSymbol symbols[TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES] = {};\n-  for (uint i = 0; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+  TempNewSymbol symbols[TempSymbolCleanupDelayer::QueueSize] = {};\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n@@ -187,1 +187,1 @@\n-  for (uint i = 0; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n@@ -192,2 +192,2 @@\n-  TempNewSymbol::drain_cleanup_delay_queue();\n-  for (uint i = 0; i < TempNewSymbol::CLEANUP_DELAY_MAX_ENTRIES; i++) {\n+  TempSymbolCleanupDelayer::drain_queue();\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}