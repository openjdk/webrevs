{"files":[{"patch":"@@ -133,1 +133,1 @@\n-      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_virtual_call_stub());\n+      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_virtual_call_stub(), JVMCI_CHECK);\n@@ -140,1 +140,1 @@\n-      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_static_call_stub());\n+      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_static_call_stub(), JVMCI_CHECK);\n@@ -147,1 +147,1 @@\n-      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_opt_virtual_call_stub());\n+      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_opt_virtual_call_stub(), JVMCI_CHECK);\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#endif\n@@ -526,0 +529,1 @@\n+#if INCLUDE_JVMCI\n@@ -528,1 +532,1 @@\n-address NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest) {\n+void NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS) {\n@@ -530,6 +534,0 @@\n-  address stub = NULL;\n-\n-  if (a.far_branches()\n-      && ! is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n-    stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n-  }\n@@ -537,4 +535,2 @@\n-  if (stub == NULL) {\n-    \/\/ If we generated no stub, patch this call directly to dest.\n-    \/\/ This will happen if we don't need far branches or if there\n-    \/\/ already was a trampoline.\n+  if (!a.far_branches()) {\n+    \/\/ If not using far branches, patch this call directly to dest.\n@@ -542,0 +538,11 @@\n+  } else if (!is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n+    \/\/ If we want far branches and there isn't a trampoline stub, emit one.\n+    address stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n+    if (stub == nullptr) {\n+      JVMCI_ERROR(\"could not emit trampoline stub - code cache is full\");\n+    }\n+    \/\/ The relocation created while emitting the stub will ensure this\n+    \/\/ call instruction is subsequently patched to call the stub.\n+  } else {\n+    \/\/ Not sure how this can be happen but be defensive\n+    JVMCI_ERROR(\"single-use stub should not exist\");\n@@ -543,2 +550,0 @@\n-\n-  return stub;\n@@ -546,0 +551,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+#include \"runtime\/os.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciExceptions.hpp\"\n+#endif\n+\n@@ -254,1 +259,3 @@\n-  address trampoline_jump(CodeBuffer &cbuf, address dest);\n+#if INCLUDE_JVMCI\n+  void trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -341,0 +341,2 @@\n+\n+  \/\/ Returns NULL if CodeBuffer::expand fails\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1181,1 +1181,3 @@\n-      CompiledStaticCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset);\n+      if (CompiledStaticCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset) == nullptr) {\n+        JVMCI_ERROR(\"could not emit to_interp stub - code cache is full\");\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}