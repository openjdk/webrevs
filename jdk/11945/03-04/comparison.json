{"files":[{"patch":"@@ -535,13 +535,1 @@\n-  if (a.far_branches()) {\n-    if (!is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n-      address stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n-      if (stub == nullptr) {\n-        JVMCI_ERROR(\"could not emit trampoline stub - code cache is full\");\n-      }\n-      \/\/ The relocation is created while emitting the stub will ensure this\n-      \/\/ call instruction is subsequently patched to call the stub.\n-    } else {\n-      \/\/ Not sure how this can be happen but be defensive\n-      JVMCI_ERROR(\"single-use stub should not exist\");\n-    }\n-  } else {\n+  if (!a.far_branches()) {\n@@ -550,0 +538,11 @@\n+  } else if (!is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n+    \/\/ If we want far branches and there isn't a trampoline stub, emit one.\n+    address stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n+    if (stub == nullptr) {\n+      JVMCI_ERROR(\"could not emit trampoline stub - code cache is full\");\n+    }\n+    \/\/ The relocation created while emitting the stub will ensure this\n+    \/\/ call instruction is subsequently patched to call the stub.\n+  } else {\n+    \/\/ Not sure how this can be happen but be defensive\n+    JVMCI_ERROR(\"single-use stub should not exist\");\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"}]}