{"files":[{"patch":"@@ -499,0 +499,10 @@\n+     * @implNote {@code HashMap}'s resize policy is intentionally conservative to\n+     *           avoid an unnecessarily large capacity if {@code m} contains many\n+     *           duplicate keys. This can lead to a potentially expensive, extra\n+     *           resize operation. To avoid such an additional resize operation,\n+     *           callers of {@link putAll} can use the\n+     *           {@link #HashMap(int) HashMap(int initialCapacity)} constructor or\n+     *           {@link #newHashMap(int) newHashMap} to create a map with a large\n+     *           enough capacity before calling {@link putAll} to ensure that the\n+     *           map is only resized and copied once.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-    private Supplier<Map<Integer, Integer>> mapSupplier;\n-    private Map<Integer, Integer> bigMapToAdd;\n+    private Map<Integer, Integer> mapToAdd;\n+    private Map<Integer, Integer> mapToAddLinear;\n@@ -58,1 +58,1 @@\n-    @Param(\"1000000\")\n+    @Param({\"0\", \"1\", \"100000\"})\n@@ -61,0 +61,3 @@\n+    @Param({\"0\", \"100000\"})\n+    private int addSize;\n+\n@@ -69,2 +72,5 @@\n-    @Setup\n-    public void setup() {\n+    private Map<Integer, Integer> getMap() {\n+        return getMap(0);\n+    }\n+\n+    private Map<Integer, Integer> getMap(int size) {\n@@ -73,2 +79,1 @@\n-            mapSupplier = () -> new HashMap<>();\n-            break;\n+            return new HashMap<>(size);\n@@ -76,2 +81,1 @@\n-            mapSupplier = () -> new LinkedHashMap<>();\n-            break;\n+            return new LinkedHashMap<>(size);\n@@ -81,0 +85,1 @@\n+    }\n@@ -82,0 +87,4 @@\n+    @Setup\n+    public void setup() {\n+        mapToAdd = getMap(addSize);\n+        mapToAddLinear = getMap(addSize);\n@@ -83,2 +92,5 @@\n-        this.bigMapToAdd = IntStream.range(0, size).boxed()\n-            .collect(toMap(i -> 7 + i * 128, i -> rnd.nextInt()));\n+        for (int i = 0; i < addSize; ++i) {\n+            int r = rnd.nextInt();\n+            mapToAdd.put(r, r);\n+            mapToAddLinear.put(i, i);\n+        }\n@@ -88,4 +100,8 @@\n-    public int putAllWithBigMapToNonEmptyMap() {\n-        Map<Integer, Integer> map = mapSupplier.get();\n-        map.put(-1, -1);\n-        map.putAll(bigMapToAdd);\n+    public int putAll() {\n+        Map<Integer, Integer> map = getMap(size);\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        for (int i = 0; i < size; ++i) {\n+            int r = rnd.nextInt();\n+            map.put(r, r);\n+        }\n+        map.putAll(mapToAdd);\n@@ -96,3 +112,7 @@\n-    public int putAllWithBigMapToEmptyMap() {\n-        Map<Integer, Integer> map = mapSupplier.get();\n-        map.putAll(bigMapToAdd);\n+    public int putAllSameKeys() {\n+        Map<Integer, Integer> map = getMap(size);\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        for (int i = 0; i < size; ++i) {\n+            map.put(i, i);\n+        }\n+        map.putAll(mapToAddLinear);\n@@ -104,3 +124,3 @@\n-        Map<Integer, Integer> map = mapSupplier.get();\n-        for (int k : bigMapToAdd.keySet()) {\n-            map.put(k, bigMapToAdd.get(k));\n+        Map<Integer, Integer> map = getMap();\n+        for (int k : mapToAdd.keySet()) {\n+            map.put(k, mapToAdd.get(k));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HashMapBench.java","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"}]}