{"files":[{"patch":"@@ -220,2 +220,1 @@\n-  const ZPageAge age = page->age();\n-  if (age == ZPageAge::old) {\n+  if (!page->allows_raw_null()) {\n@@ -223,2 +222,2 @@\n-    \/\/ breaks that promise. Take a few steps in the interpreter instead, which has\n-    \/\/ no such assumptions about where an object resides.\n+    \/\/ is too old to guarantee that. Take a few steps in the interpreter instead,\n+    \/\/ which does not elide barriers based on the age of an object.\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -193,1 +193,2 @@\n-  _relocate.barrier_flip_promoted_pages(_relocation_set.flip_promoted_pages());\n+  _relocate.barrier_promoted_pages(_relocation_set.flip_promoted_pages(),\n+                                   _relocation_set.relocate_promoted_pages());\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-    _multi_partition_tracker(multi_partition_tracker) {\n+    _multi_partition_tracker(multi_partition_tracker),\n+    _relocate_promoted(false) {\n@@ -73,0 +74,8 @@\n+bool ZPage::allows_raw_null() const {\n+  return is_young() && !AtomicAccess::load(&_relocate_promoted);\n+}\n+\n+void ZPage::set_is_relocate_promoted() {\n+  AtomicAccess::store(&_relocate_promoted, true);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  volatile bool                 _relocate_promoted;\n@@ -106,0 +107,3 @@\n+  bool allows_raw_null() const;\n+  void set_is_relocate_promoted();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,2 @@\n-  ZArrayParallelIterator<ZPage*> _iter;\n+  ZArrayParallelIterator<ZPage*> _flip_promoted_iter;\n+  ZArrayParallelIterator<ZPage*> _relocate_promoted_iter;\n@@ -1372,1 +1373,2 @@\n-  ZPromoteBarrierTask(const ZArray<ZPage*>* pages)\n+  ZPromoteBarrierTask(const ZArray<ZPage*>* flip_promoted_pages,\n+                      const ZArray<ZPage*>* relocate_promoted_pages)\n@@ -1374,1 +1376,2 @@\n-      _iter(pages) {}\n+      _flip_promoted_iter(flip_promoted_pages),\n+      _relocate_promoted_iter(relocate_promoted_pages) {}\n@@ -1379,8 +1382,13 @@\n-    for (ZPage* page; _iter.next(&page);) {\n-      \/\/ When promoting an object (and before relocate start), we must ensure that all\n-      \/\/ contained zpointers are store good. The marking code ensures that for non-null\n-      \/\/ pointers, but null pointers are ignored. This code ensures that even null pointers\n-      \/\/ are made store good, for the promoted objects.\n-      page->object_iterate([&](oop obj) {\n-        ZIterator::basic_oop_iterate_safe(obj, ZBarrier::promote_barrier_on_young_oop_field);\n-      });\n+    auto promote_barriers = [&](ZArrayParallelIterator<ZPage*>* iter) {\n+      for (ZPage* page; iter->next(&page);) {\n+        \/\/ When promoting an object (and before relocate start), we must ensure that all\n+        \/\/ contained zpointers are store good. The marking code ensures that for non-null\n+        \/\/ pointers, but null pointers are ignored. This code ensures that even null pointers\n+        \/\/ are made store good, for the promoted objects.\n+        page->object_iterate([&](oop obj) {\n+          ZIterator::basic_oop_iterate_safe(obj, ZBarrier::promote_barrier_on_young_oop_field);\n+        });\n+\n+        SuspendibleThreadSet::yield();\n+      }\n+    };\n@@ -1388,2 +1396,2 @@\n-      SuspendibleThreadSet::yield();\n-    }\n+    promote_barriers(&_flip_promoted_iter);\n+    promote_barriers(&_relocate_promoted_iter);\n@@ -1398,2 +1406,3 @@\n-void ZRelocate::barrier_flip_promoted_pages(const ZArray<ZPage*>* pages) {\n-  ZPromoteBarrierTask promote_barrier_task(pages);\n+void ZRelocate::barrier_promoted_pages(const ZArray<ZPage*>* flip_promoted_pages,\n+                                       const ZArray<ZPage*>* relocate_promoted_pages) {\n+  ZPromoteBarrierTask promote_barrier_task(flip_promoted_pages, relocate_promoted_pages);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -122,1 +122,2 @@\n-  void barrier_flip_promoted_pages(const ZArray<ZPage*>* pages);\n+  void barrier_promoted_pages(const ZArray<ZPage*>* flip_promoted_pages,\n+                              const ZArray<ZPage*>* relocate_promoted_pages);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  ZRelocationSet*                _relocation_set;\n@@ -57,10 +58,0 @@\n-\n-    if (forwarding->is_promotion()) {\n-      \/\/ Before promoting an object (and before relocate start), we must ensure that all\n-      \/\/ contained zpointers are store good. The marking code ensures that for non-null\n-      \/\/ pointers, but null pointers are ignored. This code ensures that even null pointers\n-      \/\/ are made store good, for the promoted objects.\n-      page->object_iterate([&](oop obj) {\n-        ZIterator::basic_oop_iterate_safe(obj, ZBarrier::promote_barrier_on_young_oop_field);\n-      });\n-    }\n@@ -81,0 +72,7 @@\n+  void track_if_promoted(ZPage* page, ZForwarding* forwarding, ZArray<ZPage*>& relocate_promoted) {\n+    if (forwarding->is_promotion()) {\n+      page->set_is_relocate_promoted();\n+      relocate_promoted.append(page);\n+    }\n+  }\n+\n@@ -82,1 +80,1 @@\n-  ZRelocationSetInstallTask(ZForwardingAllocator* allocator, const ZRelocationSetSelector* selector)\n+  ZRelocationSetInstallTask(ZRelocationSet* relocation_set, const ZRelocationSetSelector* selector)\n@@ -84,1 +82,2 @@\n-      _allocator(allocator),\n+      _relocation_set(relocation_set),\n+      _allocator(&relocation_set->_allocator),\n@@ -111,0 +110,2 @@\n+    ZArray<ZPage*> relocate_promoted;\n+\n@@ -116,0 +117,1 @@\n+      track_if_promoted(page, forwarding, relocate_promoted);\n@@ -125,0 +127,1 @@\n+      track_if_promoted(page, forwarding, relocate_promoted);\n@@ -128,0 +131,2 @@\n+\n+    _relocation_set->register_relocate_promoted(relocate_promoted);\n@@ -146,0 +151,1 @@\n+    _relocate_promoted_pages(),\n@@ -160,0 +166,4 @@\n+ZArray<ZPage*>* ZRelocationSet::relocate_promoted_pages() {\n+  return &_relocate_promoted_pages;\n+}\n+\n@@ -162,1 +172,1 @@\n-  ZRelocationSetInstallTask task(&_allocator, selector);\n+  ZRelocationSetInstallTask task(this, selector);\n@@ -192,0 +202,1 @@\n+  _relocate_promoted_pages.clear();\n@@ -202,0 +213,12 @@\n+void ZRelocationSet::register_relocate_promoted(const ZArray<ZPage*>& pages) {\n+  if (pages.is_empty()) {\n+    return;\n+  }\n+\n+  ZLocker<ZLock> locker(&_promotion_lock);\n+  for (ZPage* const page : pages) {\n+    assert(!_relocate_promoted_pages.contains(page), \"no duplicates allowed\");\n+    _relocate_promoted_pages.append(page);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  friend class ZRelocationSetInstallTask;\n@@ -48,0 +49,1 @@\n+  ZArray<ZPage*>       _relocate_promoted_pages;\n@@ -61,0 +63,1 @@\n+  ZArray<ZPage*>* relocate_promoted_pages();\n@@ -63,0 +66,1 @@\n+  void register_relocate_promoted(const ZArray<ZPage*>& pages);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}