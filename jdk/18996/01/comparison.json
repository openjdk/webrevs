{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.internal.org.jline.terminal.TerminalBuilder.SystemOutput;\n@@ -54,1 +55,3 @@\n-                                               .exec(false).build();\n+                                               .exec(false)\n+                                               .systemOutput(SystemOutput.SysOut)\n+                                               .build();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,1 +509,2 @@\n-                        new FileOutputStream(console == TerminalProvider.Stream.Output ? FileDescriptor.out : FileDescriptor.err),\n+                        \/\/JDK change: always write into stdout:\n+                        new FileOutputStream(FileDescriptor.out),\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8330998\n+ * @summary Verify that even if the stdout is redirected java.io.Console will\n+ *          use it for writing.\n+ * @run main RedirectedStdOut runRedirectAllTest\n+ * @run main\/othervm RedirectedStdOut runRedirectOutOnly\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class RedirectedStdOut {\n+    private static final String OUTPUT = \"Hello!\";\n+\n+    public static void main(String... args) throws Throwable {\n+        RedirectedStdOut.class.getDeclaredMethod(args[0])\n+                              .invoke(new RedirectedStdOut());\n+    }\n+\n+    \/\/verify the case where neither stdin\/out\/err is attached to a terminal,\n+    \/\/this test is weaker, but more reliable:\n+    void runRedirectAllTest() throws Exception {\n+        String testJDK = System.getProperty(\"test.jdk\");\n+        Path javaLauncher = Path.of(testJDK, \"bin\", \"java\");\n+        AtomicReference<byte[]> out = new AtomicReference<>();\n+        AtomicReference<byte[]> err = new AtomicReference<>();\n+        Process launched = new ProcessBuilder(javaLauncher.toString(),\n+                                              \"--class-path\",\n+                                              System.getProperty(\"test.classes\"),\n+                                              ConsoleTest.class.getName()\n+                                              )\n+                           .start();\n+        Thread outReader = Thread.ofVirtual().unstarted(() -> {\n+            try {\n+                out.set(launched.getInputStream().readAllBytes());\n+            } catch (IOException ex) {\n+                ex.printStackTrace();\n+            }\n+        });\n+\n+        outReader.start();\n+\n+        Thread errReader = Thread.ofVirtual().unstarted(() -> {\n+            try {\n+                err.set(launched.getErrorStream().readAllBytes());\n+            } catch (IOException ex) {\n+                ex.printStackTrace();\n+            }\n+        });\n+\n+        errReader.start();\n+\n+        int r = launched.waitFor();\n+\n+        outReader.join();\n+        errReader.join();\n+\n+        String actualOut = new String(out.get());\n+        String actualErr = new String(err.get());\n+\n+        if (r != 0) {\n+            throw new AssertionError(\"Unexpected return value: \" + r +\n+                                     \", actualOut: \" + actualOut +\n+                                     \", actualErr: \" + actualErr);\n+        }\n+\n+        String expectedOut = OUTPUT;\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+\n+        String expectedErr = \"\";\n+\n+        if (!Objects.equals(expectedErr, actualErr)) {\n+            throw new AssertionError(\"Unexpected stderr content. \" +\n+                                     \"Expected: '\" + expectedErr + \"'\" +\n+                                     \", got: '\" + actualErr + \"'\");\n+        }\n+    }\n+\n+    \/\/verify the case where stdin is attached to a terminal,\n+    \/\/this test allocates pty, and it might be skipped, if the appropriate\n+    \/\/native functions cannot be found\n+    \/\/it also leaves the VM in a broken state (with a pty attached), and so\n+    \/\/should run in a separate VM instance\n+    void runRedirectOutOnly() throws Throwable {\n+        Path stdout = Path.of(\".\", \"stdout.txt\").toAbsolutePath();\n+\n+        Files.deleteIfExists(stdout);\n+\n+        Linker linker = Linker.nativeLinker();\n+        SymbolLookup stdlib = linker.defaultLookup();\n+        MemorySegment parent = Arena.global().allocate(ValueLayout.ADDRESS);\n+        MemorySegment child = Arena.global().allocate(ValueLayout.ADDRESS);\n+        Optional<MemorySegment> openptyAddress = stdlib.find(\"openpty\");\n+\n+        if (openptyAddress.isEmpty()) {\n+            System.out.println(\"Cannot lookup openpty.\");\n+            \/\/does not have forkpty, ignore\n+            return ;\n+        }\n+\n+        Optional<MemorySegment> loginttyAddress = stdlib.find(\"login_tty\");\n+\n+        if (loginttyAddress.isEmpty()) {\n+            System.out.println(\"Cannot lookup login_tty.\");\n+            \/\/does not have forkpty, ignore\n+            return ;\n+        }\n+\n+        FunctionDescriptor openttyDescriptor =\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS);\n+        MethodHandle forkpty = linker.downcallHandle(openptyAddress.get(),\n+                                                     openttyDescriptor);\n+        int res = (int) forkpty.invoke(parent,\n+                                       child,\n+                                       MemorySegment.NULL,\n+                                       MemorySegment.NULL,\n+                                       MemorySegment.NULL);\n+\n+        if (res != 0) {\n+            throw new AssertionError();\n+        }\n+\n+        \/\/set the current VM's in\/out to the terminal:\n+        FunctionDescriptor loginttyDescriptor =\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+                                      ValueLayout.JAVA_INT);\n+        MethodHandle logintty = linker.downcallHandle(loginttyAddress.get(),\n+                                                      loginttyDescriptor);\n+        logintty.invoke(child.get(ValueLayout.JAVA_INT, 0));\n+\n+        String testJDK = System.getProperty(\"test.jdk\");\n+        Path javaLauncher = Path.of(testJDK, \"bin\", \"java\");\n+\n+        ProcessBuilder builder = new ProcessBuilder(javaLauncher.toString(),\n+                                                    \"RedirectedStdOut$ConsoleTest\");\n+\n+        builder.inheritIO();\n+        builder.redirectOutput(stdout.toFile());\n+\n+        Process launched = builder.start();\n+\n+        launched.waitFor();\n+\n+        String expectedOut = OUTPUT;\n+        String actualOut = Files.readString(stdout);\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+    }\n+\n+    public static class ConsoleTest {\n+        public static void main(String... args) {\n+            System.console().printf(OUTPUT);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/RedirectedStdOut.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}