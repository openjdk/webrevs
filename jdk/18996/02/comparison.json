{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.internal.org.jline.terminal.TerminalBuilder.SystemOutput;\n@@ -54,1 +55,3 @@\n-                                               .exec(false).build();\n+                                               .exec(false)\n+                                               .systemOutput(SystemOutput.SysOut)\n+                                               .build();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,1 +509,2 @@\n-                        new FileOutputStream(console == TerminalProvider.Stream.Output ? FileDescriptor.out : FileDescriptor.err),\n+                        \/\/JDK change: always write into stdout:\n+                        new FileOutputStream(FileDescriptor.out),\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8330998\n+ * @summary Verify that even if the stdout is redirected java.io.Console will\n+ *          use it for writing.\n+ * @modules jdk.internal.le\n+ * @library \/test\/lib\n+ * @run main RedirectedStdOut runRedirectAllTest\n+ * @run main\/othervm RedirectedStdOut runRedirectOutOnly\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RedirectedStdOut {\n+    private static final String OUTPUT = \"Hello!\";\n+\n+    public static void main(String... args) throws Throwable {\n+        RedirectedStdOut.class.getDeclaredMethod(args[0])\n+                              .invoke(new RedirectedStdOut());\n+    }\n+\n+    \/\/verify the case where neither stdin\/out\/err is attached to a terminal,\n+    \/\/this test is weaker, but more reliable:\n+    void runRedirectAllTest() throws Exception {\n+        if (true) return ;\n+        ProcessBuilder builder =\n+                ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName());\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n+\n+        output.waitFor();\n+\n+        if (output.getExitValue() != 0) {\n+            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n+                                     \", actualOut: \" + output.getStdout() +\n+                                     \", actualErr: \" + output.getStderr());\n+        }\n+\n+        String expectedOut = OUTPUT;\n+        String actualOut = output.getStdout();\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+\n+        String expectedErr = \"\";\n+        String actualErr = output.getStderr();\n+\n+        if (!Objects.equals(expectedErr, actualErr)) {\n+            throw new AssertionError(\"Unexpected stderr content. \" +\n+                                     \"Expected: '\" + expectedErr + \"'\" +\n+                                     \", got: '\" + actualErr + \"'\");\n+        }\n+    }\n+\n+    \/\/verify the case where stdin is attached to a terminal,\n+    \/\/this test allocates pty, and it might be skipped, if the appropriate\n+    \/\/native functions cannot be found\n+    \/\/it also leaves the VM in a broken state (with a pty attached), and so\n+    \/\/should run in a separate VM instance\n+    void runRedirectOutOnly() throws Throwable {\n+        Path stdout = Path.of(\".\", \"stdout.txt\").toAbsolutePath();\n+\n+        Files.deleteIfExists(stdout);\n+\n+        Linker linker = Linker.nativeLinker();\n+        SymbolLookup stdlib = linker.defaultLookup();\n+        MemorySegment parent = Arena.global().allocate(ValueLayout.ADDRESS);\n+        MemorySegment child = Arena.global().allocate(ValueLayout.ADDRESS);\n+        Optional<MemorySegment> openptyAddress = stdlib.find(\"openpty\");\n+\n+        if (openptyAddress.isEmpty()) {\n+            System.out.println(\"Cannot lookup openpty.\");\n+            \/\/does not have forkpty, ignore\n+            return ;\n+        }\n+\n+        Optional<MemorySegment> loginttyAddress = stdlib.find(\"login_tty\");\n+\n+        if (loginttyAddress.isEmpty()) {\n+            System.out.println(\"Cannot lookup login_tty.\");\n+            \/\/does not have forkpty, ignore\n+            return ;\n+        }\n+\n+        FunctionDescriptor openttyDescriptor =\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS);\n+        MethodHandle forkpty = linker.downcallHandle(openptyAddress.get(),\n+                                                     openttyDescriptor);\n+        int res = (int) forkpty.invoke(parent,\n+                                       child,\n+                                       MemorySegment.NULL,\n+                                       MemorySegment.NULL,\n+                                       MemorySegment.NULL);\n+\n+        if (res != 0) {\n+            throw new AssertionError();\n+        }\n+\n+        \/\/set the current VM's in\/out to the terminal:\n+        FunctionDescriptor loginttyDescriptor =\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+                                      ValueLayout.JAVA_INT);\n+        MethodHandle logintty = linker.downcallHandle(loginttyAddress.get(),\n+                                                      loginttyDescriptor);\n+        logintty.invoke(child.get(ValueLayout.JAVA_INT, 0));\n+\n+        ProcessBuilder builder =\n+            ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName());\n+\n+        builder.inheritIO();\n+        builder.redirectOutput(stdout.toFile());\n+\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n+\n+        output.waitFor();\n+\n+        String expectedOut = OUTPUT;\n+        String actualOut = Files.readString(stdout);\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+    }\n+\n+    public static class ConsoleTest {\n+        public static void main(String... args) {\n+            System.console().printf(OUTPUT);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/RedirectedStdOut.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}