{"files":[{"patch":"@@ -818,0 +818,2 @@\n+  INSN(fcvt_s_h, 0b1010011, 0b00010, 0b0100000);\n+  INSN(fcvt_h_s, 0b1010011, 0b00000, 0b0100010);\n@@ -1074,0 +1076,1 @@\n+  INSN(fmv_h_x,  0b1010011, 0b000, 0b00000, 0b1111010);\n@@ -1111,0 +1114,1 @@\n+  INSN(fclass_h, 0b1010011, 0b001, 0b00000, 0b1110010);\n@@ -1113,0 +1117,1 @@\n+  INSN(fmv_x_h,  0b1010011, 0b000, 0b00000, 0b1110010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1786,0 +1786,46 @@\n+static void float16_to_float_slow_path(C2_MacroAssembler& masm, C2GeneralStub<FloatRegister, Register, Register>& stub) {\n+#define __ masm.\n+  FloatRegister dst = stub.data<0>();\n+  Register src = stub.data<1>();\n+  Register tmp = stub.data<2>();\n+  __ bind(stub.entry());\n+\n+  \/\/ following instructions mainly focus on NaN, as riscv does not handle\n+  \/\/ NaN well with fcvt, but the code also works for Inf at the same time.\n+\n+  \/\/ construct a NaN in 32 bits from the NaN in 16 bits,\n+  \/\/ we need the payloads of non-canonical NaNs to be preserved.\n+  __ mv(tmp, 0x7f800000);\n+  \/\/ sign-bit was already set via sign-extension if necessary.\n+  __ slli(t0, src, 13);\n+  __ orr(tmp, t0, tmp);\n+  __ fmv_w_x(dst, tmp);\n+\n+  __ j(stub.continuation());\n+#undef __\n+}\n+\n+\/\/ j.l.Float.float16ToFloat\n+void C2_MacroAssembler::float16_to_float(FloatRegister dst, Register src, Register tmp) {\n+  auto stub = C2CodeStub::make<FloatRegister, Register, Register>(dst, src, tmp, 20, float16_to_float_slow_path);\n+\n+  \/\/ in riscv, NaN needs a special process as fcvt does not work in that case.\n+  \/\/ in riscv, Inf does not need a special process as fcvt can handle it correctly.\n+  \/\/ but we consider to get the slow path to process NaN and Inf at the same time,\n+  \/\/ as both of them are rare cases, and if we try to get the slow path to handle\n+  \/\/ only NaN case it would sacrifise the performance for normal cases,\n+  \/\/ i.e. non-NaN and non-Inf cases.\n+\n+  \/\/ check whether it's a NaN or +\/- Inf.\n+  mv(t0, 0x7c00);\n+  andr(tmp, src, t0);\n+  \/\/ jump to stub processing NaN and Inf cases.\n+  beq(t0, tmp, stub->entry());\n+\n+  \/\/ non-NaN or non-Inf cases, just use built-in instructions.\n+  fmv_h_x(dst, src);\n+  fcvt_s_h(dst, dst);\n+\n+  bind(stub->continuation());\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+  void float16_to_float(FloatRegister dst, Register src, Register tmp);\n+\n@@ -177,0 +179,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+  product(bool, UseZfh, false, \"Use Zfh instructions\")                           \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1935,0 +1935,3 @@\n+\n+    case Op_ConvHF2F:\n+      return UseZfh;\n@@ -8278,0 +8281,14 @@\n+\/\/ single <-> half precision\n+\n+instruct convHF2F_reg_reg(fRegF dst, iRegINoSp src, iRegINoSp tmp) %{\n+  match(Set dst (ConvHF2F src));\n+  effect(TEMP tmp);\n+  format %{ \"fmv.h.x $dst, $src\\t# move source from $src to $dst\\n\\t\"\n+            \"fcvt.s.h $dst, $dst\\t# convert half to single precision\"\n+  %}\n+  ins_encode %{\n+    __ float16_to_float($dst$$FloatRegister, $src$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+    if (FLAG_IS_DEFAULT(UseZfh)) {\n+      FLAG_SET_DEFAULT(UseZfh, true);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+  \/\/ Zfh Half-Precision Floating-Point instructions\n+  \/\/\n@@ -146,0 +148,1 @@\n+  decl(ext_Zfh         , \"Zfh\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfh))         \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#define   RISCV_HWPROBE_EXT_ZFH                 (1 << 27)\n@@ -148,0 +149,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZFH)) {\n+    VM_Version::ext_Zfh.enable_feature();\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+  ext_Zfh.enable_feature();\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16Conversion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestAllFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}