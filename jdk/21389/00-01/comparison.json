{"files":[{"patch":"@@ -330,5 +330,3 @@\n-  } else if (_id == load_mirror_id || _id == load_appendix_id) {\n-    \/\/ Produce a copy of the load mirror \/ appendix instruction.\n-    \/\/ 8-byte align the address of the oop immediate to guarantee atomicity\n-    \/\/ when patching since the GC might walk nmethod oops concurrently.\n-    __ align(8, __ offset() + NativeMovConstReg::data_offset_rex);\n+  } else if (_id == load_mirror_id) {\n+    \/\/ produce a copy of the load mirror instruction for use by the being\n+    \/\/ initialized case\n@@ -415,1 +413,1 @@\n-    case load_appendix_id: target = Runtime1::entry_for(C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id:      target = Runtime1::entry_for(C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1271,12 +1271,14 @@\n-  }\n-\n-  \/\/ If we are patching in a non-perm oop, make sure the nmethod\n-  \/\/ is on the right list.\n-  {\n-    MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());\n-    guarantee(nm != nullptr, \"only nmethods can contain non-perm oops\");\n-\n-    \/\/ Since we've patched some oops in the nmethod,\n-    \/\/ (re)register it with the heap.\n-    Universe::heap()->register_nmethod(nm);\n+    \/\/ Keep holding the Patching_lock when walking oops because another thread\n+    \/\/ might update immediate oops in the patch body concurrently and non-atomic.\n+\n+    \/\/ If we are patching in a non-perm oop, make sure the nmethod\n+    \/\/ is on the right list.\n+    {\n+      MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());\n+      guarantee(nm != nullptr, \"only nmethods can contain non-perm oops\");\n+\n+      \/\/ Since we've patched some oops in the nmethod,\n+      \/\/ (re)register it with the heap.\n+      Universe::heap()->register_nmethod(nm);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    static final int ITERATIONS = 10_000;\n+    static final int ITERATIONS = 1000;\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestConcurrentPatching.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}