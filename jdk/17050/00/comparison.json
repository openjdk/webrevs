{"files":[{"patch":"@@ -1847,4 +1847,0 @@\n-  if (NotRunnable(current, static_cast<JavaThread*>(owner_raw()))) {\n-    return 0;\n-  }\n-\n@@ -1936,7 +1932,0 @@\n-    \/\/ Abort the spin if the owner is not executing.\n-    \/\/ The owner must be executing in order to drop the lock.\n-    \/\/ Spinning while the owner is OFFPROC is idiocy.\n-    \/\/ Consider: ctr -= RunnablePenalty ;\n-    if (NotRunnable(current, ox)) {\n-      goto Abort;\n-    }\n@@ -1975,56 +1964,0 @@\n-\/\/ NotRunnable() -- informed spinning\n-\/\/\n-\/\/ Don't bother spinning if the owner is not eligible to drop the lock.\n-\/\/ Spin only if the owner thread is _thread_in_Java or _thread_in_vm.\n-\/\/ The thread must be runnable in order to drop the lock in timely fashion.\n-\/\/ If the _owner is not runnable then spinning will not likely be\n-\/\/ successful (profitable).\n-\/\/\n-\/\/ Beware -- the thread referenced by _owner could have died\n-\/\/ so a simply fetch from _owner->_thread_state might trap.\n-\/\/ Instead, we use SafeFetchXX() to safely LD _owner->_thread_state.\n-\/\/ Because of the lifecycle issues, the _thread_state values\n-\/\/ observed by NotRunnable() might be garbage.  NotRunnable must\n-\/\/ tolerate this and consider the observed _thread_state value\n-\/\/ as advisory.\n-\/\/\n-\/\/ Beware too, that _owner is sometimes a BasicLock address and sometimes\n-\/\/ a thread pointer.\n-\/\/ Alternately, we might tag the type (thread pointer vs basiclock pointer)\n-\/\/ with the LSB of _owner.  Another option would be to probabilistically probe\n-\/\/ the putative _owner->TypeTag value.\n-\/\/\n-\/\/ Checking _thread_state isn't perfect.  Even if the thread is\n-\/\/ in_java it might be blocked on a page-fault or have been preempted\n-\/\/ and sitting on a ready\/dispatch queue.\n-\/\/\n-\/\/ The return value from NotRunnable() is *advisory* -- the\n-\/\/ result is based on sampling and is not necessarily coherent.\n-\/\/ The caller must tolerate false-negative and false-positive errors.\n-\/\/ Spinning, in general, is probabilistic anyway.\n-\n-\n-int ObjectMonitor::NotRunnable(JavaThread* current, JavaThread* ox) {\n-  \/\/ Check ox->TypeTag == 2BAD.\n-  if (ox == nullptr) return 0;\n-\n-  \/\/ Avoid transitive spinning ...\n-  \/\/ Say T1 spins or blocks trying to acquire L.  T1._Stalled is set to L.\n-  \/\/ Immediately after T1 acquires L it's possible that T2, also\n-  \/\/ spinning on L, will see L.Owner=T1 and T1._Stalled=L.\n-  \/\/ This occurs transiently after T1 acquired L but before\n-  \/\/ T1 managed to clear T1.Stalled.  T2 does not need to abort\n-  \/\/ its spin in this circumstance.\n-  intptr_t BlockedOn = SafeFetchN((intptr_t *) &ox->_Stalled, intptr_t(1));\n-\n-  if (BlockedOn == 1) return 1;\n-  if (BlockedOn != 0) {\n-    return BlockedOn != intptr_t(this) && owner_raw() == ox;\n-  }\n-\n-  assert(sizeof(ox->_thread_state == sizeof(int)), \"invariant\");\n-  int jst = SafeFetch32((int *) &ox->_thread_state, -1);;\n-  \/\/ consider also: jst != _thread_in_Java -- but that's overspecific.\n-  return jst == _thread_blocked || jst == _thread_in_native;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":67,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -360,1 +360,0 @@\n-  int       NotRunnable(JavaThread* current, JavaThread* Owner);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}