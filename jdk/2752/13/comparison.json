{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -248,0 +250,8 @@\n+            },\n+            new Option(true, true, OptionType.EXTRACT, \"--dir\") {\n+                void process(Main jartool, String opt, String arg) throws BadArgs {\n+                    if (jartool.xdestDir != null) {\n+                        throw new BadArgs(\"error.extract.multiple.dest.dir\").showUsage(true);\n+                    }\n+                    jartool.xdestDir = arg;\n+                }\n@@ -257,0 +267,1 @@\n+        EXTRACT(\"extract\"),\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -163,0 +163,3 @@\n+    \/\/ destination directory for extraction\n+    String xdestDir = null;\n+\n@@ -375,0 +378,9 @@\n+                if (xdestDir != null) {\n+                    final Path destPath = Paths.get(xdestDir);\n+                    try {\n+                        Files.createDirectories(destPath);\n+                    } catch (IOException ioe) {\n+                        throw new IOException(formatMsg(\"error.create.dir\",\n+                                destPath.toString()), ioe);\n+                    }\n+                }\n@@ -634,0 +646,5 @@\n+                        if (xflag && xdestDir != null) {\n+                            \/\/ extract option doesn't allow more than one destination directory\n+                            usageError(getMsg(\"error.extract.multiple.dest.dir\"));\n+                            return false;\n+                        }\n@@ -645,2 +662,6 @@\n-                        pathsMap.get(version).add(dir);\n-                        nameBuf[k++] = dir + args[++i];\n+                        if (xflag) {\n+                            xdestDir = dir;\n+                        } else {\n+                            pathsMap.get(version).add(dir);\n+                            nameBuf[k++] = dir + args[++i];\n+                        }\n@@ -705,0 +726,4 @@\n+        if (xflag && pflag && xdestDir != null) {\n+            usageError(getMsg(\"error.extract.pflag.not.allowed\"));\n+            return false;\n+        }\n@@ -1358,1 +1383,1 @@\n-                    File f = new File(name.replace('\/', File.separatorChar));\n+                    File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n@@ -1369,0 +1394,4 @@\n+        if (vflag) {\n+            output(formatMsg(\"out.extract.dir\", Path.of(xdestDir == null ? \".\" : xdestDir).normalize()\n+                    .toAbsolutePath().toString()));\n+        }\n@@ -1397,0 +1426,4 @@\n+        if (vflag) {\n+            output(formatMsg(\"out.extract.dir\", Path.of(xdestDir == null ? \".\" : xdestDir).normalize()\n+                    .toAbsolutePath().toString()));\n+        }\n@@ -1426,1 +1459,1 @@\n-        \/\/ The spec requres all slashes MUST be forward '\/', it is possible\n+        \/\/ The spec requires all slashes MUST be forward '\/', it is possible\n@@ -1429,1 +1462,1 @@\n-        \/\/ our \"safe\" check for leading slahs and dot-dot. So replace them\n+        \/\/ our \"safe\" check for leading slash and dot-dot. So replace them\n@@ -1435,1 +1468,9 @@\n-        File f = new File(name.replace('\/', File.separatorChar));\n+        \/\/ the xdestDir points to the user specified location where the jar needs to\n+        \/\/ be extracted. By default xdestDir is null and represents current working\n+        \/\/ directory.\n+        \/\/ jar extraction using -P option is only allowed when the destination\n+        \/\/ directory isn't specified (and hence defaults to current working directory).\n+        \/\/ In such cases using this java.io.File constructor which accepts a null parent path\n+        \/\/ allows us to extract entries that may have leading slashes and hence may need\n+        \/\/ to be extracted outside of the current directory.\n+        File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":47,"deletions":6,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,4 @@\n+error.extract.multiple.dest.dir=\\\n+        You may not specify the '-C' or '--dir' option more than once with the '-x' option\n+error.extract.pflag.not.allowed=\\\n+        You may not specify '-Px' with the '-C' or '--dir' options\n@@ -172,0 +176,2 @@\n+out.extract.dir=\\\n+        extracting to directory: {0}\n@@ -193,0 +199,1 @@\n+When used in extract mode, extracts the jar to the specified directory\\n\\\n@@ -260,1 +267,2 @@\n-\\                             following file\n+\\                             following file. When used in extract mode, extracts\\n\\\n+\\                             the jar to the specified directory\n@@ -327,0 +335,4 @@\n+main.help.opt.extract=\\\n+\\ Operation modifiers valid only in extract mode:\\n\n+main.help.opt.extract.dir=\\\n+\\  --dir                    Directory into which the jar will be extracted\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,0 +132,2 @@\n+When used in extract mode, extracts the JAR file to the specified\n+directory.\n@@ -205,0 +207,4 @@\n+.SH OPERATION MODIFIERS VALID ONLY IN EXTRACT MODE\n+.TP\n+\\f[V]--dir\\f[R] \\f[I]DIR\\f[R]\n+Directory into which the jar will be extracted.\n@@ -345,0 +351,14 @@\n+.IP \\[bu] 2\n+Extract a JAR file \\f[V]foo.jar\\f[R] to \\f[V]\/tmp\/bar\/\\f[R] directory:\n+.RS 2\n+.RS\n+.PP\n+\\f[V]jar -xf foo.jar -C \/tmp\/bar\/\\f[R]\n+.RE\n+.PP\n+Alternatively, you can also do:\n+.RS\n+.PP\n+\\f[V]jar --extract --file foo.jar --dir \/tmp\/bar\/\\f[R]\n+.RE\n+.RE\n","filename":"src\/jdk.jartool\/share\/man\/jar.1","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,517 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.util.JarBuilder;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8173970\n+ * @summary jar tool should allow extracting to specific directory\n+ * @library \/test\/lib\n+ * @comment The test relies on verification of error messages generated by jar tool, so we use\n+ *          a fixed en_US locale for this test.\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US JarExtractTest\n+ *\/\n+public class JarExtractTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    private static final byte[] FILE_CONTENT = \"Hello world!!!\".getBytes(StandardCharsets.UTF_8);\n+    \/\/ the jar that will get extracted in the tests\n+    private Path testJarPath;\n+    private static Collection<Path> filesToDelete = new ArrayList<>();\n+\n+    @BeforeEach\n+    public void createTestJar() throws Exception {\n+        final String tmpDir = Files.createTempDirectory(\"8173970-\").toString();\n+        testJarPath = Path.of(tmpDir, \"8173970-test.jar\");\n+        final JarBuilder builder = new JarBuilder(testJarPath.toString());\n+        \/\/ d1\n+        \/\/  |--- d2\n+        \/\/  |    |--- d3\n+        \/\/  |    |    |--- f2.txt\n+        \/\/  |\n+        \/\/  |--- d4\n+        \/\/  ...\n+        \/\/  f1.txt\n+\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"f1.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d2\/d3\/f2.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d4\/\", new byte[0]);\n+        builder.build();\n+    }\n+\n+    @AfterEach\n+    public void cleanup() {\n+        for (final Path p : filesToDelete) {\n+            try {\n+                System.out.println(\"Deleting file\/dir \" + p);\n+                Files.delete(p);\n+            } catch (IOException ioe) {\n+                \/\/ignore\n+                System.err.println(\"ignoring exception: \" + ioe\n+                        + \" that happened when deleting: \" + p);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates and returns various relative paths, to which the jar will be extracted in the tests\n+     *\/\n+    static Stream<Arguments> provideRelativeExtractLocations() throws Exception {\n+        \/\/ create some dirs so that they already exist when the jar is being extracted\n+        final String existing1 = \".\" + File.separator + \"8173970-existing-1\";\n+        Files.createDirectories(Path.of(existing1));\n+        final String existing2 = \".\" + File.separator + \"foo\" + File.separator + \"8173970-existing-2\";\n+        Files.createDirectories(Path.of(existing2));\n+        final Path dirOutsideScratchDir = Files.createTempDirectory(Path.of(\"..\"), \"8173970\");\n+        \/\/ we need to explicitly delete this dir after the tests end\n+        filesToDelete.add(dirOutsideScratchDir);\n+        final String existing3 = dirOutsideScratchDir.toString() + File.separator + \"8173970-existing-3\";\n+        Files.createDirectories(Path.of(existing3));\n+\n+        final String anotherDirOutsideScratchDir = \"..\" + File.separator + \"8173970-non-existent\";\n+        filesToDelete.add(Path.of(anotherDirOutsideScratchDir));\n+\n+        final List<Arguments> args = new ArrayList<>();\n+        args.add(Arguments.of(\".\")); \/\/ current dir\n+        \/\/ (explicitly) relative to current dir\n+        args.add(Arguments.of(\".\" + File.separator + \"8173970-extract-1\"));\n+        \/\/ (implicitly) relative to current dir\n+        args.add(Arguments.of(\"8173970-extract-2\"));\n+        \/\/ sibling to current dir\n+        args.add(Arguments.of(anotherDirOutsideScratchDir));\n+        \/\/ some existing dirs\n+        args.add(Arguments.of(existing1));\n+        args.add(Arguments.of(existing2));\n+        args.add(Arguments.of(existing3));\n+        \/\/ a non-existent dir within an existing dir\n+        args.add(Arguments.of(existing1 + File.separator\n+                + \"non-existing\" + File.separator + \"foo\"));\n+        return args.stream();\n+    }\n+\n+    \/**\n+     * Creates and returns various absolute paths, to which the jar will be extracted in the tests\n+     *\/\n+    static Stream<Arguments> provideAbsoluteExtractLocations() throws Exception {\n+        final Stream<Arguments> relative = provideRelativeExtractLocations();\n+        return relative.map((arg) -> {\n+            final String relPath = (String) arg.get()[0];\n+            return Arguments.of(Path.of(relPath).toAbsolutePath().toString());\n+        });\n+    }\n+\n+    \/**\n+     * Creates and returns various normalized paths, to which the jar will be extracted in the tests\n+     *\/\n+    static Stream<Arguments> provideAbsoluteNormalizedExtractLocations() throws Exception {\n+        final Stream<Arguments> relative = provideRelativeExtractLocations();\n+        return relative.map((arg) -> {\n+            final String relPath = (String) arg.get()[0];\n+            return Arguments.of(Path.of(relPath).toAbsolutePath().normalize().toString());\n+        });\n+    }\n+\n+    \/**\n+     * Extracts a jar to various relative paths, using the -C\/--dir option and then\n+     * verifies that the extracted content is at the expected locations with the correct\n+     * content\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"provideRelativeExtractLocations\")\n+    public void testExtractToRelativeDir(final String dest) throws Exception {\n+        testLongFormExtract(dest);\n+        testExtract(dest);\n+    }\n+\n+    \/**\n+     * Extracts a jar to various absolute paths, using the -C\/--dir option and then\n+     * verifies that the extracted content is at the expected locations with the correct\n+     * content\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"provideAbsoluteExtractLocations\")\n+    public void testExtractToAbsoluteDir(final String dest) throws Exception {\n+        testExtract(dest);\n+        testLongFormExtract(dest);\n+    }\n+\n+    \/**\n+     * Extracts a jar to various normalized paths (i.e. no {@code .} or @{code ..} in the path components),\n+     * using the -C\/--dir option and then verifies that the extracted content is at the expected locations\n+     * with the correct content\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"provideAbsoluteNormalizedExtractLocations\")\n+    public void testExtractToAbsoluteNormalizedDir(final String dest) throws Exception {\n+        testExtract(dest);\n+        testLongFormExtract(dest);\n+    }\n+\n+    \/**\n+     * Test that extracting a jar with {@code jar -x -f --dir} works as expected\n+     *\/\n+    @Test\n+    public void testExtractLongFormDir() throws Exception {\n+        final String dest = \"foo-bar\";\n+        System.out.println(\"Extracting \" + testJarPath + \" to \" + dest);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-x\", \"-f\", testJarPath.toString(),\n+                \"--dir\", dest);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the {@code jar --help} output contains the --dir option\n+     *\/\n+    @Test\n+    public void testHelpOutput() {\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+        final int exitCode = JAR_TOOL.run(new PrintStream(outStream), System.err, \"--help\");\n+        assertEquals(0, exitCode, \"jar --help command failed\");\n+        final String output = outStream.toString();\n+        \/\/ this message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedMsg = \"--dir                    Directory into which the jar will be extracted\";\n+        assertTrue(output.contains(expectedMsg), \"jar --help didn't contain --dir option\");\n+    }\n+\n+    \/**\n+     * Tests that {@code jar -x -f} command works fine even when the -C or --dir option\n+     * isn't specified\n+     *\/\n+    @Test\n+    public void testExtractWithoutOutputDir() throws Exception {\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-x\", \"-f\", testJarPath.toString());\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        \/\/ the content would have been extracted to current dir\n+        verifyExtractedContent(\".\");\n+    }\n+\n+    \/**\n+     * Tests that {@code jar --extract -f} command works fine even when the -C or --dir option\n+     * isn't specified\n+     *\/\n+    @Test\n+    public void testLongFormExtractWithoutOutputDir() throws Exception {\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"--extract\", \"-f\", testJarPath.toString());\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        \/\/ the content would have been extracted to current dir\n+        verifyExtractedContent(\".\");\n+    }\n+\n+    \/**\n+     * Tests that when the destination directory specified for jar extract is actually a file\n+     * or one of the path component in the specified destination path is a file, then the\n+     * extraction fails.\n+     *\/\n+    @Test\n+    public void testExtractToNonDirectory() throws Exception {\n+        final String expectedErrMsg = \"could not create directory\";\n+        final Path notADir1 = Files.createTempFile(Path.of(\".\"), \"8173970\", \".txt\");\n+        final Path notADir2 = notADir1.resolve(\"foobar\");\n+        for (final Path dest : List.of(notADir1, notADir2)) {\n+            final String[] args = {\"-x\", \"-f\", testJarPath.toString(), \"-C\", dest.toString()};\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            assertNotEquals(0, exitCode, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that extracting a jar using {@code -P} flag and without any explicit destination\n+     * directory works correctly if the jar contains entries with leading slashes and\/or {@code ..}\n+     * parts preserved.\n+     *\/\n+    @Test\n+    public void testExtractNoDestDirWithPFlag() throws Exception {\n+        \/\/ run this test only on those systems where \"\/tmp\" directory is available and we\n+        \/\/ can write to it\n+        Assumptions.assumeTrue(Files.isDirectory(Path.of(\"\/tmp\")),\n+                \"skipping test, since \/tmp isn't a directory\");\n+        \/\/ try and write into \"\/tmp\"\n+        final Path tmpDir;\n+        try {\n+            tmpDir = Files.createTempDirectory(Path.of(\"\/tmp\"), \"8173970-\").toAbsolutePath();\n+        } catch (IOException ioe) {\n+            Assumptions.abort(\"skipping test, since \/tmp cannot be written to: \" + ioe);\n+            return;\n+        }\n+        final String leadingSlashEntryName = tmpDir.toString() + \"\/foo\/f1.txt\";\n+        \/\/ create a jar which has leading slash (\/) and dot-dot (..) preserved in entry names\n+        final Path jarPath = createJarWithPFlagSemantics(leadingSlashEntryName);\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-xvfP\", jarPath.toString()});\n+        cmdArgs.add(new String[]{\"--extract\", \"-v\", \"-P\", \"-f\", jarPath.toString()});\n+        try {\n+            for (final String[] args : cmdArgs) {\n+                printJarCommand(args);\n+                final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+                assertEquals(0, exitCode, \"Failed to extract \" + jarPath);\n+                final String dest = \".\";\n+                assertTrue(Files.isDirectory(Path.of(dest)), dest + \" is not a directory\");\n+                final Path d1 = Path.of(dest, \"d1\");\n+                assertTrue(Files.isDirectory(d1), d1 + \" directory is missing or not a directory\");\n+                final Path d2 = Path.of(dest, \"d1\", \"d2\");\n+                assertTrue(Files.isDirectory(d2), d2 + \" directory is missing or not a directory\");\n+                final Path f1 = Path.of(leadingSlashEntryName);\n+                assertTrue(Files.isRegularFile(f1), f1 + \" is missing or not a file\");\n+                assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f1),\n+                        \"Unexpected content in file \" + f1);\n+                final Path f2 = Path.of(\"d1\/d2\/..\/f2.txt\");\n+                assertTrue(Files.isRegularFile(f2), f2 + \" is missing or not a file\");\n+                assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f2),\n+                        \"Unexpected content in file \" + f2);\n+            }\n+        } finally {\n+            \/\/ clean up the file that might have been extracted into \"\/tmp\/....\" directory\n+            Files.deleteIfExists(Path.of(leadingSlashEntryName));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that the {@code -P} option cannot be used during jar extraction when the {@code -C} and\/or\n+     * {@code --dir} option is used\n+     *\/\n+    @Test\n+    public void testExtractWithDirPFlagNotAllowed() throws Exception {\n+        \/\/ this error message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedErrMsg = \"You may not specify '-Px' with the '-C' or '--dir' options\";\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", \".\"});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", \".\"});\n+        cmdArgs.add(new String[]{\"-xvfP\", testJarPath.toString(), \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", \".\"});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", \".\"});\n+        for (final String[] args : cmdArgs) {\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            assertNotEquals(0, exitCode, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@code jar -xvf <jarname> -C <dir>} works fine too\n+     *\/\n+    @Test\n+    public void testLegacyCompatibilityMode() throws Exception {\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final String[] args = new String[]{\"-xvf\", testJarPath.toString(), \"-C\", tmpDir};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        verifyExtractedContent(tmpDir);\n+    }\n+\n+    \/**\n+     * Tests that when multiple directories are specified for extracting the jar, the jar extraction\n+     * fails\n+     *\/\n+    @Test\n+    public void testExtractFailWithMultipleDir() throws Exception {\n+        \/\/ this error message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedErrMsg = \"You may not specify the '-C' or '--dir' option more than once with the '-x' option\";\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-C\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-C\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"-C\", tmpDir});\n+        for (final String[] args : cmdArgs) {\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            assertNotEquals(0, exitCode, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that extracting only specific files from a jar, into a specific destination directory,\n+     * works as expected\n+     *\/\n+    @Test\n+    public void testExtractPartialContent() throws Exception {\n+        String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        String[] cmdArgs = new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir,\n+                \"f1.txt\", \"d1\/d2\/d3\/f2.txt\"};\n+        testExtractPartialContent(tmpDir, cmdArgs);\n+\n+        tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        cmdArgs = new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir,\n+                \"f1.txt\", \"d1\/d2\/d3\/f2.txt\"};\n+        testExtractPartialContent(tmpDir, cmdArgs);\n+\n+    }\n+\n+    \/**\n+     * Extract to destDir using the passed command arguments and verify the extracted content\n+     *\/\n+    private void testExtractPartialContent(final String destDir, final String[] extractArgs) throws Exception {\n+        printJarCommand(extractArgs);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, extractArgs);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath);\n+        \/\/ make sure only the specific files were extracted\n+        final Stream<Path> paths = Files.walk(Path.of(destDir));\n+        \/\/ files\/dirs count expected to be found when the location to which the jar was extracted\n+        \/\/ is walked.\n+        \/\/ 1) The top level dir being walked 2) f1.txt file 3) d1 dir 4) d1\/d2 dir\n+        \/\/ 5) d1\/d2\/d3 dir 6) d1\/d2\/d3\/f2.txt file\n+        final int numExpectedFiles = 6;\n+        assertEquals(numExpectedFiles, paths.count(), \"Unexpected number of files\/dirs in \" + destDir);\n+        final Path f1 = Path.of(destDir, \"f1.txt\");\n+        assertTrue(Files.isRegularFile(f1), f1.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f1), \"Unexpected content in file \" + f1);\n+        final Path d1 = Path.of(destDir, \"d1\");\n+        assertTrue(Files.isDirectory(d1), d1.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertEquals(2, Files.walk(d1, 1).count(), \"Unexpected number \" +\n+                \"of files\/dirs in \" + d1);\n+        final Path d2 = Path.of(d1.toString(), \"d2\");\n+        assertTrue(Files.isDirectory(d2), d2.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertEquals(2, Files.walk(d2, 1).count(), \"Unexpected number \" +\n+                \"of files\/dirs in \" + d2);\n+        final Path d3 = Path.of(d2.toString(), \"d3\");\n+        assertTrue(Files.isDirectory(d3), d3.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertEquals(2, Files.walk(d3, 1).count(), \"Unexpected number \" +\n+                \"of files\/dirs in \" + d3);\n+        final Path f2 = Path.of(d3.toString(), \"f2.txt\");\n+        assertTrue(Files.isRegularFile(f2), f2.toString() + \" wasn't extracted from \" + testJarPath);\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f2), \"Unexpected content in file \" + f2);\n+    }\n+\n+    \/**\n+     * Extracts the jar file using {@code jar -x -f <jarfile> -C <dest>} and verifies the extracted content\n+     *\/\n+    private void testExtract(final String dest) throws Exception {\n+        final String[] args = new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-C\", dest};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Extracts the jar file using {@code jar --extract -f <jarfile> -C <dest>} and verifies the\n+     * extracted content\n+     *\/\n+    private void testLongFormExtract(final String dest) throws Exception {\n+        final String[] args = new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-C\", dest};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        assertEquals(0, exitCode, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the extracted jar content matches what was present in the original jar\n+     *\/\n+    private void verifyExtractedContent(final String dest) throws IOException {\n+        assertTrue(Files.isDirectory(Path.of(dest)), dest + \" is not a directory\");\n+        final Path d1 = Path.of(dest, \"d1\");\n+        assertTrue(Files.isDirectory(d1), d1 + \" directory is missing or not a directory\");\n+        final Path d2 = Path.of(dest, \"d1\", \"d2\");\n+        assertTrue(Files.isDirectory(d2), d2 + \" directory is missing or not a directory\");\n+        final Path d3 = Path.of(dest, \"d1\", \"d2\", \"d3\");\n+        assertTrue(Files.isDirectory(d3), d3 + \" directory is missing or not a directory\");\n+        final Path d4 = Path.of(dest, \"d1\", \"d4\");\n+        assertTrue(Files.isDirectory(d4), d4 + \" directory is missing or not a directory\");\n+        \/\/ d1\/d4 is expected to be empty directory\n+        final List<Path> d4Children;\n+        try (final Stream<Path> s = Files.walk(d4, 1)) {\n+            d4Children = s.toList();\n+        }\n+        assertEquals(1, d4Children.size(), \"Directory \" + d4\n+                + \" has unexpected files\/dirs: \" + d4Children);\n+        final Path f1 = Path.of(dest, \"f1.txt\");\n+        assertTrue(Files.isRegularFile(f1), f1 + \" is missing or not a file\");\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f1), \"Unexpected content in file \" + f1);\n+        final Path f2 = Path.of(d3.toString(), \"f2.txt\");\n+        assertTrue(Files.isRegularFile(f2), f2 + \" is missing or not a file\");\n+        assertArrayEquals(FILE_CONTENT, Files.readAllBytes(f2), \"Unexpected content in file \" + f2);\n+    }\n+\n+    \/**\n+     * Creates a jar whose entries have a leading slash and the dot-dot character preserved.\n+     * This is the same as creating a jar using {@code jar -cfP somejar.jar <file1> <file2> ...}\n+     *\/\n+    private static Path createJarWithPFlagSemantics(String leadingSlashEntryName)\n+            throws IOException {\n+        final Path tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toAbsolutePath();\n+        final Path jarPath = tmpDir.resolve(\"8173970-test-withpflag.jar\");\n+        final JarBuilder builder = new JarBuilder(jarPath.toString());\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"d1\/d2\/\", new byte[0]);\n+        builder.addEntry(leadingSlashEntryName, FILE_CONTENT);\n+        builder.addEntry(\"d1\/d2\/..\/f2.txt\", FILE_CONTENT);\n+        builder.build();\n+        return jarPath;\n+    }\n+\n+    private static void printJarCommand(final String[] cmdArgs) {\n+        System.out.println(\"Running 'jar \" + String.join(\" \", cmdArgs) + \"'\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/JarExtractTest.java","additions":517,"deletions":0,"binary":false,"changes":517,"status":"added"}]}