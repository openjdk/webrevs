{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -973,1 +973,1 @@\n-            int targetIdx = addString(cp, header.moduleMainClass);\n+            int targetIdx = addClassName(cp, header.moduleMainClass);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331027\n+ * @summary Verify classfile inside ct.sym\n+ * @enablePreview\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.platform\n+ *          jdk.compiler\/com.sun.tools.javac.util:+open\n+ * @build toolbox.ToolBox VerifyCTSymClassFiles\n+ * @run main VerifyCTSymClassFiles\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class VerifyCTSymClassFiles {\n+\n+    public static void main(String... args) throws IOException, URISyntaxException {\n+        VerifyCTSymClassFiles t = new VerifyCTSymClassFiles();\n+\n+        t.checkClassFiles();\n+    }\n+\n+    void checkClassFiles() throws IOException {\n+        Path ctSym = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"ct.sym\");\n+\n+        if (!Files.exists(ctSym)) {\n+            \/\/no ct.sym, nothing to check:\n+            return ;\n+        }\n+        try (FileSystem fs = FileSystems.newFileSystem(ctSym)) {\n+            Files.walk(fs.getRootDirectories().iterator().next())\n+                 .filter(p -> Files.isRegularFile(p))\n+                 .forEach(p -> checkClassFile(p));\n+        }\n+    }\n+\n+    void checkClassFile(Path p) {\n+        if (!\"module-info.sig\".equals(p.getFileName().toString())) {\n+            return ;\n+        }\n+        try {\n+            ClassFile.of().parse(p).attributes().forEach(attr -> {\n+                if (attr instanceof ModuleMainClassAttribute mmca) {\n+                    mmca.mainClass();\n+                }\n+            });\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/VerifyCTSymClassFiles.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8072480 8277106\n+ * @bug 8072480 8277106 8331027\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -104,0 +105,3 @@\n+                                              \"--enable-preview\",\n+                                              \"--source\",\n+                                              \"\" + System.getProperty(\"java.specification.version\"),\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.constant.PackageDesc;\n@@ -61,8 +66,5 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -984,0 +986,5 @@\n+        return prepareVersionedCTSym(code7, code8, _ -> {});\n+    }\n+\n+    Path prepareVersionedCTSym(String[] code7, String[] code8,\n+                               Consumer<Path> adjustClassFiles) throws Exception {\n@@ -989,1 +996,1 @@\n-        compileAndPack(output, ver7Jar, code7);\n+        compileAndPack(output, ver7Jar, adjustClassFiles, code7);\n@@ -991,1 +998,1 @@\n-        compileAndPack(output, ver8Jar, code8);\n+        compileAndPack(output, ver8Jar, adjustClassFiles, code8);\n@@ -1051,0 +1058,100 @@\n+    @Test\n+    void testModuleMainClass() throws Exception {\n+        ClassFile cf = ClassFile.of();\n+        ToolBox tb = new ToolBox();\n+        String testClasses = System.getProperty(\"test.classes\");\n+        Path output = Paths.get(testClasses, \"test-data\" + i++);\n+        deleteRecursively(output);\n+        Files.createDirectories(output);\n+        Path ver9Jar = output.resolve(\"9.jar\");\n+        compileAndPack(output,\n+                       ver9Jar,\n+                       classesDir -> {\n+                           try {\n+                               Path moduleInfo = classesDir.resolve(\"module-info.class\");\n+                               byte[] newClassData =\n+                                       cf.transform(cf.parse(moduleInfo),\n+                                                    (builder, element) -> {\n+                                                        builder.with(element);\n+                                                        if (element instanceof ModuleAttribute) {\n+                                                            builder.with(ModuleMainClassAttribute.of(ClassDesc.of(\"main.Main\")));\n+                                                        }\n+                                                    });\n+                               try (OutputStream out = Files.newOutputStream(moduleInfo)) {\n+                                   out.write(newClassData);\n+                               }\n+                           } catch (IOException ex) {\n+                               throw new UncheckedIOException(ex);\n+                           }\n+                       },\n+                       \"\"\"\n+                       module m {\n+                       }\n+                       \"\"\",\n+                       \"\"\"\n+                       package main;\n+                       public class Main {}\n+                       \"\"\");\n+\n+\n+        Path ctSym = output.resolve(\"ct.sym\");\n+\n+        deleteRecursively(ctSym);\n+\n+        CreateSymbols.ALLOW_NON_EXISTING_CLASSES = true;\n+        CreateSymbols.EXTENSION = \".class\";\n+\n+        List<VersionDescription> versions =\n+                Arrays.asList(new VersionDescription(ver9Jar.toAbsolutePath().toString(), \"9\", null));\n+\n+        ExcludeIncludeList acceptAll = new ExcludeIncludeList(null, null) {\n+            @Override public boolean accepts(String className, boolean includePrivateClasses) {\n+                return true;\n+            }\n+        };\n+        new CreateSymbols().createBaseLine(versions, acceptAll, ctSym, new String[0]);\n+        Path symbolsDesc = ctSym.resolve(\"symbols\");\n+        Path modules = ctSym.resolve(\"modules\");\n+        Path modulesList = ctSym.resolve(\"modules-list\");\n+\n+        Files.createDirectories(modules);\n+        try (Writer w = Files.newBufferedWriter(modulesList)) {}\n+\n+        Path classesZip = output.resolve(\"classes.zip\");\n+        Path classesDir = output.resolve(\"classes\");\n+\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", \"\", modules.toString(), modulesList.toString());\n+\n+        try (JarFile jf = new JarFile(classesZip.toFile())) {\n+            Enumeration<JarEntry> en = jf.entries();\n+\n+            while (en.hasMoreElements()) {\n+                JarEntry je = en.nextElement();\n+                if (je.isDirectory()) continue;\n+                Path target = classesDir.resolve(je.getName());\n+                Files.createDirectories(target.getParent());\n+                Files.copy(jf.getInputStream(je), target);\n+            }\n+        }\n+\n+        Path moduleInfo = classesDir.resolve(\"9\")\n+                                    .resolve(\"m\")\n+                                    .resolve(\"module-info.class\");\n+\n+        cf.parse(moduleInfo)\n+          .attributes()\n+          .stream()\n+          .filter(attr -> attr instanceof ModuleMainClassAttribute)\n+          .forEach(attr -> {\n+              String expectedMain = \"Lmain\/Main;\";\n+              String mainClass =\n+                      ((ModuleMainClassAttribute) attr).mainClass()\n+                                                       .asSymbol()\n+                                                       .descriptorString();\n+              if (!Objects.equals(expectedMain, mainClass)) {\n+                  throw new AssertionError(\"Expected \" + expectedMain + \" as a main class, \" +\n+                                           \"but got: \" + mainClass);\n+              }\n+          });\n+    }\n+\n@@ -1052,0 +1159,5 @@\n+        compileAndPack(output, outputFile, _ -> {}, code);\n+    }\n+\n+    void compileAndPack(Path output, Path outputFile,\n+                        Consumer<Path> adjustClassFiles, String... code) throws Exception {\n@@ -1068,17 +1180,10 @@\n-            ClassFile cf = ClassFile.read(moduleInfo);\n-            List<CPInfo> cp = new ArrayList<>();\n-            cp.add(null);\n-            cf.constant_pool.entries().forEach(cp::add);\n-            Map<String, Attribute> attrs = new HashMap<>(cf.attributes.map);\n-            int[] encodedPackages = new int[packages.size()];\n-            int i = 0;\n-            for (String p : packages) {\n-                int nameIndex = cp.size();\n-                cp.add(new CONSTANT_Utf8_info(p));\n-                encodedPackages[i++] = cp.size();\n-                cp.add(new ConstantPool.CONSTANT_Package_info(null, nameIndex));\n-            }\n-            int attrName = cp.size();\n-            cp.add(new CONSTANT_Utf8_info(Attribute.ModulePackages));\n-            attrs.put(Attribute.ModulePackages, new ModulePackages_attribute(attrName, encodedPackages));\n-            ClassFile newFile = new ClassFile(cf.magic, cf.minor_version, cf.major_version, new ConstantPool(cp.toArray(new CPInfo[0])), cf.access_flags, cf.this_class, cf.super_class, cf.interfaces, cf.fields, cf.methods, new Attributes(attrs));\n+            ClassFile cf = ClassFile.of();\n+            ClassModel cm = cf.parse(moduleInfo);\n+            byte[] newData = cf.transform(cm, (builder, element) -> {\n+                builder.with(element);\n+                if (element instanceof ModuleAttribute) {\n+                    builder.with(ModulePackagesAttribute.ofNames(packages.stream()\n+                                                                         .map(pack -> PackageDesc.of(pack))\n+                                                                         .toList()));\n+                }\n+            });\n@@ -1086,1 +1191,1 @@\n-                new ClassWriter().write(newFile, out);\n+                out.write(newData);\n@@ -1089,0 +1194,1 @@\n+        adjustClassFiles.accept(scratch);\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":134,"deletions":28,"binary":false,"changes":162,"status":"modified"}]}