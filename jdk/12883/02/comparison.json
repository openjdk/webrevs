{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,6 @@\n-                                                                      SysVx64Linker, WindowsAArch64Linker, Windowsx64Linker, LinuxRISCV64Linker {\n+                                                                      SysVx64Linker, WindowsAArch64Linker,\n+                                                                      Windowsx64Linker, LinuxRISCV64Linker {\n+\n+    public interface UpcallStubFactory {\n+        MemorySegment makeStub(MethodHandle target, SegmentScope arena);\n+    }\n@@ -52,0 +57,1 @@\n+    private final SoftReferenceCache<FunctionDescriptor, UpcallStubFactory> UPCALL_CACHE = new SoftReferenceCache<>();\n@@ -82,1 +88,3 @@\n-        return arrangeUpcall(target, target.type(), function, scope);\n+\n+        UpcallStubFactory factory = UPCALL_CACHE.get(function, f -> arrangeUpcall(type, f));\n+        return factory.makeStub(target, scope);\n@@ -85,2 +93,1 @@\n-    protected abstract MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType,\n-                                                   FunctionDescriptor function, SegmentScope scope);\n+    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,2 +129,0 @@\n-    private static final SoftReferenceCache<FunctionDescriptor, MethodHandle> UPCALL_WRAPPER_CACHE = new SoftReferenceCache<>();\n-\n@@ -160,10 +158,1 @@\n-    static MethodHandle specialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n-        if (callingSequence.forUpcall()) {\n-            MethodHandle wrapper = UPCALL_WRAPPER_CACHE.get(callingSequence.functionDesc(), fd -> specializeUpcall(leafHandle, callingSequence, abi));\n-            return MethodHandles.insertArguments(wrapper, 0, leafHandle); \/\/ lazily customized for leaf handle instances\n-        } else {\n-            return specializeDowncall(leafHandle, callingSequence, abi);\n-        }\n-    }\n-\n-    private static MethodHandle specializeDowncall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+    static MethodHandle specializeDowncall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n@@ -186,1 +175,1 @@\n-    private static MethodHandle specializeUpcall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+    static MethodHandle specializeUpcall(MethodType targetType, CallingSequence callingSequence, ABIDescriptor abi) {\n@@ -190,1 +179,1 @@\n-        byte[] bytes = specializeHelper(leafHandle.type(), callerMethodType, callingSequence, abi);\n+        byte[] bytes = specializeHelper(targetType, callerMethodType, callingSequence, abi);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-            handle = BindingSpecializer.specialize(handle, callingSequence, abi);\n+            handle = BindingSpecializer.specializeDowncall(handle, callingSequence, abi);\n@@ -201,1 +201,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -140,1 +141,1 @@\n-    public static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n+    private static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n@@ -157,0 +158,21 @@\n+    public static UpcallStubFactory arrangeUpcallHelper(MethodType targetType, boolean isInMemoryReturn, boolean dropReturn,\n+                                                        ABIDescriptor abi, CallingSequence callingSequence) {\n+        if (isInMemoryReturn) {\n+            \/\/ simulate the adaptation to get the type\n+            MethodHandle fakeTarget = MethodHandles.empty(targetType);\n+            targetType = adaptUpcallForIMR(fakeTarget, dropReturn).type();\n+        }\n+\n+        UpcallStubFactory factory = UpcallLinker.makeFactory(targetType, abi, callingSequence);\n+\n+        if (isInMemoryReturn) {\n+            final UpcallStubFactory finalFactory = factory;\n+            factory = (target, scope) -> {\n+                target = adaptUpcallForIMR(target, dropReturn);\n+                return finalFactory.makeStub(target, scope);\n+            };\n+        }\n+\n+        return factory;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -38,0 +39,1 @@\n+import java.util.function.UnaryOperator;\n@@ -58,1 +60,1 @@\n-                    methodType(Object.class, Object[].class, InvocationData.class));\n+                    methodType(Object.class, MethodHandle.class, Object[].class, InvocationData.class));\n@@ -64,1 +66,1 @@\n-    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, SegmentScope scope) {\n+    public static UpcallStubFactory makeFactory(MethodType targetType, ABIDescriptor abi, CallingSequence callingSequence) {\n@@ -71,1 +73,1 @@\n-        MethodHandle doBindings;\n+        UnaryOperator<MethodHandle> doBindingsMaker;\n@@ -73,2 +75,6 @@\n-            doBindings = BindingSpecializer.specialize(target, callingSequence, abi);\n-            assert doBindings.type() == llType;\n+            MethodHandle doBindings = BindingSpecializer.specializeUpcall(targetType, callingSequence, abi);\n+            doBindingsMaker = target -> {\n+                MethodHandle handle = MethodHandles.insertArguments(doBindings, 0, target);\n+                assert handle.type() == llType;\n+                return handle;\n+            };\n@@ -82,5 +88,9 @@\n-            target = target.asSpreader(Object[].class, spreaderCount);\n-            InvocationData invData = new InvocationData(target, argIndices, retIndices, callingSequence, retMoves, abi);\n-            doBindings = insertArguments(MH_invokeInterpBindings, 1, invData);\n-            doBindings = doBindings.asCollector(Object[].class, llType.parameterCount());\n-            doBindings = doBindings.asType(llType);\n+            final int finalSpreaderCount = spreaderCount;\n+            InvocationData invData = new InvocationData(argIndices, retIndices, callingSequence, retMoves, abi);\n+            MethodHandle doBindings = insertArguments(MH_invokeInterpBindings, 2, invData);\n+            doBindingsMaker = target -> {\n+                target = target.asSpreader(Object[].class, finalSpreaderCount);\n+                MethodHandle handle = MethodHandles.insertArguments(doBindings, 0, target);\n+                handle = handle.asCollector(Object[].class, llType.parameterCount());\n+                return handle.asType(llType);\n+            };\n@@ -89,2 +99,0 @@\n-        checkPrimitive(doBindings.type());\n-        doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n@@ -94,3 +102,9 @@\n-        long entryPoint = makeUpcallStub(doBindings, abi, conv,\n-                callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n-        return UpcallStubs.makeUpcall(entryPoint, scope);\n+        return (target, scope) -> {\n+            assert target.type() == targetType;\n+            MethodHandle doBindings = doBindingsMaker.apply(target);\n+            checkPrimitive(doBindings.type());\n+            doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n+            long entryPoint = makeUpcallStub(doBindings, abi, conv,\n+                    callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n+            return UpcallStubs.makeUpcall(entryPoint, scope);\n+        };\n@@ -123,2 +137,1 @@\n-    private record InvocationData(MethodHandle leaf,\n-                                  Map<VMStorage, Integer> argIndexMap,\n+    private record InvocationData(Map<VMStorage, Integer> argIndexMap,\n@@ -130,1 +143,1 @@\n-    private static Object invokeInterpBindings(Object[] lowLevelArgs, InvocationData invData) throws Throwable {\n+    private static Object invokeInterpBindings(MethodHandle leaf, Object[] lowLevelArgs, InvocationData invData) throws Throwable {\n@@ -157,1 +170,1 @@\n-            Object o = invData.leaf.invoke(highLevelArgs);\n+            Object o = leaf.invoke(highLevelArgs);\n@@ -165,1 +178,1 @@\n-            if (invData.leaf.type().returnType() != void.class) {\n+            if (leaf.type().returnType() != void.class) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":34,"deletions":21,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -192,1 +193,1 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -194,6 +195,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(abiDescriptor(), target, bindings.callingSequence, session);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, abiDescriptor(),\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -64,2 +63,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n+        return CallArranger.LINUX.arrangeUpcall(targetType, function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -64,2 +63,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n+        return CallArranger.MACOS.arrangeUpcall(targetType, function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -61,2 +60,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return  CallArranger.WINDOWS.arrangeUpcall(target, targetType, function, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n+        return CallArranger.WINDOWS.arrangeUpcall(targetType, function);\n@@ -79,1 +78,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -123,2 +124,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n-\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -126,6 +126,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(CLinux, target, bindings.callingSequence, scope);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CLinux,\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return LinuxRISCV64CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n+        return LinuxRISCV64CallArranger.arrangeUpcall(targetType, function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -135,1 +136,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -137,6 +138,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(CSysV, target, bindings.callingSequence, scope);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CSysV,\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -55,0 +54,1 @@\n+\n@@ -61,2 +61,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n+        return CallArranger.arrangeUpcall(targetType, function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -134,1 +135,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -136,6 +137,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, false \/* need the return value as well *\/);\n-        }\n-\n-        return UpcallLinker.make(CWindows, target, bindings.callingSequence, scope);\n+        final boolean dropReturn = false; \/* need the return value as well *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CWindows,\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n+        return CallArranger.arrangeUpcall(targetType, function);\n@@ -79,1 +79,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.foreign.Arena;\n@@ -67,1 +68,3 @@\n-        return LINKER.upcallStub(BLANK, BLANK_DESC, SegmentScope.auto());\n+        try (Arena arena = Arena.openConfined()) {\n+            return LINKER.upcallStub(BLANK, BLANK_DESC, arena.scope());\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}