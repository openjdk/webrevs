{"files":[{"patch":"@@ -41,1 +41,15 @@\n-  return compute_heap_alignment();\n+  \/\/ The card marking array and the offset arrays for old generations are\n+  \/\/ committed in os pages as well. Make sure they are entirely full (to\n+  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n+  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n+  \/\/ be 512*4096 = 2MB aligned.\n+\n+  size_t alignment = CardTable::ct_max_alignment_constraint();\n+\n+  if (UseLargePages) {\n+      \/\/ In presence of large pages we have to make sure that our\n+      \/\/ alignment is large page aware.\n+      alignment = lcm(os::large_page_size(), alignment);\n+  }\n+\n+  return alignment;\n@@ -101,0 +115,12 @@\n+static size_t num_young_spaces() {\n+  \/\/ When using NUMA, we create one MutableNUMASpace for each NUMA node\n+  const size_t num_eden_spaces = UseNUMA ? os::numa_get_groups_num() : 1;\n+\n+  \/\/ The young generation must have room for eden + two survivors\n+  return num_eden_spaces + 2;\n+}\n+\n+static size_t num_old_spaces() {\n+  return 1;\n+}\n+\n@@ -104,0 +130,1 @@\n+  const size_t card_table_alignment = CardTable::ct_max_alignment_constraint();\n@@ -105,2 +132,0 @@\n-  HeapAlignment = compute_heap_alignment();\n-}\n@@ -108,4 +133,4 @@\n-void ParallelArguments::initialize_heap_flags_and_sizes_one_pass() {\n-  \/\/ Do basic sizing work\n-  GenArguments::initialize_heap_flags_and_sizes();\n-}\n+  if (UseLargePages) {\n+    const size_t total_spaces = num_young_spaces() + num_old_spaces();\n+    const size_t page_size =  os::page_size_for_region_unaligned(MaxHeapSize, total_spaces);\n+    ParallelScavengeHeap::set_desired_page_size(page_size);\n@@ -113,2 +138,4 @@\n-void ParallelArguments::initialize_heap_flags_and_sizes() {\n-  initialize_heap_flags_and_sizes_one_pass();\n+    if (page_size == os::vm_page_size()) {\n+      log_warning(gc, heap)(\"MaxHeapSize (%zu) must be large enough for %zu * page-size; Disabling UseLargePages for heap\",\n+                            MaxHeapSize, total_spaces);\n+    }\n@@ -116,4 +143,3 @@\n-  if (!UseLargePages) {\n-    ParallelScavengeHeap::set_desired_page_size(os::vm_page_size());\n-    return;\n-  }\n+    if (page_size > SpaceAlignment) {\n+      SpaceAlignment = page_size;\n+    }\n@@ -121,4 +147,1 @@\n-  \/\/ If using large-page, need to update SpaceAlignment so that spaces are page-size aligned.\n-  const size_t min_pages = 4; \/\/ 1 for eden + 1 for each survivor + 1 for old\n-  const size_t page_sz = os::page_size_for_region_aligned(MinHeapSize, min_pages);\n-  ParallelScavengeHeap::set_desired_page_size(page_sz);\n+    HeapAlignment = lcm(page_size, card_table_alignment);\n@@ -126,3 +149,4 @@\n-  if (page_sz == os::vm_page_size()) {\n-    log_warning(gc, heap)(\"MinHeapSize (%zu) must be large enough for 4 * page-size; Disabling UseLargePages for heap\", MinHeapSize);\n-    return;\n+  } else {\n+    assert(is_aligned(SpaceAlignment, os::vm_page_size()), \"\");\n+    ParallelScavengeHeap::set_desired_page_size(os::vm_page_size());\n+    HeapAlignment = card_table_alignment;\n@@ -130,0 +154,1 @@\n+}\n@@ -131,7 +156,6 @@\n-  \/\/ Space is largepage-aligned.\n-  size_t new_alignment = page_sz;\n-  if (new_alignment != SpaceAlignment) {\n-    SpaceAlignment = new_alignment;\n-    \/\/ Redo everything from the start\n-    initialize_heap_flags_and_sizes_one_pass();\n-  }\n+size_t ParallelArguments::young_gen_size_lower_bound() {\n+  return num_young_spaces() * SpaceAlignment;\n+}\n+\n+size_t ParallelArguments::old_gen_size_lower_bound() {\n+  return num_old_spaces() * SpaceAlignment;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":51,"deletions":27,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-  virtual void initialize_heap_flags_and_sizes();\n-\n-  void initialize_heap_flags_and_sizes_one_pass();\n@@ -43,0 +40,2 @@\n+  virtual size_t young_gen_size_lower_bound();\n+  virtual size_t old_gen_size_lower_bound();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,22 @@\n+static size_t compute_heap_alignment() {\n+  \/\/ The card marking array and the offset arrays for old generations are\n+  \/\/ committed in os pages as well. Make sure they are entirely full (to\n+  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n+  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n+  \/\/ be 512*4096 = 2MB aligned.\n+\n+  size_t alignment = CardTable::ct_max_alignment_constraint();\n+\n+  if (UseLargePages) {\n+      \/\/ In presence of large pages we have to make sure that our\n+      \/\/ alignment is large page aware.\n+      alignment = lcm(os::large_page_size(), alignment);\n+  }\n+\n+  return alignment;\n+}\n+\n+size_t SerialArguments::conservative_max_heap_alignment() {\n+  return MAX2((size_t)Generation::GenGrain, compute_heap_alignment());\n+}\n+\n@@ -35,0 +57,7 @@\n+void SerialArguments::initialize_alignments() {\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n+  SpaceAlignment = (size_t)Generation::GenGrain;\n+  HeapAlignment = compute_heap_alignment();\n+}\n+\n@@ -38,0 +67,9 @@\n+\n+size_t SerialArguments::young_gen_size_lower_bound() {\n+  \/\/ The young generation must be aligned and have room for eden + two survivors\n+  return 3 * SpaceAlignment;\n+}\n+\n+size_t SerialArguments::old_gen_size_lower_bound() {\n+  return SpaceAlignment;\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  size_t conservative_max_heap_alignment();\n@@ -35,0 +36,1 @@\n+  virtual void initialize_alignments();\n@@ -36,0 +38,2 @@\n+  virtual size_t young_gen_size_lower_bound();\n+  virtual size_t old_gen_size_lower_bound();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,18 +65,0 @@\n-size_t GCArguments::compute_heap_alignment() {\n-  \/\/ The card marking array and the offset arrays for old generations are\n-  \/\/ committed in os pages as well. Make sure they are entirely full (to\n-  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n-  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n-  \/\/ be 512*4096 = 2MB aligned.\n-\n-  size_t alignment = CardTable::ct_max_alignment_constraint();\n-\n-  if (UseLargePages) {\n-      \/\/ In presence of large pages we have to make sure that our\n-      \/\/ alignment is large page aware.\n-      alignment = lcm(os::large_page_size(), alignment);\n-  }\n-\n-  return alignment;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+\n+  \/\/ Return the (conservative) maximum heap alignment\n@@ -62,2 +64,0 @@\n-\n-  static size_t compute_heap_alignment();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,11 +45,0 @@\n-size_t GenArguments::conservative_max_heap_alignment() { return (size_t)Generation::GenGrain; }\n-\n-static size_t young_gen_size_lower_bound() {\n-  \/\/ The young generation must be aligned and have room for eden + two survivors\n-  return 3 * SpaceAlignment;\n-}\n-\n-static size_t old_gen_size_lower_bound() {\n-  return SpaceAlignment;\n-}\n-\n@@ -67,7 +56,0 @@\n-void GenArguments::initialize_alignments() {\n-  \/\/ Initialize card size before initializing alignments\n-  CardTable::initialize_card_size();\n-  SpaceAlignment = (size_t)Generation::GenGrain;\n-  HeapAlignment = compute_heap_alignment();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-  virtual void initialize_alignments();\n@@ -44,3 +43,0 @@\n-  \/\/ Return the (conservative) maximum heap alignment\n-  virtual size_t conservative_max_heap_alignment();\n-\n@@ -54,0 +50,2 @@\n+  virtual size_t young_gen_size_lower_bound() = 0;\n+  virtual size_t old_gen_size_lower_bound() = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-    heap_alignment = GCArguments::compute_heap_alignment();\n+    heap_alignment = Arguments::conservative_max_heap_alignment();\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1481,1 +1481,1 @@\n-  _conservative_max_heap_alignment = MAX4(heap_alignment,\n+  _conservative_max_heap_alignment = MAX3(heap_alignment,\n@@ -1483,2 +1483,1 @@\n-                                          os::max_page_size(),\n-                                          GCArguments::compute_heap_alignment());\n+                                          os::max_page_size());\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,11 +143,0 @@\n-\n-  class SetMaxNewSizeCmd : public BinaryExecutor {\n-   public:\n-    SetMaxNewSizeCmd(size_t param1, size_t param2) : BinaryExecutor(param1, param2) { }\n-    void execute() {\n-      size_t heap_alignment = GCArguments::compute_heap_alignment();\n-      size_t new_size_value = align_up(MaxHeapSize, heap_alignment)\n-              - param1 + param2;\n-      FLAG_SET_CMDLINE(MaxNewSize, new_size_value);\n-    }\n-  };\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"}]}