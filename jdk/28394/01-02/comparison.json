{"files":[{"patch":"@@ -41,1 +41,15 @@\n-  return compute_heap_alignment();\n+  \/\/ The card marking array and the offset arrays for old generations are\n+  \/\/ committed in os pages as well. Make sure they are entirely full (to\n+  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n+  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n+  \/\/ be 512*4096 = 2MB aligned.\n+\n+  size_t alignment = CardTable::ct_max_alignment_constraint();\n+\n+  if (UseLargePages) {\n+      \/\/ In presence of large pages we have to make sure that our\n+      \/\/ alignment is large page aware.\n+      alignment = lcm(os::large_page_size(), alignment);\n+  }\n+\n+  return alignment;\n@@ -101,0 +115,12 @@\n+static size_t num_young_spaces() {\n+  \/\/ When using NUMA, we create one MutableNUMASpace for each NUMA node\n+  const size_t num_eden_spaces = UseNUMA ? os::numa_get_groups_num() : 1;\n+\n+  \/\/ The young generation must have room for eden + two survivors\n+  return num_eden_spaces + 2;\n+}\n+\n+static size_t num_old_spaces() {\n+  return 1;\n+}\n+\n@@ -104,0 +130,1 @@\n+  const size_t card_table_alignment = CardTable::ct_max_alignment_constraint();\n@@ -105,2 +132,0 @@\n-  HeapAlignment = compute_heap_alignment();\n-}\n@@ -108,4 +133,4 @@\n-size_t ParallelArguments::young_gen_size_lower_bound() {\n-  const size_t num_eden_spaces = UseNUMA\n-                               ? os::numa_get_groups_num()\n-                               : 1;\n+  if (UseLargePages) {\n+    const size_t total_spaces = num_young_spaces() + num_old_spaces();\n+    const size_t page_size =  os::page_size_for_region_unaligned(MaxHeapSize, total_spaces);\n+    ParallelScavengeHeap::set_desired_page_size(page_size);\n@@ -113,3 +138,10 @@\n-  \/\/ One for each space in eden and two survivors\n-  return (num_eden_spaces + 2) * SpaceAlignment;\n-}\n+    if (page_size == os::vm_page_size()) {\n+      log_warning(gc, heap)(\"MaxHeapSize (%zu) must be large enough for %zu * page-size; Disabling UseLargePages for heap\",\n+                            MaxHeapSize, total_spaces);\n+    }\n+\n+    if (page_size > SpaceAlignment) {\n+      SpaceAlignment = page_size;\n+    }\n+\n+    HeapAlignment = lcm(page_size, card_table_alignment);\n@@ -117,4 +149,4 @@\n-void ParallelArguments::initialize_heap_flags_and_sizes() {\n-  const size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();\n-  if (page_size > SpaceAlignment) {\n-    SpaceAlignment = page_size;\n+  } else {\n+    assert(is_aligned(SpaceAlignment, os::vm_page_size()), \"\");\n+    ParallelScavengeHeap::set_desired_page_size(os::vm_page_size());\n+    HeapAlignment = card_table_alignment;\n@@ -122,0 +154,5 @@\n+}\n+\n+size_t ParallelArguments::young_gen_size_lower_bound() {\n+  return num_young_spaces() * SpaceAlignment;\n+}\n@@ -123,1 +160,2 @@\n-  GenArguments::initialize_heap_flags_and_sizes();\n+size_t ParallelArguments::old_gen_size_lower_bound() {\n+  return num_old_spaces() * SpaceAlignment;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  virtual size_t young_gen_size_lower_bound();\n-  virtual void initialize_heap_flags_and_sizes();\n@@ -42,0 +40,2 @@\n+  virtual size_t young_gen_size_lower_bound();\n+  virtual size_t old_gen_size_lower_bound();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+size_t ParallelScavengeHeap::_desired_page_size = 0;\n@@ -69,1 +70,2 @@\n-  ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment);\n+  assert(_desired_page_size != 0, \"Should be initialized\");\n+  ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment, _desired_page_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+  \/\/ At startup, calculate the desired OS page-size based on heap size and large-page flags.\n+  static size_t _desired_page_size;\n+\n@@ -141,0 +144,5 @@\n+  static void set_desired_page_size(size_t page_size) {\n+    assert(is_power_of_2(page_size), \"precondition\");\n+    _desired_page_size = page_size;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,22 @@\n+static size_t compute_heap_alignment() {\n+  \/\/ The card marking array and the offset arrays for old generations are\n+  \/\/ committed in os pages as well. Make sure they are entirely full (to\n+  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n+  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n+  \/\/ be 512*4096 = 2MB aligned.\n+\n+  size_t alignment = CardTable::ct_max_alignment_constraint();\n+\n+  if (UseLargePages) {\n+      \/\/ In presence of large pages we have to make sure that our\n+      \/\/ alignment is large page aware.\n+      alignment = lcm(os::large_page_size(), alignment);\n+  }\n+\n+  return alignment;\n+}\n+\n+size_t SerialArguments::conservative_max_heap_alignment() {\n+  return MAX2((size_t)Generation::GenGrain, compute_heap_alignment());\n+}\n+\n@@ -35,0 +57,7 @@\n+void SerialArguments::initialize_alignments() {\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n+  SpaceAlignment = (size_t)Generation::GenGrain;\n+  HeapAlignment = compute_heap_alignment();\n+}\n+\n@@ -38,0 +67,9 @@\n+\n+size_t SerialArguments::young_gen_size_lower_bound() {\n+  \/\/ The young generation must be aligned and have room for eden + two survivors\n+  return 3 * SpaceAlignment;\n+}\n+\n+size_t SerialArguments::old_gen_size_lower_bound() {\n+  return SpaceAlignment;\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  size_t conservative_max_heap_alignment();\n@@ -35,0 +36,1 @@\n+  virtual void initialize_alignments();\n@@ -36,0 +38,2 @@\n+  virtual size_t young_gen_size_lower_bound();\n+  virtual size_t old_gen_size_lower_bound();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,18 +65,0 @@\n-size_t GCArguments::compute_heap_alignment() {\n-  \/\/ The card marking array and the offset arrays for old generations are\n-  \/\/ committed in os pages as well. Make sure they are entirely full (to\n-  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n-  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n-  \/\/ be 512*4096 = 2MB aligned.\n-\n-  size_t alignment = CardTable::ct_max_alignment_constraint();\n-\n-  if (UseLargePages) {\n-      \/\/ In presence of large pages we have to make sure that our\n-      \/\/ alignment is large page aware.\n-      alignment = lcm(os::large_page_size(), alignment);\n-  }\n-\n-  return alignment;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+\n+  \/\/ Return the (conservative) maximum heap alignment\n@@ -62,2 +64,0 @@\n-\n-  static size_t compute_heap_alignment();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-size_t GenArguments::conservative_max_heap_alignment() { return (size_t)Generation::GenGrain; }\n-\n@@ -58,16 +56,0 @@\n-void GenArguments::initialize_alignments() {\n-  \/\/ Initialize card size before initializing alignments\n-  CardTable::initialize_card_size();\n-  SpaceAlignment = (size_t)Generation::GenGrain;\n-  HeapAlignment = compute_heap_alignment();\n-}\n-\n-size_t GenArguments::young_gen_size_lower_bound() {\n-  \/\/ The young generation must be aligned and have room for eden + two survivors\n-  return 3 * SpaceAlignment;\n-}\n-\n-size_t GenArguments::old_gen_size_lower_bound() {\n-  return SpaceAlignment;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-  virtual void initialize_alignments();\n@@ -44,3 +43,0 @@\n-  \/\/ Return the (conservative) maximum heap alignment\n-  virtual size_t conservative_max_heap_alignment();\n-\n@@ -53,2 +49,0 @@\n-  virtual size_t young_gen_size_lower_bound();\n-  virtual size_t old_gen_size_lower_bound();\n@@ -56,0 +50,2 @@\n+  virtual size_t young_gen_size_lower_bound() = 0;\n+  virtual size_t old_gen_size_lower_bound() = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-    heap_alignment = GCArguments::compute_heap_alignment();\n+    heap_alignment = Arguments::conservative_max_heap_alignment();\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-#include \"runtime\/globals.hpp\"\n@@ -975,1 +974,1 @@\n-ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {\n+ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size) {\n@@ -986,1 +985,14 @@\n-  size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();\n+  size_t page_size;\n+  if (desired_page_size == 0) {\n+    if (UseLargePages) {\n+      page_size = os::large_page_size();\n+    } else {\n+      page_size = os::vm_page_size();\n+    }\n+  } else {\n+    \/\/ Parallel is the only collector that might opt out of using large pages\n+    \/\/ for the heap.\n+    assert(UseParallelGC , \"only Parallel\");\n+    \/\/ Use caller provided value.\n+    page_size = desired_page_size;\n+  }\n@@ -988,1 +1000,0 @@\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment);\n+  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size = 0);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1481,1 +1481,1 @@\n-  _conservative_max_heap_alignment = MAX4(heap_alignment,\n+  _conservative_max_heap_alignment = MAX3(heap_alignment,\n@@ -1483,2 +1483,1 @@\n-                                          os::max_page_size(),\n-                                          GCArguments::compute_heap_alignment());\n+                                          os::max_page_size());\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,11 +143,0 @@\n-\n-  class SetMaxNewSizeCmd : public BinaryExecutor {\n-   public:\n-    SetMaxNewSizeCmd(size_t param1, size_t param2) : BinaryExecutor(param1, param2) { }\n-    void execute() {\n-      size_t heap_alignment = GCArguments::compute_heap_alignment();\n-      size_t new_size_value = align_up(MaxHeapSize, heap_alignment)\n-              - param1 + param2;\n-      FLAG_SET_CMDLINE(MaxNewSize, new_size_value);\n-    }\n-  };\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @comment Since 8372150, UseLargePages may alter Min and Initial heap size\n@@ -34,1 +33,0 @@\n- * @requires !vm.opt.final.UseLargePages\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelHeapSizeFlags.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}