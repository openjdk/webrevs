{"files":[{"patch":"@@ -40,6 +40,3 @@\n-size_t ParallelArguments::conservative_max_heap_alignment() {\n-  \/\/ The card marking array and the offset arrays for old generations are\n-  \/\/ committed in os pages as well. Make sure they are entirely full (to\n-  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n-  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n-  \/\/ be 512*4096 = 2MB aligned.\n+static size_t num_young_spaces() {\n+  \/\/ When using NUMA, we create one MutableNUMASpace for each NUMA node\n+  const size_t num_eden_spaces = UseNUMA ? os::numa_get_groups_num() : 1;\n@@ -47,1 +44,13 @@\n-  size_t alignment = CardTable::ct_max_alignment_constraint();\n+  \/\/ The young generation must have room for eden + two survivors\n+  return num_eden_spaces + 2;\n+}\n+\n+static size_t num_old_spaces() {\n+  return 1;\n+}\n+\n+void ParallelArguments::initialize_alignments() {\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n+  const size_t card_table_alignment = CardTable::ct_max_alignment_constraint();\n+  SpaceAlignment = ParallelScavengeHeap::default_space_alignment();\n@@ -50,4 +59,3 @@\n-      \/\/ In presence of large pages we have to make sure that our\n-      \/\/ alignment is large page aware.\n-      alignment = lcm(os::large_page_size(), alignment);\n-  }\n+    const size_t total_spaces = num_young_spaces() + num_old_spaces();\n+    const size_t page_size =  os::page_size_for_region_unaligned(MaxHeapSize, total_spaces);\n+    ParallelScavengeHeap::set_desired_page_size(page_size);\n@@ -55,1 +63,16 @@\n-  return alignment;\n+    if (page_size == os::vm_page_size()) {\n+      log_warning(gc, heap)(\"MaxHeapSize (%zu) must be large enough for %zu * page-size; Disabling UseLargePages for heap\",\n+                            MaxHeapSize, total_spaces);\n+    }\n+\n+    if (page_size > SpaceAlignment) {\n+      SpaceAlignment = page_size;\n+    }\n+\n+    HeapAlignment = lcm(page_size, card_table_alignment);\n+\n+  } else {\n+    assert(is_aligned(SpaceAlignment, os::vm_page_size()), \"\");\n+    ParallelScavengeHeap::set_desired_page_size(os::vm_page_size());\n+    HeapAlignment = card_table_alignment;\n+  }\n@@ -115,11 +138,6 @@\n-static size_t num_young_spaces() {\n-  \/\/ When using NUMA, we create one MutableNUMASpace for each NUMA node\n-  const size_t num_eden_spaces = UseNUMA ? os::numa_get_groups_num() : 1;\n-\n-  \/\/ The young generation must have room for eden + two survivors\n-  return num_eden_spaces + 2;\n-}\n-\n-static size_t num_old_spaces() {\n-  return 1;\n-}\n+size_t ParallelArguments::conservative_max_heap_alignment() {\n+  \/\/ The card marking array and the offset arrays for old generations are\n+  \/\/ committed in os pages as well. Make sure they are entirely full (to\n+  \/\/ avoid partial page problems), e.g. if 512 bytes heap corresponds to 1\n+  \/\/ byte entry and the os page size is 4096, the maximum heap size should\n+  \/\/ be 512*4096 = 2MB aligned.\n@@ -127,5 +145,1 @@\n-void ParallelArguments::initialize_alignments() {\n-  \/\/ Initialize card size before initializing alignments\n-  CardTable::initialize_card_size();\n-  const size_t card_table_alignment = CardTable::ct_max_alignment_constraint();\n-  SpaceAlignment = ParallelScavengeHeap::default_space_alignment();\n+  size_t alignment = CardTable::ct_max_alignment_constraint();\n@@ -134,12 +148,4 @@\n-    const size_t total_spaces = num_young_spaces() + num_old_spaces();\n-    const size_t page_size =  os::page_size_for_region_unaligned(MaxHeapSize, total_spaces);\n-    ParallelScavengeHeap::set_desired_page_size(page_size);\n-\n-    if (page_size == os::vm_page_size()) {\n-      log_warning(gc, heap)(\"MaxHeapSize (%zu) must be large enough for %zu * page-size; Disabling UseLargePages for heap\",\n-                            MaxHeapSize, total_spaces);\n-    }\n-\n-    if (page_size > SpaceAlignment) {\n-      SpaceAlignment = page_size;\n-    }\n+      \/\/ In presence of large pages we have to make sure that our\n+      \/\/ alignment is large page aware.\n+      alignment = lcm(os::large_page_size(), alignment);\n+  }\n@@ -147,1 +153,2 @@\n-    HeapAlignment = lcm(page_size, card_table_alignment);\n+  return alignment;\n+}\n@@ -149,5 +156,2 @@\n-  } else {\n-    assert(is_aligned(SpaceAlignment, os::vm_page_size()), \"\");\n-    ParallelScavengeHeap::set_desired_page_size(os::vm_page_size());\n-    HeapAlignment = card_table_alignment;\n-  }\n+CollectedHeap* ParallelArguments::create_heap() {\n+  return new ParallelScavengeHeap();\n@@ -167,4 +171,0 @@\n-\n-CollectedHeap* ParallelArguments::create_heap() {\n-  return new ParallelScavengeHeap();\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +29,0 @@\n-#include \"gc\/shared\/gcArguments.hpp\"\n@@ -31,2 +31,0 @@\n-class CollectedHeap;\n-\n@@ -36,1 +34,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +49,5 @@\n-size_t SerialArguments::conservative_max_heap_alignment() {\n-  return MAX2((size_t)Generation::GenGrain, compute_heap_alignment());\n+void SerialArguments::initialize_alignments() {\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n+  SpaceAlignment = (size_t)Generation::GenGrain;\n+  HeapAlignment = compute_heap_alignment();\n@@ -57,5 +61,2 @@\n-void SerialArguments::initialize_alignments() {\n-  \/\/ Initialize card size before initializing alignments\n-  CardTable::initialize_card_size();\n-  SpaceAlignment = (size_t)Generation::GenGrain;\n-  HeapAlignment = compute_heap_alignment();\n+size_t SerialArguments::conservative_max_heap_alignment() {\n+  return MAX2((size_t)Generation::GenGrain, compute_heap_alignment());\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +31,0 @@\n-class CollectedHeap;\n-\n@@ -34,2 +33,0 @@\n-  size_t conservative_max_heap_alignment();\n-  virtual void initialize();\n@@ -37,0 +34,2 @@\n+  virtual void initialize();\n+  virtual size_t conservative_max_heap_alignment();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-protected:\n-  virtual void initialize_heap_flags_and_sizes();\n@@ -52,0 +50,3 @@\n+\n+protected:\n+  virtual void initialize_heap_flags_and_sizes();\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}