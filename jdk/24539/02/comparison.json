{"files":[{"patch":"@@ -1215,1 +1215,1 @@\n-  JavaThread* current_thread  = JavaThread::current();\n+  JavaThread* current_thread = JavaThread::current();\n@@ -1231,0 +1231,1 @@\n+    JvmtiJavaUpcallMark jjum(current_thread); \/\/ hide JVMTI events for Java upcall\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -867,0 +867,1 @@\n+  JvmtiJavaUpcallMark jjum(current_thread); \/\/ hide JVMTI events for Java upcall\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -457,0 +457,18 @@\n+\/\/ This helper class marks current thread as making a Java upcall.\n+\/\/ It is needed to hide JVMTI events during JVMTI operation.\n+class JvmtiJavaUpcallMark : public StackObj {\n+ private:\n+  JavaThread* _current;\n+ public:\n+  JvmtiJavaUpcallMark(JavaThread* current) {\n+    _current = current;\n+    assert(!_current->is_in_java_upcall(), \"sanity check\");\n+    _current->toggle_is_in_java_upcall();\n+  }\n+\n+  ~JvmtiJavaUpcallMark() {\n+    assert(_current->is_in_java_upcall(), \"sanity check\");\n+    _current->toggle_is_in_java_upcall();\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1379,0 +1379,4 @@\n+    \/\/ All events can be disabled if current thread is doing a Java upcall originated by JVMTI.\n+    \/\/ ClassLoad events are important for JDWP agent but not expected during such upcalls.\n+    \/\/ Catch if this invariant is broken.\n+    assert(!thread->is_in_java_upcall(), \"unexpected ClassLoad event during JVMTI upcall\");\n@@ -1416,0 +1420,4 @@\n+    \/\/ All events can be disabled if current thread is doing a Java upcall originated by JVMTI.\n+    \/\/ ClassPrepare events are important for JDWP agent but not expected during such upcalls.\n+    \/\/ Catch if this invariant is broken.\n+    assert(!thread->is_in_java_upcall(), \"unexpected ClassPrepare event during JVMTI upcall\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+  _is_in_java_upcall(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -334,0 +334,1 @@\n+  bool                  _is_in_java_upcall;              \/\/ JVMTI is doing a Java upcall, so JVMTI events must be hidden\n@@ -725,0 +726,3 @@\n+  bool is_in_java_upcall() const                 { return _is_in_java_upcall; }\n+  void toggle_is_in_java_upcall()                { _is_in_java_upcall = !_is_in_java_upcall; };\n+\n@@ -731,1 +735,2 @@\n-  bool should_hide_jvmti_events() const          { return _is_in_VTMS_transition || _is_disable_suspend; }\n+  \/\/ - JVMTI is making a Java upcall (_is_in_java_upcall)\n+  bool should_hide_jvmti_events() const          { return _is_in_VTMS_transition || _is_disable_suspend || _is_in_java_upcall; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}