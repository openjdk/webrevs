{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,2 +394,1 @@\n-            String s = Utils.stackTrace(t);\n-            logger.log(Level.INFO, \"ERROR: \" + s);\n+            logger.log(Level.INFO, \"ERROR: \" + t, t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Log.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -594,0 +594,5 @@\n+                if (Log.errors()) {\n+                    Log.logError(\"%s QUIC handshake failed: %s\"\n+                            .formatted(logTag(), cause));\n+                    Log.logError(cause);\n+                }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicConnectionImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+import java.util.logging.Handler;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.internal.net.http.quic.QuicConnectionImpl;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8371471\n+ * @summary Verify that HTTP\/3 handshake failures are logged if\n+ *          logging errors is enabled\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run testng\/othervm\n+ *              -Djdk.httpclient.HttpClient.log=errors\n+ *              H3LogHandshakeErrors\n+ *\/\n+\/\/ -Djava.security.debug=all\n+public class H3LogHandshakeErrors implements HttpServerAdapters {\n+\n+    private SSLContext sslContext;\n+    private HttpTestServer h3Server;\n+    private String requestURI;\n+    private static Logger clientLogger;\n+\n+    @BeforeClass\n+    public void beforeClass() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        \/\/ create an H3 only server\n+        h3Server = HttpTestServer.create(HTTP_3_URI_ONLY, sslContext);\n+        h3Server.addHandler((exchange) -> exchange.sendResponseHeaders(200, 0), \"\/hello\");\n+        h3Server.start();\n+        System.out.println(\"Server started at \" + h3Server.getAddress());\n+        requestURI = \"https:\/\/\" + h3Server.serverAuthority() + \"\/hello\";\n+    }\n+\n+    @AfterClass\n+    public void afterClass() throws Exception {\n+        if (h3Server != null) {\n+            System.out.println(\"Stopping server \" + h3Server.getAddress());\n+            h3Server.stop();\n+        }\n+    }\n+\n+    static String format(LogRecord record) {\n+        String thrown = Optional.ofNullable(record.getThrown())\n+                .map(t -> \": \" + t).orElse(\"\");\n+        return \"\\n  \\\"%s: %s %s: %s%s\\\"\".formatted(\n+                record.getLevel(),\n+                record.getSourceClassName(),\n+                record.getSourceMethodName(),\n+                record.getMessage(),\n+                thrown);\n+    }\n+\n+    \/**\n+     * Issues a GET HTTP3 requests and verifies that the\n+     * expected exception is logged.\n+     *\/\n+    @Test\n+    public void testErrorLogging() throws Exception {\n+        \/\/ jdk.httpclient.HttpClient.log=errors must be enabled\n+        \/\/ for this test\n+        String logging = System.getProperty(\"jdk.httpclient.HttpClient.log\", \"\");\n+        var categories = Arrays.asList(logging.split(\",\"));\n+        assertTrue(categories.contains(\"errors\"),\n+                \"'errors' not found in \" + categories);\n+\n+        \/\/ create a client without the test specific SSLContext\n+        \/\/ so that the client doesn't have the server's\n+        \/\/ certificate\n+        final HttpClient client = newClientBuilderForH3()\n+                .proxy(NO_PROXY)\n+                .build();\n+        final URI reqURI = new URI(requestURI);\n+        final HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(reqURI)\n+                .version(HTTP_3);\n+        clientLogger = Logger.getLogger(\"jdk.httpclient.HttpClient\");\n+\n+        CopyOnWriteArrayList<LogRecord> records = new CopyOnWriteArrayList<>();\n+        Handler handler = new Handler() {\n+            @Override\n+            public void publish(LogRecord record) {\n+                \/\/ forces the LogRecord to evaluate the caller\n+                \/\/ while in the publish() method to make sure\n+                \/\/ the source class name and source method name\n+                \/\/ are correctly evaluated.\n+                record.getSourceClassName();\n+                records.add(record);\n+            }\n+            @Override public void flush() {}\n+            @Override public void close() {\n+            }\n+        };\n+        clientLogger.addHandler(handler);\n+\n+        try {\n+            final HttpRequest req1 = reqBuilder.copy().GET().build();\n+            System.out.println(\"Issuing request: \" + req1);\n+            final HttpResponse<Void> resp1 = client.send(req1, BodyHandlers.discarding());\n+            Assert.assertEquals(resp1.statusCode(), 200, \"unexpected response code for GET request\");\n+        } catch (IOException io) {\n+            System.out.println(\"Got expected exception: \" + io);\n+        } finally {\n+            LogRecord expected = null;\n+            \/\/ this is a bit fragile and may need to be updated if the\n+            \/\/ place where we log the exception from changes.\n+            String expectedClassName = QuicConnectionImpl.class.getName()\n+                    + \"$HandshakeFlow\";\n+            for (var record : records) {\n+                if (record.getLevel() != Level.INFO) continue;\n+                if (!record.getMessage().contains(\"ERROR:\")) continue;\n+                if (record.getMessage().contains(\"client peer\")) continue;\n+                var expectedThrown = record.getThrown();\n+                if (expectedThrown == null) continue;\n+                if (!record.getSourceClassName().equals(expectedClassName)) continue;\n+                if (expectedThrown.getMessage().contains(\"client peer\")) continue;\n+                expected = record;\n+                break;\n+            }\n+            assertNotNull(expected, \"No throwable for \"\n+                    + expectedClassName + \" found in \"\n+                    + records.stream().map(H3LogHandshakeErrors::format).toList()\n+                    + \"\\n \");\n+            System.out.printf(\"Found expected exception: %s%n\\t logged at: %s %s%n\",\n+                    expected.getThrown(),\n+                    expected.getSourceClassName(),\n+                    expected.getSourceMethodName());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3LogHandshakeErrors.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"}]}