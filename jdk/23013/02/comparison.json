{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n@@ -33,0 +34,1 @@\n+#include <string.h>\n@@ -185,0 +187,26 @@\n+\/**\n+ * Helper function to get the 'psinfo_t' data from \"\/proc\/%d\/psinfo\".\n+ * Returns 0 on success and -1 on error.\n+ *\/\n+static int getPsinfo(pid_t pid, psinfo_t *psinfo) {\n+    FILE* fp;\n+    char fn[32];\n+    size_t ret;\n+\n+    \/*\n+     * Try to open \/proc\/%d\/psinfo\n+     *\/\n+    snprintf(fn, sizeof fn, \"\/proc\/%d\/psinfo\", pid);\n+    fp = fopen(fn, \"r\");\n+    if (fp == NULL) {\n+        return -1;\n+    }\n+\n+    ret = fread(psinfo, 1, sizeof(psinfo_t), fp);\n+    fclose(fp);\n+    if (ret < sizeof(psinfo_t)) {\n+        return -1;\n+    }\n+    return 0;\n+}\n+\n@@ -186,1 +214,31 @@\n-    unix_getCmdlineAndUserInfo(env, jinfo, pid);\n+    psinfo_t psinfo;\n+    char prargs[PRARGSZ + 1];\n+    jstring cmdexe = NULL;\n+\n+    \/*\n+     * Now try to open \/proc\/%d\/psinfo\n+     *\/\n+    if (getPsinfo(pid, &psinfo) < 0) {\n+        unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe, NULL);\n+        return;\n+    }\n+\n+    unix_getUserInfo(env, jinfo, psinfo.pr_uid);\n+\n+    \/*\n+     * Now read psinfo.pr_psargs which contains the first PRARGSZ characters of the\n+     * argument list (i.e. arg[0] arg[1] ...). Unfortunately, PRARGSZ is usually set\n+     * to 80 characters only. Nevertheless it's better than nothing :)\n+     *\/\n+    strncpy(prargs, psinfo.pr_psargs, PRARGSZ);\n+    prargs[PRARGSZ] = '\\0';\n+    if (prargs[0] == '\\0') {\n+        \/* If psinfo.pr_psargs didn't contain any strings, use psinfo.pr_fname\n+         * (which only contains the last component of exec()ed pathname) as a\n+         * last resort. This is true for AIX kernel processes for example.\n+         *\/\n+        strncpy(prargs, psinfo.pr_fname, PRARGSZ);\n+        prargs[PRARGSZ] = '\\0';\n+    }\n+    unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe,\n+                      prargs[0] == '\\0' ? NULL : prargs);\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":60,"deletions":2,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-\n+#include <dirent.h>\n@@ -63,0 +63,18 @@\n+\/*\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Reads \/proc and accumulates any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n+ * The number of pids is returned if they all fit.\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n+ * the desired length is returned.\n+ *\/\n@@ -65,1 +83,105 @@\n-    return unix_getChildren(env, jpid, jarray, jparentArray, jstimesArray);\n+    DIR* dir;\n+    struct dirent* ptr;\n+    pid_t pid = (pid_t) jpid;\n+    jlong* pids = NULL;\n+    jlong* ppids = NULL;\n+    jlong* stimes = NULL;\n+    jsize parentArraySize = 0;\n+    jsize arraySize = 0;\n+    jsize stimesSize = 0;\n+    jsize count = 0;\n+\n+    arraySize = (*env)->GetArrayLength(env, jarray);\n+    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+    if (jparentArray != NULL) {\n+        parentArraySize = (*env)->GetArrayLength(env, jparentArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != parentArraySize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+    if (jstimesArray != NULL) {\n+        stimesSize = (*env)->GetArrayLength(env, jstimesArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != stimesSize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * To locate the children we scan \/proc looking for files that have a\n+     * position integer as a filename.\n+     *\/\n+    if ((dir = opendir(\"\/proc\")) == NULL) {\n+        JNU_ThrowByNameWithMessageAndLastError(env,\n+            \"java\/lang\/RuntimeException\", \"Unable to open \/proc\");\n+        return -1;\n+    }\n+\n+    do { \/\/ Block to break out of on Exception\n+        pids = (*env)->GetLongArrayElements(env, jarray, NULL);\n+        if (pids == NULL) {\n+            break;\n+        }\n+        if (jparentArray != NULL) {\n+            ppids  = (*env)->GetLongArrayElements(env, jparentArray, NULL);\n+            if (ppids == NULL) {\n+                break;\n+            }\n+        }\n+        if (jstimesArray != NULL) {\n+            stimes  = (*env)->GetLongArrayElements(env, jstimesArray, NULL);\n+            if (stimes == NULL) {\n+                break;\n+            }\n+        }\n+\n+        while ((ptr = readdir(dir)) != NULL) {\n+            pid_t ppid = 0;\n+            jlong totalTime = 0L;\n+            jlong startTime = 0L;\n+\n+            \/* skip files that aren't numbers *\/\n+            pid_t childpid = (pid_t) atoi(ptr->d_name);\n+            if ((int) childpid <= 0) {\n+                continue;\n+            }\n+\n+            \/\/ Get the parent pid, and start time\n+            ppid = os_getParentPidAndTimings(env, childpid, &totalTime, &startTime);\n+            if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n+                if (count < arraySize) {\n+                    \/\/ Only store if it fits\n+                    pids[count] = (jlong) childpid;\n+\n+                    if (ppids != NULL) {\n+                        \/\/ Store the parentPid\n+                        ppids[count] = (jlong) ppid;\n+                    }\n+                    if (stimes != NULL) {\n+                        \/\/ Store the process start time\n+                        stimes[count] = startTime;\n+                    }\n+                }\n+                count++; \/\/ Count to tabulate size needed\n+            }\n+        }\n+    } while (0);\n+\n+    if (pids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jarray, pids, 0);\n+    }\n+    if (ppids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jparentArray, ppids, 0);\n+    }\n+    if (stimes != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jstimesArray, stimes, 0);\n+    }\n+\n+    closedir(dir);\n+    \/\/ If more pids than array had size for; count will be greater than array size\n+    return count;\n","filename":"src\/java.base\/linux\/native\/libjava\/ProcessHandleImpl_linux.c","additions":125,"deletions":3,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n- * The currently supported Unix variants are Solaris, Linux, MaxOS X and AIX.\n+ * The currently supported Unix variants are Linux, MaxOS X and AIX.\n@@ -81,1 +81,1 @@\n- * Example 1:\n+ * Example:\n@@ -90,11 +90,0 @@\n- * Example 2:\n- * ----------\n- * The implementation of Java_java_lang_ProcessHandleImpl_00024Info_info0 is the\n- * same on Solaris and AIX but different on Linux and MacOSX. We therefore simply\n- * call the helpers os_getParentPidAndTimings() and os_getCmdlineAndUserInfo().\n- * The Linux and MaxOS X versions of these functions (in the corresponding files\n- * ProcessHandleImpl_linux.c and ProcessHandleImpl_macosx.c) directly contain\n- * the platform specific implementations while the Solaris and AIX\n- * implementations simply call back to unix_getParentPidAndTimings() and\n- * unix_getCmdlineAndUserInfo() which are implemented right in this file.\n- *\n@@ -468,229 +457,0 @@\n-\/*\n- * The following functions are for Linux\n- *\/\n-\n-#if defined (__linux__)\n-\n-\/*\n- * Return pids of active processes, and optionally parent pids and\n- * start times for each process.\n- * For a specific non-zero pid, only the direct children are returned.\n- * If the pid is zero, all active processes are returned.\n- * Reads \/proc and accumulates any process following the rules above.\n- * The resulting pids are stored into an array of longs named jarray.\n- * The number of pids is returned if they all fit.\n- * If the parentArray is non-null, store also the parent pid.\n- * In this case the parentArray must have the same length as the result pid array.\n- * Of course in the case of a given non-zero pid all entries in the parentArray\n- * will contain this pid, so this array does only make sense in the case of a given\n- * zero pid.\n- * If the jstimesArray is non-null, store also the start time of the pid.\n- * In this case the jstimesArray must have the same length as the result pid array.\n- * If the array(s) (is|are) too short, excess pids are not stored and\n- * the desired length is returned.\n- *\/\n-jint unix_getChildren(JNIEnv *env, jlong jpid, jlongArray jarray,\n-                      jlongArray jparentArray, jlongArray jstimesArray) {\n-    DIR* dir;\n-    struct dirent* ptr;\n-    pid_t pid = (pid_t) jpid;\n-    jlong* pids = NULL;\n-    jlong* ppids = NULL;\n-    jlong* stimes = NULL;\n-    jsize parentArraySize = 0;\n-    jsize arraySize = 0;\n-    jsize stimesSize = 0;\n-    jsize count = 0;\n-\n-    arraySize = (*env)->GetArrayLength(env, jarray);\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    if (jparentArray != NULL) {\n-        parentArraySize = (*env)->GetArrayLength(env, jparentArray);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-\n-        if (arraySize != parentArraySize) {\n-            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n-            return 0;\n-        }\n-    }\n-    if (jstimesArray != NULL) {\n-        stimesSize = (*env)->GetArrayLength(env, jstimesArray);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-\n-        if (arraySize != stimesSize) {\n-            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n-            return 0;\n-        }\n-    }\n-\n-    \/*\n-     * To locate the children we scan \/proc looking for files that have a\n-     * position integer as a filename.\n-     *\/\n-    if ((dir = opendir(\"\/proc\")) == NULL) {\n-        JNU_ThrowByNameWithMessageAndLastError(env,\n-            \"java\/lang\/RuntimeException\", \"Unable to open \/proc\");\n-        return -1;\n-    }\n-\n-    do { \/\/ Block to break out of on Exception\n-        pids = (*env)->GetLongArrayElements(env, jarray, NULL);\n-        if (pids == NULL) {\n-            break;\n-        }\n-        if (jparentArray != NULL) {\n-            ppids  = (*env)->GetLongArrayElements(env, jparentArray, NULL);\n-            if (ppids == NULL) {\n-                break;\n-            }\n-        }\n-        if (jstimesArray != NULL) {\n-            stimes  = (*env)->GetLongArrayElements(env, jstimesArray, NULL);\n-            if (stimes == NULL) {\n-                break;\n-            }\n-        }\n-\n-        while ((ptr = readdir(dir)) != NULL) {\n-            pid_t ppid = 0;\n-            jlong totalTime = 0L;\n-            jlong startTime = 0L;\n-\n-            \/* skip files that aren't numbers *\/\n-            pid_t childpid = (pid_t) atoi(ptr->d_name);\n-            if ((int) childpid <= 0) {\n-                continue;\n-            }\n-\n-            \/\/ Get the parent pid, and start time\n-            ppid = os_getParentPidAndTimings(env, childpid, &totalTime, &startTime);\n-            if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n-                if (count < arraySize) {\n-                    \/\/ Only store if it fits\n-                    pids[count] = (jlong) childpid;\n-\n-                    if (ppids != NULL) {\n-                        \/\/ Store the parentPid\n-                        ppids[count] = (jlong) ppid;\n-                    }\n-                    if (stimes != NULL) {\n-                        \/\/ Store the process start time\n-                        stimes[count] = startTime;\n-                    }\n-                }\n-                count++; \/\/ Count to tabulate size needed\n-            }\n-        }\n-    } while (0);\n-\n-    if (pids != NULL) {\n-        (*env)->ReleaseLongArrayElements(env, jarray, pids, 0);\n-    }\n-    if (ppids != NULL) {\n-        (*env)->ReleaseLongArrayElements(env, jparentArray, ppids, 0);\n-    }\n-    if (stimes != NULL) {\n-        (*env)->ReleaseLongArrayElements(env, jstimesArray, stimes, 0);\n-    }\n-\n-    closedir(dir);\n-    \/\/ If more pids than array had size for; count will be greater than array size\n-    return count;\n-}\n-\n-#endif \/\/ defined (__linux__)\n-\n-\/*\n- * The following functions are for AIX.\n- *\/\n-\n-#if defined(_AIX)\n-\n-\/**\n- * Helper function to get the 'psinfo_t' data from \"\/proc\/%d\/psinfo\".\n- * Returns 0 on success and -1 on error.\n- *\/\n-static int getPsinfo(pid_t pid, psinfo_t *psinfo) {\n-    FILE* fp;\n-    char fn[32];\n-    size_t ret;\n-\n-    \/*\n-     * Try to open \/proc\/%d\/psinfo\n-     *\/\n-    snprintf(fn, sizeof fn, \"\/proc\/%d\/psinfo\", pid);\n-    fp = fopen(fn, \"r\");\n-    if (fp == NULL) {\n-        return -1;\n-    }\n-\n-    ret = fread(psinfo, 1, sizeof(psinfo_t), fp);\n-    fclose(fp);\n-    if (ret < sizeof(psinfo_t)) {\n-        return -1;\n-    }\n-    return 0;\n-}\n-\n-\/**\n- * Read \/proc\/<pid>\/psinfo and return the ppid, total cputime and start time.\n- * Return: -1 is fail;  >=  0 is parent pid\n- * 'total' will contain the running time of 'pid' in nanoseconds.\n- * 'start' will contain the start time of 'pid' in milliseconds since epoch.\n- *\/\n-pid_t unix_getParentPidAndTimings(JNIEnv *env, pid_t pid,\n-                                  jlong *totalTime, jlong* startTime) {\n-    psinfo_t psinfo;\n-\n-    if (getPsinfo(pid, &psinfo) < 0) {\n-        return -1;\n-    }\n-\n-    \/\/ Validate the pid before returning the info\n-    if (kill(pid, 0) < 0) {\n-        return -1;\n-    }\n-\n-    *totalTime = psinfo.pr_time.tv_sec * 1000000000L + psinfo.pr_time.tv_nsec;\n-\n-    *startTime = psinfo.pr_start.tv_sec * (jlong)1000 +\n-                 psinfo.pr_start.tv_nsec \/ 1000000;\n-\n-    return (pid_t) psinfo.pr_ppid;\n-}\n-\n-void unix_getCmdlineAndUserInfo(JNIEnv *env, jobject jinfo, pid_t pid) {\n-    psinfo_t psinfo;\n-    char prargs[PRARGSZ + 1];\n-    jstring cmdexe = NULL;\n-\n-    \/*\n-     * Now try to open \/proc\/%d\/psinfo\n-     *\/\n-    if (getPsinfo(pid, &psinfo) < 0) {\n-        unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe, NULL);\n-        return;\n-    }\n-\n-    unix_getUserInfo(env, jinfo, psinfo.pr_uid);\n-\n-    \/*\n-     * Now read psinfo.pr_psargs which contains the first PRARGSZ characters of the\n-     * argument list (i.e. arg[0] arg[1] ...). Unfortunately, PRARGSZ is usually set\n-     * to 80 characters only. Nevertheless it's better than nothing :)\n-     *\/\n-    strncpy(prargs, psinfo.pr_psargs, PRARGSZ);\n-    prargs[PRARGSZ] = '\\0';\n-    if (prargs[0] == '\\0') {\n-        \/* If psinfo.pr_psargs didn't contain any strings, use psinfo.pr_fname\n-         * (which only contains the last component of exec()ed pathname) as a\n-         * last resort. This is true for AIX kernel processes for example.\n-         *\/\n-        strncpy(prargs, psinfo.pr_fname, PRARGSZ);\n-        prargs[PRARGSZ] = '\\0';\n-    }\n-    unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe,\n-                      prargs[0] == '\\0' ? NULL : prargs);\n-}\n-\n-#endif \/\/ defined(_AIX)\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":3,"deletions":243,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,0 @@\n-extern pid_t unix_getParentPidAndTimings(JNIEnv *env, pid_t pid,\n-                                         jlong *total, jlong *start);\n@@ -64,1 +62,0 @@\n-extern void unix_getCmdlineAndUserInfo(JNIEnv *env, jobject jinfo, pid_t pid);\n@@ -67,2 +64,0 @@\n-extern jint unix_getChildren(JNIEnv *env, jlong jpid, jlongArray array,\n-                             jlongArray jparentArray, jlongArray jstimesArray);\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}