{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include <string.h>\n@@ -185,0 +186,26 @@\n+\/**\n+ * Helper function to get the 'psinfo_t' data from \"\/proc\/%d\/psinfo\".\n+ * Returns 0 on success and -1 on error.\n+ *\/\n+static int getPsinfo(pid_t pid, psinfo_t *psinfo) {\n+    FILE* fp;\n+    char fn[32];\n+    size_t ret;\n+\n+    \/*\n+     * Try to open \/proc\/%d\/psinfo\n+     *\/\n+    snprintf(fn, sizeof fn, \"\/proc\/%d\/psinfo\", pid);\n+    fp = fopen(fn, \"r\");\n+    if (fp == NULL) {\n+        return -1;\n+    }\n+\n+    ret = fread(psinfo, 1, sizeof(psinfo_t), fp);\n+    fclose(fp);\n+    if (ret < sizeof(psinfo_t)) {\n+        return -1;\n+    }\n+    return 0;\n+}\n+\n@@ -186,1 +213,31 @@\n-    unix_getCmdlineAndUserInfo(env, jinfo, pid);\n+    psinfo_t psinfo;\n+    char prargs[PRARGSZ + 1];\n+    jstring cmdexe = NULL;\n+\n+    \/*\n+     * Now try to open \/proc\/%d\/psinfo\n+     *\/\n+    if (getPsinfo(pid, &psinfo) < 0) {\n+        unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe, NULL);\n+        return;\n+    }\n+\n+    unix_getUserInfo(env, jinfo, psinfo.pr_uid);\n+\n+    \/*\n+     * Now read psinfo.pr_psargs which contains the first PRARGSZ characters of the\n+     * argument list (i.e. arg[0] arg[1] ...). Unfortunately, PRARGSZ is usually set\n+     * to 80 characters only. Nevertheless it's better than nothing :)\n+     *\/\n+    strncpy(prargs, psinfo.pr_psargs, PRARGSZ);\n+    prargs[PRARGSZ] = '\\0';\n+    if (prargs[0] == '\\0') {\n+        \/* If psinfo.pr_psargs didn't contain any strings, use psinfo.pr_fname\n+         * (which only contains the last component of exec()ed pathname) as a\n+         * last resort. This is true for AIX kernel processes for example.\n+         *\/\n+        strncpy(prargs, psinfo.pr_fname, PRARGSZ);\n+        prargs[PRARGSZ] = '\\0';\n+    }\n+    unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe,\n+                      prargs[0] == '\\0' ? NULL : prargs);\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n- * Example 1:\n+ * Example :\n@@ -90,11 +90,0 @@\n- * Example 2:\n- * ----------\n- * The implementation of Java_java_lang_ProcessHandleImpl_00024Info_info0 is the\n- * same on Solaris and AIX but different on Linux and MacOSX. We therefore simply\n- * call the helpers os_getParentPidAndTimings() and os_getCmdlineAndUserInfo().\n- * The Linux and MaxOS X versions of these functions (in the corresponding files\n- * ProcessHandleImpl_linux.c and ProcessHandleImpl_macosx.c) directly contain\n- * the platform specific implementations while the Solaris and AIX\n- * implementations simply call back to unix_getParentPidAndTimings() and\n- * unix_getCmdlineAndUserInfo() which are implemented right in this file.\n- *\n@@ -603,94 +592,0 @@\n-\/*\n- * The following functions are for AIX.\n- *\/\n-\n-#if defined(_AIX)\n-\n-\/**\n- * Helper function to get the 'psinfo_t' data from \"\/proc\/%d\/psinfo\".\n- * Returns 0 on success and -1 on error.\n- *\/\n-static int getPsinfo(pid_t pid, psinfo_t *psinfo) {\n-    FILE* fp;\n-    char fn[32];\n-    size_t ret;\n-\n-    \/*\n-     * Try to open \/proc\/%d\/psinfo\n-     *\/\n-    snprintf(fn, sizeof fn, \"\/proc\/%d\/psinfo\", pid);\n-    fp = fopen(fn, \"r\");\n-    if (fp == NULL) {\n-        return -1;\n-    }\n-\n-    ret = fread(psinfo, 1, sizeof(psinfo_t), fp);\n-    fclose(fp);\n-    if (ret < sizeof(psinfo_t)) {\n-        return -1;\n-    }\n-    return 0;\n-}\n-\n-\/**\n- * Read \/proc\/<pid>\/psinfo and return the ppid, total cputime and start time.\n- * Return: -1 is fail;  >=  0 is parent pid\n- * 'total' will contain the running time of 'pid' in nanoseconds.\n- * 'start' will contain the start time of 'pid' in milliseconds since epoch.\n- *\/\n-pid_t unix_getParentPidAndTimings(JNIEnv *env, pid_t pid,\n-                                  jlong *totalTime, jlong* startTime) {\n-    psinfo_t psinfo;\n-\n-    if (getPsinfo(pid, &psinfo) < 0) {\n-        return -1;\n-    }\n-\n-    \/\/ Validate the pid before returning the info\n-    if (kill(pid, 0) < 0) {\n-        return -1;\n-    }\n-\n-    *totalTime = psinfo.pr_time.tv_sec * 1000000000L + psinfo.pr_time.tv_nsec;\n-\n-    *startTime = psinfo.pr_start.tv_sec * (jlong)1000 +\n-                 psinfo.pr_start.tv_nsec \/ 1000000;\n-\n-    return (pid_t) psinfo.pr_ppid;\n-}\n-\n-void unix_getCmdlineAndUserInfo(JNIEnv *env, jobject jinfo, pid_t pid) {\n-    psinfo_t psinfo;\n-    char prargs[PRARGSZ + 1];\n-    jstring cmdexe = NULL;\n-\n-    \/*\n-     * Now try to open \/proc\/%d\/psinfo\n-     *\/\n-    if (getPsinfo(pid, &psinfo) < 0) {\n-        unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe, NULL);\n-        return;\n-    }\n-\n-    unix_getUserInfo(env, jinfo, psinfo.pr_uid);\n-\n-    \/*\n-     * Now read psinfo.pr_psargs which contains the first PRARGSZ characters of the\n-     * argument list (i.e. arg[0] arg[1] ...). Unfortunately, PRARGSZ is usually set\n-     * to 80 characters only. Nevertheless it's better than nothing :)\n-     *\/\n-    strncpy(prargs, psinfo.pr_psargs, PRARGSZ);\n-    prargs[PRARGSZ] = '\\0';\n-    if (prargs[0] == '\\0') {\n-        \/* If psinfo.pr_psargs didn't contain any strings, use psinfo.pr_fname\n-         * (which only contains the last component of exec()ed pathname) as a\n-         * last resort. This is true for AIX kernel processes for example.\n-         *\/\n-        strncpy(prargs, psinfo.pr_fname, PRARGSZ);\n-        prargs[PRARGSZ] = '\\0';\n-    }\n-    unix_fillArgArray(env, jinfo, 0, NULL, NULL, cmdexe,\n-                      prargs[0] == '\\0' ? NULL : prargs);\n-}\n-\n-#endif \/\/ defined(_AIX)\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":1,"deletions":106,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-extern pid_t unix_getParentPidAndTimings(JNIEnv *env, pid_t pid,\n-                                         jlong *total, jlong *start);\n@@ -64,1 +62,0 @@\n-extern void unix_getCmdlineAndUserInfo(JNIEnv *env, jobject jinfo, pid_t pid);\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}