{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-\n+#include <dirent.h>\n@@ -63,0 +63,18 @@\n+\/*\n+ * Return pids of active processes, and optionally parent pids and\n+ * start times for each process.\n+ * For a specific non-zero pid, only the direct children are returned.\n+ * If the pid is zero, all active processes are returned.\n+ * Reads \/proc and accumulates any process following the rules above.\n+ * The resulting pids are stored into an array of longs named jarray.\n+ * The number of pids is returned if they all fit.\n+ * If the parentArray is non-null, store also the parent pid.\n+ * In this case the parentArray must have the same length as the result pid array.\n+ * Of course in the case of a given non-zero pid all entries in the parentArray\n+ * will contain this pid, so this array does only make sense in the case of a given\n+ * zero pid.\n+ * If the jstimesArray is non-null, store also the start time of the pid.\n+ * In this case the jstimesArray must have the same length as the result pid array.\n+ * If the array(s) (is|are) too short, excess pids are not stored and\n+ * the desired length is returned.\n+ *\/\n@@ -65,1 +83,105 @@\n-    return unix_getChildren(env, jpid, jarray, jparentArray, jstimesArray);\n+    DIR* dir;\n+    struct dirent* ptr;\n+    pid_t pid = (pid_t) jpid;\n+    jlong* pids = NULL;\n+    jlong* ppids = NULL;\n+    jlong* stimes = NULL;\n+    jsize parentArraySize = 0;\n+    jsize arraySize = 0;\n+    jsize stimesSize = 0;\n+    jsize count = 0;\n+\n+    arraySize = (*env)->GetArrayLength(env, jarray);\n+    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+    if (jparentArray != NULL) {\n+        parentArraySize = (*env)->GetArrayLength(env, jparentArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != parentArraySize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+    if (jstimesArray != NULL) {\n+        stimesSize = (*env)->GetArrayLength(env, jstimesArray);\n+        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n+\n+        if (arraySize != stimesSize) {\n+            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * To locate the children we scan \/proc looking for files that have a\n+     * position integer as a filename.\n+     *\/\n+    if ((dir = opendir(\"\/proc\")) == NULL) {\n+        JNU_ThrowByNameWithMessageAndLastError(env,\n+            \"java\/lang\/RuntimeException\", \"Unable to open \/proc\");\n+        return -1;\n+    }\n+\n+    do { \/\/ Block to break out of on Exception\n+        pids = (*env)->GetLongArrayElements(env, jarray, NULL);\n+        if (pids == NULL) {\n+            break;\n+        }\n+        if (jparentArray != NULL) {\n+            ppids  = (*env)->GetLongArrayElements(env, jparentArray, NULL);\n+            if (ppids == NULL) {\n+                break;\n+            }\n+        }\n+        if (jstimesArray != NULL) {\n+            stimes  = (*env)->GetLongArrayElements(env, jstimesArray, NULL);\n+            if (stimes == NULL) {\n+                break;\n+            }\n+        }\n+\n+        while ((ptr = readdir(dir)) != NULL) {\n+            pid_t ppid = 0;\n+            jlong totalTime = 0L;\n+            jlong startTime = 0L;\n+\n+            \/* skip files that aren't numbers *\/\n+            pid_t childpid = (pid_t) atoi(ptr->d_name);\n+            if ((int) childpid <= 0) {\n+                continue;\n+            }\n+\n+            \/\/ Get the parent pid, and start time\n+            ppid = os_getParentPidAndTimings(env, childpid, &totalTime, &startTime);\n+            if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n+                if (count < arraySize) {\n+                    \/\/ Only store if it fits\n+                    pids[count] = (jlong) childpid;\n+\n+                    if (ppids != NULL) {\n+                        \/\/ Store the parentPid\n+                        ppids[count] = (jlong) ppid;\n+                    }\n+                    if (stimes != NULL) {\n+                        \/\/ Store the process start time\n+                        stimes[count] = startTime;\n+                    }\n+                }\n+                count++; \/\/ Count to tabulate size needed\n+            }\n+        }\n+    } while (0);\n+\n+    if (pids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jarray, pids, 0);\n+    }\n+    if (ppids != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jparentArray, ppids, 0);\n+    }\n+    if (stimes != NULL) {\n+        (*env)->ReleaseLongArrayElements(env, jstimesArray, stimes, 0);\n+    }\n+\n+    closedir(dir);\n+    \/\/ If more pids than array had size for; count will be greater than array size\n+    return count;\n","filename":"src\/java.base\/linux\/native\/libjava\/ProcessHandleImpl_linux.c","additions":125,"deletions":3,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n- * The currently supported Unix variants are Solaris, Linux, MaxOS X and AIX.\n+ * The currently supported Unix variants are Linux, MaxOS X and AIX.\n@@ -457,135 +457,0 @@\n-\/*\n- * The following functions are for Linux\n- *\/\n-\n-#if defined (__linux__)\n-\n-\/*\n- * Return pids of active processes, and optionally parent pids and\n- * start times for each process.\n- * For a specific non-zero pid, only the direct children are returned.\n- * If the pid is zero, all active processes are returned.\n- * Reads \/proc and accumulates any process following the rules above.\n- * The resulting pids are stored into an array of longs named jarray.\n- * The number of pids is returned if they all fit.\n- * If the parentArray is non-null, store also the parent pid.\n- * In this case the parentArray must have the same length as the result pid array.\n- * Of course in the case of a given non-zero pid all entries in the parentArray\n- * will contain this pid, so this array does only make sense in the case of a given\n- * zero pid.\n- * If the jstimesArray is non-null, store also the start time of the pid.\n- * In this case the jstimesArray must have the same length as the result pid array.\n- * If the array(s) (is|are) too short, excess pids are not stored and\n- * the desired length is returned.\n- *\/\n-jint unix_getChildren(JNIEnv *env, jlong jpid, jlongArray jarray,\n-                      jlongArray jparentArray, jlongArray jstimesArray) {\n-    DIR* dir;\n-    struct dirent* ptr;\n-    pid_t pid = (pid_t) jpid;\n-    jlong* pids = NULL;\n-    jlong* ppids = NULL;\n-    jlong* stimes = NULL;\n-    jsize parentArraySize = 0;\n-    jsize arraySize = 0;\n-    jsize stimesSize = 0;\n-    jsize count = 0;\n-\n-    arraySize = (*env)->GetArrayLength(env, jarray);\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    if (jparentArray != NULL) {\n-        parentArraySize = (*env)->GetArrayLength(env, jparentArray);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-\n-        if (arraySize != parentArraySize) {\n-            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n-            return 0;\n-        }\n-    }\n-    if (jstimesArray != NULL) {\n-        stimesSize = (*env)->GetArrayLength(env, jstimesArray);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-\n-        if (arraySize != stimesSize) {\n-            JNU_ThrowIllegalArgumentException(env, \"array sizes not equal\");\n-            return 0;\n-        }\n-    }\n-\n-    \/*\n-     * To locate the children we scan \/proc looking for files that have a\n-     * position integer as a filename.\n-     *\/\n-    if ((dir = opendir(\"\/proc\")) == NULL) {\n-        JNU_ThrowByNameWithMessageAndLastError(env,\n-            \"java\/lang\/RuntimeException\", \"Unable to open \/proc\");\n-        return -1;\n-    }\n-\n-    do { \/\/ Block to break out of on Exception\n-        pids = (*env)->GetLongArrayElements(env, jarray, NULL);\n-        if (pids == NULL) {\n-            break;\n-        }\n-        if (jparentArray != NULL) {\n-            ppids  = (*env)->GetLongArrayElements(env, jparentArray, NULL);\n-            if (ppids == NULL) {\n-                break;\n-            }\n-        }\n-        if (jstimesArray != NULL) {\n-            stimes  = (*env)->GetLongArrayElements(env, jstimesArray, NULL);\n-            if (stimes == NULL) {\n-                break;\n-            }\n-        }\n-\n-        while ((ptr = readdir(dir)) != NULL) {\n-            pid_t ppid = 0;\n-            jlong totalTime = 0L;\n-            jlong startTime = 0L;\n-\n-            \/* skip files that aren't numbers *\/\n-            pid_t childpid = (pid_t) atoi(ptr->d_name);\n-            if ((int) childpid <= 0) {\n-                continue;\n-            }\n-\n-            \/\/ Get the parent pid, and start time\n-            ppid = os_getParentPidAndTimings(env, childpid, &totalTime, &startTime);\n-            if (ppid >= 0 && (pid == 0 || ppid == pid)) {\n-                if (count < arraySize) {\n-                    \/\/ Only store if it fits\n-                    pids[count] = (jlong) childpid;\n-\n-                    if (ppids != NULL) {\n-                        \/\/ Store the parentPid\n-                        ppids[count] = (jlong) ppid;\n-                    }\n-                    if (stimes != NULL) {\n-                        \/\/ Store the process start time\n-                        stimes[count] = startTime;\n-                    }\n-                }\n-                count++; \/\/ Count to tabulate size needed\n-            }\n-        }\n-    } while (0);\n-\n-    if (pids != NULL) {\n-        (*env)->ReleaseLongArrayElements(env, jarray, pids, 0);\n-    }\n-    if (ppids != NULL) {\n-        (*env)->ReleaseLongArrayElements(env, jparentArray, ppids, 0);\n-    }\n-    if (stimes != NULL) {\n-        (*env)->ReleaseLongArrayElements(env, jstimesArray, stimes, 0);\n-    }\n-\n-    closedir(dir);\n-    \/\/ If more pids than array had size for; count will be greater than array size\n-    return count;\n-}\n-\n-#endif \/\/ defined (__linux__)\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":2,"deletions":137,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,0 @@\n-extern jint unix_getChildren(JNIEnv *env, jlong jpid, jlongArray array,\n-                             jlongArray jparentArray, jlongArray jstimesArray);\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}