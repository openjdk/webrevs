{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import sun.security.ssl.SSLCipher.SSLWriteCipher;\n-\n@@ -149,4 +147,0 @@\n-\n-                    \/\/ Switch server to use plaintext.\n-                    context.handshakeContext.conContext.outputRecord.changeWriteCiphers(\n-                            SSLWriteCipher.nullTlsWriteCipher(), false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n@@ -593,1 +592,5 @@\n-        closeNotify(!isNegotiated && handshakeContext != null);\n+        \/\/ initial handshake\n+        boolean useUserCanceled = !isNegotiated &&\n+                (handshakeContext != null) && !peerUserCanceled;\n+\n+        closeNotify(useUserCanceled);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,4 +57,0 @@\n- * Note, this is a *very* simple example: real code will be much more\n- * involved.  For example, different threading and I\/O models could be\n- * used, transport mechanisms could close unexpectedly, and so on.\n- * <p>\n@@ -96,1 +92,2 @@\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+        \/\/ Make it larger so subsequent server wraps won't generate BUFFER_OVERFLOWS\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax + 1000);\n@@ -166,1 +163,1 @@\n-        sTOc.clear();  \/\/ SH packet went missing.  Timeout on Client.\n+        \/\/ SH packet went missing.  Timeout on Client.\n@@ -174,1 +171,1 @@\n-        sTOc.clear();  \/\/ CCS packet went missing.  Timeout on Client.\n+        \/\/ CCS packet went missing.  Timeout on Client.\n@@ -182,1 +179,1 @@\n-        sTOc.clear();  \/\/ EE\/etc. packet went missing.  Timeout on Client.\n+        \/\/ EE\/etc. packet went missing.  Timeout on Client.\n@@ -195,0 +192,1 @@\n+        inspectTlsFlight(cTOs);\n@@ -196,1 +194,1 @@\n-        \/\/ Server unwrap should process an unencrypted 2 byte packet,\n+        \/\/ Server unwrap should process an unencrypted 2 byte packet user_cancelled alert.\n@@ -202,1 +200,1 @@\n-        cTOs.clear();\n+        cTOs.compact();\n@@ -213,0 +211,1 @@\n+        inspectTlsFlight(cTOs);\n@@ -222,5 +221,0 @@\n-        log(\"---Server Wrap user_cancelled---\");\n-        serverResult = serverEngine.wrap(serverOut, sTOc);\n-        logEngineStatus(serverEngine, serverResult);\n-        runDelegatedTasks(serverEngine);\n-\n@@ -228,0 +222,2 @@\n+\n+        \/\/ Client receives delayed serverHello\n@@ -230,1 +226,1 @@\n-        log(\"---Client Unwrap user_cancelled alert---\");\n+        log(\"---Client Unwrap serverHello---\");\n@@ -235,1 +231,2 @@\n-        sTOc.clear();\n+        \/\/ Client receives delayed CCS\n+        inspectTlsFlight(sTOc);\n@@ -237,1 +234,18 @@\n-        log(\"---Server Wrap close_notify---\");\n+        log(\"---Client Unwrap CCS---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        \/\/ Client receives delayed EE\n+        inspectTlsFlight(sTOc);\n+\n+        log(\"---Client Unwrap EE---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        sTOc.compact();\n+\n+        \/\/ Only a stand-alone user_cancelled alert is needed in server -> client direction to terminate the handshake\n+        \/\/ after the server already received user_cancelled:close_notify sequence from the client.\n+        log(\"---Server Wrap user_cancelled---\");\n@@ -247,1 +261,1 @@\n-        log(\"---Client Unwrap close_notify alert---\");\n+        log(\"---Client Unwrap user_cancelled alert---\");\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLEngineNoServerHelloClientShutdown.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"}]}