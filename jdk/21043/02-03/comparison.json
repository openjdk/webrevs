{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import sun.security.ssl.SSLCipher.SSLWriteCipher;\n+\n@@ -126,2 +128,5 @@\n-            \/\/ Check for unexpected plaintext alert message during TLSv1.3 handshake, @bug 8331682\n-            if (srcsLength == 1 && !context.isNegotiated && context.handshakeContext != null &&\n+            \/\/ Check for unexpected plaintext alert message during TLSv1.3 handshake.\n+            \/\/ This can happen if client doesn't receive ServerHello due to network timeout\n+            \/\/ and tries to close the connection by sending an alert message.\n+            if (srcsLength == 1 && !context.sslConfig.isClientMode && !context.isNegotiated &&\n+                    context.handshakeContext != null &&\n@@ -131,4 +136,4 @@\n-                byte contentType = packet.get();                   \/\/ pos: 0\n-                byte majorVersion = packet.get();                  \/\/ pos: 1\n-                byte minorVersion = packet.get();                  \/\/ pos: 2\n-                int contentLen = Record.getInt16(packet);          \/\/ pos: 3, 4\n+                byte contentType = (byte) Record.getInt8(packet);                   \/\/ pos: 0\n+                byte majorVersion = (byte) Record.getInt8(packet);                  \/\/ pos: 1\n+                byte minorVersion = (byte) Record.getInt8(packet);                  \/\/ pos: 2\n+                int contentLen = Record.getInt16(packet);                           \/\/ pos: 3, 4\n@@ -137,0 +142,4 @@\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        SSLLogger.finest(\"Processing plaintext alert during TLSv1.3 handshake\");\n+                    }\n+\n@@ -140,0 +149,4 @@\n+\n+                    \/\/ Switch server to use plaintext.\n+                    context.handshakeContext.conContext.outputRecord.changeWriteCiphers(\n+                            SSLWriteCipher.nullTlsWriteCipher(), false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+\n@@ -592,5 +593,1 @@\n-        \/\/ initial handshake\n-        boolean useUserCanceled = !isNegotiated &&\n-                (handshakeContext != null) && !peerUserCanceled;\n-\n-        closeNotify(useUserCanceled);\n+        closeNotify(!isNegotiated && handshakeContext != null);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import static jdk.test.lib.Utils.inspectTlsFlight;\n@@ -73,3 +74,0 @@\n-    \/\/ For data transport, this example uses local ByteBuffers.  This\n-    \/\/ isn't really useful, but the purpose of this example is to show\n-    \/\/ SSLEngine concepts, not how to do network transport.\n@@ -86,2 +84,1 @@\n-        \/\/ We'll assume the buffer sizes are the same\n-        \/\/ between client and server.\n+        \/\/ We'll assume the buffer sizes are the same between client and server.\n@@ -95,4 +92,0 @@\n-        \/\/\n-        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n-        \/\/ tutorial purposes only.  In reality, only use direct\n-        \/\/ ByteBuffers when they give a clear performance enhancement.\n@@ -113,4 +106,0 @@\n-    \/\/\n-    \/\/ Protected methods could be used to customize the test case.\n-    \/\/\n-\n@@ -219,0 +208,1 @@\n+        assertTrue(clientEngine.isOutboundDone());\n@@ -232,1 +222,1 @@\n-        log(\"---Last Server Wrap ---\");\n+        log(\"---Server Wrap user_cancelled---\");\n@@ -235,1 +225,0 @@\n-        assertTrue(serverEngine.isOutboundDone());\n@@ -238,2 +227,16 @@\n-        \/* TODO: Final client unwrap fails because server doesn't send an alert to terminate\n-           the handshake after receiving close_notify alert from the client. Investigate why.\n+        sTOc.flip();\n+        inspectTlsFlight(sTOc);\n+\n+        log(\"---Client Unwrap user_cancelled alert---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        sTOc.clear();\n+\n+        log(\"---Server Wrap close_notify---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        assertTrue(serverEngine.isOutboundDone());\n+        assertTrue(serverEngine.isInboundDone());\n+        runDelegatedTasks(serverEngine);\n@@ -242,0 +245,1 @@\n+        inspectTlsFlight(sTOc);\n@@ -243,1 +247,1 @@\n-        log(\"---Last Client Unwrap---\");\n+        log(\"---Client Unwrap close_notify alert---\");\n@@ -246,0 +250,2 @@\n+        assertTrue(clientEngine.isOutboundDone());\n+        assertTrue(clientEngine.isInboundDone());\n@@ -247,1 +253,0 @@\n-        *\/\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLEngineNoServerHelloClientShutdown.java","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -26,0 +26,5 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -41,0 +46,1 @@\n+import java.nio.channels.SocketChannel;\n@@ -50,1 +56,0 @@\n-import java.nio.channels.SocketChannel;\n@@ -58,0 +63,1 @@\n+import java.util.HashMap;\n@@ -60,2 +66,0 @@\n-import java.util.Map;\n-import java.util.HashMap;\n@@ -64,0 +68,1 @@\n+import java.util.Map;\n@@ -66,1 +71,0 @@\n-import java.util.function.BooleanSupplier;\n@@ -68,0 +72,1 @@\n+import java.util.function.BooleanSupplier;\n@@ -74,4 +79,0 @@\n-import static jdk.test.lib.Asserts.assertTrue;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n@@ -1053,0 +1054,23 @@\n+\n+    public static void inspectTlsFlight(ByteBuffer flight) throws IOException {\n+        ByteBuffer packet = flight.slice();\n+\n+        System.err.println(\"---TLS Flight Inspection---\");\n+\n+        if (packet.position() < packet.limit()) {\n+            byte contentType = packet.get();                   \/\/ pos: 0\n+            byte majorVersion = packet.get();                  \/\/ pos: 1\n+            byte minorVersion = packet.get();                  \/\/ pos: 2\n+            int contentLen = getInt16(packet);                 \/\/ pos: 3, 4\n+\n+            System.err.println(\"\\tcontentType: \" + (int) contentType);\n+            System.err.println(\"\\tmajorVersion: \" + (int) majorVersion);\n+            System.err.println(\"\\tminorVersion: \" + (int) minorVersion);\n+            System.err.println(\"\\tcontentLen: \" + contentLen);\n+        }\n+    }\n+\n+    public static int getInt16(ByteBuffer m) throws IOException {\n+        return ((m.get() & 0xFF) << 8) |\n+                (m.get() & 0xFF);\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"}]}