{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+\n@@ -108,1 +109,2 @@\n-        Plaintext[] plaintexts;\n+        Plaintext[] plaintexts = null;\n+\n@@ -110,2 +112,1 @@\n-            plaintexts =\n-                    context.inputRecord.decode(srcs, srcsOffset, srcsLength);\n+            plaintexts = context.inputRecord.decode(srcs, srcsOffset, srcsLength);\n@@ -125,10 +126,29 @@\n-            \/*\n-             * The basic SSLv3 record protection involves (optional)\n-             * encryption for privacy, and an integrity check ensuring\n-             * data origin authentication.  We do them both here, and\n-             * throw a fatal alert if the integrity check fails.\n-             *\/\n-             Alert alert = (context.handshakeContext != null) ?\n-                     Alert.HANDSHAKE_FAILURE :\n-                     Alert.BAD_RECORD_MAC;\n-            throw context.fatal(alert, bpe);\n+            \/\/ Check for unexpected plaintext alert message during TLSv1.3 handshake, @bug 8331682\n+            if (srcsLength == 1 && !context.isNegotiated && context.handshakeContext != null &&\n+                    ProtocolVersion.TLS13.equals(context.handshakeContext.negotiatedProtocol)) {\n+                ByteBuffer packet = srcs[srcsOffset].duplicate();\n+                packet.position(0);\n+                byte contentType = packet.get();                   \/\/ pos: 0\n+                byte majorVersion = packet.get();                  \/\/ pos: 1\n+                byte minorVersion = packet.get();                  \/\/ pos: 2\n+                int contentLen = Record.getInt16(packet);          \/\/ pos: 3, 4\n+\n+                if (contentLen == 2 && ContentType.ALERT.equals(ContentType.valueOf(contentType))) {\n+                    plaintexts = new Plaintext[]{\n+                            new Plaintext(contentType, majorVersion, minorVersion, -1, -1L, packet)\n+                    };\n+                }\n+            }\n+\n+            if (plaintexts == null) {\n+                \/*\n+                 * The basic SSLv3 record protection involves (optional)\n+                 * encryption for privacy, and an integrity check ensuring\n+                 * data origin authentication.  We do them both here, and\n+                 * throw a fatal alert if the integrity check fails.\n+                 *\/\n+                Alert alert = (context.handshakeContext != null) ?\n+                        Alert.HANDSHAKE_FAILURE :\n+                        Alert.BAD_RECORD_MAC;\n+                throw context.fatal(alert, bpe);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8331682\n+ * @summary Slow networks\/Impatient clients can potentially send\n+ *          unencrypted TLSv1.3 alerts that won't parse on the server.\n+ * @library \/javax\/net\/ssl\/templates\n+ * @library \/test\/lib\n+ * @run main\/othervm SSLEngineNoServerHelloClientShutdown\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.nio.ByteBuffer;\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLEngineResult.Status;\n+import javax.net.ssl.SSLSession;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ * <p>\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ * <p>\n+ * Note, this is a *very* simple example: real code will be much more\n+ * involved.  For example, different threading and I\/O models could be\n+ * used, transport mechanisms could close unexpectedly, and so on.\n+ * <p>\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class SSLEngineNoServerHelloClientShutdown extends SSLContextTemplate {\n+    protected final SSLEngine clientEngine;     \/\/ client Engine\n+    protected final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    protected final SSLEngine serverEngine;     \/\/ server Engine\n+    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    \/\/ For data transport, this example uses local ByteBuffers.  This\n+    \/\/ isn't really useful, but the purpose of this example is to show\n+    \/\/ SSLEngine concepts, not how to do network transport.\n+    protected final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    protected SSLEngineNoServerHelloClientShutdown() throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine());\n+\n+        \/\/ We'll assume the buffer sizes are the same\n+        \/\/ between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        \/\/\n+        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n+        \/\/ tutorial purposes only.  In reality, only use direct\n+        \/\/ ByteBuffers when they give a clear performance enhancement.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = createClientOutputBuffer();\n+        serverOut = createServerOutputBuffer();\n+    }\n+\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    \/\/\n+    \/\/ Protected methods could be used to customize the test case.\n+    \/\/\n+\n+    protected ByteBuffer createClientOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n+    \/*\n+     * Configure the client side engine.\n+     *\/\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] {\"TLSv1.3\"});\n+        return clientEngine;\n+    }\n+\n+    \/*\n+     * Configure the server side engine.\n+     *\/\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+        return serverEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new SSLEngineNoServerHelloClientShutdown().runTestUserCancelled();\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTestUserCancelled() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        log(\"=================\");\n+\n+        \/\/ client wrap\n+        \/\/ produce client_hello\n+        log(\"---Client Wrap client_hello---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+\n+        \/\/ server unwrap\n+        \/\/ Consume client_hello\n+        log(\"---Server Unwrap client_hello---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+\n+        cTOs.compact();\n+\n+        \/\/ server wrap\n+        \/\/ produce server_hello\n+        log(\"---Server Wrap server_hello---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        sTOc.clear();  \/\/ SH packet went missing.  Timeout on Client.\n+\n+        \/\/ server wrap\n+        \/\/ produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        sTOc.clear();  \/\/ CCS packet went missing.  Timeout on Client.\n+\n+        \/\/ server wrap\n+        \/\/ produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        sTOc.clear();  \/\/ EE\/etc. packet went missing.  Timeout on Client.\n+\n+        \/\/ *Yawn*  No response.  Shutdown client\n+        log(\"---Client closeOutbound---\");\n+        clientEngine.closeOutbound();\n+\n+        \/\/ Sends an unencrypted user_cancelled\n+        log(\"---Client Wrap user_cancelled---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+\n+        \/\/ Server unwrap should process an unencrypted 2 byte packet,\n+        log(\"---Server Unwrap user_cancelled alert---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+\n+        cTOs.clear();\n+\n+        \/\/ Sends an unencrypted close_notify\n+        log(\"---Client Wrap close_notify---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        assertEquals(clientResult.getStatus(), Status.CLOSED);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+\n+        \/\/ Server unwrap should process an unencrypted 2 byte close_notify alert.\n+        log(\"---Server Unwrap close_notify alert---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        assertTrue(serverEngine.isInboundDone());\n+        assertEquals(serverResult.getStatus(), Status.CLOSED);\n+        runDelegatedTasks(serverEngine);\n+\n+        log(\"---Last Server Wrap ---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        assertTrue(serverEngine.isOutboundDone());\n+        runDelegatedTasks(serverEngine);\n+\n+        \/* TODO: Final client unwrap fails because server doesn't send an alert to terminate\n+           the handshake after receiving close_notify alert from the client. Investigate why.\n+\n+        sTOc.flip();\n+\n+        log(\"---Last Client Unwrap---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+        *\/\n+    }\n+\n+    private static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    private static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+\n+    \/\/ Simple check to make sure everything came across as expected.\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+            throws Exception {\n+        a.flip();\n+        b.flip();\n+\n+        if (!a.equals(b)) {\n+            throw new Exception(\"Data didn't transfer cleanly\");\n+        } else {\n+            log(\"\\tData transferred cleanly\");\n+        }\n+\n+        a.position(a.limit());\n+        b.position(b.limit());\n+        a.limit(a.capacity());\n+        b.limit(b.capacity());\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLEngineNoServerHelloClientShutdown.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"}]}