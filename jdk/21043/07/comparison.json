{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+\n@@ -108,1 +109,2 @@\n-        Plaintext[] plaintexts;\n+        Plaintext[] plaintexts = null;\n+\n@@ -110,2 +112,1 @@\n-            plaintexts =\n-                    context.inputRecord.decode(srcs, srcsOffset, srcsLength);\n+            plaintexts = context.inputRecord.decode(srcs, srcsOffset, srcsLength);\n@@ -125,10 +126,36 @@\n-            \/*\n-             * The basic SSLv3 record protection involves (optional)\n-             * encryption for privacy, and an integrity check ensuring\n-             * data origin authentication.  We do them both here, and\n-             * throw a fatal alert if the integrity check fails.\n-             *\/\n-             Alert alert = (context.handshakeContext != null) ?\n-                     Alert.HANDSHAKE_FAILURE :\n-                     Alert.BAD_RECORD_MAC;\n-            throw context.fatal(alert, bpe);\n+            \/\/ Check for unexpected plaintext alert message during TLSv1.3 handshake.\n+            \/\/ This can happen if client doesn't receive ServerHello due to network timeout\n+            \/\/ and tries to close the connection by sending an alert message.\n+            if (srcsLength == 1 && !context.sslConfig.isClientMode && !context.isNegotiated &&\n+                    context.handshakeContext != null &&\n+                    ProtocolVersion.TLS13.equals(context.handshakeContext.negotiatedProtocol)) {\n+                ByteBuffer packet = srcs[srcsOffset].duplicate();\n+                packet.position(0);\n+                byte contentType = (byte) Record.getInt8(packet);                   \/\/ pos: 0\n+                byte majorVersion = (byte) Record.getInt8(packet);                  \/\/ pos: 1\n+                byte minorVersion = (byte) Record.getInt8(packet);                  \/\/ pos: 2\n+                int contentLen = Record.getInt16(packet);                           \/\/ pos: 3, 4\n+\n+                if (contentLen == 2 && ContentType.ALERT.equals(ContentType.valueOf(contentType))) {\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        SSLLogger.finest(\"Processing plaintext alert during TLSv1.3 handshake\");\n+                    }\n+\n+                    plaintexts = new Plaintext[]{\n+                            new Plaintext(contentType, majorVersion, minorVersion, -1, -1L, packet)\n+                    };\n+                }\n+            }\n+\n+            if (plaintexts == null) {\n+                \/*\n+                 * The basic SSLv3 record protection involves (optional)\n+                 * encryption for privacy, and an integrity check ensuring\n+                 * data origin authentication.  We do them both here, and\n+                 * throw a fatal alert if the integrity check fails.\n+                 *\/\n+                Alert alert = (context.handshakeContext != null) ?\n+                        Alert.HANDSHAKE_FAILURE :\n+                        Alert.BAD_RECORD_MAC;\n+                throw context.fatal(alert, bpe);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":41,"deletions":14,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8331682\n+ * @summary Slow networks\/Impatient clients can potentially send\n+ *          unencrypted TLSv1.3 alerts that won't parse on the server.\n+ * @library \/javax\/net\/ssl\/templates\n+ * @library \/test\/lib\n+ * @run main\/othervm SSLEngineNoServerHelloClientShutdown\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.security.SecurityUtils.inspectTlsFlight;\n+\n+import java.nio.ByteBuffer;\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLEngineResult.Status;\n+import javax.net.ssl.SSLSession;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ * <p>\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ * <p>\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class SSLEngineNoServerHelloClientShutdown extends SSLContextTemplate {\n+    protected final SSLEngine clientEngine;     \/\/ client Engine\n+    protected final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    protected final SSLEngine serverEngine;     \/\/ server Engine\n+    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    protected final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    protected SSLEngineNoServerHelloClientShutdown() throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine());\n+\n+        \/\/ We'll assume the buffer sizes are the same between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        \/\/ Make it larger so subsequent server wraps won't generate BUFFER_OVERFLOWS\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax + 1000);\n+\n+        clientOut = createClientOutputBuffer();\n+        serverOut = createServerOutputBuffer();\n+    }\n+\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    protected ByteBuffer createClientOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n+    \/*\n+     * Configure the client side engine.\n+     *\/\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] {\"TLSv1.3\"});\n+        return clientEngine;\n+    }\n+\n+    \/*\n+     * Configure the server side engine.\n+     *\/\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+        return serverEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new SSLEngineNoServerHelloClientShutdown().runTestUserCancelled();\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTestUserCancelled() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        log(\"=================\");\n+\n+        \/\/ client wrap\n+        \/\/ produce client_hello\n+        log(\"---Client Wrap client_hello---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+\n+        \/\/ server unwrap\n+        \/\/ Consume client_hello\n+        log(\"---Server Unwrap client_hello---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+\n+        cTOs.compact();\n+\n+        \/\/ server wrap\n+        \/\/ produce server_hello\n+        log(\"---Server Wrap server_hello---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ SH packet went missing.  Timeout on Client.\n+\n+        \/\/ server wrap\n+        \/\/ produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ CCS packet went missing.  Timeout on Client.\n+\n+        \/\/ server wrap\n+        \/\/ produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ EE\/etc. packet went missing.  Timeout on Client.\n+\n+        \/\/ *Yawn*  No response.  Shutdown client\n+        log(\"---Client closeOutbound---\");\n+        clientEngine.closeOutbound();\n+\n+        \/\/ Sends an unencrypted user_canceled\n+        log(\"---Client Wrap user_canceled---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+        inspectTlsFlight(cTOs);\n+\n+        \/\/ Server unwrap should process an unencrypted 2 byte packet user_canceled alert.\n+        log(\"---Server Unwrap user_canceled alert---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+\n+        cTOs.compact();\n+\n+        \/\/ Sends an unencrypted close_notify\n+        log(\"---Client Wrap close_notify---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        assertTrue(clientEngine.isOutboundDone());\n+        assertEquals(clientResult.getStatus(), Status.CLOSED);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+        inspectTlsFlight(cTOs);\n+\n+        \/\/ Server unwrap should process an unencrypted 2 byte close_notify alert.\n+        log(\"---Server Unwrap close_notify alert---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        assertTrue(serverEngine.isInboundDone());\n+        assertEquals(serverResult.getStatus(), Status.CLOSED);\n+        runDelegatedTasks(serverEngine);\n+\n+        sTOc.flip();\n+\n+        \/\/ Client receives delayed serverHello\n+        inspectTlsFlight(sTOc);\n+\n+        log(\"---Client Unwrap serverHello---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        \/\/ Client receives delayed CCS\n+        inspectTlsFlight(sTOc);\n+\n+        log(\"---Client Unwrap CCS---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        \/\/ Client receives delayed EE\n+        inspectTlsFlight(sTOc);\n+\n+        log(\"---Client Unwrap EE---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        sTOc.compact();\n+\n+        \/\/ Only a stand-alone user_canceled alert is needed in server -> client direction\n+        \/\/ to terminate the handshake after the server already received user_canceled:close_notify\n+        \/\/ sequence from the client.\n+        log(\"---Server Wrap user_canceled---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        assertTrue(serverEngine.isOutboundDone());\n+        assertTrue(serverEngine.isInboundDone());\n+        runDelegatedTasks(serverEngine);\n+\n+        sTOc.flip();\n+        inspectTlsFlight(sTOc);\n+\n+        log(\"---Client Unwrap user_canceled alert---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        assertTrue(clientEngine.isOutboundDone());\n+        assertTrue(clientEngine.isInboundDone());\n+        runDelegatedTasks(clientEngine);\n+    }\n+\n+    private static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    private static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLEngineNoServerHelloClientShutdown.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n@@ -128,0 +130,22 @@\n+    public static void inspectTlsFlight(ByteBuffer flight) throws IOException {\n+        ByteBuffer packet = flight.slice();\n+\n+        System.err.println(\"---TLS Flight Inspection---\");\n+\n+        if (packet.position() < packet.limit()) {\n+            byte contentType = packet.get();                   \/\/ pos: 0\n+            byte majorVersion = packet.get();                  \/\/ pos: 1\n+            byte minorVersion = packet.get();                  \/\/ pos: 2\n+            int contentLen = getInt16(packet);                 \/\/ pos: 3, 4\n+\n+            System.err.println(\"\\tcontentType: \" + (int) contentType);\n+            System.err.println(\"\\tmajorVersion: \" + (int) majorVersion);\n+            System.err.println(\"\\tminorVersion: \" + (int) minorVersion);\n+            System.err.println(\"\\tcontentLen: \" + contentLen);\n+        }\n+    }\n+\n+    public static int getInt16(ByteBuffer m) throws IOException {\n+        return ((m.get() & 0xFF) << 8) | (m.get() & 0xFF);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SecurityUtils.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}