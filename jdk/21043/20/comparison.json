{"files":[{"patch":"@@ -1862,2 +1862,1 @@\n-                    throw new BadPaddingException(\n-                        \"Insufficient buffer remaining for AEAD cipher \" +\n+                    String msg = \"Insufficient buffer remaining for AEAD cipher \" +\n@@ -1865,1 +1864,15 @@\n-                        \"more than tag size (\" + tagSize + \")\");\n+                        \"more than tag size (\" + tagSize + \")\";\n+\n+                    \/\/ Check for unexpected plaintext alert.\n+                    if (ContentType.ALERT.equals(ContentType.valueOf(contentType))) {\n+                        msg = \"Unexpected plaintext alert received. This can happen\"\n+                            + \" during TLSv1.3 handshake if client doesn't receive\"\n+                            + \" server_hello due to network timeout and tries to\"\n+                            + \" close a connection by sending an alert message.\";\n+\n+                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                            SSLLogger.info(msg);\n+                        }\n+                    }\n+\n+                    throw new BadPaddingException(msg);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8331682\n+ * @summary Slow networks\/Impatient clients can potentially send\n+ *          unencrypted TLSv1.3 alerts that won't parse on the server.\n+ * @library \/javax\/net\/ssl\/templates \/test\/lib\n+ * @run main\/othervm SSLEngineNoServerHelloClientShutdown\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.fail;\n+import static jdk.test.lib.security.SecurityUtils.inspectTlsBuffer;\n+\n+import java.nio.ByteBuffer;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSession;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ * <p>\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ * <p>\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class SSLEngineNoServerHelloClientShutdown extends SSLContextTemplate {\n+\n+    protected static final String EXCEPTION_MSG =\n+        \"Unexpected plaintext alert received. This can happen\"\n+            + \" during TLSv1.3 handshake if client doesn't receive\"\n+            + \" server_hello due to network timeout and tries to\"\n+            + \" close a connection by sending an alert message.\";\n+\n+    protected SSLEngine clientEngine;     \/\/ client Engine\n+    protected ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    protected final SSLEngine serverEngine;     \/\/ server Engine\n+    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    protected ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    protected SSLEngineNoServerHelloClientShutdown() throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine());\n+\n+        \/\/ We'll assume the buffer sizes are the same between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax * 2);\n+        \/\/ Make it larger so subsequent server wraps won't generate BUFFER_OVERFLOWS\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax * 2);\n+\n+        clientOut = createClientOutputBuffer();\n+        serverOut = createServerOutputBuffer();\n+    }\n+\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    protected ByteBuffer createClientOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n+    \/*\n+     * Configure the client side engine.\n+     *\/\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] {\"TLSv1.3\"});\n+        return clientEngine;\n+    }\n+\n+    \/*\n+     * Configure the server side engine.\n+     *\/\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+        return serverEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new SSLEngineNoServerHelloClientShutdown().runTestUserCancelled();\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTestUserCancelled() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        log(\"=================\");\n+\n+        \/\/ Client: produce client_hello\n+        log(\"---Client Wrap client_hello---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+\n+        \/\/ Server: consume client_hello\n+        log(\"---Server Unwrap client_hello---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+\n+        cTOs.compact();\n+\n+        \/\/ Server: produce server_hello\n+        log(\"---Server Wrap server_hello---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ SH packet went missing.  Timeout on Client.\n+\n+        \/\/ Server: produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ CCS packet went missing.  Timeout on Client.\n+\n+        \/\/ Server: produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ EE\/etc. packet went missing.  Timeout on Client.\n+\n+        \/\/ Shutdown client\n+        log(\"---Client closeOutbound---\");\n+        clientEngine.closeOutbound();\n+\n+        \/\/ Client:  produce an unencrypted user_canceled\n+        log(\"---Client Wrap user_canceled---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+        inspectTlsBuffer(cTOs);\n+\n+        \/\/ Server unwrap should throw a proper exception when receiving an\n+        \/\/ unencrypted 2 byte packet user_canceled alert.\n+        log(\"---Server Unwrap user_canceled alert---\");\n+        try {\n+            serverEngine.unwrap(cTOs, serverIn);\n+        } catch (SSLHandshakeException e) {\n+            assertEquals(e.getCause().getClass(), BadPaddingException.class);\n+            assertEquals(e.getCause().getMessage(), EXCEPTION_MSG);\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    protected static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    protected static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    protected static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLCipher\/SSLEngineNoServerHelloClientShutdown.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331682\n+ * @summary Slow networks\/Impatient clients can potentially send\n+ *          unencrypted TLSv1.3 alerts that won't parse on the server.\n+ * @library \/javax\/net\/ssl\/templates \/test\/lib\n+ * @run main\/othervm SSLSocketNoServerHelloClientShutdown\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.fail;\n+import static jdk.test.lib.security.SecurityUtils.inspectTlsBuffer;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.nio.channels.SocketChannel;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.Status;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+\n+\/**\n+ * To reproduce @bug 8331682 (client sends an unencrypted TLS alert during 1.3 handshake)\n+ * with SSLSockets we use an SSLSocket on the server side and a plain TCP socket backed by\n+ * SSLEngine on the client side.\n+ *\/\n+public class SSLSocketNoServerHelloClientShutdown extends SSLEngineNoServerHelloClientShutdown {\n+\n+    private volatile Exception clientException;\n+    private volatile Exception serverException;\n+\n+    public static void main(String[] args) throws Exception {\n+        new SSLSocketNoServerHelloClientShutdown().runTest();\n+    }\n+\n+    public SSLSocketNoServerHelloClientShutdown() throws Exception {\n+        super();\n+    }\n+\n+    private void runTest() throws Exception {\n+        \/\/ Set up SSL server\n+        SSLContext context = createServerSSLContext();\n+        SSLServerSocketFactory sslssf = context.getServerSocketFactory();\n+\n+        try (SSLServerSocket serverSocket = (SSLServerSocket) sslssf.createServerSocket()) {\n+\n+            serverSocket.setReuseAddress(false);\n+            serverSocket.bind(null);\n+            int port = serverSocket.getLocalPort();\n+            log(\"Port: \" + port);\n+            Thread thread = createClientThread(port);\n+\n+            try {\n+                \/\/ Server-side SSL socket that will read.\n+                SSLSocket socket = (SSLSocket) serverSocket.accept();\n+                socket.setSoTimeout(2000);\n+                InputStream is = socket.getInputStream();\n+                byte[] inbound = new byte[512];\n+\n+                log(\"===Server is ready and reading===\");\n+                if (is.read(inbound) > 0) {\n+                    throw new Exception(\"Server returned data\");\n+                }\n+            } catch (Exception e) {\n+                serverException = e;\n+                log(e.toString());\n+            } finally {\n+                thread.join();\n+            }\n+        } finally {\n+            if (serverException != null) {\n+                assertEquals(serverException.getClass(), SSLHandshakeException.class);\n+                assertEquals(serverException.getCause().getClass(), BadPaddingException.class);\n+                assertEquals(serverException.getCause().getMessage(), EXCEPTION_MSG);\n+            } else {\n+                fail(\"Server should have thrown SSLHandshakeException\");\n+            }\n+            if (clientException != null) {\n+                throw clientException;\n+            }\n+        }\n+    }\n+\n+    private Thread createClientThread(final int port) {\n+\n+        Thread t = new Thread(\"ClientThread\") {\n+            @Override\n+            public void run() {\n+                \/\/ Client-side plain TCP socket.\n+                try (SocketChannel clientSocketChannel = SocketChannel.open(\n+                        new InetSocketAddress(\"localhost\", port))) {\n+\n+                    SSLEngineResult clientResult;\n+                    clientSocketChannel.socket().setSoTimeout(500);\n+\n+                    log(\"=================\");\n+\n+                    \/\/ Produce client_hello\n+                    log(\"---Client Wrap client_hello---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    \/\/ Shutdown client\n+                    log(\"---Client closeOutbound---\");\n+                    clientEngine.closeOutbound();\n+\n+                    \/\/ Produce an unencrypted user_canceled\n+                    log(\"---Client Wrap user_canceled---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    \/\/ Produce an unencrypted close_notify\n+                    log(\"---Client Wrap close_notify---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+                    assertTrue(clientEngine.isOutboundDone());\n+                    assertEquals(clientResult.getStatus(), Status.CLOSED);\n+\n+                    \/\/ Send client_hello, user_canceled alert and close_notify alert\n+                    \/\/ to server. Server should throw a proper exception when\n+                    \/\/ receiving an unencrypted 2 byte packet user_canceled alert.\n+                    cTOs.flip();\n+                    inspectTlsBuffer(cTOs);\n+                    log(\"---Client sends unencrypted alerts---\");\n+                    int len = clientSocketChannel.write(cTOs);\n+\n+                    \/\/ Give server a chance to read before we shutdown via\n+                    \/\/ the try-with-resources block.\n+                    Thread.sleep(2000);\n+                } catch (Exception e) {\n+                    clientException = e;\n+                }\n+            }\n+        };\n+\n+        t.start();\n+        return t;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLCipher\/SSLSocketNoServerHelloClientShutdown.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n@@ -128,0 +130,26 @@\n+    public static void inspectTlsBuffer(ByteBuffer buffer) throws IOException {\n+        if (buffer == null || !buffer.hasRemaining()) {\n+            return;\n+        }\n+\n+        ByteBuffer packet = buffer.slice();\n+        System.err.printf(\"---TLS Buffer Inspection. Bytes Remaining: %d---\\n\", packet.remaining());\n+\n+        for (int i = 1; packet.position() < packet.limit(); i++) {\n+            byte contentType = packet.get();                   \/\/ pos: 0\n+            byte majorVersion = packet.get();                  \/\/ pos: 1\n+            byte minorVersion = packet.get();                  \/\/ pos: 2\n+            int contentLen = getInt16(packet);                 \/\/ pos: 3, 4\n+\n+            System.err.printf(\n+                    \"Flight %d: contentType: %d; majorVersion: %d; minorVersion: %d; contentLen: %d\\n\",\n+                    i, (int) contentType, (int) majorVersion, (int) minorVersion, contentLen);\n+\n+            packet.position(packet.position() + contentLen);\n+        }\n+    }\n+\n+    public static int getInt16(ByteBuffer m) throws IOException {\n+        return ((m.get() & 0xFF) << 8) | (m.get() & 0xFF);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SecurityUtils.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}