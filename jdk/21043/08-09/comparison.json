{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import sun.security.ssl.SSLCipher.SSLReadCipher;\n+\n@@ -35,0 +37,1 @@\n+\n@@ -36,1 +39,0 @@\n-import sun.security.ssl.SSLCipher.SSLReadCipher;\n@@ -156,0 +158,8 @@\n+    }\n+\n+    \/**\n+     * @return the last record we attempted to decode\n+     *\/\n+    \/\/ apply to SSLSocket only\n+    ByteBuffer getLastDecodeRecord() {\n+        throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/InputRecord.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import sun.security.ssl.SSLCipher.SSLReadCipher;\n+\n@@ -30,1 +32,0 @@\n-import java.io.InterruptedIOException;\n@@ -33,0 +34,1 @@\n+import java.io.InterruptedIOException;\n@@ -37,0 +39,1 @@\n+\n@@ -42,2 +45,0 @@\n-import sun.security.ssl.SSLCipher.SSLReadCipher;\n-\n@@ -57,0 +58,3 @@\n+    \/\/ Store the last record we attempted to decode.\n+    private ByteBuffer lastDecodeRecord = ByteBuffer.allocate(headerSize + recordBody.capacity());\n+\n@@ -206,0 +210,15 @@\n+    @Override\n+    ByteBuffer getLastDecodeRecord() {\n+        return lastDecodeRecord;\n+    }\n+\n+    private void saveLastDecodedRecord() {\n+        if (lastDecodeRecord.capacity() < headerSize + recordBody.remaining()) {\n+            lastDecodeRecord = ByteBuffer.allocate(headerSize + recordBody.remaining());\n+        }\n+        lastDecodeRecord.clear();\n+        lastDecodeRecord.put(header);\n+        lastDecodeRecord.put(recordBody.slice());\n+        lastDecodeRecord.flip();\n+    }\n+\n@@ -245,0 +264,2 @@\n+        \/\/ Record is ready to be decoded, save it.\n+        saveLastDecodedRecord();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -110,0 +110,5 @@\n+        ByteBuffer currentFlight = null;\n+\n+        if (srcs != null) {\n+            currentFlight = srcs[srcsOffset].slice();\n+        }\n@@ -129,2 +134,7 @@\n-            if (srcsLength == 1 && !context.sslConfig.isClientMode && !context.isNegotiated &&\n-                    context.handshakeContext != null &&\n+\n+            if (context.inputRecord instanceof SSLSocketInputRecord) {\n+                currentFlight = context.inputRecord.getLastDecodeRecord();\n+            }\n+\n+            if (currentFlight != null && !context.sslConfig.isClientMode && !context.isNegotiated &&\n+                    context.handshakeContext != null && context.handshakeContext.negotiatedProtocol != null &&\n@@ -132,6 +142,5 @@\n-                ByteBuffer packet = srcs[srcsOffset].duplicate();\n-                packet.position(0);\n-                byte contentType = (byte) Record.getInt8(packet);                   \/\/ pos: 0\n-                byte majorVersion = (byte) Record.getInt8(packet);                  \/\/ pos: 1\n-                byte minorVersion = (byte) Record.getInt8(packet);                  \/\/ pos: 2\n-                int contentLen = Record.getInt16(packet);                           \/\/ pos: 3, 4\n+\n+                byte contentType = (byte) Record.getInt8(currentFlight);                   \/\/ pos: 0\n+                byte majorVersion = (byte) Record.getInt8(currentFlight);                  \/\/ pos: 1\n+                byte minorVersion = (byte) Record.getInt8(currentFlight);                  \/\/ pos: 2\n+                int contentLen = Record.getInt16(currentFlight);                           \/\/ pos: 3, 4\n@@ -141,1 +150,1 @@\n-                        SSLLogger.finest(\"Processing plaintext alert during TLSv1.3 handshake\");\n+                        SSLLogger.info(\"Processing plaintext alert during TLSv1.3+ handshake\");\n@@ -145,1 +154,1 @@\n-                            new Plaintext(contentType, majorVersion, minorVersion, -1, -1L, packet)\n+                            new Plaintext(contentType, majorVersion, minorVersion, -1, -1L, currentFlight)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import static jdk.test.lib.security.SecurityUtils.inspectTlsFlight;\n+import static jdk.test.lib.security.SecurityUtils.inspectTlsBuffer;\n@@ -62,2 +62,3 @@\n-    protected final SSLEngine clientEngine;     \/\/ client Engine\n-    protected final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+\n+    protected SSLEngine clientEngine;     \/\/ client Engine\n+    protected ByteBuffer clientOut;       \/\/ write side of clientEngine\n@@ -70,1 +71,1 @@\n-    protected final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n@@ -91,1 +92,1 @@\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax * 2);\n@@ -93,1 +94,1 @@\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax + 1000);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax * 2);\n@@ -192,1 +193,1 @@\n-        inspectTlsFlight(cTOs);\n+        inspectTlsBuffer(cTOs);\n@@ -211,1 +212,1 @@\n-        inspectTlsFlight(cTOs);\n+        inspectTlsBuffer(cTOs);\n@@ -222,0 +223,1 @@\n+        inspectTlsBuffer(sTOc);\n@@ -224,2 +226,0 @@\n-        inspectTlsFlight(sTOc);\n-\n@@ -232,2 +232,0 @@\n-        inspectTlsFlight(sTOc);\n-\n@@ -240,2 +238,0 @@\n-        inspectTlsFlight(sTOc);\n-\n@@ -249,1 +245,1 @@\n-        \/\/ Only a stand-alone user_canceled alert is needed in server -> client direction\n+        \/\/ Only a stand-alone close_notify alert is needed in server -> client direction\n@@ -252,1 +248,1 @@\n-        log(\"---Server Wrap user_canceled---\");\n+        log(\"---Server Wrap close_notify---\");\n@@ -260,1 +256,1 @@\n-        inspectTlsFlight(sTOc);\n+        inspectTlsBuffer(sTOc);\n@@ -270,1 +266,1 @@\n-    private static void logEngineStatus(SSLEngine engine) {\n+    protected static void logEngineStatus(SSLEngine engine) {\n@@ -276,1 +272,1 @@\n-    private static void logEngineStatus(\n+    protected static void logEngineStatus(\n@@ -286,1 +282,1 @@\n-    private static void log(String message) {\n+    protected static void log(String message) {\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLEngineNoServerHelloClientShutdown.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331682\n+ * @summary Slow networks\/Impatient clients can potentially send\n+ *          unencrypted TLSv1.3 alerts that won't parse on the server.\n+ * @library \/javax\/net\/ssl\/templates\n+ * @library \/test\/lib\n+ * @run main\/othervm SSLSocketNoServerHelloClientShutdown\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.security.SecurityUtils.inspectTlsBuffer;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.Override;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.Status;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+\n+\/**\n+ * To reproduce @bug 8331682 (client sends an unencrypted TLS alert during 1.3 handshake)\n+ * with SSLSockets we use a SSLSocket on the server side and a plain TCP socket backed by\n+ * SSLEngine on the client side.\n+ *\/\n+public class SSLSocketNoServerHelloClientShutdown extends SSLEngineNoServerHelloClientShutdown {\n+\n+    private volatile Exception clientException;\n+    private volatile Exception serverException;\n+    private volatile Socket clientSocket;\n+\n+    public static void main(String[] args) throws Exception {\n+        new SSLSocketNoServerHelloClientShutdown().runTest();\n+    }\n+\n+    public SSLSocketNoServerHelloClientShutdown() throws Exception {\n+        super();\n+    }\n+\n+    private void runTest() throws Exception {\n+        \/\/ Set up SSL server\n+        SSLContext context = createServerSSLContext();\n+        SSLServerSocketFactory sslssf = context.getServerSocketFactory();\n+\n+        try (SSLServerSocket serverSocket = (SSLServerSocket) sslssf.createServerSocket()) {\n+\n+            serverSocket.setReuseAddress(false);\n+            serverSocket.bind(null);\n+            int port = serverSocket.getLocalPort();\n+            log(\"Port: \" + port);\n+            Thread thread = createClientThread(port);\n+\n+            try {\n+                \/\/ Server-side SSL socket that will read.\n+                SSLSocket socket = (SSLSocket) serverSocket.accept();\n+                InputStream is = socket.getInputStream();\n+                byte[] inbound = new byte[8192];\n+\n+                int len = is.read(inbound);\n+                log(\"Server reads \" + len + \" bytes\");\n+\n+            } catch (Exception e) {\n+                serverException = e;\n+                log(e.getMessage());\n+            } finally {\n+                thread.join();\n+            }\n+        } finally {\n+            if (serverException != null && serverException instanceof SSLHandshakeException) {\n+                throw serverException;\n+            }\n+            if (clientException != null) {\n+                throw clientException;\n+            }\n+        }\n+    }\n+\n+    private Thread createClientThread(final int port) {\n+\n+        Thread t = new Thread(\"ClientThread\") {\n+            @Override\n+            public void run() {\n+                try {\n+                    Queue<ByteBuffer> delayed = new ArrayDeque<>() {};\n+                    SSLEngineResult clientResult;\n+                    \/\/ Client-side plain socket.\n+                    clientSocket = new Socket(\"localhost\", port);\n+\n+                    log(\"=================\");\n+\n+                    \/\/ client wrap\n+                    \/\/ produce client_hello\n+                    log(\"---Client Wrap client_hello---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    \/\/ Read and store all available messages from the server\n+                    while (delayed.size() < 6) {\n+                        ByteBuffer msg = clientWriteRead();\n+                        if (msg == null) {\n+                            break;\n+                        }\n+                        delayed.add(msg);\n+                    }\n+\n+                    \/\/ Shutdown client\n+                    log(\"---Client closeOutbound---\");\n+                    clientEngine.closeOutbound();\n+\n+                    \/\/ Sends an unencrypted user_canceled\n+                    log(\"---Client Wrap user_canceled---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    \/\/ Sends an unencrypted close_notify\n+                    log(\"---Client Wrap close_notify---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    assertTrue(clientEngine.isOutboundDone());\n+                    assertEquals(clientResult.getStatus(), Status.CLOSED);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    ByteBuffer serverCloseNotify = clientWriteRead();\n+\n+                    \/\/ Consume delayed messages.\n+                    for (int i = 1; !delayed.isEmpty(); i++) {\n+                        ByteBuffer msg = delayed.remove();\n+                        inspectTlsBuffer(msg);\n+\n+                        log(\"---Client Unwrap delayed flight \" + i + \"---\");\n+                        clientResult = clientEngine.unwrap(msg, clientIn);\n+                        logEngineStatus(clientEngine, clientResult);\n+                        assertTrue(clientEngine.isOutboundDone());\n+                        runDelegatedTasks(clientEngine);\n+                    }\n+\n+                    assert serverCloseNotify != null;\n+                    inspectTlsBuffer(serverCloseNotify);\n+\n+                    log(\"---Client Unwrap close_notify response---\");\n+                    clientResult = clientEngine.unwrap(serverCloseNotify, clientIn);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    assertTrue(clientEngine.isOutboundDone());\n+                    assertTrue(clientEngine.isInboundDone());\n+                    runDelegatedTasks(clientEngine);\n+\n+                } catch (Exception e) {\n+                    clientException = e;\n+                }\n+            }\n+        };\n+\n+        t.start();\n+        return t;\n+    }\n+\n+    private ByteBuffer clientWriteRead() throws IOException {\n+        OutputStream os = clientSocket.getOutputStream();\n+        InputStream is = clientSocket.getInputStream();\n+        byte[] inbound = new byte[8192];\n+\n+        cTOs.flip();\n+        inspectTlsBuffer(cTOs);\n+\n+        byte[] outbound = new byte[cTOs.limit() - cTOs.position()];\n+        cTOs.get(outbound);\n+        cTOs.compact();\n+\n+        log(\"---Client writes \" + outbound.length + \" bytes---\");\n+        os.write(outbound);\n+        os.flush();\n+\n+        int len = 0;\n+\n+        try {\n+            len = is.read(inbound);\n+            log(\"---Client reads \" + len + \" bytes---\");\n+        } catch (Exception e) {\n+            log(e.getMessage());\n+            return null;\n+        }\n+\n+        if (len < 1) {\n+            return null;\n+        }\n+\n+        ByteBuffer flight = ByteBuffer.wrap(inbound);\n+        flight.limit(len);\n+        return flight;\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLSocketNoServerHelloClientShutdown.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -130,2 +130,4 @@\n-    public static void inspectTlsFlight(ByteBuffer flight) throws IOException {\n-        ByteBuffer packet = flight.slice();\n+    public static void inspectTlsBuffer(ByteBuffer flight) throws IOException {\n+        if (flight == null || !flight.hasRemaining()) {\n+            return;\n+        }\n@@ -133,1 +135,2 @@\n-        System.err.println(\"---TLS Flight Inspection---\");\n+        ByteBuffer packet = flight.slice();\n+        System.err.printf(\"---TLS Buffer Inspection. Bytes Remaining: %d---\\n\", packet.remaining());\n@@ -135,1 +138,1 @@\n-        if (packet.position() < packet.limit()) {\n+        for (int i = 1; packet.position() < packet.limit(); i++) {\n@@ -141,4 +144,4 @@\n-            System.err.println(\"\\tcontentType: \" + (int) contentType);\n-            System.err.println(\"\\tmajorVersion: \" + (int) majorVersion);\n-            System.err.println(\"\\tminorVersion: \" + (int) minorVersion);\n-            System.err.println(\"\\tcontentLen: \" + contentLen);\n+            System.err.printf(\"Flight %d: contentType: %d; majorVersion: %d; minorVersion: %d; contentLen: %d\\n\",\n+                    i, (int) contentType, (int) majorVersion, (int) minorVersion, contentLen);\n+\n+            packet.position(packet.position() + contentLen);\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SecurityUtils.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"}]}