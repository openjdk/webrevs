{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.security.ssl.SSLCipher.SSLReadCipher;\n+\n@@ -35,0 +37,1 @@\n+\n@@ -36,1 +39,0 @@\n-import sun.security.ssl.SSLCipher.SSLReadCipher;\n@@ -156,0 +158,8 @@\n+    }\n+\n+    \/**\n+     * @return the last record we attempted to decode\n+     *\/\n+    \/\/ apply to SSLSocket only\n+    ByteBuffer getLastDecodeRecord() {\n+        throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/InputRecord.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import sun.security.ssl.SSLCipher.SSLReadCipher;\n+\n@@ -30,1 +32,0 @@\n-import java.io.InterruptedIOException;\n@@ -33,0 +34,1 @@\n+import java.io.InterruptedIOException;\n@@ -37,0 +39,1 @@\n+\n@@ -42,2 +45,0 @@\n-import sun.security.ssl.SSLCipher.SSLReadCipher;\n-\n@@ -57,0 +58,3 @@\n+    \/\/ Store the last record we attempted to decode.\n+    private ByteBuffer lastDecodeRecord = null;\n+\n@@ -206,0 +210,15 @@\n+    @Override\n+    ByteBuffer getLastDecodeRecord() {\n+        return lastDecodeRecord;\n+    }\n+\n+    private void saveLastDecodeRecord() {\n+        if (lastDecodeRecord == null || lastDecodeRecord.capacity() < headerSize + recordBody.remaining()) {\n+            lastDecodeRecord = ByteBuffer.allocate(headerSize + recordBody.remaining());\n+        }\n+        lastDecodeRecord.clear();\n+        lastDecodeRecord.put(header);\n+        lastDecodeRecord.put(recordBody.slice());\n+        lastDecodeRecord.flip();\n+    }\n+\n@@ -245,0 +264,2 @@\n+        \/\/ Record is ready to be decoded, save it.\n+        saveLastDecodeRecord();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+\n@@ -108,1 +109,7 @@\n-        Plaintext[] plaintexts;\n+        Plaintext[] plaintexts = null;\n+        ByteBuffer currentFlight = null;\n+\n+        if (srcs != null) {\n+            currentFlight = srcs[srcsOffset].slice();\n+        }\n+\n@@ -110,2 +117,1 @@\n-            plaintexts =\n-                    context.inputRecord.decode(srcs, srcsOffset, srcsLength);\n+            plaintexts = context.inputRecord.decode(srcs, srcsOffset, srcsLength);\n@@ -125,10 +131,40 @@\n-            \/*\n-             * The basic SSLv3 record protection involves (optional)\n-             * encryption for privacy, and an integrity check ensuring\n-             * data origin authentication.  We do them both here, and\n-             * throw a fatal alert if the integrity check fails.\n-             *\/\n-             Alert alert = (context.handshakeContext != null) ?\n-                     Alert.HANDSHAKE_FAILURE :\n-                     Alert.BAD_RECORD_MAC;\n-            throw context.fatal(alert, bpe);\n+            \/\/ Check for unexpected plaintext alert message during TLSv1.3 handshake.\n+            \/\/ This can happen if client doesn't receive ServerHello due to network timeout\n+            \/\/ and tries to close the connection by sending an alert message.\n+\n+            if (context.inputRecord instanceof SSLSocketInputRecord) {\n+                currentFlight = context.inputRecord.getLastDecodeRecord();\n+            }\n+\n+            if (currentFlight != null && !context.sslConfig.isClientMode && !context.isNegotiated &&\n+                    context.handshakeContext != null && context.handshakeContext.negotiatedProtocol != null &&\n+                    context.handshakeContext.negotiatedProtocol.useTLS13PlusSpec()) {\n+\n+                byte contentType = (byte) Record.getInt8(currentFlight);                   \/\/ pos: 0\n+                byte majorVersion = (byte) Record.getInt8(currentFlight);                  \/\/ pos: 1\n+                byte minorVersion = (byte) Record.getInt8(currentFlight);                  \/\/ pos: 2\n+                int contentLen = Record.getInt16(currentFlight);                           \/\/ pos: 3, 4\n+\n+                if (contentLen == 2 && ContentType.ALERT.equals(ContentType.valueOf(contentType))) {\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        SSLLogger.info(\"Processing plaintext alert during TLSv1.3+ handshake\");\n+                    }\n+\n+                    plaintexts = new Plaintext[]{\n+                            new Plaintext(contentType, majorVersion, minorVersion, -1, -1L, currentFlight)\n+                    };\n+                }\n+            }\n+\n+            if (plaintexts == null) {\n+                \/*\n+                 * The basic SSLv3 record protection involves (optional)\n+                 * encryption for privacy, and an integrity check ensuring\n+                 * data origin authentication.  We do them both here, and\n+                 * throw a fatal alert if the integrity check fails.\n+                 *\/\n+                Alert alert = (context.handshakeContext != null) ?\n+                        Alert.HANDSHAKE_FAILURE :\n+                        Alert.BAD_RECORD_MAC;\n+                throw context.fatal(alert, bpe);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":50,"deletions":14,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8331682\n+ * @summary Slow networks\/Impatient clients can potentially send\n+ *          unencrypted TLSv1.3 alerts that won't parse on the server.\n+ * @library \/javax\/net\/ssl\/templates\n+ * @library \/test\/lib\n+ * @run main\/othervm SSLEngineNoServerHelloClientShutdown\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.security.SecurityUtils.inspectTlsBuffer;\n+\n+import java.nio.ByteBuffer;\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLEngineResult.Status;\n+import javax.net.ssl.SSLSession;\n+\n+\/**\n+ * A SSLEngine usage example which simplifies the presentation\n+ * by removing the I\/O and multi-threading concerns.\n+ * <p>\n+ * The test creates two SSLEngines, simulating a client and server.\n+ * The \"transport\" layer consists two byte buffers:  think of them\n+ * as directly connected pipes.\n+ * <p>\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.\n+ *\/\n+public class SSLEngineNoServerHelloClientShutdown extends SSLContextTemplate {\n+\n+    protected SSLEngine clientEngine;     \/\/ client Engine\n+    protected ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    protected final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    protected final SSLEngine serverEngine;     \/\/ server Engine\n+    protected final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    protected final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    protected ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    protected final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    protected SSLEngineNoServerHelloClientShutdown() throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine());\n+\n+        \/\/ We'll assume the buffer sizes are the same between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax * 2);\n+        \/\/ Make it larger so subsequent server wraps won't generate BUFFER_OVERFLOWS\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax * 2);\n+\n+        clientOut = createClientOutputBuffer();\n+        serverOut = createServerOutputBuffer();\n+    }\n+\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    protected ByteBuffer createClientOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n+    \/*\n+     * Configure the client side engine.\n+     *\/\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] {\"TLSv1.3\"});\n+        return clientEngine;\n+    }\n+\n+    \/*\n+     * Configure the server side engine.\n+     *\/\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+        return serverEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new SSLEngineNoServerHelloClientShutdown().runTestUserCancelled();\n+    }\n+\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n+\n+    private void runTestUserCancelled() throws Exception {\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+\n+        log(\"=================\");\n+\n+        \/\/ client wrap\n+        \/\/ produce client_hello\n+        log(\"---Client Wrap client_hello---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+\n+        \/\/ server unwrap\n+        \/\/ Consume client_hello\n+        log(\"---Server Unwrap client_hello---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+\n+        cTOs.compact();\n+\n+        \/\/ server wrap\n+        \/\/ produce server_hello\n+        log(\"---Server Wrap server_hello---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ SH packet went missing.  Timeout on Client.\n+\n+        \/\/ server wrap\n+        \/\/ produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ CCS packet went missing.  Timeout on Client.\n+\n+        \/\/ server wrap\n+        \/\/ produce other outbound messages\n+        log(\"---Server Wrap---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+        \/\/ EE\/etc. packet went missing.  Timeout on Client.\n+\n+        \/\/ *Yawn*  No response.  Shutdown client\n+        log(\"---Client closeOutbound---\");\n+        clientEngine.closeOutbound();\n+\n+        \/\/ Sends an unencrypted user_canceled\n+        log(\"---Client Wrap user_canceled---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+        inspectTlsBuffer(cTOs);\n+\n+        \/\/ Server unwrap should process an unencrypted 2 byte packet user_canceled alert.\n+        log(\"---Server Unwrap user_canceled alert---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        runDelegatedTasks(serverEngine);\n+\n+        cTOs.compact();\n+\n+        \/\/ Sends an unencrypted close_notify\n+        log(\"---Client Wrap close_notify---\");\n+        clientResult = clientEngine.wrap(clientOut, cTOs);\n+        logEngineStatus(clientEngine, clientResult);\n+        assertTrue(clientEngine.isOutboundDone());\n+        assertEquals(clientResult.getStatus(), Status.CLOSED);\n+        runDelegatedTasks(clientEngine);\n+\n+        cTOs.flip();\n+        inspectTlsBuffer(cTOs);\n+\n+        \/\/ Server unwrap should process an unencrypted 2 byte close_notify alert.\n+        log(\"---Server Unwrap close_notify alert---\");\n+        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+        logEngineStatus(serverEngine, serverResult);\n+        assertTrue(serverEngine.isInboundDone());\n+        assertEquals(serverResult.getStatus(), Status.CLOSED);\n+        runDelegatedTasks(serverEngine);\n+\n+        sTOc.flip();\n+        inspectTlsBuffer(sTOc);\n+\n+        \/\/ Client receives delayed server_hello\n+        log(\"---Client Unwrap server_hello---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        \/\/ Client receives delayed CCS\n+        log(\"---Client Unwrap CCS---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        \/\/ Client receives delayed EE\n+        log(\"---Client Unwrap EE---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        runDelegatedTasks(clientEngine);\n+\n+        sTOc.compact();\n+\n+        \/\/ Only a stand-alone close_notify alert is needed in server -> client direction\n+        \/\/ to terminate the handshake after the server already received user_canceled:close_notify\n+        \/\/ sequence from the client.\n+        log(\"---Server Wrap close_notify---\");\n+        serverResult = serverEngine.wrap(serverOut, sTOc);\n+        logEngineStatus(serverEngine, serverResult);\n+        assertTrue(serverEngine.isOutboundDone());\n+        assertTrue(serverEngine.isInboundDone());\n+        runDelegatedTasks(serverEngine);\n+\n+        sTOc.flip();\n+        inspectTlsBuffer(sTOc);\n+\n+        log(\"---Client Unwrap user_canceled alert---\");\n+        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+        logEngineStatus(clientEngine, clientResult);\n+        assertTrue(clientEngine.isOutboundDone());\n+        assertTrue(clientEngine.isInboundDone());\n+        runDelegatedTasks(clientEngine);\n+    }\n+\n+    protected static void logEngineStatus(SSLEngine engine) {\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone(): \" + engine.isOutboundDone());\n+    }\n+\n+    protected static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n+    }\n+\n+    protected static void log(String message) {\n+        System.err.println(message);\n+    }\n+\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n+    protected static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"    running delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            logEngineStatus(engine);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLEngineNoServerHelloClientShutdown.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331682\n+ * @summary Slow networks\/Impatient clients can potentially send\n+ *          unencrypted TLSv1.3 alerts that won't parse on the server.\n+ * @library \/javax\/net\/ssl\/templates\n+ * @library \/test\/lib\n+ * @run main\/othervm SSLSocketNoServerHelloClientShutdown\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.security.SecurityUtils.inspectTlsBuffer;\n+\n+import java.io.InputStream;\n+import java.lang.Override;\n+import java.net.InetSocketAddress;\n+import java.nio.channels.SocketChannel;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.Status;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+\n+\/**\n+ * To reproduce @bug 8331682 (client sends an unencrypted TLS alert during 1.3 handshake)\n+ * with SSLSockets we use an SSLSocket on the server side and a plain TCP socket backed by\n+ * SSLEngine on the client side.\n+ *\/\n+public class SSLSocketNoServerHelloClientShutdown extends SSLEngineNoServerHelloClientShutdown {\n+\n+    private volatile Exception clientException;\n+    private volatile Exception serverException;\n+    private volatile SocketChannel clientSocketChannel;\n+\n+    public static void main(String[] args) throws Exception {\n+        new SSLSocketNoServerHelloClientShutdown().runTest();\n+    }\n+\n+    public SSLSocketNoServerHelloClientShutdown() throws Exception {\n+        super();\n+    }\n+\n+    private void runTest() throws Exception {\n+        \/\/ Set up SSL server\n+        SSLContext context = createServerSSLContext();\n+        SSLServerSocketFactory sslssf = context.getServerSocketFactory();\n+\n+        try (SSLServerSocket serverSocket = (SSLServerSocket) sslssf.createServerSocket()) {\n+\n+            serverSocket.setReuseAddress(false);\n+            serverSocket.bind(null);\n+            int port = serverSocket.getLocalPort();\n+            log(\"Port: \" + port);\n+            Thread thread = createClientThread(port);\n+\n+            try {\n+                \/\/ Server-side SSL socket that will read.\n+                SSLSocket socket = (SSLSocket) serverSocket.accept();\n+                socket.setSoTimeout(2000);\n+                InputStream is = socket.getInputStream();\n+                byte[] inbound = new byte[8192];\n+\n+                int len = is.read(inbound);\n+                log(\"Server reads \" + len + \" bytes\");\n+\n+            } catch (Exception e) {\n+                serverException = e;\n+                log(e.getMessage());\n+            } finally {\n+                thread.join();\n+            }\n+        } finally {\n+            if (serverException != null && serverException instanceof SSLHandshakeException) {\n+                throw serverException;\n+            }\n+            if (clientException != null) {\n+                throw clientException;\n+            }\n+        }\n+    }\n+\n+    private Thread createClientThread(final int port) {\n+\n+        Thread t = new Thread(\"ClientThread\") {\n+            @Override\n+            public void run() {\n+                try {\n+                    SSLEngineResult clientResult;\n+                    \/\/ Client-side plain TCP socket.\n+                    clientSocketChannel = SocketChannel.open(\n+                            new InetSocketAddress(\"localhost\", port));\n+                    clientSocketChannel.socket().setSoTimeout(500);\n+\n+                    log(\"=================\");\n+\n+                    \/\/ Produce client_hello\n+                    log(\"---Client Wrap client_hello---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    \/\/ Shutdown client\n+                    log(\"---Client closeOutbound---\");\n+                    clientEngine.closeOutbound();\n+\n+                    \/\/ Produce an unencrypted user_canceled\n+                    log(\"---Client Wrap user_canceled---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    \/\/ Produce an unencrypted close_notify\n+                    log(\"---Client Wrap close_notify---\");\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    logEngineStatus(clientEngine, clientResult);\n+                    runDelegatedTasks(clientEngine);\n+                    assertTrue(clientEngine.isOutboundDone());\n+                    assertEquals(clientResult.getStatus(), Status.CLOSED);\n+\n+                    \/\/ Send client_hello, user_canceled alert and close_notify alert to server.\n+                    \/\/ Server should process 2 unencrypted alerts.\n+                    cTOs.flip();\n+                    inspectTlsBuffer(cTOs);\n+                    int len = clientSocketChannel.write(cTOs);\n+                    log(\"---Client wrote \" + len + \" bytes---\");\n+\n+                    \/\/ Read all the messages from the server.\n+                    \/\/ Server should reply with server_hello, CCS, EE and its own close_notify\n+                    \/\/ alert back to the client.\n+                    while ((len = clientSocketChannel.read(sTOc)) != -1) {\n+                        log(\"---Client read \" + len + \" bytes---\");\n+                    }\n+                    sTOc.flip();\n+                    inspectTlsBuffer(sTOc);\n+\n+                    \/\/ Consume server messages.\n+                    for (int i = 1; sTOc.hasRemaining(); i++) {\n+                        log(\"---Client Unwrap server flight \" + i + \"---\");\n+                        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+                        logEngineStatus(clientEngine, clientResult);\n+                        runDelegatedTasks(clientEngine);\n+                    }\n+\n+                    assertTrue(clientEngine.isOutboundDone());\n+                    assertTrue(clientEngine.isInboundDone());\n+\n+                } catch (Exception e) {\n+                    clientException = e;\n+                }\n+            }\n+        };\n+\n+        t.start();\n+        return t;\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv13\/SSLSocketNoServerHelloClientShutdown.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n@@ -128,0 +130,25 @@\n+    public static void inspectTlsBuffer(ByteBuffer buffer) throws IOException {\n+        if (buffer == null || !buffer.hasRemaining()) {\n+            return;\n+        }\n+\n+        ByteBuffer packet = buffer.slice();\n+        System.err.printf(\"---TLS Buffer Inspection. Bytes Remaining: %d---\\n\", packet.remaining());\n+\n+        for (int i = 1; packet.position() < packet.limit(); i++) {\n+            byte contentType = packet.get();                   \/\/ pos: 0\n+            byte majorVersion = packet.get();                  \/\/ pos: 1\n+            byte minorVersion = packet.get();                  \/\/ pos: 2\n+            int contentLen = getInt16(packet);                 \/\/ pos: 3, 4\n+\n+            System.err.printf(\"Flight %d: contentType: %d; majorVersion: %d; minorVersion: %d; contentLen: %d\\n\",\n+                    i, (int) contentType, (int) majorVersion, (int) minorVersion, contentLen);\n+\n+            packet.position(packet.position() + contentLen);\n+        }\n+    }\n+\n+    public static int getInt16(ByteBuffer m) throws IOException {\n+        return ((m.get() & 0xFF) << 8) | (m.get() & 0xFF);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SecurityUtils.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"}]}