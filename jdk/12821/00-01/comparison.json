{"files":[{"patch":"@@ -85,0 +85,2 @@\n+FDLIBM_CFLAGS := @OPENJDK_BUILD_FDLIBM_CFLAGS@\n+\n","filename":"make\/autoconf\/buildjdk-spec.gmk.in","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n-\/\/ These are copied defines from fdlibm.h, this allows us to keep the code\n-\/\/ the same as in the JDK, for easier maintenance.\n+\/\/ These are copied defines originally from fdlibm.h.\n@@ -35,1 +34,1 @@\n-\/\/ This code is a copy of __ieee754_fmod() from the JDK's libfdlibm and is\n+\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and is\n","filename":"src\/hotspot\/os\/windows\/sharedRuntimeRem.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,6 +31,2 @@\n-\/\/ This file contains copies of the fdlibm routines used by\n-\/\/ StrictMath. It turns out that it is almost always required to use\n-\/\/ these runtime routines; the Intel CPU doesn't meet the Java\n-\/\/ specification for sin\/cos outside a certain limited argument range,\n-\/\/ and the SPARC CPU doesn't appear to have sin\/cos instructions. It\n-\/\/ also turns out that avoiding the indirect call through function\n+\/\/ This file contains copies of the C fdlibm routines originally used by\n+\/\/ StrictMath. Avoiding the indirect call through function\n@@ -38,1 +34,1 @@\n-\/\/ by roughly 15% on both Win32\/x86 and Solaris\/SPARC.\n+\/\/ by roughly 15% on multiple architectures.\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntimeTrig.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,2 +45,22 @@\n- * then to be understood as executed with all floating-point\n- * operations following the rules of Java floating-point arithmetic.\n+ * then to be understood to be transliterated into Java and executed\n+ * with all floating-point and integer operations following the rules\n+ * of Java arithmetic. The following transformations are used in the\n+ * transliteration:\n+ *\n+ * <ul>\n+ * <li>Extraction and setting of the high and low halves of a 64-bit\n+ * {@code double} in C is expressed using Java platform methods that\n+ * perform bit-wise conversions {@linkplain\n+ * Double#doubleToRawLongBits(double) from {@code double} to {@code\n+ * long}} and {@linkplain Double#longBitsToDouble(long) {@code long}\n+ * to {@code double}}.\n+ *\n+ * <li>Unsigned {@code int} values in C are mapped to signed {@code\n+ * int} values in Java with updates to operations to replicate\n+ * unsigned semantics where the results on the same textual operation\n+ * would differ. For example, {@code >>} shifts on unsigned C values\n+ * are replaced with {@code >>>} shifts on signed Java values. Sized\n+ * comparisons on unsigned C values ({@code <}, {@code <=}, {@code >},\n+ * {@code >=}) are replaced with semantically equivalent calls to\n+ * {@link Integer#compareUnsigned(int, int) compareUnsigned}.\n+ * <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}