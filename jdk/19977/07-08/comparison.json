{"files":[{"patch":"@@ -30,1 +30,2 @@\n- * type variable.\n+ * type variable.  Its {@linkplain #getType() underlying} {@code TypeVariable}\n+ * represents the type parameter declaration.\n@@ -45,2 +46,2 @@\n-     * {@return the potentially annotated use of upper bounds of the type\n-     * variable}\n+     * {@return the potentially annotated use of upper bounds of the underlying\n+     * type parameter declaration}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedTypeVariable.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n- * {@code GenericArrayType} represents an array type whose element\n- * type is either a parameterized type, such as {@code Comparable<?>} for the\n- * array type {@code Comparable<?>[]}, or a type variable, such as {@code T}\n- * for the array type {@code T[][]}.\n+ * {@code GenericArrayType} represents an array type whose element type is\n+ * either a parameterized type, such as {@code Comparable<?>} for the array type\n+ * {@code Comparable<?>[]}, or a type variable, such as {@code T} for the array\n+ * type {@code T[][]}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/GenericArrayType.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,0 +93,29 @@\n+ * @apiNote\n+ * The {@code Type} hierarchy follows the design principle outlined below.\n+ * <blockquote><a href=\"https:\/\/bracha.org\/mirrors.pdf\">\n+ * Gilad Bracha and David Ungar. <cite>Mirrors: Design Principles for\n+ * Meta-level Facilities of Object-Oriented Programming Languages<\/cite>.\n+ * In Proc. of the ACM Conf. on Object-Oriented Programming, Systems,\n+ * Languages and Applications, October 2004.\n+ * <\/a><\/blockquote>\n+ * The goal is to represent both types and type arguments present in the current\n+ * runtime, such as those returned by core reflection, and those not available\n+ * as well.  As a result, no factories were provided for users to easily\n+ * construct types due to the different use cases.\n+ * <p>\n+ * However, this API is troubled with the goal of retrofitting {@link Class}\n+ * into the hierarchy; since {@link Class} already represents primitive types,\n+ * classes and interfaces that are non-generic or raw, or array types with\n+ * the previous types as elements, the new type additions in <a href=\n+ * \"https:\/\/jcp.org\/en\/jsr\/detail?id=14\">JSR 14<\/a> are modeled with the other\n+ * four subinterfaces.  This results in inconsistencies; for example, array\n+ * types are {@link ##alone Type} if the element is primitive, non-generic, or\n+ * raw, but {@link GenericArrayType} if the element is a parameterized type or a\n+ * type variable.  In addition, the simple {@code Type} interface does not\n+ * provide necessary accessors to access the component type for array types or\n+ * the owner type for nested classes or interfaces, making this API less useful.\n+ * <p>\n+ * The subsequent API modeling annotated uses of type, {@link AnnotatedType},\n+ * does not model types not in the current runtime, and provides proper\n+ * accessors for array component types and class or interface owner types.\n+ *\n@@ -95,0 +124,1 @@\n+ * @see java.compiler\/javax.lang.model\n@@ -97,0 +127,1 @@\n+@SuppressWarnings(\"doclint:reference\")\n@@ -100,1 +131,1 @@\n-     * about any type parameters.\n+     * about any type parameter.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Type.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n- * TypeVariable is the common superinterface for type variables of kinds.\n+ * {@code TypeVariable} represents a type variable (JLS {@jls 4.4}) and its\n+ * declaration, known as a {@index \"type parameter\"}, such as {@code <T extends\n+ * Comparable<? super T>>}.  The first occurrence of {@code T} is the declaration\n+ * of the type variable, and the second occurrence in {@code ? super T} is a use\n+ * of the type variable.\n+ * <p>\n@@ -31,6 +36,7 @@\n- * method, as specified in this package.  If a type variable t is referenced\n- * by a type (i.e, class, interface or annotation type) T, and T is declared\n- * by the n<sup>th<\/sup> enclosing class of T (see JLS {@jls 8.1.2}), then the creation of t\n- * requires the resolution (see JVMS {@jvms 5}) of the i<sup>th<\/sup> enclosing class of T,\n- * for i = 0 to n, inclusive. Creating a type variable must not cause the\n- * creation of its bounds. Repeated creation of a type variable has no effect.\n+ * method, as specified in this package.  If a type variable {@code T} is\n+ * referenced by a class {@code C}, and {@code T} is declared by the n<sup>th<\/sup>\n+ * enclosing class of {@code C} (see JLS {@jls 8.1.2}), then the creation of\n+ * {@code T} requires the resolution (see JVMS {@jvms 5}) of the i<sup>th<\/sup>\n+ * enclosing class of {@code C}, for i = 0 to n, inclusive.  Creating a type\n+ * variable must not cause the creation of its bounds. Repeated creation of a\n+ * type variable has no effect.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/TypeVariable.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}