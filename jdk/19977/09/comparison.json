{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,10 @@\n+ * <p>\n+ * For example, an annotated use {@code @TC int @TA [] @TB []} has an annotation\n+ * {@code @TA} and represents the array type {@code int[][]}.  Its component\n+ * type is the use {@code @TC int @TB []}, with an annotation {@code @TB},\n+ * representing the array type {@code int[]}.  Its element type is the use\n+ * {@code @TC int}, with an annotation {@code @TC}, representing the primitive\n+ * type {@code int}.\n+ * <p>\n+ * Two {@code AnnotatedArrayType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -34,0 +44,2 @@\n+ * @see Class\n+ * @see GenericArrayType\n@@ -40,1 +52,2 @@\n-     * Returns the potentially annotated generic component type of this array type.\n+     * {@return the potentially annotated use of the component type of the array\n+     * type}\n@@ -42,1 +55,1 @@\n-     * @return the potentially annotated generic component type of this array type\n+     * @see Class#componentType() Class::componentType\n@@ -44,0 +57,1 @@\n+     *      GenericArrayType::getGenericComponentType\n@@ -45,1 +59,1 @@\n-    AnnotatedType  getAnnotatedGenericComponentType();\n+    AnnotatedType getAnnotatedGenericComponentType();\n@@ -48,8 +62,1 @@\n-     * Returns the potentially annotated type that this type is a member of, if\n-     * this type represents a nested class or interface. For example, if this\n-     * type is {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.\n-     *\n-     * <p>Returns {@code null} for an {@code AnnotatedType} that is an instance\n-     *     of {@code AnnotatedArrayType}.\n-     *\n-     * @return {@code null}\n+     * {@return {@code null}}  An array type is not a member class or interface.\n@@ -61,0 +68,8 @@\n+\n+    \/**\n+     * {@return the array type that this potentially annotated use represents}\n+     * Returns a {@link Class} representing an array type or a {@link\n+     * GenericArrayType}.\n+     *\/\n+    @Override\n+    Type getType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedArrayType.java","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,12 @@\n- * annotated uses of types.\n+ * annotated uses of type arguments.\n+ * <p>\n+ * For example, an annotated use {@code Outer<@TC Long>.@TA Inner<@TB String>}\n+ * has an annotation {@code @TA} and represents the parameterized type {@code\n+ * Outer<Long>.Inner<String>}, a class.  It has exactly one type argument, which\n+ * is the annotated use {@code @TB String}, with an annotation {@code @TB},\n+ * representing the {@code String} class.  The use of its immediately enclosing\n+ * class is {@code Outer<@TC Long>}, with no annotation, representing the\n+ * parameterized type {@code Outer<Long>}.\n+ * <p>\n+ * Two {@code AnnotatedParameterizedType} objects should be compared using the\n+ * {@link Object#equals equals} method.\n@@ -33,0 +44,1 @@\n+ * @see ParameterizedType\n@@ -39,1 +51,11 @@\n-     * Returns the potentially annotated actual type arguments of this parameterized type.\n+     * {@return the potentially annotated use, as in the source code, of type\n+     * arguments of the parameterized type}\n+     * <p>\n+     * This method does not return the potentially annotated use of type\n+     * arguments of the {@linkplain #getAnnotatedOwnerType() enclosing classes}\n+     * of the parameterized type, if the parameterized type is nested.  For\n+     * example, if this use is {@code @TB O<@TC T>.@TA I<@TB S>}, this method\n+     * returns an array containing exactly the use of {@code @TB S}.  In\n+     * particular, if this nested type is a non-generic class in a generic\n+     * enclosing class, such as in the use {@code @TB O<@TC T>.@TA I}, this\n+     * method returns an empty array.\n@@ -41,5 +63,0 @@\n-     * <p>Note that in some cases, the returned array can be empty. This can occur\n-     * if this annotated type represents a non-parameterized type nested within\n-     * a parameterized type.\n-     *\n-     * @return the potentially annotated actual type arguments of this parameterized type\n@@ -51,15 +68,1 @@\n-     * Returns the potentially annotated type that this type is a member of, if\n-     * this type represents a nested type. For example, if this type is\n-     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.\n-     *\n-     * <p>Returns {@code null} if this {@code AnnotatedType} represents a\n-     *     top-level class or interface, or a local or anonymous class, or\n-     *     a primitive type, or void.\n-     *\n-     * @return an {@code AnnotatedType} object representing the potentially\n-     *     annotated type that this type is a member of, or {@code null}\n-     * @throws TypeNotPresentException if the owner type\n-     *     refers to a non-existent class or interface declaration\n-     * @throws MalformedParameterizedTypeException if the owner type\n-     *     refers to a parameterized type that cannot be instantiated\n-     *     for any reason\n+     * {@inheritDoc}\n@@ -67,0 +70,3 @@\n+     * @throws TypeNotPresentException {@inheritDoc}\n+     * @throws MalformedParameterizedTypeException {@inheritDoc}\n+     * @see ParameterizedType#getOwnerType()\n@@ -71,0 +77,7 @@\n+\n+    \/**\n+     * {@return the parameterized type that this potentially annotated use\n+     * represents}  Returns a {@link ParameterizedType}.\n+     *\/\n+    @Override\n+    Type getType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedParameterizedType.java","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,5 +31,40 @@\n- * {@code AnnotatedType} represents the potentially annotated use of a type in\n- * the program currently running in this VM. The use may be of any type in the\n- * Java programming language, including an array type, a parameterized type, a\n- * type variable, or a wildcard type.\n- *\n+ * {@code AnnotatedType} represents the potentially annotated use of a type or\n+ * type argument in the current runtime.  The use of a type (JLS {@jls 4.1}) is\n+ * the use of a primitive type or a reference type.  The use of a type argument\n+ * (JLS {@jls 4.5.1}) is the use of a reference type or a wildcard type\n+ * argument.\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">\n+ * Types and Type Arguments Used to Modeling Interfaces\n+ * <\/caption>\n+ * <thead>\n+ * <tr><th colspan=\"3\">Type or Type Argument Used\n+ *     <th>Example\n+ *     <th>Modeling interface\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><td colspan=\"3\">Primitive Types (JLS {@jls 4.2})\n+ *     <td>{@code @TA int}\n+ *     <td rowspan=\"3\">{@link ##alone AnnotatedType}\n+ * <tr><td rowspan=\"5\">Reference<br>Types<br>(JLS {@jls 4.3})\n+ *     <td rowspan=\"3\">Class and<br>Interface Types\n+ *     <td>Non-generic Class and Interface<br>Types\n+ *         (JLS {@jls 8.1.3}, {@jls 9.1.3})\n+ *     <td>{@code @TA String}\n+ * <tr><td>Raw Types (JLS {@jls 4.8})\n+ *     <td>{@code @TA List}\n+ * <tr><td>Parameterized Types (JLS {@jls 4.5})\n+ *     <td>{@code @TA List<@TB String>}\n+ *     <td>{@link AnnotatedParameterizedType}\n+ * <tr><td colspan=\"2\">Type Variables (JLS {@jls 4.4})\n+ *     <td>{@code @TA T}\n+ *     <td>{@link AnnotatedTypeVariable}\n+ * <tr><td colspan=\"2\">Array Types (JLS {@jls 10.1})\n+ *     <td>{@code @TB int @TA []}\n+ *     <td>{@link AnnotatedArrayType}\n+ * <tr><td colspan=\"3\">Wildcard Type Arguments (JLS {@jls 4.5.1})\n+ *     <td>{@code @TA ? extends @TB String}\n+ *     <td>{@link AnnotatedWildcardType}\n+ * <\/tbody>\n+ * <\/table>\n+ * <p>\n@@ -39,0 +74,21 @@\n+ * <p>\n+ * Class and Interface Types may be members of other classes and interfaces.\n+ * The use of a class or interface that declares another class or interface is\n+ * accessible via {@link #getAnnotatedOwnerType()}.\n+ * <p>\n+ * Two {@code AnnotatedType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n+ *\n+ * <h2 id=\"alone\">The {@code AnnotatedType} interface alone<\/h2>\n+ * Some {@code AnnotatedType} objects are not instances of the {@link\n+ * AnnotatedArrayType}, {@link AnnotatedParameterizedType}, {@link\n+ * AnnotatedTypeVariable}, or {@link AnnotatedWildcardType} subinterfaces.\n+ * Such a potentially annotated use represents a primitive type, a non-generic\n+ * class or interface, or a raw type, and the {@link #getType() getType()}\n+ * method returns a {@link Class}.\n+ * <p>\n+ * For example, an annotated use {@code @TB Outer.@TA Inner} is such an object;\n+ * it has an annotation {@code @TA} and represents the non-generic {@code\n+ * Outer.Inner} class. The use of its immediately enclosing class is {@code @TB\n+ * Outer}, with an annotation {@code @TB}, representing the non-generic {@code\n+ * Outer} class.\n@@ -40,8 +96,3 @@\n- * @jls 4.1 The Kinds of Types and Values\n- * @jls 4.2 Primitive Types and Values\n- * @jls 4.3 Reference Types and Values\n- * @jls 4.4 Type Variables\n- * @jls 4.5 Parameterized Types\n- * @jls 4.8 Raw Types\n- * @jls 4.9 Intersection Types\n- * @jls 10.1 Array Types\n+ * @see Type\n+ * @jls 4.11 Where Types Are Used\n+ * @jls 9.7.4 Where Annotations May Appear\n@@ -53,11 +104,33 @@\n-     * Returns the potentially annotated type that this type is a member of, if\n-     * this type represents a nested type. For example, if this type is\n-     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.\n-     *\n-     * <p>Returns {@code null} if this {@code AnnotatedType} represents a\n-     *     top-level class or interface, or a local or anonymous class, or\n-     *     a primitive type, or void.\n-     *\n-     * <p>Returns {@code null} if this {@code AnnotatedType} is an instance of\n-     *     {@code AnnotatedArrayType}, {@code AnnotatedTypeVariable}, or\n-     *     {@code AnnotatedWildcardType}.\n+     * {@return the potentially annotated use of the type that this type is a\n+     * member of, or {@code null} if this type is not a nested type}  The type\n+     * of the returned use is the immediately enclosing class or interface of\n+     * this type.\n+     * <p>\n+     * Top-level classes and interfaces, local classes and interfaces, and\n+     * anonymous classes are not members of other classes or interfaces.  For\n+     * example, if this use is {@code @TA Map<@TB K, V>}, this method returns\n+     * {@code null}.\n+     * <p>\n+     * If this type is explicitly or implicitly {@code static}, the uses of all\n+     * enclosing classes and interfaces of this type are unannotated and\n+     * represented by an {@link ##alone AnnotatedType} without any other\n+     * subinterface.  For example, if this use is {@code Map.@TA Entry<@TB K, V>},\n+     * this method returns the unannotated use of the raw type {@code Map}.\n+     * <p>\n+     * If this type is not {@code static}, the use of enclosing classes and\n+     * interfaces of this type are potentially annotated.  For example, if this\n+     * use is {@code @TB Outer.@TA Inner}, this method returns a representation\n+     * of {@code @TB Outer}.  In particular, if this use is an {@link\n+     * AnnotatedParameterizedType}, the enclosing classes and interfaces of this\n+     * parameterized type are possibly generic, and the use of type arguments\n+     * in these enclosing classes and interfaces are potentially annotated.  For\n+     * example, if this use is {@code @TB O<@TC T>.@TA I<S>}, this method\n+     * returns the use {@code @TB O<@TC T>}.\n+     * <p>\n+     * If this use is an {@link ##alone AnnotatedType} without any other\n+     * subinterface, this method returns an {@code AnnotatedType} without any\n+     * other subinterface or {@code null}.  If this use is an {@link\n+     * AnnotatedParameterizedType}, this method returns an {@code\n+     * AnnotatedParameterizedType}, an {@code AnnotatedType} without any other\n+     * subinterface, or {@code null}.  For all other subinterfaces, this method\n+     * returns {@code null}.\n@@ -69,8 +142,6 @@\n-     * @return an {@code AnnotatedType} object representing the potentially\n-     *     annotated type that this type is a member of, or {@code null}\n-     * @throws TypeNotPresentException if the owner type\n-     *     refers to a non-existent class or interface declaration\n-     * @throws MalformedParameterizedTypeException if the owner type\n-     *     refers to a parameterized type that cannot be instantiated\n-     *     for any reason\n-     *\n+     * @throws TypeNotPresentException if the immediate enclosing class or\n+     *     interface refers to a non-existent class or interface declaration\n+     * @throws MalformedParameterizedTypeException if the immediate enclosing\n+     *     class or interface refers to a parameterized type that cannot be\n+     *     instantiated for any reason\n+     * @see Class#getDeclaringClass() Class::getDeclaringClass\n@@ -84,1 +155,5 @@\n-     * Returns the underlying type that this annotated type represents.\n+     * {@return the type that this potentially annotated use represents}\n+     * <p>\n+     * If this object is not an instance of {@link AnnotatedArrayType}, {@link\n+     * AnnotatedParameterizedType}, {@link AnnotatedTypeVariable}, or {@link\n+     * AnnotatedWildcardType}, this method returns a {@link Class}.\n@@ -86,1 +161,1 @@\n-     * @return the type this annotated type represents\n+     * @see ##alone The {@code AnnotatedType} interface alone\n@@ -88,1 +163,1 @@\n-    public Type getType();\n+    Type getType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedType.java","additions":111,"deletions":36,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,8 @@\n- * type variable, whose declaration may have bounds which themselves represent\n- * annotated uses of types.\n+ * type variable.  Its {@linkplain #getType() underlying} {@code TypeVariable}\n+ * represents the type parameter declaration.\n+ * <p>\n+ * For example, an annotated use {@code @TA T} has an annotation {@code @TA}\n+ * and represents the type variable {@code T}.\n+ * <p>\n+ * Two {@code AnnotatedTypeVariable} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -33,0 +39,1 @@\n+ * @see TypeVariable\n@@ -39,3 +46,9 @@\n-     * Returns the potentially annotated bounds of this type variable.\n-     * If no bound is explicitly declared, the bound is unannotated\n-     * {@code Object}.\n+     * {@return the potentially annotated use of upper bounds of the underlying\n+     * type parameter declaration}\n+     * <p>\n+     * Given an {@code AnnotatedTypeVariable tv}, the call {@code\n+     * tv.getAnnotatedBounds()} is equivalent to:\n+     * {@snippet lang=java :\n+     * \/\/ @link substring=\"getAnnotatedBounds\" target=\"TypeVariable#getAnnotatedBounds()\" :\n+     * ((TypeVariable<?>) tv.getType()).getAnnotatedBounds() \/\/ @link substring=\"getType\" target=\"#getType()\"\n+     * }\n@@ -43,1 +56,6 @@\n-     * @return the potentially annotated bounds of this type variable\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n+     * @jls 4.9 Intersection Types\n+     * @see TypeVariable#getAnnotatedBounds()\n@@ -49,8 +67,1 @@\n-     * Returns the potentially annotated type that this type is a member of, if\n-     * this type represents a nested type. For example, if this type is\n-     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.\n-     *\n-     * <p>Returns {@code null} for an {@code AnnotatedType} that is an instance\n-     *     of {@code AnnotatedTypeVariable}.\n-     *\n-     * @return {@code null}\n+     * {@return {@code null}}  A type variable is not a member class or interface.\n@@ -62,0 +73,7 @@\n+\n+    \/**\n+     * {@return the type variable that this potentially annotated use\n+     * represents}  Returns a {@link TypeVariable}.\n+     *\/\n+    @Override\n+    Type getType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedTypeVariable.java","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,14 @@\n- * annotated uses of types.\n+ * annotated uses of types.  Since the use of a wildcard type argument is not\n+ * the use of a type, it will only be returned by APIs where uses of type\n+ * arguments may appear, such as {@link\n+ * AnnotatedParameterizedType#getAnnotatedActualTypeArguments()\n+ * AnnotatedParameterizedType::getAnnotatedActualTypeArguments}.\n+ * <p>\n+ * For example, an annotated use {@code @TA ? extends @TB Number} has an\n+ * annotation {@code @TA} and represents the wildcard type argument {@code ?\n+ * extends Number}.  Its upper bound is the annotated use {@code @TB Number}\n+ * with an annotation {@code @TB}, representing the {@code Number} class.  It\n+ * has no lower bound.\n+ * <p>\n+ * Two {@code AnnotatedWildcardType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -33,0 +46,1 @@\n+ * @see WildcardType\n@@ -39,3 +53,6 @@\n-     * Returns the potentially annotated lower bounds of this wildcard type.\n-     * If no lower bound is explicitly declared, the lower bound is the\n-     * type of null. In this case, a zero length array is returned.\n+     * {@return the potentially annotated use of lower bounds of the wildcard\n+     * type argument}  A lower bound has the syntax {@code ? super B} in Java\n+     * source code, where {@code B} is the bound.  If no lower bound is\n+     * explicitly declared, the lower bound is the null type (JLS {@jls 4.1})\n+     * and the use is unannotated.  In this case, a zero length array is\n+     * returned.\n@@ -43,3 +60,3 @@\n-     * @apiNote While to date a wildcard may have at most one lower\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one lower bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -47,2 +64,0 @@\n-     * @return the potentially annotated lower bounds of this wildcard type or\n-     * an empty array if no lower bound is explicitly declared.\n@@ -54,3 +69,5 @@\n-     * Returns the potentially annotated upper bounds of this wildcard type.\n-     * If no upper bound is explicitly declared, the upper bound is\n-     * unannotated {@code Object}\n+     * {@return the potentially annotated use of upper bounds of the wildcard\n+     * type argument}  An upper bound has the syntax {@code ? extends B} in Java\n+     * source code, where {@code B} is the bound.  If no upper bound is\n+     * explicitly declared, the upper bound is the {@code Object} class and the\n+     * use is unannotated.\n@@ -58,3 +75,3 @@\n-     * @apiNote While to date a wildcard may have at most one upper\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one upper bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -62,1 +79,0 @@\n-     * @return the potentially annotated upper bounds of this wildcard type\n@@ -68,8 +84,2 @@\n-     * Returns the potentially annotated type that this type is a member of, if\n-     * this type represents a nested type. For example, if this type is\n-     * {@code @TA O<T>.I<S>}, return a representation of {@code @TA O<T>}.\n-     *\n-     * <p>Returns {@code null} for an {@code AnnotatedType} that is an instance\n-     *     of {@code AnnotatedWildcardType}.\n-     *\n-     * @return {@code null}\n+     * {@return {@code null}}  A wildcard type argument is not a member class or\n+     * interface.\n@@ -81,0 +91,7 @@\n+\n+    \/**\n+     * {@return the wildcard type argument that this potentially annotated use\n+     * represents}  Returns a {@link WildcardType}.\n+     *\/\n+    @Override\n+    Type getType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedWildcardType.java","additions":42,"deletions":25,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,7 @@\n- * {@code GenericArrayType} represents an array type whose component\n- * type is either a parameterized type or a type variable.\n+ * {@code GenericArrayType} represents an array type whose element type is\n+ * either a parameterized type, such as {@code Comparable<?>} for the array type\n+ * {@code Comparable<?>[]}, or a type variable, such as {@code T} for the array\n+ * type {@code T[][]}.\n+ * <p>\n+ * Two {@code GenericArrayType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -32,0 +37,1 @@\n+ * @see AnnotatedArrayType\n@@ -37,7 +43,8 @@\n-     * Returns a {@code Type} object representing the component type\n-     * of this array. This method creates the component type of the\n-     * array.  See the declaration of {@link\n-     * java.lang.reflect.ParameterizedType ParameterizedType} for the\n-     * semantics of the creation process for parameterized types and\n-     * see {@link java.lang.reflect.TypeVariable TypeVariable} for the\n-     * creation process for type variables.\n+     * {@return the component type of this array type}  The component type must\n+     * be one of {@link GenericArrayType}, {@link ParameterizedType}, or {@link\n+     * TypeVariable}.\n+     * <p>\n+     * This method creates the component type of the array.  See {@link\n+     * ParameterizedType} for the semantics of the creation process for\n+     * parameterized types and see {@link TypeVariable} for the creation process\n+     * for type variables.\n@@ -45,7 +52,4 @@\n-     * @return  a {@code Type} object representing the component type\n-     *     of this array\n-     * @throws TypeNotPresentException if the underlying array type's component\n-     *     type refers to a non-existent class or interface declaration\n-     * @throws MalformedParameterizedTypeException if  the\n-     *     underlying array type's component type refers to a\n-     *     parameterized type that cannot be instantiated for any reason\n+     * @throws TypeNotPresentException if the component type refers to a\n+     *     non-existent class or interface declaration\n+     * @throws MalformedParameterizedTypeException if the component type refers\n+     *     to a parameterized type that cannot be instantiated for any reason\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/GenericArrayType.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,14 +30,13 @@\n- * ParameterizedType represents a parameterized type such as\n- * {@code Collection<String>}.\n- *\n- * <p>A parameterized type is created the first time it is needed by a\n- * reflective method, as specified in this package. When a\n- * parameterized type p is created, the generic class or interface declaration\n- * that p instantiates is resolved, and all type arguments of p are created\n- * recursively. See {@link java.lang.reflect.TypeVariable\n- * TypeVariable} for details on the creation process for type\n- * variables. Repeated creation of a parameterized type has no effect.\n- *\n- * <p>Instances of classes that implement this interface must implement\n- * an equals() method that equates any two instances that share the\n- * same generic class or interface declaration and have equal type parameters.\n+ * {@code ParameterizedType} represents a parameterized type, such as {@code\n+ * Collection<String>}.  A parameterized type is a class or interface.\n+ * <p>\n+ * A parameterized type is created the first time it is needed by a reflective\n+ * method, as specified in this package. When a parameterized type {@code p} is\n+ * created, the generic class or interface declaration that {@linkplain\n+ * #getRawType() defines} {@code p} is resolved, and all type arguments of\n+ * {@code p} are created recursively.  See {@link TypeVariable} for details on\n+ * the creation process for type variables. Repeated creation of a parameterized\n+ * type has no effect.\n+ * <p>\n+ * Two {@code ParameterizedType} objects should be compared using the {@link\n+ * #equals equals} method.\n@@ -45,0 +44,1 @@\n+ * @see AnnotatedParameterizedType\n@@ -50,6 +50,8 @@\n-     * Returns an array of {@code Type} objects representing the actual type\n-     * arguments to this type.\n-     *\n-     * <p>Note that in some cases, the returned array be empty. This can occur\n-     * if this type represents a non-parameterized type nested within\n-     * a parameterized type.\n+     * {@return the type arguments of this type, as used in the source code}\n+     * <p>\n+     * This method does not return the type arguments of the {@linkplain\n+     * #getOwnerType() enclosing classes} of this type, if this type is nested.\n+     * For example, if this type is {@code O<T>.I<S>}, this method returns an\n+     * array containing exactly {@code S}.  In particular, if this is a\n+     * non-generic class in a generic enclosing class, such as the type {@code\n+     * O<T>.I}, this method returns an empty array.\n@@ -57,2 +59,0 @@\n-     * @return an array of {@code Type} objects representing the actual type\n-     *     arguments to this type\n@@ -62,1 +62,1 @@\n-     *     actual type parameters refer to a parameterized type that cannot\n+     *     actual type arguments refer to a parameterized type that cannot\n@@ -64,1 +64,0 @@\n-     * @since 1.5\n@@ -69,2 +68,11 @@\n-     * {@return the {@code Type} object representing the class or interface\n-     * that declared this type}\n+     * {@return the raw type of this type}  This is the generic class or\n+     * interface that defines this parameterized type, and applies recursively\n+     * to the {@linkplain #getOwnerType() type that this type is a member of} if\n+     * such a type exists.  For example, if this type is {@code O<T>.I<S>}, this\n+     * method returns a representation of {@code O.I}.\n+     * <p>\n+     * The returned object implements {@link Type##alone Type} without any other\n+     * subinterface.\n+     * <p>\n+     * This method performs type erasure (JLS {@jls 4.6}) for parameterized\n+     * types.\n@@ -72,7 +80,2 @@\n-     * @apiNote\n-     * All {@code ParameterizedType} objects from core reflection return a\n-     * {@link Class}. The static {@code Type} return type allows other\n-     * implementations to represent classes and interfaces not in the current\n-     * runtime.\n-     *\n-     * @since 1.5\n+     * @see Type##alone The {@code Type} interface alone\n+     * @jls 4.8 Raw Types\n@@ -83,5 +86,21 @@\n-     * Returns a {@code Type} object representing the type that this type\n-     * is a member of.  For example, if this type is {@code O<T>.I<S>},\n-     * return a representation of {@code O<T>}.\n-     *\n-     * <p>If this type is a top-level type, {@code null} is returned.\n+     * {@return the type that this type is a member of, or {@code null} if this\n+     * type is not a nested type}  The returned type is the immediately enclosing\n+     * class or interface of this type.\n+     * <p>\n+     * Top-level classes and interfaces, local classes and interfaces, and\n+     * anonymous classes are not members of other classes or interfaces.  For\n+     * example, if this type is {@code Map<K, V>}, this method returns {@code\n+     * null}.\n+     * <p>\n+     * If this type is explicitly or implicitly {@code static}, the class or\n+     * interface that declared this type is always represented by a {@link\n+     * Type##alone Type} without any other subinterface.  For example, if this\n+     * type is {@code Map.Entry<K, V>}, this method returns the raw type {@code\n+     * Map}.\n+     * <p>\n+     * If this type is not {@code static}, the class or interface that declared\n+     * this type may be a {@code ParameterizedType} that has more type arguments\n+     * in one of the enclosing classes and interfaces, or a {@link Type##alone\n+     * Type} without any other subinterface if there is no more type argument.\n+     * For example, if this type is {@code O<T>.I<S>}, this method returns the\n+     * parameterized type {@code O<T>}.\n@@ -89,9 +108,8 @@\n-     * @return a {@code Type} object representing the type that\n-     *     this type is a member of. If this type is a top-level type,\n-     *     {@code null} is returned\n-     * @throws TypeNotPresentException if the owner type\n-     *     refers to a non-existent class or interface declaration\n-     * @throws MalformedParameterizedTypeException if the owner type\n-     *     refers to a parameterized type that cannot be instantiated\n-     *     for any reason\n-     * @since 1.5\n+     * @throws TypeNotPresentException if the immediately enclosing class or\n+     *     interface refers to a non-existent class or interface declaration\n+     * @throws MalformedParameterizedTypeException if the immediately enclosing\n+     *     class or interface refers to a parameterized type that cannot be\n+     *     instantiated for any reason\n+     * @see Class#getDeclaringClass() Class::getDeclaringClass\n+     * @jls 8.5 Member Class and Interface Declarations\n+     * @jls 9.5 Member Class and Interface Declarations\n@@ -100,0 +118,13 @@\n+\n+    \/**\n+     * {@return whether some other object is equal to this {@code\n+     * ParameterizedType}}  Two instances of {@code ParameterizedType} are equal\n+     * if and only if they share the same {@linkplain #getRawType() generic\n+     * class or interface declaration} and have equal {@linkplain\n+     * #getActualTypeArguments() type arguments}, including those from the\n+     * {@linkplain #getOwnerType() enclosing classes}.\n+     *\n+     * @param o {@inheritDoc}\n+     *\/\n+    @Override\n+    boolean equals(Object o);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ParameterizedType.java","additions":79,"deletions":48,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,92 @@\n- * Type is the common superinterface for all types in the Java\n- * programming language. These include raw types, parameterized types,\n- * array types, type variables and primitive types.\n+ * {@code Type} represents types in the Java programming language and type\n+ * arguments.  Types (JLS {@jls 4.1}) are primitive types and reference types.\n+ * Type arguments (JLS {@jls 4.5.1}) are reference types and wildcard type\n+ * arguments.\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">\n+ * Types and Type Arguments to Modeling Interfaces\n+ * <\/caption>\n+ * <thead>\n+ * <tr><th colspan=\"3\">Type or Type Argument\n+ *     <th>Example\n+ *     <th>Modeling interface\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><td colspan=\"3\">Primitive Types (JLS {@jls 4.2})\n+ *     <td>{@code int}\n+ *     <td rowspan=\"3\">{@link ##alone Type}\n+ * <tr><td rowspan=\"7\">Reference<br>Types<br>(JLS {@jls 4.3})\n+ *     <td rowspan=\"3\">Class and<br>Interface Types\n+ *     <td>Non-generic Class and Interface<br>Types\n+ *         (JLS {@jls 8.1.3}, {@jls 9.1.3})\n+ *     <td>{@code String}\n+ * <tr><td>Raw Types (JLS {@jls 4.8})\n+ *     <td>{@code List}\n+ * <tr><td>Parameterized Types (JLS {@jls 4.5})\n+ *     <td>{@code List<String>}\n+ *     <td>{@link ParameterizedType}\n+ * <tr><td colspan=\"2\">Type Variables (JLS {@jls 4.4})\n+ *     <td>{@code T}\n+ *     <td>{@link TypeVariable}\n+ * <tr><td rowspan=\"3\">Array Types<br>(JLS {@jls 10.1})\n+ *     <td>Parameterized Type Elements\n+ *     <td>{@code List<String>[]}\n+ *     <td rowspan=\"2\">{@link GenericArrayType}\n+ * <tr><td>Types Variable Elements\n+ *     <td>{@code T[]}\n+ * <tr><td>Other Elements\n+ *     <td>{@code int[]}, {@code String[]}\n+ *     <td>{@link ##alone Type}\n+ * <tr><td colspan=\"3\">Wildcard Type Arguments (JLS {@jls 4.5.1})\n+ *     <td>{@code ? extends String}\n+ *     <td>{@link WildcardType}\n+ * <\/tbody>\n+ * <\/table>\n+ * <p>\n+ * Class and Interface Types may be members of other classes and interfaces.\n+ * The class or interface that declares a class or interface is accessible via\n+ * {@link Class#getDeclaringClass() Class::getDeclaringClass}.  The possibly\n+ * generic class or interface that declares a parameterized type is accessible\n+ * via {@link ParameterizedType#getOwnerType() ParameterizedType::getOwnerType}.\n+ * <p>\n+ * Two {@code Type} objects should be compared using the {@link Object#equals\n+ * equals} method.\n+ *\n+ * <h2 id=\"alone\">The {@code Type} interface alone<\/h2>\n+ * Some {@code Type} objects are not instances of the {@link GenericArrayType},\n+ * {@link ParameterizedType}, {@link TypeVariable}, or {@link WildcardType}\n+ * subinterfaces.  Such a type is a primitive type, a non-generic class or\n+ * interface, a raw type, or an array type with any of these types as its\n+ * element type.  In core reflection, they are all represented by {@link Class}.\n+ * <p>\n+ * Examples include the primitive type {@code int}, the non-generic {@link\n+ * Object} class, the raw type {@code List}, and the array type {@code int[]}.\n+ *\n+ * @apiNote\n+ * The {@code Type} hierarchy follows the design principle outlined below.\n+ * <blockquote><a href=\"https:\/\/bracha.org\/mirrors.pdf\">\n+ * Gilad Bracha and David Ungar. <cite>Mirrors: Design Principles for\n+ * Meta-level Facilities of Object-Oriented Programming Languages<\/cite>.\n+ * In Proc. of the ACM Conf. on Object-Oriented Programming, Systems,\n+ * Languages and Applications, October 2004.\n+ * <\/a><\/blockquote>\n+ * The goal is to represent both types and type arguments present in the current\n+ * runtime, such as those returned by core reflection, and those not available\n+ * as well.  As a result, no factories were provided for users to easily\n+ * construct types due to the different use cases.\n+ * <p>\n+ * However, this API is troubled with the goal of retrofitting {@link Class}\n+ * into the hierarchy; since {@link Class} already represents primitive types,\n+ * classes and interfaces that are non-generic or raw, or array types with\n+ * the previous types as elements, the new type additions in <a href=\n+ * \"https:\/\/jcp.org\/en\/jsr\/detail?id=14\">JSR 14<\/a> are modeled with the other\n+ * four subinterfaces.  This results in inconsistencies; for example, array\n+ * types are {@link ##alone Type} if the element is primitive, non-generic, or\n+ * raw, but {@link GenericArrayType} if the element is a parameterized type or a\n+ * type variable.  In addition, the simple {@code Type} interface does not\n+ * provide necessary accessors to access the component type for array types or\n+ * the owner type for nested classes or interfaces, making this API less useful.\n+ * <p>\n+ * The subsequent API modeling annotated uses of type, {@link AnnotatedType},\n+ * does not model types not in the current runtime, and provides proper\n+ * accessors for array component types and class or interface owner types.\n@@ -34,7 +123,3 @@\n- * @jls 4.2 Primitive Types and Values\n- * @jls 4.3 Reference Types and Values\n- * @jls 4.4 Type Variables\n- * @jls 4.5 Parameterized Types\n- * @jls 4.8 Raw Types\n- * @jls 4.9 Intersection Types\n- * @jls 10.1 Array Types\n+ * @jls 4.11 Where Types Are Used\n+ * @see java.compiler\/javax.lang.model\n+ * @see AnnotatedType\n@@ -43,0 +128,1 @@\n+@SuppressWarnings(\"doclint:reference\")\n@@ -46,1 +132,1 @@\n-     * about any type parameters.\n+     * about any type parameter.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Type.java","additions":98,"deletions":12,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,6 @@\n- * TypeVariable is the common superinterface for type variables of kinds.\n+ * {@code TypeVariable} represents a type variable (JLS {@jls 4.4}) and its\n+ * declaration, known as a {@index \"type parameter\"}, such as {@code <T extends\n+ * Comparable<? super T>>}.  The first occurrence of {@code T} is the declaration\n+ * of the type variable, and the second occurrence in {@code ? super T} is a use\n+ * of the type variable.\n+ * <p>\n@@ -31,17 +36,10 @@\n- * method, as specified in this package.  If a type variable t is referenced\n- * by a type (i.e, class, interface or annotation type) T, and T is declared\n- * by the n<sup>th<\/sup> enclosing class of T (see JLS {@jls 8.1.2}), then the creation of t\n- * requires the resolution (see JVMS {@jvms 5}) of the i<sup>th<\/sup> enclosing class of T,\n- * for i = 0 to n, inclusive. Creating a type variable must not cause the\n- * creation of its bounds. Repeated creation of a type variable has no effect.\n- *\n- * <p>Multiple objects may be instantiated at run-time to\n- * represent a given type variable. Even though a type variable is\n- * created only once, this does not imply any requirement to cache\n- * instances representing the type variable. However, all instances\n- * representing a type variable must be equal() to each other.\n- * As a consequence, users of type variables must not rely on the identity\n- * of instances of classes implementing this interface.\n- *\n- * @param <D> the type of generic declaration that declared the\n- * underlying type variable.\n+ * method, as specified in this package.  If a type variable {@code T} is\n+ * referenced by a class {@code C}, and {@code T} is declared by the n<sup>th<\/sup>\n+ * enclosing class of {@code C} (see JLS {@jls 8.1.2}), then the creation of\n+ * {@code T} requires the resolution (see JVMS {@jvms 5}) of the i<sup>th<\/sup>\n+ * enclosing class of {@code C}, for i = 0 to n, inclusive.  Creating a type\n+ * variable must not cause the creation of its bounds. Repeated creation of a\n+ * type variable has no effect.\n+ * <p>\n+ * Two {@code TypeVariable} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -49,0 +47,2 @@\n+ * @param <D> the type of generic declaration that declares this type variable\n+ * @see AnnotatedTypeVariable\n@@ -54,3 +54,2 @@\n-     * Returns an array of {@code Type} objects representing the\n-     * upper bound(s) of this type variable.  If no upper bound is\n-     * explicitly declared, the upper bound is {@code Object}.\n+     * {@return the upper bounds of this type variable}  If no upper bound is\n+     * explicitly declared, the upper bound is the {@link Object} class.\n@@ -58,5 +57,7 @@\n-     * <p>For each upper bound B: <ul> <li>if B is a parameterized\n-     * type or a type variable, it is created, (see {@link\n-     * java.lang.reflect.ParameterizedType ParameterizedType} for the\n-     * details of the creation process for parameterized types).\n-     * <li>Otherwise, B is resolved.  <\/ul>\n+     * <p>For each upper bound B:\n+     * <ul>\n+     *  <li>if B is a parameterized type or a type variable, it is created.\n+     *  (see {@link ParameterizedType} and {@link TypeVariable} for the details\n+     *  of the creation process for parameterized types and type variables)\n+     *  <li>Otherwise, B is resolved.\n+     * <\/ul>\n@@ -64,7 +65,5 @@\n-     * @throws TypeNotPresentException  if any of the\n-     *     bounds refers to a non-existent type declaration\n-     * @throws MalformedParameterizedTypeException if any of the\n-     *     bounds refer to a parameterized type that cannot be instantiated\n-     *     for any reason\n-     * @return an array of {@code Type}s representing the upper\n-     *     bound(s) of this type variable\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n+     * @jls 4.9 Intersection Types\n@@ -75,6 +74,1 @@\n-     * Returns the {@code GenericDeclaration} object representing the\n-     * generic declaration declared for this type variable.\n-     *\n-     * @return the generic declaration declared for this type variable.\n-     *\n-     * @since 1.5\n+     * {@return the generic declaration that declares this type variable}\n@@ -85,3 +79,2 @@\n-     * Returns the name of this type variable, as it occurs in the source code.\n-     *\n-     * @return the name of this type variable, as it appears in the source code\n+     * {@return the name of this type variable, as it appears in the source\n+     * code}\n@@ -92,6 +85,5 @@\n-     * Returns an array of AnnotatedType objects that represent the use of\n-     * types to denote the upper bounds of the type parameter represented by\n-     * this TypeVariable. The order of the objects in the array corresponds to\n-     * the order of the bounds in the declaration of the type parameter. Note that\n-     * if no upper bound is explicitly declared, the upper bound is unannotated\n-     * {@code Object}.\n+     * {@return the potentially annotated uses of upper bounds of the type\n+     * variable}  They are ordered as they appear in the declaration of the\n+     * type parameter in the source code.  If no bound is explicitly declared,\n+     * this method returns an array containing exactly the unannotated use of\n+     * the {@code Object} class.\n@@ -99,1 +91,5 @@\n-     * @return an array of objects representing the upper bound(s) of the type variable\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n+     * @jls 4.9 Intersection Types\n@@ -102,1 +98,1 @@\n-     AnnotatedType[] getAnnotatedBounds();\n+    AnnotatedType[] getAnnotatedBounds();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/TypeVariable.java","additions":47,"deletions":51,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,8 @@\n- * WildcardType represents a wildcard type expression, such as\n- * {@code ?}, {@code ? extends Number}, or {@code ? super Integer}.\n+ * {@code WildcardType} represents a wildcard type argument, such as {@code ?},\n+ * {@code ? extends Number}, or {@code ? super Integer}.  Since a wildcard type\n+ * argument is not a type, it will only be returned by APIs where type arguments\n+ * may appear, such as {@link ParameterizedType#getActualTypeArguments()\n+ * ParameterizedType::getActualTypeArguments}.\n+ * <p>\n+ * Two {@code WildcardType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -32,0 +38,1 @@\n+ * @see AnnotatedWildcardType\n@@ -37,3 +44,4 @@\n-     * Returns an array of {@code Type} objects representing the  upper\n-     * bound(s) of this type variable.  If no upper bound is\n-     * explicitly declared, the upper bound is {@code Object}.\n+     * {@return the upper bounds of this wildcard type argument}  An upper bound\n+     * has the syntax {@code ? extends B} in Java source code, where {@code B}\n+     * is the bound.  If no upper bound is explicitly declared, the upper bound\n+     * is the {@link Object} class.\n@@ -41,1 +49,1 @@\n-     * <p>For each upper bound B :\n+     * <p>For each upper bound B:\n@@ -43,3 +51,3 @@\n-     *  <li>if B is a parameterized type or a type variable, it is created,\n-     *  (see {@link java.lang.reflect.ParameterizedType ParameterizedType}\n-     *  for the details of the creation process for parameterized types).\n+     *  <li>if B is a parameterized type or a type variable, it is created.\n+     *  (see {@link ParameterizedType} and {@link TypeVariable} for the details\n+     *  of the creation process for parameterized types and type variables)\n@@ -49,3 +57,3 @@\n-     * @apiNote While to date a wildcard may have at most one upper\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one upper bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -53,7 +61,4 @@\n-     * @return an array of Types representing the upper bound(s) of this\n-     *     type variable\n-     * @throws TypeNotPresentException if any of the\n-     *     bounds refers to a non-existent type declaration\n-     * @throws MalformedParameterizedTypeException if any of the\n-     *     bounds refer to a parameterized type that cannot be instantiated\n-     *     for any reason\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n@@ -64,4 +69,5 @@\n-     * Returns an array of {@code Type} objects representing the\n-     * lower bound(s) of this type variable.  If no lower bound is\n-     * explicitly declared, the lower bound is the type of {@code null}.\n-     * In this case, a zero length array is returned.\n+     * {@return the lower bounds of this wildcard type argument}  A lower bound\n+     * has the syntax {@code ? super B} in Java source code, where {@code B} is\n+     * the bound.  If no lower bound is explicitly declared, the lower bound is\n+     * the null type (JLS {@jls 4.1}).  In this case, a zero length array is\n+     * returned.\n@@ -69,1 +75,1 @@\n-     * <p>For each lower bound B :\n+     * <p>For each lower bound B:\n@@ -71,4 +77,4 @@\n-     *   <li>if B is a parameterized type or a type variable, it is created,\n-     *  (see {@link java.lang.reflect.ParameterizedType ParameterizedType}\n-     *  for the details of the creation process for parameterized types).\n-     *   <li>Otherwise, B is resolved.\n+     *  <li>if B is a parameterized type or a type variable, it is created.\n+     *  (see {@link ParameterizedType} and {@link TypeVariable} for the details\n+     *  of the creation process for parameterized types and type variables)\n+     *  <li>Otherwise, B is resolved.\n@@ -77,3 +83,3 @@\n-     * @apiNote While to date a wildcard may have at most one lower\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one lower bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -81,7 +87,4 @@\n-     * @return an array of Types representing the lower bound(s) of this\n-     *     type variable\n-     * @throws TypeNotPresentException if any of the\n-     *     bounds refers to a non-existent type declaration\n-     * @throws MalformedParameterizedTypeException if any of the\n-     *     bounds refer to a parameterized type that cannot be instantiated\n-     *     for any reason\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/WildcardType.java","additions":42,"deletions":39,"binary":false,"changes":81,"status":"modified"}]}