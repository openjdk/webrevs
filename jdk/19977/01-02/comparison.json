{"files":[{"patch":"@@ -33,0 +33,10 @@\n+ * <p>\n+ * For example, an annotated use {@code @TC int @TA [] @TB []} has an annotation\n+ * {@code @TA} and represents the array type {@code int[][]}.  Its component\n+ * type is the use {@code @TC int @TB []}, with an annotation {@code @TB},\n+ * representing the array type {@code int[]}.  Its element type is the use\n+ * {@code @TC int}, with an annotation {@code @TC}, representing the primitive\n+ * type {@code int}.\n+ * <p>\n+ * Two {@code AnnotatedArrayType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -40,1 +50,2 @@\n-     * {@return the potentially annotated component type of this array type}\n+     * {@return the potentially annotated use of the component type of the array\n+     * type}\n@@ -42,0 +53,1 @@\n+     * @see Class#componentType() Class::componentType\n@@ -44,1 +56,0 @@\n-     * @see Class#componentType() Class::componentType\n@@ -49,2 +60,1 @@\n-     * {@return {@code null}}  An {@code AnnotatedArrayType} is not an inner\n-     * member class.\n+     * {@return {@code null}}  An array type is not an inner member class.\n@@ -58,2 +68,3 @@\n-     * {@inheritDoc}  The underlying type of an {@code AnnotatedArrayType} is\n-     * a {@link Class} representing an array type or a {@link GenericArrayType}.\n+     * {@return the array type that this potentially annotated use represents}\n+     * Returns a {@link Class} representing an array type or a {@link\n+     * GenericArrayType}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedArrayType.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,1 +31,12 @@\n- * annotated uses of types.\n+ * annotated uses of type arguments.\n+ * <p>\n+ * For example, an annotated use {@code Outer<@TC Long>.@TA Inner<@TB String>}\n+ * has an annotation {@code @TA} and represents the parameterized type {@code\n+ * Outer<Long>.Inner<String>}, a class.  It has exactly one type argument, which\n+ * is the annotated use {@code @TB String}, with an annotation {@code @TB},\n+ * representing the {@code String} class.  The use of its immediately enclosing\n+ * class is {@code Outer<@TC Long>}, with no annotation, representing the\n+ * parameterized type {@code Outer<Long>}.\n+ * <p>\n+ * Two {@code AnnotatedParameterizedType} objects should be compared using the\n+ * {@link Object#equals equals} method.\n@@ -33,0 +44,1 @@\n+ * @see ParameterizedType\n@@ -39,2 +51,2 @@\n-     * {@return the potentially annotated actual type arguments of this\n-     * parameterized type}\n+     * {@return the potentially annotated use, as in the source code, of type\n+     * arguments of the parameterized type}\n@@ -42,7 +54,8 @@\n-     * This method does not return the type arguments of the {@linkplain\n-     * #getAnnotatedOwnerType() enclosing classes} of this type, if this is an\n-     * {@linkplain ParameterizedType##inner-member-class inner member class}.\n-     * For example, if this type is {@code @TA O<T>.I<S>}, this method\n-     * returns {@code [S]}.  In particular, if this inner member class is\n-     * non-generic but an enclosing class is, this method returns an empty\n-     * array.\n+     * This method does not return the potentially annotated use of type\n+     * arguments of the {@linkplain #getAnnotatedOwnerType() enclosing classes}\n+     * of the parameterized type, if the parameterized type is an {@linkplain\n+     * ParameterizedType##inner-member-class inner member class}.  For example,\n+     * if this use is {@code @TA O<T>.I<S>}, this method returns an array\n+     * containing exactly the use of {@code S}.  In particular, if this inner\n+     * member class is non-generic but an enclosing class of it is, this method\n+     * returns an empty array.\n@@ -55,1 +68,5 @@\n-     * {@inheritDoc}\n+     * {@return the potentially annotated use of the immediately enclosing class\n+     * of the parameterized type, or {@code null} if and only if the\n+     * parameterized type is not an inner member class}  For example, if this\n+     * use is {@code Outer<@TC Long>.@TA nner<@TB String>}, this method returns\n+     * a representation of {@code Outer<@TC Long>}.\n@@ -66,2 +83,2 @@\n-     * {@inheritDoc}  The underlying type of an {@code\n-     * AnnotatedParameterizedType} is a {@link ParameterizedType}.\n+     * {@return the parameterized type that this potentially annotated use\n+     * represents}  Returns a {@link ParameterizedType}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedParameterizedType.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -31,4 +31,32 @@\n- * {@code AnnotatedType} represents the potentially annotated use of a type in\n- * the program currently running in this VM. The use may be of any type in the\n- * Java programming language, including an array type, a parameterized type, a\n- * type variable, or a wildcard type.\n+ * {@code AnnotatedType} represents the potentially annotated (JLS {@jls 9.7.4})\n+ * use of a type or type argument in the current runtime. See {@link Type} for\n+ * the complete list of types and type arguments.\n+ * <p>\n+ * Here is a mapping from types and type arguments of the use, with examples,\n+ * to the modeling interfaces. \"{@code AnnotatedType} alone\" means the modeling\n+ * class does not implement any of the subinterfaces of {@code AnnotatedType}.\n+ * <ul>\n+ * <li>Primitive types (such as {@code @TA int}):\n+ *     {@code AnnotatedType} alone\n+ * <li>Reference types: <ul>\n+ *     <li>Class types and interface types:<ul>\n+ *         <li>Parameterized types (such as {@code @TA List<@TB ? extends @TC\n+ *             String>}): {@link AnnotatedParameterizedType}\n+ *         <li>Non-generic classes and interfaces (such as {@code @TC String})\n+ *             and raw types (such as {@code @TA List}):\n+ *             {@code AnnotatedType} alone\n+ *     <\/ul>\n+ *     <li>Type variables (such as {@code @TA T}):\n+ *         {@link AnnotatedTypeVariable}\n+ *     <li>Array types (such as {@code @TB int @TA []}):\n+ *         {@link AnnotatedArrayType}\n+ * <\/ul>\n+ * <li>Wildcard type arguments (such as {@code @TB ? extends @TC String}):\n+ *     {@link AnnotatedWildcardType}\n+ * <\/ul>\n+ * <p>\n+ * For example, an annotated use {@code @TB Outer.@TA Inner}, represented by\n+ * {@code AnnotatedType} alone, has an annotation {@code @TA} and represents the\n+ * non-generic {@code Outer.Inner} class. The use of its immediately enclosing\n+ * class is {@code @TB Outer}, with an annotation {@code @TB}, representing the\n+ * non-generic {@code Outer} class.\n@@ -39,0 +67,3 @@\n+ * <p>\n+ * Two {@code AnnotatedType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -40,22 +71,1 @@\n- * <h2 id=\"hierarchy\">Interface Hierarchy of {@code AnnotatedType}<\/h2>\n- * Annotated use of types in the Java programming language is modeled with these\n- * subinterfaces, and {@link #getType() getType()} can identify their underlying\n- * {@linkplain Type##hierarchy types}:\n- * <ul>\n- * <li>No particular subinterface models primitive types (JLS {@jls 4.2}) and\n- *     non-generic (JLS {@jls 4.5}) and raw types (JLS {@jls 4.8}) of classes\n- *     and interfaces (JLS {@jls 4.3}).  Their underlying type is {@link Class}.\n- * <li>{@link AnnotatedArrayType} models array types (JLS {@jls 10.1}). Their\n- *     underlying type is {@link Class} or {@link GenericArrayType}.\n- * <li>{@link AnnotatedParameterizedType} models parameterized types (JLS {@jls\n- *     4.4}), including non-generic {@linkplain #getAnnotatedOwnerType() inner\n- *     member classes} of generic classes.  Their underlying type is {@link\n- *     ParameterizedType}.\n- * <li>{@link AnnotatedTypeVariable} models type variable (JLS {@jls 4.4})\n- *     usages.  Their underlying type is {@link TypeVariable}.\n- * <li>{@link AnnotatedWildcardType} models wildcard {@linkplain\n- *     AnnotatedParameterizedType#getAnnotatedActualTypeArguments() type\n- *     arguments} (JLS {@jls 4.5.1}).  Their underlying type is {@link\n- *     AnnotatedWildcardType}.\n- * <\/ul>\n- *\n+ * @see Type\n@@ -76,3 +86,3 @@\n-     * of this type, or {@code null} if and only if this type is not an inner\n-     * member class}  For example, if this type is {@code @TA O<T>.I<S>}, this\n-     * method returns a representation of {@code @TA O<T>}.\n+     * of the type, or {@code null} if and only if the type is not an inner\n+     * member class}  For example, if this use is {@code @TB Outer.@TA Inner},\n+     * this method returns a representation of {@code @TB Outer}.\n@@ -97,4 +107,5 @@\n-     * {@return the underlying type that this annotated type represents}\n-     *\n-     * @see ##hierarchy Interface Hierarchy of {@code AnnotatedType}\n-     * @see Type##hierarchy Interface Hierarchy of {@code Type}\n+     * {@return the type that this potentially annotated use represents}\n+     * <p>\n+     * If this object does not implement any of the subinterfaces of {@code\n+     * AnnotatedType}, this use represents a primitive type, a non-generic class\n+     * or interface, or a raw type, and this method returns a {@link Class}.\n@@ -102,1 +113,1 @@\n-    public Type getType();\n+    Type getType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedType.java","additions":45,"deletions":34,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -30,2 +30,7 @@\n- * type variable, whose declaration may have bounds which themselves represent\n- * annotated uses of types.\n+ * type variable.\n+ * <p>\n+ * For example, an annotated use {@code @TA T} has an annotation {@code @TA}\n+ * and represents the type variable {@code T}.\n+ * <p>\n+ * Two {@code AnnotatedTypeVariable} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -33,0 +38,1 @@\n+ * @see TypeVariable\n@@ -39,3 +45,11 @@\n-     * Returns the potentially annotated bounds of this type variable.\n-     * If no bound is explicitly declared, the bound is unannotated\n-     * {@code Object}.\n+     * {@return the potentially annotated use of upper bounds of the type\n+     * variable}\n+     * <p>\n+     * Given an {@code AnnotatedTypeVariable tv}, the call {@code\n+     * tv.getAnnotatedBounds()} is equivalent to:\n+     * {@snippet lang=java :\n+     * \/\/ @link region substring=\"getType\" target=\"#getType()\"\n+     * \/\/ @link substring=\"getAnnotatedBounds\" target=\"TypeVariable#getAnnotatedBounds()\" :\n+     * ((TypeVariable<?>) tv.getType()).getAnnotatedBounds()\n+     * \/\/ @end\n+     * }\n@@ -43,1 +57,1 @@\n-     * @return the potentially annotated bounds of this type variable\n+     * @see TypeVariable#getAnnotatedBounds()\n@@ -49,2 +63,1 @@\n-     * {@return {@code null}}  An {@code AnnotatedTypeVariable} is not an inner\n-     * member class.\n+     * {@return {@code null}}  A type variable is not an inner member class.\n@@ -58,2 +71,2 @@\n-     * {@inheritDoc}  The underlying type of an {@code AnnotatedTypeVariable} is\n-     * a {@link TypeVariable}.\n+     * {@return the type variable that this potentially annotated use\n+     * represents}  Returns a {@link TypeVariable}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedTypeVariable.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,1 +31,12 @@\n- * annotated uses of types.\n+ * annotated uses of types.  Note that the use of a wildcard type argument is\n+ * not the use of a type, and thus will only be returned by APIs where uses of\n+ * type arguments may appear.\n+ * <p>\n+ * For example, an annotated use {@code @TA ? extends @TB Number} has an\n+ * annotation {@code @TA} and represents the wildcard type argument {@code ?\n+ * extends Number}.  Its lower bound is the annotated use {@code @TB Number}\n+ * with an annotation {@code @TB}, representing the {@code Number} class.  It\n+ * has no upper bound.\n+ * <p>\n+ * Two {@code AnnotatedWildcardType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -33,0 +44,1 @@\n+ * @see WildcardType\n@@ -39,3 +51,4 @@\n-     * Returns the potentially annotated lower bounds of this wildcard type.\n-     * If no lower bound is explicitly declared, the lower bound is the\n-     * type of null. In this case, a zero length array is returned.\n+     * {@return the potentially annotated use of lower bounds of the wildcard\n+     * type argument}  If no lower bound is explicitly declared, the lower bound\n+     * is the null type (JLS {@jls 4.1}) and the use is unannotated. In this\n+     * case, a zero length array is returned.\n@@ -43,3 +56,3 @@\n-     * @apiNote While to date a wildcard may have at most one lower\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one upper bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -47,2 +60,0 @@\n-     * @return the potentially annotated lower bounds of this wildcard type or\n-     * an empty array if no lower bound is explicitly declared.\n@@ -54,3 +65,3 @@\n-     * Returns the potentially annotated upper bounds of this wildcard type.\n-     * If no upper bound is explicitly declared, the upper bound is\n-     * unannotated {@code Object}\n+     * {@return the potentially annotated use of upper bounds of the wildcard\n+     * type argument}  If no upper bound is explicitly declared, the upper bound\n+     * is the {@code Object} class and the use is unannotated.\n@@ -58,3 +69,3 @@\n-     * @apiNote While to date a wildcard may have at most one upper\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one upper bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -62,1 +73,0 @@\n-     * @return the potentially annotated upper bounds of this wildcard type\n@@ -68,2 +78,2 @@\n-     * {@return {@code null}}  An {@code AnnotatedTypeVariable} is not an inner\n-     * member class.\n+     * {@return {@code null}}  A wildcard type argument is not an inner member\n+     * class.\n@@ -77,2 +87,2 @@\n-     * {@inheritDoc}  The underlying type of an {@code AnnotatedWildcardType} is\n-     * a {@link WildcardType}.\n+     * {@return the wildcard type argument that this potentially annotated use\n+     * represents}  Returns a {@link WildcardType}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedWildcardType.java","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,2 +29,7 @@\n- * {@code GenericArrayType} represents an array type whose component\n- * type is either a parameterized type or a type variable.\n+ * {@code GenericArrayType} represents an array type whose element\n+ * type is either a parameterized type, such as {@code Comparable<?>} for the\n+ * array type {@code Comparable<?>[]}, or a type variable, such as {@code T}\n+ * for the array type {@code T[][]}.\n+ * <p>\n+ * Two {@code GenericArrayType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -37,7 +42,8 @@\n-     * Returns a {@code Type} object representing the component type\n-     * of this array. This method creates the component type of the\n-     * array.  See the declaration of {@link\n-     * java.lang.reflect.ParameterizedType ParameterizedType} for the\n-     * semantics of the creation process for parameterized types and\n-     * see {@link java.lang.reflect.TypeVariable TypeVariable} for the\n-     * creation process for type variables.\n+     * {@return the component type of this array type}  The component type must\n+     * be one of {@link GenericArrayType}, {@link ParameterizedType}, or {@link\n+     * TypeVariable}.\n+     * <p>\n+     * This method creates the component type of the array.  See {@link\n+     * ParameterizedType} for the semantics of the creation process for\n+     * parameterized types and see {@link TypeVariable} for the creation process\n+     * for type variables.\n@@ -45,7 +51,4 @@\n-     * @return  a {@code Type} object representing the component type\n-     *     of this array\n-     * @throws TypeNotPresentException if the underlying array type's component\n-     *     type refers to a non-existent class or interface declaration\n-     * @throws MalformedParameterizedTypeException if  the\n-     *     underlying array type's component type refers to a\n-     *     parameterized type that cannot be instantiated for any reason\n+     * @throws TypeNotPresentException if the component type refers to a\n+     *     non-existent class or interface declaration\n+     * @throws MalformedParameterizedTypeException if the component type refers\n+     *     to a parameterized type that cannot be instantiated for any reason\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/GenericArrayType.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * Collection<String>}.\n+ * Collection<String>}.  A parameterized type is a class or interface.\n@@ -37,1 +37,1 @@\n- * {@code p} are created  recursively. See {@link TypeVariable} for details on\n+ * {@code p} are created recursively.  See {@link TypeVariable} for details on\n@@ -49,2 +49,1 @@\n-     * {@return an array of {@code Type} objects representing the actual type\n-     * arguments of this type}\n+     * {@return the type arguments of this type, as used in the source code}\n@@ -53,3 +52,4 @@\n-     * #getOwnerType() enclosing classes} of this type, if this is an inner\n-     * member class.  For example, if this type is {@code O<T>.I<S>}, this\n-     * method returns {@code [S]}.  In particular, if this inner member class is\n+     * #getOwnerType() enclosing classes} of this type, if this is an\n+     * {@linkplain ##inner-member-class inner member class}.  For example, if\n+     * this type is {@code O<T>.I<S>}, this method returns an array containing\n+     * exactly {@code S}.  In particular, if this inner member class is\n@@ -64,1 +64,0 @@\n-     * @since 1.5\n@@ -69,5 +68,2 @@\n-     * {@return the raw type of this type}  This is the generic class or\n-     * interface that defines this parameterized type, and applies recursively\n-     * to the {@linkplain #getOwnerType() immediately enclosing class} of this\n-     * type if there is one.  For example, if this type is {@code O<T>.I<S>},\n-     * this method returns a representation of {@code O.I}.\n+     * {@return the raw type of this type}  Returns a {@code Type} alone, which\n+     * is a {@link Class} in core reflection.\n@@ -75,7 +71,8 @@\n-     * This method performs type erasure.\n-     *\n-     * @apiNote\n-     * All {@code ParameterizedType} objects from core reflection return a\n-     * {@link Class}. The static {@code Type} return type allows other\n-     * implementations to represent classes and interfaces not in the current\n-     * runtime.\n+     * This is the generic class or interface that defines this parameterized\n+     * type, and applies recursively to the {@linkplain #getOwnerType()\n+     * immediately enclosing class} of this type if there is one.  For example,\n+     * if this type is {@code O<T>.I<S>}, this method returns a representation\n+     * of {@code O.I}.\n+     * <p>\n+     * This method performs type erasure (JLS {@jls 4.6}) for parameterized\n+     * types.\n@@ -83,1 +80,0 @@\n-     * @jls 4.6 Type Erasure\n@@ -85,1 +81,0 @@\n-     * @since 1.5\n@@ -97,3 +92,3 @@\n-     * member class (JLS {@jls 8.5}). Any object of an inner member class {@code\n-     * C} has an immediately enclosing instance (JLS {@jls 15.9.2}) of the\n-     * {@linkplain Class#getDeclaringClass() immediately enclosing class} of\n+     * member class (JLS {@jls 8.5}).  Any object of an inner member class\n+     * {@code C} has an immediately enclosing instance (JLS {@jls 15.9.2}) of\n+     * the {@linkplain Class#getDeclaringClass() immediately enclosing class} of\n@@ -113,1 +108,3 @@\n-     * Class<?> clazz = int.class; \/\/ @replace regex=\"int.class\" replacement=...\n+     * \/\/ @replace substring=\"int.class\" replacement=... :\n+     * Class<?> clazz = int.class;\n+     * \/\/ @link substring=\"getDeclaringClass\" target=\"Class#getDeclaringClass()\" :\n@@ -115,0 +112,2 @@\n+     * \/\/ @link region substring=\"isStatic\" target=\"Modifier#isStatic(int)\"\n+     * \/\/ @link substring=\"getModifiers\" target=\"Class#getModifiers()\":\n@@ -116,0 +115,1 @@\n+     * \/\/ @end\n@@ -126,1 +126,0 @@\n-     * @since 1.5\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ParameterizedType.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -29,6 +29,16 @@\n- * Type is the common superinterface for all types in the Java\n- * programming language. These include raw types, parameterized types,\n- * array types, type variables and primitive types.\n- *\n- * <h2 id=\"hierarchy\">Interface Hierarchy of {@code Type}<\/h2>\n- * Types in the Java programming language are modeled with these subinterfaces:\n+ * {@code Type} represents types in the Java programming language (JLS {@jls\n+ * 4.1}) and type arguments (JLS {@jls 4.5.1}).  Types are primitive types (JLS\n+ * {@jls 4.2}) and reference types (JLS {@jls 4.3}).  Reference types are\n+ * non-generic classes (JLS {@jls 8.1.2}) (which must not be an {@linkplain\n+ * ParameterizedType##inner-member-class inner member class} of a generic class)\n+ * and interfaces (JLS {@jls 9.1.2}), raw types (JLS {@jls 4.8}) and\n+ * parameterized types (JLS {@jls 4.5}) of generic classes and interfaces,\n+ * type variables (JLS {@jls 4.4}), and array types (JLS {@jls 10.1}).  Type\n+ * arguments are reference types and wildcard type arguments.\n+ * <p>\n+ * Here is a mapping from types and type arguments to the modeling interfaces.\n+ * \"{@code Type} alone\" means the modeling class does not implement any other\n+ * {@code Type} subinterface.  The modeling class is {@link Class} in core\n+ * reflection representation of types in the current runtime.  Other\n+ * implementations may use different modeling classes to represent types not\n+ * in the current runtime.\n@@ -36,15 +46,22 @@\n- * <li>No particular subinterface models primitive types (JLS {@jls 4.2}) and\n- *     non-generic (JLS {@jls 4.5}) and raw types (JLS {@jls 4.8}) of reference\n- *     types (JLS {@jls 4.3}), including classes and interfaces and array types.\n- *     Core reflection models these with {@link Class}.\n- * <li>{@link GenericArrayType} models array types (JLS {@jls 10.1}) with\n- *     generic component types.\n- * <li>{@link ParameterizedType} models parameterized types (JLS {@jls 4.4}),\n- *     including non-generic {@linkplain ParameterizedType##inner-member-class\n- *     inner member classes} of generic classes.\n- * <li>{@link TypeVariable} models type variables (JLS {@jls 4.4}), including\n- *     those from {@linkplain GenericDeclaration#getTypeParameters() type\n- *     parameter declarations}.\n- * <li>{@link WildcardType} models wildcard {@linkplain\n- *     ParameterizedType#getActualTypeArguments() type arguments} (JLS {@jls\n- *     4.5.1}).\n+ * <li>Primitive types (such as {@code int}): {@code Type} alone\n+ * <li>Reference types: <ul>\n+ *     <li>Class types and interface types:<ul>\n+ *         <li>Parameterized types (such as {@code List<String>}):\n+ *             {@link ParameterizedType}\n+ *         <li>Non-generic classes and interfaces (such as {@code String}) and\n+ *             raw types (such as {@code List}): {@code Type} alone\n+ *     <\/ul>\n+ *     <li>Type variables (such as {@code T}): {@link TypeVariable}\n+ *     <li>Array types: Depends on its element type. <ul>\n+ *         <li>If the element type is modeled by {@code Type} alone, such as\n+ *             {@code int} for the array type {@code int[]}, the array type is\n+ *             modeled by {@code Type} alone.\n+ *         <li>Otherwise, the element type must be modeled by {@link\n+ *             ParameterizedType}, such as {@code Comparable<?>} for the array\n+ *             type {@code Comparable<?>[]}, or {@link TypeVariable}, such as\n+ *             {@code T} for the array type {@code T[]}, and the array type is\n+ *             modeled by {@link GenericArrayType}.\n+ *     <\/ul>\n+ * <\/ul>\n+ * <li>Wildcard type arguments (such as {@code ? extends String}):\n+ *     {@link WildcardType}\n@@ -52,0 +69,3 @@\n+ * <p>\n+ * Two {@code Type} objects should be compared using the {@link Object#equals\n+ * equals} method.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Type.java","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+ * <p>\n+ * Two {@code TypeVariable} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -38,10 +41,1 @@\n- * <p>Multiple objects may be instantiated at run-time to\n- * represent a given type variable. Even though a type variable is\n- * created only once, this does not imply any requirement to cache\n- * instances representing the type variable. However, all instances\n- * representing a type variable must be equal() to each other.\n- * As a consequence, users of type variables must not rely on the identity\n- * of instances of classes implementing this interface.\n- *\n- * @param <D> the type of generic declaration that declared the\n- * underlying type variable.\n+ * @param <D> the type of generic declaration that declares this type variable\n@@ -54,3 +48,2 @@\n-     * Returns an array of {@code Type} objects representing the\n-     * upper bound(s) of this type variable.  If no upper bound is\n-     * explicitly declared, the upper bound is {@code Object}.\n+     * {@return the upper bounds of this type variable}  If no upper bound is\n+     * explicitly declared, the upper bound is the {@link Object} class.\n@@ -58,5 +51,7 @@\n-     * <p>For each upper bound B: <ul> <li>if B is a parameterized\n-     * type or a type variable, it is created, (see {@link\n-     * java.lang.reflect.ParameterizedType ParameterizedType} for the\n-     * details of the creation process for parameterized types).\n-     * <li>Otherwise, B is resolved.  <\/ul>\n+     * <p>For each upper bound B:\n+     * <ul>\n+     *  <li>if B is a parameterized type or a type variable, it is created.\n+     *  (see {@link ParameterizedType} and {@link TypeVariable} for the details\n+     *  of the creation process for parameterized types and type variables)\n+     *  <li>Otherwise, B is resolved.\n+     * <\/ul>\n@@ -64,7 +59,4 @@\n-     * @throws TypeNotPresentException  if any of the\n-     *     bounds refers to a non-existent type declaration\n-     * @throws MalformedParameterizedTypeException if any of the\n-     *     bounds refer to a parameterized type that cannot be instantiated\n-     *     for any reason\n-     * @return an array of {@code Type}s representing the upper\n-     *     bound(s) of this type variable\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n@@ -75,6 +67,1 @@\n-     * Returns the {@code GenericDeclaration} object representing the\n-     * generic declaration declared for this type variable.\n-     *\n-     * @return the generic declaration declared for this type variable.\n-     *\n-     * @since 1.5\n+     * {@return the generic declaration that declares this type variable}\n@@ -85,3 +72,2 @@\n-     * Returns the name of this type variable, as it occurs in the source code.\n-     *\n-     * @return the name of this type variable, as it appears in the source code\n+     * {@return the name of this type variable, as it appears in the source\n+     * code}\n@@ -92,6 +78,5 @@\n-     * Returns an array of AnnotatedType objects that represent the use of\n-     * types to denote the upper bounds of the type parameter represented by\n-     * this TypeVariable. The order of the objects in the array corresponds to\n-     * the order of the bounds in the declaration of the type parameter. Note that\n-     * if no upper bound is explicitly declared, the upper bound is unannotated\n-     * {@code Object}.\n+     * {@return the potentially annotated uses of upper bounds of the type\n+     * variable}  They are ordered as they appear in the declaration of the\n+     * type parameter in the source code.  If no bound is explicitly declared,\n+     * this method returns an array containing exactly the unannotated use of\n+     * the {@code Object} class.\n@@ -99,1 +84,0 @@\n-     * @return an array of objects representing the upper bound(s) of the type variable\n@@ -102,1 +86,1 @@\n-     AnnotatedType[] getAnnotatedBounds();\n+    AnnotatedType[] getAnnotatedBounds();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/TypeVariable.java","additions":26,"deletions":42,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -29,2 +29,7 @@\n- * WildcardType represents a wildcard type expression, such as\n- * {@code ?}, {@code ? extends Number}, or {@code ? super Integer}.\n+ * {@code WildcardType} represents a wildcard type argument, such as {@code ?},\n+ * {@code ? extends Number}, or {@code ? super Integer}.  Since a wildcard type\n+ * argument is not a type, and it will only be returned by APIs where type\n+ * arguments may appear.\n+ * <p>\n+ * Two {@code WildcardType} objects should be compared using the {@link\n+ * Object#equals equals} method.\n@@ -37,3 +42,3 @@\n-     * Returns an array of {@code Type} objects representing the  upper\n-     * bound(s) of this type variable.  If no upper bound is\n-     * explicitly declared, the upper bound is {@code Object}.\n+     * {@return the upper bounds of this wildcard type argument}  If no upper\n+     * bound is explicitly declared, the upper bound is the {@link Object}\n+     * class.\n@@ -41,1 +46,1 @@\n-     * <p>For each upper bound B :\n+     * <p>For each upper bound B:\n@@ -43,3 +48,3 @@\n-     *  <li>if B is a parameterized type or a type variable, it is created,\n-     *  (see {@link java.lang.reflect.ParameterizedType ParameterizedType}\n-     *  for the details of the creation process for parameterized types).\n+     *  <li>if B is a parameterized type or a type variable, it is created.\n+     *  (see {@link ParameterizedType} and {@link TypeVariable} for the details\n+     *  of the creation process for parameterized types and type variables)\n@@ -49,3 +54,3 @@\n-     * @apiNote While to date a wildcard may have at most one upper\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one upper bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -53,7 +58,4 @@\n-     * @return an array of Types representing the upper bound(s) of this\n-     *     type variable\n-     * @throws TypeNotPresentException if any of the\n-     *     bounds refers to a non-existent type declaration\n-     * @throws MalformedParameterizedTypeException if any of the\n-     *     bounds refer to a parameterized type that cannot be instantiated\n-     *     for any reason\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n@@ -64,4 +66,3 @@\n-     * Returns an array of {@code Type} objects representing the\n-     * lower bound(s) of this type variable.  If no lower bound is\n-     * explicitly declared, the lower bound is the type of {@code null}.\n-     * In this case, a zero length array is returned.\n+     * {@return the lower bounds of this wildcard type argument}  If no lower\n+     * bound is explicitly declared, the lower bound is the null type (JLS\n+     * {@jls 4.1}).  In this case, a zero length array is returned.\n@@ -69,1 +70,1 @@\n-     * <p>For each lower bound B :\n+     * <p>For each lower bound B:\n@@ -71,4 +72,4 @@\n-     *   <li>if B is a parameterized type or a type variable, it is created,\n-     *  (see {@link java.lang.reflect.ParameterizedType ParameterizedType}\n-     *  for the details of the creation process for parameterized types).\n-     *   <li>Otherwise, B is resolved.\n+     *  <li>if B is a parameterized type or a type variable, it is created.\n+     *  (see {@link ParameterizedType} and {@link TypeVariable} for the details\n+     *  of the creation process for parameterized types and type variables)\n+     *  <li>Otherwise, B is resolved.\n@@ -77,3 +78,3 @@\n-     * @apiNote While to date a wildcard may have at most one lower\n-     * bound, callers of this method should be written to accommodate\n-     * multiple bounds.\n+     * @apiNote\n+     * While to date a wildcard type argument may have at most one upper bound,\n+     * callers of this method should be written to accommodate multiple bounds.\n@@ -81,7 +82,4 @@\n-     * @return an array of Types representing the lower bound(s) of this\n-     *     type variable\n-     * @throws TypeNotPresentException if any of the\n-     *     bounds refers to a non-existent type declaration\n-     * @throws MalformedParameterizedTypeException if any of the\n-     *     bounds refer to a parameterized type that cannot be instantiated\n-     *     for any reason\n+     * @throws TypeNotPresentException if any of the bounds refers to a\n+     *     non-existent type declaration\n+     * @throws MalformedParameterizedTypeException if any of the bounds refer to\n+     *     a parameterized type that cannot be instantiated for any reason\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/WildcardType.java","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"}]}