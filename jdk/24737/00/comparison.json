{"files":[{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toSet;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class ExecutorTest extends JUnitAdapter {\n+\n+    private record Command(List<String> stdout, List<String> stderr) {\n+        Command {\n+            stdout.forEach(Objects::requireNonNull);\n+            stderr.forEach(Objects::requireNonNull);\n+        }\n+\n+        List<String> asExecutable() {\n+            final List<String> commandline = new ArrayList<>();\n+            if (TKit.isWindows()) {\n+                commandline.addAll(List.of(\"cmd\", \"\/C\"));\n+            } else {\n+                commandline.addAll(List.of(\"sh\", \"-c\"));\n+            }\n+            commandline.add(Stream.concat(createEchoCommands(stdout),\n+                    createEchoCommands(stderr).map(v -> v + \">&2\")).collect(joining(\" && \")));\n+            return commandline;\n+        }\n+\n+        private static Stream<String> createEchoCommands(List<String> lines) {\n+            return lines.stream().map(line -> {\n+                if (TKit.isWindows()) {\n+                    return \"(echo \" + line + \")\";\n+                } else {\n+                    return \"echo \" + line;\n+                }\n+            });\n+        }\n+\n+        ToolProvider asToolProvider() {\n+            return new ToolProvider() {\n+\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    stdout.forEach(out::println);\n+                    stderr.forEach(err::println);\n+                    return 0;\n+                }\n+\n+                @Override\n+                public String name() {\n+                    return \"test\";\n+                }\n+            };\n+        }\n+    }\n+\n+    private enum OutputData {\n+        EMPTY(List.of()),\n+        ONE_LINE(List.of(\"Jupiter\")),\n+        MANY(List.of(\"Uranus\", \"Saturn\", \"Earth\"));\n+\n+        OutputData(List<String> data) {\n+            data.forEach(Objects::requireNonNull);\n+            this.data = data;\n+        }\n+\n+        final List<String> data;\n+    }\n+\n+    private record CommandSpec(OutputData stdout, OutputData stderr) {\n+        CommandSpec {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        Command command() {\n+            return new Command(stdout.data.stream().map(line -> {\n+                return \"stdout.\" + line;\n+            }).toList(), stderr.data.stream().map(line -> {\n+                return \"stderr.\" + line;\n+            }).toList());\n+        }\n+    }\n+\n+    public enum OutputControl {\n+        DUMP(Executor::dumpOutput),\n+        SAVE_ALL(Executor::saveOutput),\n+        SAVE_FIRST_LINE(Executor::saveFirstLineOfOutput),\n+        DISCARD_STDOUT(NOP),\n+        DISCARD_STDERR(NOP),\n+        ;\n+\n+        OutputControl(Consumer<Executor> configureExector) {\n+            this.configureExector = Objects.requireNonNull(configureExector);\n+        }\n+\n+        Executor applyTo(Executor exec) {\n+            configureExector.accept(exec);\n+            return exec;\n+        }\n+\n+        static List<Set<OutputControl>> variants() {\n+            final List<Set<OutputControl>> variants = new ArrayList<>();\n+            for (final var withDump : BOOLEAN_VALUES) {\n+                variants.addAll(Stream.of(\n+                        Set.<OutputControl>of(),\n+                        Set.of(SAVE_ALL),\n+                        Set.of(SAVE_FIRST_LINE),\n+                        Set.of(DISCARD_STDOUT),\n+                        Set.of(DISCARD_STDERR),\n+                        Set.of(SAVE_ALL, DISCARD_STDOUT),\n+                        Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT),\n+                        Set.of(SAVE_ALL, DISCARD_STDERR),\n+                        Set.of(SAVE_FIRST_LINE, DISCARD_STDERR),\n+                        Set.of(SAVE_ALL, DISCARD_STDOUT, DISCARD_STDERR),\n+                        Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT, DISCARD_STDERR)\n+                ).map(v -> {\n+                    if (withDump) {\n+                        return Stream.concat(Stream.of(DUMP), v.stream()).collect(toSet());\n+                    } else {\n+                        return v;\n+                    }\n+                }).toList());\n+            }\n+            return variants.stream().map(options -> {\n+                return options.stream().filter(o -> {\n+                    return o.configureExector != NOP;\n+                }).collect(toSet());\n+            }).distinct().toList();\n+        }\n+\n+        private final Consumer<Executor> configureExector;\n+\n+        static final Set<OutputControl> SAVE = Set.of(SAVE_ALL, SAVE_FIRST_LINE);\n+    }\n+\n+    public record OutputTestSpec(boolean toolProvider, Set<OutputControl> outputControl, CommandSpec commandSpec) {\n+        public OutputTestSpec {\n+            outputControl.forEach(Objects::requireNonNull);\n+            if (outputControl.containsAll(OutputControl.SAVE)) {\n+                throw new IllegalArgumentException();\n+            }\n+            Objects.requireNonNull(commandSpec);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final List<String> tokens = new ArrayList<>();\n+\n+            if (toolProvider) {\n+                tokens.add(\"tool-provider\");\n+            }\n+\n+            tokens.add(\"output=\" + format(outputControl));\n+            tokens.add(\"command=\" + commandSpec);\n+\n+            return String.join(\",\", tokens.toArray(String[]::new));\n+        }\n+\n+        void test() {\n+            final var command = commandSpec.command();\n+            final var commandWithDiscardedStreams = discardStreams(command);\n+\n+            final Executor.Result[] result = new Executor.Result[1];\n+            final var outputCapture = OutputCapture.captureOutput(() -> {\n+                result[0] = createExecutor(command).executeWithoutExitCodeCheck();\n+            });\n+\n+            assertEquals(0, result[0].getExitCode());\n+\n+            assertEquals(expectedCapturedSystemOut(commandWithDiscardedStreams), outputCapture.outLines());\n+            assertEquals(expectedCapturedSystemErr(commandWithDiscardedStreams), outputCapture.errLines());\n+\n+            if (!saveOutput()) {\n+                assertNull(result[0].getOutput());\n+            } else {\n+                assertNotNull(result[0].getOutput());\n+                final var allExpectedOutput = expectedCommandOutput(command);\n+                assertEquals(allExpectedOutput.isEmpty(), result[0].getOutput().isEmpty());\n+                if (!allExpectedOutput.isEmpty()) {\n+                    if (outputControl.contains(OutputControl.SAVE_ALL)) {\n+                        assertEquals(allExpectedOutput, result[0].getOutput());\n+                    } else if (outputControl.contains(OutputControl.SAVE_FIRST_LINE)) {\n+                        assertEquals(1, result[0].getOutput().size());\n+                        assertEquals(allExpectedOutput.getFirst(), result[0].getFirstLineOfOutput());\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private boolean dumpOutput() {\n+            return outputControl.contains(OutputControl.DUMP);\n+        }\n+\n+        private boolean saveOutput() {\n+            return !Collections.disjoint(outputControl, OutputControl.SAVE);\n+        }\n+\n+        private boolean discardStdout() {\n+            return outputControl.contains(OutputControl.DISCARD_STDOUT);\n+        }\n+\n+        private boolean discardStderr() {\n+            return outputControl.contains(OutputControl.DISCARD_STDERR);\n+        }\n+\n+        private static String format(Set<OutputControl> outputControl) {\n+            return outputControl.stream().map(OutputControl::name).sorted().collect(joining(\"+\"));\n+        }\n+\n+        private List<String> expectedCapturedSystemOut(Command command) {\n+            if (!dumpOutput() || (!toolProvider && !saveOutput())) {\n+                return List.of();\n+            } else if(saveOutput()) {\n+                return Stream.concat(command.stdout().stream(), command.stderr().stream()).toList();\n+            } else {\n+                return command.stdout();\n+            }\n+        }\n+\n+        private List<String> expectedCapturedSystemErr(Command command) {\n+            if (!dumpOutput() || (!toolProvider && !saveOutput())) {\n+                return List.of();\n+            } else if(saveOutput()) {\n+                return List.of();\n+            } else {\n+                return command.stderr();\n+            }\n+        }\n+\n+        private Command discardStreams(Command command) {\n+            return new Command(discardStdout() ? List.of() : command.stdout(), discardStderr() ? List.of() : command.stderr());\n+        }\n+\n+        private record OutputCapture(byte[] out, byte[] err, Charset outCharset, Charset errCharset) {\n+            OutputCapture {\n+                Objects.requireNonNull(out);\n+                Objects.requireNonNull(err);\n+                Objects.requireNonNull(outCharset);\n+                Objects.requireNonNull(errCharset);\n+            }\n+\n+            List<String> outLines() {\n+                return toLines(out, outCharset);\n+            }\n+\n+            List<String> errLines() {\n+                return toLines(err, errCharset);\n+            }\n+\n+            private static List<String> toLines(byte[] buf, Charset charset) {\n+                try (var reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(buf), charset))) {\n+                    return reader.lines().filter(line -> {\n+                        return !line.contains(\"TRACE\");\n+                    }).toList();\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            }\n+\n+            static OutputCapture captureOutput(Runnable runnable) {\n+                final var captureOut = new ByteArrayOutputStream();\n+                final var captureErr = new ByteArrayOutputStream();\n+\n+                final var out = System.out;\n+                final var err = System.err;\n+                try {\n+                    final var outCharset = System.out.charset();\n+                    final var errCharset = System.err.charset();\n+                    System.setOut(new PrintStream(captureOut, true, outCharset));\n+                    System.setErr(new PrintStream(captureErr, true, errCharset));\n+                    runnable.run();\n+                    return new OutputCapture(captureOut.toByteArray(), captureErr.toByteArray(), outCharset, errCharset);\n+                } finally {\n+                    try {\n+                        System.setOut(out);\n+                    } finally {\n+                        System.setErr(err);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private List<String> expectedCommandOutput(Command command) {\n+            command = discardStreams(command);\n+            return Stream.of(command.stdout(), command.stderr()).flatMap(List::stream).toList();\n+        }\n+\n+        private Executor createExecutor(Command command) {\n+            final Executor exec;\n+            if (toolProvider) {\n+                exec = Executor.of(command.asToolProvider());\n+            } else {\n+                exec = Executor.of(command.asExecutable());\n+            }\n+\n+            outputControl.forEach(control -> control.applyTo(exec));\n+\n+            return exec;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSavedOutput(OutputTestSpec spec) {\n+        spec.test();\n+    }\n+\n+    public static List<OutputTestSpec> testSavedOutput() {\n+        List<OutputTestSpec> testCases = new ArrayList<>();\n+        for (final var toolProvider : BOOLEAN_VALUES) {\n+            for (final var outputControl : OutputControl.variants()) {\n+                for (final var stdoutContent : List.of(OutputData.values())) {\n+                    for (final var stderrContent : List.of(OutputData.values())) {\n+                        final var commandSpec = new CommandSpec(stdoutContent, stderrContent);\n+                        testCases.add(new OutputTestSpec(toolProvider, outputControl, commandSpec));\n+                    }\n+                }\n+            }\n+        }\n+        return testCases;\n+    }\n+\n+    private static final List<Boolean> BOOLEAN_VALUES = List.of(Boolean.TRUE, Boolean.FALSE);\n+    private static final Consumer<Executor> NOP = exec -> {};\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ExecutorTest.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.io.Writer;\n@@ -34,1 +35,0 @@\n-import java.util.Arrays;\n@@ -53,2 +53,10 @@\n-        return new Executor().setExecutable(cmdline[0]).addArguments(\n-                Arrays.copyOfRange(cmdline, 1, cmdline.length));\n+        return of(List.of(cmdline));\n+    }\n+\n+    public static Executor of(List<String> cmdline) {\n+        cmdline.forEach(Objects::requireNonNull);\n+        return new Executor().setExecutable(cmdline.getFirst()).addArguments(cmdline.subList(1, cmdline.size()));\n+    }\n+\n+    public static Executor of(ToolProvider toolProvider, String... args) {\n+        return new Executor().setToolProvider(toolProvider).addArguments(List.of(args));\n@@ -417,2 +425,2 @@\n-                    outputLines = Arrays.asList(\n-                            outReader.lines().findFirst().orElse(null));\n+                    outputLines = Optional.ofNullable(outReader.readLine()).map(List::of).orElseGet(List::of);\n+                    outReader.transferTo(Writer.nullWriter());\n@@ -478,0 +486,1 @@\n+            final var bufAsString = buf.toString();\n@@ -479,1 +488,1 @@\n-                    buf.toString()))) {\n+                    bufAsString))) {\n@@ -481,6 +490,1 @@\n-                    String firstLine = bufReader.lines().findFirst().orElse(null);\n-                    if (firstLine != null) {\n-                        output = List.of(firstLine);\n-                    } else {\n-                        output = null;\n-                    }\n+                    output = bufReader.lines().findFirst().map(List::of).orElseGet(List::of);\n@@ -498,1 +502,1 @@\n-                        lines = bufReader.lines();\n+                        lines = new BufferedReader(new StringReader(bufAsString)).lines();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"}]}