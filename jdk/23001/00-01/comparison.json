{"files":[{"patch":"@@ -328,11 +328,0 @@\n-  test-macos-x64:\n-    name: macos-x64\n-    needs:\n-      - build-macos-x64\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: macos-x64\n-      bootjdk-platform: macos-x64\n-      runs-on: macos-13\n-      xcode-toolset-version: '14.3.1'\n-\n","filename":".github\/workflows\/main.yml","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -506,1 +506,1 @@\n-  ldr(r2, Address(r1, Method::access_flags_offset()));\n+  ldrh(r2, Address(r1, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -763,1 +763,1 @@\n-      __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));\n+      __ ldrh(rscratch1, Address(rmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -812,1 +812,1 @@\n-    __ ldrw(r0, access_flags);\n+    __ ldrh(r0, access_flags);\n@@ -823,1 +823,1 @@\n-    __ ldrw(r0, access_flags);\n+    __ ldrh(r0, access_flags);\n@@ -1228,1 +1228,1 @@\n-  __ ldrw(r0, access_flags);\n+  __ ldrh(r0, access_flags);\n@@ -1280,1 +1280,1 @@\n-      __ ldrw(r0, access_flags);\n+      __ ldrh(r0, access_flags);\n@@ -1357,1 +1357,1 @@\n-    __ ldrw(t, Address(rmethod, Method::access_flags_offset()));\n+    __ ldrh(t, Address(rmethod, Method::access_flags_offset()));\n@@ -1567,1 +1567,1 @@\n-    __ ldrw(t, Address(rmethod, Method::access_flags_offset()));\n+    __ ldrh(t, Address(rmethod, Method::access_flags_offset()));\n@@ -1698,1 +1698,1 @@\n-  __ ldrw(r0, access_flags);\n+  __ ldrh(r0, access_flags);\n@@ -1754,1 +1754,1 @@\n-      __ ldrw(r0, access_flags);\n+      __ ldrh(r0, access_flags);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -739,1 +739,1 @@\n-  ldr_u32(Raccess_flags, Address(Rmethod, Method::access_flags_offset()));\n+  ldrh(Raccess_flags, Address(Rmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -582,1 +582,1 @@\n-      __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+      __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -591,1 +591,1 @@\n-    __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+    __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -854,1 +854,1 @@\n-  __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+  __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -896,1 +896,1 @@\n-        __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+        __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -978,1 +978,1 @@\n-    __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+    __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -1207,1 +1207,1 @@\n-  __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+  __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -1252,1 +1252,1 @@\n-        __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+        __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -684,1 +684,1 @@\n-    lwz(Raccess_flags, in_bytes(Method::access_flags_offset()), R19_method);\n+    lhz(Raccess_flags, in_bytes(Method::access_flags_offset()), R19_method);\n@@ -691,1 +691,1 @@\n-    rldicl_(R0, Raccess_flags, 64-JVM_ACC_SYNCHRONIZED_BIT, 63); \/\/ Extract bit and compare to 0.\n+    testbitdi(CCR0, R0, Raccess_flags, JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1205,1 +1205,1 @@\n-      __ lwz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n+      __ lhz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,3 +147,3 @@\n-    \/\/ _access_flags must be a 32 bit value.\n-    assert(sizeof(AccessFlags) == 4, \"wrong size\");\n-    __ lwa(R11_scratch1\/*access_flags*\/, method_(access_flags));\n+    \/\/ _access_flags must be a 16 bit value.\n+    assert(sizeof(AccessFlags) == 2, \"wrong size\");\n+    __ lhz(R11_scratch1\/*access_flags*\/, method_(access_flags));\n@@ -826,1 +826,1 @@\n-      __ lwz(Rflags, method_(access_flags));\n+      __ lhz(Rflags, method_(access_flags));\n@@ -1304,2 +1304,2 @@\n-  assert(4 == sizeof(AccessFlags), \"unexpected field size\");\n-  __ lwz(access_flags, method_(access_flags));\n+  assert(2 == sizeof(AccessFlags), \"unexpected field size\");\n+  __ lhz(access_flags, method_(access_flags));\n@@ -1772,1 +1772,1 @@\n-    __ lwz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n+    __ lhz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static bool supports_shared_stubs() { return false; }\n+  static bool supports_shared_stubs() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -547,1 +547,1 @@\n-  ld(x12, Address(x11, Method::access_flags_offset()));\n+  load_unsigned_short(x12, Address(x11, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,1 +644,1 @@\n-      __ lwu(t0, Address(xmethod, Method::access_flags_offset()));\n+      __ load_unsigned_short(t0, Address(xmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -717,1 +717,1 @@\n-  __ lwu(x10, access_flags);\n+  __ load_unsigned_short(x10, access_flags);\n@@ -724,1 +724,1 @@\n-    __ lwu(x10, access_flags);\n+    __ load_unsigned_short(x10, access_flags);\n@@ -1031,1 +1031,1 @@\n-  __ lwu(x10, access_flags);\n+  __ load_unsigned_short(x10, access_flags);\n@@ -1069,1 +1069,1 @@\n-    __ lwu(x10, access_flags);\n+    __ load_unsigned_short(x10, access_flags);\n@@ -1133,1 +1133,1 @@\n-    __ lwu(t, Address(xmethod, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(xmethod, Method::access_flags_offset()));\n@@ -1349,1 +1349,1 @@\n-    __ lwu(t, Address(xmethod, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(xmethod, Method::access_flags_offset()));\n@@ -1475,1 +1475,1 @@\n-  __ lwu(x10, access_flags);\n+  __ load_unsigned_short(x10, access_flags);\n@@ -1522,1 +1522,1 @@\n-    __ lwu(x10, access_flags);\n+    __ load_unsigned_short(x10, access_flags);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -783,1 +783,1 @@\n-    testbit(method2_(R_method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+    testbit_ushort(method2_(R_method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1018,0 +1018,12 @@\n+\/\/ Test a bit in memory for 2 byte datatype.\n+void MacroAssembler::testbit_ushort(const Address &a, unsigned int bit) {\n+  assert(a.index() == noreg, \"no index reg allowed in testbit\");\n+  if (bit <= 7) {\n+    z_tm(a.disp() + 1, a.base(), 1 << bit);\n+  } else if (bit <= 15) {\n+    z_tm(a.disp() + 0, a.base(), 1 << (bit - 8));\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,0 +202,1 @@\n+  void testbit_ushort(const Address &a, unsigned int bit);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2398,1 +2398,1 @@\n-      __ testbit(Address(Z_method, Method::access_flags_offset()), JVM_ACC_STATIC_BIT);\n+      __ testbit_ushort(Address(Z_method, Method::access_flags_offset()), JVM_ACC_STATIC_BIT);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-    __ testbit(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n+    __ testbit_ushort(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n@@ -886,1 +886,1 @@\n-    __ testbit(method2_(method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+    __ testbit_ushort(method2_(method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n@@ -900,1 +900,1 @@\n-    __ testbit(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n+    __ testbit_ushort(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n@@ -1352,0 +1352,2 @@\n+  \/\/ _access_flags must be a 16 bit value.\n+  assert(sizeof(AccessFlags) == 2, \"testbit_ushort will fail\");\n@@ -1354,1 +1356,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_NATIVE_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_NATIVE_BIT);\n@@ -1360,1 +1362,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n@@ -1406,1 +1408,1 @@\n-      __ testbit(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+      __ testbit_ushort(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n@@ -1464,1 +1466,1 @@\n-    __ testbit(method2_(Rmethod, access_flags), JVM_ACC_STATIC_BIT);\n+    __ testbit_ushort(method2_(Rmethod, access_flags), JVM_ACC_STATIC_BIT);\n@@ -1722,1 +1724,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_NATIVE_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_NATIVE_BIT);\n@@ -1728,1 +1730,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n@@ -1778,1 +1780,1 @@\n-      __ testbit(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+      __ testbit_ushort(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1033,1 +1033,1 @@\n-  movl(rcx, Address(rcx, Method::access_flags_offset()));\n+  load_unsigned_short(rcx, Address(rcx, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1102,1 +1102,1 @@\n-      __ movl(flags, Address(method, Method::access_flags_offset()));\n+      __ load_unsigned_short(flags, Address(method, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -599,1 +599,1 @@\n-    __ movl(rax, access_flags);\n+    __ load_unsigned_short(rax, access_flags);\n@@ -610,1 +610,1 @@\n-    __ movl(rax, access_flags);\n+    __ load_unsigned_short(rax, access_flags);\n@@ -858,1 +858,1 @@\n-  __ movl(rax, access_flags);\n+  __ load_unsigned_short(rax, access_flags);\n@@ -912,1 +912,1 @@\n-      __ movl(rax, access_flags);\n+      __ load_unsigned_short(rax, access_flags);\n@@ -1002,1 +1002,1 @@\n-    __ movl(t, Address(method, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(method, Method::access_flags_offset()));\n@@ -1283,1 +1283,1 @@\n-    __ movl(t, Address(method, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(method, Method::access_flags_offset()));\n@@ -1435,1 +1435,1 @@\n-  __ movl(rax, access_flags);\n+  __ load_unsigned_short(rax, access_flags);\n@@ -1492,1 +1492,1 @@\n-      __ movl(rax, access_flags);\n+      __ load_unsigned_short(rax, access_flags);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        __ movl(rscratch1, Address(rbx, Method::access_flags_offset()));\n+        __ load_unsigned_short(rscratch1, Address(rbx, Method::access_flags_offset()));\n@@ -162,1 +162,1 @@\n-  __ movl(c_rarg3, Address(rbx, Method::access_flags_offset()));\n+  __ load_unsigned_short(c_rarg3, Address(rbx, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1340,1 +1340,1 @@\n-  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_INT), result);\n+  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_CHAR), result);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -512,6 +512,3 @@\n-    \/\/ copy shared path table to saved.\n-    if (!HAS_PENDING_EXCEPTION) {\n-      VM_PopulateDynamicDumpSharedSpace op(archive_name);\n-      VMThread::execute(&op);\n-      return;\n-    }\n+    VM_PopulateDynamicDumpSharedSpace op(archive_name);\n+    VMThread::execute(&op);\n+    return;\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  st->print(\" flags=%x\", _flags);\n+  st->print(\" flags=%x\", _flags.as_unsigned_short());\n","filename":"src\/hotspot\/share\/ci\/ciFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"jvm_constants.h\"\n@@ -42,1 +41,1 @@\n-  jint _flags;\n+  AccessFlags _flags;\n@@ -44,1 +43,1 @@\n-  bool _intialized_final_update;\n+  bool _initialized_final_update;\n@@ -46,1 +45,1 @@\n-  ciFlags() :_flags(0), _stable(false), _intialized_final_update(false) { }\n+  ciFlags() :_flags(0), _stable(false), _initialized_final_update(false) { }\n@@ -48,1 +47,1 @@\n-    _flags(flags.as_int()), _stable(is_stable), _intialized_final_update(is_initialized_final_update) { }\n+    _flags(flags), _stable(is_stable), _initialized_final_update(is_initialized_final_update) { }\n@@ -52,12 +51,12 @@\n-  bool is_public               () const { return (_flags & JVM_ACC_PUBLIC                    ) != 0; }\n-  bool is_private              () const { return (_flags & JVM_ACC_PRIVATE                   ) != 0; }\n-  bool is_protected            () const { return (_flags & JVM_ACC_PROTECTED                 ) != 0; }\n-  bool is_static               () const { return (_flags & JVM_ACC_STATIC                    ) != 0; }\n-  bool is_final                () const { return (_flags & JVM_ACC_FINAL                     ) != 0; }\n-  bool is_synchronized         () const { return (_flags & JVM_ACC_SYNCHRONIZED              ) != 0; }\n-  bool is_super                () const { return (_flags & JVM_ACC_SUPER                     ) != 0; }\n-  bool is_volatile             () const { return (_flags & JVM_ACC_VOLATILE                  ) != 0; }\n-  bool is_transient            () const { return (_flags & JVM_ACC_TRANSIENT                 ) != 0; }\n-  bool is_native               () const { return (_flags & JVM_ACC_NATIVE                    ) != 0; }\n-  bool is_interface            () const { return (_flags & JVM_ACC_INTERFACE                 ) != 0; }\n-  bool is_abstract             () const { return (_flags & JVM_ACC_ABSTRACT                  ) != 0; }\n+  bool is_public               () const { return _flags.is_public();       }\n+  bool is_private              () const { return _flags.is_private();      }\n+  bool is_protected            () const { return _flags.is_protected();    }\n+  bool is_static               () const { return _flags.is_static();       }\n+  bool is_final                () const { return _flags.is_final();        }\n+  bool is_synchronized         () const { return _flags.is_synchronized(); }\n+  bool is_super                () const { return _flags.is_super();        }\n+  bool is_volatile             () const { return _flags.is_volatile();     }\n+  bool is_transient            () const { return _flags.is_transient();    }\n+  bool is_native               () const { return _flags.is_native();       }\n+  bool is_interface            () const { return _flags.is_interface();    }\n+  bool is_abstract             () const { return _flags.is_abstract();     }\n@@ -69,1 +68,1 @@\n-  bool has_initialized_final_update() const { return _intialized_final_update; };\n+  bool has_initialized_final_update() const { return _initialized_final_update; };\n@@ -72,1 +71,1 @@\n-  jint   as_int()                      { return _flags; }\n+  jint   as_int()                      { return _flags.as_unsigned_short(); }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-    return get_Klass()->access_flags().as_int();\n+    return get_Klass()->access_flags().as_unsigned_short();\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2984,1 +2984,1 @@\n-    jint flags;\n+    u2 flags;\n@@ -3001,1 +3001,1 @@\n-    inner_classes->at_put(index++, inner_access_flags.as_short());\n+    inner_classes->at_put(index++, inner_access_flags.as_unsigned_short());\n@@ -3753,1 +3753,1 @@\n-  int computed_modifiers = this_klass->compute_modifier_flags();\n+  u2 computed_modifiers = this_klass->compute_modifier_flags();\n@@ -5339,1 +5339,1 @@\n-  assert(0 == _access_flags.as_int(), \"invariant\");\n+  assert(0 == _access_flags.as_unsigned_short(), \"invariant\");\n@@ -5491,1 +5491,1 @@\n-  jint flags;\n+  u2 flags;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3172,1 +3172,1 @@\n-  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  int flags = m->access_flags().as_method_flags();\n@@ -5540,1 +5540,1 @@\n-    tty->print_cr(\"  name: %s, sig: %s, flags: %08x\", fs.name()->as_C_string(), fs.signature()->as_C_string(), fs.access_flags().as_int());\n+    tty->print_cr(\"  name: %s, sig: %s, flags: %08x\", fs.name()->as_C_string(), fs.signature()->as_C_string(), fs.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-inline bool match_F_R(jshort flags) {\n+inline bool match_F_R(u2 flags) {\n@@ -45,1 +45,1 @@\n-inline bool match_F_Y(jshort flags) {\n+inline bool match_F_Y(u2 flags) {\n@@ -51,1 +51,1 @@\n-inline bool match_F_RN(jshort flags) {\n+inline bool match_F_RN(u2 flags) {\n@@ -57,1 +57,1 @@\n-inline bool match_F_S(jshort flags) {\n+inline bool match_F_S(u2 flags) {\n@@ -63,1 +63,1 @@\n-inline bool match_F_SN(jshort flags) {\n+inline bool match_F_SN(u2 flags) {\n@@ -714,1 +714,1 @@\n-                                            jshort flags) {\n+                                            u2 flags) {\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1497,1 +1497,1 @@\n-                         jshort flags);\n+                         u2 flags);\n@@ -1508,1 +1508,1 @@\n-                    jshort flags) {\n+                    u2 flags) {\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-      increment_total_full_collections();\n+      _total_full_collections++;\n@@ -390,2 +390,0 @@\n-  void increment_total_full_collections() { _total_full_collections++; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -586,1 +586,1 @@\n-    jint new_flags = flags.as_int();\n+    u2 new_flags = flags.as_method_flags();\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-        *modifiers = jfs.access_flags().as_short();\n+        *modifiers = jfs.access_flags().as_field_flags();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-static s4 get_flags(const T* ptr) {\n+static u2 get_flags(const T* ptr) {\n@@ -232,1 +232,1 @@\n-  return ptr->access_flags().get_flags();\n+  return ptr->access_flags().as_unsigned_short();\n@@ -971,1 +971,1 @@\n-  writer->write(static_cast<u2>(get_flags(method)));\n+  writer->write(get_flags(method));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-#define METHOD_USED_ANY_EPOCH(kls)                (TRACE_ID_PREDICATE(kls, (EPOCH_1_METHOD_BIT) | EPOCH_0_METHOD_BIT)))\n+#define METHOD_USED_ANY_EPOCH(kls)                (TRACE_ID_PREDICATE(kls, (EPOCH_1_METHOD_BIT | EPOCH_0_METHOD_BIT)))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1003,1 +1003,1 @@\n-  JVMCIENV->put_int_at(info, 0, fd.access_flags().as_int());\n+  JVMCIENV->put_int_at(info, 0, fd.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1595,1 +1595,1 @@\n-    HotSpotJVMCI::FieldInfo::set_classfileFlags(JVMCIENV, obj_h(), (jint)fieldinfo->access_flags().as_int());\n+    HotSpotJVMCI::FieldInfo::set_classfileFlags(JVMCIENV, obj_h(), (jint)fieldinfo->access_flags().as_field_flags());\n@@ -1606,1 +1606,1 @@\n-                                      (jint)fieldinfo->access_flags().as_int(),\n+                                      (jint)fieldinfo->access_flags().as_field_flags(),\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,1 +276,1 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               jint)                                  \\\n+  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n@@ -491,1 +491,0 @@\n-  declare_constant(JVM_ACC_WRITTEN_FLAGS)                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -357,1 +357,3 @@\n-    pos = comma_pos + 1;\n+    if (comma_pos != nullptr) {\n+      pos = comma_pos + 1;\n+    }\n","filename":"src\/hotspot\/share\/logging\/logOutput.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-                access_flags().as_int(),\n+                access_flags().as_field_flags(),\n@@ -100,1 +100,1 @@\n-    assert(fi_ref->access_flags().as_int() == fi.access_flags().as_int(), \"Must be\");\n+    assert(fi_ref->access_flags().as_field_flags() == fi.access_flags().as_field_flags(), \"Must be\");\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  _consumer->accept_uint(fi.access_flags().as_int());\n+  _consumer->accept_uint(fi.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3342,2 +3342,2 @@\n-jint InstanceKlass::compute_modifier_flags() const {\n-  jint access = access_flags().as_int();\n+u2 InstanceKlass::compute_modifier_flags() const {\n+  u2 access = access_flags().as_unsigned_short();\n@@ -3363,1 +3363,1 @@\n-  return (access & (~JVM_ACC_SUPER)) & JVM_ACC_WRITTEN_FLAGS;\n+  return (access & (~JVM_ACC_SUPER));\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,1 +394,1 @@\n-  int     field_access_flags(int index) const { return field(index).access_flags().as_int(); }\n+  int     field_access_flags(int index) const { return field(index).access_flags().as_field_flags(); }\n@@ -685,2 +685,0 @@\n-  \/\/ The flag is in access_flags so that it can be set and reset using atomic\n-  \/\/ operations, and not be reset by other misc_flag settings.\n@@ -1130,1 +1128,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  enum KlassKind {\n+  enum KlassKind : u2 {\n@@ -116,1 +116,1 @@\n-  jint        _layout_helper;\n+  jint _layout_helper;\n@@ -123,0 +123,3 @@\n+  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n+                                \/\/ Some flags created by the JVM, not in the class file itself,\n+                                \/\/ are in _misc_flags below.\n@@ -124,1 +127,3 @@\n-  jint        _modifier_flags;\n+  u2          _modifier_flags;\n+\n+  KlassFlags  _misc_flags;\n@@ -160,0 +165,2 @@\n+  markWord _prototype_header;   \/\/ Used to initialize objects' header\n+\n@@ -164,12 +171,0 @@\n-  markWord _prototype_header;   \/\/ Used to initialize objects' header\n-\n-  int _vtable_len;              \/\/ vtable length. This field may be read very often when we\n-                                \/\/ have lots of itable dispatches (e.g., lambdas and streams).\n-                                \/\/ Keep it away from the beginning of a Klass to avoid cacheline\n-                                \/\/ contention that may happen when a nearby object is modified.\n-  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n-                                \/\/ Some flags created by the JVM, not in the class file itself,\n-                                \/\/ are in _misc_flags below.\n-\n-  JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n-\n@@ -203,1 +198,4 @@\n-  KlassFlags  _misc_flags;\n+  int _vtable_len;              \/\/ vtable length. This field may be read very often when we\n+                                \/\/ have lots of itable dispatches (e.g., lambdas and streams).\n+                                \/\/ Keep it away from the beginning of a Klass to avoid cacheline\n+                                \/\/ contention that may happen when a nearby object is modified.\n@@ -207,0 +205,4 @@\n+public:\n+\n+  JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n+\n@@ -295,2 +297,2 @@\n-  jint modifier_flags() const          { return _modifier_flags; }\n-  void set_modifier_flags(jint flags)  { _modifier_flags = flags; }\n+  u2 modifier_flags() const          { return _modifier_flags; }\n+  void set_modifier_flags(u2 flags)  { _modifier_flags = flags; }\n@@ -759,1 +761,1 @@\n-  virtual jint compute_modifier_flags() const = 0;\n+  virtual u2 compute_modifier_flags() const = 0;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1655,1 +1655,0 @@\n-  jshort flags = access_flags().as_short();\n@@ -1657,0 +1656,1 @@\n+  u2 flags = access_flags().as_method_flags();\n@@ -2303,1 +2303,1 @@\n-  st->print   (\" - access:            0x%x  \", access_flags().as_int()); access_flags().print_on(st); st->cr();\n+  st->print   (\" - access:            0x%x  \", access_flags().as_method_flags()); access_flags().print_on(st); st->cr();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,0 @@\n-  AccessFlags       _access_flags;               \/\/ Access flags\n@@ -80,0 +79,1 @@\n+  AccessFlags       _access_flags;               \/\/ Access flags\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,1 +344,1 @@\n-jint ObjArrayKlass::compute_modifier_flags() const {\n+u2 ObjArrayKlass::compute_modifier_flags() const {\n@@ -349,1 +349,1 @@\n-  jint element_flags = bottom_klass()->compute_modifier_flags();\n+  u2 element_flags = bottom_klass()->compute_modifier_flags();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-jint TypeArrayKlass::compute_modifier_flags() const {\n+u2 TypeArrayKlass::compute_modifier_flags() const {\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3874,1 +3874,1 @@\n-                                    Klass::access_flags_offset(), TypeInt::INT, T_INT);\n+                                    Klass::access_flags_offset(), TypeInt::CHAR, T_CHAR);\n@@ -3907,2 +3907,1 @@\n-    assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), \"change next line\");\n-    return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);\n+    return_type = TypeInt::CHAR;\n@@ -3930,1 +3929,1 @@\n-    return_type = TypeInt::INT;  \/\/ not bool!  6297094\n+    return_type = TypeInt::CHAR;\n@@ -3991,1 +3990,1 @@\n-    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n@@ -4056,1 +4055,1 @@\n-    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1979,1 +1979,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _modifier_flags\");\n+    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _modifier_flags\");\n@@ -1985,1 +1985,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _access_flags\");\n+    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _access_flags\");\n@@ -1991,1 +1991,1 @@\n-    assert(this->Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n+    assert(Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n@@ -1996,1 +1996,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _layout_helper\");\n+    assert(Opcode() == Op_LoadI, \"must load an int from _layout_helper\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-  const node_idx_t _idx;\n+  node_idx_t _idx;\n@@ -589,2 +589,1 @@\n-    const node_idx_t* ref = &_idx;\n-    *(node_idx_t*)ref = new_idx;\n+    _idx = new_idx;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1309,1 +1309,1 @@\n-  debug_only(int computed_modifiers = k->compute_modifier_flags());\n+  debug_only(u2 computed_modifiers = k->compute_modifier_flags());\n@@ -1820,1 +1820,1 @@\n-  return k->access_flags().as_int() & JVM_ACC_WRITTEN_FLAGS;\n+  return k->access_flags().as_class_flags();\n@@ -2463,1 +2463,1 @@\n-  return method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  return method->access_flags().as_method_flags();\n@@ -2470,1 +2470,1 @@\n-  return InstanceKlass::cast(k)->field_access_flags(field_index) & JVM_RECOGNIZED_FIELD_MODIFIERS;\n+  return InstanceKlass::cast(k)->field_access_flags(field_index);\n@@ -2660,1 +2660,1 @@\n-          return fs.access_flags().as_short() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n+          return fs.access_flags().as_field_flags();\n@@ -2689,1 +2689,1 @@\n-            return method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+            return method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    write_u2(access_flags.get_flags() & JVM_RECOGNIZED_FIELD_MODIFIERS);\n+    write_u2(access_flags.as_field_flags());\n@@ -707,1 +707,1 @@\n-  write_u2(access_flags.get_flags() & JVM_RECOGNIZED_METHOD_MODIFIERS);\n+  write_u2(access_flags.as_method_flags());\n@@ -922,1 +922,1 @@\n-  write_u2(ik()->access_flags().get_flags() & JVM_RECOGNIZED_CLASS_MODIFIERS);\n+  write_u2(ik()->access_flags().as_class_flags());\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3152,1 +3152,1 @@\n-  jint result = resultFlags.as_int();\n+  jint result = resultFlags.as_field_flags();\n@@ -3231,1 +3231,1 @@\n-  (*modifiers_ptr) = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  (*modifiers_ptr) = method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-  bool is_now_interp = state->is_interp_only_mode();\n+  bool is_now_interp = state->is_interp_only_mode() || state->is_pending_interp_only_mode();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1008,2 +1008,2 @@\n-  jushort old_flags = (jushort) the_class->access_flags().get_flags();\n-  jushort new_flags = (jushort) scratch_class->access_flags().get_flags();\n+  u2 old_flags = the_class->access_flags().as_class_flags();\n+  u2 new_flags = scratch_class->access_flags().as_class_flags();\n@@ -1043,3 +1043,3 @@\n-    old_flags = old_fs.access_flags().as_short();\n-    new_flags = new_fs.access_flags().as_short();\n-    if ((old_flags ^ new_flags) & JVM_RECOGNIZED_FIELD_MODIFIERS) {\n+    old_flags = old_fs.access_flags().as_field_flags();\n+    new_flags = new_fs.access_flags().as_field_flags();\n+    if (old_flags != new_flags) {\n@@ -1150,2 +1150,2 @@\n-      old_flags = (jushort) k_old_method->access_flags().get_flags();\n-      new_flags = (jushort) k_new_method->access_flags().get_flags();\n+      old_flags = k_old_method->access_flags().as_method_flags();\n+      new_flags = k_new_method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,1 +242,1 @@\n-  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  int flags = (m->access_flags().as_method_flags());\n@@ -355,1 +355,1 @@\n-  int flags = (jushort)( fd.access_flags().as_short() & JVM_RECOGNIZED_FIELD_MODIFIERS );\n+  int flags = fd.access_flags().as_field_flags();\n@@ -407,1 +407,1 @@\n-    int flags = m->access_flags().as_int();\n+    int flags = m->access_flags().as_method_flags();\n@@ -420,1 +420,1 @@\n-    int flags = m->access_flags().as_int();\n+    int flags = m->access_flags().as_method_flags();\n@@ -525,1 +525,1 @@\n-      int flags = m->access_flags().as_int();\n+      int flags = m->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2606,0 +2606,1 @@\n+    assert(_thread->is_interp_only_mode() || stub_caller, \"expected a stub-caller\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,1 +974,1 @@\n-      st->print(\"%016\" FORMAT64_MODIFIER \"x\", value);\n+      st->print(UINT64_FORMAT_0, value);\n@@ -998,1 +998,1 @@\n-      case 8: st->print(\"%016\" FORMAT64_MODIFIER \"x\", (u8)value); break;\n+      case 8: st->print(UINT64_FORMAT_0, (u8)value); break;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -781,1 +781,1 @@\n-  const int modifiers = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  const int modifiers = method->access_flags().as_method_flags();\n@@ -822,1 +822,1 @@\n-  const int modifiers = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  const int modifiers = method->access_flags().as_method_flags();\n@@ -862,1 +862,1 @@\n-  java_lang_reflect_Field::set_modifiers(rh(), fd->access_flags().as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS);\n+  java_lang_reflect_Field::set_modifiers(rh(), fd->access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1267,7 +1267,0 @@\n-  \/\/ Start with ceiling based on a per-thread estimate:\n-  size_t ceiling = ObjectSynchronizer::in_use_list_ceiling();\n-  size_t old_ceiling = ceiling;\n-  if (ceiling < list->max()) {\n-    \/\/ The max used by the system has exceeded the ceiling so use that:\n-    ceiling = list->max();\n-  }\n@@ -1278,11 +1271,6 @@\n-  if (NoAsyncDeflationProgressMax != 0 &&\n-      _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n-    double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n-    size_t new_ceiling = ceiling + (size_t)((double)ceiling * remainder) + 1;\n-    ObjectSynchronizer::set_in_use_list_ceiling(new_ceiling);\n-    log_info(monitorinflation)(\"Too many deflations without progress; \"\n-                               \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n-                               \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n-    _no_progress_cnt = 0;\n-    ceiling = new_ceiling;\n-  }\n+  size_t old_ceiling = ObjectSynchronizer::in_use_list_ceiling();\n+  \/\/ Make sure that we use a ceiling value that is not lower than\n+  \/\/ previous, not lower than the recorded max used by the system, and\n+  \/\/ not lower than the current number of monitors in use (which can\n+  \/\/ race ahead of max). The result is guaranteed > 0.\n+  size_t ceiling = MAX3(old_ceiling, list->max(), monitors_used);\n@@ -1293,0 +1281,25 @@\n+    \/\/ Deflate monitors if over the threshold percentage, unless no\n+    \/\/ progress on previous deflations.\n+    bool is_above_threshold = true;\n+\n+    \/\/ Check if it's time to adjust the in_use_list_ceiling up, due\n+    \/\/ to too many async deflation attempts without any progress.\n+    if (NoAsyncDeflationProgressMax != 0 &&\n+        _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n+      double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n+      size_t delta = (size_t)(ceiling * remainder) + 1;\n+      size_t new_ceiling = (ceiling > SIZE_MAX - delta)\n+        ? SIZE_MAX         \/\/ Overflow, let's clamp new_ceiling.\n+        : ceiling + delta;\n+\n+      ObjectSynchronizer::set_in_use_list_ceiling(new_ceiling);\n+      log_info(monitorinflation)(\"Too many deflations without progress; \"\n+                                 \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n+                                 \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n+      _no_progress_cnt = 0;\n+      ceiling = new_ceiling;\n+\n+      \/\/ Check if our monitor usage is still above the threshold:\n+      monitor_usage = (monitors_used * 100LL) \/ ceiling;\n+      is_above_threshold = int(monitor_usage) > MonitorUsedDeflationThreshold;\n+    }\n@@ -1296,1 +1309,1 @@\n-    return true;\n+    return is_above_threshold;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               jint)                                  \\\n+  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n@@ -1020,1 +1020,1 @@\n-  nonstatic_field(AccessFlags,                 _flags,                                        jint)                                  \\\n+  nonstatic_field(AccessFlags,                 _flags,                                        u2)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  assert(sizeof(AccessFlags) == sizeof(jint), \"just checking size of flags\");\n+  assert(sizeof(AccessFlags) == sizeof(u2), \"just checking size of flags\");\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-\/\/ AccessFlags is an abstraction over Java access flags.\n+\/\/ AccessFlags is an abstraction over Java ACC flags.\n+\/\/ See generated file classfile_constants.h for shared JVM_ACC_XXX access flags\n@@ -37,10 +38,0 @@\n-enum {\n-  \/\/ See jvm.h for shared JVM_ACC_XXX access flags\n-\n-  \/\/ flags actually put in .class file\n-  JVM_ACC_WRITTEN_FLAGS           = 0x00007FFF,\n-\n-  \/\/ Do not add new ACC flags here.\n-};\n-\n-\n@@ -50,1 +41,1 @@\n-  jint _flags;  \/\/ TODO: move 4 access flags above to Klass and change to u2\n+  u2 _flags;\n@@ -54,1 +45,1 @@\n-  explicit AccessFlags(jint flags) : _flags(flags) {}\n+  explicit AccessFlags(u2 flags) : _flags(flags) {}\n@@ -73,2 +64,2 @@\n-  \/\/ get .class file flags\n-  jint get_flags               () const { return (_flags & JVM_ACC_WRITTEN_FLAGS); }\n+  \/\/ get as integral value\n+  u2 as_unsigned_short() const         { return _flags; }\n@@ -76,6 +67,1 @@\n-  \/\/ Initialization\n-  void set_field_flags(jint flags)      {\n-    assert((flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == flags, \"only recognized flags\");\n-    _flags = (flags & JVM_RECOGNIZED_FIELD_MODIFIERS);\n-  }\n-  void set_flags(jint flags)            { _flags = (flags & JVM_ACC_WRITTEN_FLAGS); }\n+  void set_flags(u2 flags)            { _flags = flags; }\n@@ -93,3 +79,1 @@\n-  \/\/ Conversion\n-  jshort as_short() const              { return (jshort)_flags; }\n-  jint   as_int() const                { return _flags; }\n+  inline friend AccessFlags accessFlags_from(u2 flags);\n@@ -97,1 +81,14 @@\n-  inline friend AccessFlags accessFlags_from(jint flags);\n+  u2 as_method_flags() const {\n+    assert((_flags & JVM_RECOGNIZED_METHOD_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n+\n+  u2 as_field_flags() const  {\n+    assert((_flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n+\n+  u2 as_class_flags() const  {\n+    assert((_flags & JVM_RECOGNIZED_CLASS_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n@@ -107,1 +104,1 @@\n-inline AccessFlags accessFlags_from(jint flags) {\n+inline AccessFlags accessFlags_from(u2 flags) {\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,1 @@\n+\/\/  _0    - print as hexadecimal, with leading 0s, without 0x prefix: 0012345\n@@ -134,0 +135,1 @@\n+#define UINT64_FORMAT_0          \"%016\"       PRIx64\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,11 +93,0 @@\n-\/\/ Formatting.\n-#ifdef _LP64\n-# ifdef __APPLE__\n-# define FORMAT64_MODIFIER \"ll\"\n-# else\n-# define FORMAT64_MODIFIER \"l\"\n-# endif\n-#else \/\/ !_LP64\n-#define FORMAT64_MODIFIER \"ll\"\n-#endif \/\/ _LP64\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,3 +106,0 @@\n-\/\/ Formatting.\n-#define FORMAT64_MODIFIER \"ll\"\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 SAP SE. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -29,2 +29,1 @@\n-import java.nio.channels.spi.AsynchronousChannelProvider;\n-import sun.nio.ch.Pollset;\n+import java.io.FileDescriptor;\n@@ -32,2 +31,1 @@\n-import java.util.HashSet;\n-import java.util.Iterator;\n+import java.nio.channels.spi.AsynchronousChannelProvider;\n@@ -35,1 +33,0 @@\n-import java.util.concurrent.RejectedExecutionException;\n@@ -38,0 +35,5 @@\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import sun.nio.ch.IOUtil;\n+import sun.nio.ch.Pollset;\n@@ -144,0 +146,2 @@\n+            \/\/ make the reading part of the socket nonblocking, so the drain (drain_all) method works\n+            IOUtil.configureBlocking(IOUtil.newFD(sv[0]), false);\n@@ -274,14 +278,11 @@\n-        synchronized (controlQueue) {\n-            \/\/ On Aix it is only possible to set the event\n-            \/\/ bits on the first call of pollsetCtl. Later\n-            \/\/ calls only add bits, but cannot remove them.\n-            \/\/ Therefore, we always remove the file\n-            \/\/ descriptor ignoring the error and then add it.\n-            Iterator<ControlEvent> iter = controlQueue.iterator();\n-            while (iter.hasNext()) {\n-                ControlEvent ev = iter.next();\n-                Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n-                if (!ev.removeOnly()) {\n-                    ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n-                }\n-                iter.remove();\n+        \/\/ On Aix it is only possible to set the event\n+        \/\/ bits on the first call of pollsetCtl. Later\n+        \/\/ calls only add bits, but cannot remove them.\n+        \/\/ Therefore, we always remove the file\n+        \/\/ descriptor ignoring the error and then add it.\n+        Iterator<ControlEvent> iter = controlQueue.iterator();\n+        while (iter.hasNext()) {\n+            ControlEvent ev = iter.next();\n+            Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n+            if (!ev.removeOnly()) {\n+                ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n@@ -289,1 +290,1 @@\n-            controlQueue.notifyAll();\n+            iter.remove();\n@@ -291,0 +292,1 @@\n+        controlQueue.notifyAll();\n@@ -309,1 +311,2 @@\n-                        n = Pollset.pollsetPoll(pollset, address,\n+                        int m;\n+                        m = n = Pollset.pollsetPoll(pollset, address,\n@@ -311,0 +314,12 @@\n+                        while (m-- > 0) {\n+                            long eventAddress = Pollset.getEvent(address, m);\n+                            int fd = Pollset.getDescriptor(eventAddress);\n+\n+                            \/\/ To emulate one shot semantic we need to remove\n+                            \/\/ the file descriptor here.\n+                            if (fd != sp[0] && fd != ctlSp[0]) {\n+                                synchronized (controlQueue) {\n+                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n+                                }\n+                            }\n+                        }\n@@ -326,8 +341,0 @@\n-                            \/\/ To emulate one shot semantic we need to remove\n-                            \/\/ the file descriptor here.\n-                            if (fd != sp[0] && fd != ctlSp[0]) {\n-                                synchronized (controlQueue) {\n-                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n-                                }\n-                            }\n-\n@@ -353,1 +360,1 @@\n-                                    Pollset.drain1(ctlSp[0]);\n+                                    IOUtil.drain(ctlSp[0]);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/AixPollPort.java","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,2 +183,2 @@\n-                throw new AssertionError(\n-                        \"PRK is required for HKDFParameterSpec.Expand\");\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Cannot retrieve PRK for HKDFParameterSpec.Expand\");\n@@ -414,1 +414,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HKDFKeyDerivation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -37,3 +39,12 @@\n- * is stored in the {@code BootstrapMethods} attribute, but is modeled by\n- * the {@link ConstantPool}, since the bootstrap method table is logically\n- * part of the constant pool.\n+ * is stored in the {@link BootstrapMethodsAttribute BootstrapMethods}\n+ * attribute, but is modeled by the {@link ConstantPool}, since the bootstrap\n+ * method table is logically part of the constant pool.\n+ * <p>\n+ * A bootstrap method entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"BootstrapMethodEntry\" target=\"ConstantPoolBuilder#bsmEntry(MethodHandleEntry, List)\" :\n+ * BootstrapMethodEntry(\n+ *     MethodHandleEntry bootstrapMethod, \/\/ @link substring=\"bootstrapMethod\" target=\"#bootstrapMethod\"\n+ *     List<LoadableConstantEntry> arguments \/\/ @link substring=\"arguments\" target=\"#arguments()\"\n+ * )\n+ * }\n@@ -41,0 +52,1 @@\n+ * @see ConstantPoolBuilder#bsmEntry ConstantPoolBuilder::bsmEntry\n@@ -48,0 +60,7 @@\n+     *\n+     * @apiNote\n+     * Given a {@link ConstantPoolBuilder} {@code builder} and a {@code\n+     * BootstrapMethodEntry} {@code entry}, use {@link\n+     * ConstantPoolBuilder#canWriteDirect\n+     * builder.canWriteDirect(entry.constantPool())} instead of object equality\n+     * of the constant pool to determine if an entry is compatible.\n@@ -52,1 +71,2 @@\n-     * {@return the index into the bootstrap method table corresponding to this entry}\n+     * {@return the index into the bootstrap method table corresponding to this\n+     * entry}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/BootstrapMethodEntry.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,6 +143,7 @@\n-     * transforming a classfile.  Reusing the constant pool enables significant\n-     * optimizations in processing time and minimizes differences between the\n-     * original and transformed classfile, but may result in a bigger classfile\n-     * when a classfile is significantly transformed.\n-     * Default is {@code SHARED_POOL} to preserve the original constant\n-     * pool.\n+     * transforming a {@code class} file.  Reusing the constant pool enables\n+     * significant optimizations in processing time and minimizes differences\n+     * between the original and transformed {@code class} files, but may result\n+     * in a bigger transformed {@code class} file when many elements of the\n+     * original {@code class} file are dropped and many original constant\n+     * pool entries become unused.  Default is {@link #SHARED_POOL} to preserve\n+     * the original constant pool.\n@@ -150,0 +151,3 @@\n+     * @see ConstantPoolBuilder\n+     * @see #build(ClassEntry, ConstantPoolBuilder, Consumer)\n+     * @see #transformClass(ClassModel, ClassTransform)\n@@ -154,1 +158,17 @@\n-        \/** Preserves the original constant pool when transforming classfile *\/\n+        \/**\n+         * Preserves the original constant pool when transforming the {@code\n+         * class} file.\n+         * <p>\n+         * These two transformations below are equivalent:\n+         * {@snippet lang=java :\n+         * ClassModel originalClass = null; \/\/ @replace substring=null; replacement=...\n+         * ClassDesc resultClassName = null; \/\/ @replace substring=null; replacement=...\n+         * ClassTransform classTransform = null; \/\/ @replace substring=null; replacement=...\n+         * var resultOne = ClassFile.of(ConstantPoolSharingOption.SHARED_POOL)\n+         *         .transformClass(originalClass, resultClassName, classTransform);\n+         * var resultTwo = ClassFile.of().build(resultClassName, ConstantPoolBuilder.of(originalClass),\n+         *         clb -> clb.transform(originalClass, classTransform));\n+         * }\n+         *\n+         * @see ConstantPoolBuilder#of(ClassModel) ConstantPoolBuilder::of(ClassModel)\n+         *\/\n@@ -157,1 +177,16 @@\n-        \/** Creates a new constant pool when transforming classfile *\/\n+        \/**\n+         * Creates a new constant pool when transforming the {@code class} file.\n+         * <p>\n+         * These two transformations below are equivalent:\n+         * {@snippet lang=java :\n+         * ClassModel originalClass = null; \/\/ @replace substring=null; replacement=...\n+         * ClassDesc resultClassName = null; \/\/ @replace substring=null; replacement=...\n+         * ClassTransform classTransform = null; \/\/ @replace substring=null; replacement=...\n+         * var resultOne = ClassFile.of(ConstantPoolSharingOption.NEW_POOL)\n+         *         .transformClass(originalClass, resultClassName, classTransform);\n+         * var resultTwo = ClassFile.of().build(resultClassName, ConstantPoolBuilder.of(),\n+         *         clb -> clb.transform(originalClass, classTransform));\n+         * }\n+         *\n+         * @see ConstantPoolBuilder#of() ConstantPoolBuilder::of()\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,3 @@\n- * A constant pool entry that may be used by annotation constant values,\n- * which includes the four kinds of primitive constants and UTF8 constants.\n- * These entries are also the only entries that do not refer to other\n- * constant pool entries.\n+ * Marker interface for constant pool entries that can represent constant values\n+ * associated with elements of annotations.  They are also the only entries that\n+ * do not refer to other constant pool entries.\n@@ -43,0 +42,1 @@\n+ * @jvms 4.7.16.1 The {@code element_value} structure\n@@ -50,3 +50,3 @@\n-     * {@return the constant value}  The constant value will be an {@link Integer},\n-     * {@link Long}, {@link Float}, {@link Double} for the primitive constants,\n-     * or {@link String} for UTF8 constants.\n+     * {@return the constant value}  The constant value will be an {@link\n+     * Integer}, {@link Long}, {@link Float}, {@link Double} for the primitive\n+     * constants, or {@link String} for UTF8 constants.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/AnnotationConstantValueEntry.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,24 @@\n- * Models a {@code CONSTANT_Class_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.1 The CONSTANT_Class_info Structure\n+ * Models a {@code CONSTANT_Class_info} structure, representing a reference\n+ * type, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code ClassEntry} is modeled by a {@link ClassDesc} that is not\n+ * primitive.  Conversions are through {@link ConstantPoolBuilder#classEntry(\n+ * ClassDesc)} and {@link #asSymbol()}.\n+ * <p>\n+ * A {@code ClassEntry} is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"ClassEntry\" target=\"ConstantPoolBuilder#classEntry(Utf8Entry)\" :\n+ * ClassEntry(Utf8Entry name) \/\/ @link substring=\"name\" target=\"#name\"\n+ * }\n+ * where {@code name} represents:\n+ * <ul>\n+ * <li>The internal form of a binary name (JVMS {@jvms 4.2.1}), if and only if\n+ * this {@code ClassEntry} represents a class or interface, such as {@code\n+ * java\/lang\/String} for the {@link String} class.\n+ * <li>A field descriptor string (JVMS {@jvms 4.3.2}) representing an array type,\n+ * if and only if this {@code ClassEntry} represents an array type, such as\n+ * {@code [I} for the {@code int[]} type, or {@code [Ljava\/lang\/String;} for the\n+ * {@code String[]} type.\n+ * <\/ul>\n+ * A field descriptor string for an array type can be distinguished by its\n+ * leading {@code '['} character.\n@@ -37,0 +58,9 @@\n+ * @apiNote\n+ * The internal form of a binary name, where all occurrences of {@code .} in the\n+ * name are replaced by {@code \/}, is informally known as an <dfn>{@index\n+ * \"internal name\"}<\/dfn>.  This concept also applies to package names in\n+ * addition to class and interface names.\n+ *\n+ * @see ConstantPoolBuilder#classEntry ConstantPoolBuilder::classEntry\n+ * @see ClassDesc\n+ * @jvms 4.4.1 The {@code CONSTANT_Class_info} Structure\n@@ -43,0 +73,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -49,1 +84,8 @@\n-     * {@return the UTF8 constant pool entry for the class name}\n+     * {@return the {@code Utf8Entry} referred by this structure}  If the\n+     * value of the UTF8 starts with a {@code [}, this represents an array type\n+     * and the value is a descriptor string; otherwise, this represents a class\n+     * or interface and the value is the {@linkplain ##internalname internal\n+     * form} of a binary name.\n+     *\n+     * @see ConstantPoolBuilder#classEntry(Utf8Entry)\n+     *      ConstantPoolBuilder::classEntry(Utf8Entry)\n@@ -54,1 +96,3 @@\n-     * {@return the class name, as an internal binary name}\n+     * {@return the represented reference type, as the {@linkplain\n+     * ##internalname internal form} of a binary name or an array descriptor\n+     * string}  This is a shortcut for {@link #name() name().stringValue()}.\n@@ -59,1 +103,6 @@\n-     * {@return the class name, as a symbolic descriptor}\n+     * {@return the represented reference type, as a symbolic descriptor}  The\n+     * returned descriptor is never {@linkplain ClassDesc#isPrimitive()\n+     * primitive}.\n+     *\n+     * @see ConstantPoolBuilder#classEntry(ClassDesc)\n+     *      ConstantPoolBuilder::classEntry(ClassDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ClassEntry.java","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,18 @@\n- * Models a {@code CONSTANT_Dynamic_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+ * Models a {@code CONSTANT_Dynamic_info} structure, representing a <dfn>{@index\n+ * \"dynamically-computed constant\"}<\/dfn>, in the constant pool of a {@code\n+ * class} file.\n+ * <p>\n+ * The use of a {@code ConstantDynamicEntry} is modeled by a {@link\n+ * DynamicConstantDesc}.  Conversions are through {@link #asSymbol()} and {@link\n+ * ConstantPoolBuilder#constantDynamicEntry(DynamicConstantDesc)}.\n+ * <p>\n+ * A dynamic constant entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"ConstantDynamicEntry\" target=\"ConstantPoolBuilder#constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\" :\n+ * ConstantDynamicEntry(\n+ *     BootstrapMethodEntry bootstrap, \/\/ @link substring=\"bootstrap\" target=\"#bootstrap()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where {@link #type() nameAndType.type()} is a {@linkplain #typeSymbol()\n+ * field descriptor} string.\n@@ -40,0 +55,11 @@\n+ * @apiNote\n+ * A dynamically-computed constant is frequently called a <dfn>{@index \"dynamic\n+ * constant\"}<\/dfn>, or a <dfn>{@index \"condy\"}<\/dfn>, from the abbreviation of\n+ * \"constant dynamic\".\n+ *\n+ * @see ConstantPoolBuilder#constantDynamicEntry\n+ *      ConstantPoolBuilder::constantDynamicEntry\n+ * @see DynamicConstantDesc\n+ * @see java.lang.invoke##condycon Dynamically-computed constants\n+ * @jvms 4.4.10 The {@code CONSTANT_Dynamic_info} and {@code\n+ *              CONSTANT_InvokeDynamic_info} Structures\n@@ -47,1 +73,2 @@\n-     * {@return a symbolic descriptor for the dynamic constant's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() field type} of\n+     * this dynamically-computed constant}\n@@ -53,0 +80,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -59,1 +91,4 @@\n-     * {@return the symbolic descriptor for the {@code invokedynamic} constant}\n+     * {@return a symbolic descriptor for this dynamically-computed constant}\n+     *\n+     * @see ConstantPoolBuilder#constantDynamicEntry(DynamicConstantDesc)\n+     *      ConstantPoolBuilder::constantDynamicEntry(DynamicConstantDesc)\n@@ -71,1 +106,6 @@\n-     * {@return the type of the constant}\n+     * {@inheritDoc}\n+     *\n+     * @apiNote\n+     * The data type of a dynamically-computed constant depends on its\n+     * {@linkplain #type() descriptor}, while the data type of all other\n+     * constants can be determined by their {@linkplain #tag() constant type}.\n@@ -75,1 +115,1 @@\n-        return TypeKind.fromDescriptor(type().stringValue());\n+        return TypeKind.fromDescriptor(type());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantDynamicEntry.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n@@ -34,3 +35,8 @@\n- * Provides read access to the constant pool and bootstrap method table of a\n- * classfile.\n- * @jvms 4.4 The Constant Pool\n+ * Provides read access to the constant pool and the bootstrap method table of a\n+ * {@code class} file.\n+ *\n+ * <h2 id=\"index\">Index in the Constant Pool<\/h2>\n+ * The constant pool entries are accessed by index.  A valid index is in the\n+ * range of {@link #size() [1, size())}.  It is {@linkplain PoolEntry#width()\n+ * unusable} if a {@link LongEntry} or {@link DoubleEntry} is at its previous\n+ * index.\n@@ -38,0 +44,2 @@\n+ * @see BootstrapMethodsAttribute\n+ * @jvms 4.4 The Constant Pool\n@@ -49,1 +57,1 @@\n-     * int, Class) entryByIndex(int, Class)}.\n+     * int, Class)}.\n@@ -58,1 +66,5 @@\n-     * {@return the size of the constant pool}\n+     * {@return the exclusive upper bound of the valid indices of this constant\n+     * pool}  The actual number of entries is lower because {@code 0}, {@code\n+     * size()} are not valid, and a valid index may be unusable.\n+     *\n+     * @see ##index Index in the Constant Pool\n@@ -69,1 +81,2 @@\n-     *         constant pool, or the entry is not of the given type\n+     *         constant pool or considered unusable, or the entry is not\n+     *         of the given type\n@@ -75,0 +88,4 @@\n+     *\n+     * @apiNote\n+     * This skips any unusable index and is less error-prone than iterating by\n+     * raw index.  See <em>{@linkplain ##index Index in the Constant Pool}<\/em>.\n@@ -96,1 +113,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPool.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileBuilder;\n@@ -30,0 +31,3 @@\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -31,0 +35,1 @@\n+import java.lang.invoke.MethodHandleInfo;\n@@ -32,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -42,3 +48,12 @@\n- * Builder for the constant pool of a classfile.  Provides read and write access\n- * to the constant pool that is being built.  Writing is append-only and idempotent\n- * (entry-bearing methods will return an existing entry if there is one).\n+ * Builder for the constant pool of a {@code class} file.  Provides read and\n+ * write access to the constant pool that is {@linkplain ClassFileBuilder#constantPool()\n+ * being built}.  Writing is append-only (the index of new entries monotonically\n+ * increase) and idempotent (entry-bearing methods will return an existing entry\n+ * if there is a suitable one).\n+ * <p>\n+ * For {@code class} file building, an overload of {@link ClassFile#build(\n+ * ClassEntry, ConstantPoolBuilder, Consumer) ClassFile::build} takes a\n+ * {@code ConstantPoolBuilder}.  For {@code class} file transformations via\n+ * {@link ClassFile#transformClass ClassFile::transformClass}, the {@link\n+ * ClassFile.ConstantPoolSharingOption} controls how the constant pool builder\n+ * of the resulting {@code class} is created.\n@@ -46,3 +61,24 @@\n- * A {@linkplain ConstantPoolBuilder} is associated with a {@link ClassBuilder}.\n- * The {@linkplain ConstantPoolBuilder} also provides access to some of the\n- * state of the {@linkplain ClassBuilder}, such as classfile processing options.\n+ * <h2 id=\"alien\">Alien Constant Pool Entries<\/h2>\n+ * In {@code class} file building and constant pool building, some constant pool\n+ * entries supplied may be {@linkplain #canWriteDirect(ConstantPool) alien}\n+ * to this constant pool builder of the active class file builder.  For example,\n+ * {@link #classEntry(Utf8Entry) classEntry(Utf8Entry)} may be called with an\n+ * alien UTF8 entry.  Alien entries will be converted to a pool entry in\n+ * this constant pool builder, reusing equivalent entries or adding new entries\n+ * if there is none.  As a result, all pool entries returned by entry-bearing\n+ * methods in this constant pool builder belong to this constant pool.\n+ * <p>\n+ * Some {@link ClassFileBuilder} methods may have their outputs adjusted if they\n+ * receive pool entries alien to {@linkplain ClassFileBuilder#constantPool\n+ * their constant pools}.  For example, if an {@link ConstantInstruction#ofLoad\n+ * ldc_w} instruction with an alien entry is written to a {@link CodeBuilder},\n+ * the {@code CodeBuilder} may emit a functionally equivalent {@code ldc}\n+ * instruction instead, if the converted entry can be encoded in such an\n+ * instruction.\n+ * <p>\n+ * To avoid the conversion of alien constant pool entries, such as for the\n+ * accuracy of the generated {@code class} file, users can always supply\n+ * constant pool entries obtained by calling the constant pool builder\n+ * entry-bearing methods of the constant pools associated with the {@code\n+ * ClassFileBuilder}.  Otherwise, the conversions have no impact on the\n+ * behaviors of the generated {@code class} files.\n@@ -50,0 +86,1 @@\n+ * @see ClassFileBuilder#constantPool()\n@@ -58,2 +95,4 @@\n-     * be pre-populated with the contents of the constant pool associated with\n-     * the class reader.\n+     * be pre-populated with the contents of the constant pool {@linkplain\n+     * ClassModel#constantPool() associated with} the given class model.  The\n+     * index of new entries will start from the {@link ConstantPool#size()\n+     * size()} of the source pool.\n@@ -62,0 +101,2 @@\n+     * @see ClassFile#build(ClassEntry, ConstantPoolBuilder, Consumer)\n+     * @see ClassFile.ConstantPoolSharingOption#SHARED_POOL\n@@ -69,1 +110,3 @@\n-     * will be empty.\n+     * will be empty.  The index of new entries will start from {@code 1}.\n+     *\n+     * @see ClassFile.ConstantPoolSharingOption#NEW_POOL\n@@ -76,3 +119,8 @@\n-     * {@return whether the provided constant pool is index-compatible with this\n-     * one}  This may be because they are the same constant pool, or because this\n-     * constant pool was copied from the other.\n+     * {@return {@code true} if the index of any entry in the given constant\n+     * pool refers to the same entry in this builder}  This may be because they\n+     * are the same builder, or because this builder was {@linkplain\n+     * #of(ClassModel) pre-populated} from the given constant pool.\n+     * <p>\n+     * If the constant pool of an entry is not directly writable to this pool,\n+     * it is alien to this pool, and a {@link ClassFileBuilder} associated\n+     * with this constant pool will convert that alien constant pool entry.\n@@ -80,1 +128,3 @@\n-     * @param constantPool the other constant pool\n+     * @param constantPool the given constant pool\n+     * @see ClassFileBuilder#constantPool() ClassFileBuilder::constantPool\n+     * @see ##alien Alien Constant Pool Entries\n@@ -85,3 +135,1 @@\n-     * {@return A {@link Utf8Entry} describing the provided {@linkplain String}}\n-     * If a UTF8 entry in the pool already describes this string, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link Utf8Entry} describing the provided {@link String}}\n@@ -90,0 +138,1 @@\n+     * @see Utf8Entry#stringValue() Utf8Entry::stringValue\n@@ -94,4 +143,8 @@\n-     * {@return A {@link Utf8Entry} describing the field descriptor of the provided\n-     * {@linkplain ClassDesc}}\n-     * If a UTF8 entry in the pool already describes this field descriptor, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link Utf8Entry} describing the {@linkplain\n+     * ClassDesc#descriptorString() field descriptor string} of the provided\n+     * {@link ClassDesc}}\n+     *\n+     * @apiNote\n+     * The resulting {@code Utf8Entry} is usually not {@linkplain\n+     * #classEntry(Utf8Entry) referable by} a {@link ClassEntry}, which uses\n+     * internal form of binary names.\n@@ -106,4 +159,3 @@\n-     * {@return A {@link Utf8Entry} describing the method descriptor of the provided\n-     * {@linkplain MethodTypeDesc}}\n-     * If a UTF8 entry in the pool already describes this field descriptor, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link Utf8Entry} describing the {@linkplain\n+     * MethodTypeDesc#descriptorString() method descriptor string} of the\n+     * provided {@link MethodTypeDesc}}\n@@ -118,5 +170,4 @@\n-     * {@return A {@link ClassEntry} describing the class whose internal name\n-     * is encoded in the provided {@linkplain Utf8Entry}}\n-     * If a Class entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ClassEntry} referring to the provided {@link\n+     * Utf8Entry}}  The {@code Utf8Entry} describes the internal form\n+     * of the binary name of a class or interface or the field descriptor\n+     * string of an array type.\n@@ -124,1 +175,2 @@\n-     * @param ne the constant pool entry describing the internal name of the class\n+     * @param ne the {@code Utf8Entry}\n+     * @see ClassEntry#name() ClassEntry::name\n@@ -129,5 +181,2 @@\n-     * {@return A {@link ClassEntry} describing the class described by\n-     * provided {@linkplain ClassDesc}}\n-     * If a Class entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ClassEntry} describing the same reference type\n+     * as the provided {@link ClassDesc}}\n@@ -135,2 +184,4 @@\n-     * @param classDesc the symbolic descriptor for the class\n-     * @throws IllegalArgumentException if {@code classDesc} represents a primitive type\n+     * @param classDesc the symbolic descriptor for the reference type\n+     * @throws IllegalArgumentException if {@code classDesc} represents a\n+     *         primitive type\n+     * @see ClassEntry#asSymbol() ClassEntry::asSymbol\n@@ -148,5 +199,3 @@\n-     * {@return A {@link PackageEntry} describing the class whose internal name\n-     * is encoded in the provided {@linkplain Utf8Entry}}\n-     * If a Package entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link PackageEntry} referring to the provided {@link\n+     * Utf8Entry}}  The {@code Utf8Entry} describes the internal form\n+     * of the name of a package.\n@@ -154,2 +203,2 @@\n-     * @param nameEntry the constant pool entry describing the internal name of\n-     *                  the package\n+     * @param nameEntry the {@code Utf8Entry}\n+     * @see PackageEntry#name() PackageEntry::name\n@@ -160,5 +209,2 @@\n-     * {@return A {@link PackageEntry} describing the class described by\n-     * provided {@linkplain PackageDesc}}\n-     * If a Package entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link PackageEntry} describing the same package as the\n+     * provided {@link PackageDesc}}\n@@ -166,1 +212,2 @@\n-     * @param packageDesc the symbolic descriptor for the class\n+     * @param packageDesc the symbolic descriptor for the package\n+     * @see PackageEntry#asSymbol() PackageEntry::asSymbol\n@@ -173,5 +220,2 @@\n-     * {@return A {@link ModuleEntry} describing the module whose name\n-     * is encoded in the provided {@linkplain Utf8Entry}}\n-     * If a module entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ModuleEntry} referring to the provided {@link\n+     * Utf8Entry}}  The {@code Utf8Entry} describes the module name.\n@@ -180,0 +224,1 @@\n+     * @see ModuleEntry#name() ModuleEntry::name\n@@ -184,5 +229,2 @@\n-     * {@return A {@link ModuleEntry} describing the module described by\n-     * provided {@linkplain ModuleDesc}}\n-     * If a module entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ModuleEntry} describing the same module as the provided\n+     * {@link ModuleDesc}}\n@@ -190,1 +232,2 @@\n-     * @param moduleDesc the symbolic descriptor for the class\n+     * @param moduleDesc the symbolic descriptor for the module\n+     * @see ModuleEntry#asSymbol() ModuleEntry::asSymbol\n@@ -197,4 +240,5 @@\n-     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n-     * If a NameAndType entry in the pool already describes this name and type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link NameAndTypeEntry} referring to the provided name and\n+     * type {@link Utf8Entry}}  The name {@code Utf8Entry} describes an\n+     * unqualified name or the special name {@value ConstantDescs#INIT_NAME},\n+     * and the type {@code Utf8Entry} describes a field or method descriptor\n+     * string.\n@@ -202,2 +246,4 @@\n-     * @param nameEntry the member name\n-     * @param typeEntry the member field or method descriptor\n+     * @param nameEntry the name {@code Utf8Entry}\n+     * @param typeEntry the type {@code Utf8Entry}\n+     * @see NameAndTypeEntry#name() NameAndTypeEntry::name\n+     * @see NameAndTypeEntry#type() NameAndTypeEntry::type\n@@ -208,4 +254,2 @@\n-     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n-     * If a NameAndType entry in the pool already describes this name and type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link NameAndTypeEntry} describing the provided unqualified\n+     * name and field descriptor}\n@@ -213,2 +257,2 @@\n-     * @param name the member name\n-     * @param type the symbolic descriptor for a field type\n+     * @param name the unqualified name\n+     * @param type the field descriptor\n@@ -221,4 +265,3 @@\n-     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n-     * If a NameAndType entry in the pool already describes this name and type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link NameAndTypeEntry} describing the provided name and\n+     * method descriptor}  The name can be an unqualified name or the\n+     * special name {@value ConstantDescs#INIT_NAME}.\n@@ -226,2 +269,2 @@\n-     * @param name the member name\n-     * @param type the symbolic descriptor for a method type\n+     * @param name the unqualified name, or {@value ConstantDescs#INIT_NAME}\n+     * @param type the method descriptor\n@@ -234,4 +277,5 @@\n-     * {@return A {@link FieldRefEntry} describing a field of a class}\n-     * If a FieldRef entry in the pool already describes this field,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link FieldRefEntry} referring to a {@link ClassEntry} and a\n+     * {@link NameAndTypeEntry}}  The {@code ClassEntry} describes a class or\n+     * interface that has this field as a member, and the {@code\n+     * NameAndTypeEntry} describes the unqualified name and the field descriptor\n+     * for this field.\n@@ -239,2 +283,4 @@\n-     * @param owner the class the field is a member of\n-     * @param nameAndType the name and type of the field\n+     * @param owner the {@code ClassEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see FieldRefEntry#owner() FieldRefEntry::owner\n+     * @see FieldRefEntry#nameAndType() FieldRefEntry::nameAndType\n@@ -245,4 +291,1 @@\n-     * {@return A {@link FieldRefEntry} describing a field of a class}\n-     * If a FieldRef entry in the pool already describes this field,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link FieldRefEntry} describing a field of a class}\n@@ -250,3 +293,3 @@\n-     * @param owner the class the field is a member of\n-     * @param name the name of the field\n-     * @param type the type of the field\n+     * @param owner the class or interface the field is a member of\n+     * @param name the unqualified name of the field\n+     * @param type the field descriptor\n@@ -254,0 +297,1 @@\n+     * @see FieldRefEntry#typeSymbol() FieldRefEntry::typeSymbol\n@@ -260,4 +304,5 @@\n-     * {@return A {@link MethodRefEntry} describing a method of a class}\n-     * If a MethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodRefEntry} referring to a {@link ClassEntry} and a\n+     * {@link NameAndTypeEntry}}  The {@code ClassEntry} describes a class that\n+     * has this method as a member, and the {@code NameAndTypeEntry} describes\n+     * the unqualified name or the special name {@value ConstantDescs#INIT_NAME}\n+     * and the method descriptor for this method.\n@@ -265,2 +310,4 @@\n-     * @param owner the class the method is a member of\n-     * @param nameAndType the name and type of the method\n+     * @param owner the {@code ClassEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see MethodRefEntry#owner() MethodRefEntry::owner\n+     * @see MethodRefEntry#nameAndType() MethodRefEntry::nameAndType\n@@ -271,4 +318,1 @@\n-     * {@return A {@link MethodRefEntry} describing a method of a class}\n-     * If a MethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodRefEntry} describing a method of a class}\n@@ -277,2 +321,3 @@\n-     * @param name the name of the method\n-     * @param type the type of the method\n+     * @param name the unqualified name, or special name {@value\n+     *        ConstantDescs#INIT_NAME}, of the method\n+     * @param type the method descriptor\n@@ -280,0 +325,1 @@\n+     * @see MethodRefEntry#typeSymbol() MethodRefEntry::typeSymbol\n@@ -286,4 +332,5 @@\n-     * {@return A {@link InterfaceMethodRefEntry} describing a method of a class}\n-     * If a InterfaceMethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InterfaceMethodRefEntry} referring to a {@link\n+     * ClassEntry} and a {@link NameAndTypeEntry}}  The {@code ClassEntry}\n+     * describes an interface that has this method as a member, and the {@code\n+     * NameAndTypeEntry} describes the unqualified name and the method\n+     * descriptor for this method.\n@@ -291,2 +338,5 @@\n-     * @param owner the class the method is a member of\n-     * @param nameAndType the name and type of the method\n+     * @param owner the {@code ClassEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see InterfaceMethodRefEntry#owner() InterfaceMethodRefEntry::owner\n+     * @see InterfaceMethodRefEntry#nameAndType()\n+     *      InterfaceMethodRefEntry::nameAndType\n@@ -297,4 +347,2 @@\n-     * {@return A {@link InterfaceMethodRefEntry} describing a method of a class}\n-     * If a InterfaceMethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InterfaceMethodRefEntry} describing a method of an\n+     * interface}\n@@ -302,3 +350,3 @@\n-     * @param owner the class the method is a member of\n-     * @param name the name of the method\n-     * @param type the type of the method\n+     * @param owner the interface the method is a member of\n+     * @param name the unqualified name of the method\n+     * @param type the method descriptor\n@@ -306,0 +354,1 @@\n+     * @see InterfaceMethodRefEntry#typeSymbol() InterfaceMethodRefEntry::typeSymbol\n@@ -312,4 +361,2 @@\n-     * {@return A {@link MethodTypeEntry} describing a method type}\n-     * If a MethodType entry in the pool already describes this method type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodTypeEntry} describing the same method type as\n+     * the provided {@link MethodTypeDesc}}\n@@ -318,0 +365,1 @@\n+     * @see MethodTypeEntry#asSymbol() MethodTypeEntry::asSymbol\n@@ -322,4 +370,2 @@\n-     * {@return A {@link MethodTypeEntry} describing a method type}\n-     * If a MethodType entry in the pool already describes this method type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodTypeEntry} referring to a {@link Utf8Entry}}\n+     * The {@code Utf8Entry} represents a method descriptor string.\n@@ -327,1 +373,2 @@\n-     * @param descriptor the constant pool entry for the method type descriptor\n+     * @param descriptor the {@code Utf8Entry}\n+     * @see MethodTypeEntry#descriptor() MethodTypeEntry::descriptor\n@@ -332,4 +379,2 @@\n-     * {@return A {@link MethodHandleEntry} describing a direct method handle}\n-     * If a MethodHandle entry in the pool already describes this method handle,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodHandleEntry} describing the same method handle as\n+     * the given {@link DirectMethodHandleDesc}}\n@@ -338,0 +383,1 @@\n+     * @see MethodHandleEntry#asSymbol() MethodHandleEntry::asSymbol\n@@ -350,4 +396,4 @@\n-     * {@return A {@link MethodHandleEntry} describing a field accessor or method}\n-     * If a MethodHandle entry in the pool already describes this method handle,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodHandleEntry} encoding a reference kind and\n+     * referring to a {@link MemberRefEntry}}  The reference kind must be\n+     * in {@code [1, 9]}, and the {@code MemberRefEntry} is subject to\n+     * various restrictions based on the reference kind (JVMS {@jvms 4.4.8}).\n@@ -355,2 +401,5 @@\n-     * @param refKind the reference kind of the method handle (JVMS {@jvms 4.4.8})\n-     * @param reference the constant pool entry describing the field or method\n+     * @param refKind the reference kind of the method handle\n+     * @param reference the {@code MemberRefEntry}\n+     * @see MethodHandleInfo##refkinds Reference kinds\n+     * @see MethodHandleEntry#kind() MethodHandleEntry::kind\n+     * @see MethodHandleEntry#reference() MethodHandleEntry::reference\n@@ -361,4 +410,2 @@\n-     * {@return An {@link InvokeDynamicEntry} describing a dynamic call site}\n-     * If an InvokeDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InvokeDynamicEntry} describing the same dynamic call\n+     * site as the provided {@link DynamicCallSiteDesc}}\n@@ -366,1 +413,2 @@\n-     * @param dcsd the symbolic descriptor of the method handle\n+     * @param dcsd the symbolic descriptor of the dynamic call site\n+     * @see InvokeDynamicEntry#asSymbol() InvokeDynamicEntry::asSymbol\n@@ -373,4 +421,5 @@\n-     * {@return An {@link InvokeDynamicEntry} describing a dynamic call site}\n-     * If an InvokeDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InvokeDynamicEntry} referring to a {@link\n+     * BootstrapMethodEntry} and a {@link NameAndTypeEntry}}\n+     * The {@code BootstrapMethodEntry} describes the bootstrap method\n+     * and its invocation arguments in addition to the name and type,\n+     * and the {@code NameAndTypeEntry} a name and a method descriptor.\n@@ -378,2 +427,4 @@\n-     * @param bootstrapMethodEntry the entry in the bootstrap method table\n-     * @param nameAndType the invocation name and type\n+     * @param bootstrapMethodEntry the {@code BootstrapMethodEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see InvokeDynamicEntry#bootstrap() InvokeDynamicEntry::bootstrap\n+     * @see InvokeDynamicEntry#nameAndType() InvokeDynamicEntry::nameAndType\n@@ -385,4 +436,2 @@\n-     * {@return A {@link ConstantDynamicEntry} describing a dynamic constant}\n-     * If a ConstantDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ConstantDynamicEntry} describing the dynamic constant\n+     * as the provided {@link DynamicConstantDesc}}\n@@ -391,0 +440,1 @@\n+     * @see ConstantDynamicEntry#asSymbol() ConstantDynamicEntry::asSymbol\n@@ -397,4 +447,5 @@\n-     * {@return A {@link ConstantDynamicEntry} describing a dynamic constant}\n-     * If a ConstantDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ConstantDynamicEntry} referring to a {@link\n+     * BootstrapMethodEntry} and a {@link NameAndTypeEntry}}\n+     * The {@code BootstrapMethodEntry} describes the bootstrap method\n+     * and its invocation arguments in addition to the name and type,\n+     * and the {@code NameAndTypeEntry} a name and a field descriptor.\n@@ -402,2 +453,4 @@\n-     * @param bootstrapMethodEntry the entry in the bootstrap method table\n-     * @param nameAndType the invocation name and type\n+     * @param bootstrapMethodEntry the {@code BootstrapMethodEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see ConstantDynamicEntry#bootstrap() ConstantDynamicEntry::bootstrap\n+     * @see ConstantDynamicEntry#nameAndType() ConstantDynamicEntry::nameAndType\n@@ -408,3 +461,1 @@\n-     * {@return An {@link IntegerEntry} describing the provided value}\n-     * If an integer entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return an {@link IntegerEntry} describing the provided value}\n@@ -413,0 +464,1 @@\n+     * @see IntegerEntry#intValue() IntegerEntry::intValue\n@@ -417,3 +469,1 @@\n-     * {@return A {@link FloatEntry} describing the provided value}\n-     * If a float entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link FloatEntry} describing the provided value}\n@@ -422,0 +472,1 @@\n+     * @see FloatEntry#floatValue() FloatEntry::floatValue\n@@ -426,3 +477,1 @@\n-     * {@return A {@link LongEntry} describing the provided value}\n-     * If a long entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link LongEntry} describing the provided value}\n@@ -431,0 +480,1 @@\n+     * @see LongEntry#longValue() LongEntry::longValue\n@@ -435,3 +485,1 @@\n-     * {@return A {@link DoubleEntry} describing the provided value}\n-     * If a double entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link DoubleEntry} describing the provided value}\n@@ -440,0 +488,1 @@\n+     * @see DoubleEntry#doubleValue() DoubleEntry::doubleValue\n@@ -444,3 +493,2 @@\n-     * {@return A {@link StringEntry} referencing the provided UTF8 entry}\n-     * If a String entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link StringEntry} referring to a {@link Utf8Entry}}\n+     * The {@code Utf8Entry} describes the string value.\n@@ -448,1 +496,2 @@\n-     * @param utf8 the UTF8 entry describing the string\n+     * @param utf8 the {@code Utf8Entry}\n+     * @see StringEntry#utf8() StringEntry::utf8\n@@ -453,3 +502,1 @@\n-     * {@return A {@link StringEntry} describing the provided value}\n-     * If a string entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link StringEntry} describing the provided value}\n@@ -458,0 +505,1 @@\n+     * @see StringEntry#stringValue() StringEntry::stringValue\n@@ -464,2 +512,3 @@\n-     * {@return A {@link ConstantValueEntry} describing the provided\n-     * Integer, Long, Float, Double, or String constant}\n+     * {@return a {@link ConstantValueEntry} describing the provided constant\n+     * {@link Integer}, {@link Long}, {@link Float}, {@link Double}, or {@link\n+     * String} value}\n@@ -467,2 +516,7 @@\n-     * @param c the constant\n-     * @see ConstantValueEntry#constantValue()\n+     * @param c the provided constant value\n+     * @throws IllegalArgumentException if the value is not one of {@code\n+     *         Integer}, {@code Long}, {@code Float}, {@code Double}, or {@code\n+     *         String}\n+     * @see ConstantValueEntry#constantValue() ConstantValueEntry::constantValue\n+     * @see ConstantValueAttribute#of(ConstantDesc)\n+     *      ConstantValueAttribute::of(ConstantDesc)\n@@ -480,5 +534,2 @@\n-     * {@return A {@link LoadableConstantEntry} describing the provided\n-     * constant}  The constant should be an Integer, String, Long, Float,\n-     * Double, ClassDesc (for a Class constant), MethodTypeDesc (for a MethodType\n-     * constant), DirectMethodHandleDesc (for a MethodHandle constant), or\n-     * a DynamicConstantDesc (for a dynamic constant.)\n+     * {@return a {@link LoadableConstantEntry} describing the provided constant\n+     * value}\n@@ -486,1 +537,1 @@\n-     * @param c the constant\n+     * @param c the nominal descriptor for the constant\n@@ -503,1 +554,1 @@\n-     * bootstrap method and static arguments}\n+     * bootstrap method and arguments}\n@@ -506,1 +557,1 @@\n-     * @param arguments the bootstrap arguments\n+     * @param arguments the arguments\n@@ -515,2 +566,4 @@\n-     * {@return a {@link BootstrapMethodEntry} describing the provided\n-     * bootstrap method and static arguments}\n+     * {@return a {@link BootstrapMethodEntry} referring to a {@link\n+     * MethodHandleEntry} and a list of {@link LoadableConstantEntry}}\n+     * The {@code MethodHandleEntry} is the bootstrap method, and the\n+     * list of {@code LoadableConstantEntry} is the arguments.\n@@ -518,2 +571,5 @@\n-     * @param methodReference the bootstrap method\n-     * @param arguments the bootstrap arguments\n+     * @param methodReference the {@code MethodHandleEntry}\n+     * @param arguments the list of {@code LoadableConstantEntry}\n+     * @see BootstrapMethodEntry#bootstrapMethod()\n+     *      BootstrapMethodEntry::bootstrapMethod\n+     * @see BootstrapMethodEntry#arguments() BootstrapMethodEntry::arguments\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":250,"deletions":194,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,3 @@\n- * pool.\n+ * pool or the bootstrap method table.  This is also thrown when the lazy\n+ * evaluation of constant pool or bootstrap method table entries encounter\n+ * format errors.\n@@ -50,1 +52,2 @@\n-     * @param message the detail message.\n+     * @param message the detail message, may be {@code null} for no detail\n+     *                message\n@@ -58,5 +61,4 @@\n-     * a detail message of {@code (cause==null ? null : cause.toString())}.\n-     * @param cause the cause (which is saved for later retrieval by the\n-     *        {@link Throwable#getCause()} method).  (A {@code null} value is\n-     *        permitted, and indicates that the cause is nonexistent or\n-     *        unknown.)\n+     * a detail message of {@code cause == null ? null : cause.toString()}.\n+     *\n+     * @param cause the cause, may be {@code null} for nonexistent or unknown\n+     *              cause\n@@ -72,6 +74,4 @@\n-     * @param message the detail message (which is saved for later retrieval\n-     *        by the {@link Throwable#getMessage()} method).\n-     * @param cause the cause (which is saved for later retrieval by the\n-     *        {@link Throwable#getCause()} method).  (A {@code null} value\n-     *        is permitted, and indicates that the cause is nonexistent or\n-     *        unknown.)\n+     * @param message the detail message, may be {@code null} for no detail\n+     *                message\n+     * @param cause the cause, may be {@code null} for nonexistent or unknown\n+     *              cause\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolException.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,2 @@\n- * Models a constant pool entry that can be used as the constant in a\n- * {@link Attributes#constantValue() ConstantValue} attribute; this includes the four\n- * primitive constant types and {@linkplain String} constants.\n+ * Marker interface for constant pool entries that can represent constant values\n+ * in the {@link Attributes#constantValue() ConstantValue} attribute.\n@@ -35,0 +34,2 @@\n+ * @see ConstantPoolBuilder#constantValueEntry\n+ *      ConstantPoolBuilder::constantValueEntry\n@@ -42,2 +43,2 @@\n-     * {@return the constant value}  The constant value will be an {@link Integer},\n-     * {@link Long}, {@link Float}, {@link Double}, or {@link String}.\n+     * {@return the constant value}  The constant value will be an {@link\n+     * Integer}, {@link Long}, {@link Float}, {@link Double}, or {@link String}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantValueEntry.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,10 @@\n- * Models a {@code CONSTANT_Double_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info Structures\n+ * Models a {@code CONSTANT_Double_info} structure, representing a {@code\n+ * double} constant, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code DoubleEntry} is modeled by a {@code double}.  Conversions\n+ * are through {@link ConstantPoolBuilder#doubleEntry} and {@link #doubleValue()}.\n+ * In the conversions, all NaN values of the {@code double} may be collapsed\n+ * into a single {@linkplain Double#NaN \"canonical\" NaN value}.\n+ * <p>\n+ * A double entry has a {@linkplain #width() width} of {@code 2}, making its\n+ * subsequent constant pool index valid and unusable.\n@@ -36,0 +43,3 @@\n+ * @see ConstantPoolBuilder#doubleEntry ConstantPoolBuilder::doubleEntry\n+ * @jvms 4.4.5 The {@code CONSTANT_Long_info} and {@code CONSTANT_Double_info}\n+ *             Structures\n@@ -43,1 +53,4 @@\n-     * {@return the double value}\n+     * {@return the {@code double} value}\n+     *\n+     * @see ConstantPoolBuilder#doubleEntry(double)\n+     *      ConstantPoolBuilder::doubleEntry(double)\n@@ -47,3 +60,0 @@\n-    \/**\n-     * {@return the type of the constant}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/DoubleEntry.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,15 @@\n- * Models a dynamic constant pool entry, which is either {@link ConstantDynamicEntry}\n- * or {@link InvokeDynamicEntry}.\n- * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+ * Superinterface modeling dynamically-computed constant pool entries, which\n+ * include {@link ConstantDynamicEntry} and {@link InvokeDynamicEntry}, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * Different types of dynamically-computed constant pool entries bear structural\n+ * similarities, but they appear in distinct locations.  As a result, their uses\n+ * are represented by different symbolic descriptors, specific to each subtype.\n+ * <p>\n+ * A dynamic constant entry is composite:\n+ * {@snippet lang=text :\n+ * DynamicConstantPoolEntry(\n+ *     BootstrapMethodEntry bootstrap, \/\/ @link substring=\"bootstrap\" target=\"#bootstrap()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n@@ -34,0 +46,5 @@\n+ * @see java.lang.invoke##jvm_mods Dynamic resolution of call sites and\n+ *      constants\n+ * @jvms 4.4.10 The {@code CONSTANT_Dynamic_info} and {@code\n+ *              CONSTANT_InvokeDynamic_info} Structures\n+ * @jvms 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n@@ -42,0 +59,6 @@\n+     *\n+     * @see java.lang.invoke##bsm Execution of bootstrap methods\n+     * @see ConstantPoolBuilder#constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     * @see ConstantPoolBuilder#invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n@@ -46,1 +69,3 @@\n-     * {@return index of the entry in the bootstrap method table for this constant}\n+     * {@return index of the entry in the bootstrap method table for this\n+     * constant}  The return value is equivalent to {@code\n+     * bootstrap().bsmIndex()}.\n@@ -51,1 +76,8 @@\n-     * {@return the invocation name and type}\n+     * {@return the name and the descriptor string indicated by this symbolic\n+     * reference}\n+     *\n+     * @see java.lang.invoke##bsm Execution of bootstrap methods\n+     * @see ConstantPoolBuilder#constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     * @see ConstantPoolBuilder#invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n@@ -56,1 +88,1 @@\n-     * {@return the invocation name}\n+     * {@return the name indicated by this symbolic reference}\n@@ -63,1 +95,8 @@\n-     * {@return the invocation type}\n+     * {@return the descriptor string indicated by this symbolic reference}\n+     * This is a field descriptor string if this entry is a {@link\n+     * ConstantDynamicEntry}, or a method descriptor string if this entry is a\n+     * {@link InvokeDynamicEntry}.\n+     *\n+     * @apiNote\n+     * Each subinterface has its specific accessor named {@code typeSymbol} for\n+     * the symbolic descriptor derived from this descriptor string.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/DynamicConstantPoolEntry.java","additions":47,"deletions":8,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,13 @@\n- * Models a {@code CONSTANT_Fieldref_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures\n+ * Models a {@code CONSTANT_Fieldref_info} structure, or a symbolic reference\n+ * to a field, in the constant pool of a {@code class} file.\n+ * <p>\n+ * A field reference constant pool entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"FieldRefEntry\" target=\"ConstantPoolBuilder#fieldRefEntry(ClassEntry, NameAndTypeEntry)\" :\n+ * FieldRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the {@link #type() nameAndType.type()} represents a {@linkplain\n+ * #typeSymbol() field descriptor} string.\n@@ -37,0 +47,4 @@\n+ * @see ConstantPoolBuilder#fieldRefEntry ConstantPoolBuilder::fieldRefEntry\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -43,1 +57,1 @@\n-     * {@return a symbolic descriptor for the field's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() field type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/FieldRefEntry.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,7 @@\n- * Models a {@code CONSTANT_Float_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures\n+ * Models a {@code CONSTANT_Float_info} structure, or a {@code float} constant,\n+ * in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code FloatEntry} is modeled by a {@code float}.  Conversions\n+ * are through {@link ConstantPoolBuilder#floatEntry} and {@link #floatValue()}.\n+ * In the conversions, all NaN values of the {@code float} may be collapsed into\n+ * a single {@linkplain Float#NaN \"canonical\" NaN value}.\n@@ -36,0 +40,3 @@\n+ * @see ConstantPoolBuilder#floatEntry ConstantPoolBuilder::floatEntry\n+ * @jvms 4.4.4 The {@code CONSTANT_Integer_info} and {@code CONSTANT_Float_info}\n+ *             Structures\n@@ -43,1 +50,3 @@\n-     * {@return the float value}\n+     * {@return the {@code float} value}\n+     *\n+     * @see ConstantPoolBuilder#floatEntry(float)\n@@ -45,1 +54,0 @@\n-\n@@ -48,3 +56,0 @@\n-    \/**\n-     * {@return the type of the constant}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/FloatEntry.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,5 @@\n- * Models a {@code CONSTANT_Integer_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures\n+ * Models a {@code CONSTANT_Integer_info} structure, or an {@code int} constant,\n+ * in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code IntegerEntry} is modeled by an {@code int}.  Conversions\n+ * are through {@link ConstantPoolBuilder#intEntry(int)} and {@link #intValue()}.\n@@ -36,0 +38,3 @@\n+ * @see ConstantPoolBuilder#intEntry ConstantPoolBuilder::intEntry\n+ * @jvms 4.4.4 The {@code CONSTANT_Integer_info} and {@code CONSTANT_Float_info}\n+ *             Structures\n@@ -43,1 +48,3 @@\n-     * {@return the integer value}\n+     * {@return the {@code int} value}\n+     *\n+     * @see ConstantPoolBuilder#intEntry(int)\n@@ -47,3 +54,0 @@\n-    \/**\n-     * {@return the type of the constant}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/IntegerEntry.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,14 @@\n- * Models a {@code CONSTANT_InterfaceMethodRef_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures\n+ * Models a {@code CONSTANT_InterfaceMethodRef_info} structure, or a symbolic\n+ * reference to an interface method, in the constant pool of a {@code class}\n+ * file.\n+ * <p>\n+ * An interface method reference entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"InterfaceMethodRefEntry\" target=\"ConstantPoolBuilder#interfaceMethodRefEntry(ClassEntry, NameAndTypeEntry)\" :\n+ * InterfaceMethodRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the {@link #type() type} in the {@code nameAndType} is a {@linkplain\n+ * #typeSymbol() method descriptor} string.\n@@ -37,0 +48,5 @@\n+ * @see ConstantPoolBuilder#interfaceMethodRefEntry\n+ *      ConstantPoolBuilder::interfaceMethodRefEntry\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -44,1 +60,1 @@\n-     * {@return a symbolic descriptor for the interface method's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() method type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/InterfaceMethodRefEntry.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,20 @@\n- * Models a constant pool entry for a dynamic call site.\n- * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+ * Models a {@code CONSTANT_InvokeDynamic_info} structure, or the symbolic\n+ * reference to a <dfn>{@index \"dynamically-computed call site\"}<\/dfn>, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code InvokeDynamicEntry} is modeled by a {@link\n+ * DynamicCallSiteDesc} symbolic descriptor.  It can be obtained from {@link\n+ * #asSymbol() InvokeDynamicEntry::asSymbol} and converted back to a constant\n+ * pool entry through {@link ConstantPoolBuilder#invokeDynamicEntry(DynamicCallSiteDesc)\n+ * ConstantPoolBuilder::invokeDynamicEntry}.\n+ * <p>\n+ * An invoke dynamic entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"InvokeDynamicEntry\" target=\"ConstantPoolBuilder#invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\" :\n+ * InvokeDynamicEntry(\n+ *     BootstrapMethodEntry bootstrap, \/\/ @link substring=\"bootstrap\" target=\"#bootstrap()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the {@link #type() type} in the {@code nameAndType} is a {@linkplain\n+ * #typeSymbol() method descriptor} string.\n@@ -38,0 +56,11 @@\n+ * @apiNote\n+ * A dynamically-computed call site is frequently called a <dfn>{@index \"dynamic\n+ * call site\"}<\/dfn>, or an <dfn>{@index \"indy\"}<\/dfn>, from the abbreviation of\n+ * \"invoke dynamic\".\n+ *\n+ * @see ConstantPoolBuilder#invokeDynamicEntry\n+ *      ConstantPoolBuilder::invokeDynamicEntry\n+ * @see DynamicCallSiteDesc\n+ * @see java.lang.invoke##indyinsn Dynamically-computed call sites\n+ * @jvms 4.4.10 The {@code CONSTANT_Dynamic_info} and {@code\n+ *              CONSTANT_InvokeDynamic_info} Structures\n@@ -45,1 +74,2 @@\n-     * {@return a symbolic descriptor for the call site's invocation type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() invocation\n+     * type} of this dynamic call site}\n@@ -52,1 +82,4 @@\n-     * {@return a symbolic descriptor for the dynamic call site}\n+     * {@return a symbolic descriptor for this dynamic call site}\n+     *\n+     * @see ConstantPoolBuilder#invokeDynamicEntry(DynamicCallSiteDesc)\n+     *      ConstantPoolBuilder::invokeDynamicEntry(DynamicCallSiteDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/InvokeDynamicEntry.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Opcode;\n@@ -28,0 +30,1 @@\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -32,1 +35,5 @@\n- * {@code LDC} instructions.\n+ * {@link ConstantInstruction.LoadConstantInstruction ldc} instructions.\n+ * <p>\n+ * The use of a {@code LoadableConstantEntry} is modeled by a {@link ConstantDesc}.\n+ * Conversions are through {@link ConstantPoolBuilder#loadableConstantEntry(ConstantDesc)}\n+ * and {@link #constantValue()}.\n@@ -34,0 +41,2 @@\n+ * @see CodeBuilder#ldc(LoadableConstantEntry)\n+ * @jvms 4.4 The Constant Pool\n@@ -41,1 +50,3 @@\n-     * {@return the constant described by this entry}\n+     * {@return a symbolic descriptor of this constant}\n+     *\n+     * @see ConstantPoolBuilder#loadableConstantEntry(ConstantDesc)\n@@ -46,1 +57,6 @@\n-     * {@return the type of the constant}\n+     * {@return the data type of this constant}\n+     * <p>\n+     * If the data type is of {@linkplain TypeKind#slotSize() category} 2, this\n+     * constant must be loaded with {@link Opcode#LDC2_W ldc2_w}; otherwise, the\n+     * data type is of category 1, and this constant must be loaded with {@link\n+     * Opcode#LDC ldc} or {@link Opcode#LDC_W ldc_w}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,8 @@\n- * Models a {@code CONSTANT_Long_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info Structures\n+ * Models a {@code CONSTANT_Long_info} structure, or a {@code long} constant, in\n+ * the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code LongEntry} is modeled by a {@code long}.  Conversions are\n+ * through {@link ConstantPoolBuilder#longEntry(long)} and {@link #longValue()}.\n+ * <p>\n+ * A long entry has a {@linkplain #width() width} of {@code 2}, making its\n+ * subsequent constant pool index valid and unusable.\n@@ -36,0 +41,3 @@\n+ * @see ConstantPoolBuilder#longEntry ConstantPoolBuilder::longEntry\n+ * @jvms 4.4.5 The {@code CONSTANT_Long_info} and {@code CONSTANT_Double_info}\n+ *             Structures\n@@ -43,1 +51,4 @@\n-     * {@return the long value}\n+     * {@return the {@code long} value}\n+     *\n+     * @see ConstantPoolBuilder#longEntry(long)\n+     *      ConstantPoolBuilder::longEntry(long)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LongEntry.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.lang.classfile.Opcode;\n+\n@@ -30,2 +32,18 @@\n- * Models a member reference constant in the constant pool of a classfile,\n- * which includes references to fields, methods, and interface methods.\n+ * Superinterface modeling symbolic references to a member of a class or interface\n+ * in the constant pool of a {@code class} file, which include references to\n+ * {@linkplain FieldRefEntry fields}, {@linkplain MethodRefEntry class methods},\n+ * and {@linkplain InterfaceMethodRefEntry interface methods}.\n+ * <p>\n+ * Different types of symbolic references to a member of a class or interface\n+ * bear structural similarities and share parts of the resolution processes, and\n+ * they can sometimes appear in the same locations.  For example, both {@link\n+ * MethodRefEntry} and {@link InterfaceMethodRefEntry} can appear in an {@link\n+ * Opcode#INVOKESTATIC invokestatic} instruction.\n+ * <p>\n+ * A member reference entry is composite:\n+ * {@snippet lang=text :\n+ * MemberRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n@@ -33,0 +51,3 @@\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -39,1 +60,1 @@\n-     * {@return the class in which this member ref lives}\n+     * {@return the class or interface which this member belongs to}\n@@ -44,1 +65,1 @@\n-     * {@return the name and type of the member}\n+     * {@return the name and descriptor string of the member}\n@@ -56,1 +77,8 @@\n-     * {@return the type of the member}\n+     * {@return the descriptor string of the member}  This is a field descriptor\n+     * string if this entry is a {@link FieldRefEntry}, or a method descriptor\n+     * string if this entry is a {@link MethodRefEntry} or {@link\n+     * InterfaceMethodRefEntry}.\n+     *\n+     * @apiNote\n+     * Each subinterface defines a {@code typeSymbol()} accessor for the\n+     * symbolic descriptor for the member type.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MemberRefEntry.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleInfo;\n@@ -33,3 +35,23 @@\n- * Models a {@code CONSTANT_MethodHandle_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.8 The CONSTANT_MethodHandle_info Structure\n+ * Models a {@code CONSTANT_MethodHandle_info} structure, or a symbolic\n+ * reference to a {@linkplain MethodHandle method handle}, in the constant pool\n+ * of a {@code class} file.  The method handle directly accesses an accessible\n+ * method, field, or constructor.\n+ * <p>\n+ * The use of a {@code MethodHandleEntry} is modeled by a {@link\n+ * DirectMethodHandleDesc}.  Conversions are through {@link\n+ * ConstantPoolBuilder#methodHandleEntry(DirectMethodHandleDesc)} and {@link\n+ * #asSymbol()}.\n+ * <p>\n+ * A method handle entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"MethodHandleEntry\" target=\"ConstantPoolBuilder#methodHandleEntry(int, MemberRefEntry)\" :\n+ * MethodHandleEntry(\n+ *     int refKind, \/\/ @link substring=\"refKind\" target=\"#kind()\"\n+ *     MemberRefEntry reference \/\/ @link substring=\"reference\" target=\"#reference()\"\n+ * )\n+ * }\n+ * where {@code refKind} is in the range {@code [1, 9]}.\n+ *\n+ * @see ConstantPoolBuilder#methodHandleEntry\n+ *      ConstantPoolBuilder::methodHandleEntry\n+ * @jvms 4.4.8 The {@code CONSTANT_MethodHandle_info} Structure\n@@ -43,0 +65,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -50,1 +77,2 @@\n-     * @see java.lang.invoke.MethodHandleInfo\n+     *\n+     * @see MethodHandleInfo##refkinds Reference kinds\n@@ -55,1 +83,2 @@\n-     * {@return the constant pool entry describing the method}\n+     * {@return the constant pool entry describing the field or method,\n+     * according to the {@linkplain #kind() reference kind}}\n@@ -61,0 +90,3 @@\n+     *\n+     * @see ConstantPoolBuilder#methodHandleEntry(DirectMethodHandleDesc)\n+     *      ConstantPoolBuilder::methodHandleEntry(DirectMethodHandleDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodHandleEntry.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,13 @@\n- * Models a {@code CONSTANT_MethodRef_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures\n+ * Models a {@code CONSTANT_MethodRef_info} structure, or a symbolic reference\n+ * to a class method, in the constant pool of a {@code class} file.\n+ * <p>\n+ * A class method reference entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"MethodRefEntry\" target=\"ConstantPoolBuilder#methodRefEntry(ClassEntry, NameAndTypeEntry)\" :\n+ * MethodRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the type in the {@code NameAndTypeEntry} is a {@linkplain #typeSymbol()\n+ * method descriptor} string.\n@@ -37,0 +47,4 @@\n+ * @see ConstantPoolBuilder#methodRefEntry ConstantPoolBuilder::methodRefEntry\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -43,1 +57,1 @@\n-     * {@return a symbolic descriptor for the method's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() method type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodRefEntry.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,14 @@\n- * Models a {@code CONSTANT_MethodType_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.9 The CONSTANT_MethodType_info Structure\n+ * Models a {@code CONSTANT_MethodType_info} structure, or a symbolic reference\n+ * to a method type, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code MethodTypeEntry} is modeled by a {@link MethodTypeDesc}.\n+ * Conversions are through {@link ConstantPoolBuilder#methodTypeEntry(MethodTypeDesc)}\n+ * and {@link #asSymbol()}.\n+ * <p>\n+ * A method type entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"MethodTypeEntry\" target=\"ConstantPoolBuilder#methodTypeEntry(Utf8Entry)\" :\n+ * MethodTypeEntry(Utf8Entry descriptor) \/\/ @link substring=\"descriptor\" target=\"#descriptor()\"\n+ * }\n+ * where {@code descriptor} is a {@linkplain #asSymbol() method descriptor}\n+ * string.\n@@ -37,0 +48,1 @@\n+ * @jvms 4.4.9 The {@code CONSTANT_MethodType_info} Structure\n@@ -43,0 +55,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -49,1 +66,1 @@\n-     * {@return the constant pool entry describing the method type}\n+     * {@return the {@linkplain #asSymbol() method descriptor} string}\n@@ -54,1 +71,2 @@\n-     * {@return a symbolic descriptor for the method type}\n+     * {@return a symbolic descriptor for the {@linkplain #descriptor() method\n+     * type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodTypeEntry.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,13 @@\n- * Models a {@code CONSTANT_Module_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.11 The CONSTANT_Module_info Structure\n+ * Models a {@code CONSTANT_Module_info} structure, denoting a module, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code ModuleEntry} is modeled by a {@link ModuleDesc}.\n+ * Conversions are through {@link ConstantPoolBuilder#moduleEntry(ModuleDesc)}\n+ * and {@link #asSymbol()}.\n+ * <p>\n+ * A module entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"ModuleEntry\" target=\"ConstantPoolBuilder#moduleEntry(Utf8Entry)\" :\n+ * ModuleEntry(Utf8Entry name) \/\/ @link substring=\"name\" target=\"#name()\"\n+ * }\n+ * where {@code name} is a {@linkplain #asSymbol() module name}.\n@@ -36,0 +46,1 @@\n+ * @jvms 4.4.11 The {@code CONSTANT_Module_info} Structure\n@@ -41,1 +52,1 @@\n-     * {@return the name of the module}\n+     * {@return the name of the {@linkplain #asSymbol() module}}\n@@ -46,1 +57,1 @@\n-     * {@return a symbolic descriptor for the module}\n+     * {@return a symbolic descriptor for the {@linkplain #name() module name}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ModuleEntry.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.TypeDescriptor;\n+\n@@ -30,3 +34,21 @@\n- * Models a {@code CONSTANT_NameAndType_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.6 The CONSTANT_NameAndType_info Structure\n+ * Models a {@code CONSTANT_NameAndType_info} structure, representing a field or\n+ * method, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code NameAndTypeEntry} is symbolically represented as a\n+ * {@code String name}, and a {@link ConstantPoolBuilder#nameAndTypeEntry(String,\n+ * ClassDesc) ClassDesc} or a {@link ConstantPoolBuilder#nameAndTypeEntry(String,\n+ * MethodTypeDesc) MethodTypeDesc} {@code type}, depending on where this {@code\n+ * NameAndTypeEntry} appears.  The accessors to the symbolic descriptors for the\n+ * {@code type} is defined on a per-use-site basis, such as {@link\n+ * FieldRefEntry#typeSymbol()} returning a {@code ClassDesc}, and {@link\n+ * MethodRefEntry#typeSymbol()} returning a {@code MethodTypeDesc}.\n+ * <p>\n+ * A name and type entry is composite:\n+ * {@snippet lang=text :\n+ * NameAndTypeEntry( \/\/ @link substring=\"NameAndTypeEntry\" target=\"ConstantPoolBuilder#nameAndTypeEntry(Utf8Entry, Utf8Entry)\"\n+ *     Utf8Entry name, \/\/ @link substring=\"name\" target=\"#name()\"\n+ *     Utf8Entry type  \/\/ @link substring=\"type\" target=\"#type()\"\n+ * )\n+ * }\n+ * where {@code name} is an unqualified name, and {@code type} is a field or\n+ * method descriptor string.\n@@ -34,0 +56,1 @@\n+ * @jvms 4.4.6 The {@code CONSTANT_NameAndType_info} Structure\n@@ -45,1 +68,4 @@\n-     * {@return the field or method descriptor}\n+     * {@return the field or method {@linkplain TypeDescriptor descriptor}\n+     * string}  It is a method descriptor strings if it starts with {@code (}.\n+     * Otherwise, it is a field descriptor string, and must start with one of\n+     * the {@code BCDFIJSZL[} characters.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/NameAndTypeEntry.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,15 @@\n- * Models a {@code CONSTANT_Package_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.12 The CONSTANT_Package_info Structure\n+ * Models a {@code CONSTANT_Package_info}, representing a package, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code PackageEntry} is represented by a {@link PackageDesc}\n+ * that does not represent the unnamed package.  Conversions are through\n+ * {@link ConstantPoolBuilder#packageEntry(PackageDesc)} and\n+ * {@link #asSymbol()}.\n+ * <p>\n+ * A package entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"PackageEntry\" target=\"ConstantPoolBuilder#packageEntry(Utf8Entry)\" :\n+ * PackageEntry(Utf8Entry name) \/\/ @link substring=\"name\" target=\"#name()\"\n+ * }\n+ * where {@code name} is the {@linkplain ClassEntry##internalname internal form}\n+ * of a binary package name and is not empty.\n@@ -36,0 +48,1 @@\n+ * @jvms 4.4.12 The {@code CONSTANT_Package_info} Structure\n@@ -41,1 +54,2 @@\n-     * {@return the package name}\n+     * {@return the {@linkplain ClassEntry##internalname internal form} of the\n+     * {@linkplain #asSymbol() package} name}\n@@ -46,1 +60,1 @@\n-     * {@return a symbolic descriptor for the package name}\n+     * {@return a symbolic descriptor for the {@linkplain #name() package name}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PackageEntry.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,5 @@\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.ClassFileBuilder;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+\n@@ -28,1 +33,14 @@\n- * Models an entry in the constant pool of a classfile.\n+ * Models an entry in the constant pool of a {@code class} file.  Entries are\n+ * read from {@code class} files, and can be created with a {@link\n+ * ConstantPoolBuilder} to write to {@code class} files.\n+ *\n+ * @implNote\n+ * <h2 id=\"unbound\">Unbound Constant Pool Entries<\/h2>\n+ * Implementations may create unbound constant pool entries not belonging to\n+ * an actual constant pool.  They conveniently represent constant pool entries\n+ * referred by unbound {@linkplain Attribute attributes} not read from a {@code\n+ * class} file.  Their {@link #index() index()} return a non-positive invalid\n+ * value, and behaviors of their {@link #constantPool() constantPool()} are\n+ * unspecified.  They are considered alien to any {@linkplain\n+ * ClassFileBuilder#constantPool() contextual constant pool} and will be\n+ * converted when they are written to {@code class} files.\n@@ -30,0 +48,1 @@\n+ * @see ConstantPoolBuilder##alien Alien Constant Pool Entries\n@@ -91,0 +110,8 @@\n+     *\n+     * @apiNote\n+     * Given a {@link ConstantPoolBuilder} {@code builder} and a {@code\n+     * PoolEntry entry}, use {@link ConstantPoolBuilder#canWriteDirect\n+     * builder.canWriteDirect(entry.constantPool())} instead of object equality\n+     * of the constant pool to determine if an entry belongs to the builder.\n+     *\n+     * @see ##unbound Unbound Constant Pool Entries\n@@ -105,0 +132,4 @@\n+     * A valid index is always positive; if the index is non-positive, this\n+     * entry is {@linkplain ##unbound unbound}.\n+     *\n+     * @see ##unbound Unbound Constant Pool Entries\n@@ -110,0 +141,17 @@\n+     * <p>\n+     * All pool entries except {@link LongEntry CONSTANT_Long} and {@link\n+     * DoubleEntry CONSTANT_Double} have width {@code 1}. These two exceptions\n+     * have width {@code 2}, and their subsequent indices at {@link #index()\n+     * index() + 1} are considered unusable.\n+     *\n+     * @apiNote\n+     * If this entry is {@linkplain LoadableConstantEntry loadable}, the width\n+     * of this entry does not decide if this entry should be loaded with {@link\n+     * Opcode#LDC ldc} or {@link Opcode#LDC2_W ldc2_w}.  For example, {@link\n+     * ConstantDynamicEntry} always has width {@code 1}, but it must be loaded\n+     * with {@code ldc2_w} if its {@linkplain ConstantDynamicEntry#typeKind()\n+     * type} is {@link TypeKind#LONG long} or {@link TypeKind#DOUBLE double}.\n+     * Use {@link LoadableConstantEntry#typeKind() typeKind().slotSize()} to\n+     * determine the loading instruction instead.\n+     *\n+     * @see ConstantPool##index Index in the Constant Pool\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PoolEntry.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,12 @@\n- * Models a {@code CONSTANT_String_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.3 The CONSTANT_String_info Structure\n+ * Models a {@code CONSTANT_String_info} structure, or a string constant, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code StringEntry} is represented by a {@link String}.\n+ * Conversions are through {@link ConstantPoolBuilder#stringEntry(String)} and\n+ * {@link #stringValue()}.\n+ * <p>\n+ * A string entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"StringEntry\" target=\"ConstantPoolBuilder#stringEntry(Utf8Entry)\" :\n+ * StringEntry(Utf8Entry utf8) \/\/ @link substring=\"utf8\" target=\"#utf8()\"\n+ * }\n@@ -34,0 +43,1 @@\n+ * @jvms 4.4.3 The {@code CONSTANT_String_info} Structure\n@@ -41,0 +51,2 @@\n+     *\n+     * @see ConstantPoolBuilder#stringEntry(Utf8Entry)\n@@ -46,0 +58,2 @@\n+     *\n+     * @see ConstantPoolBuilder#stringEntry(String)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/StringEntry.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,7 @@\n+import java.io.DataInput;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.MethodModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.TypeDescriptor;\n+\n@@ -30,3 +37,21 @@\n- * Models a {@code CONSTANT_UTF8_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.7 The CONSTANT_Utf8_info Structure\n+ * Models a {@code CONSTANT_UTF8_info} constant, representing strings, in the\n+ * constant pool of a {@code class} file.  This describes strings in the\n+ * {@linkplain DataInput##modified-utf-8 Modified UTF-8} format.\n+ * <p>\n+ * The use of a {@code Utf8Entry} is represented by a {@link String}.\n+ * Conversions are through {@link ConstantPoolBuilder#utf8Entry(String)} and\n+ * {@link #stringValue()}.\n+ * <p>\n+ * Some uses of {@code Utf8Entry} represent field or method {@linkplain\n+ * TypeDescriptor#descriptorString() descriptor strings}, symbolically\n+ * represented as {@link ClassDesc} or {@link MethodTypeDesc}, depending on\n+ * where a {@code Utf8Entry} appear.  Entries representing such uses are created\n+ * with {@link ConstantPoolBuilder#utf8Entry(ClassDesc)} and {@link\n+ * ConstantPoolBuilder#utf8Entry(MethodTypeDesc)}, and they can be converted to\n+ * symbolic descriptors on a per-use-site basis, such as in {@link\n+ * AnnotationValue.OfClass#classSymbol()} and {@link MethodModel#methodTypeSymbol()}.\n+ * <p>\n+ * Unlike most constant pool entries, a UTF-8 entry is of flexible length: it is\n+ * represented as an array structure, with an {@code u2} for the data length in\n+ * bytes, followed by that number of bytes of Modified UTF-8 data.  It can\n+ * represent at most 65535 bytes of data due to the physical restrictions.\n@@ -34,0 +59,2 @@\n+ * @jvms 4.4.7 The {@code CONSTANT_Utf8_info} Structure\n+ * @see DataInput##modified-utf-8 Modified UTF-8\n@@ -42,0 +69,9 @@\n+     *\n+     * @apiNote\n+     * A {@code Utf8Entry} can be used directly as a {@link CharSequence} if\n+     * {@code String} functionalities are not strictly desired.  If only string\n+     * equivalence is desired, {@link #equalsString(String) equalsString} should\n+     * be used.  Reduction of string processing can significantly improve {@code\n+     * class} file reading performance.\n+     *\n+     * @see ConstantPoolBuilder#utf8Entry(String)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * <h2>Provides interfaces describing classfile constant pool entries for the {@link java.lang.classfile} library.<\/h2>\n+ * <h2>Provides interfaces describing constant pool entries for the {@link java.lang.classfile} library.<\/h2>\n@@ -29,1 +29,7 @@\n- * The {@code java.lang.classfile.constantpool} package contains interfaces describing classfile constant pool entries.\n+ * The {@code java.lang.classfile.constantpool} package contains interfaces describing constant pool entries in the\n+ * {@code class} file format.  Constant pool entries are low-level models to faithfully represent the exact structure\n+ * of a {@code class} file.\n+ * <p>\n+ * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n+ * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n+ * to be thrown.\n@@ -31,0 +37,38 @@\n+ * <h2 id=\"reading\">Reading the constant pool entries<\/h2>\n+ * When read from {@code class} files, the pool entries are lazily inflated; the contents of these entries, besides the\n+ * bare structure, are not evaluated to speed up parsing.  Entries to users interest, usually accessed from other models\n+ * and elements, have their contents read on demand.  For example, to search for methods, a user should filter first by\n+ * access flags and then by method name, and use {@link Utf8Entry#equalsString(String)} instead of checking equality\n+ * against {@link Utf8Entry#stringValue()}.  This avoids inflation of UTF-8 entries as much as possible:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"isStaticWorkMethod\"}\n+ * <p>\n+ * The entries also define accessors to validated symbolic information with nominal descriptor abstractions from the\n+ * {@link java.lang.constant} package.  These symbolic information accessors perform validation against the read\n+ * {@code class} files, and throw {@link IllegalArgumentException} when the accessed constant pool entry contains\n+ * invalid data.  The nominal descriptors represent validated data, which saves users from extra validations in future\n+ * processing.\n+ * <p>\n+ * Due to the lazy nature of {@code class} file parsing, {@link IllegalArgumentException} indicating malformed\n+ * {@code class} file data can be thrown at any method invocation.  For example, an exception may come from a {@link\n+ * ClassEntry} when it is first read from the constant pool (referring to an invalid index or wrong type of entry), when\n+ * its referred UTF-8 entry is expanded (malformed UTF-8 data), or when its symbolic information is accessed (the string\n+ * is not valid for a class entry).\n+ *\n+ * <h2 id=\"writing\">Writing the constant pool entries<\/h2>\n+ * In general, users do not need to worry about working with the constant pool and its entries when writing {@code\n+ * class} files.  Most Class-File API models and elements have two sets of factory methods: one that accepts symbolic\n+ * information representing the uses, and another that accepts constant pool entries.  The constant pool builder\n+ * associated with {@code class} file builders, {@link ClassFileBuilder#constantPool}, automatically creates or reuses\n+ * pool entries from the symbolic information.  Validated data in symbolic information helps {@code class} file\n+ * generation by avoiding extraneous parsing of raw constant pool entry data.\n+ * <p>\n+ * As always, users can use factories that accept constant pool entries if they already have them by hand, or if they\n+ * desire fine-grained control over {@code class} file generation.\n+ * <p>\n+ * If many models and elements are reused from another {@link ClassModel} in class building, the class building process\n+ * can use a constant pool builder that extends from the given {@code ClassModel}, available through {@link\n+ * ConstantPoolBuilder#of(ClassModel) ConstantPoolBuilder::of(ClassModel)}, so that byte data with constant pool\n+ * references can be copied in batch, speeding up class building.  This is especially applicable to class transformations,\n+ * and {@link ClassFile.ConstantPoolSharingOption ConstantPoolSharingOption} exists to control this behavior.\n+ *\n+ * @jvms 4.4 The Constant Pool\n@@ -35,0 +79,4 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileBuilder;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/package-info.java","additions":51,"deletions":3,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.classfile.constantpool.snippet;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+\n+class PackageSnippets {\n+\n+    \/\/ @start region=isStaticWorkMethod\n+    boolean isStaticWorkMethod(MethodModel method) {\n+        \/\/ check static flag first to avoid unnecessary evaluation of UTF-8 entry\n+        return (method.flags().flagsMask() & ClassFile.ACC_STATIC) != 0\n+                \/\/ use equalsString to avoid full conversion to String for comparison\n+                \/\/ the Utf8Entry can also act as a basic CharSequence without full conversion\n+                \/\/ @link substring=\"methodName\" target=\"MethodModel#methodName\" :\n+                && method.methodName().equalsString(\"work\"); \/\/ @link substring=\"equalsString\" target=\"Utf8Entry#equalsString\"\n+    }\n+    \/\/ @end\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/snippet-files\/PackageSnippets.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -1100,8 +1100,8 @@\n-     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n-     * expects an offset-based zone and will not match region-based zones.\n-     * The offset ID, such as '+02:30', may be at the start of the parse,\n-     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n-     * equivalent to using {@link #appendOffset(String, String)} using the\n-     * arguments 'HH:MM:ss' and the no offset string '0'.\n-     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n-     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.\n+     * If the parse starts with '+' or '-', then the parser expects an\n+     * offset-based zone and will not match region-based zones. The offset\n+     * ID parsing is equivalent to using {@link #appendOffset(String, String)}\n+     * using the arguments 'HH:MM:ss' and the no offset string '0'.\n+     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser can\n+     * match a following offset, then a region-based zone with the parsed\n+     * offset will be returned, or else if the parser cannot match a following\n+     * offset, then {@link ZoneOffset#UTC} is selected.\n@@ -1121,3 +1121,3 @@\n-     *   \"UT+01:30\"                -- ZoneOffset.of(\"+01:30\")\n-     *   \"UTC+01:30\"               -- ZoneOffset.of(\"+01:30\")\n-     *   \"GMT+01:30\"               -- ZoneOffset.of(\"+01:30\")\n+     *   \"UT+01:30\"                -- ZoneId.of(\"UT+01:30\")\n+     *   \"UTC+01:30\"               -- ZoneId.of(\"UTC+01:30\")\n+     *   \"GMT+01:30\"               -- ZoneId.of(\"GMT+01:30\")\n@@ -1138,2 +1138,1 @@\n-     * This appends an instruction to format\/parse the zone ID to the builder\n-     * only if it is a region-based ID.\n+     * This appends an instruction to format only region-based zone IDs to the builder.\n@@ -1151,8 +1150,8 @@\n-     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n-     * expects an offset-based zone and will not match region-based zones.\n-     * The offset ID, such as '+02:30', may be at the start of the parse,\n-     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n-     * equivalent to using {@link #appendOffset(String, String)} using the\n-     * arguments 'HH:MM:ss' and the no offset string '0'.\n-     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n-     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.\n+     * If the parse starts with '+' or '-', then the parser expects an\n+     * offset-based zone and will not match region-based zones. The offset\n+     * ID parsing is equivalent to using {@link #appendOffset(String, String)}\n+     * using the arguments 'HH:MM:ss' and the no offset string '0'.\n+     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser can\n+     * match a following offset, then a region-based zone with the parsed\n+     * offset will be returned, or else if the parser cannot match a following\n+     * offset, then {@link ZoneOffset#UTC} is selected.\n@@ -1172,3 +1171,3 @@\n-     *   \"UT+01:30\"                -- ZoneOffset.of(\"+01:30\")\n-     *   \"UTC+01:30\"               -- ZoneOffset.of(\"+01:30\")\n-     *   \"GMT+01:30\"               -- ZoneOffset.of(\"+01:30\")\n+     *   \"UT+01:30\"                -- ZoneId.of(\"UT+01:30\")\n+     *   \"UTC+01:30\"               -- ZoneId.of(\"UTC+01:30\")\n+     *   \"GMT+01:30\"               -- ZoneId.of(\"GMT+01:30\")\n@@ -1209,8 +1208,8 @@\n-     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n-     * expects an offset-based zone and will not match region-based zones.\n-     * The offset ID, such as '+02:30', may be at the start of the parse,\n-     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n-     * equivalent to using {@link #appendOffset(String, String)} using the\n-     * arguments 'HH:MM:ss' and the no offset string '0'.\n-     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n-     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.\n+     * If the parse starts with '+' or '-', then the parser expects an\n+     * offset-based zone and will not match region-based zones. The offset\n+     * ID parsing is equivalent to using {@link #appendOffset(String, String)}\n+     * using the arguments 'HH:MM:ss' and the no offset string '0'.\n+     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser can\n+     * match a following offset, then a region-based zone with the parsed\n+     * offset will be returned, or else if the parser cannot match a following\n+     * offset, then {@link ZoneOffset#UTC} is selected.\n@@ -1230,3 +1229,3 @@\n-     *   \"UT+01:30\"                -- ZoneOffset.of(\"UT+01:30\")\n-     *   \"UTC+01:30\"               -- ZoneOffset.of(\"UTC+01:30\")\n-     *   \"GMT+01:30\"               -- ZoneOffset.of(\"GMT+01:30\")\n+     *   \"UT+01:30\"                -- ZoneId.of(\"UT+01:30\")\n+     *   \"UTC+01:30\"               -- ZoneId.of(\"UTC+01:30\")\n+     *   \"GMT+01:30\"               -- ZoneId.of(\"GMT+01:30\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,3 +148,1 @@\n-        Runnable action = cleanup != null ?\n-                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address(), newSize)) :\n-                null;\n+        Runnable action = cleanupAction(address(), newSize, cleanup);\n@@ -154,0 +152,7 @@\n+    \/\/ Using a static helper method ensures there is no unintended lambda capturing of `this`\n+    private static Runnable cleanupAction(long address, long newSize, Consumer<MemorySegment> cleanup) {\n+        return cleanup != null ?\n+                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address, newSize)) :\n+                null;\n+    }\n+\n@@ -489,3 +494,12 @@\n-        return \"MemorySegment{ \" +\n-                heapBase().map(hb -> \"heapBase: \" + hb + \", \").orElse(\"\") +\n-                \"address: \" + Utils.toHexString(address()) +\n+        final String kind;\n+        if (this instanceof HeapMemorySegmentImpl) {\n+            kind = \"heap\";\n+        } else if (this instanceof MappedMemorySegmentImpl) {\n+            kind = \"mapped\";\n+        } else {\n+            kind = \"native\";\n+        }\n+        return \"MemorySegment{ kind: \" +\n+                kind +\n+                heapBase().map(hb -> \", heapBase: \" + hb).orElse(\"\") +\n+                \", address: \" + Utils.toHexString(address()) +\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,413 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# So much for footnotes about Saudi Arabia.\n-# Apparent noon times below are for Riyadh; your mileage will vary.\n-# Times were computed using formulas in the U.S. Naval Observatory's\n-# Almanac for Computers 1987; the formulas \"will give EqT to an accuracy of\n-# [plus or minus two] seconds during the current year.\"\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol87\t1987\tonly\t-\tJan\t1\t12:03:20s -0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t2\t12:03:50s -0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t3\t12:04:15s -0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t4\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t5\t12:05:10s -0:05:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t6\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t7\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t8\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t9\t12:06:55s -0:06:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t10\t12:07:20s -0:07:20 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t11\t12:07:45s -0:07:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t12\t12:08:10s -0:08:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t13\t12:08:30s -0:08:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t14\t12:08:55s -0:08:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t15\t12:09:15s -0:09:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t16\t12:09:35s -0:09:35 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t17\t12:09:55s -0:09:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t18\t12:10:15s -0:10:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t19\t12:10:35s -0:10:35 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t20\t12:10:55s -0:10:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t21\t12:11:10s -0:11:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t22\t12:11:30s -0:11:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t23\t12:11:45s -0:11:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t24\t12:12:00s -0:12:00 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t25\t12:12:15s -0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t26\t12:12:30s -0:12:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t27\t12:12:40s -0:12:40 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t28\t12:12:55s -0:12:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t29\t12:13:05s -0:13:05 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t30\t12:13:15s -0:13:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t31\t12:13:25s -0:13:25 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t1\t12:13:35s -0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t2\t12:13:40s -0:13:40 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t3\t12:13:50s -0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t4\t12:13:55s -0:13:55 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t5\t12:14:00s -0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t6\t12:14:05s -0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t8\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t10\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t11\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t12\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t21\t12:13:45s -0:13:45 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t22\t12:13:35s -0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t23\t12:13:30s -0:13:30 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t24\t12:13:20s -0:13:20 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t25\t12:13:10s -0:13:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t26\t12:13:00s -0:13:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t27\t12:12:50s -0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t28\t12:12:40s -0:12:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t1\t12:12:30s -0:12:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t2\t12:12:20s -0:12:20 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t3\t12:12:05s -0:12:05 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t4\t12:11:55s -0:11:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t5\t12:11:40s -0:11:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t6\t12:11:25s -0:11:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t7\t12:11:15s -0:11:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t8\t12:11:00s -0:11:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t9\t12:10:45s -0:10:45 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t10\t12:10:30s -0:10:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t11\t12:10:15s -0:10:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t12\t12:09:55s -0:09:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t13\t12:09:40s -0:09:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t14\t12:09:25s -0:09:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t15\t12:09:10s -0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t16\t12:08:50s -0:08:50 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t17\t12:08:35s -0:08:35 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t18\t12:08:15s -0:08:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t19\t12:08:00s -0:08:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t20\t12:07:40s -0:07:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t21\t12:07:25s -0:07:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t22\t12:07:05s -0:07:05 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t23\t12:06:50s -0:06:50 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t24\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t25\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t26\t12:05:55s -0:05:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t27\t12:05:35s -0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t28\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t29\t12:05:00s -0:05:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t30\t12:04:40s -0:04:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t31\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t1\t12:04:05s -0:04:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t2\t12:03:45s -0:03:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t3\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t4\t12:03:10s -0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t5\t12:02:55s -0:02:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t6\t12:02:35s -0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t7\t12:02:20s -0:02:20 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t8\t12:02:05s -0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t9\t12:01:45s -0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t10\t12:01:30s -0:01:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t11\t12:01:15s -0:01:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t12\t12:00:55s -0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t13\t12:00:40s -0:00:40 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t14\t12:00:25s -0:00:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t15\t12:00:10s -0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t16\t11:59:55s 0:00:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t17\t11:59:45s 0:00:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t18\t11:59:30s 0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t19\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t20\t11:59:05s 0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t21\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t22\t11:58:40s 0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t23\t11:58:25s 0:01:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t24\t11:58:15s 0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t25\t11:58:05s 0:01:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t26\t11:57:55s 0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t27\t11:57:45s 0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t28\t11:57:35s 0:02:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t29\t11:57:25s 0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t30\t11:57:15s 0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t1\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t2\t11:57:00s 0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t3\t11:56:55s 0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t4\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t5\t11:56:45s 0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t6\t11:56:40s 0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t7\t11:56:35s 0:03:25 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t8\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t10\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t18\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t20\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t21\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t22\t11:56:35s 0:03:25 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t23\t11:56:40s 0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t24\t11:56:45s 0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t25\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t26\t11:56:55s 0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t27\t11:57:00s 0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t28\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t29\t11:57:15s 0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t30\t11:57:25s 0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t31\t11:57:30s 0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t1\t11:57:40s 0:02:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t2\t11:57:50s 0:02:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t3\t11:58:00s 0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t4\t11:58:10s 0:01:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t5\t11:58:20s 0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t6\t11:58:30s 0:01:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t7\t11:58:40s 0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t8\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t9\t11:59:05s 0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t10\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t11\t11:59:30s 0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t12\t11:59:40s 0:00:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t13\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t14\t12:00:05s -0:00:05 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t15\t12:00:15s -0:00:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t16\t12:00:30s -0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t17\t12:00:45s -0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t18\t12:00:55s -0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t19\t12:01:10s -0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t20\t12:01:20s -0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t21\t12:01:35s -0:01:35 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t22\t12:01:50s -0:01:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t23\t12:02:00s -0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t24\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t25\t12:02:25s -0:02:25 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t26\t12:02:40s -0:02:40 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t27\t12:02:50s -0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t28\t12:03:05s -0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t29\t12:03:15s -0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t30\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t1\t12:03:40s -0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t2\t12:03:50s -0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t3\t12:04:05s -0:04:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t4\t12:04:15s -0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t5\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t6\t12:04:35s -0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t7\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t8\t12:04:55s -0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t9\t12:05:05s -0:05:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t10\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t11\t12:05:20s -0:05:20 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t12\t12:05:30s -0:05:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t13\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t14\t12:05:45s -0:05:45 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t15\t12:05:50s -0:05:50 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t20\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t21\t12:06:20s -0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t24\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t31\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t1\t12:06:20s -0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t5\t12:06:00s -0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t6\t12:05:55s -0:05:55 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t7\t12:05:50s -0:05:50 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t8\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t9\t12:05:35s -0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t10\t12:05:25s -0:05:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t11\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t12\t12:05:05s -0:05:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t13\t12:04:55s -0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t14\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t15\t12:04:35s -0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t16\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t17\t12:04:10s -0:04:10 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t18\t12:04:00s -0:04:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t19\t12:03:45s -0:03:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t20\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t21\t12:03:15s -0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t22\t12:03:00s -0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t23\t12:02:45s -0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t24\t12:02:30s -0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t25\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t26\t12:02:00s -0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t27\t12:01:40s -0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t28\t12:01:25s -0:01:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t29\t12:01:05s -0:01:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t30\t12:00:50s -0:00:50 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t31\t12:00:30s -0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t1\t12:00:10s -0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t2\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t3\t11:59:35s 0:00:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t4\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t5\t11:58:55s 0:01:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t6\t11:58:35s 0:01:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t7\t11:58:15s 0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t8\t11:57:55s 0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t9\t11:57:30s 0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t10\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t11\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t12\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t13\t11:56:10s 0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t14\t11:55:45s 0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t15\t11:55:25s 0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t16\t11:55:05s 0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t17\t11:54:45s 0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t18\t11:54:20s 0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t19\t11:54:00s 0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t20\t11:53:40s 0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t21\t11:53:15s 0:06:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t22\t11:52:55s 0:07:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t23\t11:52:35s 0:07:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t24\t11:52:15s 0:07:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t25\t11:51:55s 0:08:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t26\t11:51:35s 0:08:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t27\t11:51:10s 0:08:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t28\t11:50:50s 0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t29\t11:50:30s 0:09:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t30\t11:50:10s 0:09:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t1\t11:49:50s 0:10:10 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t2\t11:49:35s 0:10:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t3\t11:49:15s 0:10:45 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t4\t11:48:55s 0:11:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t5\t11:48:35s 0:11:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t6\t11:48:20s 0:11:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t7\t11:48:00s 0:12:00 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t8\t11:47:45s 0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t9\t11:47:25s 0:12:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t10\t11:47:10s 0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t11\t11:46:55s 0:13:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t12\t11:46:40s 0:13:20 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t13\t11:46:25s 0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t14\t11:46:10s 0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t15\t11:45:55s 0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t16\t11:45:45s 0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t17\t11:45:30s 0:14:30 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t18\t11:45:20s 0:14:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t19\t11:45:05s 0:14:55 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t20\t11:44:55s 0:15:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t21\t11:44:45s 0:15:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t22\t11:44:35s 0:15:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t23\t11:44:25s 0:15:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t24\t11:44:20s 0:15:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t25\t11:44:10s 0:15:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t26\t11:44:05s 0:15:55 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t27\t11:43:55s 0:16:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t28\t11:43:50s 0:16:10 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t29\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t30\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t31\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t1\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t3\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t5\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t6\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t7\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t10\t11:43:55s 0:16:05 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t11\t11:44:00s 0:16:00 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t12\t11:44:05s 0:15:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t13\t11:44:15s 0:15:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t14\t11:44:20s 0:15:40 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t15\t11:44:30s 0:15:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t16\t11:44:40s 0:15:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t17\t11:44:50s 0:15:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t18\t11:45:05s 0:14:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t19\t11:45:15s 0:14:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t20\t11:45:30s 0:14:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t21\t11:45:45s 0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t22\t11:46:00s 0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t23\t11:46:15s 0:13:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t24\t11:46:30s 0:13:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t25\t11:46:50s 0:13:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t26\t11:47:10s 0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t27\t11:47:25s 0:12:35 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t28\t11:47:45s 0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t29\t11:48:05s 0:11:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t30\t11:48:30s 0:11:30 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t1\t11:48:50s 0:11:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t2\t11:49:10s 0:10:50 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t3\t11:49:35s 0:10:25 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t4\t11:50:00s 0:10:00 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t5\t11:50:25s 0:09:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t6\t11:50:50s 0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t7\t11:51:15s 0:08:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t8\t11:51:40s 0:08:20 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t9\t11:52:05s 0:07:55 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t10\t11:52:30s 0:07:30 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t11\t11:53:00s 0:07:00 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t12\t11:53:25s 0:06:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t13\t11:53:55s 0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t14\t11:54:25s 0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t15\t11:54:50s 0:05:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t16\t11:55:20s 0:04:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t17\t11:55:50s 0:04:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t18\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t19\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t20\t11:57:20s 0:02:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t21\t11:57:50s 0:02:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t22\t11:58:20s 0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t23\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t24\t11:59:20s 0:00:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t25\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t26\t12:00:20s -0:00:20 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t27\t12:00:45s -0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t28\t12:01:15s -0:01:15 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t29\t12:01:45s -0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t30\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t31\t12:02:45s -0:02:45 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1987, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh87\t3:07:04\t-\t\tzzz\t1987\n-\t\t\t3:07:04\tsol87\t\tzzz\t1988\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh87\tMideast\/Riyadh87\n","filename":"src\/java.base\/share\/data\/tzdata\/solar87","additions":0,"deletions":413,"binary":false,"changes":413,"status":"deleted"},{"patch":"@@ -1,413 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# Apparent noon times below are for Riyadh; they're a bit off for other places.\n-# Times were computed using formulas in the U.S. Naval Observatory's\n-# Almanac for Computers 1988; the formulas \"will give EqT to an accuracy of\n-# [plus or minus two] seconds during the current year.\"\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol88\t1988\tonly\t-\tJan\t1\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t2\t12:03:40s -0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t3\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t4\t12:04:40s -0:04:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t5\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t6\t12:05:30s -0:05:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t7\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t8\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t9\t12:06:50s -0:06:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t10\t12:07:15s -0:07:15 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t11\t12:07:40s -0:07:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t12\t12:08:05s -0:08:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t13\t12:08:25s -0:08:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t14\t12:08:50s -0:08:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t15\t12:09:10s -0:09:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t16\t12:09:30s -0:09:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t17\t12:09:50s -0:09:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t18\t12:10:10s -0:10:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t19\t12:10:30s -0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t20\t12:10:50s -0:10:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t21\t12:11:05s -0:11:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t22\t12:11:25s -0:11:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t23\t12:11:40s -0:11:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t24\t12:11:55s -0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t25\t12:12:10s -0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t26\t12:12:25s -0:12:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t27\t12:12:40s -0:12:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t28\t12:12:50s -0:12:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t29\t12:13:00s -0:13:00 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t30\t12:13:10s -0:13:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t31\t12:13:20s -0:13:20 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t1\t12:13:30s -0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t2\t12:13:40s -0:13:40 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t3\t12:13:45s -0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t4\t12:13:55s -0:13:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t5\t12:14:00s -0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t6\t12:14:05s -0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t8\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t10\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t11\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t12\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t21\t12:13:45s -0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t22\t12:13:40s -0:13:40 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t23\t12:13:30s -0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t24\t12:13:20s -0:13:20 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t25\t12:13:15s -0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t26\t12:13:05s -0:13:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t27\t12:12:55s -0:12:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t28\t12:12:45s -0:12:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t29\t12:12:30s -0:12:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t1\t12:12:20s -0:12:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t2\t12:12:10s -0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t3\t12:11:55s -0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t4\t12:11:45s -0:11:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t5\t12:11:30s -0:11:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t6\t12:11:15s -0:11:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t7\t12:11:00s -0:11:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t8\t12:10:45s -0:10:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t9\t12:10:30s -0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t10\t12:10:15s -0:10:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t11\t12:10:00s -0:10:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t12\t12:09:45s -0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t13\t12:09:30s -0:09:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t14\t12:09:10s -0:09:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t15\t12:08:55s -0:08:55 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t16\t12:08:40s -0:08:40 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t17\t12:08:20s -0:08:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t18\t12:08:05s -0:08:05 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t19\t12:07:45s -0:07:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t20\t12:07:30s -0:07:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t21\t12:07:10s -0:07:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t22\t12:06:50s -0:06:50 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t23\t12:06:35s -0:06:35 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t24\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t25\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t26\t12:05:40s -0:05:40 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t27\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t28\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t29\t12:04:45s -0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t30\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t31\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t1\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t2\t12:03:35s -0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t3\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t4\t12:03:00s -0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t5\t12:02:40s -0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t6\t12:02:25s -0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t7\t12:02:05s -0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t8\t12:01:50s -0:01:50 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t9\t12:01:35s -0:01:35 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t10\t12:01:15s -0:01:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t11\t12:01:00s -0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t12\t12:00:45s -0:00:45 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t13\t12:00:30s -0:00:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t14\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t15\t12:00:00s 0:00:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t16\t11:59:45s 0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t17\t11:59:30s 0:00:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t18\t11:59:20s 0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t19\t11:59:05s 0:00:55 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t20\t11:58:55s 0:01:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t21\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t22\t11:58:30s 0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t23\t11:58:15s 0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t24\t11:58:05s 0:01:55 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t25\t11:57:55s 0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t26\t11:57:45s 0:02:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t27\t11:57:35s 0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t28\t11:57:30s 0:02:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t29\t11:57:20s 0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t30\t11:57:10s 0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t1\t11:57:05s 0:02:55 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t2\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t3\t11:56:50s 0:03:10 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t4\t11:56:45s 0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t5\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t6\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t7\t11:56:30s 0:03:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t8\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t10\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t18\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t20\t11:56:30s 0:03:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t21\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t22\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t23\t11:56:45s 0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t24\t11:56:50s 0:03:10 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t25\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t26\t11:57:00s 0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t27\t11:57:05s 0:02:55 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t28\t11:57:15s 0:02:45 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t29\t11:57:20s 0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t30\t11:57:30s 0:02:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t31\t11:57:40s 0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t1\t11:57:50s 0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t2\t11:57:55s 0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t3\t11:58:05s 0:01:55 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t4\t11:58:15s 0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t5\t11:58:30s 0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t6\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t7\t11:58:50s 0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t8\t11:59:00s 0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t9\t11:59:15s 0:00:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t10\t11:59:25s 0:00:35 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t11\t11:59:35s 0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t12\t11:59:50s 0:00:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t13\t12:00:00s 0:00:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t14\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t15\t12:00:25s -0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t16\t12:00:40s -0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t17\t12:00:55s -0:00:55 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t18\t12:01:05s -0:01:05 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t19\t12:01:20s -0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t20\t12:01:30s -0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t21\t12:01:45s -0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t22\t12:02:00s -0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t23\t12:02:10s -0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t24\t12:02:25s -0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t25\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t26\t12:02:50s -0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t27\t12:03:00s -0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t28\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t29\t12:03:25s -0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t30\t12:03:40s -0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t1\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t2\t12:04:00s -0:04:00 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t3\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t4\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t5\t12:04:35s -0:04:35 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t6\t12:04:45s -0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t7\t12:04:55s -0:04:55 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t8\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t9\t12:05:10s -0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t10\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t11\t12:05:30s -0:05:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t12\t12:05:35s -0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t13\t12:05:45s -0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t14\t12:05:50s -0:05:50 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t15\t12:05:55s -0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t20\t12:06:20s -0:06:20 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t21\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t24\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t31\t12:06:20s -0:06:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t1\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t5\t12:05:55s -0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t6\t12:05:50s -0:05:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t7\t12:05:45s -0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t8\t12:05:35s -0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t9\t12:05:25s -0:05:25 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t10\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t11\t12:05:10s -0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t12\t12:05:00s -0:05:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t13\t12:04:50s -0:04:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t14\t12:04:35s -0:04:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t15\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t16\t12:04:15s -0:04:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t17\t12:04:00s -0:04:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t18\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t19\t12:03:35s -0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t20\t12:03:20s -0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t21\t12:03:05s -0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t22\t12:02:50s -0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t23\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t24\t12:02:20s -0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t25\t12:02:00s -0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t26\t12:01:45s -0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t27\t12:01:30s -0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t28\t12:01:10s -0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t29\t12:00:50s -0:00:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t30\t12:00:35s -0:00:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t31\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t1\t11:59:55s 0:00:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t2\t11:59:35s 0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t3\t11:59:20s 0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t4\t11:59:00s 0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t5\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t6\t11:58:20s 0:01:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t7\t11:58:00s 0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t8\t11:57:35s 0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t9\t11:57:15s 0:02:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t10\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t11\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t12\t11:56:15s 0:03:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t13\t11:55:50s 0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t14\t11:55:30s 0:04:30 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t15\t11:55:10s 0:04:50 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t16\t11:54:50s 0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t17\t11:54:25s 0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t18\t11:54:05s 0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t19\t11:53:45s 0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t20\t11:53:25s 0:06:35 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t21\t11:53:00s 0:07:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t22\t11:52:40s 0:07:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t23\t11:52:20s 0:07:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t24\t11:52:00s 0:08:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t25\t11:51:40s 0:08:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t26\t11:51:15s 0:08:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t27\t11:50:55s 0:09:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t28\t11:50:35s 0:09:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t29\t11:50:15s 0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t30\t11:49:55s 0:10:05 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t1\t11:49:35s 0:10:25 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t2\t11:49:20s 0:10:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t3\t11:49:00s 0:11:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t4\t11:48:40s 0:11:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t5\t11:48:25s 0:11:35 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t6\t11:48:05s 0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t7\t11:47:50s 0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t8\t11:47:30s 0:12:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t9\t11:47:15s 0:12:45 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t10\t11:47:00s 0:13:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t11\t11:46:45s 0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t12\t11:46:30s 0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t13\t11:46:15s 0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t14\t11:46:00s 0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t15\t11:45:45s 0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t16\t11:45:35s 0:14:25 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t17\t11:45:20s 0:14:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t18\t11:45:10s 0:14:50 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t19\t11:45:00s 0:15:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t20\t11:44:45s 0:15:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t21\t11:44:40s 0:15:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t22\t11:44:30s 0:15:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t23\t11:44:20s 0:15:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t24\t11:44:10s 0:15:50 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t25\t11:44:05s 0:15:55 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t26\t11:44:00s 0:16:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t27\t11:43:55s 0:16:05 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t28\t11:43:50s 0:16:10 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t29\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t30\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t31\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t1\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t3\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t5\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t6\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t7\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t10\t11:44:00s 0:16:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t11\t11:44:05s 0:15:55 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t12\t11:44:10s 0:15:50 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t13\t11:44:20s 0:15:40 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t14\t11:44:30s 0:15:30 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t15\t11:44:40s 0:15:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t16\t11:44:50s 0:15:10 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t17\t11:45:00s 0:15:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t18\t11:45:15s 0:14:45 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t19\t11:45:25s 0:14:35 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t20\t11:45:40s 0:14:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t21\t11:45:55s 0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t22\t11:46:10s 0:13:50 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t23\t11:46:30s 0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t24\t11:46:45s 0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t25\t11:47:05s 0:12:55 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t26\t11:47:20s 0:12:40 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t27\t11:47:40s 0:12:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t28\t11:48:00s 0:12:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t29\t11:48:25s 0:11:35 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t30\t11:48:45s 0:11:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t1\t11:49:05s 0:10:55 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t2\t11:49:30s 0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t3\t11:49:55s 0:10:05 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t4\t11:50:15s 0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t5\t11:50:40s 0:09:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t6\t11:51:05s 0:08:55 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t7\t11:51:35s 0:08:25 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t8\t11:52:00s 0:08:00 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t9\t11:52:25s 0:07:35 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t10\t11:52:55s 0:07:05 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t11\t11:53:20s 0:06:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t12\t11:53:50s 0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t13\t11:54:15s 0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t14\t11:54:45s 0:05:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t15\t11:55:15s 0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t16\t11:55:45s 0:04:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t17\t11:56:15s 0:03:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t18\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t19\t11:57:10s 0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t20\t11:57:40s 0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t21\t11:58:10s 0:01:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t22\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t23\t11:59:10s 0:00:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t24\t11:59:40s 0:00:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t25\t12:00:10s -0:00:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t26\t12:00:40s -0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t27\t12:01:10s -0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t28\t12:01:40s -0:01:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t29\t12:02:10s -0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t30\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t31\t12:03:05s -0:03:05 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1988, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh88\t3:07:04\t-\t\tzzz\t1988\n-\t\t\t3:07:04\tsol88\t\tzzz\t1989\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh88\tMideast\/Riyadh88\n","filename":"src\/java.base\/share\/data\/tzdata\/solar88","additions":0,"deletions":413,"binary":false,"changes":413,"status":"deleted"},{"patch":"@@ -1,418 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# Apparent noon times below are for Riyadh; they're a bit off for other places.\n-# Times were computed using a formula provided by the U. S. Naval Observatory:\n-#\teqt = -105.8 * sin(l) + 596.2 * sin(2 * l) + 4.4 * sin(3 * l)\n-#\t\t-12.7 * sin(4 * l) - 429.0 * cos(l) - 2.1 * cos (2 * l)\n-#\t\t+ 19.3 * cos(3 * l);\n-# where l is the \"mean longitude of the Sun\" given by\n-#\tl = 279.642 degrees + 0.985647 * d\n-# and d is the interval in days from January 0, 0 hours Universal Time\n-# (equaling the day of the year plus the fraction of a day from zero hours).\n-# The accuracy of the formula is plus or minus three seconds.\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol89\t1989\tonly\t-\tJan\t1\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t2\t12:04:05s -0:04:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t3\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t4\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t5\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t6\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t7\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t8\t12:06:45s -0:06:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t9\t12:07:10s -0:07:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t10\t12:07:35s -0:07:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t11\t12:07:55s -0:07:55 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t12\t12:08:20s -0:08:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t13\t12:08:45s -0:08:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t14\t12:09:05s -0:09:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t15\t12:09:25s -0:09:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t16\t12:09:45s -0:09:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t17\t12:10:05s -0:10:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t18\t12:10:25s -0:10:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t19\t12:10:45s -0:10:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t20\t12:11:05s -0:11:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t21\t12:11:20s -0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t22\t12:11:35s -0:11:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t23\t12:11:55s -0:11:55 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t24\t12:12:10s -0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t25\t12:12:20s -0:12:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t26\t12:12:35s -0:12:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t27\t12:12:50s -0:12:50 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t28\t12:13:00s -0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t29\t12:13:10s -0:13:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t30\t12:13:20s -0:13:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t31\t12:13:30s -0:13:30 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t1\t12:13:40s -0:13:40 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t2\t12:13:45s -0:13:45 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t3\t12:13:55s -0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t4\t12:14:00s -0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t5\t12:14:05s -0:14:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t6\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t8\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t10\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t11\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t12\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t21\t12:13:40s -0:13:40 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t22\t12:13:35s -0:13:35 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t23\t12:13:25s -0:13:25 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t24\t12:13:15s -0:13:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t25\t12:13:05s -0:13:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t26\t12:12:55s -0:12:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t27\t12:12:45s -0:12:45 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t28\t12:12:35s -0:12:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t1\t12:12:25s -0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t2\t12:12:10s -0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t3\t12:12:00s -0:12:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t4\t12:11:45s -0:11:45 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t5\t12:11:35s -0:11:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t6\t12:11:20s -0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t7\t12:11:05s -0:11:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t8\t12:10:50s -0:10:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t9\t12:10:35s -0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t10\t12:10:20s -0:10:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t11\t12:10:05s -0:10:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t12\t12:09:50s -0:09:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t13\t12:09:30s -0:09:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t14\t12:09:15s -0:09:15 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t15\t12:09:00s -0:09:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t16\t12:08:40s -0:08:40 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t17\t12:08:25s -0:08:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t18\t12:08:05s -0:08:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t19\t12:07:50s -0:07:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t20\t12:07:30s -0:07:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t21\t12:07:15s -0:07:15 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t22\t12:06:55s -0:06:55 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t23\t12:06:35s -0:06:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t24\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t25\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t26\t12:05:40s -0:05:40 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t27\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t28\t12:05:05s -0:05:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t29\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t30\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t31\t12:04:10s -0:04:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t1\t12:03:55s -0:03:55 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t2\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t3\t12:03:20s -0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t4\t12:03:00s -0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t5\t12:02:45s -0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t6\t12:02:25s -0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t7\t12:02:10s -0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t8\t12:01:50s -0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t9\t12:01:35s -0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t10\t12:01:20s -0:01:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t11\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t12\t12:00:50s -0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t13\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t14\t12:00:20s -0:00:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t15\t12:00:05s -0:00:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t16\t11:59:50s 0:00:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t17\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t18\t11:59:20s 0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t19\t11:59:10s 0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t20\t11:58:55s 0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t21\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t22\t11:58:30s 0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t23\t11:58:20s 0:01:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t24\t11:58:10s 0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t25\t11:58:00s 0:02:00 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t26\t11:57:50s 0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t27\t11:57:40s 0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t28\t11:57:30s 0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t29\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t30\t11:57:15s 0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t1\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t2\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t3\t11:56:50s 0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t4\t11:56:45s 0:03:15 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t5\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t6\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t7\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t8\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t10\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t18\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t20\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t21\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t22\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t23\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t24\t11:56:45s 0:03:15 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t25\t11:56:55s 0:03:05 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t26\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t27\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t28\t11:57:15s 0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t29\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t30\t11:57:30s 0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t31\t11:57:35s 0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t1\t11:57:45s 0:02:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t2\t11:57:55s 0:02:05 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t3\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t4\t11:58:15s 0:01:45 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t5\t11:58:25s 0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t6\t11:58:35s 0:01:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t7\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t8\t11:59:00s 0:01:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t9\t11:59:10s 0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t10\t11:59:20s 0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t11\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t12\t11:59:45s 0:00:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t13\t12:00:00s 0:00:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t14\t12:00:10s -0:00:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t15\t12:00:25s -0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t16\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t17\t12:00:50s -0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t18\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t19\t12:01:15s -0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t20\t12:01:30s -0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t21\t12:01:40s -0:01:40 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t22\t12:01:55s -0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t23\t12:02:10s -0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t24\t12:02:20s -0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t25\t12:02:35s -0:02:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t26\t12:02:45s -0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t27\t12:03:00s -0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t28\t12:03:10s -0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t29\t12:03:25s -0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t30\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t1\t12:03:45s -0:03:45 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t2\t12:04:00s -0:04:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t3\t12:04:10s -0:04:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t4\t12:04:20s -0:04:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t5\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t6\t12:04:40s -0:04:40 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t7\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t8\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t9\t12:05:10s -0:05:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t10\t12:05:20s -0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t11\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t12\t12:05:35s -0:05:35 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t13\t12:05:40s -0:05:40 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t14\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t15\t12:05:55s -0:05:55 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t20\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t21\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t24\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t31\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t1\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t5\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t6\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t7\t12:05:45s -0:05:45 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t8\t12:05:35s -0:05:35 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t9\t12:05:30s -0:05:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t10\t12:05:20s -0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t11\t12:05:10s -0:05:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t12\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t13\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t14\t12:04:40s -0:04:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t15\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t16\t12:04:15s -0:04:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t17\t12:04:05s -0:04:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t18\t12:03:50s -0:03:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t19\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t20\t12:03:25s -0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t21\t12:03:10s -0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t22\t12:02:55s -0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t23\t12:02:40s -0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t24\t12:02:20s -0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t25\t12:02:05s -0:02:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t26\t12:01:50s -0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t27\t12:01:30s -0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t28\t12:01:15s -0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t29\t12:00:55s -0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t30\t12:00:40s -0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t31\t12:00:20s -0:00:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t1\t12:00:00s 0:00:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t2\t11:59:45s 0:00:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t3\t11:59:25s 0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t4\t11:59:05s 0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t5\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t6\t11:58:25s 0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t7\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t8\t11:57:45s 0:02:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t9\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t10\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t11\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t12\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t13\t11:56:00s 0:04:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t14\t11:55:35s 0:04:25 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t15\t11:55:15s 0:04:45 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t16\t11:54:55s 0:05:05 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t17\t11:54:35s 0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t18\t11:54:10s 0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t19\t11:53:50s 0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t20\t11:53:30s 0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t21\t11:53:10s 0:06:50 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t22\t11:52:45s 0:07:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t23\t11:52:25s 0:07:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t24\t11:52:05s 0:07:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t25\t11:51:45s 0:08:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t26\t11:51:25s 0:08:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t27\t11:51:05s 0:08:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t28\t11:50:40s 0:09:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t29\t11:50:20s 0:09:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t30\t11:50:00s 0:10:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t1\t11:49:45s 0:10:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t2\t11:49:25s 0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t3\t11:49:05s 0:10:55 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t4\t11:48:45s 0:11:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t5\t11:48:30s 0:11:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t6\t11:48:10s 0:11:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t7\t11:47:50s 0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t8\t11:47:35s 0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t9\t11:47:20s 0:12:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t10\t11:47:00s 0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t11\t11:46:45s 0:13:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t12\t11:46:30s 0:13:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t13\t11:46:15s 0:13:45 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t14\t11:46:00s 0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t15\t11:45:50s 0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t16\t11:45:35s 0:14:25 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t17\t11:45:20s 0:14:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t18\t11:45:10s 0:14:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t19\t11:45:00s 0:15:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t20\t11:44:50s 0:15:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t21\t11:44:40s 0:15:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t22\t11:44:30s 0:15:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t23\t11:44:20s 0:15:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t24\t11:44:10s 0:15:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t25\t11:44:05s 0:15:55 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t26\t11:44:00s 0:16:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t27\t11:43:50s 0:16:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t28\t11:43:45s 0:16:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t29\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t30\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t31\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t1\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t3\t11:43:30s 0:16:30 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t5\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t6\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t7\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t10\t11:43:55s 0:16:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t11\t11:44:00s 0:16:00 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t12\t11:44:05s 0:15:55 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t13\t11:44:15s 0:15:45 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t14\t11:44:25s 0:15:35 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t15\t11:44:35s 0:15:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t16\t11:44:45s 0:15:15 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t17\t11:44:55s 0:15:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t18\t11:45:10s 0:14:50 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t19\t11:45:20s 0:14:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t20\t11:45:35s 0:14:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t21\t11:45:50s 0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t22\t11:46:05s 0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t23\t11:46:25s 0:13:35 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t24\t11:46:40s 0:13:20 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t25\t11:47:00s 0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t26\t11:47:20s 0:12:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t27\t11:47:35s 0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t28\t11:47:55s 0:12:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t29\t11:48:20s 0:11:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t30\t11:48:40s 0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t1\t11:49:00s 0:11:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t2\t11:49:25s 0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t3\t11:49:50s 0:10:10 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t4\t11:50:15s 0:09:45 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t5\t11:50:35s 0:09:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t6\t11:51:00s 0:09:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t7\t11:51:30s 0:08:30 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t8\t11:51:55s 0:08:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t9\t11:52:20s 0:07:40 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t10\t11:52:50s 0:07:10 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t11\t11:53:15s 0:06:45 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t12\t11:53:45s 0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t13\t11:54:10s 0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t14\t11:54:40s 0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t15\t11:55:10s 0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t16\t11:55:40s 0:04:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t17\t11:56:05s 0:03:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t18\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t19\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t20\t11:57:35s 0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t21\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t22\t11:58:35s 0:01:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t23\t11:59:05s 0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t24\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t25\t12:00:05s -0:00:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t26\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t27\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t28\t12:01:35s -0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t29\t12:02:00s -0:02:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t30\t12:02:30s -0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t31\t12:03:00s -0:03:00 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1989, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh89\t3:07:04\t-\t\tzzz\t1989\n-\t\t\t3:07:04\tsol89\t\tzzz\t1990\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh89\tMideast\/Riyadh89\n","filename":"src\/java.base\/share\/data\/tzdata\/solar89","additions":0,"deletions":418,"binary":false,"changes":418,"status":"deleted"},{"patch":"@@ -1,470 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# tzdb timezone descriptions (deprecated version)\n-#\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-#\n-# From Paul Eggert (2021-09-20):\n-# This file is intended as a backward-compatibility aid for older programs.\n-# New programs should use zone1970.tab.  This file is like zone1970.tab (see\n-# zone1970.tab's comments), but with the following additional restrictions:\n-#\n-# 1.  This file contains only ASCII characters.\n-# 2.  The first data column contains exactly one country code.\n-#\n-# Because of (2), each row stands for an area that is the intersection\n-# of a region identified by a country code and of a timezone where civil\n-# clocks have agreed since 1970; this is a narrower definition than\n-# that of zone1970.tab.\n-#\n-# Unlike zone1970.tab, a row's third column can be a Link from\n-# 'backward' instead of a Zone.\n-#\n-# This table is intended as an aid for users, to help them select timezones\n-# appropriate for their practical needs.  It is not intended to take or\n-# endorse any position on legal or territorial claims.\n-#\n-#country-\n-#code\tcoordinates\tTZ\t\t\tcomments\n-AD\t+4230+00131\tEurope\/Andorra\n-AE\t+2518+05518\tAsia\/Dubai\n-AF\t+3431+06912\tAsia\/Kabul\n-AG\t+1703-06148\tAmerica\/Antigua\n-AI\t+1812-06304\tAmerica\/Anguilla\n-AL\t+4120+01950\tEurope\/Tirane\n-AM\t+4011+04430\tAsia\/Yerevan\n-AO\t-0848+01314\tAfrica\/Luanda\n-AQ\t-7750+16636\tAntarctica\/McMurdo\tNew Zealand time - McMurdo, South Pole\n-AQ\t-6617+11031\tAntarctica\/Casey\tCasey\n-AQ\t-6835+07758\tAntarctica\/Davis\tDavis\n-AQ\t-6640+14001\tAntarctica\/DumontDUrville\tDumont-d'Urville\n-AQ\t-6736+06253\tAntarctica\/Mawson\tMawson\n-AQ\t-6448-06406\tAntarctica\/Palmer\tPalmer\n-AQ\t-6734-06808\tAntarctica\/Rothera\tRothera\n-AQ\t-690022+0393524\tAntarctica\/Syowa\tSyowa\n-AQ\t-720041+0023206\tAntarctica\/Troll\tTroll\n-AQ\t-7824+10654\tAntarctica\/Vostok\tVostok\n-AR\t-3436-05827\tAmerica\/Argentina\/Buenos_Aires\tBuenos Aires (BA, CF)\n-AR\t-3124-06411\tAmerica\/Argentina\/Cordoba\tArgentina (most areas: CB, CC, CN, ER, FM, MN, SE, SF)\n-AR\t-2447-06525\tAmerica\/Argentina\/Salta\tSalta (SA, LP, NQ, RN)\n-AR\t-2411-06518\tAmerica\/Argentina\/Jujuy\tJujuy (JY)\n-AR\t-2649-06513\tAmerica\/Argentina\/Tucuman\tTucuman (TM)\n-AR\t-2828-06547\tAmerica\/Argentina\/Catamarca\tCatamarca (CT), Chubut (CH)\n-AR\t-2926-06651\tAmerica\/Argentina\/La_Rioja\tLa Rioja (LR)\n-AR\t-3132-06831\tAmerica\/Argentina\/San_Juan\tSan Juan (SJ)\n-AR\t-3253-06849\tAmerica\/Argentina\/Mendoza\tMendoza (MZ)\n-AR\t-3319-06621\tAmerica\/Argentina\/San_Luis\tSan Luis (SL)\n-AR\t-5138-06913\tAmerica\/Argentina\/Rio_Gallegos\tSanta Cruz (SC)\n-AR\t-5448-06818\tAmerica\/Argentina\/Ushuaia\tTierra del Fuego (TF)\n-AS\t-1416-17042\tPacific\/Pago_Pago\n-AT\t+4813+01620\tEurope\/Vienna\n-AU\t-3133+15905\tAustralia\/Lord_Howe\tLord Howe Island\n-AU\t-5430+15857\tAntarctica\/Macquarie\tMacquarie Island\n-AU\t-4253+14719\tAustralia\/Hobart\tTasmania\n-AU\t-3749+14458\tAustralia\/Melbourne\tVictoria\n-AU\t-3352+15113\tAustralia\/Sydney\tNew South Wales (most areas)\n-AU\t-3157+14127\tAustralia\/Broken_Hill\tNew South Wales (Yancowinna)\n-AU\t-2728+15302\tAustralia\/Brisbane\tQueensland (most areas)\n-AU\t-2016+14900\tAustralia\/Lindeman\tQueensland (Whitsunday Islands)\n-AU\t-3455+13835\tAustralia\/Adelaide\tSouth Australia\n-AU\t-1228+13050\tAustralia\/Darwin\tNorthern Territory\n-AU\t-3157+11551\tAustralia\/Perth\tWestern Australia (most areas)\n-AU\t-3143+12852\tAustralia\/Eucla\tWestern Australia (Eucla)\n-AW\t+1230-06958\tAmerica\/Aruba\n-AX\t+6006+01957\tEurope\/Mariehamn\n-AZ\t+4023+04951\tAsia\/Baku\n-BA\t+4352+01825\tEurope\/Sarajevo\n-BB\t+1306-05937\tAmerica\/Barbados\n-BD\t+2343+09025\tAsia\/Dhaka\n-BE\t+5050+00420\tEurope\/Brussels\n-BF\t+1222-00131\tAfrica\/Ouagadougou\n-BG\t+4241+02319\tEurope\/Sofia\n-BH\t+2623+05035\tAsia\/Bahrain\n-BI\t-0323+02922\tAfrica\/Bujumbura\n-BJ\t+0629+00237\tAfrica\/Porto-Novo\n-BL\t+1753-06251\tAmerica\/St_Barthelemy\n-BM\t+3217-06446\tAtlantic\/Bermuda\n-BN\t+0456+11455\tAsia\/Brunei\n-BO\t-1630-06809\tAmerica\/La_Paz\n-BQ\t+120903-0681636\tAmerica\/Kralendijk\n-BR\t-0351-03225\tAmerica\/Noronha\tAtlantic islands\n-BR\t-0127-04829\tAmerica\/Belem\tPara (east), Amapa\n-BR\t-0343-03830\tAmerica\/Fortaleza\tBrazil (northeast: MA, PI, CE, RN, PB)\n-BR\t-0803-03454\tAmerica\/Recife\tPernambuco\n-BR\t-0712-04812\tAmerica\/Araguaina\tTocantins\n-BR\t-0940-03543\tAmerica\/Maceio\tAlagoas, Sergipe\n-BR\t-1259-03831\tAmerica\/Bahia\tBahia\n-BR\t-2332-04637\tAmerica\/Sao_Paulo\tBrazil (southeast: GO, DF, MG, ES, RJ, SP, PR, SC, RS)\n-BR\t-2027-05437\tAmerica\/Campo_Grande\tMato Grosso do Sul\n-BR\t-1535-05605\tAmerica\/Cuiaba\tMato Grosso\n-BR\t-0226-05452\tAmerica\/Santarem\tPara (west)\n-BR\t-0846-06354\tAmerica\/Porto_Velho\tRondonia\n-BR\t+0249-06040\tAmerica\/Boa_Vista\tRoraima\n-BR\t-0308-06001\tAmerica\/Manaus\tAmazonas (east)\n-BR\t-0640-06952\tAmerica\/Eirunepe\tAmazonas (west)\n-BR\t-0958-06748\tAmerica\/Rio_Branco\tAcre\n-BS\t+2505-07721\tAmerica\/Nassau\n-BT\t+2728+08939\tAsia\/Thimphu\n-BW\t-2439+02555\tAfrica\/Gaborone\n-BY\t+5354+02734\tEurope\/Minsk\n-BZ\t+1730-08812\tAmerica\/Belize\n-CA\t+4734-05243\tAmerica\/St_Johns\tNewfoundland, Labrador (SE)\n-CA\t+4439-06336\tAmerica\/Halifax\tAtlantic - NS (most areas), PE\n-CA\t+4612-05957\tAmerica\/Glace_Bay\tAtlantic - NS (Cape Breton)\n-CA\t+4606-06447\tAmerica\/Moncton\tAtlantic - New Brunswick\n-CA\t+5320-06025\tAmerica\/Goose_Bay\tAtlantic - Labrador (most areas)\n-CA\t+5125-05707\tAmerica\/Blanc-Sablon\tAST - QC (Lower North Shore)\n-CA\t+4339-07923\tAmerica\/Toronto\tEastern - ON & QC (most areas)\n-CA\t+6344-06828\tAmerica\/Iqaluit\tEastern - NU (most areas)\n-CA\t+484531-0913718\tAmerica\/Atikokan\tEST - ON (Atikokan), NU (Coral H)\n-CA\t+4953-09709\tAmerica\/Winnipeg\tCentral - ON (west), Manitoba\n-CA\t+744144-0944945\tAmerica\/Resolute\tCentral - NU (Resolute)\n-CA\t+624900-0920459\tAmerica\/Rankin_Inlet\tCentral - NU (central)\n-CA\t+5024-10439\tAmerica\/Regina\tCST - SK (most areas)\n-CA\t+5017-10750\tAmerica\/Swift_Current\tCST - SK (midwest)\n-CA\t+5333-11328\tAmerica\/Edmonton\tMountain - AB, BC(E), NT(E), SK(W)\n-CA\t+690650-1050310\tAmerica\/Cambridge_Bay\tMountain - NU (west)\n-CA\t+682059-1334300\tAmerica\/Inuvik\tMountain - NT (west)\n-CA\t+4906-11631\tAmerica\/Creston\tMST - BC (Creston)\n-CA\t+5546-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n-CA\t+5848-12242\tAmerica\/Fort_Nelson\tMST - BC (Ft Nelson)\n-CA\t+6043-13503\tAmerica\/Whitehorse\tMST - Yukon (east)\n-CA\t+6404-13925\tAmerica\/Dawson\tMST - Yukon (west)\n-CA\t+4916-12307\tAmerica\/Vancouver\tPacific - BC (most areas)\n-CC\t-1210+09655\tIndian\/Cocos\n-CD\t-0418+01518\tAfrica\/Kinshasa\tDem. Rep. of Congo (west)\n-CD\t-1140+02728\tAfrica\/Lubumbashi\tDem. Rep. of Congo (east)\n-CF\t+0422+01835\tAfrica\/Bangui\n-CG\t-0416+01517\tAfrica\/Brazzaville\n-CH\t+4723+00832\tEurope\/Zurich\n-CI\t+0519-00402\tAfrica\/Abidjan\n-CK\t-2114-15946\tPacific\/Rarotonga\n-CL\t-3327-07040\tAmerica\/Santiago\tmost of Chile\n-CL\t-5309-07055\tAmerica\/Punta_Arenas\tRegion of Magallanes\n-CL\t-2709-10926\tPacific\/Easter\tEaster Island\n-CM\t+0403+00942\tAfrica\/Douala\n-CN\t+3114+12128\tAsia\/Shanghai\tBeijing Time\n-CN\t+4348+08735\tAsia\/Urumqi\tXinjiang Time\n-CO\t+0436-07405\tAmerica\/Bogota\n-CR\t+0956-08405\tAmerica\/Costa_Rica\n-CU\t+2308-08222\tAmerica\/Havana\n-CV\t+1455-02331\tAtlantic\/Cape_Verde\n-CW\t+1211-06900\tAmerica\/Curacao\n-CX\t-1025+10543\tIndian\/Christmas\n-CY\t+3510+03322\tAsia\/Nicosia\tmost of Cyprus\n-CY\t+3507+03357\tAsia\/Famagusta\tNorthern Cyprus\n-CZ\t+5005+01426\tEurope\/Prague\n-DE\t+5230+01322\tEurope\/Berlin\tmost of Germany\n-DE\t+4742+00841\tEurope\/Busingen\tBusingen\n-DJ\t+1136+04309\tAfrica\/Djibouti\n-DK\t+5540+01235\tEurope\/Copenhagen\n-DM\t+1518-06124\tAmerica\/Dominica\n-DO\t+1828-06954\tAmerica\/Santo_Domingo\n-DZ\t+3647+00303\tAfrica\/Algiers\n-EC\t-0210-07950\tAmerica\/Guayaquil\tEcuador (mainland)\n-EC\t-0054-08936\tPacific\/Galapagos\tGalapagos Islands\n-EE\t+5925+02445\tEurope\/Tallinn\n-EG\t+3003+03115\tAfrica\/Cairo\n-EH\t+2709-01312\tAfrica\/El_Aaiun\n-ER\t+1520+03853\tAfrica\/Asmara\n-ES\t+4024-00341\tEurope\/Madrid\tSpain (mainland)\n-ES\t+3553-00519\tAfrica\/Ceuta\tCeuta, Melilla\n-ES\t+2806-01524\tAtlantic\/Canary\tCanary Islands\n-ET\t+0902+03842\tAfrica\/Addis_Ababa\n-FI\t+6010+02458\tEurope\/Helsinki\n-FJ\t-1808+17825\tPacific\/Fiji\n-FK\t-5142-05751\tAtlantic\/Stanley\n-FM\t+0725+15147\tPacific\/Chuuk\tChuuk\/Truk, Yap\n-FM\t+0658+15813\tPacific\/Pohnpei\tPohnpei\/Ponape\n-FM\t+0519+16259\tPacific\/Kosrae\tKosrae\n-FO\t+6201-00646\tAtlantic\/Faroe\n-FR\t+4852+00220\tEurope\/Paris\n-GA\t+0023+00927\tAfrica\/Libreville\n-GB\t+513030-0000731\tEurope\/London\n-GD\t+1203-06145\tAmerica\/Grenada\n-GE\t+4143+04449\tAsia\/Tbilisi\n-GF\t+0456-05220\tAmerica\/Cayenne\n-GG\t+492717-0023210\tEurope\/Guernsey\n-GH\t+0533-00013\tAfrica\/Accra\n-GI\t+3608-00521\tEurope\/Gibraltar\n-GL\t+6411-05144\tAmerica\/Nuuk\tmost of Greenland\n-GL\t+7646-01840\tAmerica\/Danmarkshavn\tNational Park (east coast)\n-GL\t+7029-02158\tAmerica\/Scoresbysund\tScoresbysund\/Ittoqqortoormiit\n-GL\t+7634-06847\tAmerica\/Thule\tThule\/Pituffik\n-GM\t+1328-01639\tAfrica\/Banjul\n-GN\t+0931-01343\tAfrica\/Conakry\n-GP\t+1614-06132\tAmerica\/Guadeloupe\n-GQ\t+0345+00847\tAfrica\/Malabo\n-GR\t+3758+02343\tEurope\/Athens\n-GS\t-5416-03632\tAtlantic\/South_Georgia\n-GT\t+1438-09031\tAmerica\/Guatemala\n-GU\t+1328+14445\tPacific\/Guam\n-GW\t+1151-01535\tAfrica\/Bissau\n-GY\t+0648-05810\tAmerica\/Guyana\n-HK\t+2217+11409\tAsia\/Hong_Kong\n-HN\t+1406-08713\tAmerica\/Tegucigalpa\n-HR\t+4548+01558\tEurope\/Zagreb\n-HT\t+1832-07220\tAmerica\/Port-au-Prince\n-HU\t+4730+01905\tEurope\/Budapest\n-ID\t-0610+10648\tAsia\/Jakarta\tJava, Sumatra\n-ID\t-0002+10920\tAsia\/Pontianak\tBorneo (west, central)\n-ID\t-0507+11924\tAsia\/Makassar\tBorneo (east, south), Sulawesi\/Celebes, Bali, Nusa Tengarra, Timor (west)\n-ID\t-0232+14042\tAsia\/Jayapura\tNew Guinea (West Papua \/ Irian Jaya), Malukus\/Moluccas\n-IE\t+5320-00615\tEurope\/Dublin\n-IL\t+314650+0351326\tAsia\/Jerusalem\n-IM\t+5409-00428\tEurope\/Isle_of_Man\n-IN\t+2232+08822\tAsia\/Kolkata\n-IO\t-0720+07225\tIndian\/Chagos\n-IQ\t+3321+04425\tAsia\/Baghdad\n-IR\t+3540+05126\tAsia\/Tehran\n-IS\t+6409-02151\tAtlantic\/Reykjavik\n-IT\t+4154+01229\tEurope\/Rome\n-JE\t+491101-0020624\tEurope\/Jersey\n-JM\t+175805-0764736\tAmerica\/Jamaica\n-JO\t+3157+03556\tAsia\/Amman\n-JP\t+353916+1394441\tAsia\/Tokyo\n-KE\t-0117+03649\tAfrica\/Nairobi\n-KG\t+4254+07436\tAsia\/Bishkek\n-KH\t+1133+10455\tAsia\/Phnom_Penh\n-KI\t+0125+17300\tPacific\/Tarawa\tGilbert Islands\n-KI\t-0247-17143\tPacific\/Kanton\tPhoenix Islands\n-KI\t+0152-15720\tPacific\/Kiritimati\tLine Islands\n-KM\t-1141+04316\tIndian\/Comoro\n-KN\t+1718-06243\tAmerica\/St_Kitts\n-KP\t+3901+12545\tAsia\/Pyongyang\n-KR\t+3733+12658\tAsia\/Seoul\n-KW\t+2920+04759\tAsia\/Kuwait\n-KY\t+1918-08123\tAmerica\/Cayman\n-KZ\t+4315+07657\tAsia\/Almaty\tmost of Kazakhstan\n-KZ\t+4448+06528\tAsia\/Qyzylorda\tQyzylorda\/Kyzylorda\/Kzyl-Orda\n-KZ\t+5312+06337\tAsia\/Qostanay\tQostanay\/Kostanay\/Kustanay\n-KZ\t+5017+05710\tAsia\/Aqtobe\tAqtobe\/Aktobe\n-KZ\t+4431+05016\tAsia\/Aqtau\tMangghystau\/Mankistau\n-KZ\t+4707+05156\tAsia\/Atyrau\tAtyrau\/Atirau\/Gur'yev\n-KZ\t+5113+05121\tAsia\/Oral\tWest Kazakhstan\n-LA\t+1758+10236\tAsia\/Vientiane\n-LB\t+3353+03530\tAsia\/Beirut\n-LC\t+1401-06100\tAmerica\/St_Lucia\n-LI\t+4709+00931\tEurope\/Vaduz\n-LK\t+0656+07951\tAsia\/Colombo\n-LR\t+0618-01047\tAfrica\/Monrovia\n-LS\t-2928+02730\tAfrica\/Maseru\n-LT\t+5441+02519\tEurope\/Vilnius\n-LU\t+4936+00609\tEurope\/Luxembourg\n-LV\t+5657+02406\tEurope\/Riga\n-LY\t+3254+01311\tAfrica\/Tripoli\n-MA\t+3339-00735\tAfrica\/Casablanca\n-MC\t+4342+00723\tEurope\/Monaco\n-MD\t+4700+02850\tEurope\/Chisinau\n-ME\t+4226+01916\tEurope\/Podgorica\n-MF\t+1804-06305\tAmerica\/Marigot\n-MG\t-1855+04731\tIndian\/Antananarivo\n-MH\t+0709+17112\tPacific\/Majuro\tmost of Marshall Islands\n-MH\t+0905+16720\tPacific\/Kwajalein\tKwajalein\n-MK\t+4159+02126\tEurope\/Skopje\n-ML\t+1239-00800\tAfrica\/Bamako\n-MM\t+1647+09610\tAsia\/Yangon\n-MN\t+4755+10653\tAsia\/Ulaanbaatar\tmost of Mongolia\n-MN\t+4801+09139\tAsia\/Hovd\tBayan-Olgii, Hovd, Uvs\n-MO\t+221150+1133230\tAsia\/Macau\n-MP\t+1512+14545\tPacific\/Saipan\n-MQ\t+1436-06105\tAmerica\/Martinique\n-MR\t+1806-01557\tAfrica\/Nouakchott\n-MS\t+1643-06213\tAmerica\/Montserrat\n-MT\t+3554+01431\tEurope\/Malta\n-MU\t-2010+05730\tIndian\/Mauritius\n-MV\t+0410+07330\tIndian\/Maldives\n-MW\t-1547+03500\tAfrica\/Blantyre\n-MX\t+1924-09909\tAmerica\/Mexico_City\tCentral Mexico\n-MX\t+2105-08646\tAmerica\/Cancun\tQuintana Roo\n-MX\t+2058-08937\tAmerica\/Merida\tCampeche, Yucatan\n-MX\t+2540-10019\tAmerica\/Monterrey\tDurango; Coahuila, Nuevo Leon, Tamaulipas (most areas)\n-MX\t+2550-09730\tAmerica\/Matamoros\tCoahuila, Nuevo Leon, Tamaulipas (US border)\n-MX\t+2838-10605\tAmerica\/Chihuahua\tChihuahua (most areas)\n-MX\t+3144-10629\tAmerica\/Ciudad_Juarez\tChihuahua (US border - west)\n-MX\t+2934-10425\tAmerica\/Ojinaga\tChihuahua (US border - east)\n-MX\t+2313-10625\tAmerica\/Mazatlan\tBaja California Sur, Nayarit (most areas), Sinaloa\n-MX\t+2048-10515\tAmerica\/Bahia_Banderas\tBahia de Banderas\n-MX\t+2904-11058\tAmerica\/Hermosillo\tSonora\n-MX\t+3232-11701\tAmerica\/Tijuana\tBaja California\n-MY\t+0310+10142\tAsia\/Kuala_Lumpur\tMalaysia (peninsula)\n-MY\t+0133+11020\tAsia\/Kuching\tSabah, Sarawak\n-MZ\t-2558+03235\tAfrica\/Maputo\n-NA\t-2234+01706\tAfrica\/Windhoek\n-NC\t-2216+16627\tPacific\/Noumea\n-NE\t+1331+00207\tAfrica\/Niamey\n-NF\t-2903+16758\tPacific\/Norfolk\n-NG\t+0627+00324\tAfrica\/Lagos\n-NI\t+1209-08617\tAmerica\/Managua\n-NL\t+5222+00454\tEurope\/Amsterdam\n-NO\t+5955+01045\tEurope\/Oslo\n-NP\t+2743+08519\tAsia\/Kathmandu\n-NR\t-0031+16655\tPacific\/Nauru\n-NU\t-1901-16955\tPacific\/Niue\n-NZ\t-3652+17446\tPacific\/Auckland\tmost of New Zealand\n-NZ\t-4357-17633\tPacific\/Chatham\tChatham Islands\n-OM\t+2336+05835\tAsia\/Muscat\n-PA\t+0858-07932\tAmerica\/Panama\n-PE\t-1203-07703\tAmerica\/Lima\n-PF\t-1732-14934\tPacific\/Tahiti\tSociety Islands\n-PF\t-0900-13930\tPacific\/Marquesas\tMarquesas Islands\n-PF\t-2308-13457\tPacific\/Gambier\tGambier Islands\n-PG\t-0930+14710\tPacific\/Port_Moresby\tmost of Papua New Guinea\n-PG\t-0613+15534\tPacific\/Bougainville\tBougainville\n-PH\t+1435+12100\tAsia\/Manila\n-PK\t+2452+06703\tAsia\/Karachi\n-PL\t+5215+02100\tEurope\/Warsaw\n-PM\t+4703-05620\tAmerica\/Miquelon\n-PN\t-2504-13005\tPacific\/Pitcairn\n-PR\t+182806-0660622\tAmerica\/Puerto_Rico\n-PS\t+3130+03428\tAsia\/Gaza\tGaza Strip\n-PS\t+313200+0350542\tAsia\/Hebron\tWest Bank\n-PT\t+3843-00908\tEurope\/Lisbon\tPortugal (mainland)\n-PT\t+3238-01654\tAtlantic\/Madeira\tMadeira Islands\n-PT\t+3744-02540\tAtlantic\/Azores\tAzores\n-PW\t+0720+13429\tPacific\/Palau\n-PY\t-2516-05740\tAmerica\/Asuncion\n-QA\t+2517+05132\tAsia\/Qatar\n-RE\t-2052+05528\tIndian\/Reunion\n-RO\t+4426+02606\tEurope\/Bucharest\n-RS\t+4450+02030\tEurope\/Belgrade\n-RU\t+5443+02030\tEurope\/Kaliningrad\tMSK-01 - Kaliningrad\n-RU\t+554521+0373704\tEurope\/Moscow\tMSK+00 - Moscow area\n-# The obsolescent zone.tab format cannot represent Europe\/Simferopol well.\n-# Put it in RU section and list as UA.  See \"territorial claims\" above.\n-# Programs should use zone1970.tab instead; see above.\n-UA\t+4457+03406\tEurope\/Simferopol\tCrimea\n-RU\t+5836+04939\tEurope\/Kirov\tMSK+00 - Kirov\n-RU\t+4844+04425\tEurope\/Volgograd\tMSK+00 - Volgograd\n-RU\t+4621+04803\tEurope\/Astrakhan\tMSK+01 - Astrakhan\n-RU\t+5134+04602\tEurope\/Saratov\tMSK+01 - Saratov\n-RU\t+5420+04824\tEurope\/Ulyanovsk\tMSK+01 - Ulyanovsk\n-RU\t+5312+05009\tEurope\/Samara\tMSK+01 - Samara, Udmurtia\n-RU\t+5651+06036\tAsia\/Yekaterinburg\tMSK+02 - Urals\n-RU\t+5500+07324\tAsia\/Omsk\tMSK+03 - Omsk\n-RU\t+5502+08255\tAsia\/Novosibirsk\tMSK+04 - Novosibirsk\n-RU\t+5322+08345\tAsia\/Barnaul\tMSK+04 - Altai\n-RU\t+5630+08458\tAsia\/Tomsk\tMSK+04 - Tomsk\n-RU\t+5345+08707\tAsia\/Novokuznetsk\tMSK+04 - Kemerovo\n-RU\t+5601+09250\tAsia\/Krasnoyarsk\tMSK+04 - Krasnoyarsk area\n-RU\t+5216+10420\tAsia\/Irkutsk\tMSK+05 - Irkutsk, Buryatia\n-RU\t+5203+11328\tAsia\/Chita\tMSK+06 - Zabaykalsky\n-RU\t+6200+12940\tAsia\/Yakutsk\tMSK+06 - Lena River\n-RU\t+623923+1353314\tAsia\/Khandyga\tMSK+06 - Tomponsky, Ust-Maysky\n-RU\t+4310+13156\tAsia\/Vladivostok\tMSK+07 - Amur River\n-RU\t+643337+1431336\tAsia\/Ust-Nera\tMSK+07 - Oymyakonsky\n-RU\t+5934+15048\tAsia\/Magadan\tMSK+08 - Magadan\n-RU\t+4658+14242\tAsia\/Sakhalin\tMSK+08 - Sakhalin Island\n-RU\t+6728+15343\tAsia\/Srednekolymsk\tMSK+08 - Sakha (E), N Kuril Is\n-RU\t+5301+15839\tAsia\/Kamchatka\tMSK+09 - Kamchatka\n-RU\t+6445+17729\tAsia\/Anadyr\tMSK+09 - Bering Sea\n-RW\t-0157+03004\tAfrica\/Kigali\n-SA\t+2438+04643\tAsia\/Riyadh\n-SB\t-0932+16012\tPacific\/Guadalcanal\n-SC\t-0440+05528\tIndian\/Mahe\n-SD\t+1536+03232\tAfrica\/Khartoum\n-SE\t+5920+01803\tEurope\/Stockholm\n-SG\t+0117+10351\tAsia\/Singapore\n-SH\t-1555-00542\tAtlantic\/St_Helena\n-SI\t+4603+01431\tEurope\/Ljubljana\n-SJ\t+7800+01600\tArctic\/Longyearbyen\n-SK\t+4809+01707\tEurope\/Bratislava\n-SL\t+0830-01315\tAfrica\/Freetown\n-SM\t+4355+01228\tEurope\/San_Marino\n-SN\t+1440-01726\tAfrica\/Dakar\n-SO\t+0204+04522\tAfrica\/Mogadishu\n-SR\t+0550-05510\tAmerica\/Paramaribo\n-SS\t+0451+03137\tAfrica\/Juba\n-ST\t+0020+00644\tAfrica\/Sao_Tome\n-SV\t+1342-08912\tAmerica\/El_Salvador\n-SX\t+180305-0630250\tAmerica\/Lower_Princes\n-SY\t+3330+03618\tAsia\/Damascus\n-SZ\t-2618+03106\tAfrica\/Mbabane\n-TC\t+2128-07108\tAmerica\/Grand_Turk\n-TD\t+1207+01503\tAfrica\/Ndjamena\n-TF\t-492110+0701303\tIndian\/Kerguelen\n-TG\t+0608+00113\tAfrica\/Lome\n-TH\t+1345+10031\tAsia\/Bangkok\n-TJ\t+3835+06848\tAsia\/Dushanbe\n-TK\t-0922-17114\tPacific\/Fakaofo\n-TL\t-0833+12535\tAsia\/Dili\n-TM\t+3757+05823\tAsia\/Ashgabat\n-TN\t+3648+01011\tAfrica\/Tunis\n-TO\t-210800-1751200\tPacific\/Tongatapu\n-TR\t+4101+02858\tEurope\/Istanbul\n-TT\t+1039-06131\tAmerica\/Port_of_Spain\n-TV\t-0831+17913\tPacific\/Funafuti\n-TW\t+2503+12130\tAsia\/Taipei\n-TZ\t-0648+03917\tAfrica\/Dar_es_Salaam\n-UA\t+5026+03031\tEurope\/Kyiv\tmost of Ukraine\n-UG\t+0019+03225\tAfrica\/Kampala\n-UM\t+2813-17722\tPacific\/Midway\tMidway Islands\n-UM\t+1917+16637\tPacific\/Wake\tWake Island\n-US\t+404251-0740023\tAmerica\/New_York\tEastern (most areas)\n-US\t+421953-0830245\tAmerica\/Detroit\tEastern - MI (most areas)\n-US\t+381515-0854534\tAmerica\/Kentucky\/Louisville\tEastern - KY (Louisville area)\n-US\t+364947-0845057\tAmerica\/Kentucky\/Monticello\tEastern - KY (Wayne)\n-US\t+394606-0860929\tAmerica\/Indiana\/Indianapolis\tEastern - IN (most areas)\n-US\t+384038-0873143\tAmerica\/Indiana\/Vincennes\tEastern - IN (Da, Du, K, Mn)\n-US\t+410305-0863611\tAmerica\/Indiana\/Winamac\tEastern - IN (Pulaski)\n-US\t+382232-0862041\tAmerica\/Indiana\/Marengo\tEastern - IN (Crawford)\n-US\t+382931-0871643\tAmerica\/Indiana\/Petersburg\tEastern - IN (Pike)\n-US\t+384452-0850402\tAmerica\/Indiana\/Vevay\tEastern - IN (Switzerland)\n-US\t+415100-0873900\tAmerica\/Chicago\tCentral (most areas)\n-US\t+375711-0864541\tAmerica\/Indiana\/Tell_City\tCentral - IN (Perry)\n-US\t+411745-0863730\tAmerica\/Indiana\/Knox\tCentral - IN (Starke)\n-US\t+450628-0873651\tAmerica\/Menominee\tCentral - MI (Wisconsin border)\n-US\t+470659-1011757\tAmerica\/North_Dakota\/Center\tCentral - ND (Oliver)\n-US\t+465042-1012439\tAmerica\/North_Dakota\/New_Salem\tCentral - ND (Morton rural)\n-US\t+471551-1014640\tAmerica\/North_Dakota\/Beulah\tCentral - ND (Mercer)\n-US\t+394421-1045903\tAmerica\/Denver\tMountain (most areas)\n-US\t+433649-1161209\tAmerica\/Boise\tMountain - ID (south), OR (east)\n-US\t+332654-1120424\tAmerica\/Phoenix\tMST - AZ (except Navajo)\n-US\t+340308-1181434\tAmerica\/Los_Angeles\tPacific\n-US\t+611305-1495401\tAmerica\/Anchorage\tAlaska (most areas)\n-US\t+581807-1342511\tAmerica\/Juneau\tAlaska - Juneau area\n-US\t+571035-1351807\tAmerica\/Sitka\tAlaska - Sitka area\n-US\t+550737-1313435\tAmerica\/Metlakatla\tAlaska - Annette Island\n-US\t+593249-1394338\tAmerica\/Yakutat\tAlaska - Yakutat\n-US\t+643004-1652423\tAmerica\/Nome\tAlaska (west)\n-US\t+515248-1763929\tAmerica\/Adak\tAlaska - western Aleutians\n-US\t+211825-1575130\tPacific\/Honolulu\tHawaii\n-UY\t-345433-0561245\tAmerica\/Montevideo\n-UZ\t+3940+06648\tAsia\/Samarkand\tUzbekistan (west)\n-UZ\t+4120+06918\tAsia\/Tashkent\tUzbekistan (east)\n-VA\t+415408+0122711\tEurope\/Vatican\n-VC\t+1309-06114\tAmerica\/St_Vincent\n-VE\t+1030-06656\tAmerica\/Caracas\n-VG\t+1827-06437\tAmerica\/Tortola\n-VI\t+1821-06456\tAmerica\/St_Thomas\n-VN\t+1045+10640\tAsia\/Ho_Chi_Minh\n-VU\t-1740+16825\tPacific\/Efate\n-WF\t-1318-17610\tPacific\/Wallis\n-WS\t-1350-17144\tPacific\/Apia\n-YE\t+1245+04512\tAsia\/Aden\n-YT\t-1247+04514\tIndian\/Mayotte\n-ZA\t-2615+02800\tAfrica\/Johannesburg\n-ZM\t-1525+02817\tAfrica\/Lusaka\n-ZW\t-1750+03103\tAfrica\/Harare\n","filename":"src\/java.base\/share\/data\/tzdata\/zone.tab","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-        if(::DrawFocusRect(hDC, &focusRect) == 0)\n+        if (!::IsRectEmpty(&focusRect) && (::DrawFocusRect(hDC, &focusRect) == 0))\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Button.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,1 @@\n-        if(::DrawFocusRect(hDC, &focusRect) == 0)\n+        if (!::IsRectEmpty(&focusRect) && (::DrawFocusRect(hDC, &focusRect) == 0))\n@@ -299,1 +299,1 @@\n-        if(::DrawFocusRect(hDC, &focusRect) == 0)\n+        if (!::IsRectEmpty(&focusRect) && (::DrawFocusRect(hDC, &focusRect) == 0))\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Checkbox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -4468,1 +4468,1 @@\n-          if(::DrawFocusRect(hDC, &rect) == 0)\n+          if (!::IsRectEmpty(&rect) && (::DrawFocusRect(hDC, &rect) == 0))\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3907,0 +3907,2 @@\n+            case KeyEvent.VK_TAB:\n+            case KeyEvent.VK_SPACE:\n@@ -3949,9 +3951,4 @@\n-        String keyText = KeyEvent.getKeyText(keyStroke.getKeyCode());\n-        debugString(\"[INFO]:   Shortcut is: \" + keyText);\n-        if (keyText != null || keyText.length() > 0) {\n-            CharSequence seq = keyText.subSequence(0, 1);\n-            if (seq != null || seq.length() > 0) {\n-                return seq.charAt(0);\n-            }\n-        }\n-        return 0;\n+\n+        keyCode = keyStroke.getKeyCode();\n+        debugString(\"[INFO]:   Shortcut is: \" + Integer.toHexString(keyCode));\n+        return (char)keyCode;\n","filename":"src\/jdk.accessibility\/windows\/classes\/com\/sun\/java\/accessibility\/internal\/AccessBridge.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1111,0 +1111,2 @@\n+#define ACCESSIBLE_VK_TAB           9\n+#define ACCESSIBLE_VK_SPACE         32\n","filename":"src\/jdk.accessibility\/windows\/native\/include\/bridge\/AccessBridgePackages.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,5 +78,0 @@\n-\n-  \/\/ get flags written to .class files\n-  public int getStandardFlags() {\n-    return (int) (flags & JVM_ACC_WRITTEN_FLAGS);\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/AccessFlags.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,8 +101,0 @@\n-    \/\/ from accessFlags.hpp - hotspot internal flags\n-\n-    \/\/ flags actually put in .class file\n-    public static final long JVM_ACC_WRITTEN_FLAGS = 0x00007FFF;\n-\n-    \/\/ flags accepted by set_field_flags\n-    public static final long JVM_ACC_FIELD_FLAGS = 0x00008000 | JVM_ACC_WRITTEN_FLAGS;\n-\n@@ -110,1 +102,0 @@\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ClassConstants.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -356,3 +356,4 @@\n-                        String n = we.name + \".\" + subField.getName();\n-                        String l = we.label + \" : \" + makeLabel(subField, false);\n-                        if (stack.size() < 2) { \/\/ Limit depth to 2\n+                        \/\/ Limit depth to 2\n+                        if (!we.name.contains(\".\")) {\n+                            String n = we.name + \".\" + subField.getName();\n+                            String l = we.label + \" : \" + makeLabel(subField, false);\n@@ -372,1 +373,0 @@\n-            field.index = result.size();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            return createPercentile(field, 0.9999);\n+            return createPercentile(field, 0.999);\n@@ -178,3 +178,3 @@\n-                long s = seconds \/ count;\n-                long n = nanos \/ count;\n-                return Duration.ofSeconds(s, n);\n+                double total = 1_000_000_000.0 * seconds + nanos;\n+                double average = total \/ count;\n+                return Duration.ofNanos(Math.round(average));\n@@ -581,1 +581,1 @@\n-            double fraction = doubleIndex - valueIndex;\n+            double fraction = doubleIndex - (int) doubleIndex;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Function.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+        applyIndex();\n@@ -106,0 +107,7 @@\n+    private void applyIndex() {\n+        int index = 0;\n+        for (Field field : resultFields) {\n+            field.index = index++;\n+        }\n+    }\n+\n@@ -241,1 +249,0 @@\n-            field.index = resultFields.size();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryResolver.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n@@ -52,0 +55,1 @@\n+        public InputStream getResource(String name);\n@@ -74,1 +78,0 @@\n-                byte[] baseBytes = base.getResourceBytes(item);\n@@ -85,1 +88,1 @@\n-                           .setResourceBytes(baseBytes)\n+                           .setResourceBytes(base.getResourceBytes(item))\n@@ -91,2 +94,1 @@\n-                boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n-                if (!contentEquals) {\n+                if (!compareStreams(base.getResource(item), image.getResource(item))) {\n@@ -97,1 +99,1 @@\n-                        .setResourceBytes(baseBytes)\n+                        .setResourceBytes(base.getResourceBytes(item))\n@@ -115,0 +117,47 @@\n+    \/**\n+     * Compare the contents of the two input streams (byte-by-byte).\n+     *\n+     * @param is1 The first input stream\n+     * @param is2 The second input stream\n+     * @return {@code true} iff the two streams contain the same number of\n+     *         bytes and each byte of the streams are equal. {@code false}\n+     *         otherwise.\n+     *\/\n+    private boolean compareStreams(InputStream is1, InputStream is2) {\n+        byte[] buf1 = new byte[1024];\n+        byte[] buf2 = new byte[1024];\n+        int bytesRead1, bytesRead2 = 0;\n+        try {\n+            try (is1; is2) {\n+                while ((bytesRead1 = is1.read(buf1)) != -1 &&\n+                       (bytesRead2 = is2.read(buf2)) != -1) {\n+                    if (bytesRead1 != bytesRead2) {\n+                        return false;\n+                    }\n+                    if (bytesRead1 == buf1.length) {\n+                        if (!Arrays.equals(buf1, buf2)) {\n+                            return false;\n+                        }\n+                    } else {\n+                        for (int i = 0; i < bytesRead1; i++) {\n+                            if (buf1[i] != buf2[i]) {\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                \/\/ ensure we read both to the end\n+                if (bytesRead1 == -1) {\n+                    bytesRead2 = is2.read(buf2);\n+                    if (bytesRead2 != -1) {\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"IO exception when comparing bytes\", e);\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JimageDiffGenerator.java","additions":54,"deletions":5,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.InputStream;\n@@ -59,0 +60,5 @@\n+    @Override\n+    public InputStream getResource(String name) {\n+        return pool.findEntry(name).orElseThrow().content();\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourcePoolReader.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.LAYOUT_NODE_DEGREE_COMPARATOR;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n+import java.util.*;\n+\n+public class FreeInteractiveLayoutManager extends LayoutManager implements LayoutMover {\n+\n+    private boolean cutEdges = false;\n+\n+    private static final int LINE_OFFSET = 10;\n+\n+    private Map<Vertex, LayoutNode> layoutNodes;\n+\n+    private LayoutGraph prevGraph;\n+\n+    private final Random random = new Random(42);\n+\n+    \/\/ Constants for offsets and displacements\n+    private static final int MAX_OFFSET_AROUND_NEIGHBOR = 200; \/\/ Max offset for random positioning around a neighbor\n+    private static final int MAX_OFFSET_AROUND_ORIGIN = 200; \/\/ Max offset for random positioning around origin\n+    private static final int DISPLACEMENT_RANGE_BARYCENTER = 100; \/\/ Displacement range for barycenter calculation\n+    private static final int DISPLACEMENT_RANGE_SINGLE = 200;\n+\n+    \/\/ Create a comparator to sort nodes by the number of unassigned neighbors\n+    private final Comparator<LayoutNode> LeastUnassignedNeighborsComparator = Comparator.comparingInt(node -> {\n+        Vertex vertex = node.getVertex();\n+        int unassignedNeighbors = 0;\n+        for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+            if (!layoutNodes.containsKey(neighborVertex)) {\n+                unassignedNeighbors++;\n+            }\n+        }\n+        return unassignedNeighbors;\n+    });\n+\n+    public FreeInteractiveLayoutManager() {\n+        this.cutEdges = false;\n+        this.layoutNodes = new HashMap<>();\n+        this.prevGraph = null;\n+    }\n+\n+    @Override\n+    public void moveLink(Point linkPos, int shiftX) {}\n+\n+    @Override\n+    public void moveVertices(Set<? extends Vertex> movedVertices) {\n+        for (Vertex v : movedVertices) {\n+            moveVertex(v);\n+        }\n+    }\n+\n+    @Override\n+    public void moveVertex(Vertex vertex) {\n+        assert prevGraph.containsVertex(vertex);\n+        LayoutNode layoutNode = layoutNodes.get(vertex);\n+        layoutNode.setX(vertex.getPosition().x);\n+        layoutNode.setY(vertex.getPosition().y);\n+        for (Link link : prevGraph.getAllLinks(vertex)) {\n+            setLinkControlPoints(link);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isFreeForm() {\n+        return true;\n+    }\n+\n+    public void setCutEdges(boolean enable) {\n+        this.cutEdges = enable;\n+    }\n+\n+    @Override\n+    public void doLayout(LayoutGraph graph) {\n+        prevGraph = graph;\n+        if (layoutNodes.isEmpty()) {\n+            HierarchicalLayoutManager manager = new HierarchicalLayoutManager();\n+            manager.doLayout(graph);\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                node.initSize();\n+                layoutNodes.put(node.getVertex(), node);\n+            }\n+            graph.clearLayout();\n+        } else {\n+            \/\/ add new vertices to layoutNodes, x\/y from barycenter\n+            List<LayoutNode> newLayoutNodes = new ArrayList<>();\n+\n+            \/\/ Set up layout nodes for each vertex\n+            for (Vertex vertex : prevGraph.getVertices()) {\n+                if (!layoutNodes.containsKey(vertex)) {\n+                    LayoutNode addedNode = new LayoutNode(vertex);\n+                    addedNode.initSize();\n+                    newLayoutNodes.add(addedNode);\n+                }\n+            }\n+\n+            positionNewLayoutNodes(newLayoutNodes);\n+        }\n+\n+        \/\/ Write back vertices\n+        for (Vertex vertex : prevGraph.getVertices()) {\n+            LayoutNode layoutNode = layoutNodes.get(vertex);\n+            layoutNode.setVertex(vertex);\n+            vertex.setPosition(new Point(layoutNode.getLeft(), layoutNode.getTop()));\n+        }\n+\n+        \/\/ Write back links\n+        for (Link link : prevGraph.getLinks()) {\n+            setLinkControlPoints(link);\n+        }\n+    }\n+\n+    public void positionNewLayoutNodes(List<LayoutNode> newLayoutNodes) {\n+        \/\/ First pass: Initial positioning based on unassigned neighbors\n+        newLayoutNodes.sort(LeastUnassignedNeighborsComparator);\n+\n+        for (LayoutNode node : newLayoutNodes) {\n+            Vertex vertex = node.getVertex();\n+\n+            \/\/ Gather assigned neighbors\n+            List<LayoutNode> assignedNeighbors = new ArrayList<>();\n+            for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+                if (layoutNodes.containsKey(neighborVertex)) {\n+                    assignedNeighbors.add(layoutNodes.get(neighborVertex));\n+                }\n+            }\n+\n+            if (!assignedNeighbors.isEmpty()) {\n+                if (assignedNeighbors.size() == 1) {\n+                    \/\/ Single neighbor: position around the neighbor\n+                    setPositionAroundSingleNode(node, assignedNeighbors.get(0), DISPLACEMENT_RANGE_SINGLE);\n+                } else {\n+                    \/\/ Multiple neighbors: Calculate barycenter with displacement\n+                    calculateBarycenterWithDisplacement(node, assignedNeighbors, DISPLACEMENT_RANGE_BARYCENTER);\n+                }\n+            } else {\n+                \/\/ No neighbors: Position randomly around (0, 0)\n+                setRandomPositionAroundOrigin(node, random);\n+            }\n+\n+            \/\/ Add the new node to the layout\n+            layoutNodes.put(vertex, node);\n+        }\n+\n+        \/\/ Second pass: Refine positions based on neighbor degree\n+        newLayoutNodes.sort(LAYOUT_NODE_DEGREE_COMPARATOR.reversed());\n+\n+        \/\/ Collect all nodes (existing and new)\n+        Collection<LayoutNode> allNodes = layoutNodes.values();\n+\n+        for (LayoutNode node : newLayoutNodes) {\n+            Vertex vertex = node.getVertex();\n+\n+            \/\/ Gather assigned neighbors\n+            List<LayoutNode> assignedNeighbors = new ArrayList<>();\n+            for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+                if (layoutNodes.containsKey(neighborVertex)) {\n+                    assignedNeighbors.add(layoutNodes.get(neighborVertex));\n+                }\n+            }\n+\n+            if (!assignedNeighbors.isEmpty()) {\n+                \/\/ Refine position based on force-based method\n+                applyForceBasedAdjustment(node, assignedNeighbors, allNodes);\n+            }\n+\n+            \/\/ Ensure node's position remains updated in the layout\n+            layoutNodes.put(vertex, node);\n+        }\n+    }\n+\n+    \/**\n+     * Applies a force-based adjustment to the position of a given layout node\n+     * based on repulsive forces from all other nodes and attractive forces from its assigned neighbors.\n+     * <p>\n+     * This method simulates a physical system where nodes repel each other to maintain spacing\n+     * and are pulled towards their neighbors to maintain connectivity. The forces are calculated\n+     * using Coulomb's law for repulsion and Hooke's law for attraction. The system iterates for\n+     * a fixed number of iterations to stabilize the position of the node.\n+     *\n+     * @param node               The node whose position is being adjusted.\n+     * @param assignedNeighbors  A list of neighboring nodes that attract this node.\n+     * @param allNodes           A collection of all nodes in the layout, used for repulsive forces.\n+     *\/\n+    private void applyForceBasedAdjustment(LayoutNode node, List<LayoutNode> assignedNeighbors, Collection<LayoutNode> allNodes) {\n+        \/\/ Constants for force-based adjustment\n+        final int ITERATIONS = 50; \/\/ Number of simulation iterations\n+        final double REPULSION_CONSTANT = 1000; \/\/ Magnitude of repulsive forces (Coulomb's law)\n+        final double SPRING_CONSTANT = 0.2; \/\/ Strength of attractive forces to neighbors (Hooke's law)\n+        final double DAMPING = 0.8; \/\/ Factor to reduce displacement and ensure stability\n+        final double IDEAL_LENGTH = 100; \/\/ Desired distance between a node and its neighbors\n+        final double MAX_FORCE = 1000; \/\/ Upper limit for the magnitude of applied forces\n+        final double CONVERGENCE_THRESHOLD = 0.01; \/\/ Force threshold for stopping early\n+\n+        double posX = node.getX();\n+        double posY = node.getY();\n+        double dx = 0, dy = 0; \/\/ Displacement\n+\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            double netForceX = 0;\n+            double netForceY = 0;\n+\n+            \/\/ Repulsive forces from all other nodes\n+            for (LayoutNode otherNode : allNodes) {\n+                if (otherNode == node) continue; \/\/ Skip self\n+\n+                double deltaX = posX - otherNode.getX();\n+                double deltaY = posY - otherNode.getY();\n+                double distanceSquared = deltaX * deltaX + deltaY * deltaY;\n+                double distance = Math.sqrt(distanceSquared);\n+\n+                \/\/ Avoid division by zero by introducing a minimum distance\n+                if (distance < 1e-6) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05;\n+                    deltaY = random.nextDouble() * 0.1 - 0.05;\n+                    distanceSquared = deltaX * deltaX + deltaY * deltaY;\n+                    distance = Math.sqrt(distanceSquared);\n+                }\n+\n+                \/\/ Repulsive force (Coulomb's law)\n+                double repulsiveForce = REPULSION_CONSTANT \/ distanceSquared;\n+\n+                \/\/ Normalize force to prevent large displacements\n+                if (repulsiveForce > MAX_FORCE) repulsiveForce = MAX_FORCE;\n+\n+                netForceX += (deltaX \/ distance) * repulsiveForce;\n+                netForceY += (deltaY \/ distance) * repulsiveForce;\n+            }\n+\n+            \/\/ Attractive forces to assigned neighbors\n+            for (LayoutNode neighbor : assignedNeighbors) {\n+                double deltaX = neighbor.getX() - posX;\n+                double deltaY = neighbor.getY() - posY;\n+                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n+\n+                if (distance < 1e-6) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05;\n+                    deltaY = random.nextDouble() * 0.1 - 0.05;\n+                    distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n+                }\n+\n+                \/\/ Attractive force (Hooke's law)\n+                double displacement = distance - IDEAL_LENGTH;\n+                double attractiveForce = SPRING_CONSTANT * displacement;\n+\n+                if (attractiveForce > MAX_FORCE) attractiveForce = MAX_FORCE;\n+\n+                netForceX += (deltaX \/ distance) * attractiveForce;\n+                netForceY += (deltaY \/ distance) * attractiveForce;\n+            }\n+\n+            \/\/ Apply damping and update displacement\n+            dx = (dx + netForceX) * DAMPING;\n+            dy = (dy + netForceY) * DAMPING;\n+\n+            \/\/ Scale displacement if it's too large\n+            double displacementMagnitude = Math.sqrt(dx * dx + dy * dy);\n+            if (displacementMagnitude > MAX_FORCE) {\n+                dx *= MAX_FORCE \/ displacementMagnitude;\n+                dy *= MAX_FORCE \/ displacementMagnitude;\n+            }\n+\n+            \/\/ Update position\n+            posX += dx;\n+            posY += dy;\n+\n+            \/\/ Stop early if the net force is negligible\n+            if (Math.abs(netForceX) < CONVERGENCE_THRESHOLD && Math.abs(netForceY) < CONVERGENCE_THRESHOLD) {\n+                break;\n+            }\n+\n+            \/\/ Validate position to avoid invalid or extreme values\n+            if (Double.isNaN(posX) || Double.isInfinite(posX) || Double.isNaN(posY) || Double.isInfinite(posY)) {\n+                posX = node.getX(); \/\/ Reset to original position\n+                posY = node.getY();\n+                break;\n+            }\n+        }\n+\n+        \/\/ Set final position\n+        node.setX((int) Math.round(posX));\n+        node.setY((int) Math.round(posY));\n+    }\n+\n+    \/\/ Utility method: position around a given node\n+    private void setPositionAroundSingleNode(LayoutNode node, LayoutNode neighbor, int displacement) {\n+        boolean neighborIsPredecessor = prevGraph.isPredecessorVertex(node.getVertex(), neighbor.getVertex());\n+        boolean neighborIsSuccessor = prevGraph.isSuccessorVertex(node.getVertex(), neighbor.getVertex());\n+\n+        int shiftY = 0;\n+        if (neighborIsPredecessor) {\n+            shiftY = displacement;\n+        } else if (neighborIsSuccessor) {\n+            shiftY = -displacement;\n+        }\n+        assert shiftY != 0;\n+\n+        int randomY = neighbor.getY() + random.nextInt(MAX_OFFSET_AROUND_NEIGHBOR + 1) + shiftY;\n+        int randomX = neighbor.getX() + random.nextInt(MAX_OFFSET_AROUND_NEIGHBOR + 1);\n+        node.setX(randomX);\n+        node.setY(randomY);\n+    }\n+\n+    \/\/ Utility method: Random position around origin\n+    private void setRandomPositionAroundOrigin(LayoutNode node, Random random) {\n+        int randomX = random.nextInt(MAX_OFFSET_AROUND_ORIGIN + 1);\n+        int randomY = random.nextInt(MAX_OFFSET_AROUND_ORIGIN + 1);\n+        node.setX(randomX);\n+        node.setY(randomY);\n+    }\n+\n+    \/\/ Utility method: Calculate barycenter with displacement\n+    private void calculateBarycenterWithDisplacement(LayoutNode node, List<LayoutNode> neighbors, int displacementRange) {\n+        double barycenterX = 0, barycenterY = 0;\n+        for (LayoutNode neighbor : neighbors) {\n+            barycenterX += neighbor.getX();\n+            barycenterY += neighbor.getY();\n+        }\n+        barycenterX \/= neighbors.size();\n+        barycenterY \/= neighbors.size();\n+\n+        \/\/ Add random displacement for slight separation\n+        int displacementX = random.nextInt(displacementRange + 1);\n+        int displacementY = random.nextInt(displacementRange + 1);\n+        node.setX((int) barycenterX + displacementX);\n+        node.setY((int) barycenterY + displacementY);\n+    }\n+\n+    \/**\n+     * Sets control points for a given link based on its start and end layout nodes.\n+     * <p>\n+     * Calculates the start and end points, applies offsets for curvature, and updates\n+     * the link's control points.\n+     *\n+     * @param link The link to process.\n+     *\/\n+    private void setLinkControlPoints(Link link) {\n+        if (link.getFrom().getVertex() == link.getTo().getVertex()) return; \/\/ Skip self-links\n+\n+        LayoutNode from = layoutNodes.get(link.getFrom().getVertex());\n+        from.setVertex(link.getFrom().getVertex());\n+        from.updateSize();\n+\n+        LayoutNode to = layoutNodes.get(link.getTo().getVertex());\n+        to.setVertex(link.getTo().getVertex());\n+        to.updateSize();\n+\n+        Point startPoint = new Point(from.getLeft() + link.getFrom().getRelativePosition().x, from.getBottom());\n+        Point endPoint = new Point(to.getLeft() + link.getTo().getRelativePosition().x, to.getTop());\n+\n+        List<Point> controlPoints = new ArrayList<>();\n+        controlPoints.add(startPoint);\n+        controlPoints.add(new Point(startPoint.x, startPoint.y + LINE_OFFSET));\n+        controlPoints.add(new Point(endPoint.x, endPoint.y - LINE_OFFSET));\n+        controlPoints.add(endPoint);\n+\n+        link.setControlPoints(controlPoints);\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/FreeInteractiveLayoutManager.java","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -56,0 +56,5 @@\n+   @Override\n+    public boolean isFreeForm() {\n+        return false;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +172,1 @@\n-     * @return An unmodifiable list containing all nodes in the graph.\n+     * @return An unmodifiable list containing all nodes in the graph\n@@ -450,0 +450,57 @@\n+    \/**\n+     * Checks if the given predecessorVertex is a direct predecessor of the specified vertex.\n+     *\n+     * @param vertex The vertex to check for predecessors.\n+     * @param predecessorVertex The vertex to verify as a predecessor of the given vertex.\n+     * @return true if predecessorVertex is a direct predecessor of vertex, false otherwise.\n+     *\/\n+    public boolean isPredecessorVertex(Vertex vertex, Vertex predecessorVertex) {\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link inputLink : portLinks.getOrDefault(inputPort, Collections.emptySet())) {\n+                Vertex fromVertex = inputLink.getFrom().getVertex();\n+                if (fromVertex.equals(predecessorVertex)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Checks if the given successorVertex is a direct successor of the specified vertex.\n+     *\n+     * @param vertex The vertex to check for successors.\n+     * @param successorVertex The vertex to verify as a successor of the given vertex.\n+     * @return true if successorVertex is a direct successor of vertex, false otherwise.\n+     *\/\n+    public boolean isSuccessorVertex(Vertex vertex, Vertex successorVertex) {\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link outputLink : portLinks.getOrDefault(outputPort, Collections.emptySet())) {\n+                Vertex toVertex = outputLink.getTo().getVertex();\n+                if (toVertex.equals(successorVertex)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public List<Vertex> getNeighborVertices(Vertex vertex) {\n+        List<Vertex> neighborVertices = new ArrayList<>();\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link inputLink : portLinks.getOrDefault(inputPort, Collections.emptySet())) {\n+                Vertex fromVertex = inputLink.getFrom().getVertex();\n+                assert fromVertex != null;\n+                neighborVertices.add(fromVertex);\n+            }\n+        }\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link outputLink : portLinks.getOrDefault(outputPort, Collections.emptySet())) {\n+                Vertex toVertex = outputLink.getTo().getVertex();\n+                assert toVertex != null;\n+                neighborVertices.add(toVertex);\n+            }\n+        }\n+        return neighborVertices;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutGraph.java","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+\n+    boolean isFreeForm();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutMover.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,6 +110,1 @@\n-    \/**\n-     * Initializes the size and margins of the node.\n-     * If the node represents a real vertex, it uses the vertex's size.\n-     * Dummy nodes use default dimensions.\n-     *\/\n-    public void initSize() {\n+    public void updateSize() {\n@@ -124,0 +119,9 @@\n+    }\n+\n+    \/**\n+     * Initializes the size and margins of the node.\n+     * If the node represents a real vertex, it uses the vertex's size.\n+     * Dummy nodes use default dimensions.\n+     *\/\n+    public void initSize() {\n+        updateSize();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutNode.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+        public static final int INTERACTIVE_FREE_NODES = 4;\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    private final FreeInteractiveLayoutManager freeInteractiveLayoutManager;\n@@ -514,0 +515,1 @@\n+        freeInteractiveLayoutManager = new FreeInteractiveLayoutManager();\n@@ -646,0 +648,2 @@\n+                if (layoutMover.isFreeForm()) return;\n+\n@@ -705,2 +709,6 @@\n-                int shiftY = magnetToStartLayerY(widget, location);\n-\n+                int shiftY;\n+                if (layoutMover.isFreeForm()) {\n+                    shiftY = location.y - widget.getLocation().y;\n+                } else {\n+                    shiftY = magnetToStartLayerY(widget, location);\n+                }\n@@ -716,1 +724,0 @@\n-                                Point toPt = lw.getTo();\n@@ -718,4 +725,8 @@\n-                                if (toPt != null && fromPt != null) {\n-                                    int xTo = toPt.x + shiftX;\n-                                    int yTo = toPt.y + shiftY;\n-                                    lw.setTo(new Point(xTo, yTo));\n+                                Point toPt = lw.getTo();\n+                                if (toPt == null || fromPt == null) {\n+                                    continue;\n+                                }\n+                                int xTo = toPt.x + shiftX;\n+                                int yTo = toPt.y + shiftY;\n+                                lw.setTo(new Point(xTo, yTo));\n+                                if (!layoutMover.isFreeForm()) {\n@@ -738,4 +749,7 @@\n-                                if (toPt != null && fromPt != null) {\n-                                    int xFrom = fromPt.x + shiftX;\n-                                    int yFrom = fromPt.y + shiftY;\n-                                    lw.setFrom(new Point(xFrom, yFrom));\n+                                if (toPt == null || fromPt == null) {\n+                                    continue;\n+                                }\n+                                int xFrom = fromPt.x + shiftX;\n+                                int yFrom = fromPt.y + shiftY;\n+                                lw.setFrom(new Point(xFrom, yFrom));\n+                                if (!layoutMover.isFreeForm()) {\n@@ -756,4 +770,6 @@\n-                FigureWidget fw = getWidget(selectedFigures.iterator().next());\n-                pointerWidget.setVisible(true);\n-                Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n-                ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                if (selectedFigures.size() == 1 && !layoutMover.isFreeForm()) {\n+                    FigureWidget fw = getWidget(selectedFigures.iterator().next());\n+                    pointerWidget.setVisible(true);\n+                    Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n+                    ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                }\n@@ -837,1 +853,3 @@\n-        if (getModel().getShowStableSea()) {\n+        if (getModel().getShowFreeInteractive()) {\n+            doFreeInteractiveLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowStableSea()) {\n@@ -907,0 +925,6 @@\n+    private void doFreeInteractiveLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        layoutMover = freeInteractiveLayoutManager;\n+        freeInteractiveLayoutManager.setCutEdges(model.getCutEdges());\n+        freeInteractiveLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n+    }\n+\n@@ -1111,0 +1135,46 @@\n+    private void processFreeForm(OutputSlot outputSlot, List<FigureConnection> connections) {\n+        for (FigureConnection connection : connections) {\n+            if (isVisibleFigureConnection(connection)) {\n+                boolean isBold = false;\n+                boolean isDashed = true;\n+                boolean isVisible = true;\n+                if (connection.getStyle() == Connection.ConnectionStyle.BOLD) {\n+                    isBold = true;\n+                } else if (connection.getStyle() == Connection.ConnectionStyle.INVISIBLE) {\n+                    isVisible = false;\n+                }\n+                if (connection.getStyle() != Connection.ConnectionStyle.DASHED) {\n+                    isDashed = false;\n+                }\n+\n+\n+                List<Point> controlPoints = connection.getControlPoints();\n+                if (controlPoints.size() <= 2) continue;\n+                Point firstPoint = controlPoints.get(0); \/\/ First point\n+                Point lastPoint = controlPoints.get(controlPoints.size() - 1); \/\/ Last point\n+                List<FigureConnection> connectionList = new ArrayList<>(Collections.singleton(connection));\n+                LineWidget line = new LineWidget(this, outputSlot, connectionList, firstPoint, lastPoint, null, isBold, isDashed);\n+                line.setFromControlYOffset(50);\n+                line.setToControlYOffset(-50);\n+                line.setVisible(isVisible);\n+                connectionLayer.addChild(line);\n+\n+                addObject(new ConnectionSet(connectionList), line);\n+                line.getActions().addAction(hoverAction);\n+\n+                if (outputSlotToLineWidget.containsKey(outputSlot)) {\n+                    outputSlotToLineWidget.get(outputSlot).add(line);\n+                } else {\n+                    outputSlotToLineWidget.put(outputSlot, new HashSet<>(Collections.singleton(line)));\n+                }\n+\n+                InputSlot inputSlot = connection.getInputSlot();\n+                if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                    inputSlotToLineWidget.get(inputSlot).add(line);\n+                } else {\n+                    inputSlotToLineWidget.put(inputSlot, new HashSet<>(Collections.singleton(line)));\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1284,1 +1354,5 @@\n-                processOutputSlot(outputSlot, connectionList, 0, null, null);\n+                if (layoutMover != null && layoutMover.isFreeForm()) {\n+                    processFreeForm(outputSlot, connectionList);\n+                } else {\n+                    processOutputSlot(outputSlot, connectionList, 0, null, null);\n+                }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":91,"deletions":17,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private boolean showFreeInteractive;\n@@ -107,0 +108,11 @@\n+    public boolean getShowFreeInteractive() {\n+        return showFreeInteractive;\n+    }\n+\n+    public void setShowFreeInteractive(boolean enable) {\n+        showFreeInteractive = enable;\n+        if (enable) {\n+            diagramChangedEvent.fire();\n+        }\n+    }\n+\n@@ -227,0 +239,1 @@\n+        showFreeInteractive = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.INTERACTIVE_FREE_NODES;\n@@ -269,1 +282,1 @@\n-        if (nodes.size() >= 1) {\n+        if (!nodes.isEmpty()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -179,0 +179,5 @@\n+        JToggleButton freeInteractiveLayoutButton = new JToggleButton(new EnableFreeLayoutAction(this));\n+        freeInteractiveLayoutButton.setSelected(diagramViewModel.getShowFreeInteractive());\n+        layoutButtons.add(freeInteractiveLayoutButton);\n+        toolBar.add(freeInteractiveLayoutButton);\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.actions;\n+\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n+import java.beans.PropertyChangeEvent;\n+\n+public class EnableFreeLayoutAction extends EnableLayoutAction {\n+\n+    public EnableFreeLayoutAction(EditorTopComponent etc) {\n+        super(etc);\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/dynamic.png\";\n+    }\n+\n+    @Override\n+    protected String getDescription() {\n+        return \"Show dynamic free layout\";\n+    }\n+\n+    @Override\n+    public void propertyChange(PropertyChangeEvent evt) {\n+        editor.getModel().setShowFreeInteractive(this.isSelected());\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/EnableFreeLayoutAction.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.hotspot.igv.view.actions.CustomSelectAction;\n@@ -35,0 +34,1 @@\n+import java.awt.geom.CubicCurve2D;\n@@ -41,0 +41,2 @@\n+\n+import com.sun.hotspot.igv.view.actions.CustomSelectAction;\n@@ -73,0 +75,2 @@\n+    private int fromControlYOffset;\n+    private int toControlYOffset;\n@@ -175,0 +179,10 @@\n+    public void setFromControlYOffset(int fromControlYOffset) {\n+        this.fromControlYOffset = fromControlYOffset;\n+        computeClientArea();\n+    }\n+\n+    public void setToControlYOffset(int toControlYOffset) {\n+        this.toControlYOffset = toControlYOffset;\n+        computeClientArea();\n+    }\n+\n@@ -228,1 +242,35 @@\n-        g.drawLine(from.x, from.y, to.x, to.y);\n+        \/\/ Define S-shaped curve with control points\n+        if (fromControlYOffset != 0 && toControlYOffset != 0) {\n+            if (from.y < to.y) { \/\/ non-reversed edges\n+                if (Math.abs(from.x - to.x) > 10) {\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x, from.y + fromControlYOffset,\n+                            to.x, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                } else {\n+                    g.drawLine(from.x, from.y, to.x, to.y);\n+                }\n+            } else {  \/\/ reverse edges\n+                if (from.x - to.x > 0) {\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x - 150, from.y + fromControlYOffset,\n+                            to.x + 150, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                } else {\n+                    \/\/ add x offset\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x + 150, from.y + fromControlYOffset,\n+                            to.x - 150, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                }\n+            }\n+        } else {\n+            \/\/ Fallback to straight line if control points are not set\n+            g.drawLine(from.x, from.y, to.x, to.y);\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/dynamic.png","binary":true,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -292,0 +292,3 @@\n+\n+  \/\/ Check all platforms print this compatibly without leading 0x.\n+  check_format(UINT64_FORMAT_0,        (u8)0x123,         \"0000000000000123\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-vmTestbase\/nsk\/jdi\/VMOutOfMemoryException\/VMOutOfMemoryException001\/VMOutOfMemoryException001.java 8285417 generic-all\n+vmTestbase\/nsk\/jdi\/VMOutOfMemoryException\/VMOutOfMemoryException001\/VMOutOfMemoryException001.java 8347137 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+        \"-XX:-SegmentedCodeCache\",\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @requires os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedTrampolineTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+            \"-Xmx1g\",\n@@ -82,3 +83,3 @@\n-        \/\/ Figure out suitable number of workers (~1 per gig).\n-        int gigsOfAllocation = (int) Math.ceil((double) allocationSize \/ G);\n-        int numWorkers = Math.min(gigsOfAllocation, Runtime.getRuntime().availableProcessors());\n+        \/\/ Figure out suitable number of workers (~1 per 100M).\n+        int allocationChunks = (int) Math.ceil((double) allocationSize \/ (100 * M));\n+        int numWorkers = Math.min(allocationChunks, Runtime.getRuntime().availableProcessors());\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressG1Uncommit.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+\t--add-exports java.base\/jdk.internal.module=ALL-UNNAMED \\\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/Makefile","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-            System.out.println(\"Can't reproduce OOME due to a limit on iterations\/execution time. Test was useless.\"\n+            System.out.println(\"Test resexhausted001: Can't reproduce OOME due to a limit on iterations\/execution time. Test was useless.\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-            System.out.println(\"Can't reproduce OOME due to a limit on iterations\/execution time. Test was useless.\");\n+            System.out.println(\"Test resexhausted002: Can't reproduce OOME due to a limit on iterations\/execution time. Test was useless.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-            System.out.println(\"Can't reproduce OOME due to a limit on iterations\/execution time. Test was useless.\");\n+            System.out.println(\"Test resexhausted003: Can't reproduce OOME due to a limit on iterations\/execution time. Test was useless.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,1 @@\n- *      -Xms64m\n- *      -Xmx64m\n- *      -XX:MaxMetaspaceSize=9m\n- *      -XX:-UseGCOverheadLimit\n+ *      -XX:MaxMetaspaceSize=20m\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted003\/TestDescription.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -586,2 +586,0 @@\n-java\/nio\/channels\/AsynchronousSocketChannel\/StressLoopback.java 8211851 aix-ppc64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347289\n+ * @summary make sure DPS works when non-extractable PRK is provided\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @enablePreview\n+ * @run main\/othervm HKDFDelayedPRK\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFParameters;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+public class HKDFDelayedPRK {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ This is a fake non-extractable key\n+        var prk = new SecretKey() {\n+            @Override\n+            public String getAlgorithm() {\n+                return \"PRK\";\n+            }\n+\n+            @Override\n+            public String getFormat() {\n+                return null;\n+            }\n+\n+            @Override\n+            public byte[] getEncoded() {\n+                return null;\n+            }\n+        };\n+\n+        Security.addProvider(new ProviderImpl());\n+        var kdf = KDF.getInstance(\"HKDF-SHA256\");\n+        kdf.deriveData(HKDFParameterSpec.expandOnly(prk, null, 32));\n+\n+        \/\/ Confirms our own omnipotent impl is selected\n+        Asserts.assertEquals(\"P\", kdf.getProviderName());\n+    }\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"info\");\n+            put(\"KDF.HKDF-SHA256\", KDFImpl.class.getName());\n+        }\n+    }\n+\n+    \/\/ This HKDF impl accepts everything\n+    public static class KDFImpl extends KDFSpi {\n+\n+        public KDFImpl(KDFParameters params) throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+\n+        @Override\n+        protected KDFParameters engineGetParameters() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected SecretKey engineDeriveKey(String alg, AlgorithmParameterSpec dummy) {\n+            return new SecretKeySpec(new byte[32], alg);\n+        }\n+\n+        @Override\n+        protected byte[] engineDeriveData(AlgorithmParameterSpec dummy) {\n+            return new byte[32];\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFDelayedPRK.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    final static ByteBuffer requestBuf = ByteBuffer.allocate(64).put(request.getBytes());\n+    final static ByteBuffer requestBuf = ByteBuffer.wrap(request.getBytes());\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6361557.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,0 +263,1 @@\n+            assertTrue(segment.toString().contains(\"mapped\"));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,0 +237,1 @@\n+            assertFalse(s.contains(\"native\"));\n@@ -239,0 +240,1 @@\n+            assertTrue(s.contains(\"native\"));\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    private static final Pattern DF_PATTERN = Pattern.compile(\"([^\\\\s]+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+\\\\d+%\\\\s+([^\\\\s].*)\\n\");\n+\n@@ -107,2 +109,11 @@\n-            if (getSpace0(name, sizes))\n-                System.err.println(\"WARNING: total space is estimated\");\n+            if (Platform.isWindows() & isCDDrive(name)) {\n+                try {\n+                    getCDDriveSpace(name, sizes);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    throw new RuntimeException(\"can't get CDDrive sizes\");\n+                }\n+            } else {\n+                if (getSpace0(name, sizes))\n+                    System.err.println(\"WARNING: total space is estimated\");\n+            }\n@@ -170,1 +181,2 @@\n-        out.format(fmt, \"getSpace0\", s.total(), s.free(), s.available());\n+        String method = Platform.isWindows() & isCDDrive(s.name()) ? \"getCDDriveSpace\" : \"getSpace0\";\n+        out.format(fmt, method, s.total(), s.free(), s.available());\n@@ -327,1 +339,1 @@\n-        \/\/ returned by File::getXSpace are equivalent to those from getSpace0\n+        \/\/ returned by File::getXSpace are equivalent to those from getSpace0 or getCDDriveSpace\n@@ -400,0 +412,36 @@\n+\n+    private static native boolean isCDDrive(String root);\n+\n+    private static void getCDDriveSpace(String root, long[] sizes)\n+        throws IOException {\n+        String[] cmd = new String[] {\"df\", \"-k\", \"-P\", root};\n+        Process p = Runtime.getRuntime().exec(cmd);\n+        StringBuilder sb = new StringBuilder();\n+\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String s;\n+            int i = 0;\n+            while ((s = in.readLine()) != null) {\n+                \/\/ skip header\n+                if (i++ == 0) continue;\n+                sb.append(s).append(\"\\n\");\n+            }\n+        }\n+        out.println(sb);\n+\n+        Matcher m = DF_PATTERN.matcher(sb);\n+        int j = 0;\n+        while (j < sb.length()) {\n+            if (m.find(j)) {\n+                sizes[0] = Long.parseLong(m.group(2)) * 1024;\n+                sizes[1] = Long.parseLong(m.group(3)) * 1024;\n+                sizes[2] = sizes[0] - sizes[1];\n+                sizes[3] = Long.parseLong(m.group(4)) * 1024;\n+                j = m.end();\n+            } else {\n+                throw new RuntimeException(\"unrecognized df output format: \"\n+                                           + \"charAt(\" + j + \") = '\"\n+                                           + sb.charAt(j) + \"'\");\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/io\/File\/GetXSpace.java","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,0 +162,27 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_GetXSpace_isCDDrive\n+    (JNIEnv *env, jclass cls, jstring root)\n+{\n+#ifdef WINDOWS\n+    const jchar* strchars = (*env)->GetStringChars(env, root, NULL);\n+    if (strchars == NULL) {\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     \"GetStringChars\");\n+        return JNI_FALSE;\n+    }\n+\n+    LPCWSTR path = (LPCWSTR)strchars;\n+    UINT driveType = GetDriveTypeW(path);\n+\n+    (*env)->ReleaseStringChars(env, root, strchars);\n+\n+    if (driveType != DRIVE_CDROM) {\n+        return JNI_FALSE;\n+    }\n+\n+    return JNI_TRUE;\n+#else\n+    return JNI_FALSE;\n+#endif\n+}\n","filename":"test\/jdk\/java\/io\/File\/libGetXSpace.c","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -86,1 +87,1 @@\n-                    Path.of(System.getProperty(\"user.home\"), \".mime.types\");\n+                    Path.of(StaticProperty.userHome(), \".mime.types\");\n@@ -191,1 +192,2 @@\n-        \/\/ extensions with content type that differs on Windows 11+\n+        \/\/ extensions with content type that differs on Windows 11+ and\n+        \/\/ Windows Server 2025\n@@ -193,1 +195,1 @@\n-            (System.getProperty(\"os.name\").endsWith(\"11\") ||\n+            (StaticProperty.osName().matches(\"^.*[11|2025]$\") ||\n","filename":"test\/jdk\/java\/nio\/file\/Files\/probeContentType\/Basic.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-\tsolar87 solar88 solar89 southamerica \\\n-\tbackward\n+\tsouthamerica backward\n","filename":"test\/jdk\/java\/util\/TimeZone\/tools\/share\/Makefile","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.KeyStroke;\n+\n+\/*\n+ * @test\n+ * @bug 8339728\n+ * @summary Tests that JAWS announce the shortcuts for JMenuItems.\n+ * @requires os.family == \"windows\"\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual TestJMenuItemShortcutAccessibility\n+ *\/\n+\n+public class TestJMenuItemShortcutAccessibility {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Start the JAWS application\n+                2. Press Alt + M to open application Menu\n+                3. Navigate the Menu Items by using UP \/ DOWN arrow key\n+                4. Press Pass if you are able to hear correct JAWS announcements\n+                   (JAWS should read full shortcut text and not only the 1st\n+                   character of shortcut text for each menu item) else Fail\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"TestJMenuItemShortcutAccessibility Instruction\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(TestJMenuItemShortcutAccessibility::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JFrame createUI() {\n+        JFrame frame = new JFrame(\"A Frame with Menu\");\n+\n+        JMenuBar menuBar = new JMenuBar();\n+        JMenu menu = new JMenu(\"Menu with shortcuts\");\n+        menu.setMnemonic(KeyEvent.VK_M);\n+        menuBar.add(menu);\n+\n+        KeyStroke keyStroke1 = KeyStroke.getKeyStroke(KeyEvent.VK_F,\n+                InputEvent.CTRL_DOWN_MASK);\n+        KeyStroke keyStroke2 = KeyStroke.getKeyStroke(KeyEvent.VK_2,\n+                InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);\n+        KeyStroke keyStroke3 = KeyStroke.getKeyStroke(KeyEvent.VK_F1,\n+                InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);\n+        KeyStroke keyStroke4 = KeyStroke.getKeyStroke(KeyEvent.VK_COMMA,\n+                InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);\n+        KeyStroke keyStroke5 = KeyStroke.getKeyStroke(KeyEvent.VK_PERIOD,\n+                InputEvent.CTRL_DOWN_MASK | InputEvent.ALT_DOWN_MASK);\n+        KeyStroke keyStroke6 = KeyStroke.getKeyStroke(KeyEvent.VK_TAB,\n+                InputEvent.CTRL_DOWN_MASK);\n+        KeyStroke keyStroke7 = KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,\n+                InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);\n+\n+        JMenuItem menuItem1 = new JMenuItem(\"First Menu Item\");\n+        menuItem1.setAccelerator(keyStroke1);\n+        JMenuItem menuItem2 = new JMenuItem(\"Second Menu Item\");\n+        menuItem2.setAccelerator(keyStroke2);\n+        JMenuItem menuItem3 = new JMenuItem(\"Third Menu Item\");\n+        menuItem3.setAccelerator(keyStroke3);\n+        JMenuItem menuItem4 = new JMenuItem(\"Fourth Menu Item\");\n+        menuItem4.setAccelerator(keyStroke4);\n+        JMenuItem menuItem5 = new JMenuItem(\"Fifth Menu Item\");\n+        menuItem5.setAccelerator(keyStroke5);\n+        JMenuItem menuItem6 = new JMenuItem(\"Sixth Menu Item\");\n+        menuItem6.setAccelerator(keyStroke6);\n+        JMenuItem menuItem7 = new JMenuItem(\"Seventh Menu Item\");\n+        menuItem7.setAccelerator(keyStroke7);\n+\n+        menu.add(menuItem1);\n+        menu.add(menuItem2);\n+        menu.add(menuItem3);\n+        menu.add(menuItem4);\n+        menu.add(menuItem5);\n+        menu.add(menuItem6);\n+        menu.add(menuItem7);\n+\n+        frame.setJMenuBar(menuBar);\n+        frame.setSize(300, 200);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/javax\/accessibility\/TestJMenuItemShortcutAccessibility.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.print.attribute.standard.PageRanges;\n+\n+\/*\n+ * @test\n+ * @bug 4433126 4433096\n+ * @key printer\n+ * @summary  The line \"ERROR: <message>\" should NOT appear.\n+ * @run main PageRangesException\n+ *\/\n+\n+public class PageRangesException {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ test 4433126\n+        try {\n+            PageRanges pr = new PageRanges(\"0:22\");\n+            throw new RuntimeException(\"ERROR: no exceptions\");\n+        } catch (IllegalArgumentException ie) {\n+            System.out.println(\"OKAY: IllegalArgumentException \" + ie);\n+        }\n+\n+        \/\/ test 4433096\n+        try {\n+            int[][] m = null;\n+            PageRanges pr = new PageRanges(m);\n+            throw new RuntimeException(\"ERROR: NullPointerException expected\");\n+        } catch (IllegalArgumentException ie) {\n+            throw new RuntimeException(\"ERROR: IllegalArgumentException\", ie);\n+        } catch (NullPointerException e) {\n+            System.out.println(\"OKAY: NullPointerException\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/print\/attribute\/PageRangesException.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,3 @@\n-        \"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java\"})\n+        \"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/snippet-files\/PackageSnippets.java\",\n+        \"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java\"\n+    })\n","filename":"test\/jdk\/jdk\/classfile\/SnippetsTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 6802846 8172529 8227758 8260960 8345134\n+ * @bug 6802846 8172529 8227758 8260960\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/ConciseJarsigner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * <code>BackEnd<\/code> is an abstract base class for a back-end of compiling\n- * Olson's zoneinfo database and generating Java zoneinfo database.\n- *\n- * @since 1.4\n- *\/\n-abstract class BackEnd {\n-\n-    \/**\n-     * Receives each zone's TimeZone information which was created by\n-     * {@link Zoneinfo#parse} in class <code>Zoneinfo<\/code>,\n-     * and processes it.\n-     *\n-     * @param tz Timezone object for each zone\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    abstract int processZoneinfo(Timezone tz);\n-\n-    \/**\n-     * Receives whole information which is generated by JavaZic's front-end\n-     * in the form of Mapping object and generates all Java zone information\n-     * files.\n-     *\n-     * @param m Mappings object which is generated by\n-     *          {@link Main#compile() Main.compile()}.\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    abstract int generateSrc(Mappings m);\n-\n-    \/**\n-     * Decides which backend class should be used and returns its instance.\n-     * @return an instance of backend class\n-     *\/\n-    static BackEnd getBackEnd() {\n-        if (Zoneinfo.isYearForTimeZoneDataSpecified) {\n-            return new Simple();\n-        } else if (Main.outputDoc) {\n-            return new GenDoc();\n-        } else {\n-            return new Gen();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/BackEnd.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8073446 8262110\n- * @summary Tests DST related beyond the year 2037\n- * @run testng Beyond2037\n- *\/\n-\n-import java.text.SimpleDateFormat;\n-import java.util.TimeZone;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class Beyond2037 {\n-\n-    @DataProvider\n-    Object[][] dstTransition() {\n-        return new Object[][] {\n-            {\"2037\/03\/08 01:59:59:999\", \"2037\/03\/08 01:59:59:999\"},\n-            {\"2037\/03\/08 02:00:00:000\", \"2037\/03\/08 03:00:00:000\"},\n-            {\"2038\/03\/14 01:59:59:999\", \"2038\/03\/14 01:59:59:999\"},\n-            {\"2038\/03\/14 02:00:00:000\", \"2038\/03\/14 03:00:00:000\"},\n-            {\"2099\/03\/08 01:59:59:999\", \"2099\/03\/08 01:59:59:999\"},\n-            {\"2099\/03\/08 02:00:00:000\", \"2099\/03\/08 03:00:00:000\"},\n-            {\"2100\/03\/14 01:59:59:999\", \"2100\/03\/14 01:59:59:999\"},\n-            {\"2100\/03\/14 02:00:00:000\", \"2100\/03\/14 03:00:00:000\"},\n-            {\"8000\/03\/12 01:59:59:999\", \"8000\/03\/12 01:59:59:999\"},\n-            {\"8000\/03\/12 02:00:00:000\", \"8000\/03\/12 03:00:00:000\"},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"dstTransition\")\n-    public void testDstTransition(String source, String expected) throws Exception {\n-        var timeZone = TimeZone.getTimeZone(\"America\/New_York\");\n-        var sdf = new SimpleDateFormat(\"yyyy\/MM\/dd HH:mm:ss:SSS\" );\n-        sdf.setTimeZone(timeZone);\n-        assertEquals(sdf.format(sdf.parse(source)), expected);\n-    }\n-\n-    @Test\n-    public void testGetOffset() throws Exception {\n-        var timeZone = TimeZone.getTimeZone(\"PST8PDT\");\n-        var df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n-        df.setTimeZone(timeZone);\n-        var tMilli = df.parse(\"7681-03-09 03:20:49\").getTime();\n-        assertEquals(timeZone.getOffset(tMilli), -25200000);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Beyond2037.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.zip.CRC32;\n-\n-\/**\n- * Checksum provides methods for calculating a CRC32 value for a\n- * transitions table.\n- *\n- * @since 1.4\n- *\/\n-public class Checksum extends CRC32\n-{\n-    \/**\n-     * Updates the CRC32 value from each byte of the given int\n-     * value. The bytes are used in the big endian order.\n-     * @param val the int value\n-     *\/\n-    public void update(int val) {\n-        byte[] b = new byte[4];\n-        b[0] = (byte)((val >>> 24) & 0xff);\n-        b[1] = (byte)((val >>> 16) & 0xff);\n-        b[2] = (byte)((val >>> 8) & 0xff);\n-        b[3] = (byte)(val & 0xff);\n-        update(b);\n-    }\n-\n-    \/**\n-     * Updates the CRC32 value from each byte of the given long\n-     * value. The bytes are used in the big endian order.\n-     * @param val the long value\n-     *\/\n-    void update(long val) {\n-        byte[] b = new byte[8];\n-        b[0] = (byte)((val >>> 56) & 0xff);\n-        b[1] = (byte)((val >>> 48) & 0xff);\n-        b[2] = (byte)((val >>> 40) & 0xff);\n-        b[3] = (byte)((val >>> 32) & 0xff);\n-        b[4] = (byte)((val >>> 24) & 0xff);\n-        b[5] = (byte)((val >>> 16) & 0xff);\n-        b[6] = (byte)((val >>> 8) & 0xff);\n-        b[7] = (byte)(val & 0xff);\n-        update(b);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Checksum.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Day of week enum.\n- *\n- * @since 1.6\n- *\/\n-\n-enum DayOfWeek {\n-    SUNDAY(\"Sun\"),\n-    MONDAY(\"Mon\"),\n-    TUESDAY(\"Tue\"),\n-    WEDNESDAY(\"Wed\"),\n-    THURSDAY(\"Thu\"),\n-    FRIDAY(\"Fri\"),\n-    SATURDAY(\"Sat\");\n-\n-    private final String abbr;\n-\n-    private DayOfWeek(String abbr) {\n-        this.abbr = abbr;\n-    }\n-\n-    String getAbbr() {\n-        return abbr;\n-    }\n-\n-    int value() {\n-        return ordinal() + 1;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/DayOfWeek.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,342 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.IOException;\n-import  java.io.File;\n-import  java.io.FileOutputStream;\n-import  java.io.DataOutputStream;\n-import  java.io.RandomAccessFile;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-\n-\/**\n- * <code>Gen<\/code> is one of back-end classes of javazic, and generates\n- * ZoneInfoMappings and zone-specific file for each zone.\n- *\/\n-class Gen extends BackEnd {\n-\n-    \/**\n-     * Generates datafile in binary TLV format for each time zone.\n-     * Regarding contents of output files, see {@link ZoneInfoFile}.\n-     *\n-     * @param Timezone\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        try {\n-            int size;\n-            String outputDir = Main.getOutputDir();\n-            String zonefile = ZoneInfoFile.getFileName(tz.getName());\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-\n-            \/* If zonefile includes file-separator, it's treated as part of\n-             * pathname. And make directory if necessary.\n-             *\/\n-            int index = zonefile.lastIndexOf(File.separatorChar);\n-            if (index != -1) {\n-                outputDir += zonefile.substring(0, index+1);\n-            }\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            FileOutputStream fos =\n-                new FileOutputStream(outputDir + zonefile.substring(index+1));\n-            DataOutputStream dos = new DataOutputStream(fos);\n-\n-            \/* Output Label *\/\n-            dos.write(ZoneInfoFile.JAVAZI_LABEL, 0,\n-                      ZoneInfoFile.JAVAZI_LABEL.length);\n-\n-            \/* Output Version of ZoneInfoFile *\/\n-            dos.writeByte(ZoneInfoFile.JAVAZI_VERSION);\n-\n-            List<Long> transitions = tz.getTransitions();\n-            if (transitions != null) {\n-                List<Integer> dstOffsets = tz.getDstOffsets();\n-                List<Integer> offsets = tz.getOffsets();\n-\n-                if ((dstOffsets == null && offsets != null) ||\n-                    (dstOffsets != null && offsets == null)) {\n-                    Main.panic(\"Data not exist. (dstOffsets or offsets)\");\n-                    return 1;\n-                }\n-\n-                \/* Output Transition records *\/\n-                dos.writeByte(ZoneInfoFile.TAG_Transition);\n-                size = transitions.size();\n-                dos.writeShort((size * 8) & 0xFFFF);\n-                int dstoffset;\n-                for (int i = 0; i < size; i++) {\n-                    \/* if DST offset is 0, this means DST isn't used.\n-                     * (NOT: offset's index is 0.)\n-                     *\/\n-                    if ((dstoffset = dstOffsets.get(i).intValue()) == -1) {\n-                        dstoffset = 0;\n-                    }\n-\n-                    dos.writeLong((transitions.get(i).longValue() << 12)\n-                                  | (dstoffset << 4)\n-                                  | offsets.get(i).intValue());\n-\n-                }\n-\n-                \/* Output data for GMTOffset *\/\n-                List<Integer> gmtoffset = tz.getGmtOffsets();\n-                dos.writeByte(ZoneInfoFile.TAG_Offset);\n-                size = gmtoffset.size();\n-                dos.writeShort((size * 4) & 0xFFFF);\n-                for (int i = 0; i < size; i++) {\n-                    dos.writeInt(gmtoffset.get(i));\n-                }\n-            }\n-\n-            \/* Output data for SimpleTimeZone *\/\n-            List<RuleRec> stz = tz.getLastRules();\n-            if (stz != null) {\n-                RuleRec[] rr = new RuleRec[2];\n-                boolean wall = true;\n-\n-                rr[0] = stz.get(0);\n-                rr[1] = stz.get(1);\n-\n-                dos.writeByte(ZoneInfoFile.TAG_SimpleTimeZone);\n-                wall = rr[0].getTime().isWall() && rr[1].getTime().isWall();\n-                if (wall) {\n-                    dos.writeShort(32);\n-                } else {\n-                    dos.writeShort(40);\n-                }\n-\n-                for (int i = 0; i < 2; i++) {\n-                    dos.writeInt(rr[i].getMonthNum() - 1); \/\/ 0-based month number\n-                    dos.writeInt(rr[i].getDay().getDayForSimpleTimeZone());\n-                    dos.writeInt(rr[i].getDay().getDayOfWeekForSimpleTimeZoneInt());\n-                    dos.writeInt((int)rr[i].getTime().getTime());\n-                    if (!wall) {\n-                        dos.writeInt((rr[i].getTime().getType() & 0xFF) - 1);\n-                    }\n-                }\n-            }\n-\n-            \/* Output RawOffset *\/\n-            dos.writeByte(ZoneInfoFile.TAG_RawOffset);\n-            dos.writeShort(4);\n-            dos.writeInt(tz.getRawOffset());\n-\n-            \/* Output willGMTOffsetChange flag *\/\n-            if (tz.willGMTOffsetChange()) {\n-                dos.writeByte(ZoneInfoFile.TAG_GMTOffsetWillChange);\n-                dos.writeShort(1);\n-                dos.writeByte(1);\n-            }\n-\n-            \/* Output LastDSTSaving *\/\n-            dos.writeByte(ZoneInfoFile.TAG_LastDSTSaving);\n-            dos.writeShort(2);\n-            dos.writeShort(tz.getLastDSTSaving()\/1000);\n-\n-            \/* Output checksum *\/\n-            dos.writeByte(ZoneInfoFile.TAG_CRC32);\n-            dos.writeShort(4);\n-            dos.writeInt(tz.getCRC32());\n-\n-            fos.close();\n-            dos.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates ZoneInfoMappings in binary TLV format for each zone.\n-     * Regarding contents of output files, see {@link ZoneInfoFile}.\n-     *\n-     * @param Mappings\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            int index;\n-            int block_size;\n-            int roi_size;\n-            long fp;\n-            String outputDir = Main.getOutputDir();\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* Open ZoneInfoMapping file to write. *\/\n-            RandomAccessFile raf =\n-                new RandomAccessFile(outputDir + ZoneInfoFile.JAVAZM_FILE_NAME, \"rw\");\n-\n-            \/* Whether rawOffsetIndex list exists or not. *\/\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            if (roi == null) {\n-                Main.panic(\"Data not exist. (rawOffsetsIndex)\");\n-                return 1;\n-            }\n-            roi_size = roi.size();\n-\n-            \/* Whether rawOffsetIndexTable list exists or not. *\/\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-            if (roit == null || roit.size() != roi_size) {\n-                Main.panic(\"Data not exist. (rawOffsetsIndexTable) Otherwise, Invalid size\");\n-                return 1;\n-            }\n-\n-            \/* Output Label *\/\n-            raf.write(ZoneInfoFile.JAVAZM_LABEL, 0,\n-                      ZoneInfoFile.JAVAZM_LABEL.length);\n-\n-            \/* Output Version *\/\n-            raf.writeByte(ZoneInfoFile.JAVAZM_VERSION);\n-\n-            index = ZoneInfoFile.JAVAZM_LABEL.length + 2;\n-\n-            \/* Output Version of Olson's tzdata *\/\n-            byte[] b = Main.getVersionName().getBytes(\"UTF-8\");\n-            raf.writeByte(ZoneInfoFile.TAG_TZDataVersion);\n-            raf.writeShort((b.length+1) & 0xFFFF);\n-            raf.write(b);\n-            raf.writeByte(0x00);\n-            index += b.length + 4;\n-\n-            \/* Output ID list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_ZoneIDs);\n-            block_size = 2;\n-            raf.writeShort(block_size & 0xFFFF);\n-            short nID = 0;\n-            raf.writeShort(nID & 0xFFFF);\n-            for (int i = 0; i < roi_size; i++) {\n-                for (String key : roit.get(i)) {\n-                    byte size = (byte)key.getBytes(\"UTF-8\").length;\n-                    raf.writeByte(size & 0xFF);\n-                    raf.write(key.getBytes(\"UTF-8\"), 0, size);\n-                    block_size += 1 + size;\n-                    nID++;\n-                }\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.writeShort(nID & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Output sorted rawOffset list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_RawOffsets);\n-            index += 3 + block_size;\n-            block_size = roi_size * 4;\n-            raf.writeShort(block_size & 0xFFFF);\n-            for (int i = 0; i < roi_size; i++) {\n-                raf.writeInt(Integer.parseInt(roi.get(i).toString()));\n-            }\n-\n-            \/* Output sorted rawOffsetIndex list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_RawOffsetIndices);\n-            index += 3 + block_size;\n-            block_size = 0;\n-            raf.writeShort(block_size & 0xFFFF);\n-            int num;\n-            for (int i = 0; i < roi_size; i++) {\n-                num = roit.get(i).size();\n-                block_size += num;\n-                for (int j = 0; j < num; j++) {\n-                    raf.writeByte(i);\n-                }\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Whether alias list exists or not. *\/\n-            Map<String,String> a = map.getAliases();\n-            if (a == null) {\n-                Main.panic(\"Data not exist. (aliases)\");\n-                return 0;\n-            }\n-\n-            \/* Output ID list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_ZoneAliases);\n-            index += 3 + block_size;\n-            block_size = 2;\n-            raf.writeShort(block_size & 0xFFFF);\n-            raf.writeShort(a.size() & 0xFFFF);\n-            for (String key : a.keySet()) {\n-                String alias = a.get(key);\n-                byte key_size = (byte)key.length();\n-                byte alias_size = (byte)alias.length();\n-                raf.writeByte(key_size & 0xFF);\n-                raf.write(key.getBytes(\"UTF-8\"), 0, key_size);\n-                raf.writeByte(alias_size & 0xFF);\n-                raf.write(alias.getBytes(\"UTF-8\"), 0, alias_size);\n-                block_size += 2 + key_size + alias_size;\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Output the exclude list if it exists. *\/\n-            List<String> excludedZones = map.getExcludeList();\n-            if (excludedZones != null) {\n-                raf.writeByte(ZoneInfoFile.TAG_ExcludedZones);\n-                index += 3 + block_size;\n-                block_size = 2;\n-                raf.writeShort(block_size & 0xFFFF);  \/\/ place holder\n-                raf.writeShort(excludedZones.size()); \/\/ the number of excluded zones\n-                for (String name : excludedZones) {\n-                    byte size = (byte) name.length();\n-                    raf.writeByte(size);                 \/\/ byte length\n-                    raf.write(name.getBytes(\"UTF-8\"), 0, size); \/\/ zone name\n-                    block_size += 1 + size;\n-                }\n-                fp = raf.getFilePointer();\n-                raf.seek(index);\n-                raf.writeShort(block_size & 0xFFFF);\n-                raf.seek(fp);\n-            }\n-\n-            \/* Close ZoneInfoMapping file. *\/\n-            raf.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Gen.java","additions":0,"deletions":342,"binary":false,"changes":342,"status":"deleted"},{"patch":"@@ -1,776 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.BufferedReader;\n-import  java.io.BufferedWriter;\n-import  java.io.File;\n-import  java.io.FileReader;\n-import  java.io.FileWriter;\n-import  java.io.IOException;\n-import  java.util.Date;\n-import  java.util.HashMap;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.SortedMap;\n-import  java.util.StringTokenizer;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>GenDoc<\/code> is one of back-end classes of javazic, and generates\n- * index.html and other html files which prints the detailed time zone\n- * information for each zone.\n- *\/\n-class GenDoc extends BackEnd {\n-\n-    private static final String docDir = \"doc\";\n-\n-    private static final String header1 =\n-        \"<!DOCTYPE HTML PUBLIC \\\"-\/\/W3C\/\/DTD HTML 4.0 Frameset\/\/EN\\\"\" +\n-        \"\\\"http:\/\/www.w3.org\/TR\/REC-html40\/frameset.dtd\\\">\\n\" +\n-        \"<HTML>\\n<HEAD>\\n<!-- Generated by javazic on \";\n-    private static final String header2 =\n-        \"-->\\n<TITLE>\\n\" +\n-        \"Java Platform, Standard Edition - TimeZone information based on \";\n-    private static final String header3 =\n-        \"-->\\n<TITLE>\\n\" +\n-        \"Java Platform, Standard Edition  TimeZone - \";\n-    private static final String header4 =\n-        \"<\/TITLE>\\n\" +\n-        \"<\/HEAD>\\n\\n\";\n-\n-    private static final String body1 =\n-        \"<BODY BGCOLOR=\\\"white\\\">\\n\";\n-    private static final String body2 =\n-        \"<\/BODY>\\n\";\n-\n-    private static final String footer =\n-        \"<\/HTML>\\n\";\n-\n-\n-    \/\/ list of time zone name and zonefile name\/real time zone name\n-    \/\/   e.g.\n-    \/\/      key (String)       : value (String)\n-    \/\/      \"America\/Denver\"   : \"America\/Denver.html\" (real time zone)\n-    \/\/      \"America\/Shiprock\" : \"America\/Denver\"      (alias)\n-    TreeMap<String,String> timezoneList = new TreeMap<String,String>();\n-\n-    \/\/ list of time zone's display name and time zone name\n-    \/\/   e.g.\n-    \/\/      key (String)                : value (String)\n-    \/\/      \"Tokyo, Asia\"               : \"Asia\/Tokyo\"\n-    \/\/      \"Marengo, Indiana, America\" : \"America\/Indiana\/Marengo\"\n-    \/\/          (aliases included)\n-    TreeMap<String,String> displayNameList = new TreeMap<String,String>();\n-\n-    \/\/ list of top level regions\n-    \/\/   e.g.\n-    \/\/      key (String) : value (String)\n-    \/\/      \"America\"    : \"America.html\"\n-    \/\/          (including entries in America\/Indiana\/, America\/Kentucky\/, ...)\n-    TreeMap<String,String> regionList = new TreeMap<String,String>();\n-\n-    \/\/ mapping list from zone name to latitude & longitude\n-    \/\/   This list is generated from zone.tab.\n-    \/\/   e.g.\n-    \/\/      key (String) : value (LatitudeAndLongitude object)\n-    \/\/      \"Asia\/Tokyo\" : latitude=35.3916, longitude=13.9444\n-    \/\/          (aliases not included)\n-    HashMap<String,LatitudeAndLongitude> mapList = null;\n-\n-    \/\/ SortedMap of zone IDs sorted by their GMT offsets. If zone's GMT\n-    \/\/ offset will change in the future, its last known offset is\n-    \/\/ used.\n-    SortedMap<Integer, Set<String>> zonesByOffset = new TreeMap<Integer, Set<String>>();\n-\n-    \/**\n-     * Generates HTML document for each zone.\n-     * @param Timezone\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        try {\n-            int size;\n-            int index;\n-            String outputDir = Main.getOutputDir();\n-            String zonename = tz.getName();\n-            String zonefile = ZoneInfoFile.getFileName(zonename) + \".html\";\n-            List<RuleRec> stz = tz.getLastRules();\n-            timezoneList.put(zonename, zonefile);\n-            displayNameList.put(transform(zonename), zonename);\n-\n-            \/\/ Populate zonesByOffset. (Zones that will change their\n-            \/\/ GMT offsets are also added to zonesByOffset here.)\n-            int lastKnownOffset = tz.getRawOffset();\n-            Set<String> set = zonesByOffset.get(lastKnownOffset);\n-            if (set == null) {\n-                set = new TreeSet<String>();\n-                zonesByOffset.put(lastKnownOffset, set);\n-            }\n-            set.add(zonename);\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-            outputDir += docDir + File.separatorChar;\n-\n-            index = zonename.indexOf('\/');\n-            if (index != -1) {\n-                regionList.put(zonename.substring(0, index),\n-                               zonename.substring(0, index) + \".html\");\n-            }\n-\n-            \/* If zonefile includes file-separator, it's treated as part of\n-             * pathname. And make directory if necessary.\n-             *\/\n-            index = zonefile.lastIndexOf('\/');\n-            if (index != -1) {\n-                zonefile.replace('\/', File.separatorChar);\n-                outputDir += zonefile.substring(0, index+1);\n-            }\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* If mapfile is available, add a link to the appropriate map *\/\n-            if (mapList == null && Main.getMapFile() != null) {\n-                mapList = new HashMap<String, LatitudeAndLongitude>();\n-                FileReader fr = new FileReader(Main.getMapFile());\n-                BufferedReader in = new BufferedReader(fr);\n-                String line;\n-                while ((line = in.readLine()) != null) {\n-                    \/\/ skip blank and comment lines\n-                    if (line.length() == 0 || line.charAt(0) == '#') {\n-                        continue;\n-                    }\n-                    StringTokenizer tokens = new StringTokenizer(line);\n-                    String token = tokens.nextToken();  \/* We don't use the first token. *\/\n-                    token = tokens.nextToken();\n-                    LatitudeAndLongitude location = new LatitudeAndLongitude(token);\n-                    token = tokens.nextToken();\n-                    mapList.put(token, location);\n-                }\n-                in.close();\n-            }\n-\n-            \/* Open zoneinfo file to write. *\/\n-            FileWriter fw = new FileWriter(outputDir + zonefile.substring(index+1));\n-            BufferedWriter out = new BufferedWriter(fw);\n-\n-            out.write(header1 + new Date() + header3 + zonename + header4);\n-            out.write(body1 + \"<FONT size=\\\"+2\\\"><B>\" + zonename + \"<\/B><\/FONT>\");\n-            LatitudeAndLongitude location = (mapList != null ? mapList.get(zonename) : null);\n-            if (location != null) {\n-                int deg, min, sec;\n-\n-                deg = location.getLatDeg();\n-                min = location.getLatMin();\n-                sec = location.getLatSec();\n-                if (deg < 0) {\n-                    min = -min;\n-                    sec = -sec;\n-                } else if (min < 0) {\n-                    sec = -sec;\n-                }\n-                out.write(\"&nbsp;&nbsp;&nbsp;\" +\n-                          \"<A HREF=\\\"http:\/\/www.mapquest.com\/maps\/map.adp?\" +\n-                          \"latlongtype=degrees\" +\n-                          \"&latdeg=\" + deg +\n-                          \"&latmin=\" + min +\n-                          \"&latsec=\" + sec);\n-\n-                deg = location.getLongDeg();\n-                min = location.getLongMin();\n-                sec = location.getLongSec();\n-                if (deg < 0) {\n-                    min = -min;\n-                    sec = -sec;\n-                } else if (min < 0) {\n-                    sec = -sec;\n-                }\n-                out.write(\"&longdeg=\" + deg +\n-                          \"&longmin=\" + min +\n-                          \"&longsec=\" + sec +\n-                          \"\\\" target=\\\"_blank\\\">[map]<\/A>\");\n-            }\n-            out.write(\"\\n<P>\\n\");\n-\n-            List<ZoneRec> zone = tz.getZones();\n-            List<RuleRec> rule = tz.getRules();\n-            if (rule != null && zone != null) {\n-                out.write(\"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"1\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR>\\n\" +\n-                          \"<TD BGCOLOR=\\\"#EEEEFF\\\" WIDTH=\\\"50%\\\" ALIGN=\\\"CENTER\\\"><BR>\" +\n-                          \"<A HREF=\\\"#Rules\\\">Rules<\/A><BR><\/TD>\\n\" +\n-                          \"<TD BGCOLOR=\\\"#EEEEFF\\\" WIDTH=\\\"50%\\\" ALIGN=\\\"CENTER\\\">\" +\n-                          \"<A HREF=\\\"#Zone\\\"><BR>Zone<BR><\/A><\/TD>\\n\" +\n-                          \"<\/TR>\\n<\/TABLE>\\n\");\n-            }\n-\n-            \/* Output Rule records. *\/\n-            if (rule != null) {\n-                size = rule.size();\n-                out.write(\"<P>\\n<A NAME=\\\"Rules\\\">\" +\n-                          \"<FONT SIZE=\\\"+1\\\"><B>Rules<\/B><\/FONT><\/A>\\n\" +\n-                          \"<TABLE BORDER=\\\"1\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"3\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR BGCOLOR=\\\"#CCCCFF\\\">\\n\" +\n-                          \"<TD>NAME<\/TD><TD>FROM<\/TD><TD>TO<\/TD><TD>TYPE<\/TD>\" +\n-                          \"<TD>IN<\/TD><TD>ON<\/TD><TD>AT<\/TD><TD>SAVE<\/TD>\" +\n-                          \"<TD>LETTER\/S<\/TD><TD>NOTES<\/TD>\\n<\/TR>\\n\");\n-                for (int i = 0; i < size; i++) {\n-                    out.write(\"<TR BGCOLOR=\\\"#FFFFFF\\\">\\n\");\n-                    StringTokenizer st = new StringTokenizer(rule.get(i).getLine());\n-                    String s;\n-                    if (st.hasMoreTokens()) {   \/* RULE - truncated *\/\n-                        st.nextToken();\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* NAME *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* FROM *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* TO *\/\n-                        s = st.nextToken();\n-                        if (s.equals(\"min\") || s.equals(\"max\")) {\n-                            out.write(\"<TD><FONT COLOR=\\\"red\\\">\" + s + \"<\/FONT><\/TD>\");\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");\n-                        }\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* TYPE *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* IN *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* ON *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* AT *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* SAVE *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* LETTER\/S *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* NOTES *\/\n-                        s = st.nextToken();\n-                        while (st.hasMoreTokens()) {\n-                            s += \" \" + st.nextToken();\n-                        }\n-                        index = s.indexOf('#');\n-                        out.write(\"<TD>\" + s.substring(index+1) + \"<\/TD>\\n\");\n-                    } else {\n-                        out.write(\"<TD>&nbsp;<\/TD>\\n\");\n-                    }\n-                    out.write(\"<\/TR>\\n\");\n-                }\n-                out.write(\"<\/TABLE>\\n<P>&nbsp;<P>\\n\");\n-            }\n-\n-            \/* Output Zone records. *\/\n-            if (zone != null) {\n-                size = zone.size();\n-                out.write(\"<P>\\n<A NAME=\\\"Zone\\\">\" +\n-                          \"<FONT SIZE=\\\"+1\\\"><B>Zone<\/B><\/FONT><\/A>\\n\" +\n-                          \"<TABLE BORDER=\\\"1\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"3\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR BGCOLOR=\\\"#CCCCFF\\\">\\n<TD>GMTOFF<\/TD>\" +\n-                          \"<TD>RULES<\/TD><TD>FORMAT<\/TD><TD>UNTIL<\/TD>\" +\n-                          \"<TD>NOTES<\/TD>\\n<\/TR>\\n\");\n-                for (int i = 0; i < size; i++) {\n-                    out.write(\"<TR>\\n\");\n-                    StringTokenizer st = new StringTokenizer(zone.get(i).getLine());\n-                    String s = st.nextToken();\n-                    if (s.equals(\"Zone\")) {     \/* NAME *\/\n-                        s = st.nextToken();\n-                        s = st.nextToken();\n-                    }\n-                    out.write(\"<TD>\" + s + \"<\/TD>\");    \/* GMTOFFSET *\/\n-                    if (st.hasMoreTokens()) {   \/* RULES *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* FORMAT *\/\n-                        s = st.nextToken();\n-                        index = s.indexOf('#');\n-                        if (index != -1) {\n-                            if (index != 0) {\n-                                out.write(\"<TD>\" + s.substring(0, index-1) +\n-                                          \"<\/TD>\");     \/* FORMAT *\/\n-                                s = s.substring(index+1);\n-                            } else {\n-                                out.write(\"<TD>&nbsp;<\/TD>\");   \/* FORMAT *\/\n-                            }\n-                            while (st.hasMoreTokens()) {\n-                                s += \" \" + st.nextToken();\n-                            }\n-                            out.write(\"<TD>&nbsp;<\/TD>\");       \/* UNTIL *\/\n-                            out.write(\"<TD>\" + s + \"<\/TD>\\n<\/TR>\\n\");   \/* NOTES *\/\n-                            continue;\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");    \/* FORMAT *\/\n-                        }\n-                    }\n-\n-                    if (st.hasMoreTokens()) {   \/* UNTIL *\/\n-                        s = st.nextToken();\n-                        while (st.hasMoreTokens()) {\n-                            s += \" \" + st.nextToken();\n-                        }\n-                        index = s.indexOf('#');\n-                        if (index != -1) {\n-                            if (index != 0) {\n-                                out.write(\"<TD>\" + s.substring(0, index-1) +\n-                                          \"<\/TD>\");     \/* UNTIL *\/\n-                            } else {\n-                                out.write(\"<TD>&nbsp;<\/TD>\");   \/* UNTIL *\/\n-                            }\n-                            out.write(\"<TD>\" + s.substring(index+1) +\n-                                      \"<\/TD>\\n\");       \/* NOTES *\/\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");    \/* UNTIL *\/\n-                            out.write(\"<TD>&nbsp;<\/TD>\\n\");     \/* NOTES *\/\n-                        }\n-                    } else {\n-                        out.write(\"<TD>&nbsp;<\/TD>\");           \/* UNTIL *\/\n-                        out.write(\"<TD>&nbsp;<\/TD>\\n\");         \/* NOTES *\/\n-                    }\n-                    out.write(\"<\/TR>\\n\");\n-                }\n-                out.write(\"<\/TABLE>\\n\");\n-            }\n-            out.write(body2 + footer);\n-\n-            out.close();\n-            fw.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates index.html and other top-level frame files.\n-     * @param Mappings\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            int len;\n-            Object o[];\n-            String outputDir = Main.getOutputDir();\n-            FileWriter fw1, fw2;\n-            BufferedWriter out1, out2;\n-\n-            \/* Whether alias list exists or not. *\/\n-            Map<String,String> a = map.getAliases();\n-            if (a == null) {\n-                Main.panic(\"Data not exist. (aliases)\");\n-                return 1;\n-            }\n-\n-            timezoneList.putAll(a);\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-            outputDir += docDir + File.separatorChar;\n-\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* Creates index.html *\/\n-            fw1 = new FileWriter(outputDir + \"index.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 +\n-                       \"<FRAMESET cols=\\\"20%,80%\\\">\\n\" +\n-                       \"<FRAMESET rows=\\\"30%,70%\\\">\\n\" +\n-                       \"<FRAME src=\\\"overview-frame.html\\\" name=\\\"TimeZoneListFrame\\\">\\n\" +\n-                       \"<FRAME src=\\\"allTimeZone-frame1.html\\\" name=\\\"allTimeZoneFrame\\\">\\n\" +\n-                       \"<\/FRAMESET>\" +\n-                       \"<FRAME src=\\\"overview-summary.html\\\" name=\\\"rightFrame\\\">\\n\" +\n-                       \"<\/FRAMESET>\\n\" +\n-                       \"<NOFRAMES>\\n\" +\n-                       \"<H2>\\nFrame Alert\\n<\/H2>\\n\\n\" +\n-                       \"<P>\\n\\n\" +\n-                       \"This document is designed to be viewed using the frames feature. If you see this\\n\" +\n-                       \"message, you are using a non-frame-capable web client.\\n\" +\n-                       \"<BR>\\n\" +\n-                       \"Link to<A HREF=\\\"overview-summary.html\\\">Non-frame version.<\/A>\\n\" +\n-                       \"<\/NOFRAMES>\\n\" + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates overview-frame.html *\/\n-            fw1 = new FileWriter(outputDir + \"overview-frame.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n<TR>\\n\" +\n-                       \"<TD NOWRAP><FONT size=\\\"+1\\\">\\n\" +\n-                       \"<B>Java<sup><font size=-2>TM<\/font><\/sup>&nbsp;Platform<br>Standard&nbsp;Ed.<\/B><\/FONT><\/TD>\\n\" +\n-                       \"<\/TR>\\n<\/TABLE>\\n\\n\" +\n-                       \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n<TR>\\n<TD NOWRAP>\" +\n-                       \"<P>\\n<FONT size=\\\"+1\\\">\\nAll Time Zones Sorted By:<\/FONT>\\n<BR>\\n\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame1.html\\\" TARGET=\\\"allTimeZoneFrame\\\">GMT offsets<\/A><\/FONT>\\n<BR>\\n\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame2.html\\\" TARGET=\\\"allTimeZoneFrame\\\">Zone names<\/A><\/FONT>\\n<BR>\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame3.html\\\" TARGET=\\\"allTimeZoneFrame\\\">City names<\/A><\/FONT>\\n\" +\n-                       \"<P>\\n<FONT size=\\\"+1\\\">\\nContinents and Oceans<\/FONT>\\n<BR>\\n\");\n-\n-            for (String regionKey : regionList.keySet()) {\n-                out1.write(\"&nbsp;&nbsp;<A HREF=\\\"\" + regionList.get(regionKey) +\n-                           \"\\\" TARGET=\\\"allTimeZoneFrame\\\">\" + regionKey +\n-                           \"<\/A><BR>\\n\");\n-\n-                fw2 = new FileWriter(outputDir + regionList.get(regionKey),\n-                                     false);\n-                out2 = new BufferedWriter(fw2);\n-\n-                out2.write(header1 + new Date() + header3 + regionKey +\n-                           header4 + body1 + \"<FONT size=\\\"+1\\\"><B>\" +\n-                           regionKey + \"<\/B><\/FONT>\\n<BR>\\n<TABLE>\\n<TR>\\n<TD>\");\n-\n-                boolean found = false;\n-                for (String timezoneKey : timezoneList.keySet()) {\n-                    int regionIndex = timezoneKey.indexOf('\/');\n-                    if (regionIndex == -1 ||\n-                        !regionKey.equals(timezoneKey.substring(0, regionIndex))) {\n-                        if (found) {\n-                            break;\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-\n-                    found = true;\n-                    if (a.containsKey(timezoneKey)) {\n-                        Object realName = a.get(timezoneKey);\n-                        while (a.containsKey(realName)) {\n-                            realName = a.get(realName);\n-                        }\n-                        out2.write(timezoneKey +\n-                                   \" (alias for \" + \"<A HREF=\\\"\" +\n-                                   timezoneList.get(realName) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" +\n-                                   realName + \"<\/A>)\");\n-                    } else {\n-                        out2.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                                   \"<\/A>\");\n-                    }\n-                    out2.write(\"<BR>\\n\");\n-                }\n-                out2.write(\"<\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-                out2.close();\n-                fw2.close();\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR><\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates allTimeZone-frame1.html (Sorted by GMT offsets) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame1.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by GMT offsets<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-\n-            int index = 0;\n-            for (Integer offset : zonesByOffset.keySet()) {\n-                int off = roi.get(index);\n-                Set<String> perRO = zonesByOffset.get(offset);\n-                if (offset == off) {\n-                    \/\/ Merge aliases into zonesByOffset\n-                    perRO.addAll(roit.get(index));\n-                }\n-                index++;\n-\n-                for (String timezoneKey : perRO) {\n-                    out1.write(\"<TR>\\n<TD><FONT SIZE=\\\"-1\\\">(\" +\n-                               Time.toGMTFormat(offset.toString()) +\n-                               \")<\/FONT><\/TD>\\n<TD>\");\n-\n-                    if (a.containsKey(timezoneKey)) {\n-                        Object realName = a.get(timezoneKey);\n-                        while (a.containsKey(realName)) {\n-                            realName = a.get(realName);\n-                        }\n-                        out1.write(timezoneKey +\n-                                   \" (alias for \" + \"<A HREF=\\\"\" +\n-                                   timezoneList.get(realName) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                                   \"<\/A>)\");\n-                    } else {\n-                        out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                                   \"<\/A>\");\n-                    }\n-                    out1.write(\"<\/TD>\\n<\/TR>\\n\");\n-                }\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates allTimeZone-frame2.html (Sorted by zone names) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame2.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by zone names<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-            o = timezoneList.keySet().toArray();\n-            len = timezoneList.size();\n-            for (int i = 0; i < len; i++) {\n-                Object timezoneKey = o[i];\n-                if (a.containsKey(timezoneKey)) {\n-                    Object realName = a.get(timezoneKey);\n-                    while (a.containsKey(realName)) {\n-                        realName = a.get(realName);\n-                    }\n-                    out1.write(timezoneKey +\n-                               \" (alias for \" +\n-                               \"<A HREF=\\\"\" + timezoneList.get(realName) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                               \"<\/A>)\");\n-                } else {\n-                    out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                               \"<\/A>\");\n-                }\n-                out1.write(\"<BR> \\n\");\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-            \/* Creates allTimeZone-frame3.html (Sorted by city names) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame3.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by city names<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-\n-            Set<String> aliasSet = a.keySet();\n-            len = aliasSet.size();\n-            String aliasNames[] = aliasSet.toArray(new String[0]);\n-            for (int i = 0; i < len; i++) {\n-                displayNameList.put(transform(aliasNames[i]),\n-                                    aliasNames[i]);\n-            }\n-\n-            o = displayNameList.keySet().toArray();\n-            len = displayNameList.size();\n-            for (int i = 0; i < len; i++) {\n-                Object displayName = o[i];\n-                Object timezoneKey = displayNameList.get(o[i]);\n-                if (a.containsKey(timezoneKey)) {\n-                    Object realName = a.get(timezoneKey);\n-                    while (a.containsKey(realName)) {\n-                        realName = a.get(realName);\n-                    }\n-                    out1.write(displayName +\n-                               \" (alias for \" +\n-                               \"<A HREF=\\\"\" + timezoneList.get(realName) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                               \"<\/A>)\");\n-                } else {\n-                    out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + displayName +\n-                               \"<\/A>\");\n-                }\n-                out1.write(\"<BR> \\n\");\n-            }\n-\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-            \/* Creates overview-summary.html *\/\n-            fw1 = new FileWriter(outputDir + \"overview-summary.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<p>This is the list of time zones generated from <B>\" +\n-                       Main.getVersionName() + \"<\/B> for Java Platform, \" +\n-                       \"Standard Edition. The source code can be obtained \" +\n-                       \"from ftp site <a href=\\\"ftp:\/\/elsie.nci.nih.gov\/pub\/\\\">\" +\n-                       \"ftp:\/\/elsie.nci.nih.gov\/pub\/<\/a>. A total of <B>\" +\n-                       len +\n-                       \"<\/B> time zones and aliases are supported \" +\n-                       \"in this edition. For the \" +\n-                       \"format of rules and zones, refer to the zic \" +\n-                       \"(zoneinfo compiler) man page on \" +\n-                       \"Solaris or Linux.<\/p>\\n\" +\n-                       \"<p>Note that the time zone data is not \" +\n-                       \"a public interface of the Java Platform. No \" +\n-                       \"applications should rely on the time zone data of \" +\n-                       \"this document. Time zone names and data \" +\n-                       \"may change without any prior notice.<\/p>\\n\" +\n-                       body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    String transform(String s) {\n-        int index = s.lastIndexOf(\"\/\");\n-\n-        \/* If the string doesn't include any delimiter, return *\/\n-        if (index == -1) {\n-            return s;\n-        }\n-\n-        int lastIndex = index;\n-        String str = s.substring(index+1);\n-        do {\n-            index = s.substring(0, lastIndex).lastIndexOf('\/');\n-            str += \", \" + s.substring(index+1, lastIndex);\n-            lastIndex = index;\n-        } while (index > -1);\n-\n-        return str;\n-    }\n-\n-    static class LatitudeAndLongitude {\n-\n-        private int latDeg, latMin, latSec, longDeg, longMin, longSec;\n-\n-        LatitudeAndLongitude(String s) {\n-            try {\n-                \/\/ First of all, check the string has the correct format:\n-                \/\/    either +-DDMM+-DDDMM or +-DDMMSS+-DDDMMSS\n-\n-                if (!s.startsWith(\"+\") && !s.startsWith(\"-\")) {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                int index;\n-                if (((index = s.lastIndexOf(\"+\")) <= 0) &&\n-                    ((index = s.lastIndexOf(\"-\")) <= 0)) {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-\n-                if (index == 5) {\n-                    latDeg = Integer.parseInt(s.substring(1, 3));\n-                    latMin = Integer.parseInt(s.substring(3, 5));\n-                    latSec = 0;\n-                } else if (index == 7) {\n-                    latDeg = Integer.parseInt(s.substring(1, 3));\n-                    latMin = Integer.parseInt(s.substring(3, 5));\n-                    latSec = Integer.parseInt(s.substring(5, 7));\n-                } else {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                if (s.startsWith(\"-\")){\n-                        latDeg = -latDeg;\n-                        latMin = -latMin;\n-                        latSec = -latSec;\n-                }\n-\n-                int len = s.length();\n-                if (index == 5 && len == 11) {\n-                    longDeg = Integer.parseInt(s.substring(index+1, index+4));\n-                    longMin = Integer.parseInt(s.substring(index+4, index+6));\n-                    longSec = 0;\n-                } else if (index == 7 && len == 15) {\n-                    longDeg = Integer.parseInt(s.substring(index+1, index+4));\n-                    longMin = Integer.parseInt(s.substring(index+4, index+6));\n-                    longSec = Integer.parseInt(s.substring(index+6, index+8));\n-                } else {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                if (s.charAt(index) == '-'){\n-                        longDeg = -longDeg;\n-                        longMin = -longMin;\n-                        longSec = -longSec;\n-                }\n-            } catch(Exception e) {\n-                Main.warning(\"LatitudeAndLongitude() Parse error: \" + s);\n-            }\n-        }\n-\n-        int getLatDeg() {\n-            return latDeg;\n-        }\n-\n-        int getLatMin() {\n-            return latMin;\n-        }\n-\n-        int getLatSec() {\n-            return latSec;\n-        }\n-\n-        int getLongDeg() {\n-            return longDeg;\n-        }\n-\n-        int getLongMin() {\n-            return longMin;\n-        }\n-\n-        int getLongSec() {\n-            return longSec;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/GenDoc.java","additions":0,"deletions":776,"binary":false,"changes":776,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Main class for the javazic time zone data compiler.\n- *\n- * @since 1.4\n- *\/\n-public class Main {\n-\n-    private static boolean verbose = false;\n-    static boolean outputDoc = false;\n-\n-    private List<String> ziFiles = new ArrayList<String>();\n-    private static String zoneNamesFile = null;\n-    private static String versionName = \"unknown\";\n-    private static String outputDir = \"zoneinfo\";\n-    private static String mapFile = null;\n-\n-    \/**\n-     * Parses the specified arguments and sets up the variables.\n-     * @param argv the arguments\n-     *\/\n-    void processArgs(String[] argv) {\n-        for (int i = 0; i < argv.length; i++) {\n-            String arg = argv[i];\n-            if (arg.startsWith(\"-h\")) {\n-                usage();\n-                System.exit(0);\n-            } else if (arg.equals(\"-d\")) {\n-                outputDir = argv[++i];\n-            } else if (arg.equals(\"-v\")) {\n-                verbose = true;\n-            } else if (arg.equals(\"-V\")) {\n-                versionName = argv[++i];\n-            } else if (arg.equals(\"-doc\")) {\n-                outputDoc = true;\n-            } else if (arg.equals(\"-map\")) {\n-                outputDoc = true;\n-                mapFile = argv[++i];\n-            } else if (arg.equals(\"-f\")) {\n-                zoneNamesFile = argv[++i];\n-            } else if (arg.equals(\"-S\")) {\n-                try {\n-                    Zoneinfo.setYear(Integer.parseInt(argv[++i]));\n-                } catch (Exception e) {\n-                    error(\"invalid year: \" + argv[i]);\n-                    usage();\n-                    System.exit(1);\n-                }\n-            } else {\n-                boolean isStartYear = arg.equals(\"-s\");\n-                if (isStartYear || arg.equals(\"-e\")) {\n-                    try {\n-                        int year = Integer.parseInt(argv[++i]);\n-                        if (isStartYear) {\n-                            Zoneinfo.setStartYear(year);\n-                        } else {\n-                            Zoneinfo.setEndYear(year);\n-                        }\n-                    } catch (Exception e) {\n-                        error(\"invalid year: \" + argv[i]);\n-                        usage();\n-                        System.exit(1);\n-                    }\n-                } else {\n-                    \/\/ the rest of args are zoneinfo source files\n-                    while (i < argv.length) {\n-                        ziFiles.add(argv[i++]);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Parses zoneinfo source files\n-     *\/\n-    int compile() {\n-        int nFiles = ziFiles.size();\n-        int status = 0;\n-        Mappings maps = new Mappings();\n-        BackEnd backend = BackEnd.getBackEnd();\n-\n-        for (int i = 0; i < nFiles; i++) {\n-            Zoneinfo frontend = Zoneinfo.parse(ziFiles.get(i));\n-\n-            for (String key : frontend.getZones().keySet()) {\n-                info(key);\n-\n-                Timezone tz = frontend.phase2(key);\n-                status |= backend.processZoneinfo(tz);\n-            }\n-\n-            maps.add(frontend);\n-        }\n-\n-        \/\/ special code for dealing with the conflicting name \"MET\"\n-        Zone.addMET();\n-\n-        maps.resolve();\n-\n-        status |= backend.generateSrc(maps);\n-\n-        return status;\n-    }\n-\n-    public static void main(String[] argv) {\n-        Main zic = new Main();\n-\n-        \/*\n-         * Parse args\n-         *\/\n-        zic.processArgs(argv);\n-\n-        \/*\n-         * Read target zone names\n-         *\/\n-        if (zoneNamesFile != null) {\n-            Zone.readZoneNames(zoneNamesFile);\n-        }\n-\n-        zic.compile();\n-    }\n-\n-    void usage() {\n-        System.err.println(\"Usage: javazic [options] file...\\n\"+\n-                           \"         -f namefile  file containing zone names\\n\"+\n-                           \"                      to be generated (ie, generating subset)\\n\"+\n-                           \"         -d dir       output directory\\n\"+\n-                           \"         -v           verbose\\n\"+\n-                           \"         -V datavers  specifies the tzdata version string\\n\"+\n-                           \"                      (eg, \\\"tzdata2000g\\\")\"+\n-                           \"         -S year      output only SimleTimeZone data of that year\\n\"+\n-                           \"         -s year      start year (default: 1900)\\n\"+\n-                           \"         -e year      end year (default: 2037)\\n\"+\n-                           \"         -doc         generates HTML documents\\n\"+\n-                           \"         -map mapfile generates HTML documents with map information\\n\"+\n-                           \"         file...      zoneinfo source file(s)\");\n-    }\n-\n-    \/**\n-     * @return the output directory path name\n-     *\/\n-    static String getOutputDir() {\n-        return outputDir;\n-    }\n-\n-    \/**\n-     * @return the map file's path and name\n-     *\/\n-    static String getMapFile() {\n-        return mapFile;\n-    }\n-\n-    \/**\n-     * Returns the time zone data version string specified by the -V\n-     * option. If it is not specified, \"unknown\" is returned.\n-     * @return the time zone data version string\n-     *\/\n-    static String getVersionName() {\n-        return versionName;\n-    }\n-\n-    \/**\n-     * Prints out the specified fatal error message and calls {@link\n-     * java.lang.System#exit System.exit(1)}.\n-     * @param msg the fatal error message\n-     *\/\n-    static void panic(String msg) {\n-        printMessage(\"fatal error\", msg);\n-        System.exit(1);\n-    }\n-\n-    \/**\n-     * Prints out the specified error message.\n-     * @param msg the error message\n-     *\/\n-    static void error(String msg) {\n-        printMessage(\"error\", msg);\n-    }\n-\n-    \/**\n-     * Prints out the specified warning message.\n-     * @param msg the warning message\n-     *\/\n-    static void warning(String msg) {\n-        printMessage(\"warning\", msg);\n-    }\n-\n-    \/**\n-     * Prints out the informative message.\n-     * @param msg the informative message\n-     *\/\n-    static void info(String msg) {\n-        if (verbose) {\n-            printMessage(null, msg);\n-        }\n-    }\n-\n-    private static void printMessage(String type, String msg) {\n-        if (type != null) {\n-            type += \": \";\n-        } else {\n-            type = \"\";\n-        }\n-        System.err.println(\"javazic: \" + type + msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Main.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,193 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.util.ArrayList;\n-import  java.util.HashMap;\n-import  java.util.LinkedList;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>Mappings<\/code> generates two Maps and a List which are used by\n- * javazic BackEnd.\n- *\n- * @since 1.4\n- *\/\n-class Mappings {\n-    \/\/ All aliases specified by Link statements. It's alias name to\n-    \/\/ real name mappings.\n-    private Map<String,String> aliases;\n-\n-    private List<Integer> rawOffsetsIndex;\n-\n-    private List<Set<String>> rawOffsetsIndexTable;\n-\n-    \/\/ Zone names to be excluded from rawOffset table. Those have GMT\n-    \/\/ offsets to change some future time.\n-    private List<String> excludeList;\n-\n-    \/**\n-     * Constructor creates some necessary instances.\n-     *\/\n-    Mappings() {\n-        aliases = new TreeMap<String,String>();\n-        rawOffsetsIndex = new LinkedList<Integer>();\n-        rawOffsetsIndexTable = new LinkedList<Set<String>>();\n-    }\n-\n-    \/**\n-     * Generates aliases and rawOffsets tables.\n-     * @param zi a Zoneinfo containing Zones\n-     *\/\n-    void add(Zoneinfo zi) {\n-        Map<String,Zone> zones = zi.getZones();\n-\n-        for (String zoneName : zones.keySet()) {\n-            Zone zone = zones.get(zoneName);\n-            String zonename = zone.getName();\n-            int rawOffset = zone.get(zone.size()-1).getGmtOffset();\n-\n-            \/\/ If the GMT offset of this Zone will change in some\n-            \/\/ future time, this Zone is added to the exclude list.\n-            boolean isExcluded = false;\n-            for (int i = 0; i < zone.size(); i++) {\n-                ZoneRec zrec = zone.get(i);\n-                if ((zrec.getGmtOffset() != rawOffset)\n-                    && (zrec.getUntilTime(0) > Time.getCurrentTime())) {\n-                    if (excludeList == null) {\n-                        excludeList = new ArrayList<String>();\n-                    }\n-                    excludeList.add(zone.getName());\n-                    isExcluded = true;\n-                    break;\n-                }\n-            }\n-\n-            if (!rawOffsetsIndex.contains(new Integer(rawOffset))) {\n-                \/\/ Find the index to insert this raw offset zones\n-                int n = rawOffsetsIndex.size();\n-                int i;\n-                for (i = 0; i < n; i++) {\n-                    if (rawOffsetsIndex.get(i) > rawOffset) {\n-                        break;\n-                    }\n-                }\n-                rawOffsetsIndex.add(i, rawOffset);\n-\n-                Set<String> perRawOffset = new TreeSet<String>();\n-                if (!isExcluded) {\n-                    perRawOffset.add(zonename);\n-                }\n-                rawOffsetsIndexTable.add(i, perRawOffset);\n-            } else if (!isExcluded) {\n-                int i = rawOffsetsIndex.indexOf(new Integer(rawOffset));\n-                Set<String> perRawOffset = rawOffsetsIndexTable.get(i);\n-                perRawOffset.add(zonename);\n-            }\n-        }\n-\n-        Map<String,String> a = zi.getAliases();\n-        \/\/ If there are time zone names which refer to any of the\n-        \/\/ excluded zones, add those names to the excluded list.\n-        if (excludeList != null) {\n-            for (String zoneName : a.keySet()) {\n-                String realname = a.get(zoneName);\n-                if (excludeList.contains(realname)) {\n-                    excludeList.add(zoneName);\n-                }\n-            }\n-        }\n-        aliases.putAll(a);\n-    }\n-\n-    \/**\n-     * Adds valid aliases to one of per-RawOffset table and removes\n-     * invalid aliases from aliases List. Aliases referring to\n-     * excluded zones are not added to a per-RawOffset table.\n-     *\/\n-    void resolve() {\n-        int index = rawOffsetsIndexTable.size();\n-        List<String> toBeRemoved = new ArrayList<String>();\n-        for (String key : aliases.keySet()) {\n-            boolean validname = false;\n-            for (int j = 0; j < index; j++) {\n-                Set<String> perRO = rawOffsetsIndexTable.get(j);\n-                boolean isExcluded = (excludeList == null) ?\n-                                        false : excludeList.contains(key);\n-\n-                if ((perRO.contains(aliases.get(key)) || isExcluded)\n-                    && Zone.isTargetZone(key)) {\n-                    validname = true;\n-                    if (!isExcluded) {\n-                        perRO.add(key);\n-                        Main.info(\"Alias <\"+key+\"> added to the list.\");\n-                    }\n-                    break;\n-                }\n-            }\n-\n-            if (!validname) {\n-                Main.info(\"Alias <\"+key+\"> removed from the list.\");\n-                toBeRemoved.add(key);\n-            }\n-        }\n-\n-        \/\/ Remove zones, if any, from the list.\n-        for (String key : toBeRemoved) {\n-            aliases.remove(key);\n-        }\n-        \/\/ Eliminate any alias-to-alias mappings. For example, if\n-        \/\/ there are A->B and B->C, A->B is changed to A->C.\n-        Map<String, String> newMap = new HashMap<String, String>();\n-        for (String key : aliases.keySet()) {\n-            String realid = aliases.get(key);\n-            String leaf = realid;\n-            while (aliases.get(leaf) != null) {\n-                leaf = aliases.get(leaf);\n-            }\n-            if (!realid.equals(leaf)) {\n-                newMap.put(key, leaf);\n-            }\n-        }\n-        aliases.putAll(newMap);\n-    }\n-\n-    Map<String,String> getAliases() {\n-        return(aliases);\n-    }\n-\n-    List<Integer> getRawOffsetsIndex() {\n-        return(rawOffsetsIndex);\n-    }\n-\n-    List<Set<String>> getRawOffsetsIndexTable() {\n-        return(rawOffsetsIndexTable);\n-    }\n-\n-    List<String> getExcludeList() {\n-        return excludeList;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Mappings.java","additions":0,"deletions":193,"binary":false,"changes":193,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Month enum handles month related manipulation.\n- *\n- * @since 1.4\n- *\/\n-enum Month {\n-    JANUARY(\"Jan\"),\n-    FEBRUARY(\"Feb\"),\n-    MARCH(\"Mar\"),\n-    APRIL(\"Apr\"),\n-    MAY(\"May\"),\n-    JUNE(\"Jun\"),\n-    JULY(\"Jul\"),\n-    AUGUST(\"Aug\"),\n-    SEPTEMBER(\"Sep\"),\n-    OCTOBER(\"Oct\"),\n-    NOVEMBER(\"Nov\"),\n-    DECEMBER(\"Dec\");\n-\n-    private final String abbr;\n-\n-    private Month(String abbr) {\n-        this.abbr = abbr;\n-    }\n-\n-    int value() {\n-        return ordinal() + 1;\n-    }\n-\n-    \/**\n-     * Parses the specified string as a month abbreviation.\n-     * @param name the month abbreviation\n-     * @return the Month value\n-     *\/\n-    static Month parse(String name) {\n-        int len = name.length();\n-\n-        if (name.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n-        if (name.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n-        if (name.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n-        if (name.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n-        if (name.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n-        if (name.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n-        if (name.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n-        if (name.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n-        if (name.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n-        if (name.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n-        if (name.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n-        if (name.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n-\n-        throw new IllegalArgumentException(\"Unknown month: \" + name);\n-    }\n-\n-    \/**\n-     * @param month the nunmth number (1-based)\n-     * @return the month name in uppercase of the specified month\n-     *\/\n-    static String toString(int month) {\n-        if (month >= JANUARY.value() && month <= DECEMBER.value()) {\n-            return \"Calendar.\" + Month.values()[month - 1];\n-        }\n-        throw new IllegalArgumentException(\"wrong month number: \" + month);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Month.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Rule manipulates Rule records.\n- *\n- * @since 1.4\n- *\/\n-class Rule {\n-\n-    private List<RuleRec> list;\n-    private String name;\n-\n-    \/**\n-     * Constructs a Rule which consists of a Rule record list. The\n-     * specified name is given to this Rule.\n-     * @param name the Rule name\n-     *\/\n-    Rule(String name) {\n-        this.name = name;\n-        list = new ArrayList<RuleRec>();\n-    }\n-\n-    \/**\n-     * Added a RuleRec to the Rule record list.\n-     *\/\n-    void add(RuleRec rec) {\n-        list.add(rec);\n-    }\n-\n-    \/**\n-     * @return the Rule name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Gets all rule records that cover the given year.\n-     *\n-     * @param year the year number for which the rule is applicable.\n-     * @return rules in List that are collated in time. If no rule is found, an empty\n-     * List is returned.\n-     *\/\n-    List<RuleRec> getRules(int year) {\n-        List<RuleRec> rules = new ArrayList<RuleRec>(3);\n-        for (RuleRec rec : list) {\n-            if (year >= rec.getFromYear() && year <= rec.getToYear()) {\n-                if ((rec.isOdd() && year % 2 == 0) || (rec.isEven() && year % 2 == 1))\n-                    continue;\n-                rules.add(rec);\n-            }\n-        }\n-        int n = rules.size();\n-        if (n <= 1) {\n-            return rules;\n-        }\n-        if (n == 2) {\n-            RuleRec rec1 = rules.get(0);\n-            RuleRec rec2 = rules.get(1);\n-            if (rec1.getMonthNum() > rec2.getMonthNum()) {\n-                rules.set(0, rec2);\n-                rules.set(1, rec1);\n-            } else if (rec1.getMonthNum() == rec2.getMonthNum()) {\n-                \/\/ TODO: it's not accurate to ignore time types (STD, WALL, UTC)\n-                long t1 = Time.getLocalTime(year, rec1.getMonth(),\n-                                            rec1.getDay(), rec1.getTime().getTime());\n-                long t2 = Time.getLocalTime(year, rec2.getMonth(),\n-                                            rec2.getDay(), rec2.getTime().getTime());\n-                if (t1 > t2) {\n-                    rules.set(0, rec2);\n-                    rules.set(1, rec1);\n-                }\n-            }\n-            return rules;\n-        }\n-\n-        final int y = year;\n-        RuleRec[] recs = new RuleRec[rules.size()];\n-        rules.toArray(recs);\n-\n-        Arrays.sort(recs, new Comparator<RuleRec>() {\n-                public int compare(RuleRec r1, RuleRec r2) {\n-                    int n = r1.getMonthNum() - r2.getMonthNum();\n-                    if (n != 0) {\n-                        return n;\n-                    }\n-                    \/\/ TODO: it's not accurate to ignore time types (STD, WALL, UTC)\n-                    long t1 = Time.getLocalTime(y, r1.getMonth(),\n-                                                r1.getDay(), r1.getTime().getTime());\n-                    long t2 = Time.getLocalTime(y, r2.getMonth(),\n-                                                r2.getDay(), r2.getTime().getTime());\n-                    return Long.compare(t1, t2);\n-                }\n-                public boolean equals(Object o) {\n-                    return this == o;\n-                }\n-            });\n-        rules.clear();\n-        for (int i = 0; i < n; i++) {\n-            if (i != 0 && recs[i -1].getSave() == recs[i].getSave()) {\n-                \/\/ we have two recs back to back with same saving for the same year.\n-                if (recs[i].isLastRule()) {\n-                    continue;\n-                } else if (recs[i - 1].isLastRule()) {\n-                    rules.remove(rules.size() - 1);\n-                }\n-            }\n-            rules.add(recs[i]);\n-        }\n-        return rules;\n-    }\n-\n-    \/**\n-     * Gets rule records that have either \"max\" or cover the endYear\n-     * value in its DST schedule.\n-     *\n-     * @return rules that contain last DST schedule. An empty\n-     * ArrayList is returned if no last rules are found.\n-     *\/\n-    List<RuleRec> getLastRules() {\n-        RuleRec start = null;\n-        RuleRec end = null;\n-\n-        for (int i = 0; i < list.size(); i++) {\n-            RuleRec rec = list.get(i);\n-            if (rec.isLastRule()) {\n-                if (rec.getSave() > 0) {\n-                    start = rec;\n-                } else {\n-                    end = rec;\n-                }\n-            }\n-        }\n-        if (start == null || end == null) {\n-            int endYear = Zoneinfo.getEndYear();\n-            for (int i  = 0; i < list.size(); i++) {\n-                RuleRec rec = list.get(i);\n-                if (endYear >= rec.getFromYear() && endYear <= rec.getToYear()) {\n-                    if (start == null && rec.getSave() > 0) {\n-                        start = rec;\n-                    } else {\n-                        if (end == null && rec.getSave() == 0) {\n-                            end = rec;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        List<RuleRec> r = new ArrayList<RuleRec>(2);\n-        if (start == null || end == null) {\n-            if (start != null || end != null) {\n-                Main.warning(\"found last rules for \"+name+\" inconsistent.\");\n-            }\n-            return r;\n-        }\n-\n-        r.add(start);\n-        r.add(end);\n-        return r;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Rule.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * RuleDay class represents the value of the \"ON\" field.  The day of\n- * week values start from 1 following the {@link java.util.Calendar}\n- * convention.\n- *\n- * @since 1.4\n- *\/\n-class RuleDay {\n-    private String dayName = null;\n-    private DayOfWeek dow;\n-    private boolean lastOne = false;\n-    private int soonerOrLater = 0;\n-    private int thanDayOfMonth; \/\/ day of month (e.g., 8 for \"Sun>=8\")\n-\n-    RuleDay() {\n-    }\n-\n-    RuleDay(int day) {\n-        thanDayOfMonth = day;\n-    }\n-\n-    int getDay() {\n-        return thanDayOfMonth;\n-    }\n-\n-    \/**\n-     * @return the day of week value (1-based)\n-     *\/\n-    int getDayOfWeekNum() {\n-        return dow.value();\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the last day of\n-     * week. (e.g., lastSun).\n-     *\/\n-    boolean isLast() {\n-        return lastOne;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the day of week on or\n-     * later than (after) the {@link #getDay}. (e.g., Sun>=1)\n-     *\/\n-    boolean isLater() {\n-        return soonerOrLater > 0;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the day of week on or\n-     * earlier than (before) the {@link #getDay}. (e.g., Sun<=15)\n-     *\/\n-    boolean isEarlier() {\n-        return soonerOrLater < 0;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents an exact day.\n-     *\/\n-    boolean isExact() {\n-        return soonerOrLater == 0;\n-    }\n-\n-    \/**\n-     * Parses the \"ON\" field and constructs a RuleDay.\n-     * @param day an \"ON\" field string (e.g., \"Sun>=1\")\n-     * @return a RuleDay representing the given \"ON\" field\n-     *\/\n-    static RuleDay parse(String day) {\n-        RuleDay d = new RuleDay();\n-        if (day.startsWith(\"last\")) {\n-            d.lastOne = true;\n-            d.dayName = day.substring(4);\n-            d.dow = getDOW(d.dayName);\n-        } else {\n-            int index;\n-            if ((index = day.indexOf(\">=\")) != -1) {\n-                d.dayName = day.substring(0, index);\n-                d.dow = getDOW(d.dayName);\n-                d.soonerOrLater = 1; \/\/ greater or equal\n-                d.thanDayOfMonth = Integer.parseInt(day.substring(index+2));\n-            } else if ((index = day.indexOf(\"<=\")) != -1) {\n-                d.dayName = day.substring(0, index);\n-                d.dow = getDOW(d.dayName);\n-                d.soonerOrLater = -1; \/\/ less or equal\n-                d.thanDayOfMonth = Integer.parseInt(day.substring(index+2));\n-            } else {\n-                \/\/ it should be an integer value.\n-                d.thanDayOfMonth = Integer.parseInt(day);\n-            }\n-        }\n-        return d;\n-    }\n-\n-    \/**\n-     * Converts this RuleDay to the SimpleTimeZone day rule.\n-     * @return the converted SimpleTimeZone day rule\n-     *\/\n-    int getDayForSimpleTimeZone() {\n-        if (isLast()) {\n-            return -1;\n-        }\n-        return isEarlier() ? -getDay() : getDay();\n-    }\n-\n-    \/**\n-     * Converts this RuleDay to the SimpleTimeZone day-of-week rule.\n-     * @return the SimpleTimeZone day-of-week rule value\n-     *\/\n-    int getDayOfWeekForSimpleTimeZoneInt() {\n-        if (isEarlier() || isLater()) {\n-            return -getDayOfWeekNum();\n-        }\n-        return isLast() ? getDayOfWeekNum() : 0;\n-    }\n-\n-    \/**\n-     * @return the string representation of the {@link\n-     * #getDayOfWeekForSimpleTimeZoneInt} value\n-     *\/\n-    String getDayOfWeekForSimpleTimeZone() {\n-        int d = getDayOfWeekForSimpleTimeZoneInt();\n-        if (d == 0) {\n-            return \"0\";\n-        }\n-        String sign = \"\";\n-        if (d < 0) {\n-            sign = \"-\";\n-            d = -d;\n-        }\n-        return sign + toString(d);\n-    }\n-\n-    private static DayOfWeek getDOW(String name) {\n-        int len = name.length();\n-\n-        if (name.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n-        if (name.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n-        if (name.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n-        if (name.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n-        if (name.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n-        if (name.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n-        if (name.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n-\n-        throw new IllegalArgumentException(\"Unknown day-of-week: \" + name);\n-    }\n-\n-    \/**\n-     * Converts the specified day of week value to the day-of-week\n-     * name defined in {@link java.util.Calendar}.\n-     * @param dow 1-based day of week value\n-     * @return the Calendar day of week name with \"Calendar.\" prefix.\n-     * @throws IllegalArgumentException if the specified dow value is out of range.\n-     *\/\n-    static String toString(int dow) {\n-        if (dow >= DayOfWeek.SUNDAY.value() && dow <= DayOfWeek.SATURDAY.value()) {\n-            return \"Calendar.\" + DayOfWeek.values()[dow - 1];\n-        }\n-        throw new IllegalArgumentException(\"wrong Day_of_Week number: \" + dow);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleDay.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.StringTokenizer;\n-\n-\/**\n- * RuleRec class represents one record of the Rule set.\n- *\n- * @since 1.4\n- *\/\n-class RuleRec {\n-    private int fromYear;\n-    private int toYear;\n-    private String type;\n-    private Month inMonth;\n-    private RuleDay onDay;\n-    private Time atTime;\n-    private int save;\n-    private String letters;\n-    private String line;\n-    private boolean isLastRule;\n-\n-    int getFromYear() {\n-        return fromYear;\n-    }\n-\n-    int getToYear() {\n-        return toYear;\n-    }\n-\n-    Month getMonth() {\n-        return inMonth;\n-    }\n-\n-    int getMonthNum() {\n-        return inMonth.value();\n-    }\n-\n-    RuleDay getDay() {\n-        return onDay;\n-    }\n-\n-    Time getTime() {\n-        return atTime;\n-    }\n-\n-    int getSave() {\n-        return save;\n-    }\n-\n-    String getLine() {\n-        return line;\n-    }\n-\n-    \/**\n-     * Sets the line from the text file.\n-     * @param line the text of the line\n-     *\/\n-    void setLine(String line) {\n-        this.line = line;\n-    }\n-\n-    \/**\n-     * @return true if the rule type is \"odd\".\n-     *\/\n-    boolean isOdd() {\n-        return \"odd\".equals(type);\n-    }\n-\n-    \/**\n-     * @return true if the rule type is \"even\".\n-     *\/\n-    boolean isEven() {\n-        return \"even\".equals(type);\n-    }\n-\n-    \/**\n-     * Determines if this rule record is the last DST schedule rule.\n-     *\n-     * @return true if this rule record has \"max\" as TO (year).\n-     *\/\n-    boolean isLastRule() {\n-        return isLastRule;\n-    }\n-\n-    \/**\n-     * Determines if the unadjusted until time of the specified ZoneRec\n-     * is the same as the transition time of this rule in the same\n-     * year as the ZoneRec until year.\n-     *\n-     * @param zrec ZoneRec to compare to\n-     * @param save the amount of daylight saving in milliseconds\n-     * @param gmtOffset the GMT offset value in milliseconds\n-     * @return true if the unadjusted until time is the same as rule's\n-     * transition time.\n-     *\/\n-    boolean isSameTransition(ZoneRec zrec, int save, int gmtOffset) {\n-        long    until, transition;\n-\n-        if (zrec.getUntilTime().getType() != atTime.getType()) {\n-            until = zrec.getLocalUntilTime(save, gmtOffset);\n-            transition = Time.getLocalTime(zrec.getUntilYear(),\n-                                           getMonth(),\n-                                           getDay(),\n-                                           save,\n-                                           gmtOffset,\n-                                           atTime);\n-        } else {\n-            until = zrec.getLocalUntilTime();\n-            transition = Time.getLocalTime(zrec.getUntilYear(),\n-                                           getMonth(),\n-                                           getDay(),\n-                                           atTime.getTime());\n-        }\n-\n-        return until == transition;\n-    }\n-\n-    \/**\n-     * Parses a Rule line and returns a RuleRec object.\n-     *\n-     * @param tokens a StringTokenizer object that should contain a\n-     * token for the \"FROM\" field and the rest.\n-     * @return a RuleRec object.\n-     *\/\n-    static RuleRec parse(StringTokenizer tokens) {\n-        RuleRec rec = new RuleRec();\n-        try {\n-            \/\/ FROM\n-            String token = tokens.nextToken();\n-            try {\n-                rec.fromYear = Integer.parseInt(token);\n-            } catch (NumberFormatException e) {\n-                \/\/ it's not integer\n-                if (\"min\".equals(token) || \"minimum\".equals(token)) {\n-                    rec.fromYear = Zoneinfo.getMinYear();\n-                } else if (\"max\".equals(token) || \"maximum\".equals(token)) {\n-                    rec.fromYear = Zoneinfo.getMaxYear();\n-                } else {\n-                    Main.panic(\"invalid year value: \"+token);\n-                }\n-            }\n-\n-            \/\/ TO\n-            token = tokens.nextToken();\n-            rec.isLastRule = false;\n-            try {\n-                rec.toYear = Integer.parseInt(token);\n-            } catch (NumberFormatException e) {\n-                \/\/ it's not integer\n-                int len = token.length();\n-                if (token.regionMatches(true, 0, \"minimum\", 0, len)) {\n-                    rec.fromYear = Zoneinfo.getMinYear();\n-                } else if (token.regionMatches(true, 0, \"maximum\", 0, len)) {\n-                    rec.toYear = Integer.MAX_VALUE;\n-                    rec.isLastRule = true;\n-                } else if (token.regionMatches(true, 0, \"only\", 0, len)) {\n-                    rec.toYear = rec.fromYear;\n-                } else {\n-                    Main.panic(\"invalid year value: \"+token);\n-                }\n-            }\n-\n-            \/\/ TYPE\n-            rec.type = tokens.nextToken();\n-\n-            \/\/ IN\n-            rec.inMonth = Month.parse(tokens.nextToken());\n-\n-            \/\/ ON\n-            rec.onDay = RuleDay.parse(tokens.nextToken());\n-\n-            \/\/ AT\n-            rec.atTime = Time.parse(tokens.nextToken());\n-\n-            \/\/ SAVE\n-            rec.save = (int) Time.parse(tokens.nextToken()).getTime();\n-\n-            \/\/ LETTER\/S\n-            rec.letters = tokens.nextToken();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-        return rec;\n-    }\n-\n-    \/**\n-     * Calculates the transition time of the given year under this rule.\n-     * @param year the year value\n-     * @param gmtOffset the GMT offset value in milliseconds\n-     * @param save the amount of daylight save time\n-     * @return the transition time in milliseconds of the given year in UTC.\n-     *\/\n-    long getTransitionTime(int year, int gmtOffset, int save) {\n-        long time = Time.getLocalTime(year, getMonth(),\n-                                      getDay(), atTime.getTime());\n-        if (atTime.isSTD()) {\n-            time -= gmtOffset;\n-        } else if (atTime.isWall()) {\n-            time -= gmtOffset + save;\n-        }\n-        return time;\n-    }\n-\n-    private static int getInt(StringTokenizer tokens) {\n-        String token = tokens.nextToken();\n-        return Integer.parseInt(token);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleRec.java","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.BufferedWriter;\n-import  java.io.File;\n-import  java.io.FileWriter;\n-import  java.io.IOException;\n-import  java.util.HashMap;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.SortedMap;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>Simple<\/code> generates TimeZoneData, which had been used as internal\n- * data of TimeZone before J2SDK1.3.\n- * Since J2SDK1.4 doesn't need TimeZoneData, this class is for maintenance\n- * of old JDK release.\n- *\/\n-class Simple extends BackEnd {\n-\n-    \/**\n-     * Zone records which are applied for given year.\n-     *\/\n-    private static Map<String,ZoneRec> lastZoneRecs = new HashMap<>();\n-\n-    \/**\n-     * Rule records which are applied for given year.\n-     *\/\n-    private static Map<String,List<RuleRec>> lastRules = new TreeMap<>();\n-\n-    \/**\n-     * zone IDs sorted by their GMT offsets. If zone's GMT\n-     * offset will change in the future, its last known offset is\n-     * used.\n-     *\/\n-    private SortedMap<Integer, Set<String>> zonesByOffset = new TreeMap<>();\n-\n-    \/**\n-     * Sets last Rule records and Zone records for given timezone to\n-     * each Map.\n-     *\n-     * @param tz Timezone object for each zone\n-     * @return always 0\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        String zonename = tz.getName();\n-\n-        lastRules.put(zonename, tz.getLastRules());\n-        lastZoneRecs.put(zonename, tz.getLastZoneRec());\n-\n-        \/\/ Populate zonesByOffset. (Zones that will change their\n-        \/\/ GMT offsets are also added to zonesByOffset here.)\n-        int lastKnownOffset = tz.getRawOffset();\n-        Set<String> set = zonesByOffset.get(lastKnownOffset);\n-        if (set == null) {\n-            set = new TreeSet<>();\n-            zonesByOffset.put(lastKnownOffset, set);\n-        }\n-        set.add(zonename);\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates TimeZoneData to output SimpleTimeZone data.\n-     * @param map Mappings object which is generated by {@link Main#compile}.\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            File outD = new File(Main.getOutputDir());\n-            outD.mkdirs();\n-\n-            FileWriter fw =\n-                new FileWriter(new File(outD, \"TimeZoneData.java\"), false);\n-            BufferedWriter out = new BufferedWriter(fw);\n-\n-            out.write(\"import java.util.SimpleTimeZone;\\n\\n\");\n-            out.write(\"    static SimpleTimeZone zones[] = {\\n\");\n-\n-            Map<String,String> a = map.getAliases();\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-\n-            int index = 0;\n-            for (int offset : zonesByOffset.keySet()) {\n-                int o = roi.get(index);\n-                Set<String> set = zonesByOffset.get(offset);\n-                if (offset == o) {\n-                    \/\/ Merge aliases into zonesByOffset\n-                    set.addAll(roit.get(index));\n-                }\n-                index++;\n-\n-                for (String key : set) {\n-                    ZoneRec zrec;\n-                    String realname;\n-                    List<RuleRec> stz;\n-                    if ((realname = a.get(key)) != null) {\n-                        \/\/ if this alias is not targeted, ignore it.\n-                        if (!Zone.isTargetZone(key)) {\n-                            continue;\n-                        }\n-                        stz = lastRules.get(realname);\n-                        zrec = lastZoneRecs.get(realname);\n-                    } else {\n-                        stz = lastRules.get(key);\n-                        zrec = lastZoneRecs.get(key);\n-                    }\n-\n-                    out.write(\"\\t\/\/--------------------------------------------------------------------\\n\");\n-                    String s = Time.toFormedString(offset);\n-                    out.write(\"\\tnew SimpleTimeZone(\" +\n-                        Time.toFormedString(offset) + \", \\\"\" + key + \"\\\"\");\n-                    if (realname != null) {\n-                        out.write(\" \/* \" + realname + \" *\/\");\n-                    }\n-\n-                    if (stz == null) {\n-                        out.write(\"),\\n\");\n-                    } else {\n-                        RuleRec rr0 = stz.get(0);\n-                        RuleRec rr1 = stz.get(1);\n-\n-                        out.write(\",\\n\\t  \" + Month.toString(rr0.getMonthNum()) +\n-                                  \", \" + rr0.getDay().getDayForSimpleTimeZone() + \", \" +\n-                                  rr0.getDay().getDayOfWeekForSimpleTimeZone() + \", \" +\n-                                  Time.toFormedString((int)rr0.getTime().getTime()) + \", \" +\n-                                  rr0.getTime().getTypeForSimpleTimeZone() + \",\\n\" +\n-\n-                                  \"\\t  \" + Month.toString(rr1.getMonthNum()) + \", \" +\n-                                  rr1.getDay().getDayForSimpleTimeZone() + \", \" +\n-                                  rr1.getDay().getDayOfWeekForSimpleTimeZone() + \", \" +\n-                                  Time.toFormedString((int)rr1.getTime().getTime())+ \", \" +\n-                                  rr1.getTime().getTypeForSimpleTimeZone() + \",\\n\" +\n-\n-                                  \"\\t  \" + Time.toFormedString(rr0.getSave()) + \"),\\n\");\n-\n-                        out.write(\"\\t\/\/ \" + rr0.getLine() + \"\\n\");\n-                        out.write(\"\\t\/\/ \" + rr1.getLine() + \"\\n\");\n-                    }\n-\n-                    String zline = zrec.getLine();\n-                    if (zline.indexOf(\"Zone\") == -1) {\n-                        zline = \"Zone \" + key + \"\\t\" + zline.trim();\n-                    }\n-                    out.write(\"\\t\/\/ \" + zline + \"\\n\");\n-                }\n-            }\n-            out.write(\"    };\\n\");\n-\n-            out.close();\n-            fw.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Simple.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,283 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8007572 8008161 8157792 8212970 8224560 8324065\n- * @summary Test whether the TimeZone generated from JSR310 tzdb is the same\n- * as the one from the tz data from javazic\n- * @modules java.base\/sun.util.calendar:+open\n- * @build BackEnd Checksum DayOfWeek Gen GenDoc Main Mappings Month\n- *        Rule RuleDay RuleRec Simple TestZoneInfo310 Time Timezone\n- *        TzIDOldMapping Zone ZoneInfoFile ZoneInfoOld ZoneRec Zoneinfo\n- * @run main TestZoneInfo310\n- *\/\n-\n-import java.io.File;\n-import java.lang.reflect.*;\n-import java.nio.file.*;\n-import java.util.*;\n-import java.util.regex.*;\n-import java.time.zone.*;\n-import java.time.ZoneId;\n-\n-public class TestZoneInfo310 {\n-\n-    public static void main(String[] args) throws Throwable {\n-\n-        String TESTDIR = System.getProperty(\"test.dir\", \".\");\n-        Path tzdir = Paths.get(System.getProperty(\"test.root\"),\n-            \"..\/..\/src\/java.base\/share\/data\/tzdata\");\n-        String tzfiles = \"africa antarctica asia australasia europe northamerica southamerica backward etcetera gmt\";\n-        Path jdk_tzdir = Paths.get(System.getProperty(\"test.src\"), \"tzdata_jdk\");\n-        String jdk_tzfiles = \"jdk11_backward\";\n-        String zidir = TESTDIR + File.separator + \"zi\";\n-        File fZidir = new File(zidir);\n-        if (!fZidir.exists()) {\n-            fZidir.mkdirs();\n-        }\n-        Matcher m = Pattern.compile(\"tzdata(?<ver>[0-9]{4}[A-z])\")\n-                           .matcher(new String(Files.readAllBytes(tzdir.resolve(\"VERSION\")), \"ascii\"));\n-        String ver = m.find() ? m.group(\"ver\") : \"NULL\";\n-\n-        ArrayList<String> alist = new ArrayList<>();\n-        alist.add(\"-V\");\n-        alist.add(ver);\n-        alist.add(\"-d\");\n-        alist.add(zidir);\n-        for (String f : tzfiles.split(\" \")) {\n-            alist.add(tzdir.resolve(f).toString());\n-        }\n-        for (String f : jdk_tzfiles.split(\" \")) {\n-            alist.add(jdk_tzdir.resolve(f).toString());\n-        }\n-        System.out.println(\"Compiling tz files!\");\n-        Main.main(alist.toArray(new String[alist.size()]));\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        System.out.println(\"testing!\");\n-        ZoneInfoFile.ziDir = zidir;\n-        long t0, t1;\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/Los_Angeles\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[1]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/New_York\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[2]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/Denver\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[3]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        String[] zids_old = ZoneInfoOld.getAvailableIDs();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getAvailableIDs()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, zids_old.length);\n-        Arrays.sort(zids_old);\n-\n-        t0 = System.nanoTime();\n-        String[] alias_old = ZoneInfoOld.getAliasTable()\n-                                 .keySet().toArray(new String[0]);\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getAliasTable()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, alias_old.length);\n-        Arrays.sort(alias_old);\n-\n-        t0 = System.currentTimeMillis();\n-        for (String zid : zids_old) {\n-            ZoneInfoOld.getTimeZone(zid);\n-        }\n-        t1 = System.currentTimeMillis();\n-        System.out.printf(\"OLD.TotalTZ()=%d (ms)%n\", t1 - t0);\n-\n-\/*\n-        t0 = System.nanoTime();\n-        ZoneId.of(\"America\/Los_Angeles\").getRules();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.ZoneId.of()[1]=%d%n\", (t1 - t0) \/ 1000);\n-*\/\n-        t0 = System.nanoTime();\n-        TimeZone tz = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[1]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        tz = TimeZone.getTimeZone(\"America\/New_York\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[2]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        tz = TimeZone.getTimeZone(\"America\/Denver\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[3]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        String[] zids_new = TimeZone.getAvailableIDs();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getAvailableIDs()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, zids_new.length);\n-        Arrays.sort(zids_new);\n-\n-        t0 = System.nanoTime();\n-        String[] alias_new = sun.util.calendar.ZoneInfo.getAliasTable()\n-                                 .keySet().toArray(new String[0]);\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getAliasTable()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, alias_new.length);\n-        Arrays.sort(alias_new);\n-\n-        t0 = System.currentTimeMillis();\n-        for (String zid : zids_new) {\n-            TimeZone.getTimeZone(zid);\n-        }\n-        t1 = System.currentTimeMillis();\n-        System.out.printf(\"NEW.TotalTZ()=%d (ms)%n\", t1 - t0);\n-\n-        if (!Arrays.equals(zids_old, zids_new)) {\n-            throw new RuntimeException(\"  FAILED:  availableIds don't match\");\n-        }\n-\n-        if (!Arrays.equals(alias_old, alias_new)) {\n-            throw new RuntimeException(\"  FAILED:  aliases don't match\");\n-        }\n-\n-        for (String zid : zids_new) {\n-            ZoneInfoOld zi = toZoneInfoOld(TimeZone.getTimeZone(zid));\n-            ZoneInfoOld ziOLD = (ZoneInfoOld)ZoneInfoOld.getTimeZone(zid);\n-            \/*\n-             * Ignoring the failing TimeZones which have negative DST\n-             * save time in IANA tzdata, as javazic\/ZoneInfoOld cannot\n-             * handle the negative DST.\n-             *\n-             * These are the zones\/rules that employ negative DST in vanguard\n-             * format (as of 2019a), Palestine added in 2022d:\n-             *\n-             *  - Rule \"Eire\"\n-             *  - Rule \"Morocco\"\n-             *  - Rule \"Namibia\"\n-             *  - Rule \"Palestine\"\n-             *  - Zone \"Europe\/Prague\"\n-             *\/\n-            if (zid.equals(\"Africa\/Casablanca\") || \/\/ uses \"Morocco\" rule\n-                zid.equals(\"Africa\/El_Aaiun\") || \/\/ uses \"Morocco\" rule\n-                zid.equals(\"Africa\/Windhoek\") || \/\/ uses \"Namibia\" rule\n-                zid.equals(\"Eire\") ||\n-                zid.equals(\"Europe\/Bratislava\") || \/\/ link to \"Europe\/Prague\"\n-                zid.equals(\"Europe\/Dublin\") || \/\/ uses \"Eire\" rule\n-                zid.equals(\"Europe\/Prague\") ||\n-                zid.equals(\"Asia\/Gaza\") || \/\/ uses \"Palestine\" rule\n-                zid.equals(\"Asia\/Hebron\")) { \/\/ uses \"Palestine\" rule\n-                    continue;\n-            }\n-            if (! zi.equalsTo(ziOLD)) {\n-                System.out.println(zi.diffsTo(ziOLD));\n-                throw new RuntimeException(\"  FAILED:  \" + zid);\n-            }\n-        }\n-        delete(fZidir);\n-\n-        \/\/ test tzdb version\n-        if (!ver.equals(sun.util.calendar.ZoneInfoFile.getVersion())) {\n-            System.out.printf(\"  FAILED:  ver=%s, expected=%s%n\",\n-                              sun.util.calendar.ZoneInfoFile.getVersion(), ver);\n-            throw new RuntimeException(\"Version test failed\");\n-        }\n-\n-        \/\/ test getAvailableIDs(raw);\n-        zids_new = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);\n-        Arrays.sort(zids_new);\n-        zids_old = ZoneInfoOld.getAvailableIDs(-8 * 60 * 60 * 1000);\n-        Arrays.sort(zids_old);\n-        if (!Arrays.equals(zids_new, zids_old)) {\n-            System.out.println(\"------------------------\");\n-            System.out.println(\"NEW.getAvailableIDs(-8:00)\");\n-            for (String zid : zids_new) {\n-                System.out.println(zid);\n-            }\n-            System.out.println(\"------------------------\");\n-            System.out.println(\"OLD.getAvailableIDs(-8:00)\");\n-            for (String zid : zids_old) {\n-                System.out.println(zid);\n-            }\n-            throw new RuntimeException(\"  FAILED:  availableIds(offset) don't match\");\n-        }\n-    }\n-\n-    private static void delete(File f) {\n-        if (f.isDirectory()) {\n-            for (File f0 : f.listFiles()) {\n-               delete(f0);\n-            }\n-        }\n-        f.delete();\n-     }\n-\n-    \/\/ to access sun.util.calendar.ZoneInfo's private fields\n-    static Class<?> ziClz;\n-    static Field rawOffset;\n-    static Field checksum;\n-    static Field dstSavings;\n-    static Field transitions;\n-    static Field offsets;\n-    static Field simpleTimeZoneParams;\n-    static Field willGMTOffsetChange;\n-    static {\n-        try {\n-            ziClz = Class.forName(\"sun.util.calendar.ZoneInfo\");\n-            rawOffset = ziClz.getDeclaredField(\"rawOffset\");\n-            checksum = ziClz.getDeclaredField(\"checksum\");\n-            dstSavings = ziClz.getDeclaredField(\"dstSavings\");\n-            transitions = ziClz.getDeclaredField(\"transitions\");\n-            offsets = ziClz.getDeclaredField(\"offsets\");\n-            simpleTimeZoneParams = ziClz.getDeclaredField(\"simpleTimeZoneParams\");\n-            willGMTOffsetChange = ziClz.getDeclaredField(\"willGMTOffsetChange\");\n-            rawOffset.setAccessible(true);\n-            checksum.setAccessible(true);\n-            dstSavings.setAccessible(true);\n-            transitions.setAccessible(true);\n-            offsets.setAccessible(true);\n-            simpleTimeZoneParams.setAccessible(true);\n-            willGMTOffsetChange.setAccessible(true);\n-        } catch (Exception x) {\n-            throw new RuntimeException(x);\n-        }\n-    }\n-\n-    private static ZoneInfoOld toZoneInfoOld(TimeZone tz) throws Exception {\n-        return new ZoneInfoOld(tz.getID(),\n-                               rawOffset.getInt(tz),\n-                               dstSavings.getInt(tz),\n-                               checksum.getInt(tz),\n-                               (long[])transitions.get(tz),\n-                               (int[])offsets.get(tz),\n-                               (int[])simpleTimeZoneParams.get(tz),\n-                               willGMTOffsetChange.getBoolean(tz));\n-    }\n-\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/TestZoneInfo310.java","additions":0,"deletions":283,"binary":false,"changes":283,"status":"deleted"},{"patch":"@@ -1,339 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Locale;\n-import sun.util.calendar.CalendarDate;\n-import sun.util.calendar.CalendarSystem;\n-import sun.util.calendar.Gregorian;\n-\n-\/**\n- * Time class represents the \"AT\" field and other time related information.\n- *\n- * @since 1.4\n- *\/\n-class Time {\n-\n-    static final Gregorian gcal = CalendarSystem.getGregorianCalendar();\n-\n-    \/\/ type is wall clock time\n-    private static final int WALL = 1;\n-\n-    \/\/ type is standard time\n-    private static final int STD = 2;\n-\n-    \/\/ type is UTC\n-    private static final int UTC = 3;\n-\n-    \/\/ type of representing time\n-    private int type;\n-\n-    \/**\n-     * Time from the EPOCH in milliseconds\n-     *\/\n-    private long time;\n-\n-    \/**\n-     * Current time in milliseconds\n-     *\/\n-    private static final long currentTime = System.currentTimeMillis();\n-\n-    Time() {\n-        time = 0L;\n-    }\n-\n-    Time(long time) {\n-        this.time = time;\n-    }\n-\n-    void setType(int type) {\n-        this.type = type;\n-    }\n-\n-    long getTime() {\n-        return time;\n-    }\n-\n-    int getType() {\n-        return type;\n-    }\n-\n-    static long getCurrentTime() {\n-        return currentTime;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in wall-clock time.\n-     *\/\n-    boolean isWall() {\n-        return type == WALL;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in standard time.\n-     *\/\n-    boolean isSTD() {\n-        return type == STD;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in UTC time.\n-     *\/\n-    boolean isUTC() {\n-        return type == UTC;\n-    }\n-\n-    \/**\n-     * Converts the type to a string that represents the type in the\n-     * SimpleTimeZone time mode. (e.g., \"SimpleTimeZone.WALL_TIME\").\n-     * @return the converted string or null if the type is undefined.\n-     *\/\n-    String getTypeForSimpleTimeZone() {\n-        String  stz = \"SimpleTimeZone.\";\n-        if (isWall()) {\n-            return stz+\"WALL_TIME\";\n-        }\n-        else if (isSTD()) {\n-            return stz+\"STANDARD_TIME\";\n-        }\n-        else if (isUTC()) {\n-            return stz+\"UTC_TIME\";\n-        }\n-        else {\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param save the amount of daylight time in milliseconds\n-     * @param gmtOffset the GMT offset in milliseconds\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, int save,\n-                             int gmtOffset, Time time) {\n-        long    t = time.getTime();\n-\n-        if (time.isSTD())\n-            t = time.getTime() + save;\n-        else if (time.isUTC())\n-            t = time.getTime() + save + gmtOffset;\n-\n-        return getLocalTime(year, month, day, t);\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day value\n-     * @param time the time of the day in milliseconds\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, int day, long time) {\n-        CalendarDate date = gcal.newCalendarDate(null);\n-        date.setDate(year, month.value(), day);\n-        long millis = gcal.getTime(date);\n-        return millis + time;\n-    }\n-\n-    \/**\n-     * Equivalent to <code>getLocalTime(year, month, day, (long)time)<\/code>.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day value\n-     * @param time the time of the day in milliseconds\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, int day, int time) {\n-        return getLocalTime(year, month, day, (long)time);\n-    }\n-\n-    \/**\n-     * Equivalent to {@link #getLocalTime(int, Month, RuleDay, int)\n-     * getLocalTime(year, month, day, (int) time)}.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, long time) {\n-        return getLocalTime(year, month, day, (int) time);\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, int time) {\n-        CalendarDate cdate = gcal.newCalendarDate(null);\n-        int monthValue = month.value();\n-\n-        if (day.isLast()) {     \/\/ e.g., \"lastSun\"\n-            cdate.setDate(year, monthValue, 1);\n-            cdate.setDayOfMonth(gcal.getMonthLength(cdate));\n-            cdate = gcal.getNthDayOfWeek(-1, day.getDayOfWeekNum(), cdate);\n-        } else if (day.isLater()) { \/\/ e.g., \"Sun>=1\"\n-            cdate.setDate(year, monthValue, day.getDay());\n-            cdate = gcal.getNthDayOfWeek(1, day.getDayOfWeekNum(), cdate);\n-        } else if (day.isExact()) {\n-            cdate.setDate(year, monthValue, day.getDay());\n-        } else if (day.isEarlier()) {   \/\/ e.g., \"Sun<=15\"\n-            cdate.setDate(year, monthValue, day.getDay());\n-            cdate = gcal.getNthDayOfWeek(-1, day.getDayOfWeekNum(), cdate);\n-        } else {\n-            Main.panic(\"invalid day type: \" + day);\n-        }\n-        return gcal.getTime(cdate) + time;\n-    }\n-\n-    \/**\n-     * Parses the given \"AT\" field and constructs a Time object.\n-     * @param the \"AT\" field string\n-     * @return the Time object\n-     *\/\n-    static Time parse(String time) {\n-        int sign;\n-        int index = 0;\n-        Time tm;\n-\n-        if (time.charAt(0) == '-') {\n-            sign = -1;\n-            index++;\n-        } else {\n-            sign = 1;\n-        }\n-        int val = 0;\n-        int num = 0;\n-        int countDelim = 0;\n-        while (index < time.length()) {\n-            char c = time.charAt(index++);\n-            if (c == ':') {\n-                val = val * 60 + num;\n-                countDelim++;\n-                num = 0;\n-                continue;\n-            }\n-            int d = Character.digit(c, 10);\n-            if (d == -1) {\n-                --index;\n-                break;\n-            }\n-            num = num * 10 + d;\n-        }\n-        val = val * 60 + num;\n-        \/\/ convert val to second\n-        for (; countDelim < 2; countDelim++) {\n-            val *= 60;\n-        }\n-        tm = new Time((long)val * 1000 * sign);\n-        if (index < time.length()) {\n-            char c = time.charAt(index++);\n-            if (c == 's') {\n-                tm.setType(Time.STD);\n-            } else if (c == 'u' || c == 'g' || c == 'z') {\n-                tm.setType(Time.UTC);\n-            } else if (c == 'w') {\n-                tm.setType(Time.WALL);\n-            } else {\n-                Main.panic(\"unknown time mode: \"+c);\n-            }\n-        } else {\n-            tm.setType(Time.WALL);\n-        }\n-        return tm;\n-    }\n-\n-    \/**\n-     * Converts the given milliseconds string to a \"[+-]hh:mm\" string.\n-     * @param ms the milliseconds string\n-     *\/\n-    static String toGMTFormat(String ms) {\n-        long sec = Long.parseLong(ms) \/ 1000;\n-        char sign;\n-        if (sec < 0) {\n-            sign = '-';\n-            sec = -sec;\n-        } else {\n-            sign = '+';\n-        }\n-        return String.format((Locale)null, \"%c%02d:%02d\",\n-                             sign, sec\/3600, (sec%3600)\/60);\n-    }\n-\n-    \/**\n-     * Converts the given millisecond value to a string for a\n-     * SimpleTimeZone parameter.\n-     * @param ms the millisecond value\n-     * @return the string in a human readable form\n-     *\/\n-    static String toFormedString(int ms) {\n-        StringBuilder s = new StringBuilder();\n-        boolean minus = false;\n-\n-        if (ms < 0) {\n-            s.append(\"-\");\n-            minus = true;\n-            ms = -ms;\n-        } else if (ms == 0) {\n-            return \"0\";\n-        }\n-\n-        int hour = ms \/ (60 * 60 * 1000);\n-        ms %= (60 * 60 * 1000);\n-        int minute = ms \/ (60 * 1000);\n-\n-        if (hour != 0) {\n-            if (minus && minute != 0) {\n-                s.append(\"(\");\n-            }\n-            s.append(Integer.toString(hour) + \"*ONE_HOUR\");\n-        }\n-\n-        if (minute != 0) {\n-            if (hour != 0) {\n-                s.append(\"+\");\n-            }\n-            s.append(Integer.toString(minute) + \"*ONE_MINUTE\");\n-            if (minus && hour != 0) {\n-                s.append(\")\");\n-            }\n-        }\n-\n-        return s.toString();\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Time.java","additions":0,"deletions":339,"binary":false,"changes":339,"status":"deleted"},{"patch":"@@ -1,450 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Timezone represents all information of a single point of time to\n- * generate its time zone database.\n- *\n- * @since 1.4\n- *\/\n-class Timezone {\n-    \/**\n-     * zone name of this time zone\n-     *\/\n-    private String name;\n-\n-    \/**\n-     * transition time values in UTC (millisecond)\n-     *\/\n-    private List<Long> transitions;\n-\n-    \/**\n-     * All offset values in millisecond\n-     * @see sun.util.calendar.ZoneInfo\n-     *\/\n-    private List<Integer> offsets;\n-\n-    \/**\n-     * Indices of GMT offset values (both raw and raw+saving)\n-     * at transitions\n-     *\/\n-    private List<Integer> gmtOffsets;\n-\n-    \/**\n-     * Indices of regular or \"direct\" saving time values\n-     * at transitions\n-     *\/\n-    private List<Integer> dstOffsets;\n-\n-    \/**\n-     * Zone records of this time zone\n-     *\/\n-    private List<ZoneRec> usedZoneRecs;\n-\n-    \/**\n-     * Rule records referred to by this time zone\n-     *\/\n-    private List<RuleRec> usedRuleRecs;\n-\n-    \/**\n-     * Type of DST rules in this time zone\n-     *\/\n-    private int dstType;\n-    static final int UNDEF_DST = 0;     \/\/ DST type not set yet\n-    static final int NO_DST = 1;        \/\/ never observed DST\n-    static final int LAST_DST = 2;      \/\/ last rule ends in DST (all year round DST-only)\n-    static final int X_DST = 3;         \/\/ used to observe DST\n-    static final int DST = 4;           \/\/ observing DST regularly\n-\n-    \/**\n-     * Raw GMT offset of this time zone in the last rule\n-     *\/\n-    private int rawOffset;\n-\n-    \/**\n-     * The CRC32 value of the transitions data\n-     *\/\n-    private int crc32;\n-\n-    \/**\n-     * The last ZoneRec\n-     *\/\n-    private ZoneRec lastZoneRec;\n-\n-    \/**\n-     * The last DST rules. lastRules[0] is the DST start\n-     * rule. lastRules[1] is the DST end rules.\n-     *\/\n-    private List<RuleRec> lastRules;\n-\n-    \/**\n-     * The amount of DST saving value (millisecond) in the last DST\n-     * rule.\n-     *\/\n-    private int lastSaving;\n-\n-    \/**\n-     * true if the raw offset will change in the future time.\n-     *\/\n-    private boolean willRawOffsetChange = false;\n-\n-\n-    \/**\n-     * Constracts a Timezone object with the given zone name.\n-     * @param name the zone name\n-     *\/\n-    Timezone(String name) {\n-        this.name = name;\n-    }\n-\n-    \/**\n-     * @return the number of transitions\n-     *\/\n-    int getNTransitions() {\n-        if (transitions == null) {\n-            return 0;\n-        }\n-        return transitions.size();\n-    }\n-\n-    \/**\n-     * @return the zone name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Returns the list of all rule records that have been referred to\n-     * by this time zone.\n-     * @return the rule records list\n-     *\/\n-    List<RuleRec> getRules() {\n-        return usedRuleRecs;\n-    }\n-\n-    \/**\n-     * Returns the list of all zone records that have been referred to\n-     * by this time zone.\n-     * @return the zone records list\n-     *\/\n-    List<ZoneRec> getZones() {\n-        return usedZoneRecs;\n-    }\n-\n-    \/**\n-     * @return the transition table (list)\n-     *\/\n-    List<Long> getTransitions() {\n-        return transitions;\n-    }\n-\n-    \/**\n-     * @return the offsets list\n-     *\/\n-    List<Integer> getOffsets() {\n-        return offsets;\n-    }\n-\n-    \/**\n-     * @return the DST saving offsets list\n-     *\/\n-    List<Integer> getDstOffsets() {\n-        return dstOffsets;\n-    }\n-\n-    \/**\n-     * @return the GMT offsets list\n-     *\/\n-    List<Integer> getGmtOffsets() {\n-        return gmtOffsets;\n-    }\n-\n-    \/**\n-     * @return the checksum (crc32) value of the trasition table\n-     *\/\n-    int getCRC32() {\n-        return crc32;\n-    }\n-\n-    \/**\n-     * @return true if the GMT offset of this time zone would change\n-     * after the time zone database has been generated, false, otherwise.\n-     *\/\n-    boolean willGMTOffsetChange() {\n-        return willRawOffsetChange;\n-    }\n-\n-    \/**\n-     * @return the last known GMT offset value in milliseconds\n-     *\/\n-    int getRawOffset() {\n-        return rawOffset;\n-    }\n-\n-    \/**\n-     * Sets time zone's GMT offset to <code>offset<\/code>.\n-     * @param offset the GMT offset value in milliseconds\n-     *\/\n-    void setRawOffset(int offset) {\n-        rawOffset = offset;\n-    }\n-\n-    \/**\n-     * Sets time zone's GMT offset value to <code>offset<\/code>. If\n-     * <code>startTime<\/code> is future time, then the {@link\n-     * #willRawOffsetChange} value is set to true.\n-     * @param offset the GMT offset value in milliseconds\n-     * @param startTime the UTC time at which the GMT offset is in effective\n-     *\/\n-    void setRawOffset(int offset, long startTime) {\n-        \/\/ if this rawOffset is for the future time, let the run-time\n-        \/\/ look for the current GMT offset.\n-        if (startTime > Time.getCurrentTime()) {\n-            willRawOffsetChange = true;\n-        }\n-        setRawOffset(offset);\n-    }\n-\n-    \/**\n-     * Adds the specified transition information to the end of the transition table.\n-     * @param time the UTC time at which this transition happens\n-     * @param offset the total amount of the offset from GMT in milliseconds\n-     * @param dstOffset the amount of time in milliseconds saved at this transition\n-     *\/\n-    void addTransition(long time, int offset, int dstOffset) {\n-        if (transitions == null) {\n-            transitions = new ArrayList<Long>();\n-            offsets = new ArrayList<Integer>();\n-            dstOffsets = new ArrayList<Integer>();\n-        }\n-        transitions.add(time);\n-        offsets.add(offset);\n-        dstOffsets.add(dstOffset);\n-    }\n-\n-    \/**\n-     * Sets the type of historical daylight saving time\n-     * observation. For example, China used to observed daylight\n-     * saving time, but it no longer does. Then, X_DST is set to the\n-     * China time zone.\n-     * @param type the type of daylight saving time\n-     *\/\n-    void setDSTType(int type) {\n-        dstType = type;\n-    }\n-\n-    \/**\n-     * @return the type of historical daylight saving time\n-     * observation.\n-     *\/\n-    int getDSTType() {\n-        return dstType;\n-    }\n-\n-    \/**\n-     * Adds the specified zone record to the zone records list.\n-     * @param rec the zone record\n-     *\/\n-    void addUsedRec(ZoneRec rec) {\n-        if (usedZoneRecs == null) {\n-            usedZoneRecs = new ArrayList<ZoneRec>();\n-        }\n-        usedZoneRecs.add(rec);\n-    }\n-\n-    \/**\n-     * Adds the specified rule record to the rule records list.\n-     * @param rec the rule record\n-     *\/\n-    void addUsedRec(RuleRec rec) {\n-        if (usedRuleRecs == null) {\n-            usedRuleRecs = new ArrayList<RuleRec>();\n-        }\n-        \/\/ if the last used rec is the same as the given rec, avoid\n-        \/\/ putting the same rule.\n-        int n = usedRuleRecs.size();\n-        for (int i = 0; i < n; i++) {\n-            if (usedRuleRecs.get(i).equals(rec)) {\n-                return;\n-            }\n-        }\n-        usedRuleRecs.add(rec);\n-    }\n-\n-    \/**\n-     * Sets the last zone record for this time zone.\n-     * @param the last zone record\n-     *\/\n-    void setLastZoneRec(ZoneRec zrec) {\n-        lastZoneRec = zrec;\n-    }\n-\n-    \/**\n-     * @return the last zone record for this time zone.\n-     *\/\n-    ZoneRec getLastZoneRec() {\n-        return lastZoneRec;\n-    }\n-\n-    \/**\n-     * Sets the last rule records for this time zone. Those are used\n-     * for generating SimpleTimeZone parameters.\n-     * @param rules the last rule records\n-     *\/\n-    void setLastRules(List<RuleRec> rules) {\n-        int n = rules.size();\n-        if (n > 0) {\n-            lastRules = rules;\n-            RuleRec rec = rules.get(0);\n-            int offset = rec.getSave();\n-            if (offset > 0) {\n-                setLastDSTSaving(offset);\n-            } else {\n-                System.err.println(\"\\t    No DST starting rule in the last rules.\");\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * @return the last rule records for this time zone.\n-     *\/\n-    List<RuleRec> getLastRules() {\n-        return lastRules;\n-    }\n-\n-    \/**\n-     * Sets the last daylight saving amount.\n-     * @param the daylight saving amount\n-     *\/\n-    void setLastDSTSaving(int offset) {\n-        lastSaving = offset;\n-    }\n-\n-    \/**\n-     * @return the last daylight saving amount.\n-     *\/\n-    int getLastDSTSaving() {\n-        return lastSaving;\n-    }\n-\n-    \/**\n-     * Calculates the CRC32 value from the transition table and sets\n-     * the value to <code>crc32<\/code>.\n-     *\/\n-    void checksum() {\n-        if (transitions == null) {\n-            crc32 = 0;\n-            return;\n-        }\n-        Checksum sum = new Checksum();\n-        for (int i = 0; i < transitions.size(); i++) {\n-            int offset = offsets.get(i);\n-            \/\/ adjust back to make the transition in local time\n-            sum.update(transitions.get(i) + offset);\n-            sum.update(offset);\n-            sum.update(dstOffsets.get(i));\n-        }\n-        crc32 = (int)sum.getValue();\n-    }\n-\n-    \/**\n-     * Removes unnecessary transitions for Java time zone support.\n-     *\/\n-    void optimize() {\n-        \/\/ if there is only one offset, delete all transitions. This\n-        \/\/ could happen if only time zone abbreviations changed.\n-        if (gmtOffsets.size() == 1) {\n-            transitions = null;\n-            usedRuleRecs =  null;\n-            setDSTType(NO_DST);\n-            return;\n-        }\n-        for (int i = 0; i < (transitions.size() - 2); i++) { \/\/ don't remove the last one\n-            if (transitions.get(i) == transitions.get(i+1)) {\n-                transitions.remove(i);\n-                offsets.remove(i);\n-                dstOffsets.remove(i);\n-                i--;\n-            }\n-        }\n-\n-        for (int i = 0; i < (transitions.size() - 2); i++) { \/\/ don't remove the last one\n-            if (offsets.get(i) == offsets.get(i+1)\n-                && dstOffsets.get(i) == dstOffsets.get(i+1)) {\n-                transitions.remove(i+1);\n-                offsets.remove(i+1);\n-                dstOffsets.remove(i+1);\n-                i--;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Stores the specified offset value from GMT in the GMT offsets\n-     * table and returns its index. The offset value includes the base\n-     * GMT offset and any additional daylight saving if applicable. If\n-     * the same value as the specified offset is already in the table,\n-     * its index is returned.\n-     * @param offset the offset value in milliseconds\n-     * @return the index to the offset value in the GMT offsets table.\n-     *\/\n-    int getOffsetIndex(int offset) {\n-        return getOffsetIndex(offset, 0);\n-    }\n-\n-    \/**\n-     * Stores the specified daylight saving value in the GMT offsets\n-     * table and returns its index. If the same value as the specified\n-     * offset is already in the table, its index is returned. If 0 is\n-     * specified, it's not stored in the table and -1 is returned.\n-     * @param offset the offset value in milliseconds\n-     * @return the index to the specified offset value in the GMT\n-     * offsets table, or -1 if 0 is specified.\n-     *\/\n-    int getDstOffsetIndex(int offset) {\n-        if (offset == 0) {\n-            return -1;\n-        }\n-        return getOffsetIndex(offset, 1);\n-    }\n-\n-    private int getOffsetIndex(int offset, int index) {\n-        if (gmtOffsets == null) {\n-            gmtOffsets = new ArrayList<Integer>();\n-        }\n-        for (int i = index; i < gmtOffsets.size(); i++) {\n-            if (offset == gmtOffsets.get(i)) {\n-                return i;\n-            }\n-        }\n-        if (gmtOffsets.size() < index) {\n-            gmtOffsets.add(0);\n-        }\n-        gmtOffsets.add(offset);\n-        return gmtOffsets.size() - 1;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Timezone.java","additions":0,"deletions":450,"binary":false,"changes":450,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Map;\n-import java.util.HashMap;\n-\n-class TzIDOldMapping {\n-    static final Map<String, String> MAP = new HashMap<String, String>();\n-    static {\n-        String[][] oldmap = {\n-            { \"ACT\", \"Australia\/Darwin\" },\n-            { \"AET\", \"Australia\/Sydney\" },\n-            { \"AGT\", \"America\/Argentina\/Buenos_Aires\" },\n-            { \"ART\", \"Africa\/Cairo\" },\n-            { \"AST\", \"America\/Anchorage\" },\n-            { \"BET\", \"America\/Sao_Paulo\" },\n-            { \"BST\", \"Asia\/Dhaka\" },\n-            { \"CAT\", \"Africa\/Harare\" },\n-            { \"CNT\", \"America\/St_Johns\" },\n-            { \"CST\", \"America\/Chicago\" },\n-            { \"CTT\", \"Asia\/Shanghai\" },\n-            { \"EAT\", \"Africa\/Addis_Ababa\" },\n-            { \"ECT\", \"Europe\/Paris\" },\n-            { \"EST\", \"America\/New_York\" },\n-            { \"HST\", \"Pacific\/Honolulu\" },\n-            { \"IET\", \"America\/Indianapolis\" },\n-            { \"IST\", \"Asia\/Calcutta\" },\n-            { \"JST\", \"Asia\/Tokyo\" },\n-            { \"MIT\", \"Pacific\/Apia\" },\n-            { \"MST\", \"America\/Denver\" },\n-            { \"NET\", \"Asia\/Yerevan\" },\n-            { \"NST\", \"Pacific\/Auckland\" },\n-            { \"PLT\", \"Asia\/Karachi\" },\n-            { \"PNT\", \"America\/Phoenix\" },\n-            { \"PRT\", \"America\/Puerto_Rico\" },\n-            { \"PST\", \"America\/Los_Angeles\" },\n-            { \"SST\", \"Pacific\/Guadalcanal\" },\n-            { \"VST\", \"Asia\/Saigon\" },\n-        };\n-        for (String[] pair : oldmap) {\n-            MAP.put(pair[0], pair[1]);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/TzIDOldMapping.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Zone holds information corresponding to a \"Zone\" part of a time\n- * zone definition file.\n- *\n- * @since 1.4\n- *\/\n-class Zone {\n-    \/\/ zone name (e.g., \"America\/Los_Angeles\")\n-    private String name;\n-\n-    \/\/ zone records\n-    private List<ZoneRec> list;\n-\n-    \/\/ target zone names for this compilation\n-    private static Set<String> targetZones;\n-\n-    \/**\n-     * Constructs a Zone with the specified zone name.\n-     * @param name the zone name\n-     *\/\n-    Zone(String name) {\n-        this.name = name;\n-        list = new ArrayList<ZoneRec>();\n-    }\n-\n-    \/**\n-     * Reads time zone names to be generated, called \"target zone\n-     * name\", from the specified text file and creats an internal hash\n-     * table to keep those names. It's assumed that one text line\n-     * contains a zone name or comments if it starts with\n-     * '#'. Comments can't follow a zone name in a single line.\n-     * @param fileName the text file name\n-     *\/\n-    static void readZoneNames(String fileName) {\n-        if (fileName == null) {\n-            return;\n-        }\n-        BufferedReader in = null;\n-        try {\n-            FileReader fr = new FileReader(fileName);\n-            in = new BufferedReader(fr);\n-        } catch (FileNotFoundException e) {\n-            Main.panic(\"can't open file: \" + fileName);\n-        }\n-        targetZones = new HashSet<String>();\n-        String line;\n-\n-        try {\n-            while ((line = in.readLine()) != null) {\n-                line = line.trim();\n-                if (line.length() == 0 || line.charAt(0) == '#') {\n-                    continue;\n-                }\n-                if (!targetZones.add(line)) {\n-                    Main.warning(\"duplicated target zone name: \" + line);\n-                }\n-            }\n-            in.close();\n-        } catch (IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-        }\n-    }\n-\n-    \/**\n-     * Determines whether the specified zone is one of the target zones.\n-     * If no target zones are specified, this method always returns\n-     * true for any zone name.\n-     * @param zoneName the zone name\n-     * @return true if the specified name is a target zone.\n-     *\/\n-    static boolean isTargetZone(String zoneName) {\n-        if (targetZones == null) {\n-            return true;\n-        }\n-        return targetZones.contains(zoneName);\n-    }\n-\n-    \/**\n-     * Forces to add \"MET\" to the target zone table. This is because\n-     * there is a conflict between Java zone name \"WET\" and Olson zone\n-     * name.\n-     *\/\n-    static void addMET() {\n-        if (targetZones != null) {\n-            targetZones.add(\"MET\");\n-        }\n-    }\n-\n-    \/**\n-     * @return the zone name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Adds the specified zone record to the zone record list.\n-     *\/\n-    void add(ZoneRec rec) {\n-        list.add(rec);\n-    }\n-\n-    \/**\n-     * @param index the index at which the zone record in the list is returned.\n-     * @return the zone record specified by the index.\n-     *\/\n-    ZoneRec get(int index) {\n-        return list.get(index);\n-    }\n-\n-    \/**\n-     * @return the size of the zone record list\n-     *\/\n-    int size() {\n-        return list.size();\n-    }\n-\n-    \/**\n-     * Resolves the reference to a rule in each zone record.\n-     * @param zi the Zoneinfo object with which the rule reference is\n-     * resolved.\n-     *\/\n-    void resolve(Zoneinfo zi) {\n-        for (int i = 0; i < list.size(); i++) {\n-            ZoneRec rec = list.get(i);\n-            rec.resolve(zi);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Zone.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,1049 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.lang.ref.SoftReference;\n-import java.nio.file.FileSystems;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import sun.util.calendar.*;\n-\n-\/**\n- * <code>ZoneInfoFile<\/code> reads Zone information files in the\n- * &lt;java.home&gt;\/lib\/zi directory and provides time zone\n- * information in the form of a {@link ZoneInfo} object. Also, it\n- * reads the ZoneInfoMappings file to obtain time zone IDs information\n- * that is used by the {@link ZoneInfo} class. The directory layout\n- * and data file formats are as follows.\n- *\n- * <p><strong>Directory layout<\/strong><p>\n- *\n- * All zone data files and ZoneInfoMappings are put under the\n- * &lt;java.home&gt;\/lib\/zi directory. A path name for a given time\n- * zone ID is a concatenation of &lt;java.home&gt;\/lib\/zi\/ and the\n- * time zone ID. (The file separator is replaced with the platform\n- * dependent value. e.g., '\\' for Win32.) An example layout will look\n- * like as follows.\n- * <blockquote>\n- * <pre>\n- * &lt;java.home&gt;\/lib\/zi\/Africa\/Addis_Ababa\n- *                   \/Africa\/Dakar\n- *                   \/America\/Los_Angeles\n- *                   \/Asia\/Singapore\n- *                   \/EET\n- *                   \/Europe\/Oslo\n- *                   \/GMT\n- *                   \/Pacific\/Galapagos\n- *                       ...\n- *                   \/ZoneInfoMappings\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * A zone data file has specific information of each zone.\n- * <code>ZoneInfoMappings<\/code> has global information of zone IDs so\n- * that the information can be obtained without instantiating all time\n- * zones.\n- *\n- * <p><strong>File format<\/strong><p>\n- *\n- * Two binary-file formats based on a simple Tag-Length-Value format are used\n- * to describe TimeZone information. The generic format of a data file is:\n- * <blockquote>\n- * <pre>\n- *    DataFile {\n- *      u1              magic[7];\n- *      u1              version;\n- *      data_item       data[];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * where <code>magic<\/code> is a magic number identifying a file\n- * format, <code>version<\/code> is the format version number, and\n- * <code>data<\/code> is one or more <code>data_item<\/code>s. The\n- * <code>data_item<\/code> structure is:\n- * <blockquote>\n- * <pre>\n- *    data_item {\n- *      u1              tag;\n- *      u2              length;\n- *      u1              value[length];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * where <code>tag<\/code> indicates the data type of the item,\n- * <code>length<\/code> is a byte count of the following\n- * <code>value<\/code> that is the content of item data.\n- * <p>\n- * All data is stored in the big-endian order. There is no boundary\n- * alignment between date items.\n- *\n- * <p><strong>1. ZoneInfo data file<\/strong><p>\n- *\n- * Each ZoneInfo data file consists of the following members.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    ZoneInfoDataFile {\n- *      u1              magic[7];\n- *      u1              version;\n- *      SET OF<sup>1<\/sup> {\n- *        transition            transitions<sup>2<\/sup>;\n- *        offset_table          offsets<sup>2<\/sup>;\n- *        simpletimezone        stzparams<sup>2<\/sup>;\n- *        raw_offset            rawoffset;\n- *        dstsaving             dst;\n- *        checksum              crc32;\n- *        gmtoffsetwillchange   gmtflag<sup>2<\/sup>;\n- *      }\n- *   }\n- *   1: an unordered collection of zero or one occurrences of each item\n- *   2: optional item\n- * <\/pre>\n- * <\/blockquote>\n- * <code>magic<\/code> is a byte-string constant identifying the\n- * ZoneInfo data file.  This field must be <code>\"javazi&#92;0\"<\/code>\n- * defined as {@link #JAVAZI_LABEL}.\n- * <p>\n- * <code>version<\/code> is the version number of the file format. This\n- * will be used for compatibility check. This field must be\n- * <code>0x01<\/code> in this version.\n- * <p>\n- * <code>transition<\/code>, <code>offset_table<\/code> and\n- * <code>simpletimezone<\/code> have information of time transition\n- * from the past to the future.  Therefore, these structures don't\n- * exist if the zone didn't change zone names and haven't applied DST in\n- * the past, and haven't planned to apply it.  (e.g. Asia\/Tokyo zone)\n- * <p>\n- * <code>raw_offset<\/code>, <code>dstsaving<\/code> and <code>checksum<\/code>\n- * exist in every zoneinfo file. They are used by TimeZone.class indirectly.\n- *\n- * <p><strong>1.1 <code>transition<\/code> structure<\/strong><p><a name=\"transition\"><\/a>\n- * <blockquote>\n- * <pre>\n- *    transition {\n- *      u1      tag;              \/\/ 0x04 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s8      value[length\/8];  \/\/ transitions in `long'\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#transitions ZoneInfo.transitions} about the value.\n- *\n- * <p><strong>1.2 <code>offset_table<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    offset_table {\n- *      u1      tag;              \/\/ 0x05 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ offset values in `int'\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>1.3 <code>simpletimezone<\/code> structure<\/strong><p>\n- * See {@link ZoneInfo#simpleTimeZoneParams ZoneInfo.simpleTimeZoneParams}\n- * about the value.\n- * <blockquote>\n- * <pre>\n- *    simpletimezone {\n- *      u1      tag;              \/\/ 0x06 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ SimpleTimeZone parameters\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#offsets ZoneInfo.offsets} about the value.\n- *\n- * <p><strong>1.4 <code>raw_offset<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    raw_offset {\n- *      u1      tag;              \/\/ 0x01 : constant\n- *      u2      length;           \/\/ must be 4.\n- *      s4      value;            \/\/ raw GMT offset [millisecond]\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#rawOffset ZoneInfo.rawOffset} about the value.\n- *\n- * <p><strong>1.5 <code>dstsaving<\/code> structure<\/strong><p>\n- * Value has dstSaving in seconds.\n- * <blockquote>\n- * <pre>\n- *    dstsaving {\n- *      u1      tag;              \/\/ 0x02 : constant\n- *      u2      length;           \/\/ must be 2.\n- *      s2      value;            \/\/ DST save value [second]\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#dstSavings ZoneInfo.dstSavings} about value.\n- *\n- * <p><strong>1.6 <code>checksum<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    checksum {\n- *      u1      tag;              \/\/ 0x03 : constant\n- *      u2      length;           \/\/ must be 4.\n- *      s4      value;            \/\/ CRC32 value of transitions\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#checksum ZoneInfo.checksum}.\n- *\n- * <p><strong>1.7 <code>gmtoffsetwillchange<\/code> structure<\/strong><p>\n- * This record has a flag value for {@link ZoneInfo#rawOffsetWillChange}.\n- * If this record is not present in a zoneinfo file, 0 is assumed for\n- * the value.\n- * <blockquote>\n- * <pre>\n- *    gmtoffsetwillchange {\n- *      u1      tag;             \/\/ 0x07 : constant\n- *      u2      length;          \/\/ must be 1.\n- *      u1      value;           \/\/ 1: if the GMT raw offset will change\n- *                               \/\/ in the future, 0, otherwise.\n- *     }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- *\n- * <p><strong>2. ZoneInfoMappings file<\/strong><p>\n- *\n- * The ZoneInfoMappings file consists of the following members.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    ZoneInfoMappings {\n- *      u1      magic[7];\n- *      u1      version;\n- *      SET OF {\n- *        versionName                   version;\n- *        zone_id_table                 zoneIDs;\n- *        raw_offset_table              rawoffsets;\n- *        raw_offset_index_table        rawoffsetindices;\n- *        alias_table                   aliases;\n- *        excluded_list                 excludedList;\n- *      }\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <code>magic<\/code> is a byte-string constant which has the file type.\n- * This field must be <code>\"javazm&#92;0\"<\/code> defined as {@link #JAVAZM_LABEL}.\n- * <p>\n- * <code>version<\/code> is the version number of this file\n- * format. This will be used for compatibility check. This field must\n- * be <code>0x01<\/code> in this version.\n- * <p>\n- * <code>versionName<\/code> shows which version of Olson's data has been used\n- * to generate this ZoneInfoMappings. (e.g. <code>tzdata2000g<\/code>) <br>\n- * This field is for trouble-shooting and isn't usually used in runtime.\n- * <p>\n- * <code>zone_id_table<\/code>, <code>raw_offset_index_table<\/code> and\n- * <code>alias_table<\/code> are general information of supported\n- * zones.\n- *\n- * <p><strong>2.1 <code>zone_id_table<\/code> structure<\/strong><p>\n- * The list of zone IDs included in the zi database. The list does\n- * <em>not<\/em> include zone IDs, if any, listed in excludedList.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    zone_id_table {\n- *      u1      tag;              \/\/ 0x40 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      zone_id_count;\n- *      zone_id value[zone_id_count];\n- *    }\n- *\n- *    zone_id {\n- *      u1      byte_length;      \/\/ byte length of id\n- *      u1      id[byte_length];  \/\/ zone name string\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.2 <code>raw_offset_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    raw_offset_table {\n- *      u1      tag;              \/\/ 0x41 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ raw GMT offset in milliseconds\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.3 <code>raw_offset_index_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    raw_offset_index_table {\n- *      u1      tag;              \/\/ 0x42 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u1      value[length];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.4 <code>alias_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   alias_table {\n- *      u1      tag;              \/\/ 0x43 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      nentries;         \/\/ number of id-pairs\n- *      id_pair value[nentries];\n- *   }\n- *\n- *   id_pair {\n- *      zone_id aliasname;\n- *      zone_id ID;\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.5 <code>versionName<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   versionName {\n- *      u1      tag;              \/\/ 0x44 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u1      value[length];\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.6 <code>excludeList<\/code> structure<\/strong><p>\n- * The list of zone IDs whose zones will change their GMT offsets\n- * (a.k.a. raw offsets) some time in the future. Those IDs must be\n- * added to the list of zone IDs for getAvailableIDs(). Also they must\n- * be examined for getAvailableIDs(int) to determine the\n- * <em>current<\/em> GMT offsets.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   excluded_list {\n- *      u1      tag;              \/\/ 0x45 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      nentries;         \/\/ number of zone_ids\n- *      zone_id value[nentries];  \/\/ excluded zone IDs\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * @since 1.4\n- *\/\n-\n-public class ZoneInfoFile {\n-\n-    \/**\n-     * The magic number for the ZoneInfo data file format.\n-     *\/\n-    public static final byte[]  JAVAZI_LABEL = {\n-        (byte)'j', (byte)'a', (byte)'v', (byte)'a', (byte)'z', (byte)'i', (byte)'\\0'\n-    };\n-    private static final int    JAVAZI_LABEL_LENGTH = JAVAZI_LABEL.length;\n-\n-    \/**\n-     * The ZoneInfo data file format version number. Must increase\n-     * one when any incompatible change has been made.\n-     *\/\n-    public static final byte    JAVAZI_VERSION = 0x01;\n-\n-    \/**\n-     * Raw offset data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffset = 1;\n-\n-    \/**\n-     * Known last Daylight Saving Time save value data item tag.\n-     *\/\n-    public static final byte    TAG_LastDSTSaving = 2;\n-\n-    \/**\n-     * Checksum data item tag.\n-     *\/\n-    public static final byte    TAG_CRC32 = 3;\n-\n-    \/**\n-     * Transition data item tag.\n-     *\/\n-    public static final byte    TAG_Transition = 4;\n-\n-    \/**\n-     * Offset table data item tag.\n-     *\/\n-    public static final byte    TAG_Offset = 5;\n-\n-    \/**\n-     * SimpleTimeZone parameters data item tag.\n-     *\/\n-    public static final byte    TAG_SimpleTimeZone = 6;\n-\n-    \/**\n-     * Raw GMT offset will change in the future.\n-     *\/\n-    public static final byte    TAG_GMTOffsetWillChange = 7;\n-\n-\n-    \/**\n-     * The ZoneInfoMappings file name.\n-     *\/\n-    public static final String  JAVAZM_FILE_NAME = \"ZoneInfoMappings\";\n-\n-    \/**\n-     * The magic number for the ZoneInfoMappings file format.\n-     *\/\n-    public static final byte[]  JAVAZM_LABEL = {\n-        (byte)'j', (byte)'a', (byte)'v', (byte)'a', (byte)'z', (byte)'m', (byte)'\\0'\n-    };\n-    private static final int    JAVAZM_LABEL_LENGTH = JAVAZM_LABEL.length;\n-\n-    \/**\n-     * The ZoneInfoMappings file format version number. Must increase\n-     * one when any incompatible change has been made.\n-     *\/\n-    public static final byte    JAVAZM_VERSION = 0x01;\n-\n-    \/**\n-     * Time zone IDs data item tag.\n-     *\/\n-    public static final byte    TAG_ZoneIDs = 64;\n-\n-    \/**\n-     * Raw GMT offsets table data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffsets = 65;\n-\n-    \/**\n-     * Indices to the raw GMT offset table data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffsetIndices = 66;\n-\n-    \/**\n-     * Time zone aliases table data item tag.\n-     *\/\n-    public static final byte    TAG_ZoneAliases = 67;\n-\n-    \/**\n-     * Olson's public zone information version tag.\n-     *\/\n-    public static final byte    TAG_TZDataVersion = 68;\n-\n-    \/**\n-     * Excluded zones item tag. (Added in Mustang)\n-     *\/\n-    public static final byte    TAG_ExcludedZones = 69;\n-\n-    private static Map<String, ZoneInfoOld> zoneInfoObjects = null;\n-\n-    private static final ZoneInfoOld GMT = new ZoneInfoOld(\"GMT\", 0);\n-\n-    static String ziDir;\n-\n-    \/**\n-     * Converts the given time zone ID to a platform dependent path\n-     * name. For example, \"America\/Los_Angeles\" is converted to\n-     * \"America\\Los_Angeles\" on Win32.\n-     * @return a modified ID replacing '\/' with {@link\n-     * java.io.File#separatorChar File.separatorChar} if needed.\n-     *\/\n-    public static String getFileName(String ID) {\n-        if (File.separatorChar == '\/') {\n-            return ID;\n-        }\n-        return ID.replace('\/', File.separatorChar);\n-    }\n-\n-    \/**\n-     * Gets a ZoneInfo with the given GMT offset. The object\n-     * has its ID in the format of GMT{+|-}hh:mm.\n-     *\n-     * @param originalId the given custom id (before normalized such as \"GMT+9\")\n-     * @param gmtOffset GMT offset <em>in milliseconds<\/em>\n-     * @return a ZoneInfo constructed with the given GMT offset\n-     *\/\n-    public static ZoneInfoOld getCustomTimeZone(String originalId, int gmtOffset) {\n-        String id = toCustomID(gmtOffset);\n-\n-        ZoneInfoOld zi = getFromCache(id);\n-        if (zi == null) {\n-            zi = new ZoneInfoOld(id, gmtOffset);\n-            zi = addToCache(id, zi);\n-            if (!id.equals(originalId)) {\n-                zi = addToCache(originalId, zi);\n-            }\n-        }\n-        return (ZoneInfoOld) zi.clone();\n-    }\n-\n-    public static String toCustomID(int gmtOffset) {\n-        char sign;\n-        int offset = gmtOffset \/ 60000;\n-\n-        if (offset >= 0) {\n-            sign = '+';\n-        } else {\n-            sign = '-';\n-            offset = -offset;\n-        }\n-        int hh = offset \/ 60;\n-        int mm = offset % 60;\n-\n-        char[] buf = new char[] { 'G', 'M', 'T', sign, '0', '0', ':', '0', '0' };\n-        if (hh >= 10) {\n-            buf[4] += hh \/ 10;\n-        }\n-        buf[5] += hh % 10;\n-        if (mm != 0) {\n-            buf[7] += mm \/ 10;\n-            buf[8] += mm % 10;\n-        }\n-        return new String(buf);\n-    }\n-\n-    \/**\n-     * @return a ZoneInfo instance created for the specified id, or\n-     * null if there is no time zone data file found for the specified\n-     * id.\n-     *\/\n-    public static ZoneInfoOld getZoneInfoOld(String id) {\n-        \/\/treat GMT zone as special\n-        if (\"GMT\".equals(id))\n-            return (ZoneInfoOld) GMT.clone();\n-        ZoneInfoOld zi = getFromCache(id);\n-        if (zi == null) {\n-            Map<String, String> aliases = ZoneInfoOld.getCachedAliasTable();\n-            if (aliases != null && aliases.get(id) != null) {\n-                return null;\n-            }\n-            zi = createZoneInfoOld(id);\n-            if (zi == null) {\n-                return null;\n-            }\n-            zi = addToCache(id, zi);\n-        }\n-        return (ZoneInfoOld) zi.clone();\n-    }\n-\n-    synchronized static ZoneInfoOld getFromCache(String id) {\n-        if (zoneInfoObjects == null) {\n-            return null;\n-        }\n-        return zoneInfoObjects.get(id);\n-    }\n-\n-    synchronized static ZoneInfoOld addToCache(String id, ZoneInfoOld zi) {\n-        if (zoneInfoObjects == null) {\n-            zoneInfoObjects = new HashMap<>();\n-        } else {\n-            ZoneInfoOld zone = zoneInfoObjects.get(id);\n-            if (zone != null) {\n-                return zone;\n-            }\n-        }\n-        zoneInfoObjects.put(id, zi);\n-        return zi;\n-    }\n-\n-    private static ZoneInfoOld createZoneInfoOld(String id) {\n-        byte[] buf = readZoneInfoFile(getFileName(id));\n-        if (buf == null) {\n-            return null;\n-        }\n-\n-        int index = 0;\n-        int filesize = buf.length;\n-        int rawOffset = 0;\n-        int dstSavings = 0;\n-        int checksum = 0;\n-        boolean willGMTOffsetChange = false;\n-        long[] transitions = null;\n-        int[] offsets = null;\n-        int[] simpleTimeZoneParams = null;\n-\n-        try {\n-            for (index = 0; index < JAVAZI_LABEL.length; index++) {\n-                if (buf[index] != JAVAZI_LABEL[index]) {\n-                    System.err.println(\"ZoneInfoOld: wrong magic number: \" + id);\n-                    return null;\n-                }\n-            }\n-            if (buf[index++] > JAVAZI_VERSION) {\n-                System.err.println(\"ZoneInfo: incompatible version (\"\n-                                   + buf[index - 1] + \"): \" + id);\n-                return null;\n-            }\n-\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int  len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                if (filesize < index+len) {\n-                    break;\n-                }\n-\n-                switch (tag) {\n-                case TAG_CRC32:\n-                    {\n-                        int val = buf[index++] & 0xff;\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        checksum = val;\n-                    }\n-                    break;\n-\n-                case TAG_LastDSTSaving:\n-                    {\n-                        short val = (short)(buf[index++] & 0xff);\n-                        val = (short)((val << 8) + (buf[index++] & 0xff));\n-                        dstSavings = val * 1000;\n-                    }\n-                    break;\n-\n-                case TAG_RawOffset:\n-                    {\n-                        int val = buf[index++] & 0xff;\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        rawOffset = val;\n-                    }\n-                    break;\n-\n-                case TAG_Transition:\n-                    {\n-                        int n = len \/ 8;\n-                        transitions = new long[n];\n-                        for (int i = 0; i < n; i ++) {\n-                            long val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            transitions[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_Offset:\n-                    {\n-                        int n = len \/ 4;\n-                        offsets = new int[n];\n-                        for (int i = 0; i < n; i ++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            offsets[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_SimpleTimeZone:\n-                    {\n-                        if (len != 32 && len != 40) {\n-                            System.err.println(\"ZoneInfo: wrong SimpleTimeZone parameter size\");\n-                            return null;\n-                        }\n-                        int n = len \/ 4;\n-                        simpleTimeZoneParams = new int[n];\n-                        for (int i = 0; i < n; i++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            simpleTimeZoneParams[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_GMTOffsetWillChange:\n-                    {\n-                        if (len != 1) {\n-                            System.err.println(\"ZoneInfo: wrong byte length for TAG_GMTOffsetWillChange\");\n-                        }\n-                        willGMTOffsetChange = buf[index++] == 1;\n-                    }\n-                    break;\n-\n-                default:\n-                    System.err.println(\"ZoneInfo: unknown tag < \" + tag + \">. ignored.\");\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfo: corrupted zoneinfo file: \" + id);\n-            return null;\n-        }\n-\n-        if (index != filesize) {\n-            System.err.println(\"ZoneInfo: wrong file size: \" + id);\n-            return null;\n-        }\n-\n-        return new ZoneInfoOld(id, rawOffset, dstSavings, checksum,\n-                            transitions, offsets, simpleTimeZoneParams,\n-                            willGMTOffsetChange);\n-    }\n-\n-    private volatile static SoftReference<List<String>> zoneIDs = null;\n-\n-    static List<String> getZoneIDs() {\n-        List<String> ids = null;\n-        SoftReference<List<String>> cache = zoneIDs;\n-        if (cache != null) {\n-            ids = cache.get();\n-            if (ids != null) {\n-                return ids;\n-            }\n-        }\n-        byte[] buf = null;\n-        buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ZoneIDs:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        ids = new ArrayList<>(n);\n-\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            ids.add(new String(buf, index, m, \"UTF-8\"));\n-                            index += m;\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        zoneIDs = new SoftReference<>(ids);\n-        return ids;\n-    }\n-\n-    \/**\n-     * @return an alias table in HashMap where a key is an alias ID\n-     * (e.g., \"PST\") and its value is a real time zone ID (e.g.,\n-     * \"America\/Los_Angeles\").\n-     *\/\n-    static Map<String, String> getZoneAliases() {\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-        Map<String, String> aliases = null;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ZoneAliases:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        aliases = new HashMap<>(n);\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            String name = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            m = buf[index++];\n-                            String realName = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            aliases.put(name, realName);\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-        return aliases;\n-    }\n-\n-    private volatile static SoftReference<List<String>> excludedIDs = null;\n-    private volatile static boolean hasNoExcludeList = false;\n-\n-    \/**\n-     * @return a List of zone IDs for zones that will change their GMT\n-     * offsets in some future time.\n-     *\n-     * @since 1.6\n-     *\/\n-    static List<String> getExcludedZones() {\n-        if (hasNoExcludeList) {\n-            return null;\n-        }\n-\n-        List<String> excludeList = null;\n-\n-        SoftReference<List<String>> cache = excludedIDs;\n-        if (cache != null) {\n-            excludeList = cache.get();\n-            if (excludeList != null) {\n-                return excludeList;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-          loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ExcludedZones:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        excludeList = new ArrayList<>();\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            String name = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            excludeList.add(name);\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-\n-        if (excludeList != null) {\n-            excludedIDs = new SoftReference<>(excludeList);\n-        } else {\n-            hasNoExcludeList = true;\n-        }\n-        return excludeList;\n-    }\n-\n-    private volatile static SoftReference<byte[]> rawOffsetIndices = null;\n-\n-    static byte[] getRawOffsetIndices() {\n-        byte[] indices = null;\n-\n-        SoftReference<byte[]> cache = rawOffsetIndices;\n-        if (cache != null) {\n-            indices = cache.get();\n-            if (indices != null) {\n-                return indices;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_RawOffsetIndices:\n-                    {\n-                        indices = new byte[len];\n-                        for (int i = 0; i < len; i++) {\n-                            indices[i] = buf[index++];\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        rawOffsetIndices = new SoftReference<>(indices);\n-        return indices;\n-    }\n-\n-    private volatile static SoftReference<int[]> rawOffsets = null;\n-\n-    static int[] getRawOffsets() {\n-        int[] offsets = null;\n-\n-        SoftReference<int[]> cache = rawOffsets;\n-        if (cache != null) {\n-            offsets = cache.get();\n-            if (offsets != null) {\n-                return offsets;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_RawOffsets:\n-                    {\n-                        int n = len\/4;\n-                        offsets = new int[n];\n-                        for (int i = 0; i < n; i++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            offsets[i] = val;\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        rawOffsets = new SoftReference<>(offsets);\n-        return offsets;\n-    }\n-\n-    private volatile static SoftReference<byte[]> zoneInfoMappings = null;\n-\n-    private static byte[] getZoneInfoOldMappings() {\n-        byte[] data;\n-        SoftReference<byte[]> cache = zoneInfoMappings;\n-        if (cache != null) {\n-            data = cache.get();\n-            if (data != null) {\n-                return data;\n-            }\n-        }\n-        data = readZoneInfoFile(JAVAZM_FILE_NAME);\n-        if (data == null) {\n-            throw new RuntimeException(\"ZoneInfoOldMapping \" +\n-                JAVAZM_FILE_NAME + \" either doesn't exist or doesn't have data\");\n-        }\n-\n-        int index;\n-        for (index = 0; index < JAVAZM_LABEL.length; index++) {\n-            if (data[index] != JAVAZM_LABEL[index]) {\n-                System.err.println(\"ZoneInfoOld: wrong magic number: \" + JAVAZM_FILE_NAME);\n-                return null;\n-            }\n-        }\n-        if (data[index++] > JAVAZM_VERSION) {\n-            System.err.println(\"ZoneInfoOld: incompatible version (\"\n-                               + data[index - 1] + \"): \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-\n-        zoneInfoMappings = new SoftReference<>(data);\n-        return data;\n-    }\n-\n-    \/**\n-     * Reads the specified file under &lt;java.home&gt;\/lib\/zi into a buffer.\n-     * @return the buffer, or null if any I\/O error occurred.\n-     *\/\n-    private static byte[] readZoneInfoFile(final String fileName) {\n-        if (fileName.indexOf(\"..\") >= 0) {\n-            return null;\n-        }\n-        byte[] buffer = null;\n-        File file = new File(ziDir, fileName);\n-        try {\n-            int filesize = (int)file.length();\n-            if (filesize > 0) {\n-                FileInputStream fis = new FileInputStream(file);\n-                buffer = new byte[filesize];\n-                try {\n-                    if (fis.read(buffer) != filesize) {\n-                        throw new IOException(\"read error on \" + fileName);\n-                    }\n-                } finally {\n-                    fis.close();\n-                }\n-            }\n-        } catch (Exception ex) {\n-            if (!(ex instanceof FileNotFoundException) || JAVAZM_FILE_NAME.equals(fileName)) {\n-                System.err.println(\"ZoneInfoOld: \" + ex.getMessage());\n-            }\n-        }\n-        return buffer;\n-    }\n-\n-    private ZoneInfoFile() {\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoFile.java","additions":0,"deletions":1049,"binary":false,"changes":1049,"status":"deleted"},{"patch":"@@ -1,1022 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.lang.ref.SoftReference;\n-import java.time.ZoneOffset;\n-import java.time.LocalDateTime;\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.SimpleTimeZone;\n-import java.util.TimeZone;\n-\n-import sun.util.calendar.CalendarSystem;\n-import sun.util.calendar.CalendarDate;\n-\n-\/**\n- * <code>ZoneInfoOld<\/code> is an implementation subclass of {@link\n- * java.util.TimeZone TimeZone} that represents GMT offsets and\n- * daylight saving time transitions of a time zone.\n- * <p>\n- * The daylight saving time transitions are described in the {@link\n- * #transitions transitions} table consisting of a chronological\n- * sequence of transitions of GMT offset and\/or daylight saving time\n- * changes. Since all transitions are represented in UTC, in theory,\n- * <code>ZoneInfoOld<\/code> can be used with any calendar systems except\n- * for the {@link #getOffset(int,int,int,int,int,int) getOffset}\n- * method that takes Gregorian calendar date fields.\n- * <p>\n- * This table covers transitions from 1900 until 2100 (as of version\n- * 23), Before 1900, it assumes that there was no daylight saving\n- * time and the <code>getOffset<\/code> methods always return the\n- * {@link #getRawOffset} value. No Local Mean Time is supported. If a\n- * specified date is beyond the transition table and this time zone is\n- * supposed to observe daylight saving time in 2100, it delegates\n- * operations to a {@link java.util.SimpleTimeZone SimpleTimeZone}\n- * object created using the daylight saving time schedule as of 2100.\n- * <p>\n- * The date items, transitions, GMT offset(s), etc. are read from a database\n- * file. See {@link ZoneInfoFile} for details.\n- * @see java.util.SimpleTimeZone\n- * @since 1.4\n- *\/\n-\n-public class ZoneInfoOld extends TimeZone {\n-\n-    \/\/ The constants assume no leap seconds support.\n-    static final int SECOND_IN_MILLIS = 1000;\n-    static final int MINUTE_IN_MILLIS = SECOND_IN_MILLIS * 60;\n-    static final int HOUR_IN_MILLIS = MINUTE_IN_MILLIS * 60;\n-    static final int DAY_IN_MILLIS = HOUR_IN_MILLIS * 24;\n-\n-    private static final int UTC_TIME = 0;\n-    private static final int STANDARD_TIME = 1;\n-    private static final int WALL_TIME = 2;\n-\n-    private static final long OFFSET_MASK = 0x0fL;\n-    private static final long DST_MASK = 0xf0L;\n-    private static final int DST_NSHIFT = 4;\n-    \/\/ this bit field is reserved for abbreviation support\n-    private static final long ABBR_MASK = 0xf00L;\n-    private static final int TRANSITION_NSHIFT = 12;\n-\n-    \/\/ IDs having conflicting data between Olson and JDK 1.1\n-    static final Map<String, String> conflictingIDs = Map.of(\n-        \"EST\", \"America\/Panama\",\n-        \"MST\", \"America\/Phoenix\");\n-\n-    private static final CalendarSystem gcal = CalendarSystem.getGregorianCalendar();\n-\n-    \/**\n-     * The raw GMT offset in milliseconds between this zone and GMT.\n-     * Negative offsets are to the west of Greenwich.  To obtain local\n-     * <em>standard<\/em> time, add the offset to GMT time.\n-     * @serial\n-     *\/\n-    int rawOffset;\n-\n-    \/**\n-     * Difference in milliseconds from the original GMT offset in case\n-     * the raw offset value has been modified by calling {@link\n-     * #setRawOffset}. The initial value is 0.\n-     * @serial\n-     *\/\n-    int rawOffsetDiff = 0;\n-\n-    \/**\n-     * A CRC32 value of all pairs of transition time (in milliseconds\n-     * in <code>long<\/code>) in local time and its GMT offset (in\n-     * seconds in <code>int<\/code>) in the chronological order. Byte\n-     * values of each <code>long<\/code> and <code>int<\/code> are taken\n-     * in the big endian order (i.e., MSB to LSB).\n-     * @serial\n-     *\/\n-    int checksum;\n-\n-    \/**\n-     * The amount of time in milliseconds saved during daylight saving\n-     * time. If <code>useDaylight<\/code> is false, this value is 0.\n-     * @serial\n-     *\/\n-    int dstSavings;\n-\n-    \/**\n-     * This array describes transitions of GMT offsets of this time\n-     * zone, including both raw offset changes and daylight saving\n-     * time changes.\n-     * A long integer consists of four bit fields.\n-     * <ul>\n-     * <li>The most significant 52-bit field represents transition\n-     * time in milliseconds from Gregorian January 1 1970, 00:00:00\n-     * GMT.<\/li>\n-     * <li>The next 4-bit field is reserved and must be 0.<\/li>\n-     * <li>The next 4-bit field is an index value to {@link #offsets\n-     * offsets[]} for the amount of daylight saving at the\n-     * transition. If this value is zero, it means that no daylight\n-     * saving, not the index value zero.<\/li>\n-     * <li>The least significant 4-bit field is an index value to\n-     * {@link #offsets offsets[]} for <em>total<\/em> GMT offset at the\n-     * transition.<\/li>\n-     * <\/ul>\n-     * If this time zone doesn't observe daylight saving time and has\n-     * never changed any GMT offsets in the past, this value is null.\n-     * @serial\n-     *\/\n-    long[] transitions;\n-\n-    \/**\n-     * This array holds all unique offset values in\n-     * milliseconds. Index values to this array are stored in the\n-     * transitions array elements.\n-     * @serial\n-     *\/\n-    int[] offsets;\n-\n-    \/**\n-     * SimpleTimeZone parameter values. It has to have either 8 for\n-     * {@link java.util.SimpleTimeZone#SimpleTimeZone(int, String,\n-     * int, int , int , int , int , int , int , int , int) the\n-     * 11-argument SimpleTimeZone constructor} or 10 for {@link\n-     * java.util.SimpleTimeZone#SimpleTimeZone(int, String, int, int,\n-     * int , int , int , int , int , int , int, int, int) the\n-     * 13-argument SimpleTimeZone constructor} parameters.\n-     * @serial\n-     *\/\n-    int[] simpleTimeZoneParams;\n-\n-    \/**\n-     * True if the raw GMT offset value would change after the time\n-     * zone data has been generated; false, otherwise. The default\n-     * value is false.\n-     * @serial\n-     *\/\n-    boolean willGMTOffsetChange = false;\n-\n-    \/**\n-     * True if the object has been modified after its instantiation.\n-     *\/\n-    transient private boolean dirty = false;\n-\n-    private static final long serialVersionUID = 2653134537216586139L;\n-\n-    \/**\n-     * A constructor.\n-     *\/\n-    public ZoneInfoOld() {\n-    }\n-\n-    \/**\n-     * A Constructor for CustomID.\n-     *\/\n-    public ZoneInfoOld(String ID, int rawOffset) {\n-        this(ID, rawOffset, 0, 0, null, null, null, false);\n-    }\n-\n-    \/**\n-     * Constructs a ZoneInfoOld instance.\n-     *\n-     * @param ID time zone name\n-     * @param rawOffset GMT offset in milliseconds\n-     * @param dstSavings daylight saving value in milliseconds or 0\n-     * (zero) if this time zone doesn't observe Daylight Saving Time.\n-     * @param checksum CRC32 value with all transitions table entry\n-     * values\n-     * @param transitions transition table\n-     * @param offsets offset value table\n-     * @param simpleTimeZoneParams parameter values for constructing\n-     * SimpleTimeZone\n-     * @param willGMTOffsetChange the value of willGMTOffsetChange\n-     *\/\n-    ZoneInfoOld(String ID,\n-             int rawOffset,\n-             int dstSavings,\n-             int checksum,\n-             long[] transitions,\n-             int[] offsets,\n-             int[] simpleTimeZoneParams,\n-             boolean willGMTOffsetChange) {\n-        setID(ID);\n-        this.rawOffset = rawOffset;\n-        this.dstSavings = dstSavings;\n-        this.checksum = checksum;\n-        this.transitions = transitions;\n-        this.offsets = offsets;\n-        this.simpleTimeZoneParams = simpleTimeZoneParams;\n-        this.willGMTOffsetChange = willGMTOffsetChange;\n-    }\n-\n-    \/**\n-     * Returns the difference in milliseconds between local time and UTC\n-     * of given time, taking into account both the raw offset and the\n-     * effect of daylight savings.\n-     *\n-     * @param date the milliseconds in UTC\n-     * @return the milliseconds to add to UTC to get local wall time\n-     *\/\n-    public int getOffset(long date) {\n-        return getOffsets(date, null, UTC_TIME);\n-    }\n-\n-    public int getOffsets(long utc, int[] offsets) {\n-        return getOffsets(utc, offsets, UTC_TIME);\n-    }\n-\n-    public int getOffsetsByStandard(long standard, int[] offsets) {\n-        return getOffsets(standard, offsets, STANDARD_TIME);\n-    }\n-\n-    public int getOffsetsByWall(long wall, int[] offsets) {\n-        return getOffsets(wall, offsets, WALL_TIME);\n-    }\n-\n-    private int getOffsets(long date, int[] offsets, int type) {\n-        \/\/ if dst is never observed, there is no transition.\n-        if (transitions == null) {\n-            int offset = getLastRawOffset();\n-            if (offsets != null) {\n-                offsets[0] = offset;\n-                offsets[1] = 0;\n-            }\n-            return offset;\n-        }\n-\n-        date -= rawOffsetDiff;\n-        int index = getTransitionIndex(date, type);\n-\n-        \/\/ prior to the transition table, returns the raw offset.\n-        \/\/ FIXME: should support LMT.\n-        if (index < 0) {\n-            int offset = getLastRawOffset();\n-            if (offsets != null) {\n-                offsets[0] = offset;\n-                offsets[1] = 0;\n-            }\n-            return offset;\n-        }\n-\n-        if (index < transitions.length) {\n-            long val = transitions[index];\n-            int offset = this.offsets[(int)(val & OFFSET_MASK)] + rawOffsetDiff;\n-            if (offsets != null) {\n-                int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                int save = (dst == 0) ? 0 : this.offsets[dst];\n-                offsets[0] = offset - save;\n-                offsets[1] = save;\n-            }\n-            return offset;\n-        }\n-\n-        \/\/ beyond the transitions, delegate to SimpleTimeZone if there\n-        \/\/ is a rule; otherwise, return rawOffset.\n-        SimpleTimeZone tz = getLastRule();\n-        if (tz != null) {\n-            int rawoffset = tz.getRawOffset();\n-            long msec = date;\n-            if (type != UTC_TIME) {\n-                msec -= rawOffset;\n-            }\n-            int dstoffset = tz.getOffset(msec) - rawOffset;\n-\n-            \/\/ Check if it's in a standard-to-daylight transition.\n-            if (dstoffset > 0 && tz.getOffset(msec - dstoffset) == rawoffset) {\n-                dstoffset = 0;\n-            }\n-\n-            if (offsets != null) {\n-                offsets[0] = rawoffset;\n-                offsets[1] = dstoffset;\n-            }\n-            return rawoffset + dstoffset;\n-        }\n-        int offset = getLastRawOffset();\n-        if (offsets != null) {\n-            offsets[0] = offset;\n-            offsets[1] = 0;\n-        }\n-        return offset;\n-    }\n-\n-    private int getTransitionIndex(long date, int type) {\n-        int low = 0;\n-        int high = transitions.length - 1;\n-\n-        while (low <= high) {\n-            int mid = (low + high) \/ 2;\n-            long val = transitions[mid];\n-            long midVal = val >> TRANSITION_NSHIFT; \/\/ sign extended\n-            if (type != UTC_TIME) {\n-                midVal += offsets[(int)(val & OFFSET_MASK)]; \/\/ wall time\n-            }\n-            if (type == STANDARD_TIME) {\n-                int dstIndex = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                if (dstIndex != 0) {\n-                    midVal -= offsets[dstIndex]; \/\/ make it standard time\n-                }\n-            }\n-\n-            if (midVal < date) {\n-                low = mid + 1;\n-            } else if (midVal > date) {\n-                high = mid - 1;\n-            } else {\n-                return mid;\n-            }\n-        }\n-\n-        \/\/ if beyond the transitions, returns that index.\n-        if (low >= transitions.length) {\n-            return low;\n-        }\n-        return low - 1;\n-    }\n-\n-   \/**\n-     * Returns the difference in milliseconds between local time and\n-     * UTC, taking into account both the raw offset and the effect of\n-     * daylight savings, for the specified date and time.  This method\n-     * assumes that the start and end month are distinct.  This method\n-     * assumes a Gregorian calendar for calculations.\n-     * <p>\n-     * <em>Note: In general, clients should use\n-     * {@link Calendar#ZONE_OFFSET Calendar.get(ZONE_OFFSET)} +\n-     * {@link Calendar#DST_OFFSET Calendar.get(DST_OFFSET)}\n-     * instead of calling this method.<\/em>\n-     *\n-     * @param era       The era of the given date. The value must be either\n-     *                  GregorianCalendar.AD or GregorianCalendar.BC.\n-     * @param year      The year in the given date.\n-     * @param month     The month in the given date. Month is 0-based. e.g.,\n-     *                  0 for January.\n-     * @param day       The day-in-month of the given date.\n-     * @param dayOfWeek The day-of-week of the given date.\n-     * @param millis    The milliseconds in day in <em>standard<\/em> local time.\n-     * @return The milliseconds to add to UTC to get local time.\n-     *\/\n-    public int getOffset(int era, int year, int month, int day,\n-                         int dayOfWeek, int milliseconds) {\n-        if (milliseconds < 0 || milliseconds >= DAY_IN_MILLIS) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (era == java.util.GregorianCalendar.BC) { \/\/ BC\n-            year = 1 - year;\n-        } else if (era != java.util.GregorianCalendar.AD) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        CalendarDate date = gcal.newCalendarDate(null);\n-        date.setDate(year, month + 1, day);\n-        if (gcal.validate(date) == false) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        \/\/ bug-for-bug compatible argument checking\n-        if (dayOfWeek < java.util.GregorianCalendar.SUNDAY\n-            || dayOfWeek > java.util.GregorianCalendar.SATURDAY) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (transitions == null) {\n-            return getLastRawOffset();\n-        }\n-\n-        long dateInMillis = gcal.getTime(date) + milliseconds;\n-        dateInMillis -= (long) rawOffset; \/\/ make it UTC\n-        return getOffsets(dateInMillis, null, UTC_TIME);\n-    }\n-\n-    \/**\n-     * Sets the base time zone offset from GMT. This operation\n-     * modifies all the transitions of this ZoneInfoOld object, including\n-     * historical ones, if applicable.\n-     *\n-     * @param offsetMillis the base time zone offset to GMT.\n-     * @see getRawOffset\n-     *\/\n-    public synchronized void setRawOffset(int offsetMillis) {\n-        if (offsetMillis == rawOffset + rawOffsetDiff) {\n-            return;\n-        }\n-        rawOffsetDiff = offsetMillis - rawOffset;\n-        if (lastRule != null) {\n-            lastRule.setRawOffset(offsetMillis);\n-        }\n-        dirty = true;\n-    }\n-\n-    \/**\n-     * Returns the GMT offset of the current date. This GMT offset\n-     * value is not modified during Daylight Saving Time.\n-     *\n-     * @return the GMT offset value in milliseconds to add to UTC time\n-     * to get local standard time\n-     *\/\n-    public int getRawOffset() {\n-        if (!willGMTOffsetChange) {\n-            return rawOffset + rawOffsetDiff;\n-        }\n-\n-        int[] offsets = new int[2];\n-        getOffsets(System.currentTimeMillis(), offsets, UTC_TIME);\n-        return offsets[0];\n-    }\n-\n-    public boolean isDirty() {\n-        return dirty;\n-    }\n-\n-    int getLastRawOffset() {\n-        return rawOffset + rawOffsetDiff;\n-    }\n-\n-    \/**\n-     * Queries if this time zone uses Daylight Saving Time in the last known rule.\n-     *\/\n-    public boolean useDaylightTime() {\n-        return (simpleTimeZoneParams != null);\n-    }\n-\n-    @Override\n-    public boolean observesDaylightTime() {\n-        if (simpleTimeZoneParams != null) {\n-            return true;\n-        }\n-        if (transitions == null) {\n-            return false;\n-        }\n-\n-        \/\/ Look up the transition table to see if it's in DST right\n-        \/\/ now or if there's any standard-to-daylight transition at\n-        \/\/ any future.\n-        long utc = System.currentTimeMillis() - rawOffsetDiff;\n-        int index = getTransitionIndex(utc, UTC_TIME);\n-\n-        \/\/ before transitions in the transition table\n-        if (index < 0) {\n-            return false;\n-        }\n-\n-        \/\/ the time is in the table range.\n-        for (int i = index; i < transitions.length; i++) {\n-            if ((transitions[i] & DST_MASK) != 0) {\n-                return true;\n-            }\n-        }\n-        \/\/ No further DST is observed.\n-        return false;\n-    }\n-\n-    \/**\n-     * Queries if the specified date is in Daylight Saving Time.\n-     *\/\n-    public boolean inDaylightTime(Date date) {\n-        if (date == null) {\n-            throw new NullPointerException();\n-        }\n-\n-        if (transitions == null) {\n-            return false;\n-        }\n-\n-        long utc = date.getTime() - rawOffsetDiff;\n-        int index = getTransitionIndex(utc, UTC_TIME);\n-\n-        \/\/ before transitions in the transition table\n-        if (index < 0) {\n-            return false;\n-        }\n-\n-        \/\/ the time is in the table range.\n-        if (index < transitions.length) {\n-            return (transitions[index] & DST_MASK) != 0;\n-        }\n-\n-        \/\/ beyond the transition table\n-        SimpleTimeZone tz = getLastRule();\n-        if (tz != null) {\n-            return tz.inDaylightTime(date);\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns the amount of time in milliseconds that the clock is advanced\n-     * during daylight saving time is in effect in its last daylight saving time rule.\n-     *\n-     * @return the number of milliseconds the time is advanced with respect to\n-     * standard time when daylight saving time is in effect.\n-     *\/\n-    public int getDSTSavings() {\n-        return dstSavings;\n-    }\n-\n-\/\/    \/**\n-\/\/     * @return the last year in the transition table or -1 if this\n-\/\/     * time zone doesn't observe any daylight saving time.\n-\/\/     *\/\n-\/\/    public int getMaxTransitionYear() {\n-\/\/      if (transitions == null) {\n-\/\/          return -1;\n-\/\/      }\n-\/\/      long val = transitions[transitions.length - 1];\n-\/\/      int offset = this.offsets[(int)(val & OFFSET_MASK)] + rawOffsetDiff;\n-\/\/      val = (val >> TRANSITION_NSHIFT) + offset;\n-\/\/      CalendarDate lastDate = Gregorian.getCalendarDate(val);\n-\/\/      return lastDate.getYear();\n-\/\/    }\n-\n-    \/**\n-     * Returns a string representation of this time zone.\n-     * @return the string\n-     *\/\n-    public String toString() {\n-        return getClass().getName() +\n-            \"[id=\\\"\" + getID() + \"\\\"\" +\n-            \",offset=\" + getLastRawOffset() +\n-            \",dstSavings=\" + dstSavings +\n-            \",useDaylight=\" + useDaylightTime() +\n-            \",transitions=\" + ((transitions != null) ? transitions.length : 0) +\n-            \",lastRule=\" + (lastRule == null ? getLastRuleInstance() : lastRule) +\n-            \"]\";\n-    }\n-\n-    \/**\n-     * Gets all available IDs supported in the Java run-time.\n-     *\n-     * @return an array of time zone IDs.\n-     *\/\n-    public static String[] getAvailableIDs() {\n-        List<String> idList = ZoneInfoFile.getZoneIDs();\n-        List<String> excluded = ZoneInfoFile.getExcludedZones();\n-        if (excluded != null) {\n-            \/\/ List all zones from the idList and excluded lists\n-            List<String> list = new ArrayList<>(idList.size() + excluded.size());\n-            list.addAll(idList);\n-            list.addAll(excluded);\n-            idList = list;\n-        }\n-        String[] ids = new String[idList.size()];\n-        return idList.toArray(ids);\n-    }\n-\n-    \/**\n-     * Gets all available IDs that have the same value as the\n-     * specified raw GMT offset.\n-     *\n-     * @param rawOffset the GMT offset in milliseconds. This\n-     * value should not include any daylight saving time.\n-     *\n-     * @return an array of time zone IDs.\n-     *\/\n-    public static String[] getAvailableIDs(int rawOffset) {\n-        String[] result;\n-        List<String> matched = new ArrayList<>();\n-        List<String> IDs = ZoneInfoFile.getZoneIDs();\n-        int[] rawOffsets = ZoneInfoFile.getRawOffsets();\n-\n-    loop:\n-        for (int index = 0; index < rawOffsets.length; index++) {\n-            if (rawOffsets[index] == rawOffset) {\n-                byte[] indices = ZoneInfoFile.getRawOffsetIndices();\n-                for (int i = 0; i < indices.length; i++) {\n-                    if (indices[i] == index) {\n-                        matched.add(IDs.get(i++));\n-                        while (i < indices.length && indices[i] == index) {\n-                            matched.add(IDs.get(i++));\n-                        }\n-                        break loop;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ We need to add any zones from the excluded zone list that\n-        \/\/ currently have the same GMT offset as the specified\n-        \/\/ rawOffset. The zones returned by this method may not be\n-        \/\/ correct as of return to the caller if any GMT offset\n-        \/\/ transition is happening during this GMT offset checking...\n-        List<String> excluded = ZoneInfoFile.getExcludedZones();\n-        if (excluded != null) {\n-            for (String id : excluded) {\n-                TimeZone zi = getTimeZone(id);\n-                if (zi != null && zi.getRawOffset() == rawOffset) {\n-                    matched.add(id);\n-                }\n-            }\n-        }\n-\n-        result = new String[matched.size()];\n-        matched.toArray(result);\n-        return result;\n-    }\n-\n-    \/**\n-     * Gets the ZoneInfoOld for the given ID.\n-     *\n-     * @param ID the ID for a ZoneInfoOld. See TimeZone for detail.\n-     *\n-     * @return the specified ZoneInfoOld object, or null if there is no\n-     * time zone of the ID.\n-     *\/\n-    public static TimeZone getTimeZone(String ID) {\n-        String givenID = null;\n-\n-        ZoneInfoOld zi = ZoneInfoFile.getZoneInfoOld(ID);\n-        if (zi == null) {\n-            \/\/ if we can't create an object for the ID, try aliases.\n-            try {\n-                Map<String, String> map = getAliasTable();\n-                String alias = ID;\n-                while ((alias = map.get(alias)) != null) {\n-                    zi = ZoneInfoFile.getZoneInfoOld(alias);\n-                    if (zi != null) {\n-                        zi.setID(ID);\n-                        zi = ZoneInfoFile.addToCache(ID, zi);\n-                        zi = (ZoneInfoOld) zi.clone();\n-                        break;\n-                    }\n-                }\n-            } catch (Exception e) {\n-                \/\/ ignore exceptions\n-            }\n-        }\n-\n-        if (givenID != null && zi != null) {\n-            zi.setID(givenID);\n-        }\n-        return zi;\n-    }\n-\n-    private transient SimpleTimeZone lastRule;\n-\n-    \/**\n-     * Returns a SimpleTimeZone object representing the last GMT\n-     * offset and DST schedule or null if this time zone doesn't\n-     * observe DST.\n-     *\/\n-    synchronized SimpleTimeZone getLastRule() {\n-        if (lastRule == null) {\n-            lastRule = getLastRuleInstance();\n-        }\n-        return lastRule;\n-    }\n-\n-    \/**\n-     * Returns a SimpleTimeZone object that represents the last\n-     * known daylight saving time rules.\n-     *\n-     * @return a SimpleTimeZone object or null if this time zone\n-     * doesn't observe DST.\n-     *\/\n-    public SimpleTimeZone getLastRuleInstance() {\n-        if (simpleTimeZoneParams == null) {\n-            return null;\n-        }\n-        if (simpleTimeZoneParams.length == 10) {\n-            return new SimpleTimeZone(getLastRawOffset(), getID(),\n-                                      simpleTimeZoneParams[0],\n-                                      simpleTimeZoneParams[1],\n-                                      simpleTimeZoneParams[2],\n-                                      simpleTimeZoneParams[3],\n-                                      simpleTimeZoneParams[4],\n-                                      simpleTimeZoneParams[5],\n-                                      simpleTimeZoneParams[6],\n-                                      simpleTimeZoneParams[7],\n-                                      simpleTimeZoneParams[8],\n-                                      simpleTimeZoneParams[9],\n-                                      dstSavings);\n-        }\n-        return new SimpleTimeZone(getLastRawOffset(), getID(),\n-                                  simpleTimeZoneParams[0],\n-                                  simpleTimeZoneParams[1],\n-                                  simpleTimeZoneParams[2],\n-                                  simpleTimeZoneParams[3],\n-                                  simpleTimeZoneParams[4],\n-                                  simpleTimeZoneParams[5],\n-                                  simpleTimeZoneParams[6],\n-                                  simpleTimeZoneParams[7],\n-                                  dstSavings);\n-    }\n-\n-    \/**\n-     * Returns a copy of this <code>ZoneInfoOld<\/code>.\n-     *\/\n-    public Object clone() {\n-        ZoneInfoOld zi = (ZoneInfoOld) super.clone();\n-        zi.lastRule = null;\n-        return zi;\n-    }\n-\n-    \/**\n-     * Returns a hash code value calculated from the GMT offset and\n-     * transitions.\n-     * @return a hash code of this time zone\n-     *\/\n-    public int hashCode() {\n-        return getLastRawOffset() ^ checksum;\n-    }\n-\n-    \/**\n-     * Compares the equity of two ZoneInfoOld objects.\n-     *\n-     * @param obj the object to be compared with\n-     * @return true if given object is same as this ZoneInfoOld object,\n-     * false otherwise.\n-     *\/\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (!(obj instanceof ZoneInfoOld)) {\n-            return false;\n-        }\n-        ZoneInfoOld that = (ZoneInfoOld) obj;\n-        return (getID().equals(that.getID())\n-                && (getLastRawOffset() == that.getLastRawOffset())\n-                && (checksum == that.checksum));\n-    }\n-\n-    \/**\n-     * Returns true if this zone has the same raw GMT offset value and\n-     * transition table as another zone info. If the specified\n-     * TimeZone object is not a ZoneInfoOld instance, this method returns\n-     * true if the specified TimeZone object has the same raw GMT\n-     * offset value with no daylight saving time.\n-     *\n-     * @param other the ZoneInfoOld object to be compared with\n-     * @return true if the given <code>TimeZone<\/code> has the same\n-     * GMT offset and transition information; false, otherwise.\n-     *\/\n-    public boolean hasSameRules(TimeZone other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (other == null) {\n-            return false;\n-        }\n-        if (!(other instanceof ZoneInfoOld)) {\n-            if (getRawOffset() != other.getRawOffset()) {\n-                return false;\n-            }\n-            \/\/ if both have the same raw offset and neither observes\n-            \/\/ DST, they have the same rule.\n-            if ((transitions == null)\n-                && (useDaylightTime() == false)\n-                && (other.useDaylightTime() == false)) {\n-                return true;\n-            }\n-            return false;\n-        }\n-        if (getLastRawOffset() != ((ZoneInfoOld)other).getLastRawOffset()) {\n-            return false;\n-        }\n-        return (checksum == ((ZoneInfoOld)other).checksum);\n-    }\n-\n-    private static SoftReference<Map<String, String>> aliasTable;\n-\n-    static Map<String, String> getCachedAliasTable() {\n-        Map<String, String> aliases = null;\n-\n-        SoftReference<Map<String, String>> cache = aliasTable;\n-        if (cache != null) {\n-            aliases = cache.get();\n-        }\n-        return aliases;\n-    }\n-\n-    \/**\n-     * Returns a Map from alias time zone IDs to their standard\n-     * time zone IDs.\n-     *\n-     * @return the Map that holds the mappings from alias time zone IDs\n-     *    to their standard time zone IDs, or null if\n-     *    <code>ZoneInfoOldMappings<\/code> file is not available.\n-     *\/\n-     public synchronized static Map<String, String> getAliasTable() {\n-         Map<String, String> aliases = getCachedAliasTable();\n-         if (aliases == null) {\n-             aliases = ZoneInfoFile.getZoneAliases();\n-             if (aliases != null) {\n-                 \/\/ Replace old mappings from `jdk11_backward`\n-                 aliases.putAll(conflictingIDs);\n-                 aliasTable = new SoftReference<Map<String, String>>(aliases);\n-             }\n-         }\n-         return aliases;\n-     }\n-\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        \/\/ We don't know how this object from 1.4.x or earlier has\n-        \/\/ been mutated. So it should always be marked as `dirty'.\n-        dirty = true;\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    public boolean equalsTo(ZoneInfoOld other) {\n-        return (getID().equals(other.getID())\n-                && (getLastRawOffset() == other.getLastRawOffset())\n-                && (dstSavings == other.dstSavings)\n-                && (willGMTOffsetChange == other.willGMTOffsetChange)\n-                && (checksum == other.checksum)\n-                && equalsTransOffsets(other)\n-                && (Arrays.equals(simpleTimeZoneParams, other.simpleTimeZoneParams) ||\n-                    getLastRule().equals(other.getLastRule())));\n-    }\n-\n-    private boolean equalsTransOffsets(ZoneInfoOld other) {\n-        if (transitions == null) {\n-            return (other.transitions == null &&\n-                    Arrays.equals(offsets, other.offsets));\n-        }\n-        if (other.transitions == null ||\n-            transitions.length != other.transitions.length) {\n-            return false;\n-        }\n-        \/\/ if offsets and other.offsets have different order\n-        \/\/ the last 4-bit in trans are different.\n-        for (int i = 0; i < transitions.length; i++) {\n-            long val = transitions[i];\n-            int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-            int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-            int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-            long second = (val >> TRANSITION_NSHIFT)\/1000;\n-\n-            val = other.transitions[i];\n-            int dstO = (int)((val >>> DST_NSHIFT) & 0xfL);\n-            int saveO = (dstO == 0) ? 0 : other.offsets[dstO] \/ 1000;\n-            int offO = other.offsets[(int)(val & OFFSET_MASK)]\/1000;\n-            long secondO = (val >> TRANSITION_NSHIFT)\/1000;\n-            if ((dst == 0) != (dstO == 0) || save != saveO || off != offO || second != secondO)\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private int transToString(long val, int off_old, int[] offsets, StringBuilder sb) {\n-        int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-        int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-        int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-        long second = (val >> TRANSITION_NSHIFT)\/1000;\n-        ZoneOffset offset_old = ZoneOffset.ofTotalSeconds(off_old);\n-        ZoneOffset offset = ZoneOffset.ofTotalSeconds(off);\n-        sb.append(\"          \" + LocalDateTime.ofEpochSecond(second, 0, offset_old));\n-\n-        sb.append(\"  [utc=\" + second +\n-                  \"   raw=\" + Long.toHexString(val >> TRANSITION_NSHIFT) +\n-                  \", offset=\" + off + \"\/\" + offset + \", saving=\" + save + \"]\");\n-        return off;\n-    }\n-\n-    public String diffsTo(ZoneInfoOld other) {\n-\n-        int rawOffset0                = other.rawOffset;\n-        int checksum0                 = other.checksum;\n-        int dstSavings0               = other.dstSavings;\n-        long[] transitions0           = other.transitions;\n-        int[] offsets0                = other.offsets;\n-        int[] simpleTimeZoneParams0   = other.simpleTimeZoneParams;\n-        boolean willGMTOffsetChange0  = other.willGMTOffsetChange;\n-\n-\n-        \/\/return getClass().getName() +\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"******************************\\n\" +\n-                  getID() + \" : \" + other.getID());\n-        \/\/ ROC is excluded by ZoneInfoOld\n-        if (\"ROC\".equals(getID())) {\n-            return sb.toString();\n-        }\n-        if (rawOffset != rawOffset0 ||\n-            dstSavings != dstSavings0 ||\n-            checksum != checksum0 ||\n-            willGMTOffsetChange != willGMTOffsetChange0 ||\n-            (simpleTimeZoneParams != null ) != (simpleTimeZoneParams0 != null) ||\n-            (transitions != null && transitions0 != null &&\n-            transitions.length != transitions0.length))\n-        {\n-            sb.append(\"\\n    offset=\" + getLastRawOffset() +\n-                  \",dstSavings=\" + dstSavings +\n-                  \",useDaylight=\" + useDaylightTime() +\n-                  \",transitions=\" + ((transitions != null) ? transitions.length : 0) +\n-                  \",offsets=\" + ((offsets != null) ? offsets.length : 0) +\n-                  \",checksum=\" + checksum +\n-                  \",gmtChanged=\" + willGMTOffsetChange)\n-              .append(\"\\n[NG]offset=\" + rawOffset0 +\n-                      \",dstSavings=\" + dstSavings0 +\n-                      \",useDaylight=\" + (simpleTimeZoneParams != null) +\n-                      \",transitions=\" + ((transitions0 != null) ? transitions0.length : 0) +\n-                      \",offsets=\" + ((offsets0 != null) ? offsets0.length : 0) +\n-                      \",checksum=\" + checksum0 +\n-                      \",gmtChanged=\" + willGMTOffsetChange0 +\n-                      \"\");\n-        }\n-        \/\/ offsets\n-        if (!Arrays.equals(offsets, offsets0)) {\n-            sb.append(\"\\n    offset.len=\" + ((offsets != null)? offsets.length : \"null\") +\n-                      \"    \" + ((offsets0 != null)? offsets0.length : \"null\"));\n-            if (offsets != null && offsets0.length != 0) {\n-                int len = Math.min(offsets.length, offsets0.length);\n-                int i = 0;\n-                for (i = 0; i < len; i++) {\n-                    sb.append(\"\\n        \" +\n-                              ZoneOffset.ofTotalSeconds(offsets[i]\/1000) + \"    \" +\n-                              ZoneOffset.ofTotalSeconds(offsets0[i]\/1000));\n-                }\n-                for (; i < offsets0.length; i++) {\n-                    sb.append(\"\\n                  \" + ZoneOffset.ofTotalSeconds(offsets0[i]\/1000));\n-                }\n-            }\n-        }\n-        \/\/ trans\n-        int offset = 0;\n-        int offset0 = 0;\n-        if (!equalsTransOffsets(other)) {\n-            sb.append(\"\\n    -------------\");\n-            if ((transitions == null) != (transitions0 == null)) {\n-                sb.append(\"\\n     (NG) Different trans(null) :\" +\n-                transitions + \", \" + transitions0);\n-                if (transitions != null) {\n-                    for (int i = 0; i < transitions.length; i++) {\n-                        sb.append(\"\\n    (NG)\");\n-                        offset = transToString(transitions[i], offset, offsets, sb);\n-                    }\n-                }\n-            } else {\n-                if (transitions.length != transitions0.length) {\n-                    sb.append(\"\\n    (NG) Different trans size :\" +\n-                              transitions.length + \", \" + transitions0.length);\n-                }\n-                int length = Math.min(transitions.length, transitions0.length);\n-                for (int i = 0; i < length; i++) {\n-                    \/\/ sb.append(\"\\n[\" + i + \"]    \");\n-                    \/\/ offset = transToString(transitions[i], offset, offsets, sb);\n-                    long val = transitions[i];\n-                    int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                    int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-                    int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-                    long second = (val >> TRANSITION_NSHIFT)\/1000;\n-                    sb.append(\"\\n        \");\n-                    offset = transToString(transitions[i], offset, offsets, sb);\n-                    if (transitions0 == null || i >= transitions0.length) {\n-                        sb.append(\"\\n    \");\n-                        offset = transToString(transitions[i], offset, offsets, sb);\n-                        sb.append(\"\\n     (NG) trans0 is null or < trans.length\");\n-                    } else {\n-                        long val0 = transitions0[i];\n-                        int dst0 = (int)((val0 >>> DST_NSHIFT) & 0xfL);\n-                        int save0 = (dst0 == 0) ? 0 : offsets0[dst0] \/ 1000;\n-                        int off0 = offsets0[(int)(val0 & OFFSET_MASK)]\/1000;\n-                        long second0 = (val0 >> TRANSITION_NSHIFT)\/1000;\n-                        if (save != save0 || off != off0 || second != second0) {\n-                            sb.append(\"\\n    (NG)\");\n-                        } else {\n-                            sb.append(\"\\n    (OK)\");\n-                        }\n-                        offset0 = transToString(transitions0[i], offset0, offsets0, sb);\n-                        sb.append(\"\\n            -----\");\n-                    }\n-                }\n-            }\n-        }\n-        SimpleTimeZone stz = getLastRuleInstance();\n-        if (stz != null) {\n-            SimpleTimeZone stz0 = other.getLastRule();\n-            if (!stz.hasSameRules(stz0)) {\n-                sb.append(\"\\n    -------------\")\n-                  .append(\"\\n    SimpleTimeZone (NG)\")\n-                  .append(\"\\n       stz=\" + stz)\n-                  .append(\"\\n      stz0=\" + stz0);\n-            }\n-        }\n-        sb.append(\"\\n    -------------\");\n-        return sb.toString();\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoOld.java","additions":0,"deletions":1022,"binary":false,"changes":1022,"status":"deleted"},{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * ZoneRec hold information of time zone corresponding to each text\n- * line of the \"Zone\" part.\n- *\n- * @since 1.4\n- *\/\n-class ZoneRec {\n-    private int gmtOffset;\n-    private String ruleName;\n-    private int directSave;\n-    private Rule ruleRef;\n-    private String format;\n-    private boolean hasUntil;\n-    private int untilYear;\n-    private Month untilMonth;\n-    private RuleDay untilDay;\n-    private Time untilTime;\n-    private long untilInMillis;\n-    private String line;\n-\n-    \/**\n-     * @return the \"UNTIL\" value in milliseconds\n-     *\/\n-    Time getUntilTime() {\n-        return untilTime;\n-    }\n-\n-    \/**\n-     * @return the GMT offset value in milliseconds\n-     *\/\n-    int getGmtOffset() {\n-        return gmtOffset;\n-    }\n-\n-    \/**\n-     * @return the rule name to which this zone record refers\n-     *\/\n-    String getRuleName() {\n-        return ruleName;\n-    }\n-\n-    \/**\n-     * @return the amount of saving time directly defined in the\n-     * \"RULES\/SAVE\" field.\n-     *\/\n-    int getDirectSave() {\n-        return directSave;\n-    }\n-\n-    \/**\n-     * @return true if this zone record has a reference to a rule\n-     *\/\n-    boolean hasRuleReference() {\n-        return ruleRef != null;\n-    }\n-\n-    \/**\n-     * Returns the \"FORMAT\" field string of this zone record. This\n-     * @return the \"FORMAT\" field\n-     *\/\n-    String getFormat() {\n-        return format;\n-    }\n-\n-    \/**\n-     * @return the year in the \"UNTIL\" field\n-     *\/\n-    int getUntilYear() {\n-        return untilYear;\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" field value in milliseconds from Janurary\n-     * 1, 1970 0:00 GMT.\n-     * @param currentSave the amount of daylight saving in\n-     * milliseconds that is used to adjust wall-clock time.\n-     * @return the milliseconds value of the \"UNTIL\" field\n-     *\/\n-    long getUntilTime(int currentSave) {\n-        if (untilTime.isWall()) {\n-            return untilInMillis - currentSave;\n-        }\n-        return untilInMillis;\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" time in milliseconds without adjusting GMT\n-     * offsets or daylight saving.\n-     * @return local \"UNTIL\" time in milliseconds\n-     *\/\n-    long getLocalUntilTime() {\n-        return Time.getLocalTime(untilYear,\n-                                 untilMonth,\n-                                 untilDay,\n-                                 untilTime.getTime());\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" time in milliseconds with adjusting GMT offsets and daylight saving.\n-     * @return the \"UNTIL\" time after the adjustment\n-     *\/\n-    long getLocalUntilTime(int save, int gmtOffset) {\n-        return Time.getLocalTime(untilYear,\n-                                 untilMonth,\n-                                 untilDay,\n-                                 save,\n-                                 gmtOffset,\n-                                 untilTime);\n-    }\n-\n-    \/**\n-     * @return the text line of this zone record\n-     *\/\n-    String getLine() {\n-        return line;\n-    }\n-\n-    \/**\n-     * Sets the specified text line to this zone record\n-     *\/\n-    void setLine(String line) {\n-        this.line = line;\n-    }\n-\n-    \/**\n-     * @return true if this zone record has the \"UNTIL\" field\n-     *\/\n-    boolean hasUntil() {\n-        return this.hasUntil;\n-    }\n-\n-    \/**\n-     * Adjusts the \"UNTIL\" time to GMT offset if this zone record has\n-     * it.  <code>untilTime<\/code> is not adjusted to daylight saving\n-     * in this method.\n-     *\/\n-    void adjustTime() {\n-        if (!hasUntil()) {\n-            return;\n-        }\n-        if (untilTime.isSTD() || untilTime.isWall()) {\n-            \/\/ adjust to gmt offset only here.  adjust to real\n-            \/\/ wall-clock time when tracking rules\n-            untilInMillis -= gmtOffset;\n-        }\n-    }\n-\n-    \/**\n-     * @return the reference to the Rule object\n-     *\/\n-    Rule getRuleRef() {\n-        return ruleRef;\n-    }\n-\n-    \/**\n-     * Resolves the reference to a Rule and adjusts its \"UNTIL\" time\n-     * to GMT offset.\n-     *\/\n-    void resolve(Zoneinfo zi) {\n-        if (ruleName != null && (!\"-\".equals(ruleName))) {\n-                ruleRef = zi.getRule(ruleName);\n-        }\n-        adjustTime();\n-    }\n-\n-    \/**\n-     * Parses a Zone text line that is described by a StringTokenizer.\n-     * @param tokens represents tokens of a Zone text line\n-     * @return the zone record produced by parsing the text\n-     *\/\n-    static ZoneRec parse(StringTokenizer tokens) {\n-        ZoneRec rec = new ZoneRec();\n-        try {\n-            rec.gmtOffset = (int) Time.parse(tokens.nextToken()).getTime();\n-            String token = tokens.nextToken();\n-            char c = token.charAt(0);\n-            if (c >= '0' && c <= '9') {\n-                rec.directSave = (int) Time.parse(token).getTime();\n-            } else {\n-                rec.ruleName = token;\n-            }\n-            rec.format = tokens.nextToken();\n-            if (tokens.hasMoreTokens()) {\n-                rec.hasUntil = true;\n-                rec.untilYear = Integer.parseInt(tokens.nextToken());\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilMonth = Month.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilMonth = Month.JANUARY;\n-                }\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilDay = RuleDay.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilDay = new RuleDay(1);\n-                }\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilTime = Time.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilTime = Time.parse(\"0:00\");\n-                }\n-                rec.untilInMillis = rec.getLocalUntilTime();\n-            }\n-        } catch (Exception e) {\n-            \/\/ TODO: error reporting\n-            e.printStackTrace();\n-        }\n-        return rec;\n-    }\n-\n-    private static void panic(String msg) {\n-        Main.panic(msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneRec.java","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -1,579 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Zoneinfo provides javazic compiler front-end functionality.\n- * @since 1.4\n- *\/\n-class Zoneinfo {\n-\n-    private static final int minYear = 1900;\n-    private static final int maxYear = 2100;\n-    private static final long minTime = Time.getLocalTime(minYear, Month.JANUARY, 1, 0);\n-    private static int startYear = minYear;\n-    private static int endYear = maxYear;\n-\n-    \/**\n-     * True if javazic should generate a list of SimpleTimeZone\n-     * instances for the SimpleTimeZone-based time zone support.\n-     *\/\n-    static boolean isYearForTimeZoneDataSpecified = false;\n-\n-    \/**\n-     * Zone name to Zone mappings\n-     *\/\n-    private Map<String,Zone> zones;\n-\n-    \/**\n-     * Rule name to Rule mappings\n-     *\/\n-    private Map<String,Rule> rules;\n-\n-    \/**\n-     * Alias name to real name mappings\n-     *\/\n-    private Map<String,String> aliases;\n-\n-    \/**\n-     * Constracts a Zoneinfo.\n-     *\/\n-    Zoneinfo() {\n-        zones = new HashMap<String,Zone>();\n-        rules = new HashMap<String,Rule>();\n-        aliases = new HashMap<String,String>();\n-    }\n-\n-    \/**\n-     * Adds the given zone to the list of Zones.\n-     * @param zone Zone to be added to the list.\n-     *\/\n-    void add(Zone zone) {\n-        String name = zone.getName();\n-        zones.put(name, zone);\n-    }\n-\n-    \/**\n-     * Adds the given rule to the list of Rules.\n-     * @param rule Rule to be added to the list.\n-     *\/\n-    void add(Rule rule) {\n-        String name = rule.getName();\n-        rules.put(name, rule);\n-    }\n-\n-    \/**\n-     * Puts the specifid name pair to the alias table.\n-     * @param name1 an alias time zone name\n-     * @param name2 the real time zone of the alias name\n-     *\/\n-    void putAlias(String name1, String name2) {\n-        aliases.put(name1, name2);\n-    }\n-\n-    \/**\n-     * Sets the given year for SimpleTimeZone list output.\n-     * This method is called when the -S option is specified.\n-     * @param year the year for which SimpleTimeZone list should be generated\n-     *\/\n-    static void setYear(int year) {\n-        setStartYear(year);\n-        setEndYear(year);\n-        isYearForTimeZoneDataSpecified = true;\n-    }\n-\n-    \/**\n-     * Sets the start year.\n-     * @param year the start year value\n-     * @throws IllegalArgumentException if the specified year value is\n-     * smaller than the minimum year or greater than the end year.\n-     *\/\n-    static void setStartYear(int year) {\n-        if (year < minYear || year > endYear) {\n-            throw new IllegalArgumentException(\"invalid start year specified: \" + year);\n-        }\n-        startYear = year;\n-    }\n-\n-    \/**\n-     * @return the start year value\n-     *\/\n-    static int getStartYear() {\n-        return startYear;\n-    }\n-\n-    \/**\n-     * Sets the end year.\n-     * @param year the end year value\n-     * @throws IllegalArgumentException if the specified year value is\n-     * smaller than the start year or greater than the maximum year.\n-     *\/\n-    static void setEndYear(int year) {\n-        if (year < startYear || year > maxYear) {\n-            throw new IllegalArgumentException();\n-        }\n-        endYear = year;\n-    }\n-\n-    \/**\n-     * @return the end year value\n-     *\/\n-    static int getEndYear() {\n-        return endYear;\n-    }\n-\n-    \/**\n-     * @return the minimum year value\n-     *\/\n-    static int getMinYear() {\n-        return minYear;\n-    }\n-\n-    \/**\n-     * @return the maximum year value\n-     *\/\n-    static int getMaxYear() {\n-        return maxYear;\n-    }\n-\n-    \/**\n-     * @return the alias table\n-     *\/\n-    Map<String,String> getAliases() {\n-        return aliases;\n-    }\n-\n-    \/**\n-     * @return the Zone list\n-     *\/\n-    Map<String,Zone> getZones() {\n-        return zones;\n-    }\n-\n-    \/**\n-     * @return a Zone specified by name.\n-     * @param name a zone name\n-     *\/\n-    Zone getZone(String name) {\n-        return zones.get(name);\n-    }\n-\n-    \/**\n-     * @return a Rule specified by name.\n-     * @param name a rule name\n-     *\/\n-    Rule getRule(String name) {\n-        return rules.get(name);\n-    }\n-\n-    private static String line;\n-\n-    private static int lineNum;\n-\n-    \/**\n-     * Parses the specified time zone data file and creates a Zoneinfo\n-     * that has all Rules, Zones and Links (aliases) information.\n-     * @param fname the time zone data file name\n-     * @return a Zoneinfo object\n-     *\/\n-    static Zoneinfo parse(String fname) {\n-        BufferedReader in = null;\n-        try {\n-            FileReader fr = new FileReader(fname);\n-            in = new BufferedReader(fr);\n-        } catch (FileNotFoundException e) {\n-            panic(\"can't open file: \"+fname);\n-        }\n-        Zoneinfo zi = new Zoneinfo();\n-        boolean continued = false;\n-        Zone zone = null;\n-        String l;\n-        lineNum = 0;\n-\n-        try {\n-            while ((line = in.readLine()) != null) {\n-                lineNum++;\n-                \/\/ skip blank and comment lines\n-                if (line.length() == 0 || line.charAt(0) == '#') {\n-                    continue;\n-                }\n-\n-                \/\/ trim trailing comments\n-                int rindex = line.lastIndexOf('#');\n-                if (rindex != -1) {\n-                    \/\/ take the data part of the line\n-                    l = line.substring(0, rindex);\n-                } else {\n-                    l = line;\n-                }\n-\n-                StringTokenizer tokens = new StringTokenizer(l);\n-                if (!tokens.hasMoreTokens()) {\n-                    continue;\n-                }\n-                String token = tokens.nextToken();\n-                int len = token.length();\n-\n-                if (continued || token.regionMatches(true, 0, \"Zone\", 0, len)){\n-                    if (zone == null) {\n-                        if (!tokens.hasMoreTokens()) {\n-                            panic(\"syntax error: zone no more token\");\n-                        }\n-                        token = tokens.nextToken();\n-                        \/\/ if the zone name is in \"GMT+hh\" or \"GMT-hh\"\n-                        \/\/ format, ignore it due to spec conflict.\n-                        if (token.startsWith(\"GMT+\") || token.startsWith(\"GMT-\")) {\n-                            continue;\n-                        }\n-                        zone = new Zone(token);\n-                    } else {\n-                        \/\/ no way to push the current token back...\n-                        tokens = new StringTokenizer(l);\n-                    }\n-\n-                    ZoneRec zrec = ZoneRec.parse(tokens);\n-                    zrec.setLine(line);\n-                    zone.add(zrec);\n-                    if ((continued = zrec.hasUntil()) == false) {\n-                        if (Zone.isTargetZone(zone.getName())) {\n-                            \/\/ zone.resolve(zi);\n-                            zi.add(zone);\n-                        }\n-                        zone = null;\n-                    }\n-                } else if (token.regionMatches(true, 0, \"Rule\", 0, len)) {\n-                    if (!tokens.hasMoreTokens()) {\n-                        panic(\"syntax error: rule no more token\");\n-                    }\n-                    token = tokens.nextToken();\n-                    Rule rule = zi.getRule(token);\n-                    if (rule == null) {\n-                        rule = new Rule(token);\n-                        zi.add(rule);\n-                    }\n-                    RuleRec rrec = RuleRec.parse(tokens);\n-                    rrec.setLine(line);\n-                    rule.add(rrec);\n-                } else if (token.regionMatches(true, 0, \"Link\", 0, len)) {\n-                    \/\/ Link <newname> <oldname>\n-                    try {\n-                        String name1 = tokens.nextToken();\n-                        String name2 = tokens.nextToken();\n-\n-                        \/\/ if the zone name is in \"GMT+hh\" or \"GMT-hh\"\n-                        \/\/ format, ignore it due to spec conflict with\n-                        \/\/ custom time zones. Also, ignore \"ROC\" for\n-                        \/\/ PC-ness.\n-                        if (name2.startsWith(\"GMT+\") || name2.startsWith(\"GMT-\")\n-                            || \"ROC\".equals(name2)) {\n-                            continue;\n-                        }\n-                        zi.putAlias(name2, name1);\n-                    } catch (Exception e) {\n-                        panic(\"syntax error: no more token for Link\");\n-                    }\n-                }\n-            }\n-            in.close();\n-        } catch (IOException ex) {\n-            panic(\"IO error: \" + ex.getMessage());\n-        }\n-\n-        return zi;\n-    }\n-\n-    \/**\n-     * Interprets a zone and constructs a Timezone object that\n-     * contains enough information on GMT offsets and DST schedules to\n-     * generate a zone info database.\n-     *\n-     * @param zoneName the zone name for which a Timezone object is\n-     * constructed.\n-     *\n-     * @return a Timezone object that contains all GMT offsets and DST\n-     * rules information.\n-     *\/\n-    Timezone phase2(String zoneName) {\n-        Timezone tz = new Timezone(zoneName);\n-        Zone zone = getZone(zoneName);\n-        zone.resolve(this);\n-\n-        \/\/ TODO: merge phase2's for the regular and SimpleTimeZone ones.\n-        if (isYearForTimeZoneDataSpecified) {\n-            ZoneRec zrec = zone.get(zone.size()-1);\n-            tz.setLastZoneRec(zrec);\n-            tz.setRawOffset(zrec.getGmtOffset());\n-            if (zrec.hasRuleReference()) {\n-                \/*\n-                 * This part assumes that the specified year is covered by\n-                 * the rules referred to by the last zone record.\n-                 *\/\n-                List<RuleRec> rrecs = zrec.getRuleRef().getRules(startYear);\n-\n-                if (rrecs.size() == 2) {\n-                    \/\/ make sure that one is a start rule and the other is\n-                    \/\/ an end rule.\n-                    RuleRec r0 = rrecs.get(0);\n-                    RuleRec r1 = rrecs.get(1);\n-                    if (r0.getSave() == 0 && r1.getSave() > 0) {\n-                        rrecs.set(0, r1);\n-                        rrecs.set(1, r0);\n-                    } else if (!(r0.getSave() > 0 && r1.getSave() == 0)) {\n-                        rrecs = null;\n-                        Main.error(zoneName + \": rules for \" +  startYear + \" not found.\");\n-                    }\n-                } else {\n-                    rrecs = null;\n-                }\n-                if (rrecs != null) {\n-                    tz.setLastRules(rrecs);\n-                }\n-            }\n-            return tz;\n-        }\n-\n-        int gmtOffset;\n-        int year = minYear;\n-        int fromYear = year;\n-        long fromTime = Time.getLocalTime(startYear,\n-                                          Month.JANUARY,\n-                                          1, 0);\n-\n-        \/\/ take the index 0 for the GMT offset of the last zone record\n-        ZoneRec zrec = zone.get(zone.size()-1);\n-        tz.getOffsetIndex(zrec.getGmtOffset());\n-\n-        int lastGmtOffsetValue = -1;\n-        ZoneRec prevzrec = null;\n-        int currentSave = 0;\n-        boolean usedZone;\n-        for (int zindex = 0; zindex < zone.size(); zindex++) {\n-            zrec = zone.get(zindex);\n-            usedZone = false;\n-            gmtOffset = zrec.getGmtOffset();\n-            int stdOffset = zrec.getDirectSave();\n-\n-            if (gmtOffset != lastGmtOffsetValue) {\n-                tz.setRawOffset(gmtOffset, fromTime);\n-                lastGmtOffsetValue = gmtOffset;\n-            }\n-            \/\/ If this is the last zone record, take the last rule info.\n-            if (!zrec.hasUntil()) {\n-                if (zrec.hasRuleReference()) {\n-                    tz.setLastRules(zrec.getRuleRef().getLastRules());\n-                } else if (stdOffset != 0) {\n-                    \/\/ in case the last rule is all year round DST-only\n-                    \/\/ (Asia\/Amman once announced this rule.)\n-                    tz.setLastDSTSaving(stdOffset);\n-                }\n-            }\n-            if (!zrec.hasRuleReference()) {\n-                if (!zrec.hasUntil() || zrec.getUntilTime(stdOffset) >= fromTime) {\n-                    tz.addTransition(fromTime,\n-                                     tz.getOffsetIndex(gmtOffset+stdOffset),\n-                                     tz.getDstOffsetIndex(stdOffset));\n-                    usedZone = true;\n-                }\n-                currentSave = stdOffset;\n-                \/\/ optimization in case the last rule is fixed.\n-                if (!zrec.hasUntil()) {\n-                    if (tz.getNTransitions() > 0) {\n-                        if (stdOffset == 0) {\n-                            tz.setDSTType(Timezone.X_DST);\n-                        } else {\n-                            tz.setDSTType(Timezone.LAST_DST);\n-                        }\n-                        long time = Time.getLocalTime(maxYear,\n-                                                      Month.JANUARY, 1, 0);\n-                        time -= zrec.getGmtOffset();\n-                        tz.addTransition(time,\n-                                         tz.getOffsetIndex(gmtOffset+stdOffset),\n-                                         tz.getDstOffsetIndex(stdOffset));\n-                        tz.addUsedRec(zrec);\n-                    } else {\n-                        tz.setDSTType(Timezone.NO_DST);\n-                    }\n-                    break;\n-                }\n-            } else {\n-                Rule rule = zrec.getRuleRef();\n-                boolean fromTimeUsed = false;\n-                currentSave = 0;\n-            year_loop:\n-                for (year = getMinYear(); year <= endYear; year++) {\n-                    if (zrec.hasUntil() && year > zrec.getUntilYear()) {\n-                        break;\n-                    }\n-                    List<RuleRec> rules = rule.getRules(year);\n-                    if (rules.size() > 0) {\n-                        for (int i = 0; i < rules.size(); i++) {\n-                            RuleRec rrec = rules.get(i);\n-                            long transition = rrec.getTransitionTime(year,\n-                                                                     gmtOffset,\n-                                                                     currentSave);\n-                            if (zrec.hasUntil()) {\n-                                if (transition >= zrec.getUntilTime(currentSave)) {\n-                                    \/\/ If the GMT offset changed from the previous one,\n-                                    \/\/ record fromTime as a transition.\n-                                    if (!fromTimeUsed && prevzrec != null\n-                                        && gmtOffset != prevzrec.getGmtOffset()) {\n-                                        tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                         tz.getDstOffsetIndex(currentSave));\n-                                        fromTimeUsed = true; \/\/ for consistency\n-                                    }\n-                                    break year_loop;\n-                                }\n-                            }\n-\n-                            if (fromTimeUsed == false) {\n-                                if (fromTime <= transition) {\n-                                    fromTimeUsed = true;\n-\n-                                    if (fromTime != minTime) {\n-                                        int prevsave;\n-\n-                                        \/\/ See if until time in the previous\n-                                        \/\/ ZoneRec is the same thing as the\n-                                        \/\/ local time in the next rule.\n-                                        \/\/ (examples are Asia\/Ashkhabad in 1991,\n-                                        \/\/ Europe\/Riga in 1989)\n-\n-                                        if (i > 0) {\n-                                            prevsave = rules.get(i-1).getSave();\n-                                        } else {\n-                                            List<RuleRec> prevrules = rule.getRules(year-1);\n-\n-                                            if (prevrules.size() > 0) {\n-                                                prevsave = prevrules.get(prevrules.size()-1).getSave();\n-                                            } else {\n-                                                prevsave = 0;\n-                                            }\n-                                        }\n-\n-                                        if (rrec.isSameTransition(prevzrec, prevsave, gmtOffset)) {\n-                                            currentSave = rrec.getSave();\n-                                            tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                         tz.getDstOffsetIndex(currentSave));\n-                                            tz.addUsedRec(rrec);\n-                                            usedZone = true;\n-                                            continue;\n-                                        }\n-                                        if (!prevzrec.hasRuleReference()\n-                                            || rule != prevzrec.getRuleRef()\n-                                            || (rule == prevzrec.getRuleRef()\n-                                                && gmtOffset != prevzrec.getGmtOffset())) {\n-                                            int save = (fromTime == transition) ? rrec.getSave() : currentSave;\n-                                            tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+save),\n-                                                         tz.getDstOffsetIndex(save));\n-                                            tz.addUsedRec(rrec);\n-                                            usedZone = true;\n-                                        }\n-                                    } else {  \/\/ fromTime == minTime\n-                                        int save = rrec.getSave();\n-                                        tz.addTransition(minTime,\n-                                                         tz.getOffsetIndex(gmtOffset),\n-                                                         tz.getDstOffsetIndex(0));\n-\n-                                        tz.addTransition(transition,\n-                                                         tz.getOffsetIndex(gmtOffset+save),\n-                                                         tz.getDstOffsetIndex(save));\n-\n-                                        tz.addUsedRec(rrec);\n-                                        usedZone = true;\n-                                    }\n-                                } else if (year == fromYear && i == rules.size()-1) {\n-                                    int save = rrec.getSave();\n-                                    tz.addTransition(fromTime,\n-                                                     tz.getOffsetIndex(gmtOffset+save),\n-                                                     tz.getDstOffsetIndex(save));\n-                                }\n-                            }\n-\n-                            currentSave = rrec.getSave();\n-                            if (fromTime < transition) {\n-                                tz.addTransition(transition,\n-                                                 tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                 tz.getDstOffsetIndex(currentSave));\n-                                tz.addUsedRec(rrec);\n-                                usedZone = true;\n-                            }\n-                        }\n-                    } else {\n-                        if (year == fromYear) {\n-                            tz.addTransition(fromTime,\n-                                             tz.getOffsetIndex(gmtOffset+currentSave),\n-                                             tz.getDstOffsetIndex(currentSave));\n-                            fromTimeUsed = true;\n-                        }\n-                        if (year == endYear && !zrec.hasUntil()) {\n-                            if (tz.getNTransitions() > 0) {\n-                                \/\/ Assume that this Zone stopped DST\n-                                tz.setDSTType(Timezone.X_DST);\n-                                long time = Time.getLocalTime(maxYear, Month.JANUARY,\n-                                                              1, 0);\n-                                time -= zrec.getGmtOffset();\n-                                tz.addTransition(time,\n-                                                 tz.getOffsetIndex(gmtOffset),\n-                                                 tz.getDstOffsetIndex(0));\n-                                usedZone = true;\n-                            } else {\n-                                tz.setDSTType(Timezone.NO_DST);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            if (usedZone) {\n-                tz.addUsedRec(zrec);\n-            }\n-            if (zrec.hasUntil() && zrec.getUntilTime(currentSave) > fromTime) {\n-                fromTime = zrec.getUntilTime(currentSave);\n-                fromYear = zrec.getUntilYear();\n-                year = zrec.getUntilYear();\n-            }\n-            prevzrec = zrec;\n-        }\n-\n-        if (tz.getDSTType() == Timezone.UNDEF_DST) {\n-            tz.setDSTType(Timezone.DST);\n-        }\n-        tz.optimize();\n-        tz.checksum();\n-        return tz;\n-    }\n-\n-    private static void panic(String msg) {\n-        Main.panic(msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Zoneinfo.java","additions":0,"deletions":579,"binary":false,"changes":579,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-#\n-# Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# JDK 1.1.x compatible time zone IDs\n-#\n-\n-Link Australia\/Darwin ACT\n-Link Australia\/Sydney AET\n-Link America\/Argentina\/Buenos_Aires AGT\n-Link Africa\/Cairo ART\n-Link America\/Anchorage AST\n-Link America\/Sao_Paulo BET\n-Link Asia\/Dhaka BST\n-Link Africa\/Harare CAT\n-Link America\/St_Johns CNT\n-Link America\/Chicago CST\n-Link Asia\/Shanghai CTT\n-Link Africa\/Addis_Ababa EAT\n-Link Europe\/Paris ECT\n-Link America\/New_York EST\n-Link Pacific\/Honolulu HST\n-Link America\/Indianapolis IET\n-Link Asia\/Calcutta IST\n-Link Asia\/Tokyo JST\n-Link Pacific\/Apia MIT\n-Link America\/Denver MST\n-Link Asia\/Yerevan NET\n-Link Pacific\/Auckland NST\n-Link Asia\/Karachi PLT\n-Link America\/Phoenix PNT\n-Link America\/Puerto_Rico PRT\n-Link America\/Los_Angeles PST\n-Link Pacific\/Guadalcanal SST\n-Link Asia\/Saigon VST\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tSystemV\tmin\t1973\t-\tApr\tlastSun\t2:00\t1:00\tD\n-Rule\tSystemV\tmin\t1973\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1974\tonly\t-\tJan\t6\t2:00\t1:00\tD\n-Rule\tSystemV\t1974\tonly\t-\tNov\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1975\tonly\t-\tFeb\t23\t2:00\t1:00\tD\n-Rule\tSystemV\t1975\tonly\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1976\tmax\t-\tApr\tlastSun\t2:00\t1:00\tD\n-Rule\tSystemV\t1976\tmax\t-\tOct\tlastSun\t2:00\t0\tS\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tSystemV\/AST4ADT\t-4:00\tSystemV\t\tA%sT\n-Zone\tSystemV\/EST5EDT\t-5:00\tSystemV\t\tE%sT\n-Zone\tSystemV\/CST6CDT\t-6:00\tSystemV\t\tC%sT\n-Zone\tSystemV\/MST7MDT\t-7:00\tSystemV\t\tM%sT\n-Zone\tSystemV\/PST8PDT\t-8:00\tSystemV\t\tP%sT\n-Zone\tSystemV\/YST9YDT\t-9:00\tSystemV\t\tY%sT\n-Zone\tSystemV\/AST4\t-4:00\t-\t\tAST\n-Zone\tSystemV\/EST5\t-5:00\t-\t\tEST\n-Zone\tSystemV\/CST6\t-6:00\t-\t\tCST\n-Zone\tSystemV\/MST7\t-7:00\t-\t\tMST\n-Zone\tSystemV\/PST8\t-8:00\t-\t\tPST\n-Zone\tSystemV\/YST9\t-9:00\t-\t\tYST\n-Zone\tSystemV\/HST10\t-10:00\t-\t\tHST\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/tzdata_jdk\/jdk11_backward","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m AddOptionsTest\n+ * @run main\/othervm -Xmx1g AddOptionsTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AddOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m BasicJlinkMissingJavaBase\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkMissingJavaBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m BasicJlinkTest false\n+ * @run main\/othervm -Xmx1g BasicJlinkTest false\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m CustomModuleJlinkTest\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/CustomModuleJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m GenerateJLIClassesTest\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/GenerateJLIClassesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m JavaSEReproducibleTest\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m KeepPackagedModulesFailTest\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/KeepPackagedModulesFailTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m ModifiedFilesExitTest\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesExitTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m ModifiedFilesWarningTest\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesWarningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m MultiHopTest\n+ * @run main\/othervm -Xmx1g MultiHopTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/MultiHopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=1200 -Xmx1400m PackagedModulesVsRuntimeImageLinkTest\n+ * @run main\/othervm\/timeout=1200 -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n@@ -79,1 +79,0 @@\n-        System.out.println(\"Now comparing jmod-less and jmod-full) images\");\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1400m PatchedJDKModuleJlinkTest\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PatchedJDKModuleJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m SystemModulesTest\n+ * @run main\/othervm -Xmx1g SystemModulesTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1400m SystemModulesTest2\n+ * @run main\/othervm -Xmx1g SystemModulesTest2\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static jdk.internal.util.OperatingSystem.LINUX;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -70,0 +72,1 @@\n+ * @requires (jpackage.test.SQETest != null)\n@@ -81,1 +84,0 @@\n- * @requires (os.family == \"linux\")\n@@ -84,6 +86,1 @@\n- *  --jpt-run=LicenseTest.testCustomDebianCopyright\n- *  --jpt-run=LicenseTest.testCustomDebianCopyrightSubst\n- *  --jpt-run=LicenseTest.testLinuxLicenseInUsrTree\n- *  --jpt-run=LicenseTest.testLinuxLicenseInUsrTree2\n- *  --jpt-run=LicenseTest.testLinuxLicenseInUsrTree3\n- *  --jpt-run=LicenseTest.testLinuxLicenseInUsrTree4\n+ *  --jpt-run=LicenseTest\n@@ -93,0 +90,2 @@\n+\n+    @Test\n@@ -105,0 +104,1 @@\n+    @Test(ifOS = LINUX)\n@@ -109,0 +109,1 @@\n+    @Test(ifOS = LINUX)\n@@ -113,0 +114,1 @@\n+    @Test(ifOS = LINUX)\n@@ -117,0 +119,1 @@\n+    @Test(ifOS = LINUX)\n@@ -121,0 +124,1 @@\n+    @Test(ifOS = LINUX)\n@@ -125,0 +129,1 @@\n+    @Test(ifOS = LINUX)\n","filename":"test\/jdk\/tools\/jpackage\/share\/LicenseTest.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import static jdk.internal.util.OperatingSystem.WINDOWS;\n@@ -52,1 +53,1 @@\n-    @Test\n+    @Test(ifNotOS = WINDOWS)\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimeImageSymbolicLinksTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-            sb.append(\"DirChooser\");\n+            sb.append(\"Dc\"); \/\/ DirChooser\n@@ -128,1 +128,1 @@\n-            sb.append(\"ShortcutPrompt\");\n+            sb.append(\"Sp\"); \/\/ ShortcutPrompt\n@@ -131,1 +131,1 @@\n-            sb.append(\"License\");\n+            sb.append(\"L\"); \/\/ License\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinInstallerUiTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jpackage.test.Executor;\n@@ -42,0 +43,1 @@\n+ * @library \/test\/lib\n@@ -44,0 +46,1 @@\n+ * @build jtreg.SkippedException\n@@ -67,0 +70,2 @@\n+        verifyDosNamesSupported();\n+\n@@ -87,0 +92,19 @@\n+\n+    private static void verifyDosNamesSupported() throws IOException {\n+        \/\/ Pick the file's name long enough to make Windows shorten it.\n+        final var probeDosNameFile = TKit.createTempFile(Path.of(\"probeDosName\"));\n+\n+        \/\/ The output should be a DOS variant of the `probeDosNameFile` path.\n+        \/\/ The filename should differ if the volume owning `probeDosNameFile` file supports DOS names.\n+        final var dosPath = new Executor()\n+                .addArguments(\"\/c\", String.format(\"for %%P in (\\\"%s\\\") do @echo %%~sP\", probeDosNameFile))\n+                .setExecutable(\"cmd\")\n+                .dumpOutput()\n+                .executeAndGetFirstLineOfOutput();\n+\n+        if (Path.of(dosPath).getFileName().equals(probeDosNameFile.getFileName())) {\n+            TKit.throwSkippedException(String.format(\"The volume %s owning the test work directory doesn't support DOS paths\",\n+                    probeDosNameFile.toAbsolutePath().getRoot()));\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongPathTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-@Fork(1)\n+@Fork(value=1, jvmArgs={\"--add-modules=jdk.incubator.vector\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/SpiltReplicate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 1, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n+public class MergeLoadBench {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    final static VarHandle\n+            INT_L  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.LITTLE_ENDIAN),\n+            INT_B  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.BIG_ENDIAN),\n+            LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN),\n+            LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN),\n+            CHAR_L = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.LITTLE_ENDIAN),\n+            CHAR_B = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.BIG_ENDIAN);\n+\n+    final static int NUMBERS = 8192;\n+\n+    final byte[] bytes4 = new byte[NUMBERS * 4];\n+    final byte[] bytes8 = new byte[NUMBERS * 8];\n+    final int [] ints   = new int [NUMBERS    ];\n+    final long[] longs  = new long[NUMBERS    ];\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random();\n+        for (int i = 0; i < ints.length; i++) {\n+            ints[i] = r.nextInt();\n+            INT_L.set(bytes4, i * 4, i);\n+        }\n+\n+        for (int i = 0; i < longs.length; i++) {\n+            longs[i] = r.nextLong();\n+            LONG_L.set(bytes8, i * 8, i);\n+        }\n+    }\n+\n+    \/*\n+     * The names of these cases have the following `B\/L\/V\/U` suffixes, which are:\n+     * ```\n+     * B BigEndian\n+     * L LittleEndian\n+     * V VarHandle\n+     * U Unsafe\n+     * R ReverseBytes\n+     * C Unsafe.getChar & putChar\n+     * S Unsafe.getShort & putShort\n+     * ```\n+     *\/\n+\n+    @Benchmark\n+    public void getIntB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_B.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_L.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += Integer.reverseBytes(\n+                    UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_B.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_L.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += Long.reverseBytes(\n+                    UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharB(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = (char) CHAR_B.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharBU(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharL(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+    @Benchmark\n+    public void getCharLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharLU(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+\n+    @Benchmark\n+    public void getCharLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = (char) CHAR_L.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharC(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = UNSAFE.getChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    static int getIntB(byte[] array, int offset) {\n+        return ((array[offset    ] & 0xff) << 24)\n+             | ((array[offset + 1] & 0xff) << 16)\n+             | ((array[offset + 2] & 0xff) <<  8)\n+             | ((array[offset + 3] & 0xff)      );\n+    }\n+\n+    static int getIntBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff) << 24)\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff)      );\n+    }\n+\n+    static int getIntL(byte[] array, int offset) {\n+        return ((array[offset       ] & 0xff)      )\n+                | ((array[offset + 1] & 0xff) <<  8)\n+                | ((array[offset + 2] & 0xff) << 16)\n+                | ((array[offset + 3] & 0xff) << 24);\n+    }\n+\n+    static int getIntRB(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntB(array, offset));\n+    }\n+\n+    static int getIntRBU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntBU(array, offset));\n+    }\n+\n+    static int getIntRL(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntL(array, offset));\n+    }\n+\n+    static int getIntRLU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntLU(array, offset));\n+    }\n+\n+    static long getLongB(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff) << 56)\n+             | (((long) array[offset + 1] & 0xff) << 48)\n+             | (((long) array[offset + 2] & 0xff) << 40)\n+             | (((long) array[offset + 3] & 0xff) << 32)\n+             | (((long) array[offset + 4] & 0xff) << 24)\n+             | (((long) array[offset + 5] & 0xff) << 16)\n+             | (((long) array[offset + 6] & 0xff) << 8)\n+             | (((long) array[offset + 7] & 0xff)     );\n+    }\n+\n+    static long getLongBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address)     & 0xff)) << 56)\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff))      );\n+    }\n+\n+    public static long getLongL(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff)      )\n+             | (((long) array[offset + 1] & 0xff) <<  8)\n+             | (((long) array[offset + 2] & 0xff) << 16)\n+             | (((long) array[offset + 3] & 0xff) << 24)\n+             | (((long) array[offset + 4] & 0xff) << 32)\n+             | (((long) array[offset + 5] & 0xff) << 40)\n+             | (((long) array[offset + 6] & 0xff) << 48)\n+             | (((long) array[offset + 7] & 0xff) << 56);\n+    }\n+\n+    static long getLongLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address    ) & 0xff))      )\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff)) << 56);\n+    }\n+\n+    static long getLongRB(byte[] array, int offset) {\n+        return getLongB(array, offset);\n+    }\n+\n+    static long getLongRBU(byte[] array, int offset) {\n+        return getLongBU(array, offset);\n+    }\n+\n+    static long getLongRL(byte[] array, int offset) {\n+        return getLongL(array, offset);\n+    }\n+\n+    static long getLongRLU(byte[] array, int offset) {\n+        return getLongLU(array, offset);\n+    }\n+\n+    public static int getIntLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff)      )\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n+    }\n+\n+    public static char getCharB(byte[] val, int index) {\n+        index <<= 1;\n+        return (char)(((val[index    ] & 0xff) << 8)\n+                    | ((val[index + 1] & 0xff)));\n+    }\n+\n+    public static char getCharBR(byte[] val, int index) {\n+        return Character.reverseBytes(getCharB(val, index));\n+    }\n+\n+    public static char getCharL(byte[] val, int index) {\n+        index <<= 1;\n+        return (char)(((val[index    ] & 0xff))\n+                    | ((val[index + 1] & 0xff) << 8));\n+    }\n+\n+    public static char getCharLR(byte[] val, int index) {\n+        return Character.reverseBytes(getCharL(val, index));\n+    }\n+\n+    public static char getCharBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        return (char) (((UNSAFE.getByte(array, address    ) & 0xff) << 8)\n+                     | ((UNSAFE.getByte(array, address + 1) & 0xff)     ));\n+    }\n+\n+    public static char getCharLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        return (char) (((UNSAFE.getByte(array, address    ) & 0xff)     )\n+                     | ((UNSAFE.getByte(array, address + 1) & 0xff) << 8));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeLoadBench.java","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-import org.openjdk.jmh.runner.Runner;\n-import org.openjdk.jmh.runner.options.Options;\n-import org.openjdk.jmh.runner.options.OptionsBuilder;\n@@ -34,1 +31,0 @@\n-import java.lang.reflect.Field;\n@@ -44,1 +40,1 @@\n-@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n@@ -46,1 +42,1 @@\n-@Fork(value = 3, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n+@Fork(value = 1, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n@@ -50,6 +46,7 @@\n-    final static VarHandle INT_L  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.LITTLE_ENDIAN);\n-    final static VarHandle INT_B  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.BIG_ENDIAN);\n-    final static VarHandle LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN);\n-    final static VarHandle LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN);\n-    final static VarHandle CHAR_L = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.LITTLE_ENDIAN);\n-    final static VarHandle CHAR_B = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.BIG_ENDIAN);\n+    final static VarHandle\n+            INT_L  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.LITTLE_ENDIAN),\n+            INT_B  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.BIG_ENDIAN),\n+            LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN),\n+            LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN),\n+            CHAR_L = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.LITTLE_ENDIAN),\n+            CHAR_B = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.BIG_ENDIAN);\n@@ -92,109 +89,0 @@\n-    @Benchmark\n-    public void getIntB(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntB(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntBU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntBU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntBV(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (int) INT_B.get(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntL(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntL(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntLU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntLU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntLV(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (int) INT_L.get(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRB(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRB(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRBU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRBU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRL(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRL(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRLU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRLU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += Integer.reverseBytes(\n-                    UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4));\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n@@ -214,5 +102,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntBU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntBU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -220,1 +107,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -225,5 +112,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            INT_B.set(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            INT_B.set(bytes4, off, ints[i]);\n+            off += 4;\n@@ -231,1 +117,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -236,5 +122,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntL(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntL(bytes4, off, ints[i]);\n+            off += 4;\n@@ -242,1 +127,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -247,5 +132,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntLU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntLU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -253,1 +137,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -258,5 +142,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            INT_L.set(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            INT_L.set(bytes4, off, ints[i]);\n+            off += 4;\n@@ -264,1 +147,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -269,5 +152,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRB(bytes4, i * 4, ints[i]);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRB(bytes4, off, ints[i]);\n+            off += 4;\n@@ -275,1 +157,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -280,5 +162,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRBU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRBU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -286,1 +167,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -291,5 +172,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRL(bytes4, i * 4, ints[i]);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRL(bytes4, off, ints[i]);\n+            off += 4;\n@@ -297,1 +177,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -302,5 +182,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRLU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRLU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -308,1 +187,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -313,6 +192,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            v = Integer.reverseBytes(v);\n-            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, Integer.reverseBytes(ints[i]));\n+            off += 4;\n@@ -320,1 +197,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -325,59 +202,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n-            sum += v;\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongB(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongB(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongBU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongBU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongBV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (long) LONG_B.get(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongL(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongL(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongLU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongLU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongLV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (long) LONG_L.get(bytes8, i * 8);\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, ints[i]);\n+            off += 4;\n@@ -385,56 +207,1 @@\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRB(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRB(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRBU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRBU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRL(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRL(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRLU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRLU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += Long.reverseBytes(\n-                    UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8));\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8);\n-        }\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -445,5 +212,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongB(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongB(bytes8, off, longs[i]);\n+            off += 8;\n@@ -451,1 +217,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -456,5 +222,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongBU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongBU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -462,1 +227,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -467,5 +232,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            LONG_B.set(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            LONG_B.set(bytes8, off, longs[i]);\n+            off += 8;\n@@ -473,1 +237,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -478,5 +242,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongL(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongL(bytes8, off, longs[i]);\n+            off += 8;\n@@ -484,1 +247,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -489,5 +252,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongLU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongLU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -495,1 +257,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -500,5 +262,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            LONG_L.set(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            LONG_L.set(bytes8, off, longs[i]);\n+            off += 8;\n@@ -506,1 +267,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -511,5 +272,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRB(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRB(bytes8, off, longs[i]);\n+            off += 8;\n@@ -517,1 +277,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -522,5 +282,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRBU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRBU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -528,1 +287,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -533,5 +292,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRL(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRL(bytes8, off, longs[i]);\n+            off += 8;\n@@ -539,1 +297,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -544,5 +302,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRLU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRLU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -550,1 +307,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -555,6 +312,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            v = Long.reverseBytes(v);\n-            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, Long.reverseBytes(longs[i]));\n+            off += 8;\n@@ -562,1 +317,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -567,15 +322,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n-            sum += v;\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getCharB(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharB(bytes4, i);\n-            sum += c;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, longs[i]);\n+            off += 8;\n@@ -583,1 +327,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -587,15 +331,5 @@\n-    public void getCharBV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = (char) CHAR_B.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n-            sum += c;\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getCharBU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharBU(bytes4, i);\n-            sum += c;\n+    public void setCharBS(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            putShortB(bytes4, off, chars[i]);\n+            off += 2;\n@@ -603,1 +337,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -607,14 +341,5 @@\n-    public void getCharL(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharL(bytes4, i);\n-            sum += c;\n-        }\n-        BH.consume(sum);\n-    }\n-    @Benchmark\n-    public void getCharLU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharLU(bytes4, i);\n-            sum += c;\n+    public void setCharBV(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            CHAR_B.set(bytes4, off, chars[i]);\n+            off += 2;\n@@ -622,1 +347,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -625,1 +350,0 @@\n-\n@@ -627,5 +351,5 @@\n-    public void getCharLV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = (char) CHAR_L.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n-            sum += c;\n+    public void setCharLS(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            putShortL(bytes4, off, chars[i]);\n+            off += 2;\n@@ -633,1 +357,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -637,5 +361,5 @@\n-    public void getCharC(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = UNSAFE.getChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n-            sum += c;\n+    public void setCharLV(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            CHAR_L.set(bytes4, off, chars[i]);\n+            off += 2;\n@@ -643,1 +367,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -647,6 +371,5 @@\n-    public void setCharBS(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            putShortB(bytes4, i * 2, c);\n-            sum += c;\n+    public void setCharC(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            UNSAFE.putChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, chars[i]);\n+            off += 2;\n@@ -654,1 +377,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -657,0 +380,4 @@\n+    \/*\n+     * putChars4 and putBytes4 Test whether four constant chars can be MergeStored\n+     *\n+     *\/\n@@ -658,6 +385,4 @@\n-    public void setCharBV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            CHAR_B.set(bytes4, i * 2, c);\n-            sum += c;\n+    public void putBytes4(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putBytes4(bytes4, off, 'n', 'u', 'l', 'l');\n@@ -665,1 +390,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -669,6 +394,4 @@\n-    public void setCharLS(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            putShortL(bytes4, i * 2, c);\n-            sum += c;\n+    public void putBytes4X(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putBytes4X(bytes4, off, 'n', 'u', 'l', 'l');\n@@ -676,1 +399,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -680,6 +403,4 @@\n-    public void setCharLV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            CHAR_L.set(bytes4, i * 2, c);\n-            sum += c;\n+    public void putBytes4U(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putBytes4U(bytes4, off, 'n', 'u', 'l', 'l');\n@@ -687,1 +408,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -691,6 +412,6 @@\n-    public void setCharC(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            UNSAFE.putChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2, c);\n-            sum += c;\n+    @SuppressWarnings(\"deprecation\")\n+    public void putBytes4GetBytes(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            \"null\".getBytes(0, 4, bytes4, off);\n+            off += 4;\n@@ -698,1 +419,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -701,4 +422,0 @@\n-    \/*\n-     * putChars4 Test whether four constant chars can be MergeStored\n-     *\n-     *\/\n@@ -707,4 +424,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4B(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4B(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -712,1 +428,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -717,4 +433,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4BU(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4BU(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -722,1 +437,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -727,4 +442,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4BV(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4BV(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -732,1 +446,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -737,4 +451,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4L(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4L(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -742,1 +455,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -747,4 +460,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4LU(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4LU(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -752,1 +464,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -757,4 +469,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4LV(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4LV(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -762,1 +473,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -767,4 +478,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4C(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4C(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -772,1 +482,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -777,4 +487,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4S(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4S(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -782,39 +491,1 @@\n-        BH.consume(sum);\n-    }\n-\n-    static int getIntB(byte[] array, int offset) {\n-        return ((array[offset    ] & 0xff) << 24)\n-             | ((array[offset + 1] & 0xff) << 16)\n-             | ((array[offset + 2] & 0xff) <<  8)\n-             | ((array[offset + 3] & 0xff)      );\n-    }\n-\n-    static int getIntBU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return ((UNSAFE.getByte(array, address    ) & 0xff) << 24)\n-             | ((UNSAFE.getByte(array, address + 1) & 0xff) << 16)\n-             | ((UNSAFE.getByte(array, address + 2) & 0xff) <<  8)\n-             | ((UNSAFE.getByte(array, address + 3) & 0xff)      );\n-    }\n-\n-    static int getIntL(byte[] array, int offset) {\n-        return ((array[offset       ] & 0xff)      )\n-                | ((array[offset + 1] & 0xff) <<  8)\n-                | ((array[offset + 2] & 0xff) << 16)\n-                | ((array[offset + 3] & 0xff) << 24);\n-    }\n-\n-    static int getIntRB(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntB(array, offset));\n-    }\n-\n-    static int getIntRBU(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntBU(array, offset));\n-    }\n-\n-    static int getIntRL(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntL(array, offset));\n-    }\n-\n-    static int getIntRLU(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntLU(array, offset));\n+        BH.consume(off);\n@@ -873,62 +544,0 @@\n-    static long getLongB(byte[] array, int offset) {\n-        return (((long) array[offset    ] & 0xff) << 56)\n-             | (((long) array[offset + 1] & 0xff) << 48)\n-             | (((long) array[offset + 2] & 0xff) << 40)\n-             | (((long) array[offset + 3] & 0xff) << 32)\n-             | (((long) array[offset + 4] & 0xff) << 24)\n-             | (((long) array[offset + 5] & 0xff) << 16)\n-             | (((long) array[offset + 6] & 0xff) << 8)\n-             | (((long) array[offset + 7] & 0xff)     );\n-    }\n-\n-    static long getLongBU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return (((long)(UNSAFE.getByte(array, address)     & 0xff)) << 56)\n-             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) << 48)\n-             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 40)\n-             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 32)\n-             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 24)\n-             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 16)\n-             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) <<  8)\n-             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff))      );\n-    }\n-\n-    public static long getLongL(byte[] array, int offset) {\n-        return (((long) array[offset    ] & 0xff)      )\n-             | (((long) array[offset + 1] & 0xff) <<  8)\n-             | (((long) array[offset + 2] & 0xff) << 16)\n-             | (((long) array[offset + 3] & 0xff) << 24)\n-             | (((long) array[offset + 4] & 0xff) << 32)\n-             | (((long) array[offset + 5] & 0xff) << 40)\n-             | (((long) array[offset + 6] & 0xff) << 48)\n-             | (((long) array[offset + 7] & 0xff) << 56);\n-    }\n-\n-    static long getLongLU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return (((long)(UNSAFE.getByte(array, address    ) & 0xff))      )\n-             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) <<  8)\n-             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 16)\n-             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 24)\n-             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 32)\n-             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 40)\n-             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) << 48)\n-             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff)) << 56);\n-    }\n-\n-    static long getLongRB(byte[] array, int offset) {\n-        return getLongB(array, offset);\n-    }\n-\n-    static long getLongRBU(byte[] array, int offset) {\n-        return getLongBU(array, offset);\n-    }\n-\n-    static long getLongRL(byte[] array, int offset) {\n-        return getLongL(array, offset);\n-    }\n-\n-    static long getLongRLU(byte[] array, int offset) {\n-        return getLongLU(array, offset);\n-    }\n-\n@@ -1001,22 +610,6 @@\n-    public static int getIntLU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return ((UNSAFE.getByte(array, address    ) & 0xff)      )\n-             | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n-             | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n-             | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n-    }\n-\n-    public static char getCharB(byte[] val, int index) {\n-        index <<= 1;\n-        return (char)(((val[index    ] & 0xff) << 8)\n-                    | ((val[index + 1] & 0xff)));\n-    }\n-\n-    public static char getCharBR(byte[] val, int index) {\n-        return Character.reverseBytes(getCharB(val, index));\n-    }\n-\n-    public static char getCharL(byte[] val, int index) {\n-        index <<= 1;\n-        return (char)(((val[index    ] & 0xff))\n-                    | ((val[index + 1] & 0xff) << 8));\n+    public int putBytes4(byte[] bytes, int offset, int c0, int c1, int c2, int c3) {\n+        bytes[offset    ] = (byte) c0;\n+        bytes[offset + 1] = (byte) c1;\n+        bytes[offset + 2] = (byte) c2;\n+        bytes[offset + 3] = (byte) c3;\n+        return offset + 4;\n@@ -1025,2 +618,6 @@\n-    public static char getCharLR(byte[] val, int index) {\n-        return Character.reverseBytes(getCharL(val, index));\n+    public int putBytes4X(byte[] bytes, int offset, int c0, int c1, int c2, int c3) {\n+        bytes[offset++] = (byte) c0;\n+        bytes[offset++] = (byte) c1;\n+        bytes[offset++] = (byte) c2;\n+        bytes[offset++] = (byte) c3;\n+        return offset;\n@@ -1029,10 +626,7 @@\n-    public static char getCharBU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n-        return (char) (((UNSAFE.getByte(array, address    ) & 0xff) << 8)\n-                     | ((UNSAFE.getByte(array, address + 1) & 0xff)     ));\n-    }\n-\n-    public static char getCharLU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n-        return (char) (((UNSAFE.getByte(array, address    ) & 0xff)     )\n-                     | ((UNSAFE.getByte(array, address + 1) & 0xff) << 8));\n+    public int putBytes4U(byte[] bytes, int offset, int c0, int c1, int c2, int c3) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(bytes, address    , (byte) c0);\n+        UNSAFE.putByte(bytes, address + 1, (byte) c1);\n+        UNSAFE.putByte(bytes, address + 2, (byte) c2);\n+        UNSAFE.putByte(bytes, address + 3, (byte) c3);\n+        return offset + 4;\n@@ -1041,2 +635,1 @@\n-    public void putChars4B(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4B(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1047,0 +640,1 @@\n+        return offset + 4;\n@@ -1049,2 +643,1 @@\n-    public void putChars4BU(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4BU(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1055,0 +648,1 @@\n+        return offset + 4;\n@@ -1057,4 +651,2 @@\n-    public void putChars4BV(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        offset <<= 1;\n-        CHAR_B.set(bytes, offset    , c0);\n+    public int putChars4BV(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n+        CHAR_B.set(bytes, offset     , c0);\n@@ -1064,0 +656,1 @@\n+        return offset + 8;\n@@ -1066,2 +659,1 @@\n-    public void putChars4L(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4L(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1072,0 +664,1 @@\n+        return offset + 4;\n@@ -1074,3 +667,1 @@\n-    public void putChars4LV(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        offset <<= 1;\n+    public int putChars4LV(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1081,0 +672,1 @@\n+        return offset + 8;\n@@ -1083,2 +675,1 @@\n-    public void putChars4LU(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4LU(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1089,0 +680,1 @@\n+        return offset + 4;\n@@ -1091,3 +683,2 @@\n-    public void putChars4C(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+    public int putChars4C(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n@@ -1098,0 +689,1 @@\n+        return offset + 8;\n@@ -1100,3 +692,2 @@\n-    public void putChars4S(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+    public int putChars4S(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n@@ -1107,0 +698,1 @@\n+        return offset + 8;\n@@ -1132,0 +724,5 @@\n+\n+    @Fork(value = 1, jvmArgs = {\n+            \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-MergeStores\"\n+    })\n+    public static class MergeStoresDisabled extends MergeStoreBench {}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStoreBench.java","additions":255,"deletions":658,"binary":false,"changes":913,"status":"modified"}]}