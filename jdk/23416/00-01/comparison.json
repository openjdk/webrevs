{"files":[{"patch":"@@ -27,1 +27,1 @@\n-\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -33,1 +33,0 @@\n-struct Empty {};\n@@ -43,0 +42,1 @@\n+\/\/ If the value has type void, no value will be stored in the nodes.\n@@ -53,0 +53,10 @@\n+  \/\/ If the value in a node is not desired (like in an intrusive tree),\n+  \/\/ we can inherit from Empty instead of Value to avoid wasting space.\n+  struct Empty {};\n+\n+  class Value {\n+  protected:\n+    V _value;\n+    Value(const V& val) : _value(val) {}\n+  };\n+\n@@ -54,1 +64,1 @@\n-  class RBNode {\n+  class RBNode : std::conditional_t<std::is_same<V, void>::value, Empty, Value>{\n@@ -64,1 +74,0 @@\n-    V _value;\n@@ -70,2 +79,6 @@\n-    V& val() { return _value; }\n-    V& val() const { return _value; }\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    VV& val() { return Value::_value; }\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    const VV& val() const { return Value::_value; }\n@@ -75,4 +88,6 @@\n-          _key(key), _value(Empty()) DEBUG_ONLY(COMMA _visited(false)) {}\n-    RBNode(const K& key, const V& val)\n-        : _parent(0), _left(nullptr), _right(nullptr),\n-          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(false)) {}\n+          _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    RBNode(const K& key, const VV& val)\n+        :  Value(val), _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n@@ -147,1 +162,8 @@\n-  RBNode* allocate_node(const K& key, const V& val) {\n+  RBNode* allocate_node(const K& key) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    return new (node_place) RBNode(key);\n+  }\n+\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  RBNode* allocate_node(const K& key, const VV& val) {\n@@ -153,0 +175,1 @@\n+  template <typename VV = V, ENABLE_IF(std::is_same<VV, void>::value)>\n@@ -154,1 +177,6 @@\n-    node->_value.~V();\n+    _allocator.free(node);\n+  }\n+\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  void free_node(RBNode* node) {\n+    node->_value.~VV();\n@@ -167,3 +195,0 @@\n-  \/\/ If the node with key k already exist, the value is updated instead.\n-  RBNode* insert_node(const K& key, const V& val);\n-\n@@ -244,1 +269,13 @@\n-  \/\/ Inserts a node with the given k\/v into the tree,\n+  \/\/ Inserts a node with the given key into the tree,\n+  \/\/ does nothing if the key already exist.\n+  void upsert(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    if (cursor.found()) {\n+      return;\n+    }\n+\n+    RBNode* node = allocate_node(key);\n+    insert_at_cursor(node, cursor);\n+  }\n+\n+  \/\/ Inserts a node with the given key\/value into the tree,\n@@ -246,1 +283,2 @@\n-  void upsert(const K& key, const V& val) {\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  void upsert(const K& key, const VV& val) {\n@@ -379,1 +417,1 @@\n-using IntrusiveRBTree = RBTree<K, Empty, COMPARATOR, RBTreeNoopAllocator>;\n+using IntrusiveRBTree = RBTree<K, void, COMPARATOR, RBTreeNoopAllocator>;\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":56,"deletions":18,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -188,79 +188,0 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) {\n-  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->get_cursor(node);\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) const {\n-  if (node == nullptr) {\n-    return Cursor();\n-  }\n-\n-  if (node->parent() == nullptr) {\n-    return Cursor(&_root, nullptr);\n-  }\n-\n-  RBNode* parent = node->parent();\n-  RBNode** insert_location =\n-      node->is_left_child() ? &parent->_left : &parent->_right;\n-  return Cursor(insert_location, parent);\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) {\n-  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->next(cursor);\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) const {\n-  if (cursor.found()) {\n-    return get_cursor(cursor.node()->next());\n-  }\n-\n-  if (cursor._parent == nullptr) { \/\/ Tree is empty\n-    return Cursor();\n-  }\n-\n-  \/\/ Pointing to non-existant node\n-  if (&cursor._parent->_left == cursor._insert_location) { \/\/ Left child, parent is next\n-    return get_cursor(cursor._parent);\n-  }\n-\n-  return get_cursor(cursor._parent->next()); \/\/ Right child, parent's next is also node's next\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) {\n-  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->prev(cursor);\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) const {\n-  if (cursor.found()) {\n-    return get_cursor(cursor.node()->prev());\n-  }\n-\n-  if (cursor._parent == nullptr) { \/\/ Tree is empty\n-    return Cursor();\n-  }\n-\n-  \/\/ Pointing to non-existant node\n-  if (&cursor._parent->_right == cursor._insert_location) { \/\/ Right child, parent is prev\n-    return get_cursor(cursor._parent);\n-  }\n-\n-  return get_cursor(cursor._parent->prev()); \/\/ Left child, parent's prev is also node's prev\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor_find(const K& key) {\n-  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->cursor_find(key);\n-}\n-\n@@ -312,76 +233,0 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_at_cursor(const Cursor& cursor) {\n-  assert(cursor.valid() && cursor.found(), \"must be\");\n-  _num_nodes--;\n-\n-  RBNode* node = cursor.node();\n-  if (node == _first) {\n-    _first = node->next();\n-  }\n-\n-  if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n-    \/\/ Swap place with the in-order successor and delete there instead\n-    RBNode* curr = node->_right;\n-    while (curr->_left != nullptr) {\n-      curr = curr->_left;\n-    }\n-\n-    if (_root == node) _root = curr;\n-\n-    swap(curr->_left, node->_left);\n-    swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n-\n-    \/\/ If node is curr's parent, parent and right pointers become invalid\n-    if (node->_right == curr) {\n-      node->_right = curr->_right;\n-      node->set_parent(curr);\n-      curr->_right = node;\n-    } else {\n-      swap(curr->_right, node->_right);\n-      node->parent()->replace_child(curr, node);\n-      curr->_right->set_parent(curr);\n-    }\n-\n-    if (curr->parent() != nullptr) curr->parent()->replace_child(node, curr);\n-    curr->_left->set_parent(curr);\n-\n-\n-    if (node->_left != nullptr) node->_left->set_parent(node);\n-    if (node->_right != nullptr) node->_right->set_parent(node);\n-  }\n-\n-  remove_from_tree(node);\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::replace_at_cursor(RBNode* new_node, const Cursor& cursor) {\n-  assert(cursor.valid() && cursor.found(), \"must be\");\n-  RBNode* old_node = cursor.node();\n-  if (old_node == new_node) {\n-    return;\n-  }\n-\n-  *cursor._insert_location = new_node;\n-  new_node->set_parent(cursor._parent);\n-  new_node->_color = old_node->_color;\n-\n-  new_node->_left = old_node->_left;\n-  new_node->_right = old_node->_right;\n-  if (new_node->_left != nullptr) {\n-    new_node->_left->set_parent(new_node);\n-  } else if (new_node->_right != nullptr) {\n-    new_node->_right->_parent = new_node;\n-    new_node->_right->set_parent(new_node);\n-  }\n-\n-  if (old_node == _first) {\n-    _first = new_node;\n-  }\n-\n-  free_node(old_node);\n-\n-#ifdef ASSERT\n-  verify_self(); \/\/ Dangerous operation, should verify no tree properties were broken\n-#endif \/\/ ASSERT\n-}\n-\n@@ -581,0 +426,155 @@\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_at_cursor(const Cursor& cursor) {\n+  assert(cursor.valid() && cursor.found(), \"must be\");\n+  _num_nodes--;\n+\n+  RBNode* node = cursor.node();\n+  if (node == _first) {\n+    _first = node->next();\n+  }\n+\n+  if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n+    \/\/ Swap place with the in-order successor and delete there instead\n+    RBNode* curr = node->_right;\n+    while (curr->_left != nullptr) {\n+      curr = curr->_left;\n+    }\n+\n+    if (_root == node) _root = curr;\n+\n+    swap(curr->_left, node->_left);\n+    swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n+\n+    \/\/ If node is curr's parent, parent and right pointers become invalid\n+    if (node->_right == curr) {\n+      node->_right = curr->_right;\n+      node->set_parent(curr);\n+      curr->_right = node;\n+    } else {\n+      swap(curr->_right, node->_right);\n+      node->parent()->replace_child(curr, node);\n+      curr->_right->set_parent(curr);\n+    }\n+\n+    if (curr->parent() != nullptr) curr->parent()->replace_child(node, curr);\n+    curr->_left->set_parent(curr);\n+\n+\n+    if (node->_left != nullptr) node->_left->set_parent(node);\n+    if (node->_right != nullptr) node->_right->set_parent(node);\n+  }\n+\n+  remove_from_tree(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) const {\n+  if (node == nullptr) {\n+    return Cursor();\n+  }\n+\n+  if (node->parent() == nullptr) {\n+    return Cursor(&_root, nullptr);\n+  }\n+\n+  RBNode* parent = node->parent();\n+  RBNode** insert_location =\n+      node->is_left_child() ? &parent->_left : &parent->_right;\n+  return Cursor(insert_location, parent);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) const {\n+  if (cursor.found()) {\n+    return get_cursor(cursor.node()->next());\n+  }\n+\n+  if (cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&cursor._parent->_left == cursor._insert_location) { \/\/ Left child, parent is next\n+    return get_cursor(cursor._parent);\n+  }\n+\n+  return get_cursor(cursor._parent->next()); \/\/ Right child, parent's next is also node's next\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) const {\n+  if (cursor.found()) {\n+    return get_cursor(cursor.node()->prev());\n+  }\n+\n+  if (cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&cursor._parent->_right == cursor._insert_location) { \/\/ Right child, parent is prev\n+    return get_cursor(cursor._parent);\n+  }\n+\n+  return get_cursor(cursor._parent->prev()); \/\/ Left child, parent's prev is also node's prev\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::replace_at_cursor(RBNode* new_node, const Cursor& cursor) {\n+  assert(cursor.valid() && cursor.found(), \"must be\");\n+  RBNode* old_node = cursor.node();\n+  if (old_node == new_node) {\n+    return;\n+  }\n+\n+  *cursor._insert_location = new_node;\n+  new_node->set_parent(cursor._parent);\n+  new_node->_color = old_node->_color;\n+\n+  new_node->_left = old_node->_left;\n+  new_node->_right = old_node->_right;\n+  if (new_node->_left != nullptr) {\n+    new_node->_left->set_parent(new_node);\n+  } else if (new_node->_right != nullptr) {\n+    new_node->_right->_parent = new_node;\n+    new_node->_right->set_parent(new_node);\n+  }\n+\n+  if (old_node == _first) {\n+    _first = new_node;\n+  }\n+\n+  free_node(old_node);\n+\n+#ifdef ASSERT\n+  verify_self(); \/\/ Dangerous operation, should verify no tree properties were broken\n+#endif \/\/ ASSERT\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor_find(const K& key) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->cursor_find(key);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->get_cursor(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->next(cursor);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->prev(cursor);\n+}\n+\n@@ -636,2 +636,2 @@\n-         \"unexpected number of nodes in rbtree. expected: %zu,\"\n-         \"actual: %zu\", size(), num_nodes);\n+         \"unexpected number of nodes in rbtree. expected: %zu\"\n+         \", actual: %zu\", size(), num_nodes);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":157,"deletions":157,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-    void test_node_next() {\n+  void test_node_next() {\n@@ -460,3 +460,3 @@\n-    \/\/ rbtree.visit_in_order([&](Node* node) {\n-    \/\/   EXPECT_EQ(node, node->val());\n-    \/\/ });\n+    rbtree.visit_in_order([&](Tree::RBNode* node) {\n+      EXPECT_EQ(node, node->val());\n+    });\n@@ -751,5 +751,4 @@\n-  struct Nothing {};\n-    RBTreeCHeap<int, Nothing, Cmp, mtOther> rbtree;\n-    constexpr int one_hundred_thousand = 100000;\n-    for (int i = 0; i < one_hundred_thousand; i++) {\n-      rbtree.upsert(i, Nothing());\n+    RBTreeCHeap<int, void, Cmp, mtOther> rbtree;\n+    constexpr size_t one_hundred_thousand = 100000;\n+    for (size_t i = 0; i < one_hundred_thousand; i++) {\n+      rbtree.upsert(i);\n@@ -757,0 +756,1 @@\n+    EXPECT_EQ(one_hundred_thousand, rbtree.size());\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}