{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -33,0 +34,2 @@\n+class RBTreeNoopAllocator;\n+\n@@ -40,0 +43,1 @@\n+\/\/ If the value has type void, no value will be stored in the nodes.\n@@ -42,1 +46,0 @@\n-\n@@ -51,0 +54,10 @@\n+  \/\/ If the value in a node is not desired (like in an intrusive tree),\n+  \/\/ we can inherit from Empty instead of Value to avoid wasting space.\n+  struct Empty {};\n+\n+  class Value {\n+  protected:\n+    V _value;\n+    Value(const V& val) : _value(val) {}\n+  };\n+\n@@ -52,1 +65,1 @@\n-  class RBNode {\n+  class RBNode : std::conditional_t<std::is_same<V, void>::value, Empty, Value>{\n@@ -61,2 +74,1 @@\n-    const K _key;\n-    V _value;\n+    K _key;\n@@ -68,2 +80,24 @@\n-    V& val() { return _value; }\n-    const V& val() const { return _value; }\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    VV& val() { return Value::_value; }\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    const VV& val() const { return Value::_value; }\n+\n+    RBNode() {}\n+    RBNode(const K& key)\n+        : _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    RBNode(const K& key, const VV& val)\n+        :  Value(val), _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n+\n+    \/\/ Gets the previous in-order node in the tree.\n+    \/\/ nullptr is returned if there is no previous node.\n+    RBNode* prev();\n+\n+    \/\/ Gets the next in-order node in the tree.\n+    \/\/ nullptr is returned if there is no next node.\n+    RBNode* next();\n@@ -81,4 +115,0 @@\n-    RBNode(const K& key, const V& val DEBUG_ONLY(COMMA bool visited))\n-        : _parent(0), _left(nullptr), _right(nullptr),\n-          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(visited)) {}\n-\n@@ -103,4 +133,0 @@\n-    RBNode* prev();\n-\n-    RBNode* next();\n-\n@@ -114,0 +140,22 @@\n+  \/\/ Represents the location of a (would be) node in the tree.\n+  \/\/ If a cursor is valid (valid() == true) it points somewhere in the tree.\n+  \/\/ If the cursor points to an existing node (found() == true), node() can be used to access that node,\n+  \/\/ Otherwise nullptr is returned, regardless if the node is valid or not.\n+  class Cursor {\n+    friend RBTree<K, V, COMPARATOR, ALLOCATOR>;\n+    RBNode** _insert_location;\n+    RBNode* _parent;\n+    K _key;\n+    Cursor() : _insert_location(nullptr), _parent(nullptr) {}\n+    Cursor(RBNode** insert_location, RBNode* parent, const K& key)\n+        : _insert_location(insert_location), _parent(parent), _key(key) {}\n+    Cursor(RBNode* const* insert_location, RBNode* parent, const K& key)\n+        : _insert_location((RBNode**)insert_location), _parent(parent), _key(key) {}\n+\n+  public:\n+    bool valid() const { return _insert_location != nullptr; }\n+    bool found() const { return *_insert_location != nullptr; }\n+    RBNode* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    RBNode* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+  };\n+\n@@ -116,0 +164,1 @@\n+  RBNode* _first;\n@@ -118,1 +167,8 @@\n-  RBNode* allocate_node(const K& key, const V& val) {\n+  RBNode* allocate_node(const K& key) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    return new (node_place) RBNode(key);\n+  }\n+\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  RBNode* allocate_node(const K& key, const VV& val) {\n@@ -121,2 +177,1 @@\n-    _num_nodes++;\n-    return new (node_place) RBNode(key, val DEBUG_ONLY(COMMA _expected_visited));\n+    return new (node_place) RBNode(key, val);\n@@ -125,0 +180,1 @@\n+  template <typename VV = V, ENABLE_IF(std::is_same<VV, void>::value)>\n@@ -126,1 +182,0 @@\n-    node->_value.~V();\n@@ -128,1 +183,6 @@\n-    _num_nodes--;\n+  }\n+\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  void free_node(RBNode* node) {\n+    node->_value.~VV();\n+    _allocator.free(node);\n@@ -140,4 +200,0 @@\n-\n-  \/\/ If the node with key k already exist, the value is updated instead.\n-  RBNode* insert_node(const K& key, const V& val);\n-\n@@ -148,1 +204,1 @@\n-  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove_at_cursor()`\n@@ -154,1 +210,1 @@\n-  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n+  RBTree() : _allocator(), _num_nodes(0), _root(nullptr), _first(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n@@ -157,1 +213,1 @@\n-  ~RBTree() { this->remove_all(); }\n+  ~RBTree() { if (!std::is_same<ALLOCATOR, RBTreeNoopAllocator>::value) this->remove_all(); }\n@@ -160,0 +216,46 @@\n+  RBNode* first() { return _first; }\n+\n+  \/\/ Gets the cursor to the given node.\n+  Cursor get_cursor(RBNode* node);\n+  const Cursor get_cursor(RBNode* node) const;\n+\n+  \/\/ Moves to the next valid node.\n+  \/\/ If no next node exist, the cursor becomes invalid.\n+  Cursor next(const Cursor& cursor);\n+  const Cursor next(const Cursor& cursor) const;\n+\n+  \/\/ Moves to the previous valid node.\n+  \/\/ If no previous node exist, the cursor becomes invalid.\n+  Cursor prev(const Cursor& cursor);\n+  const Cursor prev(const Cursor& cursor) const;\n+\n+  \/\/ Finds the cursor to the node associated with the given key.\n+  Cursor cursor_find(const K& key);\n+  const Cursor cursor_find(const K& key) const;\n+\n+  \/\/ Inserts the given node at the cursor location\n+  \/\/ The cursor must not point to an existing node\n+  void insert_at_cursor(RBNode* node, const Cursor& cursor);\n+\n+  \/\/ Removes the node referenced by the cursor\n+  \/\/ The cursor must point to a valid existing node\n+  void remove_at_cursor(const Cursor& cursor);\n+\n+  \/\/ Replace the node referenced by the cursor with a new node.\n+  \/\/ The old node is destroyed.\n+  \/\/ The user must ensure that no tree properties are broken:\n+  \/\/ There must not exist any node with the same key\n+  \/\/ For all nodes with key < old_node, must also have key < new_node\n+  \/\/ For all nodes with key > old_node, must also have key > new_node\n+  void replace_at_cursor(RBNode* new_node, const Cursor& cursor);\n+\n+  \/\/ Finds the value of the node associated with the given key.\n+  V* find(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.found() ? &cursor.node()->_value : nullptr;\n+  }\n+\n+  V* find(const K& key) const {\n+    const Cursor cursor = cursor_find(key);\n+    return cursor.found() ? &cursor.node()->_value : nullptr;\n+  }\n@@ -161,1 +263,24 @@\n-  \/\/ Inserts a node with the given k\/v into the tree,\n+  \/\/ Finds the node associated with the given key.\n+  RBNode* find_node(const K& key) const {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.node();\n+  }\n+\n+  RBNode* find_node(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.node();\n+  }\n+\n+  \/\/ Inserts a node with the given key into the tree,\n+  \/\/ does nothing if the key already exist.\n+  void upsert(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    if (cursor.found()) {\n+      return;\n+    }\n+\n+    RBNode* node = allocate_node(key);\n+    insert_at_cursor(node, cursor);\n+  }\n+\n+  \/\/ Inserts a node with the given key\/value into the tree,\n@@ -163,3 +288,11 @@\n-  void upsert(const K& key, const V& val) {\n-    RBNode* node = insert_node(key, val);\n-    fix_insert_violations(node);\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  void upsert(const K& key, const VV& val) {\n+    Cursor cursor = cursor_find(key);\n+    RBNode* node = cursor.node();\n+    if (node != nullptr) {\n+      node->_value = val;\n+      return;\n+    }\n+\n+    node = allocate_node(key, val);\n+    insert_at_cursor(node, cursor);\n@@ -171,2 +304,2 @@\n-    RBNode* node = find_node(key);\n-    if (node == nullptr){\n+    Cursor cursor = cursor_find(key);\n+    if (!cursor.found()) {\n@@ -175,1 +308,3 @@\n-    remove(node);\n+    RBNode* node = cursor.node();\n+    remove_at_cursor(cursor);\n+    free_node(node);\n@@ -179,2 +314,5 @@\n-  \/\/ Removes the given node from the tree. node must be a valid node\n-  void remove(RBNode* node);\n+  void remove(RBNode* node) {\n+    Cursor cursor = get_cursor(node);\n+    remove_at_cursor(cursor);\n+    free_node(node);\n+  }\n@@ -197,0 +335,1 @@\n+    _first = nullptr;\n@@ -200,56 +339,3 @@\n-  const RBNode* closest_leq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r < 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_right;\n-      } else {\n-        pos = pos->_left;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  \/\/ Finds the node with the closest key > the given key\n-  const RBNode* closest_gt(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  \/\/ Finds the node with the closest key >= the given key\n-  const RBNode* closest_geq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n+  RBNode* closest_leq(const K& key) const {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.found() ? cursor.node() : prev(cursor).node();\n@@ -259,2 +345,2 @@\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_leq(key));\n+    Cursor cursor = cursor_find(key);\n+    return cursor.found() ? cursor.node() : prev(cursor).node();\n@@ -263,3 +349,4 @@\n-  RBNode* closest_gt(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_gt(key));\n+  \/\/ Finds the node with the closest key > the given key\n+  RBNode* closest_gt(const K& key) const {\n+    Cursor cursor = cursor_find(key);\n+    return next(cursor).node();\n@@ -268,3 +355,3 @@\n-  RBNode* closest_geq(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_geq(key));\n+  RBNode* closest_gt(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    return next(cursor).node();\n@@ -289,19 +376,0 @@\n-  \/\/ Finds the node associated with the key\n-  const RBNode* find_node(const K& key) const;\n-\n-  RBNode* find_node(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->find_node(key));\n-  }\n-\n-  \/\/ Finds the value associated with the key\n-  V* find(const K& key) {\n-    RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n-  const V* find(const K& key) const {\n-    const RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n@@ -314,1 +382,1 @@\n-  void visit_range_in_order(const K& from, const K& to, F f);\n+  void visit_range_in_order(const K& from, const K& to, F f) const;\n@@ -338,0 +406,12 @@\n+class RBTreeNoopAllocator {\n+public:\n+  void* allocate(size_t sz) {\n+    assert(false, \"intrusive tree should not use rbtree allocator\");\n+    return nullptr;\n+  }\n+\n+  void free(void* ptr) {\n+    assert(false, \"intrusive tree should not use rbtree allocator\");\n+  }\n+};\n+\n@@ -341,0 +421,3 @@\n+template <typename K, typename COMPARATOR>\n+using IntrusiveRBTree = RBTree<K, void, COMPARATOR, RBTreeNoopAllocator>;\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":202,"deletions":119,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -189,5 +189,6 @@\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& key) const {\n-  RBNode* curr = _root;\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor_find(const K& key) const {\n+  RBNode* parent = nullptr;\n+  RBNode* const* insert_location = &_root;\n+  while (*insert_location != nullptr) {\n+    const int key_cmp_k = COMPARATOR::cmp(key, (*insert_location)->key());\n@@ -196,3 +197,6 @@\n-      return curr;\n-    } else if (key_cmp_k < 0) {\n-      curr = curr->_left;\n+      break;\n+    }\n+\n+    parent = *insert_location;\n+    if (key_cmp_k < 0) {\n+      insert_location = &((*insert_location)->_left);\n@@ -200,1 +204,1 @@\n-      curr = curr->_right;\n+      insert_location = &((*insert_location)->_right);\n@@ -203,2 +207,1 @@\n-\n-  return nullptr;\n+  return Cursor(insert_location, parent, key);\n@@ -208,7 +211,3 @@\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& key, const V& val) {\n-  RBNode* curr = _root;\n-  if (curr == nullptr) { \/\/ Tree is empty\n-    _root = allocate_node(key, val);\n-    return _root;\n-  }\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_at_cursor(RBNode* node, const Cursor& cursor) {\n+  assert(cursor.valid() && !cursor.found(), \"must be\");\n+  _num_nodes++;\n@@ -216,3 +215,3 @@\n-  RBNode* parent = nullptr;\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+  if (_first == nullptr || cursor._insert_location == &_first->_left) {\n+    _first = node;\n+  }\n@@ -220,4 +219,1 @@\n-    if (key_cmp_k == 0) {\n-      curr->_value = val;\n-      return curr;\n-    }\n+  *cursor._insert_location = node;\n@@ -225,7 +221,5 @@\n-    parent = curr;\n-    if (key_cmp_k < 0) {\n-      curr = curr->_left;\n-    } else {\n-      curr = curr->_right;\n-    }\n-  }\n+  node->set_parent(cursor._parent);\n+  node->set_red();\n+  node->_left = nullptr;\n+  node->_right = nullptr;\n+  node->_key = cursor._key;\n@@ -233,3 +227,3 @@\n-  \/\/ Create and insert new node\n-  RBNode* node = allocate_node(key, val);\n-  node->set_parent(parent);\n+#ifdef ASSERT\n+  node->_visited = _expected_visited;\n+#endif \/\/ ASSERT\n@@ -237,5 +231,2 @@\n-  const int key_cmp_k = COMPARATOR::cmp(key, parent->key());\n-  if (key_cmp_k < 0) {\n-    parent->_left = node;\n-  } else {\n-    parent->_right = node;\n+  if (cursor._parent == nullptr) {\n+    return;\n@@ -244,1 +235,1 @@\n-  return node;\n+  fix_insert_violations(node);\n@@ -441,2 +432,8 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n-  assert(node != nullptr, \"must be\");\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_at_cursor(const Cursor& cursor) {\n+  assert(cursor.valid() && cursor.found(), \"must be\");\n+  _num_nodes--;\n+\n+  RBNode* node = cursor.node();\n+  if (node == _first) {\n+    _first = node->next();\n+  }\n@@ -476,1 +473,111 @@\n-  free_node(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) const {\n+  if (node == nullptr) {\n+    return Cursor();\n+  }\n+\n+  if (node->parent() == nullptr) {\n+    return Cursor(&_root, nullptr, node->key());\n+  }\n+\n+  RBNode* parent = node->parent();\n+  RBNode** insert_location =\n+      node->is_left_child() ? &parent->_left : &parent->_right;\n+  return Cursor(insert_location, parent, node->key());\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) const {\n+  if (cursor.found()) {\n+    return get_cursor(cursor.node()->next());\n+  }\n+\n+  if (cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&cursor._parent->_left == cursor._insert_location) { \/\/ Left child, parent is next\n+    return get_cursor(cursor._parent);\n+  }\n+\n+  return get_cursor(cursor._parent->next()); \/\/ Right child, parent's next is also node's next\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) const {\n+  if (cursor.found()) {\n+    return get_cursor(cursor.node()->prev());\n+  }\n+\n+  if (cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&cursor._parent->_right == cursor._insert_location) { \/\/ Right child, parent is prev\n+    return get_cursor(cursor._parent);\n+  }\n+\n+  return get_cursor(cursor._parent->prev()); \/\/ Left child, parent's prev is also node's prev\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::replace_at_cursor(RBNode* new_node, const Cursor& cursor) {\n+  assert(cursor.valid() && cursor.found(), \"must be\");\n+  RBNode* old_node = cursor.node();\n+  if (old_node == new_node) {\n+    return;\n+  }\n+\n+  *cursor._insert_location = new_node;\n+  new_node->set_parent(cursor._parent);\n+  new_node->_color = old_node->_color;\n+\n+  new_node->_left = old_node->_left;\n+  new_node->_right = old_node->_right;\n+  if (new_node->_left != nullptr) {\n+    new_node->_left->set_parent(new_node);\n+  } else if (new_node->_right != nullptr) {\n+    new_node->_right->_parent = new_node;\n+    new_node->_right->set_parent(new_node);\n+  }\n+\n+  if (old_node == _first) {\n+    _first = new_node;\n+  }\n+\n+  free_node(old_node);\n+\n+#ifdef ASSERT\n+  verify_self(); \/\/ Dangerous operation, should verify no tree properties were broken\n+#endif \/\/ ASSERT\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor_find(const K& key) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->cursor_find(key);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->get_cursor(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->next(cursor);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->prev(cursor);\n@@ -482,11 +589,4 @@\n-  RBNode* to_visit[64];\n-  int stack_idx = 0;\n-  RBNode* head = _root;\n-  while (stack_idx > 0 || head != nullptr) {\n-    while (head != nullptr) {\n-      to_visit[stack_idx++] = head;\n-      head = head->_left;\n-    }\n-    head = to_visit[--stack_idx];\n-    f(head);\n-    head = head->_right;\n+  RBNode* node = _first;\n+  while (node != nullptr) {\n+    f(node);\n+    node = node->next();\n@@ -498,1 +598,1 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) {\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n@@ -500,3 +600,8 @@\n-  RBNode* curr = closest_geq(from);\n-  if (curr == nullptr) return;\n-  RBNode* end = closest_geq(to);\n+  if (_root == nullptr) {\n+    return;\n+  }\n+\n+  Cursor cursor_start = cursor_find(from);\n+  Cursor cursor_end = cursor_find(to);\n+  RBNode* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  RBNode* end = cursor_end.found() ? cursor_end.node() : next(cursor_end).node();\n@@ -504,3 +609,3 @@\n-  while (curr != nullptr && curr != end) {\n-    f(curr);\n-    curr = curr->next();\n+  while (start != end) {\n+    f(start);\n+    start = start->next();\n@@ -514,1 +619,1 @@\n-    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    assert(_num_nodes == 0, \"rbtree has %zu nodes but no root\", _num_nodes);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":168,"deletions":63,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -82,1 +82,15 @@\n-using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtOther>;\n+  using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtOther>;\n+  using IntrusiveTreeInt = IntrusiveRBTree<int, Cmp>;\n+  using IntrusiveNode = IntrusiveTreeInt::RBNode;\n+  using IntrusiveCursor = IntrusiveTreeInt::Cursor;\n+\n+  struct IntrusiveHolder {\n+    IntrusiveNode node;\n+    int data;\n+\n+    IntrusiveNode* get_node() { return &node; }\n+\n+    IntrusiveHolder() {}\n+    IntrusiveHolder(int data) : data(data) {}\n+    static IntrusiveHolder* cast_to_self(IntrusiveNode* node) { return (IntrusiveHolder*)node; }\n+  };\n@@ -301,0 +315,71 @@\n+  void test_closest_gt() {\n+    using Node = RBTreeInt::RBNode;\n+    {\n+      RBTreeInt rbtree;\n+      Node* n = rbtree.closest_gt(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-5, -5);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-5);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-10);\n+      EXPECT_EQ(-5, n->key());\n+\n+      rbtree.upsert(10, 10);\n+      n = rbtree.closest_gt(5);\n+      EXPECT_EQ(10, n->key());\n+\n+      n = rbtree.closest_gt(10);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_first() {\n+    using Node = RBTreeInt::RBNode;\n+\n+    RBTreeInt rbtree;\n+    Node* n = rbtree.first();\n+    EXPECT_EQ(nullptr, n);\n+\n+    rbtree.upsert(0, 0);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(2, 2);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(1, 1);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(-1, -1);\n+    n = rbtree.first();\n+    EXPECT_EQ(-1, n->key());\n+\n+    rbtree.remove(-1);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(1);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(0);\n+    n = rbtree.first();\n+    EXPECT_EQ(2, n->key());\n+\n+    rbtree.remove(2);\n+    n = rbtree.first();\n+    EXPECT_EQ(nullptr, n);\n+\n+  }\n+\n@@ -321,1 +406,1 @@\n-    void test_node_next() {\n+  void test_node_next() {\n@@ -389,1 +474,1 @@\n-    rbtree.visit_in_order([&](Node* node) {\n+    rbtree.visit_in_order([&](Tree::RBNode* node) {\n@@ -394,0 +479,82 @@\n+  void test_cursor_find() {\n+    constexpr const int num_nodes = 10;\n+    RBTreeInt tree;\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor_find(n);\n+      EXPECT_FALSE(find_cursor.found());\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor_find(n);\n+      EXPECT_TRUE(find_cursor.found());\n+    }\n+\n+    EXPECT_FALSE(tree.cursor_find(-1).found());\n+    EXPECT_FALSE(tree.cursor_find(101).found());\n+  }\n+\n+  void test_get_cursor() {\n+    constexpr const int num_nodes = 10;\n+    IntrusiveTreeInt tree;\n+    GrowableArrayCHeap<IntrusiveHolder*, mtTest> nodes(num_nodes);\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n);\n+\n+      tree.insert_at_cursor(place->get_node(), tree.cursor_find(n));\n+      nodes.push(place);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveNode* node = nodes.at(n)->get_node();\n+      IntrusiveCursor get_cursor = tree.get_cursor(node);\n+      IntrusiveCursor find_cursor = tree.cursor_find(n);\n+      EXPECT_TRUE(get_cursor.found());\n+      EXPECT_TRUE(get_cursor.valid());\n+      EXPECT_TRUE(find_cursor.found());\n+      EXPECT_TRUE(find_cursor.valid());\n+      EXPECT_EQ(get_cursor.node(), find_cursor.node());\n+    }\n+  }\n+\n+  void test_cursor_empty_tree() {\n+    RBTreeInt tree;\n+    RBTreeInt::Cursor cursor = tree.get_cursor(tree.first());\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor_find(0);\n+    EXPECT_TRUE(cursor.valid());\n+    EXPECT_FALSE(cursor.found());\n+    EXPECT_FALSE(tree.next(cursor).valid());\n+  }\n+\n+  void test_cursor_iterate() {\n+    constexpr const int num_nodes = 100;\n+    RBTreeInt tree;\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    RBTreeInt::Cursor cursor = tree.cursor_find(0);\n+    for (int n = 0; n <= num_nodes; n++) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.next(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor_find(num_nodes);\n+    for (int n = num_nodes; n >= 0; n--) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.prev(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+  }\n+\n@@ -441,0 +608,48 @@\n+  void test_intrusive() {\n+    IntrusiveTreeInt intrusive_tree;\n+    int num_iterations = 100;\n+\n+    \/\/ Insert values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NULL(cursor.node());\n+\n+      \/\/ Custom allocation here is just malloc\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n);\n+\n+      intrusive_tree.insert_at_cursor(place->get_node(), cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor_find(n);\n+\n+      EXPECT_NOT_NULL(cursor2.node());\n+\n+      verify_it(intrusive_tree);\n+    }\n+\n+    \/\/ Check inserted values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+      EXPECT_EQ(n, IntrusiveHolder::cast_to_self(cursor.node())->data);\n+    }\n+\n+    \/\/ Remove all values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+\n+      intrusive_tree.remove_at_cursor(cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor_find(n);\n+\n+      EXPECT_NULL(cursor2.node());\n+\n+      verify_it(intrusive_tree);\n+    }\n+\n+    \/\/ Check removed values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NULL(cursor.node());\n+    }\n+  }\n+\n@@ -494,0 +709,8 @@\n+TEST_VM_F(RBTreeTest, TestClosestGt) {\n+  this->test_closest_gt();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFirst) {\n+  this->test_first();\n+}\n+\n@@ -510,0 +733,16 @@\n+TEST_VM_F(RBTreeTest, CursorFind) {\n+  this->test_cursor_find();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorGet) {\n+  this->test_get_cursor();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorEmptyTreeTest) {\n+  this->test_cursor_empty_tree();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorIterateTest) {\n+  this->test_cursor_iterate();\n+}\n+\n@@ -511,0 +750,4 @@\n+TEST_VM_F(RBTreeTest, IntrusiveTest) {\n+  this->test_intrusive();\n+}\n+\n@@ -563,2 +806,1 @@\n-    struct Nothing {};\n-    RBTreeCHeap<int, Nothing, Cmp, mtOther> rbtree;\n+    RBTreeCHeap<int, void, Cmp, mtOther> rbtree;\n@@ -567,1 +809,1 @@\n-      rbtree.upsert(i, Nothing());\n+      rbtree.upsert(i);\n@@ -569,0 +811,1 @@\n+    EXPECT_EQ((size_t)one_hundred_thousand, rbtree.size());\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":249,"deletions":6,"binary":false,"changes":255,"status":"modified"}]}