{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -33,1 +34,9 @@\n-class outputStream;\n+\/\/ An intrusive red-black tree is constructed with two template parameters:\n+\/\/ K is the key type used.\n+\/\/ COMPARATOR must have a static function `cmp(K a, const IntrusiveRBNode* b)` which returns:\n+\/\/     - an int < 0 when a < b\n+\/\/     - an int == 0 when a == b\n+\/\/     - an int > 0 when a > b\n+\/\/ K needs to be of a type that is trivially destructible.\n+\/\/ K needs to be stored by the user and is not stored inside the tree.\n+\/\/ Nodes are address stable and will not change during its lifetime.\n@@ -35,1 +44,4 @@\n-\/\/ COMPARATOR must have a static function `cmp(a,b)` which returns:\n+\/\/ A red-black tree is constructed with four template parameters:\n+\/\/ K is the key type stored in the tree nodes.\n+\/\/ V is the value type stored in the tree nodes.\n+\/\/ COMPARATOR must have one of the static functions `cmp(K a, K b)` or `cmp(K a, const RBNode<K, V>* b) which returns:\n@@ -39,3 +51,2 @@\n-\/\/ ALLOCATOR must check for oom and exit, as RBTree currently does not handle the\n-\/\/ allocation failing.\n-\/\/ Key needs to be of a type that is trivially destructible.\n+\/\/ ALLOCATOR must check for oom and exit, as RBTree does not handle the allocation failing.\n+\/\/ K needs to be of a type that is trivially destructible.\n@@ -45,2 +56,10 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-class RBTree {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+class AbstractRBTree;\n+\n+class outputStream;\n+\n+class IntrusiveRBNode {\n+  template <typename K, typename NodeType, typename COMPARATOR>\n+  friend class AbstractRBTree;\n+  template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+  friend class RBTree;\n@@ -48,4 +67,6 @@\n-  typedef RBTree<K, V, COMPARATOR, ALLOCATOR> TreeType;\n-private:\n-  ALLOCATOR _allocator;\n-  size_t _num_nodes;\n+\n+  uintptr_t _parent; \/\/ LSB encodes color information. 0 = RED, 1 = BLACK\n+  IntrusiveRBNode* _left;\n+  IntrusiveRBNode* _right;\n+\n+  DEBUG_ONLY(mutable bool _visited);\n@@ -54,3 +75,1 @@\n-  class RBNode {\n-    friend RBTree;\n-    friend class RBTreeTest;\n+  IntrusiveRBNode() : _parent(0), _left(nullptr), _right(nullptr) DEBUG_ONLY(COMMA _visited(false)) {}\n@@ -58,4 +77,4 @@\n-  private:\n-    uintptr_t _parent; \/\/ LSB encodes color information. 0 = RED, 1 = BLACK\n-    RBNode* _left;\n-    RBNode* _right;\n+  \/\/ Gets the previous in-order node in the tree.\n+  \/\/ nullptr is returned if there is no previous node.\n+  const IntrusiveRBNode* prev() const;\n+  IntrusiveRBNode* prev();\n@@ -63,2 +82,4 @@\n-    const K _key;\n-    V _value;\n+  \/\/ Gets the next in-order node in the tree.\n+  \/\/ nullptr is returned if there is no next node.\n+  const IntrusiveRBNode* next() const;\n+  IntrusiveRBNode* next();\n@@ -66,1 +87,1 @@\n-    DEBUG_ONLY(mutable bool _visited);\n+  void print_on(outputStream* st, int depth = 0) const;\n@@ -68,5 +89,3 @@\n-  public:\n-    const K& key() const { return _key; }\n-    V& val() { return _value; }\n-    const V& val() const { return _value; }\n-    void set_val(const V& v) { _value = v; }\n+private:\n+  bool is_black() const { return (_parent & 0x1) != 0; }\n+  bool is_red() const { return (_parent & 0x1) == 0; }\n@@ -74,3 +93,2 @@\n-  private:\n-    bool is_black() const { return (_parent & 0x1) != 0; }\n-    bool is_red() const { return (_parent & 0x1) == 0; }\n+  void set_black() { _parent |= 0x1; }\n+  void set_red() { _parent &= ~0x1; }\n@@ -78,2 +96,2 @@\n-    void set_black() { _parent |= 0x1; }\n-    void set_red() { _parent &= ~0x1; }\n+  IntrusiveRBNode* parent() const { return (IntrusiveRBNode*)(_parent & ~0x1); }\n+  void set_parent(IntrusiveRBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n@@ -81,2 +99,3 @@\n-    RBNode* parent() const { return (RBNode*)(_parent & ~0x1); }\n-    void set_parent(RBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n+  bool is_right_child() const {\n+    return parent() != nullptr && parent()->_right == this;\n+  }\n@@ -84,3 +103,3 @@\n-    RBNode(const K& key, const V& val DEBUG_ONLY(COMMA bool visited))\n-        : _parent(0), _left(nullptr), _right(nullptr),\n-          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(visited)) {}\n+  bool is_left_child() const {\n+    return parent() != nullptr && parent()->_left == this;\n+  }\n@@ -88,3 +107,1 @@\n-    bool is_right_child() const {\n-      return parent() != nullptr && parent()->_right == this;\n-    }\n+  void replace_child(IntrusiveRBNode* old_child, IntrusiveRBNode* new_child);\n@@ -92,3 +109,3 @@\n-    bool is_left_child() const {\n-      return parent() != nullptr && parent()->_left == this;\n-    }\n+  \/\/ This node down, right child up\n+  \/\/ Returns right child (now parent)\n+  IntrusiveRBNode* rotate_left();\n@@ -96,1 +113,3 @@\n-    void replace_child(RBNode* old_child, RBNode* new_child);\n+  \/\/ This node down, left child up\n+  \/\/ Returns left child (now parent)\n+  IntrusiveRBNode* rotate_right();\n@@ -98,3 +117,5 @@\n-    \/\/ This node down, right child up\n-    \/\/ Returns right child (now parent)\n-    RBNode* rotate_left();\n+#ifdef ASSERT\n+  void verify(size_t& num_nodes, size_t& black_nodes_until_leaf,\n+              size_t& shortest_leaf_path, size_t& longest_leaf_path,\n+              size_t& tree_depth, bool expect_visited) const;\n+#endif \/\/ ASSERT\n@@ -102,3 +123,1 @@\n-    \/\/ This node down, left child up\n-    \/\/ Returns left child (now parent)\n-    RBNode* rotate_right();\n+};\n@@ -106,1 +125,5 @@\n-    const RBNode* prev() const;\n+template <typename K, typename V>\n+class RBNode : public IntrusiveRBNode {\n+  template <typename K2, typename V2, typename COMPARATOR, typename ALLOCATOR>\n+  friend class RBTree;\n+  friend class RBTreeTest;\n@@ -108,1 +131,3 @@\n-    const RBNode* next() const;\n+private:\n+  K _key;\n+  V _value;\n@@ -110,6 +135,2 @@\n-  #ifdef ASSERT\n-    void verify(size_t& num_nodes, size_t& black_nodes_until_leaf,\n-                size_t& shortest_leaf_path, size_t& longest_leaf_path,\n-                size_t& tree_depth, bool expect_visited) const;\n-  #endif \/\/ ASSERT\n-  }; \/\/ End: RBNode\n+public:\n+  const K& key() const { return _key; }\n@@ -117,1 +138,3 @@\n-  typedef TreeType::RBNode NodeType;\n+  V& val() { return _value; }\n+  const V& val() const { return _value; }\n+  void set_val(const V& v) { _value = v; }\n@@ -119,2 +142,43 @@\n-private:\n-  RBNode* _root;\n+  RBNode() {}\n+  RBNode(const K& key) : IntrusiveRBNode(), _key(key) {}\n+  RBNode(const K& key, const V& val) : IntrusiveRBNode(), _key(key), _value(val) {}\n+\n+  const RBNode<K, V>* prev() const { return (RBNode<K, V>*)IntrusiveRBNode::prev(); }\n+  const RBNode<K, V>* next() const { return (RBNode<K, V>*)IntrusiveRBNode::next(); }\n+  RBNode<K, V>* prev() { return (RBNode<K, V>*)IntrusiveRBNode::prev(); }\n+  RBNode<K, V>* next() { return (RBNode<K, V>*)IntrusiveRBNode::next(); }\n+\n+  void print_on(outputStream* st, int depth = 0) const;\n+\n+};\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+class AbstractRBTree {\n+  friend class RBTreeTest;\n+  typedef AbstractRBTree<K, NodeType, COMPARATOR> TreeType;\n+\n+public:\n+  \/\/ Represents the location of a (would be) node in the tree.\n+  \/\/ If a cursor is valid (valid() == true) it points somewhere in the tree.\n+  \/\/ If the cursor points to an existing node (found() == true), node() can be used to access that node.\n+  \/\/ If no node is pointed to, node() returns null, regardless if the cursor is valid or not.\n+  class Cursor {\n+    friend AbstractRBTree<K, NodeType, COMPARATOR>;\n+    NodeType** _insert_location;\n+    NodeType* _parent;\n+    Cursor() : _insert_location(nullptr), _parent(nullptr) {}\n+    Cursor(NodeType** insert_location, NodeType* parent)\n+        : _insert_location(insert_location), _parent(parent) {}\n+    Cursor(NodeType* const* insert_location, NodeType* parent)\n+        : _insert_location((NodeType**)insert_location), _parent(parent) {}\n+\n+  public:\n+    bool valid() const { return _insert_location != nullptr; }\n+    bool found() const { return *_insert_location != nullptr; }\n+    NodeType* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    NodeType* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+  };\n+\n+protected:\n+  size_t _num_nodes;\n+  IntrusiveRBNode* _root;\n@@ -123,5 +187,4 @@\n-  RBNode* allocate_node(const K& key, const V& val) {\n-    void* node_place = _allocator.allocate(sizeof(RBNode));\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n-    _num_nodes++;\n-    return new (node_place) RBNode(key, val DEBUG_ONLY(COMMA _expected_visited));\n+private:\n+  template <typename CMP = decltype(COMPARATOR::cmp), ENABLE_IF(std::is_same<CMP, int (K, K)>::value)>\n+  int cmp(const K& a, const NodeType* b) const {\n+    return COMPARATOR::cmp(a, b->key());\n@@ -130,4 +193,3 @@\n-  void free_node(RBNode* node) {\n-    node->_value.~V();\n-    _allocator.free(node);\n-    _num_nodes--;\n+  template <typename CMP = decltype(COMPARATOR::cmp), ENABLE_IF(std::is_same<CMP, int (K, const NodeType*)>::value)>\n+  int cmp(const K& a, const NodeType* b) const {\n+    return COMPARATOR::cmp(a, b);\n@@ -137,1 +199,1 @@\n-  static inline bool is_black(const RBNode* node) {\n+  static inline bool is_black(const IntrusiveRBNode* node) {\n@@ -141,1 +203,1 @@\n-  static inline bool is_red(const RBNode* node) {\n+  static inline bool is_red(const IntrusiveRBNode* node) {\n@@ -145,0 +207,1 @@\n+  void fix_insert_violations(IntrusiveRBNode* node);\n@@ -146,2 +209,1 @@\n-  \/\/ If the node with key k already exist, the value is updated instead.\n-  RBNode* insert_node(const K& key, const V& val);\n+  void remove_black_leaf(IntrusiveRBNode* node);\n@@ -149,6 +211,2 @@\n-  void fix_insert_violations(RBNode* node);\n-\n-  void remove_black_leaf(RBNode* node);\n-\n-  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n-  void remove_from_tree(RBNode* node);\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove_at_cursor()`\n+  void remove_from_tree(IntrusiveRBNode* node);\n@@ -159,1 +217,1 @@\n-  NONCOPYABLE(RBTree);\n+  NONCOPYABLE(AbstractRBTree);\n@@ -161,1 +219,1 @@\n-  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n+  AbstractRBTree() : _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n@@ -163,0 +221,3 @@\n+    static_assert(std::is_same<decltype(COMPARATOR::cmp), int(K, K)>::value ||\n+                  std::is_same<decltype(COMPARATOR::cmp), int(K, const NodeType*)>::value,\n+                  \"comparator must be of correct type\");\n@@ -164,1 +225,0 @@\n-  ~RBTree() { this->remove_all(); }\n@@ -168,5 +228,36 @@\n-  \/\/ Inserts a node with the given k\/v into the tree,\n-  \/\/ if the key already exist, the value is updated instead.\n-  void upsert(const K& key, const V& val) {\n-    RBNode* node = insert_node(key, val);\n-    fix_insert_violations(node);\n+  \/\/ Gets the cursor associated with the given node or key.\n+  Cursor cursor(const K& key, const NodeType* hint_node = nullptr);\n+  Cursor cursor(const NodeType* node);\n+  const Cursor cursor(const K& key, const NodeType* hint_node = nullptr) const;\n+  const Cursor cursor(const NodeType* node) const;\n+\n+  \/\/ Moves to the next existing node.\n+  \/\/ If no next node exist, the cursor becomes invalid.\n+  Cursor next(const Cursor& node_cursor);\n+  const Cursor next(const Cursor& node_cursor) const;\n+\n+  \/\/ Moves to the previous existing node.\n+  \/\/ If no previous node exist, the cursor becomes invalid.\n+  Cursor prev(const Cursor& node_cursor);\n+  const Cursor prev(const Cursor& node_cursor) const;\n+\n+  \/\/ Initializes and inserts a node at the cursor location.\n+  \/\/ The cursor must not point to an existing node.\n+  void insert_at_cursor(NodeType* node, const Cursor& node_cursor);\n+\n+  \/\/ Removes the node referenced by the cursor\n+  \/\/ The cursor must point to a valid existing node\n+  void remove_at_cursor(const Cursor& node_cursor);\n+\n+  \/\/ Replace the node referenced by the cursor with a new node.\n+  \/\/ The old node is destroyed.\n+  \/\/ The user must ensure that no tree properties are broken:\n+  \/\/ There must not exist any node with the new key\n+  \/\/ For all nodes with key < old_key, must also have key < new_key\n+  \/\/ For all nodes with key > old_key, must also have key > new_key\n+  void replace_at_cursor(NodeType* new_node, const Cursor& node_cursor);\n+\n+  \/\/ Finds the node associated with the given key.\n+  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr) const {\n+    Cursor node_cursor = cursor(key, hint_node);\n+    return node_cursor.node();\n@@ -175,9 +266,3 @@\n-  \/\/ Removes the node with the given key from the tree if it exists.\n-  \/\/ Returns true if the node was successfully removed, false otherwise.\n-  bool remove(const K& key) {\n-    RBNode* node = find_node(key);\n-    if (node == nullptr){\n-      return false;\n-    }\n-    remove(node);\n-    return true;\n+  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr) {\n+    Cursor node_cursor = cursor(key, hint_node);\n+    return node_cursor.node();\n@@ -186,8 +271,5 @@\n-  \/\/ Removes the given node from the tree. node must be a valid node\n-  void remove(RBNode* node);\n-\n-  \/\/ Removes all existing nodes from the tree.\n-  void remove_all() {\n-    RBNode* to_delete[64];\n-    int stack_idx = 0;\n-    to_delete[stack_idx++] = _root;\n+  \/\/ Inserts the given node into the tree.\n+  void insert(const K& key, NodeType* node, const NodeType* hint_node = nullptr) {\n+    Cursor node_cursor = cursor(key, hint_node);\n+    insert_at_cursor(node, node_cursor);\n+  }\n@@ -195,9 +277,3 @@\n-    while (stack_idx > 0) {\n-      RBNode* head = to_delete[--stack_idx];\n-      if (head == nullptr) continue;\n-      to_delete[stack_idx++] = head->_left;\n-      to_delete[stack_idx++] = head->_right;\n-      free_node(head);\n-    }\n-    _num_nodes = 0;\n-    _root = nullptr;\n+  void remove(NodeType* node) {\n+    Cursor node_cursor = cursor(node);\n+    remove_at_cursor(node_cursor);\n@@ -206,19 +282,5 @@\n-  \/\/ Finds the node with the closest key <= the given key\n-  const RBNode* closest_leq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r < 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_right;\n-      } else {\n-        pos = pos->_left;\n-      }\n-    }\n-    return candidate;\n+  \/\/ Finds the node with the closest key <= the given key.\n+  \/\/ If no node is found, null is returned instead.\n+  NodeType* closest_leq(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n@@ -227,15 +289,3 @@\n-  \/\/ Finds the node with the closest key > the given key\n-  const RBNode* closest_gt(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n+  NodeType* closest_leq(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n@@ -244,19 +294,5 @@\n-  \/\/ Finds the node with the closest key >= the given key\n-  const RBNode* closest_geq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n+  \/\/ Finds the node with the closest key > the given key.\n+  \/\/ If no node is found, null is returned instead.\n+  NodeType* closest_gt(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return next(node_cursor).node();\n@@ -265,3 +301,3 @@\n-  RBNode* closest_leq(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_leq(key));\n+  NodeType* closest_gt(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return next(node_cursor).node();\n@@ -270,3 +306,5 @@\n-  RBNode* closest_gt(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_gt(key));\n+  \/\/ Finds the node with the closest key >= the given key.\n+  \/\/ If no node is found, null is returned instead.\n+  NodeType* closest_ge(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n@@ -275,3 +313,3 @@\n-  RBNode* closest_geq(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_geq(key));\n+  NodeType* closest_ge(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n@@ -282,2 +320,2 @@\n-  const RBNode* leftmost() const {\n-    RBNode* n = _root, *n2 = nullptr;\n+  const NodeType* leftmost() const {\n+    IntrusiveRBNode* n = _root, *n2 = nullptr;\n@@ -288,1 +326,1 @@\n-    return n2;\n+    return (NodeType*)n2;\n@@ -293,2 +331,2 @@\n-  const RBNode* rightmost() const {\n-    RBNode* n = _root, *n2 = nullptr;\n+  const NodeType* rightmost() const {\n+    IntrusiveRBNode* n = _root, *n2 = nullptr;\n@@ -299,1 +337,1 @@\n-    return n2;\n+    return (NodeType*)n2;\n@@ -302,2 +340,2 @@\n-  RBNode* leftmost()  { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->leftmost()); }\n-  RBNode* rightmost() { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->rightmost()); }\n+  NodeType* leftmost()  { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->leftmost()); }\n+  NodeType* rightmost() { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->rightmost()); }\n@@ -306,3 +344,3 @@\n-    RBNode* start;\n-    RBNode* end;\n-    Range(RBNode* start, RBNode* end)\n+    NodeType* start;\n+    NodeType* end;\n+    Range(NodeType* start, NodeType* end)\n@@ -316,2 +354,2 @@\n-    RBNode* start = closest_leq(key);\n-    RBNode* end = closest_gt(key);\n+    NodeType* start = closest_leq(key);\n+    NodeType* end = closest_gt(key);\n@@ -321,19 +359,0 @@\n-  \/\/ Finds the node associated with the key\n-  const RBNode* find_node(const K& key) const;\n-\n-  RBNode* find_node(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->find_node(key));\n-  }\n-\n-  \/\/ Finds the value associated with the key\n-  V* find(const K& key) {\n-    RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n-  const V* find(const K& key) const {\n-    const RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n@@ -355,0 +374,97 @@\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+class RBTree : public AbstractRBTree<K, RBNode<K, V>, COMPARATOR> {\n+  friend class RBTreeTest;\n+  typedef AbstractRBTree<K, RBNode<K, V>, COMPARATOR> BaseType;\n+\n+  ALLOCATOR _allocator;\n+\n+public:\n+  RBTree() : BaseType(), _allocator() {}\n+  ~RBTree() { remove_all(); }\n+\n+  typedef typename BaseType::Cursor Cursor;\n+  using BaseType::cursor;\n+  using BaseType::insert_at_cursor;\n+  using BaseType::remove_at_cursor;\n+  using BaseType::next;\n+  using BaseType::prev;\n+\n+  void replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor) {\n+    RBNode<K, V>* old_node = node_cursor.node();\n+    BaseType::replace_at_cursor(new_node, node_cursor);\n+    free_node(old_node);\n+  }\n+\n+  RBNode<K, V>* allocate_node(const K& key, const V& val) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    return new (node_place) RBNode<K, V>(key, val);\n+  }\n+\n+  void free_node(RBNode<K, V>* node) {\n+    node->_value.~V();\n+    _allocator.free(node);\n+  }\n+\n+  \/\/ Inserts a node with the given key\/value into the tree,\n+  \/\/ if the key already exist, the value is updated instead.\n+  void upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n+    Cursor node_cursor = cursor(key, hint_node);\n+    RBNode<K, V>* node = node_cursor.node();\n+    if (node != nullptr) {\n+      node->set_val(val);\n+      return;\n+    }\n+\n+    node = allocate_node(key, val);\n+    insert_at_cursor(node, node_cursor);\n+  }\n+\n+  \/\/ Finds the value of the node associated with the given key.\n+  V* find(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+  }\n+\n+  V* find(const K& key) const {\n+    const Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+  }\n+\n+  void remove(RBNode<K, V>* node) {\n+    Cursor node_cursor = cursor(node);\n+    remove_at_cursor(node_cursor);\n+    free_node(node);\n+  }\n+\n+  \/\/ Removes the node with the given key from the tree if it exists.\n+  \/\/ Returns true if the node was successfully removed, false otherwise.\n+  bool remove(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    if (!node_cursor.found()) {\n+      return false;\n+    }\n+    RBNode<K, V>* node = node_cursor.node();\n+    remove_at_cursor(node_cursor);\n+    free_node((RBNode<K, V>*)node);\n+    return true;\n+  }\n+\n+  \/\/ Removes all existing nodes from the tree.\n+  void remove_all() {\n+    IntrusiveRBNode* to_delete[64];\n+    int stack_idx = 0;\n+    to_delete[stack_idx++] = BaseType::_root;\n+\n+    while (stack_idx > 0) {\n+      IntrusiveRBNode* head = to_delete[--stack_idx];\n+      if (head == nullptr) continue;\n+      to_delete[stack_idx++] = head->_left;\n+      to_delete[stack_idx++] = head->_right;\n+      free_node((RBNode<K, V>*)head);\n+    }\n+    BaseType::_num_nodes = 0;\n+    BaseType::_root = nullptr;\n+  }\n+};\n+\n@@ -373,0 +489,3 @@\n+template <typename K, typename COMPARATOR>\n+using IntrusiveRBTree = AbstractRBTree<K, IntrusiveRBNode, COMPARATOR>;\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":326,"deletions":207,"binary":false,"changes":533,"status":"modified"},{"patch":"@@ -35,3 +35,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::replace_child(\n-    RBNode* old_child, RBNode* new_child) {\n+inline void IntrusiveRBNode::replace_child(IntrusiveRBNode* old_child, IntrusiveRBNode* new_child) {\n@@ -47,3 +45,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_left() {\n+inline IntrusiveRBNode* IntrusiveRBNode::rotate_left() {\n@@ -51,1 +47,1 @@\n-  RBNode* old_right = _right;\n+  IntrusiveRBNode* old_right = _right;\n@@ -69,3 +65,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_right() {\n+inline IntrusiveRBNode* IntrusiveRBNode::rotate_right() {\n@@ -73,1 +67,1 @@\n-  RBNode* old_left = _left;\n+  IntrusiveRBNode* old_left = _left;\n@@ -91,4 +85,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::prev() const {\n-  const RBNode* node = this;\n+inline const IntrusiveRBNode* IntrusiveRBNode::prev() const {\n+  const IntrusiveRBNode* node = this;\n@@ -109,4 +101,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::next() const {\n-  const RBNode* node = this;\n+inline const IntrusiveRBNode* IntrusiveRBNode::next() const {\n+  const IntrusiveRBNode* node = this;\n@@ -127,0 +117,8 @@\n+inline IntrusiveRBNode* IntrusiveRBNode::prev() {\n+  return const_cast<IntrusiveRBNode*>(static_cast<const IntrusiveRBNode*>(this)->prev());\n+}\n+\n+inline IntrusiveRBNode* IntrusiveRBNode::next() {\n+  return const_cast<IntrusiveRBNode*>(static_cast<const IntrusiveRBNode*>(this)->next());\n+}\n+\n@@ -128,2 +126,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::verify(\n+inline void IntrusiveRBNode::verify(\n@@ -144,1 +141,0 @@\n-    assert(COMPARATOR::cmp(_left->key(), _key) < 0, \"left node must be less than parent\");\n@@ -160,1 +156,0 @@\n-    assert(COMPARATOR::cmp(_right->key(), _key) > 0, \"right node must be greater than parent\");\n@@ -190,13 +185,18 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& key) const {\n-  RBNode* curr = _root;\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n-\n-    if (key_cmp_k == 0) {\n-      return curr;\n-    } else if (key_cmp_k < 0) {\n-      curr = curr->_left;\n-    } else {\n-      curr = curr->_right;\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const K& key, const NodeType* hint_node) const {\n+  IntrusiveRBNode* parent = nullptr;\n+  IntrusiveRBNode* const* insert_location = &_root;\n+\n+  if (hint_node != nullptr) {\n+    const int hint_cmp = cmp(key, hint_node);\n+    while (hint_node->parent() != nullptr) {\n+      const int parent_cmp = cmp(key, (NodeType*)hint_node->parent());\n+      \/\/ Move up until the parent would put us on the other side of the key.\n+      \/\/ Meaning we are in the correct subtree.\n+      if ((parent_cmp <= 0 && hint_cmp < 0) ||\n+          (parent_cmp >= 0 && hint_cmp > 0)) {\n+        hint_node = (NodeType*)hint_node->parent();\n+      } else {\n+        break;\n+      }\n@@ -204,4 +204,0 @@\n-  }\n-\n-  return nullptr;\n-}\n@@ -209,7 +205,5 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& key, const V& val) {\n-  RBNode* curr = _root;\n-  if (curr == nullptr) { \/\/ Tree is empty\n-    _root = allocate_node(key, val);\n-    return _root;\n+    if (hint_node->is_left_child()) {\n+      insert_location = &hint_node->parent()->_left;\n+    } else if (hint_node->is_right_child()) {\n+      insert_location = &hint_node->parent()->_right;\n+    }\n@@ -218,3 +212,3 @@\n-  RBNode* parent = nullptr;\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+  while (*insert_location != nullptr) {\n+    NodeType* curr = (NodeType*)*insert_location;\n+    const int key_cmp_k = cmp(key, curr);\n@@ -223,2 +217,1 @@\n-      curr->_value = val;\n-      return curr;\n+      break;\n@@ -227,1 +220,1 @@\n-    parent = curr;\n+    parent = *insert_location;\n@@ -229,1 +222,1 @@\n-      curr = curr->_left;\n+      insert_location = &curr->_left;\n@@ -231,1 +224,1 @@\n-      curr = curr->_right;\n+      insert_location = &curr->_right;\n@@ -235,3 +228,2 @@\n-  \/\/ Create and insert new node\n-  RBNode* node = allocate_node(key, val);\n-  node->set_parent(parent);\n+  return Cursor((NodeType**)insert_location, (NodeType*)parent);\n+}\n@@ -239,5 +231,18 @@\n-  const int key_cmp_k = COMPARATOR::cmp(key, parent->key());\n-  if (key_cmp_k < 0) {\n-    parent->_left = node;\n-  } else {\n-    parent->_right = node;\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::insert_at_cursor(NodeType* node, const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && !node_cursor.found(), \"must be\");\n+  _num_nodes++;\n+\n+  *node_cursor._insert_location = node;\n+\n+  node->set_parent(node_cursor._parent);\n+  node->set_red();\n+  node->_left = nullptr;\n+  node->_right = nullptr;\n+\n+#ifdef ASSERT\n+  node->_visited = _expected_visited;\n+#endif \/\/ ASSERT\n+\n+  if (node_cursor._parent == nullptr) {\n+    return;\n@@ -246,1 +251,1 @@\n-  return node;\n+  fix_insert_violations(node);\n@@ -249,2 +254,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::fix_insert_violations(RBNode* node) {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::fix_insert_violations(IntrusiveRBNode* node) {\n@@ -255,1 +260,1 @@\n-  RBNode* parent = node->parent();\n+  IntrusiveRBNode* parent = node->parent();\n@@ -259,1 +264,1 @@\n-    RBNode* grandparent = parent->parent();\n+    IntrusiveRBNode* grandparent = parent->parent();\n@@ -266,1 +271,1 @@\n-    RBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n+    IntrusiveRBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n@@ -308,2 +313,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_black_leaf(RBNode* node) {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::remove_black_leaf(IntrusiveRBNode* node) {\n@@ -311,1 +316,1 @@\n-  RBNode* parent = node->parent();\n+  IntrusiveRBNode* parent = node->parent();\n@@ -315,1 +320,1 @@\n-    RBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n+    IntrusiveRBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n@@ -339,2 +344,2 @@\n-    RBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n-    RBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n+    IntrusiveRBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n+    IntrusiveRBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n@@ -396,5 +401,5 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_from_tree(RBNode* node) {\n-  RBNode* parent = node->parent();\n-  RBNode* left = node->_left;\n-  RBNode* right = node->_right;\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::remove_from_tree(IntrusiveRBNode* node) {\n+  IntrusiveRBNode* parent = node->parent();\n+  IntrusiveRBNode* left = node->_left;\n+  IntrusiveRBNode* right = node->_right;\n@@ -442,3 +447,6 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n-  assert(node != nullptr, \"must be\");\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::remove_at_cursor(const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && node_cursor.found(), \"must be\");\n+  _num_nodes--;\n+\n+  IntrusiveRBNode* node = node_cursor.node();\n@@ -448,1 +456,1 @@\n-    RBNode* curr = node->_right;\n+    IntrusiveRBNode* curr = node->_right;\n@@ -478,1 +486,0 @@\n-  free_node(node);\n@@ -481,1 +488,107 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const NodeType* node) const {\n+  if (node == nullptr) {\n+    return Cursor();\n+  }\n+\n+  if (node->parent() == nullptr) {\n+    return Cursor((NodeType**)&_root, nullptr);\n+  }\n+\n+  IntrusiveRBNode* parent = node->parent();\n+  IntrusiveRBNode** insert_location =\n+      node->is_left_child() ? &parent->_left : &parent->_right;\n+  return Cursor((NodeType**)insert_location, (NodeType*)parent);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::next(const Cursor& node_cursor) const {\n+  if (node_cursor.found()) {\n+    return cursor(node_cursor.node()->next());\n+  }\n+\n+  if (node_cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if ((NodeType**)&node_cursor._parent->_left == node_cursor._insert_location) { \/\/ Left child, parent is next\n+    return cursor(node_cursor._parent);\n+  }\n+\n+  return cursor(node_cursor._parent->next()); \/\/ Right child, parent's next is also node's next\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::prev(const Cursor& node_cursor) const {\n+  if (node_cursor.found()) {\n+    return cursor(node_cursor.node()->prev());\n+  }\n+\n+  if (node_cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if ((NodeType**)&node_cursor._parent->_right == node_cursor._insert_location) { \/\/ Right child, parent is prev\n+    return cursor(node_cursor._parent);\n+  }\n+\n+  return cursor(node_cursor._parent->prev()); \/\/ Left child, parent's prev is also node's prev\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::replace_at_cursor(NodeType* new_node, const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && node_cursor.found(), \"must be\");\n+  NodeType* old_node = node_cursor.node();\n+  if (old_node == new_node) {\n+    return;\n+  }\n+\n+  *node_cursor._insert_location = new_node;\n+  new_node->_parent = old_node->_parent;\n+\n+  new_node->_left = old_node->_left;\n+  new_node->_right = old_node->_right;\n+  if (new_node->_left != nullptr) {\n+    new_node->_left->set_parent(new_node);\n+  }\n+  if (new_node->_right != nullptr) {\n+    new_node->_right->set_parent(new_node);\n+  }\n+\n+  DEBUG_ONLY(new_node->_visited = old_node->_visited);\n+\n+#ifdef ASSERT\n+  verify_self(); \/\/ Dangerous operation, should verify no tree properties were broken\n+#endif \/\/ ASSERT\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const K& key, const NodeType* hint_node) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->cursor(key, hint_node);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const NodeType* node) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->cursor(node);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::next(const Cursor& node_cursor) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->next(node_cursor);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::prev(const Cursor& node_cursor) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->prev(node_cursor);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n@@ -483,13 +596,5 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_in_order(F f) const {\n-  const RBNode* to_visit[64];\n-  int stack_idx = 0;\n-  const RBNode* head = _root;\n-  while (stack_idx > 0 || head != nullptr) {\n-    while (head != nullptr) {\n-      to_visit[stack_idx++] = head;\n-      assert(stack_idx <= (int)(sizeof(to_visit)\/sizeof(to_visit[0])), \"stack too deep\");\n-      head = head->_left;\n-    }\n-    head = to_visit[--stack_idx];\n-    f(head);\n-    head = head->_right;\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_in_order(F f) const {\n+  const NodeType* node = leftmost();\n+  while (node != nullptr) {\n+    f(node);\n+    node = node->next();\n@@ -499,1 +604,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename K, typename NodeType, typename COMPARATOR>\n@@ -501,5 +606,10 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n-  assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n-  const RBNode* curr = closest_geq(from);\n-  if (curr == nullptr) return;\n-  const RBNode* const end = closest_geq(to);\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n+  \/\/ assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n+  if (_root == nullptr) {\n+    return;\n+  }\n+\n+  Cursor cursor_start = cursor(from);\n+  Cursor cursor_end = cursor(to);\n+  const NodeType* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  const NodeType* end = cursor_end.found() ? cursor_end.node() : next(cursor_end).node();\n@@ -507,3 +617,3 @@\n-  while (curr != nullptr && curr != end) {\n-    f(curr);\n-    curr = curr->next();\n+  while (start != end) {\n+    f(start);\n+    start = start->next();\n@@ -514,2 +624,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::verify_self() const {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::verify_self() const {\n@@ -517,1 +627,1 @@\n-    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    assert(_num_nodes == 0, \"rbtree has %zu nodes but no root\", _num_nodes);\n@@ -564,2 +674,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-void RBTree<K, V, COMPARATOR, ALLOCATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n+inline void IntrusiveRBNode::print_on(outputStream* st, int depth) const {\n@@ -568,2 +677,10 @@\n-  st->print(\"@\" PTR_FORMAT \": [\", p2i(n));\n-  print_T<K>(st, n->key());\n+  st->print(\"@\" PTR_FORMAT, p2i(this));\n+  st->cr();\n+}\n+\n+template <typename K, typename V>\n+inline void RBNode<K, V>::print_on(outputStream* st, int depth) const {\n+  st->print(\"(%d)\", depth);\n+  st->sp(1 + depth * 2);\n+  st->print(\"@\" PTR_FORMAT \": [\", p2i(this));\n+  print_T<K>(st, key());\n@@ -571,1 +688,1 @@\n-  print_T<V>(st, n->val());\n+  print_T<V>(st, val());\n@@ -573,0 +690,5 @@\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n+  n->print_on(st, depth);\n@@ -575,1 +697,1 @@\n-    print_node_on(st, depth, n->_right);\n+    print_node_on(st, depth, (NodeType*)n->_right);\n@@ -578,1 +700,1 @@\n-    print_node_on(st, depth, n->_left);\n+    print_node_on(st, depth, (NodeType*)n->_left);\n@@ -582,2 +704,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-void RBTree<K, V, COMPARATOR, ALLOCATOR>::print_on(outputStream* st) const {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_on(outputStream* st) const {\n@@ -585,1 +707,1 @@\n-    print_node_on(st, 0, _root);\n+    print_node_on(st, 0, (NodeType*)_root);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":243,"deletions":121,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -75,1 +75,24 @@\n-using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtOther>;\n+  using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtTest>;\n+  using RBTreeIntNode = RBNode<int, int>;\n+  using IntrusiveTreeNode = IntrusiveRBNode;\n+\n+  struct IntrusiveHolder {\n+    IntrusiveTreeNode node;\n+    int key;\n+    int data;\n+\n+    IntrusiveTreeNode* get_node() { return &node; }\n+\n+    IntrusiveHolder() {}\n+    IntrusiveHolder(int key, int data) : key(key), data(data) {}\n+    static IntrusiveHolder* cast_to_self(const IntrusiveTreeNode* node) { return (IntrusiveHolder*)node; }\n+  };\n+\n+  struct IntrusiveCmp {\n+    static int cmp(int a, const IntrusiveTreeNode* b) {\n+      return a - IntrusiveHolder::cast_to_self(b)->key;\n+    }\n+  };\n+\n+  using IntrusiveTreeInt = IntrusiveRBTree<int, IntrusiveCmp>;\n+  using IntrusiveCursor = IntrusiveTreeInt::Cursor;\n@@ -92,1 +115,1 @@\n-    rbtree_const.visit_in_order([&](const RBTreeInt::RBNode* node) {\n+    rbtree_const.visit_in_order([&](const RBTreeIntNode* node) {\n@@ -151,1 +174,1 @@\n-    using Node = RBTreeCHeap<float, Empty, FCmp, mtOther>::RBNode;\n+    using Node = RBNode<float, Empty>;\n@@ -171,1 +194,1 @@\n-      using Node = RBTreeInt::RBNode;\n+      using Node = RBTreeIntNode;\n@@ -247,1 +270,1 @@\n-      using Node = RBTreeCHeap<int, int, CmpInverse, mtOther>::RBNode;\n+      using Node = RBNode<int, int>;\n@@ -274,1 +297,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -298,0 +321,71 @@\n+  void test_closest_gt() {\n+    using Node = RBTreeIntNode;\n+    {\n+      RBTreeInt rbtree;\n+      Node* n = rbtree.closest_gt(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-5, -5);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-5);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-10);\n+      EXPECT_EQ(-5, n->key());\n+\n+      rbtree.upsert(10, 10);\n+      n = rbtree.closest_gt(5);\n+      EXPECT_EQ(10, n->key());\n+\n+      n = rbtree.closest_gt(10);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_leftmost() {\n+    using Node = RBTreeIntNode;\n+\n+    RBTreeInt rbtree;\n+    Node* n = rbtree.leftmost();\n+    EXPECT_EQ(nullptr, n);\n+\n+    rbtree.upsert(0, 0);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(2, 2);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(1, 1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(-1, -1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(-1, n->key());\n+\n+    rbtree.remove(-1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(0);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(2, n->key());\n+\n+    rbtree.remove(2);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(nullptr, n);\n+\n+  }\n+\n@@ -301,1 +395,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -322,1 +416,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -343,1 +437,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -371,1 +465,1 @@\n-    using Node = Tree::RBNode;\n+    using Node = RBNode<int, void*>;\n@@ -374,1 +468,1 @@\n-      rbtree.upsert(i, nullptr);\n+      rbtree.upsert(i, (void*)nullptr);\n@@ -394,0 +488,109 @@\n+  void test_node_hints() {\n+    constexpr int num_nodes = 100;\n+    RBTreeInt tree;\n+    RBTreeIntNode* nodes[num_nodes];\n+\n+    RBTreeIntNode* prev_node = nullptr;\n+    for (int i = 0; i < num_nodes; i++) {\n+      RBTreeIntNode* node = tree.allocate_node(i, i);\n+      nodes[i] = node;\n+      tree.insert(i, node, prev_node);\n+      prev_node = node;\n+    }\n+\n+    for (int i = 0; i < num_nodes; i++) {\n+      RBTreeIntNode* target_node = nodes[i];\n+      for (int j = 0; j < num_nodes; j++) {\n+        if (i == j) continue;\n+        RBTreeIntNode* hint_node = nodes[j];\n+        RBTreeIntNode* find_node = tree.find_node(i);\n+        RBTreeIntNode* hint_find_node = tree.find_node(i, hint_node);\n+\n+        ASSERT_EQ(find_node, hint_find_node);\n+        ASSERT_EQ(target_node, hint_find_node);\n+      }\n+    }\n+  }\n+\n+  void test_cursor() {\n+    constexpr int num_nodes = 10;\n+    RBTreeInt tree;\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor(n);\n+      EXPECT_FALSE(find_cursor.found());\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor(n);\n+      EXPECT_TRUE(find_cursor.found());\n+    }\n+\n+    EXPECT_FALSE(tree.cursor(-1).found());\n+    EXPECT_FALSE(tree.cursor(101).found());\n+  }\n+\n+  void test_get_cursor() {\n+    constexpr int num_nodes = 10;\n+    IntrusiveTreeInt tree;\n+    GrowableArrayCHeap<IntrusiveHolder*, mtTest> nodes(num_nodes);\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n, n);\n+\n+      tree.insert_at_cursor(place->get_node(), tree.cursor(n));\n+      nodes.push(place);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveTreeNode* node = nodes.at(n)->get_node();\n+      IntrusiveCursor cursor = tree.cursor(node);\n+      IntrusiveCursor find_cursor = tree.cursor(n);\n+      EXPECT_TRUE(cursor.found());\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_TRUE(find_cursor.found());\n+      EXPECT_TRUE(find_cursor.valid());\n+      EXPECT_EQ(cursor.node(), find_cursor.node());\n+    }\n+  }\n+\n+  void test_cursor_empty_tree() {\n+    RBTreeInt tree;\n+    RBTreeInt::Cursor cursor = tree.cursor(tree.leftmost());\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor(0);\n+    EXPECT_TRUE(cursor.valid());\n+    EXPECT_FALSE(cursor.found());\n+    EXPECT_FALSE(tree.next(cursor).valid());\n+  }\n+\n+  void test_cursor_iterate() {\n+    constexpr int num_nodes = 100;\n+    RBTreeInt tree;\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    RBTreeInt::Cursor cursor = tree.cursor(0);\n+    for (int n = 0; n <= num_nodes; n++) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.next(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor(num_nodes);\n+    for (int n = num_nodes; n >= 0; n--) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.prev(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+  }\n+\n@@ -395,1 +598,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -474,0 +677,72 @@\n+  void test_cursor_replace() {\n+    constexpr int num_nodes = 100;\n+    RBTreeInt tree;\n+\n+    for (int i = 0; i < num_nodes * 10; i += 10) {\n+      tree.upsert(i, i);\n+    }\n+\n+    for (int i = 0; i < num_nodes * 10; i += 10) {\n+      RBTreeInt::Cursor cursor = tree.cursor(tree.find_node(i));\n+      RBTreeIntNode* new_node = tree.allocate_node(i + 1, i + 1);\n+      tree.replace_at_cursor(new_node, cursor);\n+    }\n+\n+    for (int i = 0; i < num_nodes * 10; i += 10) {\n+      RBTreeIntNode* node = tree.find_node(i);\n+      EXPECT_NULL(node);\n+      node = tree.find_node(i + 1);\n+      EXPECT_NOT_NULL(node);\n+    }\n+\n+    tree.verify_self();\n+  }\n+\n+  void test_intrusive() {\n+    IntrusiveTreeInt intrusive_tree;\n+    int num_iterations = 100;\n+\n+    \/\/ Insert values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+\n+      \/\/ Custom allocation here is just malloc\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n, n);\n+\n+      intrusive_tree.insert_at_cursor(place->get_node(), cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NOT_NULL(cursor2.node());\n+\n+      intrusive_tree.verify_self();\n+    }\n+\n+    \/\/ Check inserted values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+      EXPECT_EQ(n, IntrusiveHolder::cast_to_self(cursor.node())->data);\n+    }\n+\n+    \/\/ Remove all values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+\n+      intrusive_tree.remove_at_cursor(cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NULL(cursor2.node());\n+\n+      intrusive_tree.verify_self();\n+    }\n+\n+    \/\/ Check removed values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+    }\n+  }\n+\n@@ -477,1 +752,1 @@\n-    using Node = Tree::RBNode;\n+    using Node = RBNode<int, int>;\n@@ -527,0 +802,8 @@\n+TEST_VM_F(RBTreeTest, TestClosestGt) {\n+  this->test_closest_gt();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFirst) {\n+  this->test_leftmost();\n+}\n+\n@@ -543,0 +826,21 @@\n+\n+TEST_VM_F(RBTreeTest, NodeHints) {\n+  this->test_node_hints();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorFind) {\n+  this->test_cursor();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorGet) {\n+  this->test_cursor();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorEmptyTreeTest) {\n+  this->test_cursor_empty_tree();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorIterateTest) {\n+  this->test_cursor_iterate();\n+}\n+\n@@ -573,3 +877,3 @@\n-  tree.upsert(p1, 1);\n-  tree.upsert(p2, 2);\n-  tree.upsert(p3, 3);\n+  tree.upsert(p1, 1U);\n+  tree.upsert(p2, 2U);\n+  tree.upsert(p3, 3U);\n@@ -597,3 +901,3 @@\n-    tree.upsert(i1, 1);\n-    tree.upsert(i2, 2);\n-    tree.upsert(i3, 3);\n+    tree.upsert(i1, 1U);\n+    tree.upsert(i2, 2U);\n+    tree.upsert(i3, 3U);\n@@ -609,0 +913,4 @@\n+TEST_VM_F(RBTreeTest, IntrusiveTest) {\n+  this->test_intrusive();\n+}\n+\n@@ -613,0 +921,4 @@\n+TEST_VM_F(RBTreeTest, CursorReplace) {\n+  this->test_cursor_replace();\n+}\n+\n@@ -648,0 +960,2 @@\n+    RBTreeInt::Cursor cursor = rbtree.cursor(10);\n+    RBTreeInt::Cursor cursor2 = rbtree.next(cursor);\n@@ -661,2 +975,1 @@\n-    struct Nothing {};\n-    RBTreeCHeap<int, Nothing, Cmp, mtOther> rbtree;\n+    RBTreeCHeap<int, int, Cmp, mtOther> rbtree;\n@@ -665,1 +978,1 @@\n-      rbtree.upsert(i, Nothing());\n+      rbtree.upsert(i, i);\n@@ -667,0 +980,1 @@\n+    EXPECT_EQ((size_t)one_hundred_thousand, rbtree.size());\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":336,"deletions":22,"binary":false,"changes":358,"status":"modified"}]}