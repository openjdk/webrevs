{"files":[{"patch":"@@ -34,1 +34,11 @@\n-\/\/ A tree is constructed with several template parameters:\n+\/\/ An intrusive red-black tree is constructed with two template parameters:\n+\/\/ K is the key type used.\n+\/\/ COMPARATOR must have a static function `cmp(K a, const IntrusiveRBNode* b)` which returns:\n+\/\/     - an int < 0 when a < b\n+\/\/     - an int == 0 when a == b\n+\/\/     - an int > 0 when a > b\n+\/\/ K needs to be of a type that is trivially destructible.\n+\/\/ K needs to be stored by the user and is not stored inside the tree.\n+\/\/ Nodes are address stable and will not change during its lifetime.\n+\n+\/\/ A red-black tree is constructed with four template parameters:\n@@ -37,1 +47,1 @@\n-\/\/ COMPARATOR must have a static function `cmp(K a, K b)` which returns:\n+\/\/ COMPARATOR must have one of the static functions `cmp(K a, K b)` or `cmp(K a, const RBNode<K, V>* b) which returns:\n@@ -42,1 +52,0 @@\n-\/\/ For the intrusive RBTree, only K and COMPARATOR are needed.\n@@ -47,3 +56,1 @@\n-class outputStream;\n-\n-template <typename K, typename V, typename COMPARATOR>\n+template <typename K, typename NodeType, typename COMPARATOR>\n@@ -52,11 +59,1 @@\n-\/\/ If the value in a node is not desired (like in an intrusive tree),\n-\/\/ we can use empty base optimization to avoid wasting space\n-\/\/ by inheriting from Empty instead of Value.\n-struct Empty {};\n-\n-template <typename V>\n-class Value {\n-public:\n-  V _value;\n-  Value(const V& val) : _value(val) {}\n-};\n+class outputStream;\n@@ -64,3 +61,2 @@\n-template <typename K, typename V>\n-class RBNode : std::conditional_t<std::is_same<V, void>::value, Empty, Value<V>>{\n-  template <typename K2, typename V2, typename COMPARATOR>\n+class IntrusiveRBNode {\n+  template <typename K, typename NodeType, typename COMPARATOR>\n@@ -68,1 +64,1 @@\n-  template <typename K2, typename V2, typename COMPARATOR, typename ALLOCATOR>\n+  template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n@@ -72,1 +68,0 @@\n-private:\n@@ -74,4 +69,2 @@\n-  RBNode* _left;\n-  RBNode* _right;\n-\n-  K _key;\n+  IntrusiveRBNode* _left;\n+  IntrusiveRBNode* _right;\n@@ -82,21 +75,1 @@\n-  const K& key() const { return _key; }\n-  void set_key(K& key) { _key = key; }\n-\n-  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n-  VV& val() { return Value<VV>::_value; }\n-\n-  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n-  const VV& val() const { return Value<VV>::_value; }\n-\n-  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n-  void set_val(const VV& v) { Value<VV>::_value = v; }\n-\n-  RBNode() {}\n-  RBNode(const K& key)\n-      : _parent(0), _left(nullptr), _right(nullptr),\n-        _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n-\n-  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n-  RBNode(const K& key, const VV& val)\n-      :  Value<VV>(val), _parent(0), _left(nullptr), _right(nullptr),\n-        _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n+  IntrusiveRBNode() : _parent(0), _left(nullptr), _right(nullptr) DEBUG_ONLY(COMMA _visited(false)) {}\n@@ -106,1 +79,1 @@\n-  const RBNode* prev() const;\n+  const IntrusiveRBNode* prev() const;\n@@ -110,1 +83,3 @@\n-  const RBNode* next() const;\n+  const IntrusiveRBNode* next() const;\n+\n+  void print_on(outputStream* st, int depth = 0) const;\n@@ -119,2 +94,2 @@\n-  RBNode* parent() const { return (RBNode*)(_parent & ~0x1); }\n-  void set_parent(RBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n+  IntrusiveRBNode* parent() const { return (IntrusiveRBNode*)(_parent & ~0x1); }\n+  void set_parent(IntrusiveRBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n@@ -130,1 +105,1 @@\n-  void replace_child(RBNode* old_child, RBNode* new_child);\n+  void replace_child(IntrusiveRBNode* old_child, IntrusiveRBNode* new_child);\n@@ -134,1 +109,1 @@\n-  RBNode* rotate_left();\n+  IntrusiveRBNode* rotate_left();\n@@ -138,1 +113,1 @@\n-  RBNode* rotate_right();\n+  IntrusiveRBNode* rotate_right();\n@@ -143,1 +118,1 @@\n-              size_t& tree_depth, bool expect_visited, int (*cmp)(K, K)) const;\n+              size_t& tree_depth, bool expect_visited) const;\n@@ -145,1 +120,0 @@\n-}; \/\/ End: RBNode\n@@ -147,2 +121,6 @@\n-template <typename K, typename V, typename COMPARATOR>\n-class AbstractRBTree {\n+};\n+\n+template <typename K, typename V>\n+class RBNode : public IntrusiveRBNode {\n+  template <typename K2, typename V2, typename COMPARATOR, typename ALLOCATOR>\n+  friend class RBTree;\n@@ -150,1 +128,4 @@\n-  typedef AbstractRBTree<K, V, COMPARATOR> TreeType;\n+\n+private:\n+  K _key;\n+  V _value;\n@@ -153,1 +134,1 @@\n-  typedef RBNode<K, V> NodeType;\n+  const K& key() const { return _key; }\n@@ -155,0 +136,21 @@\n+  V& val() { return _value; }\n+  const V& val() const { return _value; }\n+  void set_val(const V& v) { _value = v; }\n+\n+  RBNode() {}\n+  RBNode(const K& key) : IntrusiveRBNode(), _key(key) {}\n+  RBNode(const K& key, const V& val) : IntrusiveRBNode(), _key(key), _value(val) {}\n+\n+  const RBNode<K, V>* prev() const { return (RBNode<K, V>*)IntrusiveRBNode::prev(); }\n+  const RBNode<K, V>* next() const { return (RBNode<K, V>*)IntrusiveRBNode::next(); }\n+\n+  void print_on(outputStream* st, int depth = 0) const;\n+\n+};\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+class AbstractRBTree {\n+  friend class RBTreeTest;\n+  typedef AbstractRBTree<K, NodeType, COMPARATOR> TreeType;\n+\n+public:\n@@ -160,4 +162,3 @@\n-    friend AbstractRBTree<K, V, COMPARATOR>;\n-    RBNode<K, V>** _insert_location;\n-    RBNode<K, V>* _parent;\n-    K _key;\n+    friend AbstractRBTree<K, NodeType, COMPARATOR>;\n+    NodeType** _insert_location;\n+    NodeType* _parent;\n@@ -165,4 +166,4 @@\n-    Cursor(RBNode<K, V>** insert_location, RBNode<K, V>* parent, const K& key)\n-        : _insert_location(insert_location), _parent(parent), _key(key) {}\n-    Cursor(RBNode<K, V>* const* insert_location, RBNode<K, V>* parent, const K& key)\n-        : _insert_location((RBNode<K, V>**)insert_location), _parent(parent), _key(key) {}\n+    Cursor(NodeType** insert_location, NodeType* parent)\n+        : _insert_location(insert_location), _parent(parent) {}\n+    Cursor(NodeType* const* insert_location, NodeType* parent)\n+        : _insert_location((NodeType**)insert_location), _parent(parent) {}\n@@ -173,2 +174,2 @@\n-    RBNode<K, V>* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n-    RBNode<K, V>* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    NodeType* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    NodeType* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n@@ -179,1 +180,1 @@\n-  RBNode<K, V>* _root;\n+  IntrusiveRBNode* _root;\n@@ -182,0 +183,11 @@\n+private:\n+  template <typename CMP = decltype(COMPARATOR::cmp), ENABLE_IF(std::is_same<CMP, int (K, K)>::value)>\n+  int cmp(const K& a, const NodeType* b) const {\n+    return COMPARATOR::cmp(a, b->key());\n+  }\n+\n+  template <typename CMP = decltype(COMPARATOR::cmp), ENABLE_IF(std::is_same<CMP, int (K, const NodeType*)>::value)>\n+  int cmp(const K& a, const NodeType* b) const {\n+    return COMPARATOR::cmp(a, b);\n+  }\n+\n@@ -183,1 +195,1 @@\n-  static inline bool is_black(const RBNode<K, V>* node) {\n+  static inline bool is_black(const IntrusiveRBNode* node) {\n@@ -187,1 +199,1 @@\n-  static inline bool is_red(const RBNode<K, V>* node) {\n+  static inline bool is_red(const IntrusiveRBNode* node) {\n@@ -191,1 +203,1 @@\n-  void fix_insert_violations(RBNode<K, V>* node);\n+  void fix_insert_violations(IntrusiveRBNode* node);\n@@ -193,1 +205,1 @@\n-  void remove_black_leaf(RBNode<K, V>* node);\n+  void remove_black_leaf(IntrusiveRBNode* node);\n@@ -196,1 +208,1 @@\n-  void remove_from_tree(RBNode<K, V>* node);\n+  void remove_from_tree(IntrusiveRBNode* node);\n@@ -205,0 +217,3 @@\n+    static_assert(std::is_same<decltype(COMPARATOR::cmp), int(K, K)>::value ||\n+                  std::is_same<decltype(COMPARATOR::cmp), int(K, const NodeType*)>::value,\n+                  \"comparator must be of correct type\");\n@@ -210,4 +225,4 @@\n-  Cursor cursor(const K& key, const RBNode<K, V>* hint_node = nullptr);\n-  Cursor cursor(const RBNode<K, V>* node);\n-  const Cursor cursor(const K& key, const RBNode<K, V>* hint_node = nullptr) const;\n-  const Cursor cursor(const RBNode<K, V>* node) const;\n+  Cursor cursor(const K& key, const NodeType* hint_node = nullptr);\n+  Cursor cursor(const NodeType* node);\n+  const Cursor cursor(const K& key, const NodeType* hint_node = nullptr) const;\n+  const Cursor cursor(const NodeType* node) const;\n@@ -227,2 +242,1 @@\n-  \/\/ Node is given the same key used in `cursor()`.\n-  void insert_at_cursor(RBNode<K, V>* node, const Cursor& node_cursor);\n+  void insert_at_cursor(NodeType* node, const Cursor& node_cursor);\n@@ -240,12 +254,1 @@\n-  void replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor);\n-\n-  \/\/ Finds the value of the node associated with the given key.\n-  V* find(const K& key) {\n-    Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n-  }\n-\n-  V* find(const K& key) const {\n-    const Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n-  }\n+  void replace_at_cursor(NodeType* new_node, const Cursor& node_cursor);\n@@ -254,1 +257,1 @@\n-  RBNode<K, V>* find_node(const K& key, const RBNode<K, V>* hint_node = nullptr) const {\n+  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr) const {\n@@ -259,1 +262,1 @@\n-  RBNode<K, V>* find_node(const K& key, const RBNode<K, V>* hint_node = nullptr) {\n+  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr) {\n@@ -265,1 +268,1 @@\n-  void insert(RBNode<K, V>* node, const RBNode<K, V>* hint_node = nullptr) {\n+  void insert(NodeType* node, const NodeType* hint_node = nullptr) {\n@@ -270,1 +273,1 @@\n-  void remove(RBNode<K, V>* node) {\n+  void remove(NodeType* node) {\n@@ -277,1 +280,1 @@\n-  RBNode<K, V>* closest_leq(const K& key) const {\n+  NodeType* closest_leq(const K& key) const {\n@@ -282,1 +285,1 @@\n-  RBNode<K, V>* closest_leq(const K& key) {\n+  NodeType* closest_leq(const K& key) {\n@@ -289,1 +292,1 @@\n-  RBNode<K, V>* closest_gt(const K& key) const {\n+  NodeType* closest_gt(const K& key) const {\n@@ -294,1 +297,1 @@\n-  RBNode<K, V>* closest_gt(const K& key) {\n+  NodeType* closest_gt(const K& key) {\n@@ -301,1 +304,1 @@\n-  RBNode<K, V>* closest_ge(const K& key) const {\n+  NodeType* closest_ge(const K& key) const {\n@@ -306,1 +309,1 @@\n-  RBNode<K, V>* closest_ge(const K& key) {\n+  NodeType* closest_ge(const K& key) {\n@@ -313,2 +316,2 @@\n-  const RBNode<K, V>* leftmost() const {\n-    RBNode<K, V>* n = _root, *n2 = nullptr;\n+  const NodeType* leftmost() const {\n+    IntrusiveRBNode* n = _root, *n2 = nullptr;\n@@ -319,1 +322,1 @@\n-    return n2;\n+    return (NodeType*)n2;\n@@ -324,2 +327,2 @@\n-  const RBNode<K, V>* rightmost() const {\n-    RBNode<K, V>* n = _root, *n2 = nullptr;\n+  const NodeType* rightmost() const {\n+    IntrusiveRBNode* n = _root, *n2 = nullptr;\n@@ -330,1 +333,1 @@\n-    return n2;\n+    return (NodeType*)n2;\n@@ -333,2 +336,2 @@\n-  RBNode<K, V>* leftmost()  { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->leftmost()); }\n-  RBNode<K, V>* rightmost() { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->rightmost()); }\n+  NodeType* leftmost()  { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->leftmost()); }\n+  NodeType* rightmost() { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->rightmost()); }\n@@ -337,3 +340,3 @@\n-    RBNode<K, V>* start;\n-    RBNode<K, V>* end;\n-    Range(RBNode<K, V>* start, RBNode<K, V>* end)\n+    NodeType* start;\n+    NodeType* end;\n+    Range(NodeType* start, NodeType* end)\n@@ -347,2 +350,2 @@\n-    RBNode<K, V>* start = closest_leq(key);\n-    RBNode<K, V>* end = closest_gt(key);\n+    NodeType* start = closest_leq(key);\n+    NodeType* end = closest_gt(key);\n@@ -368,1 +371,1 @@\n-class RBTree : public AbstractRBTree<K, V, COMPARATOR> {\n+class RBTree : public AbstractRBTree<K, RBNode<K, V>, COMPARATOR> {\n@@ -370,1 +373,1 @@\n-  typedef AbstractRBTree<K, V, COMPARATOR> BaseType;\n+  typedef AbstractRBTree<K, RBNode<K, V>, COMPARATOR> BaseType;\n@@ -411,0 +414,11 @@\n+  \/\/ Finds the value of the node associated with the given key.\n+  V* find(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+  }\n+\n+  V* find(const K& key) const {\n+    const Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+  }\n+\n@@ -432,1 +446,1 @@\n-    RBNode<K, V>* to_delete[64];\n+    IntrusiveRBNode* to_delete[64];\n@@ -437,1 +451,1 @@\n-      RBNode<K, V>* head = to_delete[--stack_idx];\n+      IntrusiveRBNode* head = to_delete[--stack_idx];\n@@ -466,3 +480,0 @@\n-template <typename K>\n-using IntrusiveNode = RBNode<K, void>;\n-\n@@ -470,1 +481,1 @@\n-using IntrusiveRBTree = AbstractRBTree<K, void, COMPARATOR>;\n+using IntrusiveRBTree = AbstractRBTree<K, IntrusiveRBNode, COMPARATOR>;\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":136,"deletions":125,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-template <typename K, typename V>\n-inline void RBNode<K, V>::replace_child(RBNode<K, V>* old_child, RBNode<K, V>* new_child) {\n+inline void IntrusiveRBNode::replace_child(IntrusiveRBNode* old_child, IntrusiveRBNode* new_child) {\n@@ -46,2 +45,1 @@\n-template <typename K, typename V>\n-inline RBNode<K, V>* RBNode<K, V>::rotate_left() {\n+inline IntrusiveRBNode* IntrusiveRBNode::rotate_left() {\n@@ -49,1 +47,1 @@\n-  RBNode<K, V>* old_right = _right;\n+  IntrusiveRBNode* old_right = _right;\n@@ -67,2 +65,1 @@\n-template <typename K, typename V>\n-inline RBNode<K, V>* RBNode<K, V>::rotate_right() {\n+inline IntrusiveRBNode* IntrusiveRBNode::rotate_right() {\n@@ -70,1 +67,1 @@\n-  RBNode<K, V>* old_left = _left;\n+  IntrusiveRBNode* old_left = _left;\n@@ -88,3 +85,2 @@\n-template <typename K, typename V>\n-inline const RBNode<K, V>* RBNode<K, V>::prev() const {\n-  const RBNode<K, V>* node = this;\n+inline const IntrusiveRBNode* IntrusiveRBNode::prev() const {\n+  const IntrusiveRBNode* node = this;\n@@ -105,3 +101,2 @@\n-template <typename K, typename V>\n-inline const RBNode<K, V>* RBNode<K, V>::next() const {\n-  const RBNode<K, V>* node = this;\n+inline const IntrusiveRBNode* IntrusiveRBNode::next() const {\n+  const IntrusiveRBNode* node = this;\n@@ -123,2 +118,1 @@\n-template <typename K, typename V>\n-inline void RBNode<K, V>::verify(\n+inline void IntrusiveRBNode::verify(\n@@ -126,1 +120,1 @@\n-    size_t& tree_depth, bool expect_visited, int (*cmp)(K, K)) const {\n+    size_t& tree_depth, bool expect_visited) const {\n@@ -139,1 +133,0 @@\n-    assert(cmp(_left->key(), _key) < 0, \"left node must be less than parent\");\n@@ -143,1 +136,1 @@\n-                  longest_leaf_path_left, tree_depth_left, expect_visited, cmp);\n+                  longest_leaf_path_left, tree_depth_left, expect_visited);\n@@ -155,1 +148,0 @@\n-    assert(cmp(_right->key(), _key) > 0, \"right node must be greater than parent\");\n@@ -159,1 +151,1 @@\n-                   longest_leaf_path_right, tree_depth_right, expect_visited, cmp);\n+                   longest_leaf_path_right, tree_depth_right, expect_visited);\n@@ -185,5 +177,5 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::cursor(const K& key, const RBNode<K, V>* hint_node) const {\n-  RBNode<K, V>* parent = nullptr;\n-  RBNode<K, V>* const* insert_location = &_root;\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const K& key, const NodeType* hint_node) const {\n+  IntrusiveRBNode* parent = nullptr;\n+  IntrusiveRBNode* const* insert_location = &_root;\n@@ -192,1 +184,1 @@\n-    const int hint_cmp = COMPARATOR::cmp(hint_node->key(), key);\n+    const int hint_cmp = cmp(key, hint_node);\n@@ -194,1 +186,1 @@\n-      const int parent_cmp = COMPARATOR::cmp(hint_node->parent()->key(), key);\n+      const int parent_cmp = cmp(key, (NodeType*)hint_node->parent());\n@@ -199,1 +191,1 @@\n-        hint_node = hint_node->parent();\n+        hint_node = (NodeType*)hint_node->parent();\n@@ -213,2 +205,2 @@\n-    RBNode<K, V>* curr = *insert_location;\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+    NodeType* curr = (NodeType*)*insert_location;\n+    const int key_cmp_k = cmp(key, curr);\n@@ -228,1 +220,1 @@\n-  return Cursor(insert_location, parent, key);\n+  return Cursor((NodeType**)insert_location, (NodeType*)parent);\n@@ -231,2 +223,2 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline void AbstractRBTree<K, V, COMPARATOR>::insert_at_cursor(RBNode<K, V>* node, const Cursor& node_cursor) {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::insert_at_cursor(NodeType* node, const Cursor& node_cursor) {\n@@ -242,1 +234,0 @@\n-  node->_key = node_cursor._key;\n@@ -255,2 +246,2 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline void AbstractRBTree<K, V, COMPARATOR>::fix_insert_violations(RBNode<K, V>* node) {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::fix_insert_violations(IntrusiveRBNode* node) {\n@@ -261,1 +252,1 @@\n-  RBNode<K, V>* parent = node->parent();\n+  IntrusiveRBNode* parent = node->parent();\n@@ -265,1 +256,1 @@\n-    RBNode<K, V>* grandparent = parent->parent();\n+    IntrusiveRBNode* grandparent = parent->parent();\n@@ -272,1 +263,1 @@\n-    RBNode<K, V>* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n+    IntrusiveRBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n@@ -314,2 +305,2 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline void AbstractRBTree<K, V, COMPARATOR>::remove_black_leaf(RBNode<K, V>* node) {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::remove_black_leaf(IntrusiveRBNode* node) {\n@@ -317,1 +308,1 @@\n-  RBNode<K, V>* parent = node->parent();\n+  IntrusiveRBNode* parent = node->parent();\n@@ -321,1 +312,1 @@\n-    RBNode<K, V>* sibling = node->is_left_child() ? parent->_right : parent->_left;\n+    IntrusiveRBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n@@ -345,2 +336,2 @@\n-    RBNode<K, V>* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n-    RBNode<K, V>* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n+    IntrusiveRBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n+    IntrusiveRBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n@@ -402,5 +393,5 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline void AbstractRBTree<K, V, COMPARATOR>::remove_from_tree(RBNode<K, V>* node) {\n-  RBNode<K, V>* parent = node->parent();\n-  RBNode<K, V>* left = node->_left;\n-  RBNode<K, V>* right = node->_right;\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::remove_from_tree(IntrusiveRBNode* node) {\n+  IntrusiveRBNode* parent = node->parent();\n+  IntrusiveRBNode* left = node->_left;\n+  IntrusiveRBNode* right = node->_right;\n@@ -448,2 +439,2 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline void AbstractRBTree<K, V, COMPARATOR>::remove_at_cursor(const Cursor& node_cursor) {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::remove_at_cursor(const Cursor& node_cursor) {\n@@ -453,1 +444,1 @@\n-  RBNode<K, V>* node = node_cursor.node();\n+  IntrusiveRBNode* node = node_cursor.node();\n@@ -457,1 +448,1 @@\n-    RBNode<K, V>* curr = node->_right;\n+    IntrusiveRBNode* curr = node->_right;\n@@ -489,3 +480,3 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::cursor(const RBNode<K, V>* node) const {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const NodeType* node) const {\n@@ -497,1 +488,1 @@\n-    return Cursor(&_root, nullptr, node->key());\n+    return Cursor((NodeType**)&_root, nullptr);\n@@ -500,2 +491,2 @@\n-  RBNode<K, V>* parent = node->parent();\n-  RBNode<K, V>** insert_location =\n+  IntrusiveRBNode* parent = node->parent();\n+  IntrusiveRBNode** insert_location =\n@@ -503,1 +494,1 @@\n-  return Cursor(insert_location, parent, node->key());\n+  return Cursor((NodeType**)insert_location, (NodeType*)parent);\n@@ -506,3 +497,3 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::next(const Cursor& node_cursor) const {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::next(const Cursor& node_cursor) const {\n@@ -518,1 +509,1 @@\n-  if (&node_cursor._parent->_left == node_cursor._insert_location) { \/\/ Left child, parent is next\n+  if ((NodeType**)&node_cursor._parent->_left == node_cursor._insert_location) { \/\/ Left child, parent is next\n@@ -525,3 +516,3 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::prev(const Cursor& node_cursor) const {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::prev(const Cursor& node_cursor) const {\n@@ -537,1 +528,1 @@\n-  if (&node_cursor._parent->_right == node_cursor._insert_location) { \/\/ Right child, parent is prev\n+  if ((NodeType**)&node_cursor._parent->_right == node_cursor._insert_location) { \/\/ Right child, parent is prev\n@@ -544,2 +535,2 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline void AbstractRBTree<K, V, COMPARATOR>::replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor) {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::replace_at_cursor(NodeType* new_node, const Cursor& node_cursor) {\n@@ -547,1 +538,1 @@\n-  RBNode<K, V>* old_node = node_cursor.node();\n+  NodeType* old_node = node_cursor.node();\n@@ -572,4 +563,4 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::cursor(const K& key, const RBNode<K, V>* hint_node) {\n-  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->cursor(key, hint_node);\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const K& key, const NodeType* hint_node) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->cursor(key, hint_node);\n@@ -578,4 +569,4 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::cursor(const RBNode<K, V>* node) {\n-  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->cursor(node);\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::cursor(const NodeType* node) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->cursor(node);\n@@ -584,4 +575,4 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::next(const Cursor& node_cursor) {\n-  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->next(node_cursor);\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::next(const Cursor& node_cursor) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->next(node_cursor);\n@@ -590,4 +581,4 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n-AbstractRBTree<K, V, COMPARATOR>::prev(const Cursor& node_cursor) {\n-  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->prev(node_cursor);\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Cursor\n+AbstractRBTree<K, NodeType, COMPARATOR>::prev(const Cursor& node_cursor) {\n+  return static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->prev(node_cursor);\n@@ -596,1 +587,1 @@\n-template <typename K, typename V, typename COMPARATOR>\n+template <typename K, typename NodeType, typename COMPARATOR>\n@@ -598,2 +589,2 @@\n-inline void AbstractRBTree<K, V, COMPARATOR>::visit_in_order(F f) const {\n-  const RBNode<K, V>* node = leftmost();\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_in_order(F f) const {\n+  const NodeType* node = leftmost();\n@@ -606,1 +597,1 @@\n-template <typename K, typename V, typename COMPARATOR>\n+template <typename K, typename NodeType, typename COMPARATOR>\n@@ -608,2 +599,2 @@\n-inline void AbstractRBTree<K, V, COMPARATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n-  assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n+  \/\/ assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n@@ -616,2 +607,2 @@\n-  const RBNode<K, V>* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n-  const RBNode<K, V>* end = cursor_end.found() ? cursor_end.node() : next(cursor_end).node();\n+  const NodeType* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  const NodeType* end = cursor_end.found() ? cursor_end.node() : next(cursor_end).node();\n@@ -626,2 +617,2 @@\n-template <typename K, typename V, typename COMPARATOR>\n-inline void AbstractRBTree<K, V, COMPARATOR>::verify_self() const {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::verify_self() const {\n@@ -642,1 +633,1 @@\n-  _root->verify(num_nodes, black_depth, shortest_leaf_path, longest_leaf_path, tree_depth, _expected_visited, COMPARATOR::cmp);\n+  _root->verify(num_nodes, black_depth, shortest_leaf_path, longest_leaf_path, tree_depth, _expected_visited);\n@@ -676,2 +667,9 @@\n-template <typename K, typename V, typename COMPARATOR>\n-void AbstractRBTree<K, V, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n+inline void IntrusiveRBNode::print_on(outputStream* st, int depth) const {\n+  st->print(\"(%d)\", depth);\n+  st->sp(1 + depth * 2);\n+  st->print(\"@\" PTR_FORMAT, p2i(this));\n+  st->cr();\n+}\n+\n+template <typename K, typename V>\n+inline void RBNode<K, V>::print_on(outputStream* st, int depth) const {\n@@ -680,2 +678,2 @@\n-  st->print(\"@\" PTR_FORMAT \": [\", p2i(n));\n-  print_T<K>(st, n->key());\n+  st->print(\"@\" PTR_FORMAT \": [\", p2i(this));\n+  print_T<K>(st, key());\n@@ -683,1 +681,1 @@\n-  print_T<V>(st, n->val());\n+  print_T<V>(st, val());\n@@ -685,0 +683,5 @@\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n+  n->print_on(st, depth);\n@@ -687,1 +690,1 @@\n-    print_node_on(st, depth, n->_right);\n+    print_node_on(st, depth, (NodeType*)n->_right);\n@@ -690,1 +693,1 @@\n-    print_node_on(st, depth, n->_left);\n+    print_node_on(st, depth, (NodeType*)n->_left);\n@@ -694,2 +697,2 @@\n-template <typename K, typename V, typename COMPARATOR>\n-void AbstractRBTree<K, V, COMPARATOR>::print_on(outputStream* st) const {\n+template <typename K, typename NodeType, typename COMPARATOR>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_on(outputStream* st) const {\n@@ -697,1 +700,1 @@\n-    print_node_on(st, 0, _root);\n+    print_node_on(st, 0, (NodeType*)_root);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":113,"deletions":110,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -77,3 +77,1 @@\n-  using IntrusiveTreeInt = IntrusiveRBTree<int, Cmp>;\n-  using IntrusiveTreeNode = IntrusiveNode<int>;\n-  using IntrusiveCursor = IntrusiveTreeInt::Cursor;\n+  using IntrusiveTreeNode = IntrusiveRBNode;\n@@ -83,0 +81,1 @@\n+    int key;\n@@ -88,2 +87,8 @@\n-    IntrusiveHolder(int data) : data(data) {}\n-    static IntrusiveHolder* cast_to_self(IntrusiveTreeNode* node) { return (IntrusiveHolder*)node; }\n+    IntrusiveHolder(int key, int data) : key(key), data(data) {}\n+    static IntrusiveHolder* cast_to_self(const IntrusiveTreeNode* node) { return (IntrusiveHolder*)node; }\n+  };\n+\n+  struct IntrusiveCmp {\n+    static int cmp(int a, const IntrusiveTreeNode* b) {\n+      return a - IntrusiveHolder::cast_to_self(b)->key;\n+    }\n@@ -92,0 +97,3 @@\n+  using IntrusiveTreeInt = IntrusiveRBTree<int, IntrusiveCmp>;\n+  using IntrusiveCursor = IntrusiveTreeInt::Cursor;\n+\n@@ -536,1 +544,1 @@\n-      new (place) IntrusiveHolder(n);\n+      new (place) IntrusiveHolder(n, n);\n@@ -680,1 +688,1 @@\n-      new (place) IntrusiveHolder(n);\n+      new (place) IntrusiveHolder(n, n);\n@@ -924,0 +932,2 @@\n+    RBTreeInt::Cursor cursor = rbtree.cursor(10);\n+    RBTreeInt::Cursor cursor2 = rbtree.next(cursor);\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"}]}