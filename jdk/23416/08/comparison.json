{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -33,0 +34,1 @@\n+class RBTreeNoopAllocator;\n@@ -42,0 +44,1 @@\n+\/\/ If the value has type void, no value will be stored in the nodes.\n@@ -44,1 +47,0 @@\n-\n@@ -53,0 +55,11 @@\n+  \/\/ If the value in a node is not desired (like in an intrusive tree),\n+  \/\/ we can use empty base optimization to avoid wasting space\n+  \/\/ by inheriting from Empty instead of Value\n+  struct Empty {};\n+\n+  class Value {\n+  protected:\n+    V _value;\n+    Value(const V& val) : _value(val) {}\n+  };\n+\n@@ -54,1 +67,1 @@\n-  class RBNode {\n+  class RBNode : std::conditional_t<std::is_same<V, void>::value, Empty, Value>{\n@@ -63,2 +76,1 @@\n-    const K _key;\n-    V _value;\n+    K _key;\n@@ -70,3 +82,27 @@\n-    V& val() { return _value; }\n-    const V& val() const { return _value; }\n-    void set_val(const V& v) { _value = v; }\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    VV& val() { return Value::_value; }\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    const VV& val() const { return Value::_value; }\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    void set_val(const VV& v) { Value::_value = v; }\n+\n+    RBNode() {}\n+    RBNode(const K& key)\n+        : _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n+\n+    template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+    RBNode(const K& key, const VV& val)\n+        :  Value(val), _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n+\n+    \/\/ Gets the previous in-order node in the tree.\n+    \/\/ nullptr is returned if there is no previous node.\n+    const RBNode* prev() const;\n+\n+    \/\/ Gets the next in-order node in the tree.\n+    \/\/ nullptr is returned if there is no next node.\n+    const RBNode* next() const;\n@@ -84,4 +120,0 @@\n-    RBNode(const K& key, const V& val DEBUG_ONLY(COMMA bool visited))\n-        : _parent(0), _left(nullptr), _right(nullptr),\n-          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(visited)) {}\n-\n@@ -106,4 +138,0 @@\n-    const RBNode* prev() const;\n-\n-    const RBNode* next() const;\n-\n@@ -119,0 +147,22 @@\n+  \/\/ Represents the location of a (would be) node in the tree.\n+  \/\/ If a cursor is valid (valid() == true) it points somewhere in the tree.\n+  \/\/ If the cursor points to an existing node (found() == true), node() can be used to access that node.\n+  \/\/ If no node is pointed to, node() returns null, regardless if the cursor is valid or not.\n+  class Cursor {\n+    friend RBTree<K, V, COMPARATOR, ALLOCATOR>;\n+    RBNode** _insert_location;\n+    RBNode* _parent;\n+    K _key;\n+    Cursor() : _insert_location(nullptr), _parent(nullptr) {}\n+    Cursor(RBNode** insert_location, RBNode* parent, const K& key)\n+        : _insert_location(insert_location), _parent(parent), _key(key) {}\n+    Cursor(RBNode* const* insert_location, RBNode* parent, const K& key)\n+        : _insert_location((RBNode**)insert_location), _parent(parent), _key(key) {}\n+\n+  public:\n+    bool valid() const { return _insert_location != nullptr; }\n+    bool found() const { return *_insert_location != nullptr; }\n+    RBNode* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    RBNode* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+  };\n+\n@@ -123,1 +173,1 @@\n-  RBNode* allocate_node(const K& key, const V& val) {\n+  RBNode* allocate_node(const K& key) {\n@@ -126,2 +176,13 @@\n-    _num_nodes++;\n-    return new (node_place) RBNode(key, val DEBUG_ONLY(COMMA _expected_visited));\n+    return new (node_place) RBNode(key);\n+  }\n+\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  RBNode* allocate_node(const K& key, const VV& val) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    return new (node_place) RBNode(key, val);\n+  }\n+\n+  template <typename VV = V, ENABLE_IF(std::is_same<VV, void>::value)>\n+  void free_node(RBNode* node) {\n+    _allocator.free(node);\n@@ -130,0 +191,1 @@\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n@@ -131,1 +193,1 @@\n-    node->_value.~V();\n+    node->_value.~VV();\n@@ -133,1 +195,0 @@\n-    _num_nodes--;\n@@ -145,4 +206,0 @@\n-\n-  \/\/ If the node with key k already exist, the value is updated instead.\n-  RBNode* insert_node(const K& key, const V& val);\n-\n@@ -153,1 +210,1 @@\n-  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove_at_cursor()`\n@@ -164,1 +221,1 @@\n-  ~RBTree() { this->remove_all(); }\n+  ~RBTree() { if (!std::is_same<ALLOCATOR, RBTreeNoopAllocator>::value) this->remove_all(); }\n@@ -168,1 +225,68 @@\n-  \/\/ Inserts a node with the given k\/v into the tree,\n+  \/\/ Gets the cursor associated with the given node or key.\n+  Cursor cursor(const K& key);\n+  Cursor cursor(const RBNode* node);\n+  const Cursor cursor(const K& key) const;\n+  const Cursor cursor(const RBNode* node) const;\n+\n+  \/\/ Moves to the next existing node.\n+  \/\/ If no next node exist, the cursor becomes invalid.\n+  Cursor next(const Cursor& node_cursor);\n+  const Cursor next(const Cursor& node_cursor) const;\n+\n+  \/\/ Moves to the previous existing node.\n+  \/\/ If no previous node exist, the cursor becomes invalid.\n+  Cursor prev(const Cursor& node_cursor);\n+  const Cursor prev(const Cursor& node_cursor) const;\n+\n+  \/\/ Initializes and inserts a node at the cursor location.\n+  \/\/ The cursor must not point to an existing node.\n+  \/\/ Node is given the same key used in `cursor()`.\n+  void insert_at_cursor(RBNode* node, const Cursor& node_cursor);\n+\n+  \/\/ Removes the node referenced by the cursor\n+  \/\/ The cursor must point to a valid existing node\n+  void remove_at_cursor(const Cursor& node_cursor);\n+\n+  \/\/ Replace the node referenced by the cursor with a new node.\n+  \/\/ The old node is destroyed.\n+  \/\/ The user must ensure that no tree properties are broken:\n+  \/\/ There must not exist any node with the new key\n+  \/\/ For all nodes with key < old_key, must also have key < new_key\n+  \/\/ For all nodes with key > old_key, must also have key > new_key\n+  void replace_at_cursor(RBNode* new_node, const Cursor& node_cursor);\n+\n+  \/\/ Finds the value of the node associated with the given key.\n+  V* find(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+  }\n+\n+  V* find(const K& key) const {\n+    const Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+  }\n+\n+  \/\/ Finds the node associated with the given key.\n+  RBNode* find_node(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.node();\n+  }\n+\n+  RBNode* find_node(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.node();\n+  }\n+\n+  \/\/ Inserts a node with the given key into the tree,\n+  \/\/ does nothing if the key already exist.\n+  void insert(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    if (node_cursor.found()) {\n+      return;\n+    }\n+\n+    RBNode* node = allocate_node(key);\n+    insert_at_cursor(node, node_cursor);\n+  }\n+\n+  \/\/ Inserts a node with the given key\/value into the tree,\n@@ -170,3 +294,11 @@\n-  void upsert(const K& key, const V& val) {\n-    RBNode* node = insert_node(key, val);\n-    fix_insert_violations(node);\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  void upsert(const K& key, const VV& val) {\n+    Cursor node_cursor = cursor(key);\n+    RBNode* node = node_cursor.node();\n+    if (node != nullptr) {\n+      node->_value = val;\n+      return;\n+    }\n+\n+    node = allocate_node(key, val);\n+    insert_at_cursor(node, node_cursor);\n@@ -178,2 +310,2 @@\n-    RBNode* node = find_node(key);\n-    if (node == nullptr){\n+    Cursor node_cursor = cursor(key);\n+    if (!node_cursor.found()) {\n@@ -182,1 +314,3 @@\n-    remove(node);\n+    RBNode* node = node_cursor.node();\n+    remove_at_cursor(node_cursor);\n+    free_node(node);\n@@ -186,2 +320,5 @@\n-  \/\/ Removes the given node from the tree. node must be a valid node\n-  void remove(RBNode* node);\n+  void remove(RBNode* node) {\n+    Cursor node_cursor = cursor(node);\n+    remove_at_cursor(node_cursor);\n+    free_node(node);\n+  }\n@@ -207,56 +344,3 @@\n-  const RBNode* closest_leq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r < 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_right;\n-      } else {\n-        pos = pos->_left;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  \/\/ Finds the node with the closest key > the given key\n-  const RBNode* closest_gt(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  \/\/ Finds the node with the closest key >= the given key\n-  const RBNode* closest_geq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n+  RBNode* closest_leq(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n@@ -266,2 +350,2 @@\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_leq(key));\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n@@ -270,3 +354,4 @@\n-  RBNode* closest_gt(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_gt(key));\n+  \/\/ Finds the node with the closest key > the given key\n+  RBNode* closest_gt(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return next(node_cursor).node();\n@@ -275,3 +360,3 @@\n-  RBNode* closest_geq(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_geq(key));\n+  RBNode* closest_gt(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return next(node_cursor).node();\n@@ -321,19 +406,0 @@\n-  \/\/ Finds the node associated with the key\n-  const RBNode* find_node(const K& key) const;\n-\n-  RBNode* find_node(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->find_node(key));\n-  }\n-\n-  \/\/ Finds the value associated with the key\n-  V* find(const K& key) {\n-    RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n-  const V* find(const K& key) const {\n-    const RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n@@ -370,0 +436,12 @@\n+class RBTreeNoopAllocator {\n+public:\n+  void* allocate(size_t sz) {\n+    assert(false, \"intrusive tree should not use rbtree allocator\");\n+    return nullptr;\n+  }\n+\n+  void free(void* ptr) {\n+    assert(false, \"intrusive tree should not use rbtree allocator\");\n+  }\n+};\n+\n@@ -373,0 +451,3 @@\n+template <typename K, typename COMPARATOR>\n+using IntrusiveRBTree = RBTree<K, void, COMPARATOR, RBTreeNoopAllocator>;\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":199,"deletions":118,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -191,4 +191,6 @@\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& key) const {\n-  RBNode* curr = _root;\n-  while (curr != nullptr) {\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor(const K& key) const {\n+  RBNode* parent = nullptr;\n+  RBNode* const* insert_location = &_root;\n+  while (*insert_location != nullptr) {\n+    RBNode* curr = *insert_location;\n@@ -198,3 +200,6 @@\n-      return curr;\n-    } else if (key_cmp_k < 0) {\n-      curr = curr->_left;\n+      break;\n+    }\n+\n+    parent = *insert_location;\n+    if (key_cmp_k < 0) {\n+      insert_location = &curr->_left;\n@@ -202,1 +207,1 @@\n-      curr = curr->_right;\n+      insert_location = &curr->_right;\n@@ -205,2 +210,1 @@\n-\n-  return nullptr;\n+  return Cursor(insert_location, parent, key);\n@@ -210,11 +214,3 @@\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& key, const V& val) {\n-  RBNode* curr = _root;\n-  if (curr == nullptr) { \/\/ Tree is empty\n-    _root = allocate_node(key, val);\n-    return _root;\n-  }\n-\n-  RBNode* parent = nullptr;\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_at_cursor(RBNode* node, const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && !node_cursor.found(), \"must be\");\n+  _num_nodes++;\n@@ -222,4 +218,1 @@\n-    if (key_cmp_k == 0) {\n-      curr->_value = val;\n-      return curr;\n-    }\n+  *node_cursor._insert_location = node;\n@@ -227,7 +220,5 @@\n-    parent = curr;\n-    if (key_cmp_k < 0) {\n-      curr = curr->_left;\n-    } else {\n-      curr = curr->_right;\n-    }\n-  }\n+  node->set_parent(node_cursor._parent);\n+  node->set_red();\n+  node->_left = nullptr;\n+  node->_right = nullptr;\n+  node->_key = node_cursor._key;\n@@ -235,3 +226,3 @@\n-  \/\/ Create and insert new node\n-  RBNode* node = allocate_node(key, val);\n-  node->set_parent(parent);\n+#ifdef ASSERT\n+  node->_visited = _expected_visited;\n+#endif \/\/ ASSERT\n@@ -239,5 +230,2 @@\n-  const int key_cmp_k = COMPARATOR::cmp(key, parent->key());\n-  if (key_cmp_k < 0) {\n-    parent->_left = node;\n-  } else {\n-    parent->_right = node;\n+  if (node_cursor._parent == nullptr) {\n+    return;\n@@ -246,1 +234,1 @@\n-  return node;\n+  fix_insert_violations(node);\n@@ -443,2 +431,5 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n-  assert(node != nullptr, \"must be\");\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_at_cursor(const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && node_cursor.found(), \"must be\");\n+  _num_nodes--;\n+\n+  RBNode* node = node_cursor.node();\n@@ -478,1 +469,107 @@\n-  free_node(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor(const RBNode* node) const {\n+  if (node == nullptr) {\n+    return Cursor();\n+  }\n+\n+  if (node->parent() == nullptr) {\n+    return Cursor(&_root, nullptr, node->key());\n+  }\n+\n+  RBNode* parent = node->parent();\n+  RBNode** insert_location =\n+      node->is_left_child() ? &parent->_left : &parent->_right;\n+  return Cursor(insert_location, parent, node->key());\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& node_cursor) const {\n+  if (node_cursor.found()) {\n+    return cursor(node_cursor.node()->next());\n+  }\n+\n+  if (node_cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&node_cursor._parent->_left == node_cursor._insert_location) { \/\/ Left child, parent is next\n+    return cursor(node_cursor._parent);\n+  }\n+\n+  return cursor(node_cursor._parent->next()); \/\/ Right child, parent's next is also node's next\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& node_cursor) const {\n+  if (node_cursor.found()) {\n+    return cursor(node_cursor.node()->prev());\n+  }\n+\n+  if (node_cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&node_cursor._parent->_right == node_cursor._insert_location) { \/\/ Right child, parent is prev\n+    return cursor(node_cursor._parent);\n+  }\n+\n+  return cursor(node_cursor._parent->prev()); \/\/ Left child, parent's prev is also node's prev\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::replace_at_cursor(RBNode* new_node, const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && node_cursor.found(), \"must be\");\n+  RBNode* old_node = node_cursor.node();\n+  if (old_node == new_node) {\n+    return;\n+  }\n+\n+  *node_cursor._insert_location = new_node;\n+  new_node->set_parent(node_cursor._parent);\n+  new_node->_color = old_node->_color;\n+\n+  new_node->_left = old_node->_left;\n+  new_node->_right = old_node->_right;\n+  if (new_node->_left != nullptr) {\n+    new_node->_left->set_parent(new_node);\n+  } else if (new_node->_right != nullptr) {\n+    new_node->_right->_parent = new_node;\n+    new_node->_right->set_parent(new_node);\n+  }\n+\n+  free_node(old_node);\n+\n+#ifdef ASSERT\n+  verify_self(); \/\/ Dangerous operation, should verify no tree properties were broken\n+#endif \/\/ ASSERT\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor(const K& key) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->cursor(key);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor(const RBNode* node) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->cursor(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& node_cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->next(node_cursor);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& node_cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->prev(node_cursor);\n@@ -484,12 +581,4 @@\n-  const RBNode* to_visit[64];\n-  int stack_idx = 0;\n-  const RBNode* head = _root;\n-  while (stack_idx > 0 || head != nullptr) {\n-    while (head != nullptr) {\n-      to_visit[stack_idx++] = head;\n-      assert(stack_idx <= (int)(sizeof(to_visit)\/sizeof(to_visit[0])), \"stack too deep\");\n-      head = head->_left;\n-    }\n-    head = to_visit[--stack_idx];\n-    f(head);\n-    head = head->_right;\n+  const RBNode* node = leftmost();\n+  while (node != nullptr) {\n+    f(node);\n+    node = node->next();\n@@ -503,3 +592,8 @@\n-  const RBNode* curr = closest_geq(from);\n-  if (curr == nullptr) return;\n-  const RBNode* const end = closest_geq(to);\n+  if (_root == nullptr) {\n+    return;\n+  }\n+\n+  Cursor cursor_start = cursor(from);\n+  Cursor cursor_end = cursor(to);\n+  const RBNode* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  const RBNode* end = cursor_end.found() ? cursor_end.node() : next(cursor_end).node();\n@@ -507,3 +601,3 @@\n-  while (curr != nullptr && curr != end) {\n-    f(curr);\n-    curr = curr->next();\n+  while (start != end) {\n+    f(start);\n+    start = start->next();\n@@ -517,1 +611,1 @@\n-    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    assert(_num_nodes == 0, \"rbtree has %zu nodes but no root\", _num_nodes);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":157,"deletions":63,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -75,1 +75,22 @@\n-using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtOther>;\n+#ifdef ASSERT\n+  template<typename K, typename V, typename CMP, typename ALLOC>\n+  void verify_it(RBTree<K, V, CMP, ALLOC>& t) {\n+    t.verify_self();\n+  }\n+#endif \/\/ ASSERT\n+\n+  using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtTest>;\n+  using IntrusiveTreeInt = IntrusiveRBTree<int, Cmp>;\n+  using IntrusiveNode = IntrusiveTreeInt::RBNode;\n+  using IntrusiveCursor = IntrusiveTreeInt::Cursor;\n+\n+  struct IntrusiveHolder {\n+    IntrusiveNode node;\n+    int data;\n+\n+    IntrusiveNode* get_node() { return &node; }\n+\n+    IntrusiveHolder() {}\n+    IntrusiveHolder(int data) : data(data) {}\n+    static IntrusiveHolder* cast_to_self(IntrusiveNode* node) { return (IntrusiveHolder*)node; }\n+  };\n@@ -298,0 +319,71 @@\n+  void test_closest_gt() {\n+    using Node = RBTreeInt::RBNode;\n+    {\n+      RBTreeInt rbtree;\n+      Node* n = rbtree.closest_gt(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-5, -5);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-5);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-10);\n+      EXPECT_EQ(-5, n->key());\n+\n+      rbtree.upsert(10, 10);\n+      n = rbtree.closest_gt(5);\n+      EXPECT_EQ(10, n->key());\n+\n+      n = rbtree.closest_gt(10);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_leftmost() {\n+    using Node = RBTreeInt::RBNode;\n+\n+    RBTreeInt rbtree;\n+    Node* n = rbtree.leftmost();\n+    EXPECT_EQ(nullptr, n);\n+\n+    rbtree.upsert(0, 0);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(2, 2);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(1, 1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(-1, -1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(-1, n->key());\n+\n+    rbtree.remove(-1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(0);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(2, n->key());\n+\n+    rbtree.remove(2);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(nullptr, n);\n+\n+  }\n+\n@@ -394,0 +486,82 @@\n+  void test_cursor() {\n+    constexpr const int num_nodes = 10;\n+    RBTreeInt tree;\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor(n);\n+      EXPECT_FALSE(find_cursor.found());\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor(n);\n+      EXPECT_TRUE(find_cursor.found());\n+    }\n+\n+    EXPECT_FALSE(tree.cursor(-1).found());\n+    EXPECT_FALSE(tree.cursor(101).found());\n+  }\n+\n+  void test_get_cursor() {\n+    constexpr const int num_nodes = 10;\n+    IntrusiveTreeInt tree;\n+    GrowableArrayCHeap<IntrusiveHolder*, mtTest> nodes(num_nodes);\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n);\n+\n+      tree.insert_at_cursor(place->get_node(), tree.cursor(n));\n+      nodes.push(place);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveNode* node = nodes.at(n)->get_node();\n+      IntrusiveCursor cursor = tree.cursor(node);\n+      IntrusiveCursor find_cursor = tree.cursor(n);\n+      EXPECT_TRUE(cursor.found());\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_TRUE(find_cursor.found());\n+      EXPECT_TRUE(find_cursor.valid());\n+      EXPECT_EQ(cursor.node(), find_cursor.node());\n+    }\n+  }\n+\n+  void test_cursor_empty_tree() {\n+    RBTreeInt tree;\n+    RBTreeInt::Cursor cursor = tree.cursor(tree.leftmost());\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor(0);\n+    EXPECT_TRUE(cursor.valid());\n+    EXPECT_FALSE(cursor.found());\n+    EXPECT_FALSE(tree.next(cursor).valid());\n+  }\n+\n+  void test_cursor_iterate() {\n+    constexpr const int num_nodes = 100;\n+    RBTreeInt tree;\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    RBTreeInt::Cursor cursor = tree.cursor(0);\n+    for (int n = 0; n <= num_nodes; n++) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.next(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor(num_nodes);\n+    for (int n = num_nodes; n >= 0; n--) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.prev(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+  }\n+\n@@ -474,0 +648,48 @@\n+  void test_intrusive() {\n+    IntrusiveTreeInt intrusive_tree;\n+    int num_iterations = 100;\n+\n+    \/\/ Insert values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+\n+      \/\/ Custom allocation here is just malloc\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n);\n+\n+      intrusive_tree.insert_at_cursor(place->get_node(), cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NOT_NULL(cursor2.node());\n+\n+      verify_it(intrusive_tree);\n+    }\n+\n+    \/\/ Check inserted values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+      EXPECT_EQ(n, IntrusiveHolder::cast_to_self(cursor.node())->data);\n+    }\n+\n+    \/\/ Remove all values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+\n+      intrusive_tree.remove_at_cursor(cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NULL(cursor2.node());\n+\n+      verify_it(intrusive_tree);\n+    }\n+\n+    \/\/ Check removed values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+    }\n+  }\n+\n@@ -527,0 +749,8 @@\n+TEST_VM_F(RBTreeTest, TestClosestGt) {\n+  this->test_closest_gt();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFirst) {\n+  this->test_leftmost();\n+}\n+\n@@ -543,0 +773,17 @@\n+\n+TEST_VM_F(RBTreeTest, CursorFind) {\n+  this->test_cursor();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorGet) {\n+  this->test_cursor();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorEmptyTreeTest) {\n+  this->test_cursor_empty_tree();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorIterateTest) {\n+  this->test_cursor_iterate();\n+}\n+\n@@ -609,0 +856,4 @@\n+TEST_VM_F(RBTreeTest, IntrusiveTest) {\n+  this->test_intrusive();\n+}\n+\n@@ -661,2 +912,1 @@\n-    struct Nothing {};\n-    RBTreeCHeap<int, Nothing, Cmp, mtOther> rbtree;\n+    RBTreeCHeap<int, void, Cmp, mtOther> rbtree;\n@@ -665,1 +915,1 @@\n-      rbtree.upsert(i, Nothing());\n+      rbtree.insert(i);\n@@ -667,0 +917,1 @@\n+    EXPECT_EQ((size_t)one_hundred_thousand, rbtree.size());\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":255,"deletions":4,"binary":false,"changes":259,"status":"modified"}]}