{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -33,3 +34,4 @@\n-class outputStream;\n-\n-\/\/ COMPARATOR must have a static function `cmp(a,b)` which returns:\n+\/\/ A tree is constructed with several template parameters:\n+\/\/ K is the key type stored in the tree nodes.\n+\/\/ V is the value type stored in the tree nodes.\n+\/\/ COMPARATOR must have a static function `cmp(K a, K b)` which returns:\n@@ -39,3 +41,3 @@\n-\/\/ ALLOCATOR must check for oom and exit, as RBTree currently does not handle the\n-\/\/ allocation failing.\n-\/\/ Key needs to be of a type that is trivially destructible.\n+\/\/ ALLOCATOR must check for oom and exit, as RBTree does not handle the allocation failing.\n+\/\/ For the intrusive RBTree, only K and COMPARATOR are needed.\n+\/\/ K needs to be of a type that is trivially destructible.\n@@ -45,2 +47,23 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-class RBTree {\n+class outputStream;\n+\n+template <typename K, typename V, typename COMPARATOR>\n+class AbstractRBTree;\n+\n+\/\/ If the value in a node is not desired (like in an intrusive tree),\n+\/\/ we can use empty base optimization to avoid wasting space\n+\/\/ by inheriting from Empty instead of Value.\n+struct Empty {};\n+\n+template <typename V>\n+class Value {\n+public:\n+  V _value;\n+  Value(const V& val) : _value(val) {}\n+};\n+\n+template <typename K, typename V>\n+class RBNode : std::conditional_t<std::is_same<V, void>::value, Empty, Value<V>>{\n+  template <typename K2, typename V2, typename COMPARATOR>\n+  friend class AbstractRBTree;\n+  template <typename K2, typename V2, typename COMPARATOR, typename ALLOCATOR>\n+  friend class RBTree;\n@@ -48,1 +71,1 @@\n-  typedef RBTree<K, V, COMPARATOR, ALLOCATOR> TreeType;\n+\n@@ -50,2 +73,7 @@\n-  ALLOCATOR _allocator;\n-  size_t _num_nodes;\n+  uintptr_t _parent; \/\/ LSB encodes color information. 0 = RED, 1 = BLACK\n+  RBNode* _left;\n+  RBNode* _right;\n+\n+  K _key;\n+\n+  DEBUG_ONLY(mutable bool _visited);\n@@ -54,3 +82,2 @@\n-  class RBNode {\n-    friend RBTree;\n-    friend class RBTreeTest;\n+  const K& key() const { return _key; }\n+  void set_key(K& key) { _key = key; }\n@@ -58,4 +85,2 @@\n-  private:\n-    uintptr_t _parent; \/\/ LSB encodes color information. 0 = RED, 1 = BLACK\n-    RBNode* _left;\n-    RBNode* _right;\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  VV& val() { return Value<VV>::_value; }\n@@ -63,2 +88,2 @@\n-    const K _key;\n-    V _value;\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  const VV& val() const { return Value<VV>::_value; }\n@@ -66,1 +91,2 @@\n-    DEBUG_ONLY(mutable bool _visited);\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  void set_val(const VV& v) { Value<VV>::_value = v; }\n@@ -68,5 +94,4 @@\n-  public:\n-    const K& key() const { return _key; }\n-    V& val() { return _value; }\n-    const V& val() const { return _value; }\n-    void set_val(const V& v) { _value = v; }\n+  RBNode() {}\n+  RBNode(const K& key)\n+      : _parent(0), _left(nullptr), _right(nullptr),\n+        _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n@@ -74,3 +99,4 @@\n-  private:\n-    bool is_black() const { return (_parent & 0x1) != 0; }\n-    bool is_red() const { return (_parent & 0x1) == 0; }\n+  template <typename VV = V, ENABLE_IF(!std::is_same<VV, void>::value)>\n+  RBNode(const K& key, const VV& val)\n+      :  Value<VV>(val), _parent(0), _left(nullptr), _right(nullptr),\n+        _key(key) DEBUG_ONLY(COMMA _visited(false)) {}\n@@ -78,2 +104,3 @@\n-    void set_black() { _parent |= 0x1; }\n-    void set_red() { _parent &= ~0x1; }\n+  \/\/ Gets the previous in-order node in the tree.\n+  \/\/ nullptr is returned if there is no previous node.\n+  const RBNode* prev() const;\n@@ -81,2 +108,3 @@\n-    RBNode* parent() const { return (RBNode*)(_parent & ~0x1); }\n-    void set_parent(RBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n+  \/\/ Gets the next in-order node in the tree.\n+  \/\/ nullptr is returned if there is no next node.\n+  const RBNode* next() const;\n@@ -84,3 +112,3 @@\n-    RBNode(const K& key, const V& val DEBUG_ONLY(COMMA bool visited))\n-        : _parent(0), _left(nullptr), _right(nullptr),\n-          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(visited)) {}\n+private:\n+  bool is_black() const { return (_parent & 0x1) != 0; }\n+  bool is_red() const { return (_parent & 0x1) == 0; }\n@@ -88,3 +116,2 @@\n-    bool is_right_child() const {\n-      return parent() != nullptr && parent()->_right == this;\n-    }\n+  void set_black() { _parent |= 0x1; }\n+  void set_red() { _parent &= ~0x1; }\n@@ -92,3 +119,2 @@\n-    bool is_left_child() const {\n-      return parent() != nullptr && parent()->_left == this;\n-    }\n+  RBNode* parent() const { return (RBNode*)(_parent & ~0x1); }\n+  void set_parent(RBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n@@ -96,1 +122,3 @@\n-    void replace_child(RBNode* old_child, RBNode* new_child);\n+  bool is_right_child() const {\n+    return parent() != nullptr && parent()->_right == this;\n+  }\n@@ -98,3 +126,3 @@\n-    \/\/ This node down, right child up\n-    \/\/ Returns right child (now parent)\n-    RBNode* rotate_left();\n+  bool is_left_child() const {\n+    return parent() != nullptr && parent()->_left == this;\n+  }\n@@ -102,3 +130,1 @@\n-    \/\/ This node down, left child up\n-    \/\/ Returns left child (now parent)\n-    RBNode* rotate_right();\n+  void replace_child(RBNode* old_child, RBNode* new_child);\n@@ -106,1 +132,3 @@\n-    const RBNode* prev() const;\n+  \/\/ This node down, right child up\n+  \/\/ Returns right child (now parent)\n+  RBNode* rotate_left();\n@@ -108,1 +136,3 @@\n-    const RBNode* next() const;\n+  \/\/ This node down, left child up\n+  \/\/ Returns left child (now parent)\n+  RBNode* rotate_right();\n@@ -110,6 +140,6 @@\n-  #ifdef ASSERT\n-    void verify(size_t& num_nodes, size_t& black_nodes_until_leaf,\n-                size_t& shortest_leaf_path, size_t& longest_leaf_path,\n-                size_t& tree_depth, bool expect_visited) const;\n-  #endif \/\/ ASSERT\n-  }; \/\/ End: RBNode\n+#ifdef ASSERT\n+  void verify(size_t& num_nodes, size_t& black_nodes_until_leaf,\n+              size_t& shortest_leaf_path, size_t& longest_leaf_path,\n+              size_t& tree_depth, bool expect_visited, int (*cmp)(K, K)) const;\n+#endif \/\/ ASSERT\n+}; \/\/ End: RBNode\n@@ -117,1 +147,4 @@\n-  typedef TreeType::RBNode NodeType;\n+template <typename K, typename V, typename COMPARATOR>\n+class AbstractRBTree {\n+  friend class RBTreeTest;\n+  typedef AbstractRBTree<K, V, COMPARATOR> TreeType;\n@@ -119,3 +152,17 @@\n-private:\n-  RBNode* _root;\n-  DEBUG_ONLY(mutable bool _expected_visited);\n+public:\n+  typedef RBNode<K, V> NodeType;\n+\n+  \/\/ Represents the location of a (would be) node in the tree.\n+  \/\/ If a cursor is valid (valid() == true) it points somewhere in the tree.\n+  \/\/ If the cursor points to an existing node (found() == true), node() can be used to access that node.\n+  \/\/ If no node is pointed to, node() returns null, regardless if the cursor is valid or not.\n+  class Cursor {\n+    friend AbstractRBTree<K, V, COMPARATOR>;\n+    RBNode<K, V>** _insert_location;\n+    RBNode<K, V>* _parent;\n+    K _key;\n+    Cursor() : _insert_location(nullptr), _parent(nullptr) {}\n+    Cursor(RBNode<K, V>** insert_location, RBNode<K, V>* parent, const K& key)\n+        : _insert_location(insert_location), _parent(parent), _key(key) {}\n+    Cursor(RBNode<K, V>* const* insert_location, RBNode<K, V>* parent, const K& key)\n+        : _insert_location((RBNode<K, V>**)insert_location), _parent(parent), _key(key) {}\n@@ -123,6 +170,6 @@\n-  RBNode* allocate_node(const K& key, const V& val) {\n-    void* node_place = _allocator.allocate(sizeof(RBNode));\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n-    _num_nodes++;\n-    return new (node_place) RBNode(key, val DEBUG_ONLY(COMMA _expected_visited));\n-  }\n+  public:\n+    bool valid() const { return _insert_location != nullptr; }\n+    bool found() const { return *_insert_location != nullptr; }\n+    RBNode<K, V>* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    RBNode<K, V>* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+  };\n@@ -130,5 +177,4 @@\n-  void free_node(RBNode* node) {\n-    node->_value.~V();\n-    _allocator.free(node);\n-    _num_nodes--;\n-  }\n+protected:\n+  size_t _num_nodes;\n+  RBNode<K, V>* _root;\n+  DEBUG_ONLY(mutable bool _expected_visited);\n@@ -137,1 +183,1 @@\n-  static inline bool is_black(const RBNode* node) {\n+  static inline bool is_black(const RBNode<K, V>* node) {\n@@ -141,1 +187,1 @@\n-  static inline bool is_red(const RBNode* node) {\n+  static inline bool is_red(const RBNode<K, V>* node) {\n@@ -145,0 +191,1 @@\n+  void fix_insert_violations(RBNode<K, V>* node);\n@@ -146,4 +193,1 @@\n-  \/\/ If the node with key k already exist, the value is updated instead.\n-  RBNode* insert_node(const K& key, const V& val);\n-\n-  void fix_insert_violations(RBNode* node);\n+  void remove_black_leaf(RBNode<K, V>* node);\n@@ -151,4 +195,2 @@\n-  void remove_black_leaf(RBNode* node);\n-\n-  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n-  void remove_from_tree(RBNode* node);\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove_at_cursor()`\n+  void remove_from_tree(RBNode<K, V>* node);\n@@ -159,1 +201,1 @@\n-  NONCOPYABLE(RBTree);\n+  NONCOPYABLE(AbstractRBTree);\n@@ -161,1 +203,1 @@\n-  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n+  AbstractRBTree() : _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n@@ -164,1 +206,0 @@\n-  ~RBTree() { this->remove_all(); }\n@@ -168,5 +209,37 @@\n-  \/\/ Inserts a node with the given k\/v into the tree,\n-  \/\/ if the key already exist, the value is updated instead.\n-  void upsert(const K& key, const V& val) {\n-    RBNode* node = insert_node(key, val);\n-    fix_insert_violations(node);\n+  \/\/ Gets the cursor associated with the given node or key.\n+  Cursor cursor(const K& key, const RBNode<K, V>* hint_node = nullptr);\n+  Cursor cursor(const RBNode<K, V>* node);\n+  const Cursor cursor(const K& key, const RBNode<K, V>* hint_node = nullptr) const;\n+  const Cursor cursor(const RBNode<K, V>* node) const;\n+\n+  \/\/ Moves to the next existing node.\n+  \/\/ If no next node exist, the cursor becomes invalid.\n+  Cursor next(const Cursor& node_cursor);\n+  const Cursor next(const Cursor& node_cursor) const;\n+\n+  \/\/ Moves to the previous existing node.\n+  \/\/ If no previous node exist, the cursor becomes invalid.\n+  Cursor prev(const Cursor& node_cursor);\n+  const Cursor prev(const Cursor& node_cursor) const;\n+\n+  \/\/ Initializes and inserts a node at the cursor location.\n+  \/\/ The cursor must not point to an existing node.\n+  \/\/ Node is given the same key used in `cursor()`.\n+  void insert_at_cursor(RBNode<K, V>* node, const Cursor& node_cursor);\n+\n+  \/\/ Removes the node referenced by the cursor\n+  \/\/ The cursor must point to a valid existing node\n+  void remove_at_cursor(const Cursor& node_cursor);\n+\n+  \/\/ Replace the node referenced by the cursor with a new node.\n+  \/\/ The old node is destroyed.\n+  \/\/ The user must ensure that no tree properties are broken:\n+  \/\/ There must not exist any node with the new key\n+  \/\/ For all nodes with key < old_key, must also have key < new_key\n+  \/\/ For all nodes with key > old_key, must also have key > new_key\n+  void replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor);\n+\n+  \/\/ Finds the value of the node associated with the given key.\n+  V* find(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n@@ -175,9 +248,3 @@\n-  \/\/ Removes the node with the given key from the tree if it exists.\n-  \/\/ Returns true if the node was successfully removed, false otherwise.\n-  bool remove(const K& key) {\n-    RBNode* node = find_node(key);\n-    if (node == nullptr){\n-      return false;\n-    }\n-    remove(node);\n-    return true;\n+  V* find(const K& key) const {\n+    const Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n@@ -186,2 +253,5 @@\n-  \/\/ Removes the given node from the tree. node must be a valid node\n-  void remove(RBNode* node);\n+  \/\/ Finds the node associated with the given key.\n+  RBNode<K, V>* find_node(const K& key, const RBNode<K, V>* hint_node = nullptr) const {\n+    Cursor node_cursor = cursor(key, hint_node);\n+    return node_cursor.node();\n+  }\n@@ -189,5 +259,4 @@\n-  \/\/ Removes all existing nodes from the tree.\n-  void remove_all() {\n-    RBNode* to_delete[64];\n-    int stack_idx = 0;\n-    to_delete[stack_idx++] = _root;\n+  RBNode<K, V>* find_node(const K& key, const RBNode<K, V>* hint_node = nullptr) {\n+    Cursor node_cursor = cursor(key, hint_node);\n+    return node_cursor.node();\n+  }\n@@ -195,9 +264,4 @@\n-    while (stack_idx > 0) {\n-      RBNode* head = to_delete[--stack_idx];\n-      if (head == nullptr) continue;\n-      to_delete[stack_idx++] = head->_left;\n-      to_delete[stack_idx++] = head->_right;\n-      free_node(head);\n-    }\n-    _num_nodes = 0;\n-    _root = nullptr;\n+  \/\/ Inserts the given node into the tree.\n+  void insert(RBNode<K, V>* node, const RBNode<K, V>* hint_node = nullptr) {\n+    Cursor node_cursor = cursor(node->key(), hint_node);\n+    insert_at_cursor(node, node_cursor);\n@@ -206,19 +270,3 @@\n-  \/\/ Finds the node with the closest key <= the given key\n-  const RBNode* closest_leq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r < 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_right;\n-      } else {\n-        pos = pos->_left;\n-      }\n-    }\n-    return candidate;\n+  void remove(RBNode<K, V>* node) {\n+    Cursor node_cursor = cursor(node);\n+    remove_at_cursor(node_cursor);\n@@ -227,15 +275,5 @@\n-  \/\/ Finds the node with the closest key > the given key\n-  const RBNode* closest_gt(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n+  \/\/ Finds the node with the closest key <= the given key.\n+  \/\/ If no node is found, null is returned instead.\n+  RBNode<K, V>* closest_leq(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n@@ -244,19 +282,10 @@\n-  \/\/ Finds the node with the closest key >= the given key\n-  const RBNode* closest_geq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n+  RBNode<K, V>* closest_leq(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n+  }\n+\n+  \/\/ Finds the node with the closest key > the given key.\n+  \/\/ If no node is found, null is returned instead.\n+  RBNode<K, V>* closest_gt(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return next(node_cursor).node();\n@@ -265,3 +294,3 @@\n-  RBNode* closest_leq(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_leq(key));\n+  RBNode<K, V>* closest_gt(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return next(node_cursor).node();\n@@ -270,3 +299,5 @@\n-  RBNode* closest_gt(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_gt(key));\n+  \/\/ Finds the node with the closest key >= the given key.\n+  \/\/ If no node is found, null is returned instead.\n+  RBNode<K, V>* closest_ge(const K& key) const {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n@@ -275,3 +306,3 @@\n-  RBNode* closest_geq(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->closest_geq(key));\n+  RBNode<K, V>* closest_ge(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n@@ -282,2 +313,2 @@\n-  const RBNode* leftmost() const {\n-    RBNode* n = _root, *n2 = nullptr;\n+  const RBNode<K, V>* leftmost() const {\n+    RBNode<K, V>* n = _root, *n2 = nullptr;\n@@ -293,2 +324,2 @@\n-  const RBNode* rightmost() const {\n-    RBNode* n = _root, *n2 = nullptr;\n+  const RBNode<K, V>* rightmost() const {\n+    RBNode<K, V>* n = _root, *n2 = nullptr;\n@@ -302,2 +333,2 @@\n-  RBNode* leftmost()  { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->leftmost()); }\n-  RBNode* rightmost() { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->rightmost()); }\n+  RBNode<K, V>* leftmost()  { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->leftmost()); }\n+  RBNode<K, V>* rightmost() { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->rightmost()); }\n@@ -306,3 +337,3 @@\n-    RBNode* start;\n-    RBNode* end;\n-    Range(RBNode* start, RBNode* end)\n+    RBNode<K, V>* start;\n+    RBNode<K, V>* end;\n+    Range(RBNode<K, V>* start, RBNode<K, V>* end)\n@@ -316,2 +347,2 @@\n-    RBNode* start = closest_leq(key);\n-    RBNode* end = closest_gt(key);\n+    RBNode<K, V>* start = closest_leq(key);\n+    RBNode<K, V>* end = closest_gt(key);\n@@ -321,19 +352,0 @@\n-  \/\/ Finds the node associated with the key\n-  const RBNode* find_node(const K& key) const;\n-\n-  RBNode* find_node(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const TreeType*>(this)->find_node(key));\n-  }\n-\n-  \/\/ Finds the value associated with the key\n-  V* find(const K& key) {\n-    RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n-  const V* find(const K& key) const {\n-    const RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n@@ -355,0 +367,81 @@\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+class RBTree : public AbstractRBTree<K, V, COMPARATOR> {\n+  friend class RBTreeTest;\n+  typedef AbstractRBTree<K, V, COMPARATOR> BaseType;\n+\n+  ALLOCATOR _allocator;\n+\n+public:\n+  RBTree() : BaseType(), _allocator() {}\n+  ~RBTree() { remove_all(); }\n+\n+  typedef typename BaseType::Cursor Cursor;\n+  using BaseType::cursor;\n+  using BaseType::insert_at_cursor;\n+  using BaseType::remove_at_cursor;\n+  using BaseType::next;\n+  using BaseType::prev;\n+\n+  RBNode<K, V>* allocate_node(const K& key, const V& val) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    return new (node_place) RBNode<K, V>(key, val);\n+  }\n+\n+  void free_node(RBNode<K, V>* node) {\n+    node->_value.~V();\n+    _allocator.free(node);\n+  }\n+\n+  \/\/ Inserts a node with the given key\/value into the tree,\n+  \/\/ if the key already exist, the value is updated instead.\n+  void upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n+    Cursor node_cursor = cursor(key, hint_node);\n+    RBNode<K, V>* node = node_cursor.node();\n+    if (node != nullptr) {\n+      \/\/ node->_value = val;\n+      node->set_val(val);\n+      return;\n+    }\n+\n+    node = allocate_node(key, val);\n+    insert_at_cursor(node, node_cursor);\n+  }\n+\n+  void remove(RBNode<K, V>* node) {\n+    Cursor node_cursor = cursor(node);\n+    remove_at_cursor(node_cursor);\n+    free_node(node);\n+  }\n+\n+  \/\/ Removes the node with the given key from the tree if it exists.\n+  \/\/ Returns true if the node was successfully removed, false otherwise.\n+  bool remove(const K& key) {\n+    Cursor node_cursor = cursor(key);\n+    if (!node_cursor.found()) {\n+      return false;\n+    }\n+    RBNode<K, V>* node = node_cursor.node();\n+    remove_at_cursor(node_cursor);\n+    free_node((RBNode<K, V>*)node);\n+    return true;\n+  }\n+\n+  \/\/ Removes all existing nodes from the tree.\n+  void remove_all() {\n+    RBNode<K, V>* to_delete[64];\n+    int stack_idx = 0;\n+    to_delete[stack_idx++] = BaseType::_root;\n+\n+    while (stack_idx > 0) {\n+      RBNode<K, V>* head = to_delete[--stack_idx];\n+      if (head == nullptr) continue;\n+      to_delete[stack_idx++] = head->_left;\n+      to_delete[stack_idx++] = head->_right;\n+      free_node((RBNode<K, V>*)head);\n+    }\n+    BaseType::_num_nodes = 0;\n+    BaseType::_root = nullptr;\n+  }\n+};\n+\n@@ -373,0 +466,6 @@\n+template <typename K>\n+using IntrusiveNode = RBNode<K, void>;\n+\n+template <typename K, typename COMPARATOR>\n+using IntrusiveRBTree = AbstractRBTree<K, void, COMPARATOR>;\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":306,"deletions":207,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -35,3 +35,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::replace_child(\n-    RBNode* old_child, RBNode* new_child) {\n+template <typename K, typename V>\n+inline void RBNode<K, V>::replace_child(RBNode<K, V>* old_child, RBNode<K, V>* new_child) {\n@@ -47,3 +46,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_left() {\n+template <typename K, typename V>\n+inline RBNode<K, V>* RBNode<K, V>::rotate_left() {\n@@ -51,1 +49,1 @@\n-  RBNode* old_right = _right;\n+  RBNode<K, V>* old_right = _right;\n@@ -69,3 +67,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::rotate_right() {\n+template <typename K, typename V>\n+inline RBNode<K, V>* RBNode<K, V>::rotate_right() {\n@@ -73,1 +70,1 @@\n-  RBNode* old_left = _left;\n+  RBNode<K, V>* old_left = _left;\n@@ -91,4 +88,3 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::prev() const {\n-  const RBNode* node = this;\n+template <typename K, typename V>\n+inline const RBNode<K, V>* RBNode<K, V>::prev() const {\n+  const RBNode<K, V>* node = this;\n@@ -109,4 +105,3 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::next() const {\n-  const RBNode* node = this;\n+template <typename K, typename V>\n+inline const RBNode<K, V>* RBNode<K, V>::next() const {\n+  const RBNode<K, V>* node = this;\n@@ -128,2 +123,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode::verify(\n+template <typename K, typename V>\n+inline void RBNode<K, V>::verify(\n@@ -131,1 +126,1 @@\n-    size_t& tree_depth, bool expect_visited) const {\n+    size_t& tree_depth, bool expect_visited, int (*cmp)(K, K)) const {\n@@ -144,1 +139,1 @@\n-    assert(COMPARATOR::cmp(_left->key(), _key) < 0, \"left node must be less than parent\");\n+    assert(cmp(_left->key(), _key) < 0, \"left node must be less than parent\");\n@@ -148,1 +143,1 @@\n-                  longest_leaf_path_left, tree_depth_left, expect_visited);\n+                  longest_leaf_path_left, tree_depth_left, expect_visited, cmp);\n@@ -160,1 +155,1 @@\n-    assert(COMPARATOR::cmp(_right->key(), _key) > 0, \"right node must be greater than parent\");\n+    assert(cmp(_right->key(), _key) > 0, \"right node must be greater than parent\");\n@@ -164,1 +159,1 @@\n-                   longest_leaf_path_right, tree_depth_right, expect_visited);\n+                   longest_leaf_path_right, tree_depth_right, expect_visited, cmp);\n@@ -190,13 +185,18 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& key) const {\n-  RBNode* curr = _root;\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n-\n-    if (key_cmp_k == 0) {\n-      return curr;\n-    } else if (key_cmp_k < 0) {\n-      curr = curr->_left;\n-    } else {\n-      curr = curr->_right;\n+template <typename K, typename V, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::cursor(const K& key, const RBNode<K, V>* hint_node) const {\n+  RBNode<K, V>* parent = nullptr;\n+  RBNode<K, V>* const* insert_location = &_root;\n+\n+  if (hint_node != nullptr) {\n+    const int hint_cmp = COMPARATOR::cmp(hint_node->key(), key);\n+    while (hint_node->parent() != nullptr) {\n+      const int parent_cmp = COMPARATOR::cmp(hint_node->parent()->key(), key);\n+      \/\/ Move up until the parent would put us on the other side of the key.\n+      \/\/ Meaning we are in the correct subtree.\n+      if ((parent_cmp <= 0 && hint_cmp < 0) ||\n+          (parent_cmp >= 0 && hint_cmp > 0)) {\n+        hint_node = hint_node->parent();\n+      } else {\n+        break;\n+      }\n@@ -204,1 +204,0 @@\n-  }\n@@ -206,10 +205,5 @@\n-  return nullptr;\n-}\n-\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& key, const V& val) {\n-  RBNode* curr = _root;\n-  if (curr == nullptr) { \/\/ Tree is empty\n-    _root = allocate_node(key, val);\n-    return _root;\n+    if (hint_node->is_left_child()) {\n+      insert_location = &hint_node->parent()->_left;\n+    } else if (hint_node->is_right_child()) {\n+      insert_location = &hint_node->parent()->_right;\n+    }\n@@ -218,2 +212,2 @@\n-  RBNode* parent = nullptr;\n-  while (curr != nullptr) {\n+  while (*insert_location != nullptr) {\n+    RBNode<K, V>* curr = *insert_location;\n@@ -223,2 +217,1 @@\n-      curr->_value = val;\n-      return curr;\n+      break;\n@@ -227,1 +220,1 @@\n-    parent = curr;\n+    parent = *insert_location;\n@@ -229,1 +222,1 @@\n-      curr = curr->_left;\n+      insert_location = &curr->_left;\n@@ -231,1 +224,1 @@\n-      curr = curr->_right;\n+      insert_location = &curr->_right;\n@@ -235,3 +228,7 @@\n-  \/\/ Create and insert new node\n-  RBNode* node = allocate_node(key, val);\n-  node->set_parent(parent);\n+  return Cursor(insert_location, parent, key);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline void AbstractRBTree<K, V, COMPARATOR>::insert_at_cursor(RBNode<K, V>* node, const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && !node_cursor.found(), \"must be\");\n+  _num_nodes++;\n@@ -239,5 +236,14 @@\n-  const int key_cmp_k = COMPARATOR::cmp(key, parent->key());\n-  if (key_cmp_k < 0) {\n-    parent->_left = node;\n-  } else {\n-    parent->_right = node;\n+  *node_cursor._insert_location = node;\n+\n+  node->set_parent(node_cursor._parent);\n+  node->set_red();\n+  node->_left = nullptr;\n+  node->_right = nullptr;\n+  node->_key = node_cursor._key;\n+\n+#ifdef ASSERT\n+  node->_visited = _expected_visited;\n+#endif \/\/ ASSERT\n+\n+  if (node_cursor._parent == nullptr) {\n+    return;\n@@ -246,1 +252,1 @@\n-  return node;\n+  fix_insert_violations(node);\n@@ -249,2 +255,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::fix_insert_violations(RBNode* node) {\n+template <typename K, typename V, typename COMPARATOR>\n+inline void AbstractRBTree<K, V, COMPARATOR>::fix_insert_violations(RBNode<K, V>* node) {\n@@ -255,1 +261,1 @@\n-  RBNode* parent = node->parent();\n+  RBNode<K, V>* parent = node->parent();\n@@ -259,1 +265,1 @@\n-    RBNode* grandparent = parent->parent();\n+    RBNode<K, V>* grandparent = parent->parent();\n@@ -266,1 +272,1 @@\n-    RBNode* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n+    RBNode<K, V>* uncle = parent->is_left_child() ? grandparent->_right : grandparent->_left;\n@@ -308,2 +314,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_black_leaf(RBNode* node) {\n+template <typename K, typename V, typename COMPARATOR>\n+inline void AbstractRBTree<K, V, COMPARATOR>::remove_black_leaf(RBNode<K, V>* node) {\n@@ -311,1 +317,1 @@\n-  RBNode* parent = node->parent();\n+  RBNode<K, V>* parent = node->parent();\n@@ -315,1 +321,1 @@\n-    RBNode* sibling = node->is_left_child() ? parent->_right : parent->_left;\n+    RBNode<K, V>* sibling = node->is_left_child() ? parent->_right : parent->_left;\n@@ -339,2 +345,2 @@\n-    RBNode* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n-    RBNode* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n+    RBNode<K, V>* close_nephew = node->is_left_child() ? sibling->_left : sibling->_right;\n+    RBNode<K, V>* distant_nephew = node->is_left_child() ? sibling->_right : sibling->_left;\n@@ -396,5 +402,5 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_from_tree(RBNode* node) {\n-  RBNode* parent = node->parent();\n-  RBNode* left = node->_left;\n-  RBNode* right = node->_right;\n+template <typename K, typename V, typename COMPARATOR>\n+inline void AbstractRBTree<K, V, COMPARATOR>::remove_from_tree(RBNode<K, V>* node) {\n+  RBNode<K, V>* parent = node->parent();\n+  RBNode<K, V>* left = node->_left;\n+  RBNode<K, V>* right = node->_right;\n@@ -442,3 +448,6 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n-  assert(node != nullptr, \"must be\");\n+template <typename K, typename V, typename COMPARATOR>\n+inline void AbstractRBTree<K, V, COMPARATOR>::remove_at_cursor(const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && node_cursor.found(), \"must be\");\n+  _num_nodes--;\n+\n+  RBNode<K, V>* node = node_cursor.node();\n@@ -448,1 +457,1 @@\n-    RBNode* curr = node->_right;\n+    RBNode<K, V>* curr = node->_right;\n@@ -478,1 +487,0 @@\n-  free_node(node);\n@@ -481,1 +489,108 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename K, typename V, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::cursor(const RBNode<K, V>* node) const {\n+  if (node == nullptr) {\n+    return Cursor();\n+  }\n+\n+  if (node->parent() == nullptr) {\n+    return Cursor(&_root, nullptr, node->key());\n+  }\n+\n+  RBNode<K, V>* parent = node->parent();\n+  RBNode<K, V>** insert_location =\n+      node->is_left_child() ? &parent->_left : &parent->_right;\n+  return Cursor(insert_location, parent, node->key());\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::next(const Cursor& node_cursor) const {\n+  if (node_cursor.found()) {\n+    return cursor(node_cursor.node()->next());\n+  }\n+\n+  if (node_cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&node_cursor._parent->_left == node_cursor._insert_location) { \/\/ Left child, parent is next\n+    return cursor(node_cursor._parent);\n+  }\n+\n+  return cursor(node_cursor._parent->next()); \/\/ Right child, parent's next is also node's next\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline const typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::prev(const Cursor& node_cursor) const {\n+  if (node_cursor.found()) {\n+    return cursor(node_cursor.node()->prev());\n+  }\n+\n+  if (node_cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&node_cursor._parent->_right == node_cursor._insert_location) { \/\/ Right child, parent is prev\n+    return cursor(node_cursor._parent);\n+  }\n+\n+  return cursor(node_cursor._parent->prev()); \/\/ Left child, parent's prev is also node's prev\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline void AbstractRBTree<K, V, COMPARATOR>::replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor) {\n+  assert(node_cursor.valid() && node_cursor.found(), \"must be\");\n+  RBNode<K, V>* old_node = node_cursor.node();\n+  if (old_node == new_node) {\n+    return;\n+  }\n+\n+  *node_cursor._insert_location = new_node;\n+  new_node->set_parent(node_cursor._parent);\n+  new_node->_color = old_node->_color;\n+\n+  new_node->_left = old_node->_left;\n+  new_node->_right = old_node->_right;\n+  if (new_node->_left != nullptr) {\n+    new_node->_left->set_parent(new_node);\n+  } else if (new_node->_right != nullptr) {\n+    new_node->_right->_parent = new_node;\n+    new_node->_right->set_parent(new_node);\n+  }\n+\n+  free_node(old_node);\n+\n+#ifdef ASSERT\n+  verify_self(); \/\/ Dangerous operation, should verify no tree properties were broken\n+#endif \/\/ ASSERT\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::cursor(const K& key, const RBNode<K, V>* hint_node) {\n+  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->cursor(key, hint_node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::cursor(const RBNode<K, V>* node) {\n+  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->cursor(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::next(const Cursor& node_cursor) {\n+  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->next(node_cursor);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n+inline typename AbstractRBTree<K, V, COMPARATOR>::Cursor\n+AbstractRBTree<K, V, COMPARATOR>::prev(const Cursor& node_cursor) {\n+  return static_cast<const AbstractRBTree<K, V, COMPARATOR>*>(this)->prev(node_cursor);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR>\n@@ -483,13 +598,5 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_in_order(F f) const {\n-  const RBNode* to_visit[64];\n-  int stack_idx = 0;\n-  const RBNode* head = _root;\n-  while (stack_idx > 0 || head != nullptr) {\n-    while (head != nullptr) {\n-      to_visit[stack_idx++] = head;\n-      assert(stack_idx <= (int)(sizeof(to_visit)\/sizeof(to_visit[0])), \"stack too deep\");\n-      head = head->_left;\n-    }\n-    head = to_visit[--stack_idx];\n-    f(head);\n-    head = head->_right;\n+inline void AbstractRBTree<K, V, COMPARATOR>::visit_in_order(F f) const {\n+  const RBNode<K, V>* node = leftmost();\n+  while (node != nullptr) {\n+    f(node);\n+    node = node->next();\n@@ -499,1 +606,1 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template <typename K, typename V, typename COMPARATOR>\n@@ -501,1 +608,1 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n+inline void AbstractRBTree<K, V, COMPARATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n@@ -503,3 +610,8 @@\n-  const RBNode* curr = closest_geq(from);\n-  if (curr == nullptr) return;\n-  const RBNode* const end = closest_geq(to);\n+  if (_root == nullptr) {\n+    return;\n+  }\n+\n+  Cursor cursor_start = cursor(from);\n+  Cursor cursor_end = cursor(to);\n+  const RBNode<K, V>* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  const RBNode<K, V>* end = cursor_end.found() ? cursor_end.node() : next(cursor_end).node();\n@@ -507,3 +619,3 @@\n-  while (curr != nullptr && curr != end) {\n-    f(curr);\n-    curr = curr->next();\n+  while (start != end) {\n+    f(start);\n+    start = start->next();\n@@ -514,2 +626,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::verify_self() const {\n+template <typename K, typename V, typename COMPARATOR>\n+inline void AbstractRBTree<K, V, COMPARATOR>::verify_self() const {\n@@ -517,1 +629,1 @@\n-    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    assert(_num_nodes == 0, \"rbtree has %zu nodes but no root\", _num_nodes);\n@@ -530,1 +642,1 @@\n-  _root->verify(num_nodes, black_depth, shortest_leaf_path, longest_leaf_path, tree_depth, _expected_visited);\n+  _root->verify(num_nodes, black_depth, shortest_leaf_path, longest_leaf_path, tree_depth, _expected_visited, COMPARATOR::cmp);\n@@ -564,2 +676,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-void RBTree<K, V, COMPARATOR, ALLOCATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n+template <typename K, typename V, typename COMPARATOR>\n+void AbstractRBTree<K, V, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n@@ -582,2 +694,2 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-void RBTree<K, V, COMPARATOR, ALLOCATOR>::print_on(outputStream* st) const {\n+template <typename K, typename V, typename COMPARATOR>\n+void AbstractRBTree<K, V, COMPARATOR>::print_on(outputStream* st) const {\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":229,"deletions":117,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -75,1 +75,16 @@\n-using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtOther>;\n+  using RBTreeInt = RBTreeCHeap<int, int, Cmp, mtTest>;\n+  using RBTreeIntNode = RBNode<int, int>;\n+  using IntrusiveTreeInt = IntrusiveRBTree<int, Cmp>;\n+  using IntrusiveNode = IntrusiveNode<int>;\n+  using IntrusiveCursor = IntrusiveTreeInt::Cursor;\n+\n+  struct IntrusiveHolder {\n+    IntrusiveNode node;\n+    int data;\n+\n+    IntrusiveNode* get_node() { return &node; }\n+\n+    IntrusiveHolder() {}\n+    IntrusiveHolder(int data) : data(data) {}\n+    static IntrusiveHolder* cast_to_self(IntrusiveNode* node) { return (IntrusiveHolder*)node; }\n+  };\n@@ -92,1 +107,1 @@\n-    rbtree_const.visit_in_order([&](const RBTreeInt::RBNode* node) {\n+    rbtree_const.visit_in_order([&](const RBTreeIntNode* node) {\n@@ -151,1 +166,1 @@\n-    using Node = RBTreeCHeap<float, Empty, FCmp, mtOther>::RBNode;\n+    using Node = RBNode<float, Empty>;\n@@ -171,1 +186,1 @@\n-      using Node = RBTreeInt::RBNode;\n+      using Node = RBTreeIntNode;\n@@ -247,1 +262,1 @@\n-      using Node = RBTreeCHeap<int, int, CmpInverse, mtOther>::RBNode;\n+      using Node = RBNode<int, int>;\n@@ -274,1 +289,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -298,0 +313,71 @@\n+  void test_closest_gt() {\n+    using Node = RBTreeIntNode;\n+    {\n+      RBTreeInt rbtree;\n+      Node* n = rbtree.closest_gt(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-5, -5);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-5);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-10);\n+      EXPECT_EQ(-5, n->key());\n+\n+      rbtree.upsert(10, 10);\n+      n = rbtree.closest_gt(5);\n+      EXPECT_EQ(10, n->key());\n+\n+      n = rbtree.closest_gt(10);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_leftmost() {\n+    using Node = RBTreeIntNode;\n+\n+    RBTreeInt rbtree;\n+    Node* n = rbtree.leftmost();\n+    EXPECT_EQ(nullptr, n);\n+\n+    rbtree.upsert(0, 0);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(2, 2);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(1, 1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(-1, -1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(-1, n->key());\n+\n+    rbtree.remove(-1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(1);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(0);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(2, n->key());\n+\n+    rbtree.remove(2);\n+    n = rbtree.leftmost();\n+    EXPECT_EQ(nullptr, n);\n+\n+  }\n+\n@@ -301,1 +387,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -322,1 +408,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -343,1 +429,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -371,1 +457,1 @@\n-    using Node = Tree::RBNode;\n+    using Node = RBNode<int, void*>;\n@@ -374,1 +460,1 @@\n-      rbtree.upsert(i, nullptr);\n+      rbtree.upsert(i, (void*)nullptr);\n@@ -394,0 +480,109 @@\n+  void test_node_hints() {\n+    constexpr int num_nodes = 100;\n+    RBTreeInt tree;\n+    RBTreeIntNode* nodes[num_nodes];\n+\n+    RBTreeIntNode* prev_node = nullptr;\n+    for (int i = 0; i < num_nodes; i++) {\n+      RBTreeIntNode* node = tree.allocate_node(i, i);\n+      nodes[i] = node;\n+      tree.insert(node, prev_node);\n+      prev_node = node;\n+    }\n+\n+    for (int i = 0; i < num_nodes; i++) {\n+      RBTreeIntNode* target_node = nodes[i];\n+      for (int j = 0; j < num_nodes; j++) {\n+        if (i == j) continue;\n+        RBTreeIntNode* hint_node = nodes[j];\n+        RBTreeIntNode* find_node = tree.find_node(i);\n+        RBTreeIntNode* hint_find_node = tree.find_node(i, hint_node);\n+\n+        ASSERT_EQ(find_node, hint_find_node);\n+        ASSERT_EQ(target_node, hint_find_node);\n+      }\n+    }\n+  }\n+\n+  void test_cursor() {\n+    constexpr int num_nodes = 10;\n+    RBTreeInt tree;\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor(n);\n+      EXPECT_FALSE(find_cursor.found());\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      RBTreeInt::Cursor find_cursor = tree.cursor(n);\n+      EXPECT_TRUE(find_cursor.found());\n+    }\n+\n+    EXPECT_FALSE(tree.cursor(-1).found());\n+    EXPECT_FALSE(tree.cursor(101).found());\n+  }\n+\n+  void test_get_cursor() {\n+    constexpr int num_nodes = 10;\n+    IntrusiveTreeInt tree;\n+    GrowableArrayCHeap<IntrusiveHolder*, mtTest> nodes(num_nodes);\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n);\n+\n+      tree.insert_at_cursor(place->get_node(), tree.cursor(n));\n+      nodes.push(place);\n+    }\n+\n+    for (int n = 0; n <= num_nodes; n++) {\n+      IntrusiveNode* node = nodes.at(n)->get_node();\n+      IntrusiveCursor cursor = tree.cursor(node);\n+      IntrusiveCursor find_cursor = tree.cursor(n);\n+      EXPECT_TRUE(cursor.found());\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_TRUE(find_cursor.found());\n+      EXPECT_TRUE(find_cursor.valid());\n+      EXPECT_EQ(cursor.node(), find_cursor.node());\n+    }\n+  }\n+\n+  void test_cursor_empty_tree() {\n+    RBTreeInt tree;\n+    RBTreeInt::Cursor cursor = tree.cursor(tree.leftmost());\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor(0);\n+    EXPECT_TRUE(cursor.valid());\n+    EXPECT_FALSE(cursor.found());\n+    EXPECT_FALSE(tree.next(cursor).valid());\n+  }\n+\n+  void test_cursor_iterate() {\n+    constexpr int num_nodes = 100;\n+    RBTreeInt tree;\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    RBTreeInt::Cursor cursor = tree.cursor(0);\n+    for (int n = 0; n <= num_nodes; n++) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.next(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor(num_nodes);\n+    for (int n = num_nodes; n >= 0; n--) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.prev(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+  }\n+\n@@ -395,1 +590,1 @@\n-    using Node = RBTreeInt::RBNode;\n+    using Node = RBTreeIntNode;\n@@ -474,0 +669,48 @@\n+  void test_intrusive() {\n+    IntrusiveTreeInt intrusive_tree;\n+    int num_iterations = 100;\n+\n+    \/\/ Insert values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+\n+      \/\/ Custom allocation here is just malloc\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n);\n+\n+      intrusive_tree.insert_at_cursor(place->get_node(), cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NOT_NULL(cursor2.node());\n+\n+      intrusive_tree.verify_self();\n+    }\n+\n+    \/\/ Check inserted values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+      EXPECT_EQ(n, IntrusiveHolder::cast_to_self(cursor.node())->data);\n+    }\n+\n+    \/\/ Remove all values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+\n+      intrusive_tree.remove_at_cursor(cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NULL(cursor2.node());\n+\n+      intrusive_tree.verify_self();\n+    }\n+\n+    \/\/ Check removed values\n+    for (int n = 0; n < num_iterations; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+    }\n+  }\n+\n@@ -477,1 +720,1 @@\n-    using Node = Tree::RBNode;\n+    using Node = RBNode<int, int>;\n@@ -527,0 +770,8 @@\n+TEST_VM_F(RBTreeTest, TestClosestGt) {\n+  this->test_closest_gt();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFirst) {\n+  this->test_leftmost();\n+}\n+\n@@ -543,0 +794,21 @@\n+\n+TEST_VM_F(RBTreeTest, NodeHints) {\n+  this->test_node_hints();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorFind) {\n+  this->test_cursor();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorGet) {\n+  this->test_cursor();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorEmptyTreeTest) {\n+  this->test_cursor_empty_tree();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorIterateTest) {\n+  this->test_cursor_iterate();\n+}\n+\n@@ -573,3 +845,3 @@\n-  tree.upsert(p1, 1);\n-  tree.upsert(p2, 2);\n-  tree.upsert(p3, 3);\n+  tree.upsert(p1, 1U);\n+  tree.upsert(p2, 2U);\n+  tree.upsert(p3, 3U);\n@@ -597,3 +869,3 @@\n-    tree.upsert(i1, 1);\n-    tree.upsert(i2, 2);\n-    tree.upsert(i3, 3);\n+    tree.upsert(i1, 1U);\n+    tree.upsert(i2, 2U);\n+    tree.upsert(i3, 3U);\n@@ -609,0 +881,4 @@\n+TEST_VM_F(RBTreeTest, IntrusiveTest) {\n+  this->test_intrusive();\n+}\n+\n@@ -661,2 +937,1 @@\n-    struct Nothing {};\n-    RBTreeCHeap<int, Nothing, Cmp, mtOther> rbtree;\n+    RBTreeCHeap<int, int, Cmp, mtOther> rbtree;\n@@ -665,1 +940,1 @@\n-      rbtree.upsert(i, Nothing());\n+      rbtree.upsert(i, i);\n@@ -667,0 +942,1 @@\n+    EXPECT_EQ((size_t)one_hundred_thousand, rbtree.size());\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":298,"deletions":22,"binary":false,"changes":320,"status":"modified"}]}