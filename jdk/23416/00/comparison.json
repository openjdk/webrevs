{"files":[{"patch":"@@ -33,0 +33,3 @@\n+struct Empty {};\n+class RBTreeNoopAllocator;\n+\n@@ -42,1 +45,0 @@\n-\n@@ -69,1 +71,16 @@\n-    const V& val() const { return _value; }\n+    V& val() const { return _value; }\n+\n+    RBNode(const K& key)\n+        : _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key), _value(Empty()) DEBUG_ONLY(COMMA _visited(false)) {}\n+    RBNode(const K& key, const V& val)\n+        : _parent(0), _left(nullptr), _right(nullptr),\n+          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(false)) {}\n+\n+    \/\/ Gets the previous in-order node in the tree.\n+    \/\/ nullptr is returned if there is no previous node.\n+    RBNode* prev();\n+\n+    \/\/ Gets the next in-order node in the tree.\n+    \/\/ nullptr is returned if there is no next node.\n+    RBNode* next();\n@@ -81,4 +98,0 @@\n-    RBNode(const K& key, const V& val DEBUG_ONLY(COMMA bool visited))\n-        : _parent(0), _left(nullptr), _right(nullptr),\n-          _key(key), _value(val) DEBUG_ONLY(COMMA _visited(visited)) {}\n-\n@@ -103,4 +116,0 @@\n-    RBNode* prev();\n-\n-    RBNode* next();\n-\n@@ -114,0 +123,19 @@\n+  \/\/ Represents the location of a (would be) node in the tree.\n+  \/\/ If a cursor is valid (valid() == true) it points somewhere in the tree.\n+  \/\/ If the cursor points to an existing node (found() == true), node() can be used to access that node,\n+  \/\/ Otherwise nullptr is returned, regardless if the node is valid or not.\n+  class Cursor {\n+    friend RBTree<K, V, COMPARATOR, ALLOCATOR>;\n+    RBNode** _insert_location;\n+    RBNode* _parent;\n+    Cursor() : _insert_location(nullptr), _parent(nullptr) {}\n+    Cursor(RBNode** insert_location, RBNode* parent) : _insert_location(insert_location), _parent(parent) {}\n+    Cursor(RBNode* const* insert_location, RBNode* parent) : _insert_location((RBNode**)insert_location), _parent(parent) {}\n+\n+  public:\n+    bool valid() const { return _insert_location != nullptr; }\n+    bool found() const { return *_insert_location != nullptr; }\n+    RBNode* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    RBNode* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+  };\n+\n@@ -116,0 +144,1 @@\n+  RBNode* _first;\n@@ -121,2 +150,1 @@\n-    _num_nodes++;\n-    return new (node_place) RBNode(key, val DEBUG_ONLY(COMMA _expected_visited));\n+    return new (node_place) RBNode(key, val);\n@@ -128,1 +156,0 @@\n-    _num_nodes--;\n@@ -140,1 +167,0 @@\n-\n@@ -148,1 +174,1 @@\n-  \/\/ Assumption: node has at most one child. Two children is handled in `remove()`\n+  \/\/ Assumption: node has at most one child. Two children is handled in `remove_at_cursor()`\n@@ -154,1 +180,1 @@\n-  RBTree() : _allocator(), _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n+  RBTree() : _allocator(), _num_nodes(0), _root(nullptr), _first(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n@@ -157,1 +183,1 @@\n-  ~RBTree() { this->remove_all(); }\n+  ~RBTree() { if (!std::is_same<ALLOCATOR, RBTreeNoopAllocator>::value) this->remove_all(); }\n@@ -160,0 +186,57 @@\n+  RBNode* first() { return _first; }\n+\n+  \/\/ Gets the cursor to the given node.\n+  Cursor get_cursor(RBNode* node);\n+  const Cursor get_cursor(RBNode* node) const;\n+\n+  \/\/ Moves to the next valid node.\n+  \/\/ If no next node exist, the cursor becomes invalid.\n+  Cursor next(const Cursor& cursor);\n+  const Cursor next(const Cursor& cursor) const;\n+\n+  \/\/ Moves to the previous valid node.\n+  \/\/ If no previous node exist, the cursor becomes invalid.\n+  Cursor prev(const Cursor& cursor);\n+  const Cursor prev(const Cursor& cursor) const;\n+\n+  \/\/ Finds the cursor to the node associated with the given key.\n+  Cursor cursor_find(const K& key);\n+  const Cursor cursor_find(const K& key) const;\n+\n+  \/\/ Inserts the given node at the cursor location\n+  \/\/ The cursor must not point to an existing node\n+  void insert_at_cursor(RBNode* node, const Cursor& cursor);\n+\n+  \/\/ Removes the node referenced by the cursor\n+  \/\/ The cursor must point to a valid existing node\n+  void remove_at_cursor(const Cursor& cursor);\n+\n+  \/\/ Replace the node referenced by the cursor with a new node.\n+  \/\/ The old node is destroyed.\n+  \/\/ The user must ensure that no tree properties are broken:\n+  \/\/ There must not exist any node with the same key\n+  \/\/ For all nodes with key < old_node, must also have key < new_node\n+  \/\/ For all nodes with key > old_node, must also have key > new_node\n+  void replace_at_cursor(RBNode* new_node, const Cursor& cursor);\n+\n+  \/\/ Finds the value of the node associated with the given key.\n+  V* find(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.found() ? &cursor.node()->_value : nullptr;\n+  }\n+\n+  V* find(const K& key) const {\n+    const Cursor cursor = cursor_find(key);\n+    return cursor.found() ? &cursor.node()->_value : nullptr;\n+  }\n+\n+  \/\/ Finds the node associated with the given key.\n+  RBNode* find_node(const K& key) const {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.node();\n+  }\n+\n+  RBNode* find_node(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.node();\n+  }\n@@ -164,2 +247,9 @@\n-    RBNode* node = insert_node(key, val);\n-    fix_insert_violations(node);\n+    Cursor cursor = cursor_find(key);\n+    RBNode* node = cursor.node();\n+    if (node != nullptr) {\n+      node->_value = val;\n+      return;\n+    }\n+\n+    node = allocate_node(key, val);\n+    insert_at_cursor(node, cursor);\n@@ -171,2 +261,2 @@\n-    RBNode* node = find_node(key);\n-    if (node == nullptr){\n+    Cursor cursor = cursor_find(key);\n+    if (!cursor.found()) {\n@@ -175,1 +265,3 @@\n-    remove(node);\n+    RBNode* node = cursor.node();\n+    remove_at_cursor(cursor);\n+    free_node(node);\n@@ -179,2 +271,5 @@\n-  \/\/ Removes the given node from the tree. node must be a valid node\n-  void remove(RBNode* node);\n+  void remove(RBNode* node) {\n+    Cursor cursor = get_cursor(node);\n+    remove_at_cursor(cursor);\n+    free_node(node);\n+  }\n@@ -197,0 +292,1 @@\n+    _first = nullptr;\n@@ -200,56 +296,3 @@\n-  const RBNode* closest_leq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r < 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_right;\n-      } else {\n-        pos = pos->_left;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  \/\/ Finds the node with the closest key > the given key\n-  const RBNode* closest_gt(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  \/\/ Finds the node with the closest key >= the given key\n-  const RBNode* closest_geq(const K& key) const {\n-    RBNode* candidate = nullptr;\n-    RBNode* pos = _root;\n-    while (pos != nullptr) {\n-      const int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n+  RBNode* closest_leq(const K& key) const {\n+    Cursor cursor = cursor_find(key);\n+    return cursor.found() ? cursor.node() : prev(cursor).node();\n@@ -259,2 +302,2 @@\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_leq(key));\n+    Cursor cursor = cursor_find(key);\n+    return cursor.found() ? cursor.node() : prev(cursor).node();\n@@ -263,3 +306,4 @@\n-  RBNode* closest_gt(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_gt(key));\n+  \/\/ Finds the node with the closest key > the given key\n+  RBNode* closest_gt(const K& key) const {\n+    Cursor cursor = cursor_find(key);\n+    return next(cursor).node();\n@@ -268,3 +312,3 @@\n-  RBNode* closest_geq(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->closest_geq(key));\n+  RBNode* closest_gt(const K& key) {\n+    Cursor cursor = cursor_find(key);\n+    return next(cursor).node();\n@@ -289,19 +333,0 @@\n-  \/\/ Finds the node associated with the key\n-  const RBNode* find_node(const K& key) const;\n-\n-  RBNode* find_node(const K& key) {\n-    return const_cast<RBNode*>(\n-        static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->find_node(key));\n-  }\n-\n-  \/\/ Finds the value associated with the key\n-  V* find(const K& key) {\n-    RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n-  const V* find(const K& key) const {\n-    const RBNode* node = find_node(key);\n-    return node == nullptr ? nullptr : &node->val();\n-  }\n-\n@@ -314,1 +339,1 @@\n-  void visit_range_in_order(const K& from, const K& to, F f);\n+  void visit_range_in_order(const K& from, const K& to, F f) const;\n@@ -338,0 +363,12 @@\n+class RBTreeNoopAllocator {\n+public:\n+  void* allocate(size_t sz) {\n+    assert(false, \"intrusive tree should not use rbtree allocator\");\n+    return nullptr;\n+  }\n+\n+  void free(void* ptr) {\n+    assert(false, \"intrusive tree should not use rbtree allocator\");\n+  }\n+};\n+\n@@ -341,0 +378,3 @@\n+template <typename K, typename COMPARATOR>\n+using IntrusiveRBTree = RBTree<K, Empty, COMPARATOR, RBTreeNoopAllocator>;\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":148,"deletions":108,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -189,5 +189,4 @@\n-inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::find_node(const K& key) const {\n-  RBNode* curr = _root;\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->get_cursor(node);\n+}\n@@ -195,7 +194,9 @@\n-    if (key_cmp_k == 0) {\n-      return curr;\n-    } else if (key_cmp_k < 0) {\n-      curr = curr->_left;\n-    } else {\n-      curr = curr->_right;\n-    }\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::get_cursor(RBNode* node) const {\n+  if (node == nullptr) {\n+    return Cursor();\n+  }\n+\n+  if (node->parent() == nullptr) {\n+    return Cursor(&_root, nullptr);\n@@ -204,1 +205,4 @@\n-  return nullptr;\n+  RBNode* parent = node->parent();\n+  RBNode** insert_location =\n+      node->is_left_child() ? &parent->_left : &parent->_right;\n+  return Cursor(insert_location, parent);\n@@ -208,6 +212,19 @@\n-inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::RBNode*\n-RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_node(const K& key, const V& val) {\n-  RBNode* curr = _root;\n-  if (curr == nullptr) { \/\/ Tree is empty\n-    _root = allocate_node(key, val);\n-    return _root;\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->next(cursor);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::next(const Cursor& cursor) const {\n+  if (cursor.found()) {\n+    return get_cursor(cursor.node()->next());\n+  }\n+\n+  if (cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&cursor._parent->_left == cursor._insert_location) { \/\/ Left child, parent is next\n+    return get_cursor(cursor._parent);\n@@ -216,0 +233,37 @@\n+  return get_cursor(cursor._parent->next()); \/\/ Right child, parent's next is also node's next\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->prev(cursor);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::prev(const Cursor& cursor) const {\n+  if (cursor.found()) {\n+    return get_cursor(cursor.node()->prev());\n+  }\n+\n+  if (cursor._parent == nullptr) { \/\/ Tree is empty\n+    return Cursor();\n+  }\n+\n+  \/\/ Pointing to non-existant node\n+  if (&cursor._parent->_right == cursor._insert_location) { \/\/ Right child, parent is prev\n+    return get_cursor(cursor._parent);\n+  }\n+\n+  return get_cursor(cursor._parent->prev()); \/\/ Left child, parent's prev is also node's prev\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor_find(const K& key) {\n+  return static_cast<const RBTree<K, V, COMPARATOR, ALLOCATOR>*>(this)->cursor_find(key);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline const typename RBTree<K, V, COMPARATOR, ALLOCATOR>::Cursor\n+RBTree<K, V, COMPARATOR, ALLOCATOR>::cursor_find(const K& key) const {\n@@ -217,2 +271,3 @@\n-  while (curr != nullptr) {\n-    const int key_cmp_k = COMPARATOR::cmp(key, curr->key());\n+  RBNode* const* insert_location = &_root;\n+  while (*insert_location != nullptr) {\n+    const int key_cmp_k = COMPARATOR::cmp(key, (*insert_location)->key());\n@@ -221,2 +276,1 @@\n-      curr->_value = val;\n-      return curr;\n+      break;\n@@ -225,1 +279,1 @@\n-    parent = curr;\n+    parent = *insert_location;\n@@ -227,0 +281,45 @@\n+      insert_location = &((*insert_location)->_left);\n+    } else {\n+      insert_location = &((*insert_location)->_right);\n+    }\n+  }\n+  return Cursor(insert_location, parent);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::insert_at_cursor(RBNode* node, const Cursor& cursor) {\n+  assert(cursor.valid() && !cursor.found(), \"must be\");\n+  _num_nodes++;\n+\n+  if (_first == nullptr || cursor._insert_location == &_first->_left) {\n+    _first = node;\n+  }\n+\n+  node->set_parent(cursor._parent);\n+  *cursor._insert_location = node;\n+\n+#ifdef ASSERT\n+  node->_visited = _expected_visited;\n+#endif \/\/ ASSERT\n+\n+  if (cursor._parent == nullptr) {\n+    return;\n+  }\n+\n+  fix_insert_violations(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_at_cursor(const Cursor& cursor) {\n+  assert(cursor.valid() && cursor.found(), \"must be\");\n+  _num_nodes--;\n+\n+  RBNode* node = cursor.node();\n+  if (node == _first) {\n+    _first = node->next();\n+  }\n+\n+  if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n+    \/\/ Swap place with the in-order successor and delete there instead\n+    RBNode* curr = node->_right;\n+    while (curr->_left != nullptr) {\n@@ -228,0 +327,12 @@\n+    }\n+\n+    if (_root == node) _root = curr;\n+\n+    swap(curr->_left, node->_left);\n+    swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n+\n+    \/\/ If node is curr's parent, parent and right pointers become invalid\n+    if (node->_right == curr) {\n+      node->_right = curr->_right;\n+      node->set_parent(curr);\n+      curr->_right = node;\n@@ -229,1 +340,3 @@\n-      curr = curr->_right;\n+      swap(curr->_right, node->_right);\n+      node->parent()->replace_child(curr, node);\n+      curr->_right->set_parent(curr);\n@@ -231,0 +344,18 @@\n+\n+    if (curr->parent() != nullptr) curr->parent()->replace_child(node, curr);\n+    curr->_left->set_parent(curr);\n+\n+\n+    if (node->_left != nullptr) node->_left->set_parent(node);\n+    if (node->_right != nullptr) node->_right->set_parent(node);\n+  }\n+\n+  remove_from_tree(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::replace_at_cursor(RBNode* new_node, const Cursor& cursor) {\n+  assert(cursor.valid() && cursor.found(), \"must be\");\n+  RBNode* old_node = cursor.node();\n+  if (old_node == new_node) {\n+    return;\n@@ -233,3 +364,12 @@\n-  \/\/ Create and insert new node\n-  RBNode* node = allocate_node(key, val);\n-  node->set_parent(parent);\n+  *cursor._insert_location = new_node;\n+  new_node->set_parent(cursor._parent);\n+  new_node->_color = old_node->_color;\n+\n+  new_node->_left = old_node->_left;\n+  new_node->_right = old_node->_right;\n+  if (new_node->_left != nullptr) {\n+    new_node->_left->set_parent(new_node);\n+  } else if (new_node->_right != nullptr) {\n+    new_node->_right->_parent = new_node;\n+    new_node->_right->set_parent(new_node);\n+  }\n@@ -237,5 +377,2 @@\n-  const int key_cmp_k = COMPARATOR::cmp(key, parent->key());\n-  if (key_cmp_k < 0) {\n-    parent->_left = node;\n-  } else {\n-    parent->_right = node;\n+  if (old_node == _first) {\n+    _first = new_node;\n@@ -244,1 +381,5 @@\n-  return node;\n+  free_node(old_node);\n+\n+#ifdef ASSERT\n+  verify_self(); \/\/ Dangerous operation, should verify no tree properties were broken\n+#endif \/\/ ASSERT\n@@ -440,39 +581,0 @@\n-template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode* node) {\n-  assert(node != nullptr, \"must be\");\n-\n-  if (node->_left != nullptr && node->_right != nullptr) { \/\/ node has two children\n-    \/\/ Swap place with the in-order successor and delete there instead\n-    RBNode* curr = node->_right;\n-    while (curr->_left != nullptr) {\n-      curr = curr->_left;\n-    }\n-\n-    if (_root == node) _root = curr;\n-\n-    swap(curr->_left, node->_left);\n-    swap(curr->_parent, node->_parent); \/\/ Swaps parent and color\n-\n-    \/\/ If node is curr's parent, parent and right pointers become invalid\n-    if (node->_right == curr) {\n-      node->_right = curr->_right;\n-      node->set_parent(curr);\n-      curr->_right = node;\n-    } else {\n-      swap(curr->_right, node->_right);\n-      node->parent()->replace_child(curr, node);\n-      curr->_right->set_parent(curr);\n-    }\n-\n-    if (curr->parent() != nullptr) curr->parent()->replace_child(node, curr);\n-    curr->_left->set_parent(curr);\n-\n-\n-    if (node->_left != nullptr) node->_left->set_parent(node);\n-    if (node->_right != nullptr) node->_right->set_parent(node);\n-  }\n-\n-  remove_from_tree(node);\n-  free_node(node);\n-}\n-\n@@ -482,11 +584,4 @@\n-  RBNode* to_visit[64];\n-  int stack_idx = 0;\n-  RBNode* head = _root;\n-  while (stack_idx > 0 || head != nullptr) {\n-    while (head != nullptr) {\n-      to_visit[stack_idx++] = head;\n-      head = head->_left;\n-    }\n-    head = to_visit[--stack_idx];\n-    f(head);\n-    head = head->_right;\n+  RBNode* node = _first;\n+  while (node != nullptr) {\n+    f(node);\n+    node = node->next();\n@@ -498,1 +593,1 @@\n-inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) {\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::visit_range_in_order(const K& from, const K& to, F f) const {\n@@ -500,3 +595,8 @@\n-  RBNode* curr = closest_geq(from);\n-  if (curr == nullptr) return;\n-  RBNode* end = closest_geq(to);\n+  if (_root == nullptr) {\n+    return;\n+  }\n+\n+  Cursor cursor_start = cursor_find(from);\n+  Cursor cursor_end = cursor_find(to);\n+  RBNode* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  RBNode* end = cursor_end.found() ? cursor_end.node() : next(cursor_end).node();\n@@ -504,3 +604,3 @@\n-  while (curr != nullptr && curr != end) {\n-    f(curr);\n-    curr = curr->next();\n+  while (start != end) {\n+    f(start);\n+    start = start->next();\n@@ -514,1 +614,1 @@\n-    assert(_num_nodes == 0, \"rbtree has nodes but no root\");\n+    assert(_num_nodes == 0, \"rbtree has %zu nodes but no root\", _num_nodes);\n@@ -536,2 +636,2 @@\n-         \"unexpected number of nodes in rbtree. expected: %zu\"\n-         \", actual: %zu\", size(), num_nodes);\n+         \"unexpected number of nodes in rbtree. expected: %zu,\"\n+         \"actual: %zu\", size(), num_nodes);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":194,"deletions":94,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -301,0 +301,71 @@\n+  void test_closest_gt() {\n+    using Node = RBTreeInt::RBNode;\n+    {\n+      RBTreeInt rbtree;\n+      Node* n = rbtree.closest_gt(0);\n+      EXPECT_EQ(nullptr, n);\n+\n+      rbtree.upsert(0, 0);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      rbtree.upsert(-5, -5);\n+      n = rbtree.closest_gt(-1);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-5);\n+      EXPECT_EQ(0, n->key());\n+\n+      n = rbtree.closest_gt(-10);\n+      EXPECT_EQ(-5, n->key());\n+\n+      rbtree.upsert(10, 10);\n+      n = rbtree.closest_gt(5);\n+      EXPECT_EQ(10, n->key());\n+\n+      n = rbtree.closest_gt(10);\n+      EXPECT_EQ(nullptr, n);\n+    }\n+  }\n+\n+  void test_first() {\n+    using Node = RBTreeInt::RBNode;\n+\n+    RBTreeInt rbtree;\n+    Node* n = rbtree.first();\n+    EXPECT_EQ(nullptr, n);\n+\n+    rbtree.upsert(0, 0);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(2, 2);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(1, 1);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.upsert(-1, -1);\n+    n = rbtree.first();\n+    EXPECT_EQ(-1, n->key());\n+\n+    rbtree.remove(-1);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(1);\n+    n = rbtree.first();\n+    EXPECT_EQ(0, n->key());\n+\n+    rbtree.remove(0);\n+    n = rbtree.first();\n+    EXPECT_EQ(2, n->key());\n+\n+    rbtree.remove(2);\n+    n = rbtree.first();\n+    EXPECT_EQ(nullptr, n);\n+\n+  }\n+\n@@ -389,3 +460,38 @@\n-    rbtree.visit_in_order([&](Node* node) {\n-      EXPECT_EQ(node, node->val());\n-    });\n+    \/\/ rbtree.visit_in_order([&](Node* node) {\n+    \/\/   EXPECT_EQ(node, node->val());\n+    \/\/ });\n+  }\n+\n+  void test_cursor_empty_tree() {\n+    RBTreeInt tree;\n+    RBTreeInt::Cursor cursor = tree.get_cursor(tree.first());\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor_find(0);\n+    EXPECT_TRUE(cursor.valid());\n+    EXPECT_FALSE(cursor.found());\n+    EXPECT_FALSE(tree.next(cursor).valid());\n+  }\n+\n+  void test_cursor_iterate() {\n+    constexpr const int num_nodes = 100;\n+    RBTreeInt tree;\n+    for (int n = 0; n <= num_nodes; n++) {\n+      tree.upsert(n, n);\n+    }\n+\n+    RBTreeInt::Cursor cursor = tree.cursor_find(0);\n+    for (int n = 0; n <= num_nodes; n++) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.next(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n+\n+    cursor = tree.cursor_find(num_nodes);\n+    for (int n = num_nodes; n >= 0; n--) {\n+      EXPECT_TRUE(cursor.valid());\n+      EXPECT_EQ(cursor.node()->val(), n);\n+      cursor = tree.prev(cursor);\n+    }\n+    EXPECT_FALSE(cursor.valid());\n@@ -441,0 +547,62 @@\n+  void test_intrusive() {\n+    using Tree = IntrusiveRBTree<int, Cmp>;\n+    using Node = Tree::RBNode;\n+\n+    struct IntrusiveHolder {\n+      Node node;\n+      int data;\n+\n+      Node* get_node() { return &node; }\n+\n+      IntrusiveHolder(int data, Node node) : node(node), data(data) {}\n+      static IntrusiveHolder* cast_to_self(Node* node) { return (IntrusiveHolder*)node; }\n+    };\n+\n+    Tree intrusive_tree;\n+    int num_iterations = 100;\n+\n+    \/\/ Insert values\n+    for (int n = 0; n < num_iterations; n++) {\n+      Tree::Cursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NULL(cursor.node());\n+\n+      \/\/ Custom allocation here is just malloc\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n, Node(n));\n+\n+      intrusive_tree.insert_at_cursor(place->get_node(), cursor);\n+      Tree::Cursor cursor2 = intrusive_tree.cursor_find(n);\n+\n+      EXPECT_NOT_NULL(cursor2.node());\n+\n+      verify_it(intrusive_tree);\n+    }\n+\n+    \/\/ Check inserted values\n+    for (int n = 0; n < num_iterations; n++) {\n+      Tree::Cursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+      EXPECT_EQ(n, IntrusiveHolder::cast_to_self(cursor.node())->data);\n+    }\n+\n+    \/\/ Remove all values\n+    for (int n = 0; n < num_iterations; n++) {\n+      Tree::Cursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NOT_NULL(cursor.node());\n+\n+      intrusive_tree.remove_at_cursor(cursor);\n+      Tree::Cursor cursor2 = intrusive_tree.cursor_find(n);\n+\n+      EXPECT_NULL(cursor2.node());\n+\n+      verify_it(intrusive_tree);\n+    }\n+\n+    \/\/ Check removed values\n+    for (int n = 0; n < num_iterations; n++) {\n+      Tree::Cursor cursor = intrusive_tree.cursor_find(n);\n+      EXPECT_NULL(cursor.node());\n+\n+    }\n+  }\n+\n@@ -494,0 +662,8 @@\n+TEST_VM_F(RBTreeTest, TestClosestGt) {\n+  this->test_closest_gt();\n+}\n+\n+TEST_VM_F(RBTreeTest, TestFirst) {\n+  this->test_first();\n+}\n+\n@@ -510,0 +686,8 @@\n+TEST_VM_F(RBTreeTest, CursorEmptyTreeTest) {\n+  this->test_cursor_empty_tree();\n+}\n+\n+TEST_VM_F(RBTreeTest, CursorIterateTest) {\n+  this->test_cursor_iterate();\n+}\n+\n@@ -511,0 +695,4 @@\n+TEST_VM_F(RBTreeTest, IntrusiveTest) {\n+  this->test_intrusive();\n+}\n+\n@@ -563,1 +751,1 @@\n-    struct Nothing {};\n+  struct Nothing {};\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":192,"deletions":4,"binary":false,"changes":196,"status":"modified"}]}