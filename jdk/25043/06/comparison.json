{"files":[{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * An internal utility class that can be used to adapt system-call-styled method handles\n+ * for efficient and easy use.\n+ *\/\n+public final class CaptureStateUtil {\n+\n+    private static final StructLayout CAPTURE_LAYOUT = Linker.Option.captureStateLayout();\n+    private static final BufferStack POOL = BufferStack.of(CAPTURE_LAYOUT);\n+\n+    \/\/ Do not use a lambda in order to allow early use in the init sequence\n+    private static final Function<BasicKey, MethodHandle> UNDERLYING_MAKE_BASIC_HANDLE = new Function<>() {\n+        @Override\n+        public MethodHandle apply(BasicKey basicKey) {\n+            return makeBasicHandle(basicKey);\n+        }\n+    };\n+\n+    \/\/ The `BASIC_HANDLE_CACHE` contains the common \"basic handles\" that can be reused for\n+    \/\/ all adapted method handles. Keeping as much as possible reusable reduces the number\n+    \/\/ of combinators needed to form an adapted method handle.\n+    \/\/ The function is lazily computed.\n+    \/\/\n+    private static final Function<BasicKey, MethodHandle> BASIC_HANDLE_CACHE;\n+\n+    static {\n+        final Set<BasicKey> inputs = new HashSet<>();\n+        \/\/ The Cartesian product : (int.class, long.class) x (\"errno\", ...)\n+        \/\/ Do not use Streams in order to enable \"early\" use in the init sequence.\n+        for (Class<?> c : new Class<?>[]{int.class, long.class}) {\n+            for (MemoryLayout layout : CAPTURE_LAYOUT.memberLayouts()) {\n+                inputs.add(new BasicKey(c, layout.name().orElseThrow()));\n+            }\n+        }\n+        BASIC_HANDLE_CACHE = StableValue.function(inputs, UNDERLYING_MAKE_BASIC_HANDLE);\n+    }\n+\n+    \/\/ A key that holds both the `returnType` and the `stateName` needed to look up a\n+    \/\/ specific \"basic handle\" in the `BASIC_HANDLE_CACHE`.\n+    \/\/   returnType in {int.class | long.class}\n+    \/\/   stateName can be anything non-null but should be in {\"GetLastError\" | \"WSAGetLastError\" | \"errno\"}\n+    private record BasicKey(Class<?> returnType, String stateName) {\n+\n+        BasicKey(MethodHandle target, String stateName) {\n+            this(returnType(target), Objects.requireNonNull(stateName));\n+        }\n+\n+        static Class<?> returnType(MethodHandle target) {\n+            \/\/ Implicit null check\n+            final MethodType type = target.type();\n+            final Class<?> returnType = type.returnType();\n+\n+            if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n+                throw illegalArgDoesNot(target, \"return an int or a long\");\n+            }\n+            if (type.parameterCount() == 0 || type.parameterType(0) != MemorySegment.class) {\n+                throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n+            }\n+            return returnType;\n+        }\n+\n+        private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+            return new IllegalArgumentException(\"The provided target \" + target\n+                    + \" does not \" + info);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return returnType.hashCode() ^ stateName.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof BasicKey(Class<?> oReturnType, String oStateName)\n+                    && returnType.equals(oReturnType)\n+                    && stateName.equals(oStateName);\n+        }\n+    }\n+\n+    private CaptureStateUtil() {}\n+\n+    \/**\n+     * {@return a new MethodHandle that adapts the provided {@code target} so that it\n+     * directly returns the same value as the {@code target} if it is non-negative,\n+     * otherwise returns the negated captured state defined by the provided\n+     * {@code stateName}}\n+     * <p>\n+     * This method is suitable for adapting system-call method handles(e.g.\n+     * {@code open()}, {@code read()}, and {@code close()}). Clients can check the return\n+     * value as shown in this example:\n+     * {@snippet lang = java:\n+     *       \/\/ (MemorySegment capture, MemorySegment pathname, int flags)int\n+     *       static final MethodHandle CAPTURING_OPEN = ...\n+     *\n+     *      \/\/ (MemorySegment pathname, int flags)int\n+     *      static final MethodHandle OPEN = CaptureStateUtil\n+     *             .adaptSystemCall(CAPTURING_OPEN, \"errno\");\n+     *\n+     *      try {\n+     *         int fh = (int)OPEN.invokeExact(pathName, flags);\n+     *         if (fh < 0) {\n+     *             throw new IOException(\"Error opening file: errno = \" + (-fh));\n+     *         }\n+     *         processFile(fh);\n+     *      } catch (Throwable t) {\n+     *           throw new RuntimeException(t);\n+     *      }\n+     *\n+     *}\n+     *\n+     * For a {@code target} method handle that takes a {@code MemorySegment} and two\n+     * {@code int} parameters and returns an {@code int} value, the method returns a new\n+     * method handle that is doing the equivalent of:\n+     * <p>\n+     * {@snippet lang = java:\n+     *         private static final MemoryLayout CAPTURE_LAYOUT =\n+     *                 Linker.Option.captureStateLayout();\n+     *         private static final BufferStack POOL =\n+     *                 BufferStack.of(CAPTURE_LAYOUT);\n+     *\n+     *         public int invoke(MethodHandle target,\n+     *                           String stateName,\n+     *                           int a, int b) {\n+     *             try (var arena = POOL.pushFrame(CAPTURE_LAYOUT)) {\n+     *                 final MemorySegment segment = arena.allocate(CAPTURE_LAYOUT);\n+     *                 final int result = (int) handle.invoke(segment, a, b);\n+     *                 if (result >= 0) {\n+     *                     return result;\n+     *                 }\n+     *                 return -(int) CAPTURE_LAYOUT\n+     *                     .varHandle(MemoryLayout.PathElement.groupElement(stateName))\n+     *                         .get(segment, 0);\n+     *             }\n+     *         }\n+     *}\n+     * except it is more performant. In the above {@code stateName} is the name of the\n+     * captured state (e.g. {@code errno}). The static {@code CAPTURE_LAYOUT} is shared\n+     * across all target method handles adapted by this method.\n+     *\n+     * @param target    method handle that returns an {@code int} or a {@code long} and\n+     *                  has a capturing state MemorySegment as its first parameter\n+     * @param stateName the name of the capturing state member layout (i.e. \"errno\",\n+     *                  \"GetLastError\", or \"WSAGetLastError\")\n+     * @throws IllegalArgumentException if the provided {@code target}'s return type is\n+     *                                  not {@code int} or {@code long}\n+     * @throws IllegalArgumentException if the provided {@code target}'s first parameter\n+     *                                  type is not {@linkplain MemorySegment}\n+     * @throws IllegalArgumentException if the provided {@code stateName} is unknown on\n+     *                                  the current platform\n+     *\/\n+    public static MethodHandle adaptSystemCall(MethodHandle target,\n+                                               String stateName) {\n+        \/\/ Invariants checked in the BasicKey record\n+        final BasicKey basicKey = new BasicKey(target, stateName);\n+\n+        \/\/ ((int | long), MemorySegment)(int | long)\n+        final MethodHandle basicHandle = BASIC_HANDLE_CACHE.apply(basicKey);\n+\n+        \/\/ Make `target` specific adaptations of the basic handle\n+\n+        \/\/ Pre-pend all the parameters from the `target` MH.\n+        \/\/ (C0=MemorySegment, C1-Cn, MemorySegment)(int|long)\n+        MethodHandle innerAdapted = MethodHandles.collectArguments(basicHandle, 0, target);\n+\n+        final int[] perm = new int[target.type().parameterCount() + 1];\n+        for (int i = 0; i < target.type().parameterCount(); i++) {\n+            perm[i] = i;\n+        }\n+        \/\/ Last takes first\n+        perm[perm.length - 1] = 0;\n+        \/\/ Deduplicate the first and last coordinate and only use the first one.\n+        \/\/ (C0=MemorySegment, C1-Cn)(int|long)\n+        innerAdapted = MethodHandles.permuteArguments(innerAdapted, target.type(), perm);\n+\n+        \/\/ Use an `Arena` for the first argument instead and extract a segment from it.\n+        \/\/ (C0=Arena, C1-Cn)(int|long)\n+        innerAdapted = MethodHandles.collectArguments(innerAdapted, 0, HANDLES_CACHE.apply(ALLOCATE));\n+\n+        \/\/ Add an identity function for the result of the cleanup action.\n+        \/\/ ((int|long))(int|long)\n+        MethodHandle cleanup = MethodHandles.identity(basicKey.returnType());\n+        \/\/ Add a dummy `Throwable` argument for the cleanup action.\n+        \/\/ This means, anything thrown will just be propagated.\n+        \/\/ (Throwable, (int|long))(int|long)\n+        cleanup = MethodHandles.dropArguments(cleanup, 0, Throwable.class);\n+        \/\/ Add the first `Arena` parameter of the `innerAdapted` method handle to the\n+        \/\/ cleanup action and invoke `Arena::close` when it is run. The `cleanup` handle\n+        \/\/ does not have to have all parameters. It can have zero or more.\n+        \/\/ (Throwable, (int|long), Arena)(int|long)\n+        cleanup = MethodHandles.collectArguments(cleanup, 2, HANDLES_CACHE.apply(ARENA_CLOSE));\n+\n+        \/\/ Combine the `innerAdapted` and `cleanup` action into a try\/finally block.\n+        \/\/ (Arena, C1-Cn)(int|long)\n+        final MethodHandle tryFinally = MethodHandles.tryFinally(innerAdapted, cleanup);\n+\n+        \/\/ Acquire the arena from the global pool.\n+        \/\/ With this, we finally arrive at the intended method handle:\n+        \/\/ (C1-Cn)(int|long)\n+        return MethodHandles.collectArguments(tryFinally, 0, HANDLES_CACHE.apply(ACQUIRE_ARENA));\n+    }\n+\n+    private static MethodHandle makeBasicHandle(BasicKey basicKey) {\n+        final VarHandle vh = CAPTURE_LAYOUT.varHandle(\n+                MemoryLayout.PathElement.groupElement(basicKey.stateName()));\n+        \/\/ This MH is used to extract the named captured state\n+        \/\/ from the capturing `MemorySegment`.\n+        \/\/ (MemorySegment, long)int\n+        MethodHandle intExtractor = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+        \/\/ As the MH is already adapted to use the appropriate\n+        \/\/ offset, we just insert `0L` for the offset.\n+        \/\/ (MemorySegment)int\n+        intExtractor = MethodHandles.insertArguments(intExtractor, 1, 0L);\n+\n+        \/\/ If X is the `returnType` (either `int` or `long`) then\n+        \/\/ the code below is equivalent to:\n+        \/\/\n+        \/\/ X handle(X returnValue, MemorySegment segment)\n+        \/\/     if (returnValue >= 0) {\n+        \/\/         \/\/ Ignore the segment\n+        \/\/         return returnValue;\n+        \/\/     } else {\n+        \/\/         \/\/ ignore the returnValue\n+        \/\/         return -(X)intExtractor.invokeExact(segment);\n+        \/\/     }\n+        \/\/ }\n+        if (basicKey.returnType().equals(int.class)) {\n+            \/\/ (int, MemorySegment)int\n+            return MethodHandles.guardWithTest(\n+                    HANDLES_CACHE.apply(NON_NEGATIVE_INT),\n+                    HANDLES_CACHE.apply(SUCCESS_INT),\n+                    HANDLES_CACHE.apply(ERROR_INT).bindTo(intExtractor));\n+        } else {\n+            \/\/ (long, MemorySegment)long\n+            return MethodHandles.guardWithTest(\n+                    HANDLES_CACHE.apply(NON_NEGATIVE_LONG),\n+                    HANDLES_CACHE.apply(SUCCESS_LONG),\n+                    HANDLES_CACHE.apply(ERROR_LONG).bindTo(intExtractor));\n+        }\n+    }\n+\n+    \/\/ The methods below are reflective used via static MethodHandles\n+\n+    @ForceInline\n+    private static Arena acquireArena() {\n+        return POOL.pushFrame(CAPTURE_LAYOUT);\n+    }\n+\n+    @ForceInline\n+    private static MemorySegment allocate(Arena arena) {\n+        \/\/ We do not need to zero out the segment.\n+        return ((NoInitSegmentAllocator) arena)\n+                .allocateNoInit(CAPTURE_LAYOUT.byteSize(), CAPTURE_LAYOUT.byteAlignment());\n+    }\n+\n+    @ForceInline\n+    private static boolean nonNegative(int value) {\n+        return value >= 0;\n+    }\n+\n+    @ForceInline\n+    private static int success(int value,\n+                               MemorySegment segment) {\n+        return value;\n+    }\n+\n+    @ForceInline\n+    private static int error(MethodHandle errorHandle,\n+                             int value,\n+                             MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+    @ForceInline\n+    private static boolean nonNegative(long value) {\n+        return value >= 0L;\n+    }\n+\n+    @ForceInline\n+    private static long success(long value,\n+                                MemorySegment segment) {\n+        return value;\n+    }\n+\n+    @ForceInline\n+    private static long error(MethodHandle errorHandle,\n+                              long value,\n+                              MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+    \/\/ The method handles below are bound to static methods residing in this class\n+\n+    private static final int\n+            NON_NEGATIVE_INT  = 0,\n+            SUCCESS_INT       = 1,\n+            ERROR_INT         = 2,\n+            NON_NEGATIVE_LONG = 3,\n+            SUCCESS_LONG      = 4,\n+            ERROR_LONG        = 5,\n+            ACQUIRE_ARENA     = 6,\n+            ALLOCATE          = 7,\n+            ARENA_CLOSE       = 8;\n+\n+    \/\/ Do not use a lambda in order to allow early use in the init sequence\n+    private static final IntFunction<MethodHandle> UNDERLYING_MAKE_HANDLE = new IntFunction<MethodHandle>() {\n+        @Override\n+        public MethodHandle apply(int value) {\n+            return makeHandle(value);\n+        }\n+    };\n+\n+    private static final IntFunction<MethodHandle> HANDLES_CACHE =\n+            StableValue.intFunction(ARENA_CLOSE + 1, UNDERLYING_MAKE_HANDLE);\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private static MethodHandle makeHandle(int index) {\n+        return switch (index) {\n+            case NON_NEGATIVE_INT -> MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, int.class));\n+            case SUCCESS_INT -> MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(int.class, int.class, MemorySegment.class));\n+            case ERROR_INT -> MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(int.class, MethodHandle.class, int.class, MemorySegment.class));\n+            case NON_NEGATIVE_LONG -> MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, long.class));\n+            case SUCCESS_LONG -> MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(long.class, long.class, MemorySegment.class));\n+            case ERROR_LONG -> MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(long.class, MethodHandle.class, long.class, MemorySegment.class));\n+            case ACQUIRE_ARENA -> MhUtil.findStatic(LOOKUP, \"acquireArena\",\n+                    MethodType.methodType(Arena.class));\n+            case ALLOCATE -> MhUtil.findStatic(LOOKUP, \"allocate\",\n+                    MethodType.methodType(MemorySegment.class, Arena.class));\n+            case ARENA_CLOSE -> MhUtil.findVirtual(LOOKUP, Arena.class, \"close\",\n+                    MethodType.methodType(void.class));\n+            default -> throw new InternalError(\"Unknown index: \" + index);\n+        };\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.SegmentAllocator;\n+\n+public interface NoInitSegmentAllocator extends SegmentAllocator {\n+\n+    NativeMemorySegmentImpl allocateNoInit(long byteSize, long byteAlignment);\n+\n+    @ForceInline\n+    @Override\n+    default NativeMemorySegmentImpl allocate(long byteSize, long byteAlignment) {\n+        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n+        segment.fill((byte)0);\n+        return segment;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NoInitSegmentAllocator.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-    private static final long SMALL_ALLOC_SIZE = 8;\n+    private static final long SMALL_ALLOC_SIZE = JAVA_LONG.byteSize();\n@@ -270,0 +270,8 @@\n+    @Test\n+    void noInit() {\n+        BufferStack stack = newBufferStack();\n+        try (var arena = stack.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            assertDoesNotThrow(() -> arena.allocateFrom(JAVA_INT, 1));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test CaptureStateUtil\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCaptureStateUtil\n+ *\/\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCaptureStateUtil {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final MethodHandle INT_DUMMY_HANDLE;\n+    private static final MethodHandle LONG_DUMMY_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            LONG_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final MethodHandle ADAPTED_INT = CaptureStateUtil\n+            .adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+    private static final MethodHandle ADAPTED_LONG = CaptureStateUtil\n+            .adaptSystemCall(LONG_DUMMY_HANDLE, ERRNO_NAME);\n+\n+    @Test\n+    void successfulInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    private static final int EACCES = 13; \/* Permission denied *\/\n+\n+    @Test\n+    void errorInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(1L, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void errorLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(-1L, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulIntPerHandle() throws Throwable {\n+        MethodHandle handle = CaptureStateUtil\n+                .adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+        int r = (int) handle.invokeExact(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void invariants() throws Throwable {\n+        MethodHandle noSegment = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(long.class, long.class, int.class));\n+\n+        var noSegEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, ERRNO_NAME));\n+        assertTrue(noSegEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle noArgMH = MethodHandles.empty(MethodType.methodType(int.class));\n+        var emptyEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noArgMH, ERRNO_NAME));\n+        assertTrue(emptyEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle wrongReturnType = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(short.class, MemorySegment.class, long.class, int.class));\n+\n+        var wrongRetEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(wrongReturnType, ERRNO_NAME));\n+        assertTrue(wrongRetEx.getMessage().contains(\"does not return an int or a long\"));\n+\n+        var wrongCaptureName = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, \"foo\"));\n+        assertEquals(\"Input not allowed: BasicKey[returnType=long, stateName=foo]\", wrongCaptureName.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(null, ERRNO_NAME));\n+        assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static long dummy(MemorySegment segment, long result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    private static long wrongType(long result, int errno) {\n+        return 0;\n+    }\n+\n+    private static short wrongType(MemorySegment segment, long result, int errno) {\n+        return 0;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class CaptureStateUtilBench {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final MethodHandle DUMMY_EXPLICIT_ALLOC = dummyExplicitAlloc();\n+    private static final MethodHandle DUMMY_TL_ALLOC = dummyTlAlloc();\n+\n+    @Benchmark\n+    public int explicitAllocationSuccess() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int explicitAllocationFail() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int adaptedSysCallSuccess() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact(0, 0);\n+    }\n+\n+    @Benchmark\n+    public int adaptedSysCallFail() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact( -1, 1);\n+    }\n+\n+    private static MethodHandle dummyExplicitAlloc() {\n+        try {\n+            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class,\n+                    \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    private static MethodHandle dummyTlAlloc() {\n+        final MethodHandle handle = dummyExplicitAlloc();\n+        return CaptureStateUtil.adaptSystemCall(handle, ERRNO_NAME);\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        if (errno != 0) {\n+            \/\/ Assuming the capture state is only modified upon detecting an error.\n+            ERRNO_HANDLE.set(segment, 0, errno);\n+        }\n+        return result;\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends CaptureStateUtilBench {}\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}