{"files":[{"patch":"@@ -241,5 +241,0 @@\n- * This is done by replacing the '+' delimiter with a '\/'\n- * in a copy of the already mangled hidden class name.\n- *\n- * \"java.lang.invoke.LambdaForm$DMH+0x0000000037144c00\"\n- *  becomes\n@@ -250,17 +245,0 @@\n-static const char* create_hidden_klass_name(const Klass* k, uintptr_t hash) {\n-  assert(k != nullptr, \"invariant\");\n-  assert(k->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  const Symbol* const name = k->name();\n-  assert(name != nullptr, \"invariant\");\n-  assert(name->identity_hash() == hash, \"invariant\");\n-  const size_t len = static_cast<size_t>(name->utf8_length());\n-  char* hidden_klass_name = NEW_RESOURCE_ARRAY(char, len + 1);\n-  strncpy(hidden_klass_name, name->as_klass_external_name(), len + 1);\n-  char* const plus_position = strrchr(hidden_klass_name, '+');\n-  assert(plus_position != nullptr, \"invariant\");\n-  *plus_position = '\/'; \/\/ replace the '+' delimiter with a '\/'\n-  assert(strlen(hidden_klass_name) == len, \"invariant\");\n-  return hidden_klass_name;\n-}\n-\n@@ -270,3 +248,2 @@\n-  assert(k->name() != nullptr, \"invariant\");\n-  const uintptr_t hash = k->name()->identity_hash();;\n-  return mark(hash, create_hidden_klass_name(k, hash), leakp);\n+  const uintptr_t hash = k->name()->identity_hash();\n+  return mark(hash, k->external_name(), leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"}]}