{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -29,2 +29,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -203,1 +202,1 @@\n-  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp);\n@@ -239,18 +238,15 @@\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n+ * The hidden class symbol is the external name with the\n+ * address of its Klass slash appended.\n+ *\n+ * This is done by replacing the '+' delimiter with a '\/'\n+ * in a copy of the already mangled hidden class name.\n+ *\n+ * \"java.lang.invoke.LambdaForm$DMH+0x0000000037144c00\"\n+ *  becomes\n+ * \"java.lang.invoke.LambdaForm$DMH\/0x0000000037144c00\"\n+ *\n+ * Caller needs ResourceMark.\n+ *\/\n+static const char* create_hidden_klass_name(const Klass* k, uintptr_t hash) {\n+  assert(k != nullptr, \"invariant\");\n+  assert(k->is_hidden(), \"invariant\");\n@@ -258,16 +254,14 @@\n-  char* hidden_symbol = nullptr;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  char hash_buf[40];\n-  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+  const Symbol* const name = k->name();\n+  assert(name != nullptr, \"invariant\");\n+  assert(name->identity_hash() == hash, \"invariant\");\n+  const size_t len = static_cast<size_t>(name->utf8_length());\n+  char* hidden_klass_name = NEW_RESOURCE_ARRAY(char, len + 1);\n+  strncpy(hidden_klass_name, name->as_klass_external_name(), len + 1);\n+  char* const plus_position = strrchr(hidden_klass_name, '+');\n+  assert(plus_position != nullptr, \"invariant\");\n+  *plus_position = '\/'; \/\/ replace the '+' delimiter with a '\/'\n+  assert(strlen(hidden_klass_name) == len, \"invariant\");\n+  return hidden_klass_name;\n+}\n+\n+traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n@@ -275,9 +269,4 @@\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n+  assert(k->is_hidden(), \"invariant\");\n+  assert(k->name() != nullptr, \"invariant\");\n+  const uintptr_t hash = k->name()->identity_hash();;\n+  return mark(hash, create_hidden_klass_name(k, hash), leakp);\n@@ -289,3 +278,2 @@\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  if (k->is_hidden()) {\n+    symbol_id = mark_hidden_klass_name(k, leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":39,"deletions":51,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n@@ -109,4 +110,0 @@\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}