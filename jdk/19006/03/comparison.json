{"files":[{"patch":"@@ -27,60 +27,2 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n-import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n-import java.lang.classfile.attribute.CharacterRangeInfo;\n-import java.lang.classfile.attribute.CharacterRangeTableAttribute;\n-import java.lang.classfile.attribute.CodeAttribute;\n-import java.lang.classfile.attribute.CompilationIDAttribute;\n-import java.lang.classfile.attribute.ConstantValueAttribute;\n-import java.lang.classfile.attribute.DeprecatedAttribute;\n-import java.lang.classfile.attribute.EnclosingMethodAttribute;\n-import java.lang.classfile.attribute.ExceptionsAttribute;\n-import java.lang.classfile.attribute.InnerClassInfo;\n-import java.lang.classfile.attribute.InnerClassesAttribute;\n-import java.lang.classfile.attribute.LineNumberInfo;\n-import java.lang.classfile.attribute.LineNumberTableAttribute;\n-import java.lang.classfile.attribute.LocalVariableInfo;\n-import java.lang.classfile.attribute.LocalVariableTableAttribute;\n-import java.lang.classfile.attribute.LocalVariableTypeInfo;\n-import java.lang.classfile.attribute.LocalVariableTypeTableAttribute;\n-import java.lang.classfile.attribute.MethodParameterInfo;\n-import java.lang.classfile.attribute.MethodParametersAttribute;\n-import java.lang.classfile.attribute.ModuleAttribute;\n-import java.lang.classfile.attribute.ModuleExportInfo;\n-import java.lang.classfile.attribute.ModuleHashInfo;\n-import java.lang.classfile.attribute.ModuleHashesAttribute;\n-import java.lang.classfile.attribute.ModuleMainClassAttribute;\n-import java.lang.classfile.attribute.ModuleOpenInfo;\n-import java.lang.classfile.attribute.ModulePackagesAttribute;\n-import java.lang.classfile.attribute.ModuleProvideInfo;\n-import java.lang.classfile.attribute.ModuleRequireInfo;\n-import java.lang.classfile.attribute.ModuleResolutionAttribute;\n-import java.lang.classfile.attribute.ModuleTargetAttribute;\n-import java.lang.classfile.attribute.NestHostAttribute;\n-import java.lang.classfile.attribute.NestMembersAttribute;\n-import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n-import java.lang.classfile.attribute.RecordAttribute;\n-import java.lang.classfile.attribute.RecordComponentInfo;\n-import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import java.lang.classfile.attribute.SignatureAttribute;\n-import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n-import java.lang.classfile.attribute.SourceFileAttribute;\n-import java.lang.classfile.attribute.SourceIDAttribute;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.attribute.SyntheticAttribute;\n-import java.lang.classfile.constantpool.Utf8Entry;\n-import jdk.internal.classfile.impl.AbstractAttributeMapper;\n-import jdk.internal.classfile.impl.BoundAttribute;\n-import jdk.internal.classfile.impl.CodeImpl;\n-import jdk.internal.classfile.impl.AbstractPoolEntry;\n-import jdk.internal.classfile.impl.StackMapDecoder;\n+import java.lang.classfile.attribute.*;\n+import jdk.internal.classfile.impl.AbstractAttributeMapper.*;\n@@ -97,1 +39,1 @@\n-public class Attributes {\n+public final class Attributes {\n@@ -210,772 +152,271 @@\n-    \/** Attribute mapper for the {@code AnnotationDefault} attribute *\/\n-    public static final AttributeMapper<AnnotationDefaultAttribute>\n-            ANNOTATION_DEFAULT = new AbstractAttributeMapper<>(NAME_ANNOTATION_DEFAULT) {\n-                @Override\n-                public AnnotationDefaultAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundAnnotationDefaultAttr(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, AnnotationDefaultAttribute attr) {\n-                    attr.defaultValue().writeTo(buf);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code BootstrapMethods} attribute *\/\n-    public static final AttributeMapper<BootstrapMethodsAttribute>\n-            BOOTSTRAP_METHODS = new AbstractAttributeMapper<>(NAME_BOOTSTRAP_METHODS) {\n-                @Override\n-                public BootstrapMethodsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundBootstrapMethodsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, BootstrapMethodsAttribute attr) {\n-                    buf.writeList(attr.bootstrapMethods());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code CharacterRangeTable} attribute *\/\n-    public static final AttributeMapper<CharacterRangeTableAttribute>\n-            CHARACTER_RANGE_TABLE = new AbstractAttributeMapper<>(NAME_CHARACTER_RANGE_TABLE, true) {\n-                @Override\n-                public CharacterRangeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundCharacterRangeTableAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n-                    List<CharacterRangeInfo> ranges = attr.characterRangeTable();\n-                    buf.writeU2(ranges.size());\n-                    for (CharacterRangeInfo info : ranges) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.endPc());\n-                        buf.writeInt(info.characterRangeStart());\n-                        buf.writeInt(info.characterRangeEnd());\n-                        buf.writeU2(info.flags());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Code} attribute *\/\n-    public static final AttributeMapper<CodeAttribute>\n-            CODE = new AbstractAttributeMapper<>(NAME_CODE) {\n-                @Override\n-                public CodeAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new CodeImpl(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CodeAttribute attr) {\n-                    throw new UnsupportedOperationException(\"Code attribute does not support direct write\");\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-\n-    \/** Attribute mapper for the {@code CompilationID} attribute *\/\n-    public static final AttributeMapper<CompilationIDAttribute>\n-            COMPILATION_ID = new AbstractAttributeMapper<>(NAME_COMPILATION_ID, true) {\n-                @Override\n-                public CompilationIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundCompilationIDAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CompilationIDAttribute attr) {\n-                    buf.writeIndex(attr.compilationId());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ConstantValue} attribute *\/\n-    public static final AttributeMapper<ConstantValueAttribute>\n-            CONSTANT_VALUE = new AbstractAttributeMapper<>(NAME_CONSTANT_VALUE) {\n-                @Override\n-                public ConstantValueAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundConstantValueAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ConstantValueAttribute attr) {\n-                    buf.writeIndex(attr.constant());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Deprecated} attribute *\/\n-    public static final AttributeMapper<DeprecatedAttribute>\n-            DEPRECATED = new AbstractAttributeMapper<>(NAME_DEPRECATED, true) {\n-                @Override\n-                public DeprecatedAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundDeprecatedAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, DeprecatedAttribute attr) {\n-                    \/\/ empty\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code EnclosingMethod} attribute *\/\n-    public static final AttributeMapper<EnclosingMethodAttribute>\n-            ENCLOSING_METHOD = new AbstractAttributeMapper<>(NAME_ENCLOSING_METHOD) {\n-                @Override\n-                public EnclosingMethodAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundEnclosingMethodAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n-                    buf.writeIndex(attr.enclosingClass());\n-                    buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Exceptions} attribute *\/\n-    public static final AttributeMapper<ExceptionsAttribute>\n-            EXCEPTIONS = new AbstractAttributeMapper<>(NAME_EXCEPTIONS) {\n-                @Override\n-                public ExceptionsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundExceptionsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ExceptionsAttribute attr) {\n-                    buf.writeListIndices(attr.exceptions());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code InnerClasses} attribute *\/\n-    public static final AttributeMapper<InnerClassesAttribute>\n-            INNER_CLASSES = new AbstractAttributeMapper<>(NAME_INNER_CLASSES) {\n-                @Override\n-                public InnerClassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundInnerClassesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n-                    List<InnerClassInfo> classes = attr.classes();\n-                    buf.writeU2(classes.size());\n-                    for (InnerClassInfo ic : classes) {\n-                        buf.writeIndex(ic.innerClass());\n-                        buf.writeIndexOrZero(ic.outerClass().orElse(null));\n-                        buf.writeIndexOrZero(ic.innerName().orElse(null));\n-                        buf.writeU2(ic.flagsMask());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LineNumberTable} attribute *\/\n-    public static final AttributeMapper<LineNumberTableAttribute>\n-            LINE_NUMBER_TABLE = new AbstractAttributeMapper<>(NAME_LINE_NUMBER_TABLE, true) {\n-                @Override\n-                public LineNumberTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLineNumberTableAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n-                    List<LineNumberInfo> lines = attr.lineNumbers();\n-                    buf.writeU2(lines.size());\n-                    for (LineNumberInfo line : lines) {\n-                        buf.writeU2(line.startPc());\n-                        buf.writeU2(line.lineNumber());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LocalVariableTable} attribute *\/\n-    public static final AttributeMapper<LocalVariableTableAttribute>\n-            LOCAL_VARIABLE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TABLE, true) {\n-                @Override\n-                public LocalVariableTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLocalVariableTableAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n-                    List<LocalVariableInfo> infos = attr.localVariables();\n-                    buf.writeU2(infos.size());\n-                    for (LocalVariableInfo info : infos) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.length());\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.type());\n-                        buf.writeU2(info.slot());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LocalVariableTypeTable} attribute *\/\n-    public static final AttributeMapper<LocalVariableTypeTableAttribute>\n-            LOCAL_VARIABLE_TYPE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TYPE_TABLE, true) {\n-                @Override\n-                public LocalVariableTypeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLocalVariableTypeTableAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n-                    List<LocalVariableTypeInfo> infos = attr.localVariableTypes();\n-                    buf.writeU2(infos.size());\n-                    for (LocalVariableTypeInfo info : infos) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.length());\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.signature());\n-                        buf.writeU2(info.slot());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code MethodParameters} attribute *\/\n-    public static final AttributeMapper<MethodParametersAttribute>\n-            METHOD_PARAMETERS = new AbstractAttributeMapper<>(NAME_METHOD_PARAMETERS) {\n-                @Override\n-                public MethodParametersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundMethodParametersAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n-                    List<MethodParameterInfo> parameters = attr.parameters();\n-                    buf.writeU1(parameters.size());\n-                    for (MethodParameterInfo info : parameters) {\n-                        buf.writeIndexOrZero(info.name().orElse(null));\n-                        buf.writeU2(info.flagsMask());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Module} attribute *\/\n-    public static final AttributeMapper<ModuleAttribute>\n-            MODULE = new AbstractAttributeMapper<>(NAME_MODULE) {\n-                @Override\n-                public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n-                    buf.writeIndex(attr.moduleName());\n-                    buf.writeU2(attr.moduleFlagsMask());\n-                    buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n-                    buf.writeU2(attr.requires().size());\n-                    for (ModuleRequireInfo require : attr.requires()) {\n-                        buf.writeIndex(require.requires());\n-                        buf.writeU2(require.requiresFlagsMask());\n-                        buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n-                    }\n-                    buf.writeU2(attr.exports().size());\n-                    for (ModuleExportInfo export : attr.exports()) {\n-                        buf.writeIndex(export.exportedPackage());\n-                        buf.writeU2(export.exportsFlagsMask());\n-                        buf.writeListIndices(export.exportsTo());\n-                    }\n-                    buf.writeU2(attr.opens().size());\n-                    for (ModuleOpenInfo open : attr.opens()) {\n-                        buf.writeIndex(open.openedPackage());\n-                        buf.writeU2(open.opensFlagsMask());\n-                        buf.writeListIndices(open.opensTo());\n-                    }\n-                    buf.writeListIndices(attr.uses());\n-                    buf.writeU2(attr.provides().size());\n-                    for (ModuleProvideInfo provide : attr.provides()) {\n-                        buf.writeIndex(provide.provides());\n-                        buf.writeListIndices(provide.providesWith());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleHashes} attribute *\/\n-    public static final AttributeMapper<ModuleHashesAttribute>\n-            MODULE_HASHES = new AbstractAttributeMapper<>(NAME_MODULE_HASHES) {\n-                @Override\n-                public ModuleHashesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleHashesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n-                    buf.writeIndex(attr.algorithm());\n-                    List<ModuleHashInfo> hashes = attr.hashes();\n-                    buf.writeU2(hashes.size());\n-                    for (ModuleHashInfo hash : hashes) {\n-                        buf.writeIndex(hash.moduleName());\n-                        buf.writeU2(hash.hash().length);\n-                        buf.writeBytes(hash.hash());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleMainClass} attribute *\/\n-    public static final AttributeMapper<ModuleMainClassAttribute>\n-            MODULE_MAIN_CLASS = new AbstractAttributeMapper<>(NAME_MODULE_MAIN_CLASS) {\n-                @Override\n-                public ModuleMainClassAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleMainClassAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleMainClassAttribute attr) {\n-                    buf.writeIndex(attr.mainClass());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModulePackages} attribute *\/\n-    public static final AttributeMapper<ModulePackagesAttribute>\n-            MODULE_PACKAGES = new AbstractAttributeMapper<>(NAME_MODULE_PACKAGES) {\n-                @Override\n-                public ModulePackagesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModulePackagesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModulePackagesAttribute attr) {\n-                    buf.writeListIndices(attr.packages());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleResolution} attribute *\/\n-    public static final AttributeMapper<ModuleResolutionAttribute>\n-            MODULE_RESOLUTION = new AbstractAttributeMapper<>(NAME_MODULE_RESOLUTION) {\n-                @Override\n-                public ModuleResolutionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleResolutionAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleResolutionAttribute attr) {\n-                    buf.writeU2(attr.resolutionFlags());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleTarget} attribute *\/\n-    public static final AttributeMapper<ModuleTargetAttribute>\n-            MODULE_TARGET = new AbstractAttributeMapper<>(NAME_MODULE_TARGET) {\n-                @Override\n-                public ModuleTargetAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleTargetAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleTargetAttribute attr) {\n-                    buf.writeIndex(attr.targetPlatform());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code NestHost} attribute *\/\n-    public static final AttributeMapper<NestHostAttribute>\n-            NEST_HOST = new AbstractAttributeMapper<>(NAME_NEST_HOST) {\n-                @Override\n-                public NestHostAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundNestHostAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, NestHostAttribute attr) {\n-                    buf.writeIndex(attr.nestHost());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code NestMembers} attribute *\/\n-    public static final AttributeMapper<NestMembersAttribute>\n-            NEST_MEMBERS = new AbstractAttributeMapper<>(NAME_NEST_MEMBERS) {\n-                @Override\n-                public NestMembersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundNestMembersAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, NestMembersAttribute attr) {\n-                    buf.writeListIndices(attr.nestMembers());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code PermittedSubclasses} attribute *\/\n-    public static final AttributeMapper<PermittedSubclassesAttribute>\n-            PERMITTED_SUBCLASSES = new AbstractAttributeMapper<>(NAME_PERMITTED_SUBCLASSES) {\n-                @Override\n-                public PermittedSubclassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundPermittedSubclassesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, PermittedSubclassesAttribute attr) {\n-                    buf.writeListIndices(attr.permittedSubclasses());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Record} attribute *\/\n-    public static final AttributeMapper<RecordAttribute>\n-            RECORD = new AbstractAttributeMapper<>(NAME_RECORD) {\n-                @Override\n-                public RecordAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRecordAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RecordAttribute attr) {\n-                    List<RecordComponentInfo> components = attr.components();\n-                    buf.writeU2(components.size());\n-                    for (RecordComponentInfo info : components) {\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.descriptor());\n-                        buf.writeList(info.attributes());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute(cf, pos);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleParameterAnnotationsAttribute attr) {\n-                    List<List<Annotation>> lists = attr.parameterAnnotations();\n-                    buf.writeU1(lists.size());\n-                    for (List<Annotation> list : lists)\n-                        buf.writeList(list);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleTypeAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.UNSTABLE;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleAnnotationsAttribute>\n-            RUNTIME_VISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n-                    return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute>\n-            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleParameterAnnotationsAttribute attr) {\n-                    List<List<Annotation>> lists = attr.parameterAnnotations();\n-                    buf.writeU1(lists.size());\n-                    for (List<Annotation> list : lists)\n-                        buf.writeList(list);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute>\n-            RUNTIME_VISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleTypeAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.UNSTABLE;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Signature} attribute *\/\n-    public static final AttributeMapper<SignatureAttribute>\n-            SIGNATURE = new AbstractAttributeMapper<>(NAME_SIGNATURE) {\n-                @Override\n-                public SignatureAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSignatureAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SignatureAttribute attr) {\n-                    buf.writeIndex(attr.signature());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceDebugExtension} attribute *\/\n-    public static final AttributeMapper<SourceDebugExtensionAttribute>\n-            SOURCE_DEBUG_EXTENSION = new AbstractAttributeMapper<>(NAME_SOURCE_DEBUG_EXTENSION) {\n-                @Override\n-                public SourceDebugExtensionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceDebugExtensionAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceDebugExtensionAttribute attr) {\n-                    buf.writeBytes(attr.contents());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceFile} attribute *\/\n-    public static final AttributeMapper<SourceFileAttribute>\n-            SOURCE_FILE = new AbstractAttributeMapper<>(NAME_SOURCE_FILE) {\n-                @Override\n-                public SourceFileAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceFileAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceFileAttribute attr) {\n-                    buf.writeIndex(attr.sourceFile());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceID} attribute *\/\n-    public static final AttributeMapper<SourceIDAttribute>\n-            SOURCE_ID = new AbstractAttributeMapper<>(NAME_SOURCE_ID) {\n-                @Override\n-                public SourceIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceIDAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceIDAttribute attr) {\n-                    buf.writeIndex(attr.sourceId());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code StackMapTable} attribute *\/\n-    public static final AttributeMapper<StackMapTableAttribute>\n-            STACK_MAP_TABLE = new AbstractAttributeMapper<>(NAME_STACK_MAP_TABLE) {\n-                @Override\n-                public StackMapTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundStackMapTableAttribute((CodeImpl)e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter b, StackMapTableAttribute attr) {\n-                    StackMapDecoder.writeFrames(b, attr.entries());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-\n-    \/** Attribute mapper for the {@code Synthetic} attribute *\/\n-    public static final AttributeMapper<SyntheticAttribute>\n-            SYNTHETIC = new AbstractAttributeMapper<>(NAME_SYNTHETIC, true) {\n-                @Override\n-                public SyntheticAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSyntheticAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SyntheticAttribute attr) {\n-                    \/\/ empty\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n+    \/**\n+     * {@return Attribute mapper for the {@code AnnotationDefault} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<AnnotationDefaultAttribute> annotationDefault() {\n+        return AnnotationDefaultMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code BootstrapMethods} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<BootstrapMethodsAttribute> bootstrapMethods() {\n+        return BootstrapMethodsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code CharacterRangeTable} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CharacterRangeTableAttribute> characterRangeTable() {\n+        return CharacterRangeTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Code} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CodeAttribute> code() {\n+        return CodeMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code CompilationID} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CompilationIDAttribute> compilationId() {\n+        return CompilationIDMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ConstantValue} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ConstantValueAttribute> constantValue() {\n+        return ConstantValueMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Deprecated} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<DeprecatedAttribute> deprecated() {\n+        return DeprecatedMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code EnclosingMethod} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<EnclosingMethodAttribute> enclosingMethod() {\n+        return EnclosingMethodMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Exceptions} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ExceptionsAttribute> exceptions() {\n+        return ExceptionsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code InnerClasses} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<InnerClassesAttribute> innerClasses() {\n+        return InnerClassesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LineNumberTable} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LineNumberTableAttribute> lineNumberTable() {\n+        return LineNumberTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LocalVariableTable} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LocalVariableTableAttribute> localVariableTable() {\n+        return LocalVariableTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LocalVariableTypeTable} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LocalVariableTypeTableAttribute> localVariableTypeTable() {\n+        return LocalVariableTypeTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code MethodParameters} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<MethodParametersAttribute> methodParameters() {\n+        return MethodParametersMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Module} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleAttribute> module() {\n+        return ModuleMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleHashes} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleHashesAttribute> moduleHashes() {\n+        return ModuleHashesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleMainClass} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleMainClassAttribute> moduleMainClass() {\n+        return ModuleMainClassMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModulePackages} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModulePackagesAttribute> modulePackages() {\n+        return ModulePackagesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleResolution} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleResolutionAttribute> moduleResolution() {\n+        return ModuleResolutionMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleTarget} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleTargetAttribute> moduleTarget() {\n+        return ModuleTargetMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code NestHost} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<NestHostAttribute> nestHost() {\n+        return NestHostMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code NestMembers} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<NestMembersAttribute> nestMembers() {\n+        return NestMembersMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code PermittedSubclasses} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<PermittedSubclassesAttribute> permittedSubclasses() {\n+        return PermittedSubclassesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Record} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RecordAttribute> record() {\n+        return RecordMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleAnnotationsAttribute> runtimeInvisibleAnnotations() {\n+        return RuntimeInvisibleAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute> runtimeInvisibleParameterAnnotations() {\n+        return RuntimeInvisibleParameterAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute> runtimeInvisibleTypeAnnotations() {\n+        return RuntimeInvisibleTypeAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleAnnotationsAttribute> runtimeVisibleAnnotations() {\n+        return RuntimeVisibleAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute> runtimeVisibleParameterAnnotations() {\n+        return RuntimeVisibleParameterAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute> runtimeVisibleTypeAnnotations() {\n+        return RuntimeVisibleTypeAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Signature} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SignatureAttribute> signature() {\n+        return SignatureMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceDebugExtension} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceDebugExtensionAttribute> sourceDebugExtension() {\n+        return SourceDebugExtensionMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceFile} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceFileAttribute> sourceFile() {\n+        return SourceFileMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceID} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceIDAttribute> sourceId() {\n+        return SourceIDMapper.INSTANCE;\n+    }\n@@ -984,3 +425,2 @@\n-     * {@return the attribute mapper for a standard attribute}\n-     *\n-     * @param name the name of the attribute to find\n+     * {@return Attribute mapper for the {@code StackMapTable} attribute}\n+     * @since 23\n@@ -988,2 +428,2 @@\n-    public static AttributeMapper<?> standardAttribute(Utf8Entry name) {\n-        return _ATTR_MAP.get(name);\n+    public static AttributeMapper<StackMapTableAttribute> stackMapTable() {\n+        return StackMapTableMapper.INSTANCE;\n@@ -993,1 +433,2 @@\n-     * All standard attribute mappers.\n+     * {@return Attribute mapper for the {@code Synthetic} attribute}\n+     * @since 23\n@@ -995,46 +436,2 @@\n-    public static final Set<AttributeMapper<?>> PREDEFINED_ATTRIBUTES = Set.of(\n-            ANNOTATION_DEFAULT,\n-            BOOTSTRAP_METHODS,\n-            CHARACTER_RANGE_TABLE,\n-            CODE,\n-            COMPILATION_ID,\n-            CONSTANT_VALUE,\n-            DEPRECATED,\n-            ENCLOSING_METHOD,\n-            EXCEPTIONS,\n-            INNER_CLASSES,\n-            LINE_NUMBER_TABLE,\n-            LOCAL_VARIABLE_TABLE,\n-            LOCAL_VARIABLE_TYPE_TABLE,\n-            METHOD_PARAMETERS,\n-            MODULE,\n-            MODULE_HASHES,\n-            MODULE_MAIN_CLASS,\n-            MODULE_PACKAGES,\n-            MODULE_RESOLUTION,\n-            MODULE_TARGET,\n-            NEST_HOST,\n-            NEST_MEMBERS,\n-            PERMITTED_SUBCLASSES,\n-            RECORD,\n-            RUNTIME_INVISIBLE_ANNOTATIONS,\n-            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS,\n-            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS,\n-            RUNTIME_VISIBLE_ANNOTATIONS,\n-            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS,\n-            RUNTIME_VISIBLE_TYPE_ANNOTATIONS,\n-            SIGNATURE,\n-            SOURCE_DEBUG_EXTENSION,\n-            SOURCE_FILE,\n-            SOURCE_ID,\n-            STACK_MAP_TABLE,\n-            SYNTHETIC);\n-\n-    private static final Map<Utf8Entry, AttributeMapper<?>> _ATTR_MAP;\n-    \/\/no lambdas here as this is on critical JDK boostrap path\n-    static {\n-        var map = new HashMap<Utf8Entry, AttributeMapper<?>>(64);\n-        for (var am : PREDEFINED_ATTRIBUTES) {\n-            map.put(AbstractPoolEntry.rawUtf8EntryFromStandardAttributeName(am.name()), am);\n-        }\n-        _ATTR_MAP = Collections.unmodifiableMap(map);\n+    public static AttributeMapper<SyntheticAttribute> synthetic() {\n+        return SyntheticMapper.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attributes.java","additions":282,"deletions":885,"binary":false,"changes":1167,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.Annotation;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.AttributedElement;\n@@ -30,0 +32,3 @@\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.attribute.*;\n+import java.util.List;\n@@ -31,1 +36,3 @@\n-public abstract class AbstractAttributeMapper<T extends Attribute<T>>\n+import static java.lang.classfile.Attributes.*;\n+\n+public sealed abstract class AbstractAttributeMapper<T extends Attribute<T>>\n@@ -35,0 +42,1 @@\n+    private final AttributeMapper.AttributeStability stability;\n@@ -39,2 +47,2 @@\n-    public AbstractAttributeMapper(String name) {\n-        this(name, false);\n+    public AbstractAttributeMapper(String name, AttributeMapper.AttributeStability stability) {\n+        this(name, stability, false);\n@@ -44,0 +52,1 @@\n+                                   AttributeMapper.AttributeStability stability,\n@@ -46,0 +55,1 @@\n+        this.stability = stability;\n@@ -50,1 +60,1 @@\n-    public String name() {\n+    public final String name() {\n@@ -55,1 +65,1 @@\n-    public void writeAttribute(BufWriter buf, T attr) {\n+    public final void writeAttribute(BufWriter buf, T attr) {\n@@ -64,0 +74,5 @@\n+    @Override\n+    public AttributeMapper.AttributeStability stability() {\n+        return stability;\n+    }\n+\n@@ -74,0 +89,735 @@\n+\n+    public static final class AnnotationDefaultMapper extends AbstractAttributeMapper<AnnotationDefaultAttribute> {\n+        public static final AnnotationDefaultMapper INSTANCE = new AnnotationDefaultMapper();\n+\n+        private AnnotationDefaultMapper() {\n+            super(NAME_ANNOTATION_DEFAULT, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public AnnotationDefaultAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundAnnotationDefaultAttr(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, AnnotationDefaultAttribute attr) {\n+            attr.defaultValue().writeTo(buf);\n+        }\n+    }\n+\n+    public static final class BootstrapMethodsMapper extends AbstractAttributeMapper<BootstrapMethodsAttribute> {\n+        public static final BootstrapMethodsMapper INSTANCE = new BootstrapMethodsMapper();\n+\n+        private BootstrapMethodsMapper() {\n+            super(NAME_BOOTSTRAP_METHODS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public BootstrapMethodsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundBootstrapMethodsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, BootstrapMethodsAttribute attr) {\n+            buf.writeList(attr.bootstrapMethods());\n+        }\n+    }\n+\n+    public static final class CharacterRangeTableMapper extends AbstractAttributeMapper<CharacterRangeTableAttribute> {\n+        public static final CharacterRangeTableMapper INSTANCE = new CharacterRangeTableMapper();\n+\n+        private CharacterRangeTableMapper() {\n+            super(NAME_CHARACTER_RANGE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public CharacterRangeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundCharacterRangeTableAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n+            List<CharacterRangeInfo> ranges = attr.characterRangeTable();\n+            buf.writeU2(ranges.size());\n+            for (CharacterRangeInfo info : ranges) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.endPc());\n+                buf.writeInt(info.characterRangeStart());\n+                buf.writeInt(info.characterRangeEnd());\n+                buf.writeU2(info.flags());\n+            }\n+        }\n+    }\n+\n+    public static final class CodeMapper extends AbstractAttributeMapper<CodeAttribute> {\n+        public static final CodeMapper INSTANCE = new CodeMapper();\n+\n+        private CodeMapper() {\n+            super(NAME_CODE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public CodeAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new CodeImpl(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CodeAttribute attr) {\n+            throw new UnsupportedOperationException(\"Code attribute does not support direct write\");\n+        }\n+    }\n+\n+    public static final class CompilationIDMapper extends AbstractAttributeMapper<CompilationIDAttribute> {\n+        public static final CompilationIDMapper INSTANCE = new CompilationIDMapper();\n+\n+        private CompilationIDMapper() {\n+            super(NAME_COMPILATION_ID, AttributeStability.CP_REFS, true);\n+        }\n+\n+        @Override\n+        public CompilationIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundCompilationIDAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CompilationIDAttribute attr) {\n+            buf.writeIndex(attr.compilationId());\n+        }\n+    }\n+\n+    public static final class ConstantValueMapper extends AbstractAttributeMapper<ConstantValueAttribute> {\n+        public static final ConstantValueMapper INSTANCE = new ConstantValueMapper();\n+\n+        private ConstantValueMapper() {\n+            super(NAME_CONSTANT_VALUE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ConstantValueAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundConstantValueAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ConstantValueAttribute attr) {\n+            buf.writeIndex(attr.constant());\n+        }\n+    }\n+\n+    public static final class DeprecatedMapper extends AbstractAttributeMapper<DeprecatedAttribute> {\n+        public static final DeprecatedMapper INSTANCE = new DeprecatedMapper();\n+\n+        private DeprecatedMapper() {\n+            super(NAME_DEPRECATED, AttributeStability.STATELESS, true);\n+        }\n+\n+        @Override\n+        public DeprecatedAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundDeprecatedAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, DeprecatedAttribute attr) {\n+            \/\/ empty\n+        }\n+    }\n+\n+    public static final class EnclosingMethodMapper extends AbstractAttributeMapper<EnclosingMethodAttribute> {\n+        public static final EnclosingMethodMapper INSTANCE = new EnclosingMethodMapper();\n+\n+        private EnclosingMethodMapper() {\n+            super(NAME_ENCLOSING_METHOD, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public EnclosingMethodAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundEnclosingMethodAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n+            buf.writeIndex(attr.enclosingClass());\n+            buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n+        }\n+    }\n+\n+    public static final class ExceptionsMapper extends AbstractAttributeMapper<ExceptionsAttribute> {\n+        public static final ExceptionsMapper INSTANCE = new ExceptionsMapper();\n+\n+        private ExceptionsMapper() {\n+            super(NAME_EXCEPTIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ExceptionsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundExceptionsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ExceptionsAttribute attr) {\n+            buf.writeListIndices(attr.exceptions());\n+        }\n+    }\n+\n+    public static final class InnerClassesMapper extends AbstractAttributeMapper<InnerClassesAttribute> {\n+        public static final InnerClassesMapper INSTANCE = new InnerClassesMapper();\n+\n+        private InnerClassesMapper() {\n+            super(NAME_INNER_CLASSES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public InnerClassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundInnerClassesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n+            List<InnerClassInfo> classes = attr.classes();\n+            buf.writeU2(classes.size());\n+            for (InnerClassInfo ic : classes) {\n+                buf.writeIndex(ic.innerClass());\n+                buf.writeIndexOrZero(ic.outerClass().orElse(null));\n+                buf.writeIndexOrZero(ic.innerName().orElse(null));\n+                buf.writeU2(ic.flagsMask());\n+            }\n+        }\n+    }\n+\n+    public static final class LineNumberTableMapper extends AbstractAttributeMapper<LineNumberTableAttribute> {\n+        public static final LineNumberTableMapper INSTANCE = new LineNumberTableMapper();\n+\n+        private LineNumberTableMapper() {\n+            super(NAME_LINE_NUMBER_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LineNumberTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLineNumberTableAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n+            List<LineNumberInfo> lines = attr.lineNumbers();\n+            buf.writeU2(lines.size());\n+            for (LineNumberInfo line : lines) {\n+                buf.writeU2(line.startPc());\n+                buf.writeU2(line.lineNumber());\n+            }\n+        }\n+    }\n+\n+    public static final class LocalVariableTableMapper extends AbstractAttributeMapper<LocalVariableTableAttribute> {\n+        public static final LocalVariableTableMapper INSTANCE = new LocalVariableTableMapper();\n+\n+        private LocalVariableTableMapper() {\n+            super(NAME_LOCAL_VARIABLE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LocalVariableTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLocalVariableTableAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n+            List<LocalVariableInfo> infos = attr.localVariables();\n+            buf.writeU2(infos.size());\n+            for (LocalVariableInfo info : infos) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.length());\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.type());\n+                buf.writeU2(info.slot());\n+            }\n+        }\n+    }\n+\n+    public static final class LocalVariableTypeTableMapper extends AbstractAttributeMapper<LocalVariableTypeTableAttribute> {\n+        public static final LocalVariableTypeTableMapper INSTANCE = new LocalVariableTypeTableMapper();\n+\n+        private LocalVariableTypeTableMapper() {\n+            super(NAME_LOCAL_VARIABLE_TYPE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LocalVariableTypeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLocalVariableTypeTableAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n+            List<LocalVariableTypeInfo> infos = attr.localVariableTypes();\n+            buf.writeU2(infos.size());\n+            for (LocalVariableTypeInfo info : infos) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.length());\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.signature());\n+                buf.writeU2(info.slot());\n+            }\n+        }\n+    }\n+\n+    public static final class MethodParametersMapper extends AbstractAttributeMapper<MethodParametersAttribute> {\n+        public static final MethodParametersMapper INSTANCE = new MethodParametersMapper();\n+\n+        private MethodParametersMapper() {\n+            super(NAME_METHOD_PARAMETERS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public MethodParametersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundMethodParametersAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n+            List<MethodParameterInfo> parameters = attr.parameters();\n+            buf.writeU1(parameters.size());\n+            for (MethodParameterInfo info : parameters) {\n+                buf.writeIndexOrZero(info.name().orElse(null));\n+                buf.writeU2(info.flagsMask());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleMapper extends AbstractAttributeMapper<ModuleAttribute> {\n+        public static final ModuleMapper INSTANCE = new ModuleMapper();\n+\n+        private ModuleMapper() {\n+            super(NAME_MODULE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n+            buf.writeIndex(attr.moduleName());\n+            buf.writeU2(attr.moduleFlagsMask());\n+            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+            buf.writeU2(attr.requires().size());\n+            for (ModuleRequireInfo require : attr.requires()) {\n+                buf.writeIndex(require.requires());\n+                buf.writeU2(require.requiresFlagsMask());\n+                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+            }\n+            buf.writeU2(attr.exports().size());\n+            for (ModuleExportInfo export : attr.exports()) {\n+                buf.writeIndex(export.exportedPackage());\n+                buf.writeU2(export.exportsFlagsMask());\n+                buf.writeListIndices(export.exportsTo());\n+            }\n+            buf.writeU2(attr.opens().size());\n+            for (ModuleOpenInfo open : attr.opens()) {\n+                buf.writeIndex(open.openedPackage());\n+                buf.writeU2(open.opensFlagsMask());\n+                buf.writeListIndices(open.opensTo());\n+            }\n+            buf.writeListIndices(attr.uses());\n+            buf.writeU2(attr.provides().size());\n+            for (ModuleProvideInfo provide : attr.provides()) {\n+                buf.writeIndex(provide.provides());\n+                buf.writeListIndices(provide.providesWith());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleHashesMapper extends AbstractAttributeMapper<ModuleHashesAttribute> {\n+        public static final ModuleHashesMapper INSTANCE = new ModuleHashesMapper();\n+\n+        private ModuleHashesMapper() {\n+            super(NAME_MODULE_HASHES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleHashesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleHashesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n+            buf.writeIndex(attr.algorithm());\n+            List<ModuleHashInfo> hashes = attr.hashes();\n+            buf.writeU2(hashes.size());\n+            for (ModuleHashInfo hash : hashes) {\n+                buf.writeIndex(hash.moduleName());\n+                buf.writeU2(hash.hash().length);\n+                buf.writeBytes(hash.hash());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleMainClassMapper extends AbstractAttributeMapper<ModuleMainClassAttribute> {\n+        public static final ModuleMainClassMapper INSTANCE = new ModuleMainClassMapper();\n+\n+        private ModuleMainClassMapper() {\n+            super(NAME_MODULE_MAIN_CLASS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleMainClassAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleMainClassAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleMainClassAttribute attr) {\n+            buf.writeIndex(attr.mainClass());\n+        }\n+    }\n+\n+    public static final class ModulePackagesMapper extends AbstractAttributeMapper<ModulePackagesAttribute> {\n+        public static final ModulePackagesMapper INSTANCE = new ModulePackagesMapper();\n+\n+        private ModulePackagesMapper() {\n+            super(NAME_MODULE_PACKAGES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModulePackagesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModulePackagesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModulePackagesAttribute attr) {\n+            buf.writeListIndices(attr.packages());\n+        }\n+    }\n+\n+    public static final class ModuleResolutionMapper extends AbstractAttributeMapper<ModuleResolutionAttribute> {\n+        public static final ModuleResolutionMapper INSTANCE = new ModuleResolutionMapper();\n+\n+        private ModuleResolutionMapper() {\n+            super(NAME_MODULE_RESOLUTION, AttributeStability.STATELESS);\n+        }\n+\n+        @Override\n+        public ModuleResolutionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleResolutionAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleResolutionAttribute attr) {\n+            buf.writeU2(attr.resolutionFlags());\n+        }\n+    }\n+\n+    public static final class ModuleTargetMapper extends AbstractAttributeMapper<ModuleTargetAttribute> {\n+        public static final ModuleTargetMapper INSTANCE = new ModuleTargetMapper();\n+\n+        private ModuleTargetMapper() {\n+            super(NAME_MODULE_TARGET, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleTargetAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleTargetAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleTargetAttribute attr) {\n+            buf.writeIndex(attr.targetPlatform());\n+        }\n+    }\n+\n+    public static final class NestHostMapper extends AbstractAttributeMapper<NestHostAttribute> {\n+        public static final NestHostMapper INSTANCE = new NestHostMapper();\n+\n+        private NestHostMapper() {\n+            super(NAME_NEST_HOST, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public NestHostAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundNestHostAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, NestHostAttribute attr) {\n+            buf.writeIndex(attr.nestHost());\n+        }\n+    }\n+\n+    public static final class NestMembersMapper extends AbstractAttributeMapper<NestMembersAttribute> {\n+        public static final NestMembersMapper INSTANCE = new NestMembersMapper();\n+\n+        private NestMembersMapper() {\n+            super(NAME_NEST_MEMBERS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public NestMembersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundNestMembersAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, NestMembersAttribute attr) {\n+            buf.writeListIndices(attr.nestMembers());\n+        }\n+    }\n+\n+    public static final class PermittedSubclassesMapper extends AbstractAttributeMapper<PermittedSubclassesAttribute> {\n+        public static final PermittedSubclassesMapper INSTANCE = new PermittedSubclassesMapper();\n+\n+        private PermittedSubclassesMapper() {\n+            super(NAME_PERMITTED_SUBCLASSES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public PermittedSubclassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundPermittedSubclassesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, PermittedSubclassesAttribute attr) {\n+            buf.writeListIndices(attr.permittedSubclasses());\n+        }\n+    }\n+\n+    public static final class RecordMapper extends AbstractAttributeMapper<RecordAttribute> {\n+        public static final RecordMapper INSTANCE = new RecordMapper();\n+\n+        private RecordMapper() {\n+            super(NAME_RECORD, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RecordAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRecordAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RecordAttribute attr) {\n+            List<RecordComponentInfo> components = attr.components();\n+            buf.writeU2(components.size());\n+            for (RecordComponentInfo info : components) {\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.descriptor());\n+                buf.writeList(info.attributes());\n+            }\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleAnnotationsAttribute> {\n+        public static final RuntimeInvisibleAnnotationsMapper INSTANCE = new RuntimeInvisibleAnnotationsMapper();\n+\n+        private RuntimeInvisibleAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute(cf, pos);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleParameterAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute> {\n+        public static final RuntimeInvisibleParameterAnnotationsMapper INSTANCE = new RuntimeInvisibleParameterAnnotationsMapper();\n+\n+        private RuntimeInvisibleParameterAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleParameterAnnotationsAttribute attr) {\n+            List<List<Annotation>> lists = attr.parameterAnnotations();\n+            buf.writeU1(lists.size());\n+            for (List<Annotation> list : lists)\n+                buf.writeList(list);\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleTypeAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute> {\n+        public static final RuntimeInvisibleTypeAnnotationsMapper INSTANCE = new RuntimeInvisibleTypeAnnotationsMapper();\n+\n+        private RuntimeInvisibleTypeAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, AttributeStability.UNSTABLE);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleTypeAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleAnnotationsAttribute> {\n+        public static final RuntimeVisibleAnnotationsMapper INSTANCE = new RuntimeVisibleAnnotationsMapper();\n+\n+        private RuntimeVisibleAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleParameterAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleParameterAnnotationsAttribute> {\n+        public static final RuntimeVisibleParameterAnnotationsMapper INSTANCE = new RuntimeVisibleParameterAnnotationsMapper();\n+\n+        private RuntimeVisibleParameterAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleParameterAnnotationsAttribute attr) {\n+            List<List<Annotation>> lists = attr.parameterAnnotations();\n+            buf.writeU1(lists.size());\n+            for (List<Annotation> list : lists)\n+                buf.writeList(list);\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleTypeAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleTypeAnnotationsAttribute> {\n+        public static final RuntimeVisibleTypeAnnotationsMapper INSTANCE = new RuntimeVisibleTypeAnnotationsMapper();\n+\n+        private RuntimeVisibleTypeAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS, AttributeStability.UNSTABLE);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleTypeAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class SignatureMapper extends AbstractAttributeMapper<SignatureAttribute> {\n+        public static final SignatureMapper INSTANCE = new SignatureMapper();\n+\n+        private SignatureMapper() {\n+            super(NAME_SIGNATURE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SignatureAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSignatureAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SignatureAttribute attr) {\n+            buf.writeIndex(attr.signature());\n+        }\n+    }\n+\n+    public static final class SourceDebugExtensionMapper extends AbstractAttributeMapper<SourceDebugExtensionAttribute> {\n+        public static final SourceDebugExtensionMapper INSTANCE = new SourceDebugExtensionMapper();\n+\n+        private SourceDebugExtensionMapper() {\n+            super(NAME_SOURCE_DEBUG_EXTENSION, AttributeStability.STATELESS);\n+        }\n+\n+        @Override\n+        public SourceDebugExtensionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceDebugExtensionAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceDebugExtensionAttribute attr) {\n+            buf.writeBytes(attr.contents());\n+        }\n+    }\n+\n+    public static final class SourceFileMapper extends AbstractAttributeMapper<SourceFileAttribute> {\n+        public static final SourceFileMapper INSTANCE = new SourceFileMapper();\n+\n+        private SourceFileMapper() {\n+            super(NAME_SOURCE_FILE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SourceFileAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceFileAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceFileAttribute attr) {\n+            buf.writeIndex(attr.sourceFile());\n+        }\n+    }\n+\n+    public static final class SourceIDMapper extends AbstractAttributeMapper<SourceIDAttribute> {\n+        public static final SourceIDMapper INSTANCE = new SourceIDMapper();\n+\n+        private SourceIDMapper() {\n+            super(NAME_SOURCE_ID, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SourceIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceIDAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceIDAttribute attr) {\n+            buf.writeIndex(attr.sourceId());\n+        }\n+    }\n+\n+    public static final class StackMapTableMapper extends AbstractAttributeMapper<StackMapTableAttribute> {\n+        public static final StackMapTableMapper INSTANCE = new StackMapTableMapper();\n+\n+        private StackMapTableMapper() {\n+            super(NAME_STACK_MAP_TABLE, AttributeStability.LABELS);\n+        }\n+\n+        @Override\n+        public StackMapTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundStackMapTableAttribute((CodeImpl)e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter b, StackMapTableAttribute attr) {\n+            StackMapDecoder.writeFrames(b, attr.entries());\n+        }\n+    }\n+\n+    public static final class SyntheticMapper extends AbstractAttributeMapper<SyntheticAttribute> {\n+        public static final SyntheticMapper INSTANCE = new SyntheticMapper();\n+\n+        private SyntheticMapper() {\n+            super(NAME_SYNTHETIC, AttributeStability.STATELESS, true);\n+        }\n+\n+        @Override\n+        public SyntheticAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSyntheticAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SyntheticAttribute attr) {\n+            \/\/ empty\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":755,"deletions":5,"binary":false,"changes":760,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static java.lang.classfile.Attributes.*;\n+\n@@ -143,1 +145,1 @@\n-            var mapper = Attributes.standardAttribute(name);\n+            var mapper = standardAttribute(name);\n@@ -892,1 +894,1 @@\n-            super(cf, Attributes.RUNTIME_INVISIBLE_ANNOTATIONS, payloadStart);\n+            super(cf, Attributes.runtimeInvisibleAnnotations(), payloadStart);\n@@ -910,1 +912,1 @@\n-            super(cf, Attributes.RUNTIME_VISIBLE_ANNOTATIONS, payloadStart);\n+            super(cf, Attributes.runtimeVisibleAnnotations(), payloadStart);\n@@ -986,0 +988,84 @@\n+\n+    \/**\n+     * {@return the attribute mapper for a standard attribute}\n+     *\n+     * @param name the name of the attribute to find\n+     *\/\n+    public static AttributeMapper<?> standardAttribute(Utf8Entry name) {\n+        \/\/ critical bootstrap path, so no lambdas nor method handles here\n+        return switch (name.hashCode()) {\n+            case 0x78147009 ->\n+                name.equalsString(NAME_ANNOTATION_DEFAULT) ? annotationDefault() : null;\n+            case 0x665e3a3a ->\n+                name.equalsString(NAME_BOOTSTRAP_METHODS) ? bootstrapMethods() : null;\n+            case 0xcb7e162 ->\n+                name.equalsString(NAME_CHARACTER_RANGE_TABLE) ? characterRangeTable() : null;\n+            case 0x21e41e7e ->\n+                name.equalsString(NAME_CODE) ? code() : null;\n+            case 0x5a306b41 ->\n+                name.equalsString(NAME_COMPILATION_ID) ? compilationId() : null;\n+            case 0x3e191c7c ->\n+                name.equalsString(NAME_CONSTANT_VALUE) ? constantValue() : null;\n+            case 0x5e88ed0c ->\n+                name.equalsString(NAME_DEPRECATED) ? deprecated() : null;\n+            case 0x7284695e ->\n+                name.equalsString(NAME_ENCLOSING_METHOD) ? enclosingMethod() : null;\n+            case 0x21df25db ->\n+                name.equalsString(NAME_EXCEPTIONS) ? exceptions() : null;\n+            case 0x11392da9 ->\n+                name.equalsString(NAME_INNER_CLASSES) ? innerClasses() : null;\n+            case 0x167536fc ->\n+                name.equalsString(NAME_LINE_NUMBER_TABLE) ? lineNumberTable() : null;\n+            case 0x46939abc ->\n+                name.equalsString(NAME_LOCAL_VARIABLE_TABLE) ? localVariableTable() : null;\n+            case 0x63ee67f4 ->\n+                name.equalsString(NAME_LOCAL_VARIABLE_TYPE_TABLE) ? localVariableTypeTable() : null;\n+            case 0x2b597e15 ->\n+                name.equalsString(NAME_METHOD_PARAMETERS) ? methodParameters() : null;\n+            case 0x19f20ade ->\n+                name.equalsString(NAME_MODULE) ? module() : null;\n+            case 0x47f6395e ->\n+                name.equalsString(NAME_MODULE_HASHES) ? moduleHashes() : null;\n+            case 0x54db809 ->\n+                name.equalsString(NAME_MODULE_MAIN_CLASS) ? moduleMainClass() : null;\n+            case 0x1abd1c2c ->\n+                name.equalsString(NAME_MODULE_PACKAGES) ? modulePackages() : null;\n+            case 0x6ba46dd ->\n+                name.equalsString(NAME_MODULE_RESOLUTION) ? moduleResolution() : null;\n+            case 0x46f7d91d ->\n+                name.equalsString(NAME_MODULE_TARGET) ? moduleTarget() : null;\n+            case 0x5137f53 ->\n+                name.equalsString(NAME_NEST_HOST) ? nestHost() : null;\n+            case 0x4a8fa3b6 ->\n+                name.equalsString(NAME_NEST_MEMBERS) ? nestMembers() : null;\n+            case 0x55c73cb6 ->\n+                name.equalsString(NAME_PERMITTED_SUBCLASSES) ? permittedSubclasses() : null;\n+            case 0x3fe76d4e ->\n+                name.equalsString(NAME_RECORD) ? record() : null;\n+            case 0x180d6925 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_ANNOTATIONS) ? runtimeInvisibleAnnotations() : null;\n+            case 0x7be22752 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS) ? runtimeInvisibleParameterAnnotations() : null;\n+            case 0x5299824 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) ? runtimeInvisibleTypeAnnotations() : null;\n+            case 0x3534786e ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_ANNOTATIONS) ? runtimeVisibleAnnotations() : null;\n+            case 0xb4b4ac6 ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS) ? runtimeVisibleParameterAnnotations() : null;\n+            case 0x6926482 ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS) ? runtimeVisibleTypeAnnotations() : null;\n+            case 0x16a42b7c ->\n+                name.equalsString(NAME_SIGNATURE) ? signature() : null;\n+            case 0x400ab245 ->\n+                name.equalsString(NAME_SOURCE_DEBUG_EXTENSION) ? sourceDebugExtension() : null;\n+            case 0x2af490d4 ->\n+                name.equalsString(NAME_SOURCE_FILE) ? sourceFile() : null;\n+            case 0x303e0c58 ->\n+                name.equalsString(NAME_SOURCE_ID) ? sourceId() : null;\n+            case 0x19c7d0cd ->\n+                name.equalsString(NAME_STACK_MAP_TABLE) ? stackMapTable() : null;\n+            case 0x3dc79b7a ->\n+                name.equalsString(NAME_SYNTHETIC) ? synthetic() : null;\n+            default -> null;\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":89,"deletions":3,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Collection;\n@@ -30,1 +29,0 @@\n-import java.util.Set;\n@@ -32,3 +30,0 @@\n-import java.util.stream.Collectors;\n-\n-import java.lang.classfile.ClassBuilder;\n@@ -39,1 +34,0 @@\n-import java.lang.classfile.AttributeMapper;\n@@ -44,1 +38,0 @@\n-import java.lang.classfile.ClassTransform;\n@@ -47,0 +40,1 @@\n+import java.lang.classfile.CustomAttribute;\n@@ -48,1 +42,0 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -53,0 +46,11 @@\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleHashesAttribute;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.attribute.ModuleTargetAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n@@ -205,1 +209,1 @@\n-        if (findAttribute(Attributes.MODULE).isEmpty())\n+        if (findAttribute(Attributes.module()).isEmpty())\n@@ -208,21 +212,14 @@\n-        Set<AttributeMapper<?>> found = attributes().stream()\n-                                                    .map(Attribute::attributeMapper)\n-                                                    .collect(Collectors.toSet());\n-\n-        found.removeAll(allowedModuleAttributes);\n-        found.retainAll(Attributes.PREDEFINED_ATTRIBUTES);\n-        return found.isEmpty();\n-    }\n-\n-    private static final Set<AttributeMapper<?>> allowedModuleAttributes\n-            = Set.of(Attributes.MODULE,\n-                     Attributes.MODULE_HASHES,\n-                     Attributes.MODULE_MAIN_CLASS,\n-                     Attributes.MODULE_PACKAGES,\n-                     Attributes.MODULE_RESOLUTION,\n-                     Attributes.MODULE_TARGET,\n-                     Attributes.INNER_CLASSES,\n-                     Attributes.SOURCE_FILE,\n-                     Attributes.SOURCE_DEBUG_EXTENSION,\n-                     Attributes.RUNTIME_VISIBLE_ANNOTATIONS,\n-                     Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+        return attributes().stream().allMatch(a ->\n+                a instanceof ModuleAttribute\n+             || a instanceof ModulePackagesAttribute\n+             || a instanceof ModuleHashesAttribute\n+             || a instanceof ModuleMainClassAttribute\n+             || a instanceof ModuleResolutionAttribute\n+             || a instanceof ModuleTargetAttribute\n+             || a instanceof InnerClassesAttribute\n+             || a instanceof SourceFileAttribute\n+             || a instanceof SourceDebugExtensionAttribute\n+             || a instanceof RuntimeVisibleAnnotationsAttribute\n+             || a instanceof RuntimeInvisibleAnnotationsAttribute\n+             || a instanceof CustomAttribute);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-                    = containedClass.findAttribute(Attributes.BOOTSTRAP_METHODS)\n+                    = containedClass.findAttribute(Attributes.bootstrapMethods())\n@@ -327,1 +327,1 @@\n-                = containedClass.findAttribute(Attributes.BOOTSTRAP_METHODS);\n+                = containedClass.findAttribute(Attributes.bootstrapMethods());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-            if (a.attributeMapper() == Attributes.LINE_NUMBER_TABLE) {\n+            if (a.attributeMapper() == Attributes.lineNumberTable()) {\n@@ -248,1 +248,1 @@\n-        Optional<StackMapTableAttribute> a = findAttribute(Attributes.STACK_MAP_TABLE);\n+        Optional<StackMapTableAttribute> a = findAttribute(Attributes.stackMapTable());\n@@ -321,2 +321,2 @@\n-        findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).ifPresent(RuntimeVisibleTypeAnnotationsAttribute::annotations);\n-        findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS).ifPresent(RuntimeInvisibleTypeAnnotationsAttribute::annotations);\n+        findAttribute(Attributes.runtimeVisibleTypeAnnotations()).ifPresent(RuntimeVisibleTypeAnnotationsAttribute::annotations);\n+        findAttribute(Attributes.runtimeInvisibleTypeAnnotations()).ifPresent(RuntimeInvisibleTypeAnnotationsAttribute::annotations);\n@@ -341,1 +341,1 @@\n-            if (a.attributeMapper() == Attributes.CHARACTER_RANGE_TABLE) {\n+            if (a.attributeMapper() == Attributes.characterRangeTable()) {\n@@ -353,1 +353,1 @@\n-            else if (a.attributeMapper() == Attributes.LOCAL_VARIABLE_TABLE) {\n+            else if (a.attributeMapper() == Attributes.localVariableTable()) {\n@@ -365,1 +365,1 @@\n-            else if (a.attributeMapper() == Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+            else if (a.attributeMapper() == Attributes.localVariableTypeTable()) {\n@@ -377,1 +377,1 @@\n-            else if (a.attributeMapper() == Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS) {\n+            else if (a.attributeMapper() == Attributes.runtimeVisibleTypeAnnotations()) {\n@@ -380,1 +380,1 @@\n-            else if (a.attributeMapper() == Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) {\n+            else if (a.attributeMapper() == Attributes.runtimeInvisibleTypeAnnotations()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.CHARACTER_RANGE_TABLE) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.characterRangeTable()) {\n@@ -265,1 +265,1 @@\n-                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TABLE) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTable()) {\n@@ -288,1 +288,1 @@\n-                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTypeTable()) {\n@@ -315,1 +315,1 @@\n-        content = new UnboundAttribute.AdHocAttribute<>(Attributes.CODE) {\n+        content = new UnboundAttribute.AdHocAttribute<>(Attributes.code()) {\n@@ -371,1 +371,1 @@\n-                            attributes.withAttribute(original.findAttribute(Attributes.STACK_MAP_TABLE).orElse(null));\n+                            attributes.withAttribute(original.findAttribute(Attributes.stackMapTable()).orElse(null));\n@@ -404,1 +404,1 @@\n-            super(Attributes.LINE_NUMBER_TABLE);\n+            super(Attributes.lineNumberTable());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        return findAttribute(Attributes.CODE).map(a -> (CodeModel) a);\n+        return findAttribute(Attributes.code()).map(a -> (CodeModel) a);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-                    = new UnboundAttribute.AdHocAttribute<>(Attributes.BOOTSTRAP_METHODS) {\n+                    = new UnboundAttribute.AdHocAttribute<>(Attributes.bootstrapMethods()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-        return frames.isEmpty() ? null : new UnboundAttribute.AdHocAttribute<>(Attributes.STACK_MAP_TABLE) {\n+        return frames.isEmpty() ? null : new UnboundAttribute.AdHocAttribute<>(Attributes.stackMapTable()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-            super(Attributes.CONSTANT_VALUE);\n+            super(Attributes.constantValue());\n@@ -167,1 +167,1 @@\n-            super(Attributes.DEPRECATED);\n+            super(Attributes.deprecated());\n@@ -175,1 +175,1 @@\n-            super(Attributes.SYNTHETIC);\n+            super(Attributes.synthetic());\n@@ -185,1 +185,1 @@\n-            super(Attributes.SIGNATURE);\n+            super(Attributes.signature());\n@@ -201,1 +201,1 @@\n-            super(Attributes.EXCEPTIONS);\n+            super(Attributes.exceptions());\n@@ -217,1 +217,1 @@\n-            super(Attributes.ANNOTATION_DEFAULT);\n+            super(Attributes.annotationDefault());\n@@ -232,1 +232,1 @@\n-            super(Attributes.SOURCE_FILE);\n+            super(Attributes.sourceFile());\n@@ -248,1 +248,1 @@\n-            super(Attributes.STACK_MAP_TABLE);\n+            super(Attributes.stackMapTable());\n@@ -264,1 +264,1 @@\n-            super(Attributes.INNER_CLASSES);\n+            super(Attributes.innerClasses());\n@@ -280,1 +280,1 @@\n-            super(Attributes.RECORD);\n+            super(Attributes.record());\n@@ -297,1 +297,1 @@\n-            super(Attributes.ENCLOSING_METHOD);\n+            super(Attributes.enclosingMethod());\n@@ -319,1 +319,1 @@\n-            super(Attributes.METHOD_PARAMETERS);\n+            super(Attributes.methodParameters());\n@@ -335,1 +335,1 @@\n-            super(Attributes.MODULE_TARGET);\n+            super(Attributes.moduleTarget());\n@@ -351,1 +351,1 @@\n-            super(Attributes.MODULE_MAIN_CLASS);\n+            super(Attributes.moduleMainClass());\n@@ -368,1 +368,1 @@\n-            super(Attributes.MODULE_HASHES);\n+            super(Attributes.moduleHashes());\n@@ -390,1 +390,1 @@\n-            super(Attributes.MODULE_PACKAGES);\n+            super(Attributes.modulePackages());\n@@ -406,1 +406,1 @@\n-            super(Attributes.MODULE_RESOLUTION);\n+            super(Attributes.moduleResolution());\n@@ -422,1 +422,1 @@\n-            super(Attributes.PERMITTED_SUBCLASSES);\n+            super(Attributes.permittedSubclasses());\n@@ -438,1 +438,1 @@\n-            super(Attributes.NEST_MEMBERS);\n+            super(Attributes.nestMembers());\n@@ -454,1 +454,1 @@\n-            super(Attributes.NEST_HOST);\n+            super(Attributes.nestHost());\n@@ -470,1 +470,1 @@\n-            super(Attributes.COMPILATION_ID);\n+            super(Attributes.compilationId());\n@@ -486,1 +486,1 @@\n-            super(Attributes.SOURCE_ID);\n+            super(Attributes.sourceId());\n@@ -502,1 +502,1 @@\n-            super(Attributes.SOURCE_DEBUG_EXTENSION);\n+            super(Attributes.sourceDebugExtension());\n@@ -518,1 +518,1 @@\n-            super(Attributes.CHARACTER_RANGE_TABLE);\n+            super(Attributes.characterRangeTable());\n@@ -534,1 +534,1 @@\n-            super(Attributes.LINE_NUMBER_TABLE);\n+            super(Attributes.lineNumberTable());\n@@ -550,1 +550,1 @@\n-            super(Attributes.LOCAL_VARIABLE_TABLE);\n+            super(Attributes.localVariableTable());\n@@ -566,1 +566,1 @@\n-            super(Attributes.LOCAL_VARIABLE_TYPE_TABLE);\n+            super(Attributes.localVariableTypeTable());\n@@ -582,1 +582,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleAnnotations());\n@@ -598,1 +598,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleAnnotations());\n@@ -614,1 +614,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleParameterAnnotations());\n@@ -630,1 +630,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleParameterAnnotations());\n@@ -646,1 +646,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleTypeAnnotations());\n@@ -662,1 +662,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleTypeAnnotations());\n@@ -848,1 +848,1 @@\n-            super(Attributes.MODULE);\n+            super(Attributes.module());\n@@ -924,1 +924,1 @@\n-            super(Attributes.BOOTSTRAP_METHODS);\n+            super(Attributes.bootstrapMethods());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.code()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-            var attro = c.findAttribute(Attributes.LOCAL_VARIABLE_TABLE);\n+            var attro = c.findAttribute(Attributes.localVariableTable());\n@@ -150,1 +150,1 @@\n-            var attro = c.findAttribute(Attributes.STACK_MAP_TABLE);\n+            var attro = c.findAttribute(Attributes.stackMapTable());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-                        mm.findAttribute(Attributes.EXCEPTIONS).ifPresent(ea ->\n+                        mm.findAttribute(Attributes.exceptions()).ifPresent(ea ->\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/FingerPrint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-                    var sigAttr = componentInfo.findAttribute(Attributes.SIGNATURE);\n+                    var sigAttr = componentInfo.findAttribute(Attributes.signature());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-        cm.findAttribute(Attributes.SOURCE_FILE).ifPresent(sfa ->\n+        cm.findAttribute(Attributes.sourceFile()).ifPresent(sfa ->\n@@ -154,1 +154,1 @@\n-            var attr = classModel.findAttribute(Attributes.MODULE);\n+            var attr = classModel.findAttribute(Attributes.module());\n@@ -181,1 +181,1 @@\n-            var sigAttr = classModel.findAttribute(Attributes.SIGNATURE).orElse(null);\n+            var sigAttr = classModel.findAttribute(Attributes.signature()).orElse(null);\n@@ -398,1 +398,1 @@\n-                f.findAttribute(Attributes.SIGNATURE)\n+                f.findAttribute(Attributes.signature())\n@@ -404,1 +404,1 @@\n-            var a = f.findAttribute(Attributes.CONSTANT_VALUE);\n+            var a = f.findAttribute(Attributes.constantValue());\n@@ -479,1 +479,1 @@\n-            var sigAttr = m.findAttribute(Attributes.SIGNATURE);\n+            var sigAttr = m.findAttribute(Attributes.signature());\n@@ -506,1 +506,1 @@\n-            var e_attr = m.findAttribute(Attributes.EXCEPTIONS);\n+            var e_attr = m.findAttribute(Attributes.exceptions());\n@@ -558,1 +558,1 @@\n-                code.findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                code.findAttribute(Attributes.lineNumberTable())\n@@ -560,1 +560,1 @@\n-                code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE)\n+                code.findAttribute(Attributes.localVariableTable())\n@@ -588,1 +588,1 @@\n-        var attr = classModel.findAttribute(Attributes.MODULE);\n+        var attr = classModel.findAttribute(Attributes.module());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -677,1 +677,1 @@\n-            var a = cm.findAttribute(java.lang.classfile.Attributes.INNER_CLASSES);\n+            var a = cm.findAttribute(java.lang.classfile.Attributes.innerClasses());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        var lvt = attr.findAttribute(Attributes.LOCAL_VARIABLE_TABLE);\n+        var lvt = attr.findAttribute(Attributes.localVariableTable());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/LocalVariableTableWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        var lvt = attr.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE);\n+        var lvt = attr.findAttribute(Attributes.localVariableTypeTable());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/LocalVariableTypeTableWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        for (var t : attr.findAttributes(Attributes.LINE_NUMBER_TABLE)) {\n+        for (var t : attr.findAttributes(Attributes.lineNumberTable())) {\n@@ -148,1 +148,1 @@\n-            var sf = cf.findAttribute(Attributes.SOURCE_FILE);\n+            var sf = cf.findAttribute(Attributes.sourceFile());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/SourceWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        StackMapTableAttribute attr = code.findAttribute(Attributes.STACK_MAP_TABLE)\n+        StackMapTableAttribute attr = code.findAttribute(Attributes.stackMapTable())\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/StackMapWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                m.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS)\n+                m.findAttribute(Attributes.runtimeVisibleTypeAnnotations())\n@@ -82,1 +82,1 @@\n-                m.findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS)\n+                m.findAttribute(Attributes.runtimeInvisibleTypeAnnotations())\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/TypeAnnotationWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-                cm.findAttribute(Attributes.CODE).ifPresent(codeAttr -> {\n+                cm.findAttribute(Attributes.code()).ifPresent(codeAttr -> {\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                for (var a : m.findAttributes(Attributes.CODE)) {\n+                for (var a : m.findAttributes(Attributes.code())) {\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-            remapped.fields().forEach(f -> f.findAttribute(Attributes.SIGNATURE).ifPresent(sa ->\n+            remapped.fields().forEach(f -> f.findAttribute(Attributes.signature()).ifPresent(sa ->\n@@ -125,1 +125,1 @@\n-            remapped.methods().forEach(m -> m.findAttribute(Attributes.SIGNATURE).ifPresent(sa -> {\n+            remapped.methods().forEach(m -> m.findAttribute(Attributes.signature()).ifPresent(sa -> {\n@@ -176,1 +176,1 @@\n-                                                mab.uses(foo).provides(foo, foo)))))).findAttribute(Attributes.MODULE).get();\n+                                                mab.uses(foo).provides(foo, foo)))))).findAttribute(Attributes.module()).get();\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        var annotations = model.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get().annotations();\n+        var annotations = model.findAttribute(Attributes.runtimeVisibleAnnotations()).get().annotations();\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationModelTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331291\n+ * @summary Testing Attributes API.\n+ * @run junit AttributesTest\n+ *\/\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.reflect.Field;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+\n+class AttributesTest {\n+\n+    @Test\n+    void testAttributesMapping() throws Exception {\n+        var cp = TemporaryConstantPool.INSTANCE;\n+        for (Field f : Attributes.class.getDeclaredFields()) {\n+            if (f.getName().startsWith(\"NAME_\") && f.getType() == String.class) {\n+                Utf8Entry attrName = cp.utf8Entry((String)f.get(null));\n+                AttributeMapper<?> mapper = BoundAttribute.standardAttribute(attrName);\n+                assertNotNull(mapper, attrName.stringValue() + \" 0x\" + Integer.toHexString(attrName.hashCode()));\n+                assertEquals(attrName.stringValue(), mapper.name());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/AttributesTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-                .findAttribute(Attributes.METHOD_PARAMETERS)\n+                .findAttribute(Attributes.methodParameters())\n","filename":"test\/jdk\/jdk\/classfile\/BoundAttributeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                case LineNumber ln -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LINE_NUMBER_TABLE) {\n+                case LineNumber ln -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.lineNumberTable()) {\n@@ -94,1 +94,1 @@\n-                case LocalVariable lv -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TABLE) {\n+                case LocalVariable lv -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTable()) {\n@@ -101,1 +101,1 @@\n-                case LocalVariableType lvt -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+                case LocalVariableType lvt -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTypeTable()) {\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,3 +69,3 @@\n-        code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).ifPresent(a -> assertTrue(a.localVariables().isEmpty()));\n-        code.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).ifPresent(a -> assertTrue(a.localVariableTypes().isEmpty()));\n-        code.findAttribute(Attributes.CHARACTER_RANGE_TABLE).ifPresent(a -> assertTrue(a.characterRangeTable().isEmpty()));\n+        code.findAttribute(Attributes.localVariableTable()).ifPresent(a -> assertTrue(a.localVariables().isEmpty()));\n+        code.findAttribute(Attributes.localVariableTypeTable()).ifPresent(a -> assertTrue(a.localVariableTypes().isEmpty()));\n+        code.findAttribute(Attributes.characterRangeTable()).ifPresent(a -> assertTrue(a.characterRangeTable().isEmpty()));\n","filename":"test\/jdk\/jdk\/classfile\/FilterDeadLabelsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-            m.findAttribute(Attributes.CODE).ifPresent(code ->\n-                ((CodeModel) code).findAttribute(Attributes.CHARACTER_RANGE_TABLE).ifPresent(attr -> {\n+            m.findAttribute(Attributes.code()).ifPresent(code ->\n+                ((CodeModel) code).findAttribute(Attributes.characterRangeTable()).ifPresent(attr -> {\n@@ -159,1 +159,1 @@\n-\/\/            m.findAttribute(Attributes.CODE).ifPresent(code ->\n+\/\/            m.findAttribute(Attributes.code()).ifPresent(code ->\n","filename":"test\/jdk\/jdk\/classfile\/LowJCovAttributeTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-        var lvt = main.code().get().findAttribute(Attributes.LOCAL_VARIABLE_TABLE).get();\n+        var lvt = main.code().get().findAttribute(Attributes.localVariableTable()).get();\n@@ -281,1 +281,1 @@\n-        var lvtt = main.code().get().findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).get();\n+        var lvtt = main.code().get().findAttribute(Attributes.localVariableTypeTable()).get();\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        if (cm.findAttribute(Attributes.RECORD).isPresent()) {\n+        if (cm.findAttribute(Attributes.record()).isPresent()) {\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyPrimitiveMatchCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                .filter(a -> a.attributeMapper() == Attributes.MODULE)\n+                .filter(a -> a.attributeMapper() == Attributes.module())\n@@ -106,1 +106,1 @@\n-        var attr =cm.findAttribute(Attributes.MODULE).get();\n+        var attr =cm.findAttribute(Attributes.module()).get();\n@@ -184,1 +184,1 @@\n-        ModulePackagesAttribute a = moduleModel.findAttribute(Attributes.MODULE_PACKAGES).orElseThrow();\n+        ModulePackagesAttribute a = moduleModel.findAttribute(Attributes.modulePackages()).orElseThrow();\n@@ -190,1 +190,1 @@\n-        ModuleMainClassAttribute a = moduleModel.findAttribute(Attributes.MODULE_MAIN_CLASS).orElseThrow();\n+        ModuleMainClassAttribute a = moduleModel.findAttribute(Attributes.moduleMainClass()).orElseThrow();\n","filename":"test\/jdk\/jdk\/classfile\/ModuleBuilderTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-                cm.findAttribute(Attributes.SIGNATURE).ifPresent(csig -> {\n+                cm.findAttribute(Attributes.signature()).ifPresent(csig -> {\n@@ -144,1 +144,1 @@\n-                    m.findAttribute(Attributes.SIGNATURE).ifPresent(msig -> {\n+                    m.findAttribute(Attributes.signature()).ifPresent(msig -> {\n@@ -153,1 +153,1 @@\n-                    f.findAttribute(Attributes.SIGNATURE).ifPresent(fsig -> {\n+                    f.findAttribute(Attributes.signature()).ifPresent(fsig -> {\n@@ -161,2 +161,2 @@\n-                cm.findAttribute(Attributes.RECORD).ifPresent(reca\n-                        -> reca.components().forEach(rc -> rc.findAttribute(Attributes.SIGNATURE).ifPresent(rsig -> {\n+                cm.findAttribute(Attributes.record()).ifPresent(reca\n+                        -> reca.components().forEach(rc -> rc.findAttribute(Attributes.signature()).ifPresent(rsig -> {\n@@ -185,1 +185,1 @@\n-        var sig = observerCf.findAttribute(Attributes.SIGNATURE).orElseThrow().asClassSignature();\n+        var sig = observerCf.findAttribute(Attributes.signature()).orElseThrow().asClassSignature();\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-        RecordAttribute ra = newModel.findAttribute(Attributes.RECORD).orElseThrow();\n+        RecordAttribute ra = newModel.findAttribute(Attributes.record()).orElseThrow();\n@@ -113,1 +113,1 @@\n-        assertEquals(cm.findAttribute(Attributes.RECORD).orElseThrow().components().size(), 2);\n+        assertEquals(cm.findAttribute(Attributes.record()).orElseThrow().components().size(), 2);\n","filename":"test\/jdk\/jdk\/classfile\/TestRecordComponent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,2 +57,3 @@\n-        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        var rvaa = m.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -71,3 +72,3 @@\n-\n-        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        var rvaa = m.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -81,3 +82,3 @@\n-\n-        if (m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        rvaa = m2.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -115,3 +116,3 @@\n-\n-        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        var rvaa = m.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -138,1 +139,1 @@\n-        int size = m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow().annotations().size();\n+        int size = m2.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow().annotations().size();\n","filename":"test\/jdk\/jdk\/classfile\/examples\/AnnotationsExamples.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        ModuleAttribute ma = cm.findAttribute(Attributes.MODULE).orElseThrow();\n+        ModuleAttribute ma = cm.findAttribute(Attributes.module()).orElseThrow();\n@@ -61,1 +61,1 @@\n-        ModuleMainClassAttribute mmca = cm.findAttribute(Attributes.MODULE_MAIN_CLASS).orElse(null);\n+        ModuleMainClassAttribute mmca = cm.findAttribute(Attributes.moduleMainClass()).orElse(null);\n@@ -64,1 +64,1 @@\n-        ModulePackagesAttribute mmp = cm.findAttribute(Attributes.MODULE_PACKAGES).orElseThrow();\n+        ModulePackagesAttribute mmp = cm.findAttribute(Attributes.modulePackages()).orElseThrow();\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ModuleExamples.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-                    mapAttr(attrs, ANNOTATION_DEFAULT, a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n+                    mapAttr(attrs, annotationDefault(), a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n@@ -248,18 +248,18 @@\n-                    mapAttr(attrs, CODE, a -> CodeRecord.ofStreamingElements(a.maxStack(), a.maxLocals(), a.codeLength(), a::elementStream, a, new CodeNormalizerHelper(a.codeArray()), cf)),\n-                    mapAttr(attrs, COMPILATION_ID, a -> a.compilationId().stringValue()),\n-                    mapAttr(attrs, CONSTANT_VALUE, a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n-                    mapAttr(attrs, DEPRECATED, a -> DefinedValue.DEFINED),\n-                    mapAttr(attrs, ENCLOSING_METHOD, a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n-                    mapAttr(attrs, EXCEPTIONS, a -> new HashSet<>(a.exceptions().stream().map(e -> e.asInternalName()).toList())),\n-                    mapAttr(attrs, INNER_CLASSES, a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n-                    mapAttr(attrs, METHOD_PARAMETERS, a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n-                    mapAttr(attrs, MODULE, a -> ModuleRecord.ofModuleAttribute(a)),\n-                    mapAttr(attrs, MODULE_HASHES, a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n-                    mapAttr(attrs, MODULE_MAIN_CLASS, a -> a.mainClass().asInternalName()),\n-                    mapAttr(attrs, MODULE_PACKAGES, a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n-                    mapAttr(attrs, MODULE_RESOLUTION, a -> a.resolutionFlags()),\n-                    mapAttr(attrs, MODULE_TARGET, a -> a.targetPlatform().stringValue()),\n-                    mapAttr(attrs, NEST_HOST, a -> a.nestHost().asInternalName()),\n-                    mapAttr(attrs, NEST_MEMBERS, a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n-                    mapAttr(attrs, PERMITTED_SUBCLASSES, a -> new HashSet<>(a.permittedSubclasses().stream().map(e -> e.asInternalName()).toList())),\n-                    mapAttr(attrs, RECORD, a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n+                    mapAttr(attrs, code(), a -> CodeRecord.ofStreamingElements(a.maxStack(), a.maxLocals(), a.codeLength(), a::elementStream, a, new CodeNormalizerHelper(a.codeArray()), cf)),\n+                    mapAttr(attrs, compilationId(), a -> a.compilationId().stringValue()),\n+                    mapAttr(attrs, constantValue(), a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n+                    mapAttr(attrs, Attributes.deprecated(), a -> DefinedValue.DEFINED),\n+                    mapAttr(attrs, enclosingMethod(), a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n+                    mapAttr(attrs, exceptions(), a -> new HashSet<>(a.exceptions().stream().map(e -> e.asInternalName()).toList())),\n+                    mapAttr(attrs, innerClasses(), a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n+                    mapAttr(attrs, methodParameters(), a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n+                    mapAttr(attrs, module(), a -> ModuleRecord.ofModuleAttribute(a)),\n+                    mapAttr(attrs, moduleHashes(), a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n+                    mapAttr(attrs, moduleMainClass(), a -> a.mainClass().asInternalName()),\n+                    mapAttr(attrs, modulePackages(), a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n+                    mapAttr(attrs, moduleResolution(), a -> a.resolutionFlags()),\n+                    mapAttr(attrs, moduleTarget(), a -> a.targetPlatform().stringValue()),\n+                    mapAttr(attrs, nestHost(), a -> a.nestHost().asInternalName()),\n+                    mapAttr(attrs, nestMembers(), a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n+                    mapAttr(attrs, permittedSubclasses(), a -> new HashSet<>(a.permittedSubclasses().stream().map(e -> e.asInternalName()).toList())),\n+                    mapAttr(attrs, record(), a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n@@ -270,9 +270,9 @@\n-                    mapAttr(attrs, RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    mapAttr(attrs, RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    mapAttr(attrs, RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    mapAttr(attrs, RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    mapAttr(attrs, SIGNATURE, a -> a.signature().stringValue()),\n-                    mapAttr(attrs, SOURCE_DEBUG_EXTENSION, a -> new String(a.contents(), StandardCharsets.UTF_8)),\n-                    mapAttr(attrs, SOURCE_FILE, a -> a.sourceFile().stringValue()),\n-                    mapAttr(attrs, SOURCE_ID, a -> a.sourceId().stringValue()),\n-                    mapAttr(attrs, SYNTHETIC, a -> DefinedValue.DEFINED)\n+                    mapAttr(attrs, runtimeVisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    mapAttr(attrs, runtimeInvisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    mapAttr(attrs, runtimeVisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    mapAttr(attrs, runtimeInvisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    mapAttr(attrs, signature(), a -> a.signature().stringValue()),\n+                    mapAttr(attrs, sourceDebugExtension(), a -> new String(a.contents(), StandardCharsets.UTF_8)),\n+                    mapAttr(attrs, sourceFile(), a -> a.sourceFile().stringValue()),\n+                    mapAttr(attrs, sourceId(), a -> a.sourceId().stringValue()),\n+                    mapAttr(attrs, synthetic(), a -> DefinedValue.DEFINED)\n@@ -284,31 +284,31 @@\n-                    af.findAndMap(Attributes.ANNOTATION_DEFAULT, a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n-                    af.findAndMap(Attributes.BOOTSTRAP_METHODS, a -> a.bootstrapMethods().stream().map(bm -> BootstrapMethodRecord.ofBootstrapMethodEntry(bm)).collect(toSet())),\n-                    af.findAndMap(Attributes.CODE, a -> CodeRecord.ofCodeAttribute(a, cf)),\n-                    af.findAndMap(Attributes.COMPILATION_ID, a -> a.compilationId().stringValue()),\n-                    af.findAndMap(Attributes.CONSTANT_VALUE, a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n-                    af.findAndMap(Attributes.DEPRECATED, a -> DefinedValue.DEFINED),\n-                    af.findAndMap(Attributes.ENCLOSING_METHOD, a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n-                    af.findAndMap(Attributes.EXCEPTIONS, a -> a.exceptions().stream().map(e -> e.asInternalName()).collect(toSet())),\n-                    af.findAndMap(Attributes.INNER_CLASSES, a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n-                    af.findAndMap(Attributes.METHOD_PARAMETERS, a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n-                    af.findAndMap(Attributes.MODULE, a -> ModuleRecord.ofModuleAttribute(a)),\n-                    af.findAndMap(Attributes.MODULE_HASHES, a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n-                    af.findAndMap(Attributes.MODULE_MAIN_CLASS, a -> a.mainClass().asInternalName()),\n-                    af.findAndMap(Attributes.MODULE_PACKAGES, a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n-                    af.findAndMap(Attributes.MODULE_RESOLUTION, a -> a.resolutionFlags()),\n-                    af.findAndMap(Attributes.MODULE_TARGET, a -> a.targetPlatform().stringValue()),\n-                    af.findAndMap(Attributes.NEST_HOST, a -> a.nestHost().asInternalName()),\n-                    af.findAndMap(Attributes.NEST_MEMBERS, a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n-                    af.findAndMap(Attributes.PERMITTED_SUBCLASSES, a -> a.permittedSubclasses().stream().map(e -> e.asInternalName()).collect(toSet())),\n-                    af.findAndMap(RECORD, a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n-                    af.findAll(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n-                    af.findAll(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n-                    af.findAndMap(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    af.findAndMap(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    af.findAndMap(Attributes.SIGNATURE, a -> a.signature().stringValue()),\n-                    af.findAndMap(Attributes.SOURCE_DEBUG_EXTENSION, a -> new String(a.contents(), StandardCharsets.UTF_8)),\n-                    af.findAndMap(Attributes.SOURCE_FILE, a -> a.sourceFile().stringValue()),\n-                    af.findAndMap(Attributes.SOURCE_ID, a -> a.sourceId().stringValue()),\n-                    af.findAndMap(Attributes.SYNTHETIC, a -> DefinedValue.DEFINED));\n+                    af.findAndMap(annotationDefault(), a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n+                    af.findAndMap(bootstrapMethods(), a -> a.bootstrapMethods().stream().map(bm -> BootstrapMethodRecord.ofBootstrapMethodEntry(bm)).collect(toSet())),\n+                    af.findAndMap(code(), a -> CodeRecord.ofCodeAttribute(a, cf)),\n+                    af.findAndMap(compilationId(), a -> a.compilationId().stringValue()),\n+                    af.findAndMap(constantValue(), a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n+                    af.findAndMap(Attributes.deprecated(), a -> DefinedValue.DEFINED),\n+                    af.findAndMap(enclosingMethod(), a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n+                    af.findAndMap(exceptions(), a -> a.exceptions().stream().map(e -> e.asInternalName()).collect(toSet())),\n+                    af.findAndMap(innerClasses(), a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n+                    af.findAndMap(methodParameters(), a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n+                    af.findAndMap(module(), a -> ModuleRecord.ofModuleAttribute(a)),\n+                    af.findAndMap(moduleHashes(), a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n+                    af.findAndMap(moduleMainClass(), a -> a.mainClass().asInternalName()),\n+                    af.findAndMap(modulePackages(), a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n+                    af.findAndMap(moduleResolution(), a -> a.resolutionFlags()),\n+                    af.findAndMap(moduleTarget(), a -> a.targetPlatform().stringValue()),\n+                    af.findAndMap(nestHost(), a -> a.nestHost().asInternalName()),\n+                    af.findAndMap(nestMembers(), a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n+                    af.findAndMap(permittedSubclasses(), a -> a.permittedSubclasses().stream().map(e -> e.asInternalName()).collect(toSet())),\n+                    af.findAndMap(record(), a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n+                    af.findAll(runtimeVisibleAnnotations()).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    af.findAll(runtimeInvisibleAnnotations()).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    af.findAndMap(runtimeVisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    af.findAndMap(runtimeInvisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    af.findAndMap(runtimeVisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    af.findAndMap(runtimeInvisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    af.findAndMap(signature(), a -> a.signature().stringValue()),\n+                    af.findAndMap(sourceDebugExtension(), a -> new String(a.contents(), StandardCharsets.UTF_8)),\n+                    af.findAndMap(sourceFile(), a -> a.sourceFile().stringValue()),\n+                    af.findAndMap(sourceId(), a -> a.sourceId().stringValue()),\n+                    af.findAndMap(synthetic(), a -> DefinedValue.DEFINED));\n@@ -356,6 +356,6 @@\n-                    af.findAll(Attributes.CHARACTER_RANGE_TABLE).flatMap(a -> a.characterRangeTable().stream()).map(cr -> CharacterRangeRecord.ofCharacterRange(cr, code)).collect(toSetOrNull()),\n-                    af.findAll(Attributes.LINE_NUMBER_TABLE).flatMap(a -> a.lineNumbers().stream()).map(ln -> new LineNumberRecord(ln.lineNumber(), code.targetIndex(ln.startPc()))).collect(toSetOrNull()),\n-                    af.findAll(Attributes.LOCAL_VARIABLE_TABLE).flatMap(a -> a.localVariables().stream()).map(lv -> LocalVariableRecord.ofLocalVariableInfo(lv, code)).collect(toSetOrNull()),\n-                    af.findAll(Attributes.LOCAL_VARIABLE_TYPE_TABLE).flatMap(a -> a.localVariableTypes().stream()).map(lv -> LocalVariableTypeRecord.ofLocalVariableTypeInfo(lv, code)).collect(toSetOrNull()),\n-                    af.findAndMap(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())),\n-                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())));\n+                    af.findAll(Attributes.characterRangeTable()).flatMap(a -> a.characterRangeTable().stream()).map(cr -> CharacterRangeRecord.ofCharacterRange(cr, code)).collect(toSetOrNull()),\n+                    af.findAll(Attributes.lineNumberTable()).flatMap(a -> a.lineNumbers().stream()).map(ln -> new LineNumberRecord(ln.lineNumber(), code.targetIndex(ln.startPc()))).collect(toSetOrNull()),\n+                    af.findAll(Attributes.localVariableTable()).flatMap(a -> a.localVariables().stream()).map(lv -> LocalVariableRecord.ofLocalVariableInfo(lv, code)).collect(toSetOrNull()),\n+                    af.findAll(Attributes.localVariableTypeTable()).flatMap(a -> a.localVariableTypes().stream()).map(lv -> LocalVariableTypeRecord.ofLocalVariableTypeInfo(lv, code)).collect(toSetOrNull()),\n+                    af.findAndMap(Attributes.runtimeVisibleTypeAnnotations(), a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())),\n+                    af.findAndMap(Attributes.runtimeInvisibleTypeAnnotations(), a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                                                com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(cob4::with);\n+                                                com.findAttribute(Attributes.stackMapTable()).ifPresent(cob4::with);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-            SourceFileAttribute sfa = cf.findAttribute(Attributes.SOURCE_FILE).orElseThrow();\n+            SourceFileAttribute sfa = cf.findAttribute(Attributes.sourceFile()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/4241573\/T4241573.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,4 +107,4 @@\n-        RuntimeInvisibleParameterAnnotationsAttribute invAttr = method.findAttribute(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS).orElse(null);\n-        checkNull(invAttr, String.format(\"%s should be null\", Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS));\n-        RuntimeVisibleParameterAnnotationsAttribute vAttr = method.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS).orElse(null);\n-        checkNull(vAttr, String.format(\"%s should be null\", Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS));\n+        RuntimeInvisibleParameterAnnotationsAttribute invAttr = method.findAttribute(Attributes.runtimeInvisibleParameterAnnotations()).orElse(null);\n+        checkNull(invAttr, String.format(\"%s should be null\", Attributes.runtimeInvisibleParameterAnnotations()));\n+        RuntimeVisibleParameterAnnotationsAttribute vAttr = method.findAttribute(Attributes.runtimeVisibleParameterAnnotations()).orElse(null);\n+        checkNull(vAttr, String.format(\"%s should be null\", Attributes.runtimeVisibleParameterAnnotations()));\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/annotations\/RuntimeParameterAnnotationsForLambdaTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-            DeprecatedAttribute attr = cm.findAttribute(Attributes.DEPRECATED).orElse(null);\n+            DeprecatedAttribute attr = cm.findAttribute(Attributes.deprecated()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/deprecated\/DeprecatedPackageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        assertNull(classModel.findAttribute(Attributes.INNER_CLASSES).orElse(null), \"Found inner class attribute\");\n+        assertNull(classModel.findAttribute(Attributes.innerClasses()).orElse(null), \"Found inner class attribute\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/NoInnerClassesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        ModuleAttribute module = clazz.findAttribute(Attributes.MODULE).get();\n+        ModuleAttribute module = clazz.findAttribute(Attributes.module()).get();\n","filename":"test\/langtools\/tools\/javac\/platform\/ModuleVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.runtimeVisibleTypeAnnotations());\n+        test(m, Attributes.runtimeInvisibleTypeAnnotations());\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/JSR175Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-        test(mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(mm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(mm, Attributes.runtimeVisibleTypeAnnotations());\n+        test(mm, Attributes.runtimeInvisibleTypeAnnotations());\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/Visibility.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}