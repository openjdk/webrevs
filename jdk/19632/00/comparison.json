{"files":[{"patch":"@@ -7684,1 +7684,1 @@\n-    state = get_state_from_digest_object(digestBase_obj, T_BYTE);\n+    state = get_state_from_digest_object(digestBase_obj, T_LONG);\n@@ -7784,1 +7784,1 @@\n-      elem_type = T_BYTE;\n+      elem_type = T_LONG;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    private final int blockSize;\n+    protected final int blockSize;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DigestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    private static final int DM = 5; \/\/ dimension of lanes\n+    private static final int DM = 5; \/\/ dimension of state matrix\n@@ -68,2 +68,6 @@\n-    private byte[] state = new byte[WIDTH];\n-    private long[] lanes = new long[DM*DM];\n+    private long[] state = new long[DM*DM];\n+\n+    \/\/ The following two arrays are allocated to size WIDTH bytes, but we only\n+    \/\/ ever use the first blockSize bytes of them (for bytes <-> long conversions)\n+    private byte[] byteState = new byte[WIDTH];\n+    private long[] longBuf = new long[DM*DM];\n@@ -94,4 +98,6 @@\n-       for (int i = 0; i < buffer.length; i++) {\n-           state[i] ^= b[ofs++];\n-       }\n-       keccak();\n+        b2lLittle(b, ofs, longBuf, 0, blockSize);\n+        for (int i = 0; i < blockSize \/ 8; i++) {\n+            state[i] ^= longBuf[i];\n+        }\n+\n+        keccak();\n@@ -114,1 +120,1 @@\n-            System.arraycopy(state, 0, out, ofs, availableBytes);\n+            l2bLittle(state, 0, out, ofs, availableBytes);\n@@ -119,1 +125,3 @@\n-        System.arraycopy(state, 0, out, ofs, numBytes);\n+        int numLongs = (numBytes + 7) \/ 8;\n+        l2bLittle(state, 0, byteState, 0, numLongs * 8);\n+        System.arraycopy(byteState, 0, out, ofs, numBytes);\n@@ -126,2 +134,1 @@\n-        Arrays.fill(state, (byte)0);\n-        Arrays.fill(lanes, 0L);\n+        Arrays.fill(state,0L);\n@@ -147,24 +154,0 @@\n-    \/**\n-     * Utility function for transforming the specified byte array 's'\n-     * into array of lanes 'm' as defined in section 3.1.2.\n-     *\/\n-    private static void bytes2Lanes(byte[] s, long[] m) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            b2lLittle(s, sOfs, m, DM*y, 40);\n-        }\n-    }\n-\n-    \/**\n-     * Utility function for transforming the specified array of\n-     * lanes 'm' into a byte array 's' as defined in section 3.1.3.\n-     *\/\n-    private static void lanes2Bytes(long[] m, byte[] s) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            l2bLittle(m, DM*y, s, sOfs, 40);\n-        }\n-    }\n-\n@@ -176,3 +159,0 @@\n-        \/\/ convert the 200-byte state into 25 lanes\n-        bytes2Lanes(state, lanes);\n-\n@@ -182,5 +162,5 @@\n-        a0 = lanes[0]; a1 = lanes[1]; a2 = lanes[2]; a3 = lanes[3]; a4 = lanes[4];\n-        a5 = lanes[5]; a6 = lanes[6]; a7 = lanes[7]; a8 = lanes[8]; a9 = lanes[9];\n-        a10 = lanes[10]; a11 = lanes[11]; a12 = lanes[12]; a13 = lanes[13]; a14 = lanes[14];\n-        a15 = lanes[15]; a16 = lanes[16]; a17 = lanes[17]; a18 = lanes[18]; a19 = lanes[19];\n-        a20 = lanes[20]; a21 = lanes[21]; a22 = lanes[22]; a23 = lanes[23]; a24 = lanes[24];\n+        a0 = state[0]; a1 = state[1]; a2 = state[2]; a3 = state[3]; a4 = state[4];\n+        a5 = state[5]; a6 = state[6]; a7 = state[7]; a8 = state[8]; a9 = state[9];\n+        a10 = state[10]; a11 = state[11]; a12 = state[12]; a13 = state[13]; a14 = state[14];\n+        a15 = state[15]; a16 = state[16]; a17 = state[17]; a18 = state[18]; a19 = state[19];\n+        a20 = state[20]; a21 = state[21]; a22 = state[22]; a23 = state[23]; a24 = state[24];\n@@ -290,8 +270,5 @@\n-        lanes[0] = a0; lanes[1] = a1; lanes[2] = a2; lanes[3] = a3; lanes[4] = a4;\n-        lanes[5] = a5; lanes[6] = a6; lanes[7] = a7; lanes[8] = a8; lanes[9] = a9;\n-        lanes[10] = a10; lanes[11] = a11; lanes[12] = a12; lanes[13] = a13; lanes[14] = a14;\n-        lanes[15] = a15; lanes[16] = a16; lanes[17] = a17; lanes[18] = a18; lanes[19] = a19;\n-        lanes[20] = a20; lanes[21] = a21; lanes[22] = a22; lanes[23] = a23; lanes[24] = a24;\n-\n-        \/\/ convert the resulting 25 lanes back into 200-byte state\n-        lanes2Bytes(lanes, state);\n+        state[0] = a0; state[1] = a1; state[2] = a2; state[3] = a3; state[4] = a4;\n+        state[5] = a5; state[6] = a6; state[7] = a7; state[8] = a8; state[9] = a9;\n+        state[10] = a10; state[11] = a11; state[12] = a12; state[13] = a13; state[14] = a14;\n+        state[15] = a15; state[16] = a16; state[17] = a17; state[18] = a18; state[19] = a19;\n+        state[20] = a20; state[21] = a21; state[22] = a22; state[23] = a23; state[24] = a24;\n@@ -303,1 +280,0 @@\n-        copy.lanes = new long[DM*DM];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":28,"deletions":52,"binary":false,"changes":80,"status":"modified"}]}