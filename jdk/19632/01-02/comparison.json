{"files":[{"patch":"@@ -71,4 +71,0 @@\n-    \/\/ The following array is allocated to size WIDTH bytes, but we only\n-    \/\/ ever use the first blockSize bytes it (for bytes <-> long conversions)\n-    private byte[] byteState = new byte[WIDTH];\n-\n@@ -115,0 +111,1 @@\n+        byte[] byteState = new byte[8];\n@@ -116,1 +113,1 @@\n-            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % buffer.length));\n+            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % blockSize));\n@@ -121,1 +118,1 @@\n-        int availableBytes = buffer.length;\n+        int availableBytes = blockSize; \/\/ i.e. buffer.length\n@@ -133,5 +130,6 @@\n-        if (numLongs == numBytes * 8) {\n-            for (int i = 0; i < numLongs; i++) {\n-                asLittleEndian.set(out, ofs, state[i]);\n-                ofs += 8;\n-            }\n+        for (int i = 0; i < numLongs - 1; i++) {\n+            asLittleEndian.set(out, ofs, state[i]);\n+            ofs += 8;\n+        }\n+        if (numBytes == numLongs * 8) {\n+            asLittleEndian.set(out, ofs, state[numLongs - 1]);\n@@ -139,6 +137,3 @@\n-            int o = 0;\n-            for (int i = 0; i < numLongs; i++) {\n-                asLittleEndian.set(byteState, o, state[i]);\n-                o += 8;\n-            }\n-            System.arraycopy(byteState, 0, out, ofs, numBytes);\n+            asLittleEndian.set(byteState, 0, state[numLongs - 1]);\n+            System.arraycopy(byteState, 0,\n+                    out, ofs, numBytes - (numLongs - 1) * 8);\n@@ -152,1 +147,1 @@\n-        Arrays.fill(state,0L);\n+        Arrays.fill(state, 0L);\n@@ -298,1 +293,0 @@\n-        copy.byteState = copy.byteState.clone();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"}]}