{"files":[{"patch":"@@ -351,2 +351,0 @@\n-  assert(assertion_predicate_has_loop_opaque_node(template_success_proj->in(0)->as_If()),\n-         \"must find Assertion Predicate for fast loop\");\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1315,74 +1315,0 @@\n-#ifdef ASSERT\n-bool PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(IfNode* iff) {\n-  uint init;\n-  uint stride;\n-  count_opaque_loop_nodes(iff->in(1)->in(1), init, stride);\n-  ResourceMark rm;\n-  Unique_Node_List wq;\n-  wq.clear();\n-  wq.push(iff->in(1)->in(1));\n-  uint verif_init = 0;\n-  uint verif_stride = 0;\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    int op = n->Opcode();\n-    if (!n->is_CFG()) {\n-      if (n->Opcode() == Op_OpaqueLoopInit) {\n-        verif_init++;\n-      } else if (n->Opcode() == Op_OpaqueLoopStride) {\n-        verif_stride++;\n-      } else {\n-        for (uint j = 1; j < n->req(); j++) {\n-          Node* m = n->in(j);\n-          if (m != nullptr) {\n-            wq.push(m);\n-          }\n-        }\n-      }\n-    }\n-  }\n-  assert(init == verif_init && stride == verif_stride, \"missed opaque node\");\n-  assert(stride == 0 || init != 0, \"init should be there every time stride is\");\n-  return init != 0;\n-}\n-\n-void PhaseIdealLoop::count_opaque_loop_nodes(Node* n, uint& init, uint& stride) {\n-  init = 0;\n-  stride = 0;\n-  ResourceMark rm;\n-  Unique_Node_List wq;\n-  wq.push(n);\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    if (TemplateAssertionExpressionNode::is_maybe_in_expression(n)) {\n-      if (n->is_OpaqueLoopInit()) {\n-        init++;\n-      } else if (n->is_OpaqueLoopStride()) {\n-        stride++;\n-      } else {\n-        for (uint j = 1; j < n->req(); j++) {\n-          Node* m = n->in(j);\n-          if (m != nullptr) {\n-            wq.push(m);\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ ASSERT\n-\n-\/\/ Create an Initialized Assertion Predicate from the template_assertion_predicate\n-IfTrueNode* PhaseIdealLoop::create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                                   Node* new_stride, Node* new_control) {\n-  assert(assertion_predicate_has_loop_opaque_node(template_assertion_predicate),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(this);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(template_assertion_predicate,\n-                                                                                  new_control, new_init, new_stride);\n-\n-  assert(!assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n-  return success_proj;\n-}\n-\n@@ -1830,6 +1756,2 @@\n-  Node* init = target_loop_head->init_trip();\n-  Node* stride = target_loop_head->stride();\n-  LoopNode* target_outer_loop_head = target_loop_head->skip_strip_mined();\n-  Node* target_loop_entry = target_outer_loop_head->in(LoopNode::EntryControl);\n-  CreateAssertionPredicatesVisitor create_assertion_predicates_visitor(init, stride, target_loop_entry, this,\n-                                                                       _node_in_loop_body, clone_template);\n+  CreateAssertionPredicatesVisitor create_assertion_predicates_visitor(target_loop_head, this, _node_in_loop_body,\n+                                                                       clone_template);\n@@ -1839,5 +1761,0 @@\n-  if (create_assertion_predicates_visitor.has_created_predicates()) {\n-    IfTrueNode* last_created_predicate_success_proj = create_assertion_predicates_visitor.last_created_success_proj();\n-    _igvn.replace_input_of(target_outer_loop_head, LoopNode::EntryControl, last_created_predicate_success_proj);\n-    set_idom(target_outer_loop_head, last_created_predicate_success_proj, dom_depth(target_outer_loop_head));\n-  }\n@@ -2764,1 +2681,0 @@\n-            assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -2772,1 +2688,0 @@\n-          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -2778,1 +2693,0 @@\n-          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":88,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -944,4 +944,0 @@\n- public:\n-  IfTrueNode* create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n-                                                     Node* new_stride, Node* control);\n-  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n@@ -949,1 +945,0 @@\n-  DEBUG_ONLY(static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);)\n@@ -1371,0 +1366,6 @@\n+  \/\/ Replace the control input of 'node' with 'new_control' and set the dom depth to the one of 'new_control'.\n+  void replace_control(Node* node, Node* new_control) {\n+    _igvn.replace_input_of(node, 0, new_control);\n+    set_idom(node, new_control, dom_depth(new_control));\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -792,1 +792,0 @@\n-    assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2114,0 +2114,47 @@\n+\/\/ Interface to define actions that should be taken when running DataNodeBFS. Each use can extend this class to specify\n+\/\/ a customized BFS.\n+class BFSActions : public StackObj {\n+ public:\n+  \/\/ Should a node's inputs further be visited in the BFS traversal? By default, we visit all data inputs. Override this\n+  \/\/ method to provide a custom filter.\n+  virtual bool should_visit(Node* node) const {\n+    \/\/ By default, visit all inputs.\n+    return true;\n+  };\n+\n+  \/\/ Is the visited node a target node that we are looking for in the BFS traversal? We do not visit its inputs further\n+  \/\/ but the BFS will continue to visit all unvisited nodes in the queue.\n+  virtual bool is_target_node(Node* node) const = 0;\n+\n+  \/\/ Defines an action that should be taken when we visit a target node in the BFS traversal.\n+  virtual void target_node_action(Node* target_node) = 0;\n+};\n+\n+\/\/ Class to perform a BFS traversal on the data nodes from a given start node. The provided BFSActions guide which\n+\/\/ data node's inputs should be further visited, which data nodes are target nodes and what to do with the target nodes.\n+class DataNodeBFS : public StackObj {\n+  BFSActions& _bfs_actions;\n+\n+ public:\n+  explicit DataNodeBFS(BFSActions& bfs_action) : _bfs_actions(bfs_action) {}\n+\n+  \/\/ Run the BFS starting from 'start_node' and apply the actions provided to this class.\n+  void run(Node* start_node) {\n+    ResourceMark rm;\n+    Unique_Node_List _nodes_to_visit;\n+    _nodes_to_visit.push(start_node);\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (_bfs_actions.is_target_node(input)) {\n+          assert(_bfs_actions.should_visit(input), \"must also pass node filter\");\n+          _bfs_actions.target_node_action(input);\n+        } else if (_bfs_actions.should_visit(input)) {\n+          _nodes_to_visit.push(input);\n+        }\n+      }\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -156,2 +156,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  DEBUG_ONLY(verify();)\n@@ -164,2 +163,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(success_proj);)\n@@ -172,2 +170,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  DEBUG_ONLY(verify();)\n@@ -181,2 +178,1 @@\n-  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(success_proj);)\n@@ -188,0 +184,1 @@\n+  DEBUG_ONLY(verify();)\n@@ -195,6 +192,4 @@\n-  assert(phase->assertion_predicate_has_loop_opaque_node(head()),\n-         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(phase);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(head(), new_control);\n-  assert(!phase->assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n-         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n+  DEBUG_ONLY(verify();)\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate_creator(phase);\n+  IfTrueNode* success_proj = initialized_assertion_predicate_creator.create_from_template(head(), new_control);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(success_proj);)\n@@ -204,0 +199,67 @@\n+#ifdef ASSERT\n+\/\/ Class to verify Initialized and Template Assertion Predicates by trying to find OpaqueLoop*Nodes.\n+class OpaqueLoopNodesVerifier : public BFSActions {\n+  bool _found_init;\n+  bool _found_stride;\n+\n+ public:\n+  OpaqueLoopNodesVerifier()\n+      : _found_init(false),\n+        _found_stride(false) {}\n+\n+  \/\/ A Template Assertion Predicate has:\n+  \/\/ - Always an OpaqueLoopInitNode\n+  \/\/ - Only an OpaqueLoopStrideNode for the last value.\n+  void verify(const TemplateAssertionPredicate& template_assertion_predicate) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(template_assertion_predicate.opaque_node());\n+    if (template_assertion_predicate.is_last_value()) {\n+      assert(_found_init && _found_stride,\n+             \"must find OpaqueLoopInit and OpaqueLoopStride for last value Template Assertion Predicate\");\n+    } else {\n+      assert(_found_init && !_found_stride,\n+             \"must find OpaqueLoopInit but not OpaqueLoopStride for init value Template Assertion Predicate\");\n+    }\n+  }\n+\n+  \/\/ An Initialized Assertion Predicate never has any OpaqueLoop*Nodes.\n+  void verify(const InitializedAssertionPredicate& initialized_assertion_predicate) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(initialized_assertion_predicate.opaque_node());\n+    assert(!_found_init && !_found_stride,\n+           \"must neither find OpaqueLoopInit nor OpaqueLoopStride for Initialized Assertion Predicate\");\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_Opaque1();\n+  }\n+\n+  void target_node_action(Node* target_node) override {\n+    if (target_node->is_OpaqueLoopInit()) {\n+      assert(!_found_init, \"should only find one OpaqueLoopInitNode\");\n+      _found_init = true;\n+    } else {\n+      assert(target_node->is_OpaqueLoopStride(), \"unexpected Opaque1 node\");\n+      assert(!_found_stride, \"should only find one OpaqueLoopStrideNode\");\n+      _found_stride = true;\n+    }\n+  }\n+};\n+\n+\/\/ Verify that the Template Assertion Predicate has the correct OpaqueLoop*Nodes.\n+void TemplateAssertionPredicate::verify() const {\n+  OpaqueLoopNodesVerifier opaque_loop_nodes_verifier;\n+  opaque_loop_nodes_verifier.verify(*this);\n+}\n+\n+\/\/ Verify that the Initialized Assertion Predicate has no OpaqueLoop*Node.\n+void InitializedAssertionPredicate::verify() const {\n+  OpaqueLoopNodesVerifier opaque_loop_nodes_verifier;\n+  opaque_loop_nodes_verifier.verify(*this);\n+}\n+#endif \/\/ ASSERT\n+\n@@ -421,1 +483,2 @@\n-class ReplaceOpaqueStrideInput : public StackObj {\n+class ReplaceOpaqueStrideInput : public BFSActions {\n+  Node* _new_opaque_stride_input;\n@@ -423,1 +486,0 @@\n-  Unique_Node_List _nodes_to_visit;\n@@ -426,3 +488,3 @@\n-  ReplaceOpaqueStrideInput(OpaqueTemplateAssertionPredicateNode* start_node, PhaseIterGVN& igvn) : _igvn(igvn) {\n-    _nodes_to_visit.push(start_node);\n-  }\n+  ReplaceOpaqueStrideInput(Node* new_opaque_stride_input, PhaseIterGVN& igvn)\n+      : _new_opaque_stride_input(new_opaque_stride_input),\n+        _igvn(igvn) {}\n@@ -431,13 +493,15 @@\n-  void replace(Node* new_opaque_stride_input) {\n-    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n-      Node* next = _nodes_to_visit[i];\n-      for (uint j = 1; j < next->req(); j++) {\n-        Node* input = next->in(j);\n-        if (input->is_OpaqueLoopStride()) {\n-          assert(TemplateAssertionExpressionNode::is_maybe_in_expression(input), \"must also pass node filter\");\n-          _igvn.replace_input_of(input, 1, new_opaque_stride_input);\n-        } else if (TemplateAssertionExpressionNode::is_maybe_in_expression(input)) {\n-          _nodes_to_visit.push(input);\n-        }\n-      }\n-    }\n+  void replace_for(OpaqueTemplateAssertionPredicateNode* opaque_node) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(opaque_node);\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_OpaqueLoopStride();\n+  }\n+\n+  void target_node_action(Node* target_node) override {\n+    _igvn.replace_input_of(target_node, 1, _new_opaque_stride_input);\n@@ -449,2 +513,2 @@\n-  ReplaceOpaqueStrideInput replace_opaque_stride_input(_opaque_node, igvn);\n-  replace_opaque_stride_input.replace(new_stride);\n+  ReplaceOpaqueStrideInput replace_opaque_stride_input(new_stride, igvn);\n+  replace_opaque_stride_input.replace_for(_opaque_node);\n@@ -679,0 +743,2 @@\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(template_predicate_success_proj);)\n+\n@@ -681,2 +747,5 @@\n-  return create_if_node(template_predicate_success_proj, template_assertion_predicate_expression,\n-                        does_overflow, AssertionPredicateType::LastValue);\n+  template_predicate_success_proj = create_if_node(template_predicate_success_proj,\n+                                                   template_assertion_predicate_expression, does_overflow,\n+                                                   AssertionPredicateType::LastValue);\n+  DEBUG_ONLY(TemplateAssertionPredicate::verify(template_predicate_success_proj);)\n+  return template_predicate_success_proj;\n@@ -738,2 +807,4 @@\n-  return create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck, assertion_expression,\n-                              assertion_predicate_type);\n+  IfTrueNode* success_proj = create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck,\n+                                                  assertion_expression, assertion_predicate_type);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(success_proj);)\n+  return success_proj;\n@@ -811,0 +882,13 @@\n+CreateAssertionPredicatesVisitor::CreateAssertionPredicatesVisitor(CountedLoopNode* target_loop_head,\n+                                                                   PhaseIdealLoop* phase,\n+                                                                   const NodeInLoopBody& node_in_loop_body,\n+                                                                   const bool clone_template)\n+    : _init(target_loop_head->init_trip()),\n+      _stride(target_loop_head->stride()),\n+      _old_target_loop_entry(target_loop_head->skip_strip_mined()->in(LoopNode::EntryControl)),\n+      _current_predicate_chain_head(target_loop_head->skip_strip_mined()), \/\/ Initially no predicates, yet.\n+      _phase(phase),\n+      _has_hoisted_check_parse_predicates(false),\n+      _node_in_loop_body(node_in_loop_body),\n+      _clone_template(clone_template) {}\n+\n@@ -827,1 +911,6 @@\n-    _new_control = clone_template_and_replace_init_input(template_assertion_predicate);\n+    IfTrueNode* cloned_template_success_proj = clone_template_and_replace_init_input(template_assertion_predicate);\n+    initialize_from_template(template_assertion_predicate, cloned_template_success_proj);\n+    _current_predicate_chain_head = cloned_template_success_proj->in(0);\n+  } else {\n+    IfTrueNode* initialized_success_proj = initialize_from_template(template_assertion_predicate, _old_target_loop_entry);\n+    _current_predicate_chain_head = initialized_success_proj->in(0);\n@@ -829,1 +918,0 @@\n-  _new_control = initialize_from_template(template_assertion_predicate);\n@@ -834,1 +922,2 @@\n-    const TemplateAssertionPredicate& template_assertion_predicate) const {\n+    const TemplateAssertionPredicate& template_assertion_predicate, Node* new_control) const {\n+  DEBUG_ONLY(template_assertion_predicate.verify();)\n@@ -836,2 +925,4 @@\n-  IfTrueNode* initialized_predicate = _phase->create_initialized_assertion_predicate(template_head, _init, _stride,\n-                                                                                     _new_control);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(_phase);\n+  IfTrueNode* initialized_predicate = initialized_assertion_predicate.create_from_template(template_head, new_control,\n+                                                                                           _init, _stride);\n+  DEBUG_ONLY(InitializedAssertionPredicate::verify(initialized_predicate);)\n@@ -839,0 +930,1 @@\n+  rewire_to_old_predicate_chain_head(initialized_predicate);\n@@ -846,2 +938,16 @@\n-  _phase->register_new_node(opaque_init, _new_control);\n-  return template_assertion_predicate.clone_and_replace_init(_new_control, opaque_init, _phase);\n+  _phase->register_new_node(opaque_init, _old_target_loop_entry);\n+  return template_assertion_predicate.clone_and_replace_init(_old_target_loop_entry, opaque_init, _phase);\n+}\n+\n+\/\/ Rewire the newly created predicates to the old predicate chain head (i.e. '_current_predicate_chain_head') by\n+\/\/ rewiring the current control input of '_current_predicate_chain_head' from '_old_target_loop_entry' to\n+\/\/ 'initialized_assertion_predicate_success_proj'.\n+void CreateAssertionPredicatesVisitor::rewire_to_old_predicate_chain_head(\n+    Node* initialized_assertion_predicate_success_proj) const {\n+  if (_current_predicate_chain_head->is_Loop()) {\n+    assert(_current_predicate_chain_head->in(LoopNode::EntryControl) == _old_target_loop_entry, \"must be old loop entry\");\n+    _phase->replace_loop_entry(_current_predicate_chain_head->as_Loop(), initialized_assertion_predicate_success_proj);\n+  } else {\n+    assert(_current_predicate_chain_head->in(0) == _old_target_loop_entry, \"must be old loop entry\");\n+    _phase->replace_control(_current_predicate_chain_head, initialized_assertion_predicate_success_proj);\n+  }\n@@ -880,1 +986,1 @@\n-    _phase->igvn().replace_input_of(new_control_out, LoopNode::EntryControl, initialized_success_proj);\n+    _phase->replace_loop_entry(new_control_out->as_Loop(), initialized_success_proj);\n@@ -882,1 +988,1 @@\n-    _phase->igvn().replace_input_of(new_control_out, 0, initialized_success_proj);\n+    _phase->replace_control(new_control_out, initialized_success_proj);\n@@ -884,1 +990,0 @@\n-  _phase->set_idom(new_control_out, initialized_success_proj, _phase->dom_depth(new_control_out));\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":153,"deletions":48,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -403,0 +403,9 @@\n+\n+#ifdef ASSERT\n+  static void verify(IfTrueNode* template_assertion_predicate_success_proj) {\n+    TemplateAssertionPredicate template_assertion_predicate(template_assertion_predicate_success_proj);\n+    template_assertion_predicate.verify();\n+  }\n+\n+  void verify() const;\n+#endif \/\/ ASSERT\n@@ -422,0 +431,4 @@\n+  OpaqueInitializedAssertionPredicateNode* opaque_node() const {\n+    return _if_node->in(1)->as_OpaqueInitializedAssertionPredicate();\n+  }\n+\n@@ -436,0 +449,9 @@\n+\n+#ifdef ASSERT\n+  static void verify(IfTrueNode* initialized_assertion_predicate_success_proj) {\n+    InitializedAssertionPredicate initialized_assertion_predicate(initialized_assertion_predicate_success_proj);\n+    initialized_assertion_predicate.verify();\n+  }\n+\n+  void verify() const;\n+#endif \/\/ ASSERT\n@@ -965,1 +987,1 @@\n-  Node* _new_control;\n+  Node* _current_predicate_chain_head;\n@@ -972,13 +994,7 @@\n-  IfTrueNode* initialize_from_template(const TemplateAssertionPredicate& template_assertion_predicate) const;\n-\n- public:\n-  CreateAssertionPredicatesVisitor(Node* init, Node* stride, Node* new_control, PhaseIdealLoop* phase,\n-                                   const NodeInLoopBody& node_in_loop_body, const bool clone_template)\n-      : _init(init),\n-        _stride(stride),\n-        _old_target_loop_entry(new_control),\n-        _new_control(new_control),\n-        _phase(phase),\n-        _has_hoisted_check_parse_predicates(false),\n-        _node_in_loop_body(node_in_loop_body),\n-        _clone_template(clone_template) {}\n+  IfTrueNode* initialize_from_template(const TemplateAssertionPredicate& template_assertion_predicate,\n+                                       Node* new_control) const;\n+  void rewire_to_old_predicate_chain_head(Node* initialized_assertion_predicate_success_proj) const;\n+\n+ public:\n+  CreateAssertionPredicatesVisitor(CountedLoopNode* target_loop_head, PhaseIdealLoop* phase,\n+                                   const NodeInLoopBody& node_in_loop_body, bool clone_template);\n@@ -991,14 +1007,0 @@\n-\n-  \/\/ Did we create any new Initialized Assertion Predicates?\n-  bool has_created_predicates() const {\n-    return _new_control != _old_target_loop_entry;\n-  }\n-\n-  \/\/ Return the last created node by this visitor or the originally provided 'new_control' to the visitor if there was\n-  \/\/ no new node created (i.e. no Template Assertion Predicates found).\n-  IfTrueNode* last_created_success_proj() const {\n-    assert(has_created_predicates(), \"should only be queried if new nodes have been created\");\n-    assert(_new_control->unique_ctrl_out_or_null() == nullptr, \"no control outputs, yet\");\n-    assert(_new_control->is_IfTrue(), \"Assertion Predicates only have IfTrue on success proj\");\n-    return _new_control->as_IfTrue();\n-  }\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"}]}