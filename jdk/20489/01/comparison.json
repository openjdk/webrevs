{"files":[{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+\n+class PipeDispatcherImpl extends FileDispatcherImpl {\n+    PipeDispatcherImpl() {\n+        super();\n+    }\n+\n+    \/**\n+     * Skip at most n bytes\n+     * @return the number of bytes skipped or IOS_INTERRUPTED\n+     *\/\n+    long skip(FileDescriptor fd, long n) {\n+        return skip0(fd, n);\n+    }\n+\n+    \/\/ -- Native methods --\n+\n+    static native void init0();\n+\n+    static {\n+        init0();\n+    }\n+\n+    private static native long skip0(FileDescriptor fd, long n);\n+}\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/PipeDispatcherImpl.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_PipeDispatcherImpl.h\"\n+\n+static int devnull;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_PipeDispatcherImpl_init0(JNIEnv *env, jclass klass)\n+{\n+    devnull = open(\"\/dev\/null\", O_WRONLY);\n+    if (devnull < 0)\n+        JNU_ThrowIOExceptionWithLastError(env, \"open \/dev\/null failed\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_PipeDispatcherImpl_skip0(JNIEnv *env, jclass cl, jobject fdo, jlong n)\n+{\n+    if (n < 1)\n+        return 0;\n+\n+    const jint fd = fdval(env, fdo);\n+\n+    jlong tn = 0;\n+\n+    for (;;) {\n+        const jlong remaining = n - tn;\n+        const ssize_t count = remaining < SSIZE_MAX ? (ssize_t) remaining : SSIZE_MAX;\n+        const ssize_t nr = splice(fd, NULL, devnull, NULL, count, SPLICE_F_MOVE | SPLICE_F_NONBLOCK);\n+        if (nr < 0) {\n+            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n+                return tn;\n+            } else if (errno == EINTR) {\n+                return IOS_INTERRUPTED;\n+            } else {\n+                JNU_ThrowIOExceptionWithLastError(env, \"splice\");\n+                return IOS_THROWN;\n+            }\n+        }\n+        if (nr > 0)\n+            tn += nr;\n+        if (nr == SSIZE_MAX)\n+            continue;\n+        return tn;\n+    }\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/ch\/PipeDispatcherImpl.c","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -1013,2 +1013,3 @@\n-     * is in non-blocking mode then the input stream's {@code read} operations\n-     * will throw an {@link java.nio.channels.IllegalBlockingModeException}.\n+     * is in non-blocking mode then the input stream's {@code read} and\n+     * {@code skip} operations will throw an\n+     * {@link java.nio.channels.IllegalBlockingModeException}.\n@@ -1022,3 +1023,3 @@\n-     *        will close the underlying channel and cause the read method to\n-     *        throw {@link ClosedByInterruptException} with the interrupt\n-     *        status set.\n+     *        will close the underlying channel and cause the read and skip\n+     *        methods to throw {@link ClosedByInterruptException} with the\n+     *        interrupt status set.\n@@ -1413,0 +1414,3 @@\n+     * <p> Behavior of any other method call on the InputStream associated with\n+     * this Socket is implementation specific.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -220,0 +220,9 @@\n+\n+        \/\/ special case where the channel is to a pipe\n+        if (ch instanceof SourceChannelImpl sci)\n+            return sci.skip(n);\n+\n+        \/\/ special case where the channel is to a socket\n+        if (ch instanceof SocketChannelImpl sci)\n+            return sci.skip(n);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -478,0 +478,8 @@\n+    \/**\n+     * Skip at most n bytes\n+     * @return the number of bytes skipped or IOS_INTERRUPTED\n+     *\/\n+    static long skip(FileDescriptor fd, long n, NativeDispatcher nd) throws IOException {\n+        return nd.skip(fd, n);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,0 +89,8 @@\n+\n+    \/**\n+     * Skip at most n bytes\n+     * @return the number of bytes skipped or IOS_INTERRUPTED\n+     *\/\n+    long skip(FileDescriptor fd, long n) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NativeDispatcher.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1635,0 +1635,166 @@\n+\n+    \/**\n+     * Skips over and discards {@code n} bytes of data from this source\n+     * channel. The {@code skip} method may, for a variety of reasons, end\n+     * up skipping over some smaller number of bytes, possibly {@code 0}.\n+     * This may result from any of a number of conditions; reaching end of file\n+     * before {@code n} bytes have been skipped is only one possibility.\n+     * The actual number of bytes skipped is returned. If {@code n} is\n+     * negative, the {@code skip} method for class {@code SocketChannelImpl} always\n+     * returns 0, and no bytes are skipped. Subclasses may handle the negative\n+     * value differently.\n+     *\n+     * @implSpec\n+     * The {@code skip} method implementation of this class creates an off-heap\n+     * byte array and then repeatedly reads into it until {@code n} bytes\n+     * have been read or the end of the stream has been reached. Subclasses are\n+     * encouraged to provide a more efficient implementation of this method.\n+     * For instance, the implementation may depend on the ability to seek.\n+     *\n+     * @param      n   the number of bytes to be skipped.\n+     * @return     the actual number of bytes skipped which might be zero.\n+     * @throws     IOException  if an I\/O error occurs.\n+     *\/\n+    public long skip(long n) throws IOException {\n+        if (n < 1)\n+            return 0;\n+\n+        if (!SocketReadEvent.enabled()) {\n+            return implSkip(n);\n+        }\n+        long start = SocketReadEvent.timestamp();\n+        long nbytes = implSkip(n);\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n+        return nbytes;\n+    }\n+\n+    private long implSkip(long nt) throws IOException {\n+        readLock.lock();\n+        try {\n+            ensureOpenAndConnected();\n+            boolean blocking = isBlocking();\n+            long n = 0;\n+            try {\n+                beginRead(blocking);\n+\n+                \/\/ check if connection has been reset\n+                if (connectionReset)\n+                    throwConnectionReset();\n+\n+                \/\/ check if input is shutdown\n+                if (isInputClosed)\n+                    return IOStatus.EOF;\n+\n+                configureSocketNonBlockingIfVirtualThread();\n+                n = IOUtil.skip(fd, nt, nd);\n+                if (blocking) {\n+                    while (IOStatus.okayToRetry(n) && isOpen()) {\n+                        park(Net.POLLIN);\n+                        n = IOUtil.skip(fd, nt, nd);\n+                    }\n+                }\n+            } catch (ConnectionResetException e) {\n+                connectionReset = true;\n+                throwConnectionReset();\n+            } finally {\n+                endRead(blocking, n > 0);\n+                if (n <= 0 && isInputClosed)\n+                    return IOStatus.EOF;\n+            }\n+            return IOStatus.normalize(n);\n+        } finally {\n+            readLock.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Attempts to skip bytes from the socket.\n+     *\/\n+    private long trySkip(long len) throws IOException {\n+        return IOUtil.skip(fd, len, nd);\n+    }\n+\n+    \/**\n+     * Skips bytes from the socket with a timeout.\n+     * @throws SocketTimeoutException if the read timeout elapses\n+     *\/\n+    private long timedSkip(long len, long nanos) throws IOException {\n+        long startNanos = System.nanoTime();\n+        long n = trySkip(len);\n+        while (n == IOStatus.UNAVAILABLE && isOpen()) {\n+            long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+            if (remainingNanos <= 0) {\n+                throw new SocketTimeoutException(\"Skip timed out\");\n+            }\n+            park(Net.POLLIN, remainingNanos);\n+            n = trySkip(len);\n+        }\n+        return n;\n+    }\n+\n+    \/**\n+     * Skips bytes from the socket.\n+     *\n+     * @apiNote This method is for use by the socket adaptor.\n+     *\n+     * @throws IllegalBlockingModeException if the channel is non-blocking\n+     * @throws SocketTimeoutException if the skip timeout elapses\n+     *\/\n+    long blockingSkip(long len, long nanos) throws IOException {\n+        if (len == 0) {\n+            \/\/ nothing to do\n+            return 0;\n+        }\n+\n+        readLock.lock();\n+        try {\n+            ensureOpenAndConnected();\n+\n+            \/\/ check that channel is configured blocking\n+            if (!isBlocking())\n+                throw new IllegalBlockingModeException();\n+\n+            long n = 0;\n+            try {\n+                beginRead(true);\n+\n+                \/\/ check if connection has been reset\n+                if (connectionReset)\n+                    throwConnectionReset();\n+\n+                \/\/ check if input is shutdown\n+                if (isInputClosed)\n+                    return IOStatus.EOF;\n+\n+                if (nanos > 0) {\n+                    \/\/ change socket to non-blocking\n+                    lockedConfigureBlocking(false);\n+                    try {\n+                        n = timedSkip(len, nanos);\n+                    } finally {\n+                        \/\/ restore socket to blocking mode (if channel is open)\n+                        tryLockedConfigureBlocking(true);\n+                    }\n+                } else {\n+                    \/\/ skip, no timeout\n+                    configureSocketNonBlockingIfVirtualThread();\n+                    n = trySkip(len);\n+                    while (IOStatus.okayToRetry(n) && isOpen()) {\n+                        park(Net.POLLIN);\n+                        n = trySkip(len);\n+                    }\n+                }\n+            } catch (ConnectionResetException e) {\n+                connectionReset = true;\n+                throwConnectionReset();\n+            } finally {\n+                endRead(true, n > 0);\n+                if (n <= 0 && isInputClosed)\n+                    return IOStatus.EOF;\n+            }\n+            assert n >= 0 || n == -1;\n+            return n;\n+        } finally {\n+            readLock.unlock();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -86,0 +86,21 @@\n+    @Override\n+    public long skip(long n) throws IOException {\n+        int timeout = timeoutSupplier.getAsInt();\n+        if (!SocketReadEvent.enabled()) {\n+            return implSkip(n, timeout);\n+        }\n+        long start = SocketReadEvent.timestamp();\n+        long ns = implSkip(n, timeout);\n+        SocketReadEvent.offer(start, ns, sc.remoteAddress(), timeout);\n+        return ns;\n+    }\n+\n+    private long implSkip(long n, int timeout) throws IOException {\n+        if (timeout > 0) {\n+            long nanos = MILLISECONDS.toNanos(timeout);\n+            return sc.blockingSkip(n, nanos);\n+        } else {\n+            return sc.blockingSkip(n, 0);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketInputStream.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+\n+class PipeDispatcherImpl extends FileDispatcherImpl {\n+    PipeDispatcherImpl() {\n+        super();\n+    }\n+}\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/PipeDispatcherImpl.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final NativeDispatcher nd = new FileDispatcherImpl();\n+    private static final NativeDispatcher nd = new PipeDispatcherImpl();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+    long skip(FileDescriptor fd, long n) throws IOException {\n+        return skip0(fd, n);\n+    }\n+\n@@ -91,0 +95,3 @@\n+    private static native long skip0(FileDescriptor fd, long n)\n+        throws IOException;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SocketDispatcher.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final NativeDispatcher nd = new FileDispatcherImpl();\n+    private static final NativeDispatcher nd = new PipeDispatcherImpl();\n@@ -368,0 +368,49 @@\n+\n+    \/**\n+     * Skips over and discards {@code n} bytes of data from this source\n+     * channel. The {@code skip} method may, for a variety of reasons, end\n+     * up skipping over some smaller number of bytes, possibly {@code 0}.\n+     * This may result from any of a number of conditions; reaching end of file\n+     * before {@code n} bytes have been skipped is only one possibility.\n+     * The actual number of bytes skipped is returned. If {@code n} is\n+     * negative, the {@code skip} method for class {@code SourceChannelImpl} always\n+     * returns 0, and no bytes are skipped. Subclasses may handle the negative\n+     * value differently.\n+     *\n+     * @implSpec\n+     * The {@code skip} method implementation of this class creates an off-heap\n+     * byte array and then repeatedly reads into it until {@code n} bytes\n+     * have been read or the end of the stream has been reached. Subclasses are\n+     * encouraged to provide a more efficient implementation of this method.\n+     * For instance, the implementation may depend on the ability to seek.\n+     *\n+     * @param      n   the number of bytes to be skipped.\n+     * @return     the actual number of bytes skipped which might be zero.\n+     * @throws     IOException  if an I\/O error occurs.\n+     *\/\n+    public long skip(long n) throws IOException {\n+        if (n < 1)\n+            return 0;\n+\n+        readLock.lock();\n+        try {\n+            boolean blocking = isBlocking();\n+            long ns = 0;\n+            try {\n+                beginRead(blocking);\n+                configureSocketNonBlockingIfVirtualThread();\n+                ns = IOUtil.skip(fd, n, nd);\n+                if (blocking)\n+                    while (IOStatus.okayToRetry(ns) && isOpen()) {\n+                        park(Net.POLLIN);\n+                        ns = IOUtil.skip(fd, n, nd);\n+                    }\n+            } finally {\n+                endRead(blocking, ns > 0);\n+                assert IOStatus.check(ns);\n+            }\n+            return IOStatus.normalize(ns);\n+        } finally {\n+            readLock.unlock();\n+        }\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -168,0 +168,8 @@\n+    \/**\n+     * Skip at most n bytes\n+     * @return the number of bytes skipped or IOS_INTERRUPTED\n+     *\/\n+    long skip(FileDescriptor fd, long n) {\n+        return skip0(fd, n);\n+    }\n+\n@@ -216,0 +224,2 @@\n+\n+    private static native long skip0(FileDescriptor fd, long n);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixFileDispatcherImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+\/\/ MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to\n+\/\/ use when skipping.\n+static const ssize_t MAX_SKIP_BUFFER_SIZE = 4096;\n+\n@@ -85,0 +89,34 @@\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_SocketDispatcher_skip0(JNIEnv *env, jclass cl, jobject fdo, jlong n)\n+{\n+    if (n < 1)\n+        return 0;\n+\n+    const jint fd = fdval(env, fdo);\n+\n+    const long bs = n < MAX_SKIP_BUFFER_SIZE ? (long) n : MAX_SKIP_BUFFER_SIZE;\n+    char buf[bs];\n+    jlong tn = 0;\n+\n+    for (;;) {\n+        const jlong remaining = n - tn;\n+        const ssize_t count = remaining < bs ? (ssize_t) remaining : bs;\n+        const ssize_t nr = read(fd, buf, count);\n+        if (nr < 0) {\n+            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n+                return tn;\n+            } else if (errno == EINTR) {\n+                return IOS_INTERRUPTED;\n+            } else {\n+                JNU_ThrowIOExceptionWithLastError(env, \"read\");\n+                return IOS_THROWN;\n+            }\n+        }\n+        if (nr > 0)\n+            tn += nr;\n+        if (nr == bs)\n+            continue;\n+        return tn;\n+    }\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/SocketDispatcher.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -52,0 +52,4 @@\n+\/\/ MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to\n+\/\/ use when skipping.\n+static const ssize_t MAX_SKIP_BUFFER_SIZE = 4096;\n+\n@@ -394,0 +398,34 @@\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_skip0(JNIEnv *env, jclass cl, jobject fdo, jlong n)\n+{\n+    if (n < 1)\n+        return 0;\n+\n+    const jint fd = fdval(env, fdo);\n+\n+    const long bs = n < MAX_SKIP_BUFFER_SIZE ? (long) n : MAX_SKIP_BUFFER_SIZE;\n+    char buf[bs];\n+    jlong tn = 0;\n+\n+    for (;;) {\n+        const jlong remaining = n - tn;\n+        const ssize_t count = remaining < bs ? (ssize_t) remaining : bs;\n+        const ssize_t nr = read(fd, buf, count);\n+        if (nr < 0) {\n+            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n+                return tn;\n+            } else if (errno == EINTR) {\n+                return IOS_INTERRUPTED;\n+            } else {\n+                JNU_ThrowIOExceptionWithLastError(env, \"read\");\n+                return IOS_THROWN;\n+            }\n+        }\n+        if (nr > 0)\n+            tn += nr;\n+        if (nr == bs)\n+            continue;\n+        return tn;\n+    }\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixFileDispatcherImpl.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+    long skip(FileDescriptor fd, long n) throws IOException {\n+        return skip0(fd, n);\n+    }\n+\n@@ -92,0 +96,3 @@\n+    private static native long skip0(FileDescriptor fd, long n)\n+        throws IOException;\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SocketDispatcher.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -142,0 +142,33 @@\n+    \/**\n+     * Skips over and discards {@code n} bytes of data from this source\n+     * channel. The {@code skip} method may, for a variety of reasons, end\n+     * up skipping over some smaller number of bytes, possibly {@code 0}.\n+     * This may result from any of a number of conditions; reaching end of file\n+     * before {@code n} bytes have been skipped is only one possibility.\n+     * The actual number of bytes skipped is returned. If {@code n} is\n+     * negative, the {@code skip} method for class {@code SourceChannelImpl} always\n+     * returns 0, and no bytes are skipped. Subclasses may handle the negative\n+     * value differently.\n+     *\n+     * @implSpec\n+     * The {@code skip} method implementation of this class creates an off-heap\n+     * byte array and then repeatedly reads into it until {@code n} bytes\n+     * have been read or the end of the stream has been reached. Subclasses are\n+     * encouraged to provide a more efficient implementation of this method.\n+     * For instance, the implementation may depend on the ability to seek.\n+     *\n+     * @param      n   the number of bytes to be skipped.\n+     * @return     the actual number of bytes skipped which might be zero.\n+     * @throws     IOException  if an I\/O error occurs.\n+     *\/\n+    public long skip(long n) throws IOException {\n+        if (n < 1)\n+            return 0;\n+\n+        try {\n+            return ((SocketChannelImpl) sc).skip(n);\n+        } catch (AsynchronousCloseException x) {\n+            close();\n+            throw x;\n+        }\n+    }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -289,0 +289,38 @@\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_SocketDispatcher_skip0(JNIEnv *env, jclass cl, jobject fdo, jlong n)\n+{\n+    if (n < 1)\n+        return 0;\n+\n+    const jint fd = fdval(env, fdo);\n+\n+    char buf[4096];\n+    jlong tn = 0;\n+\n+    for (;;) {\n+        const int c = (int) min(n - tn, sizeof(buf));\n+\n+        if (c == 0)\n+            return convertLongReturnVal(env, tn, JNI_TRUE);\n+\n+        const int read = recv((SOCKET) fd, buf, c, 0);\n+        if (read == SOCKET_ERROR) {\n+            const int err = WSAGetLastError();\n+            if (err == WSAEWOULDBLOCK) {\n+                return tn == 0 ? IOS_UNAVAILABLE : tn;\n+            }\n+            if (err == WSAECONNRESET) {\n+                JNU_ThrowByName(env, \"sun\/net\/ConnectionResetException\", \"Connection reset\");\n+            } else {\n+                JNU_ThrowIOExceptionWithLastError(env, \"Read failed\");\n+            }\n+            return IOS_THROWN;\n+        }\n+\n+        tn += read;\n+\n+        if (read == 0)\n+            return convertLongReturnVal(env, tn, JNI_TRUE);\n+    }\n+}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/SocketDispatcher.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run testng\/othervm\/timeout=180 Skip\n+ * @bug 8337974\n+ * @summary Tests whether sun.nio.ch.ChannelInputStream.skip and\n+ *          sun.nio.ch.SocketInputStream.skip conform to the\n+ *          InputStream.skip specification\n+ * @key randomness\n+ *\/\n+public class Skip extends SkipBase {\n+\n+    \/*\n+     * Provides test scenarios, i.e., input streams to be tested.\n+     *\/\n+    @DataProvider\n+    public static Object[] streams() {\n+        return new Object[] {\n+            \/\/ tests FileChannel.skip() optimized case\n+            fileChannelInput(),\n+\n+            \/\/ tests SourceChannelImpl.skip() optimized case\n+            sourceChannelImplInput(),\n+\n+            \/\/ tests SocketChannel.skip() optimized case\n+            socketChannelInput(),\n+\n+            \/\/ tests InputStream.skip() default case\n+            readableByteChannelInput()\n+        };\n+    }\n+\n+    \/*\n+     * Testing API compliance: 0...n bytes of input stream must be\n+     * skipped, and the remainder of bytes must not be changed.\n+     *\/\n+    @Test(dataProvider = \"streams\")\n+    public void testStreamContents(InputStreamProvider inputStreamProvider) throws Exception {\n+        assertStreamContents(inputStreamProvider);\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a file channel\n+     *\/\n+    private static InputStreamProvider fileChannelInput() {\n+        return bytes -> {\n+            Path path = Files.createTempFile(CWD, \"fileChannelInput\", null);\n+            Files.write(path, bytes);\n+            FileChannel fileChannel = FileChannel.open(path);\n+            return Channels.newInputStream(fileChannel);\n+        };\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a pipe channel\n+     *\/\n+    private static InputStreamProvider sourceChannelImplInput() {\n+        return bytes -> {\n+            Pipe pipe = Pipe.open();\n+            new Thread(() -> {\n+                try (OutputStream os = Channels.newOutputStream(pipe.sink())) {\n+                    os.write(bytes);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }).start();\n+            return Channels.newInputStream(pipe.source());\n+        };\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a socket channel\n+     *\/\n+    private static InputStreamProvider socketChannelInput() {\n+        return bytes -> {\n+            try {\n+                SocketAddress loopback = new InetSocketAddress(\n+                        InetAddress.getLoopbackAddress(), 0);\n+                ServerSocketChannel serverSocket = ServerSocketChannel.open()\n+                        .bind(loopback);\n+                new Thread(() -> {\n+                    try (SocketChannel client = SocketChannel.open(\n+                                serverSocket.getLocalAddress());\n+                            OutputStream os = Channels.newOutputStream(client)) {\n+                        os.write(bytes);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    } finally {\n+                        try {\n+                            serverSocket.close();\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }).start();\n+                return Channels.newInputStream(serverSocket.accept());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/Skip.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.ToLongFunction;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+\n+class SkipBase {\n+    static final int MIN_SIZE      = 10_000;\n+    static final int MAX_SIZE_INCR = 100_000_000 - MIN_SIZE;\n+\n+    static final int ITERATIONS = 10;\n+\n+    static final Random RND = RandomFactory.getRandom();\n+\n+    static final Path CWD = Path.of(\".\");\n+\n+    \/*\n+     * Asserts that the skipped content is correct, i.e. compares the bytes\n+     * still in the input stream to those expected. The position of the input\n+     * stream before the skip is zero (BOF), and the number of bytes to skip is\n+     * \"all bytes til EOF\".\n+     *\/\n+    static void checkSkippedContents(InputStreamProvider inputStreamProvider,\n+            byte[] inBytes) throws Exception {\n+        checkSkippedContents(inputStreamProvider, inBytes, inBytes.length);\n+    }\n+\n+    \/*\n+     * Asserts that the skipped content is correct, i.e. compares the bytes\n+     * still in the input stream to those expected. The position of the input\n+     * stream before the skip is zero (BOF). The number of bytes to skip is\n+     * provided by the caller.\n+     *\/\n+    static void checkSkippedContents(InputStreamProvider inputStreamProvider,\n+            byte[] inBytes, long count) throws Exception {\n+        checkSkippedContents(inputStreamProvider, inBytes, 0, count, false);\n+    }\n+\n+    \/*\n+     * Asserts that the skipped content is correct, i.e. compares the bytes\n+     * still in the input stream to those expected. The position of the input\n+     * stream before the skip and the number of bytes to skip are provided by\n+     * the caller.\n+     *\/\n+    static void checkSkippedContents(InputStreamProvider inputStreamProvider,\n+            byte[] inBytes, int posIn, long count, boolean mustNotSkipAnything) throws Exception {\n+        try (InputStream in = inputStreamProvider.input(inBytes)) {\n+            \/\/ consume bytes until starting position\n+            in.readNBytes(posIn);\n+            long reported = in.skip(count);\n+            byte[] reminder = in.readAllBytes();\n+\n+            if (mustNotSkipAnything)\n+                assertTrue(reported == 0, format(\"must not skip any bytes, but skipped %d\", reported));\n+            assertTrue(reported >= 0 && reported <= count, format(\"reported %d bytes but should report between 0 and %d\", reported, count));\n+            int expectedRemainingCount = inBytes.length - posIn - Math.toIntExact(reported);\n+            assertEquals(reminder.length, expectedRemainingCount,\n+                    format(\"remaining %d bytes but should remain %d\", reminder.length, expectedRemainingCount));\n+            assertTrue(Arrays.equals(reminder, 0, reminder.length,\n+                    inBytes, posIn + Math.toIntExact(reported), inBytes.length),\n+                    \"remaining bytes are dissimilar\");\n+        }\n+    }\n+\n+    \/*\n+     * Creates an array of random size (between min and min + maxRandomAdditive)\n+     * filled with random bytes\n+     *\/\n+    static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+        byte[] bytes = new byte[min + (maxRandomAdditive == 0 ? 0 : RND.nextInt(maxRandomAdditive))];\n+        RND.nextBytes(bytes);\n+        return bytes;\n+    }\n+\n+    interface InputStreamProvider {\n+        InputStream input(byte... bytes) throws Exception;\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a readable byte\n+     * channel but is not a file channel.\n+     *\/\n+    static InputStreamProvider readableByteChannelInput() {\n+        return bytes -> Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n+    }\n+\n+    \/*\n+     * Testing API compliance: 0...n bytes of input stream must be\n+     * skipped, and the remainder of bytes must not be changed.\n+     *\/\n+    static void assertStreamContents(InputStreamProvider inputStreamProvider) throws Exception {\n+        \/\/ tests empty input stream\n+        checkSkippedContents(inputStreamProvider, new byte[0]);\n+\n+        \/\/ tests input stream with a length between 1k and 4k\n+        checkSkippedContents(inputStreamProvider, createRandomBytes(1024, 3072));\n+\n+        \/\/ tests input stream with several data chunks, as 16k is more than a\n+        \/\/ single chunk can hold\n+        checkSkippedContents(inputStreamProvider, createRandomBytes(16384, 16384));\n+\n+        \/\/ tests randomly chosen starting positions and counts\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n+            int posIn = RND.nextInt(inBytes.length);\n+            long count = RND.nextLong(MIN_SIZE + MAX_SIZE_INCR - posIn);\n+            checkSkippedContents(inputStreamProvider, inBytes, posIn, count, false);\n+        }\n+\n+        \/\/ tests reading beyond source EOF (must not skip any bytes)\n+        checkSkippedContents(inputStreamProvider, createRandomBytes(4096, 0),\n+                4096, 1, true);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/SkipBase.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run testng\/othervm\/timeout=180 Skip_2GB\n+ * @bug 8337974\n+ * @summary Tests if ChannelInputStream.skip and SocketInputStream.skip\n+ *          correctly skip 2GB+.\n+ * @key randomness\n+ *\/\n+public class Skip_2GB extends SkipBase {\n+\n+    \/*\n+     * Provides test scenarios, i.e., input streams to be tested.\n+     *\/\n+    @DataProvider\n+    public static Object[] streams() {\n+        return new Object[] {\n+            \/\/ tests FileChannel.skip() optimized case\n+            fileChannelInput_2G(),\n+\n+            \/\/ tests SourceChannelImpl.skip() optimized case\n+            sourceChannelImplInput_2G(),\n+\n+            \/\/ tests SourceChannelImpl.skip() optimized case\n+            socketChannelInput_2G(),\n+\n+            \/\/ tests InputStream.skip() default case\n+            readableByteChannelInput_2G()\n+        };\n+    }\n+\n+    \/*\n+     * Testing API compliance: > 0...n bytes of input stream must be\n+     * skipped, and the remainder of bytes must not be changed.\n+     *\/\n+    @Test(dataProvider = \"streams\")\n+    public void testStreamContents(InputStreamProvider_2G inputStreamProvider) throws Exception {\n+        assertStreamContentsUsingFiles(inputStreamProvider);\n+    }\n+\n+    \/*\n+     * Testing API compliance: > 0...n bytes of input stream must be\n+     * skipped, and the remainder of bytes must not be changed.\n+     *\/\n+    static void assertStreamContentsUsingFiles(InputStreamProvider_2G inputStreamProvider) throws Exception {\n+        Path inBytes = createRandomBytesFile(Integer.MAX_VALUE - 1L,\n+                Integer.MAX_VALUE + 1L, Integer.MAX_VALUE);\n+        try {\n+            checkSkippedContents(inputStreamProvider, inBytes);\n+        } finally {\n+            Files.deleteIfExists(inBytes);\n+        }\n+    }\n+\n+    \/*\n+     * Asserts that the skipped content is correct, i.e. compares the bytes\n+     * still in the input stream to those expected. The position of the input\n+     * stream before the skip is zero (BOF), and the number of bytes to skip is\n+     * \"all bytes til EOF\".\n+     *\/\n+    static void checkSkippedContents(InputStreamProvider_2G inputStreamProvider,\n+            Path inBytes) throws Exception {\n+        checkSkippedContents(inputStreamProvider, inBytes, Files.size(inBytes));\n+    }\n+\n+    \/*\n+     * Asserts that the skipped content is correct, i.e. compares the bytes\n+     * still in the input stream to those expected. The position of the input\n+     * stream before the skip is zero (BOF). The number of bytes to skip is\n+     * provided by the caller.\n+     *\/\n+    static void checkSkippedContents(InputStreamProvider_2G inputStreamProvider,\n+            Path inBytes, long count) throws Exception {\n+        checkSkippedContents(inputStreamProvider, inBytes, 0, count, false);\n+    }\n+\n+    \/*\n+     * Asserts that the skipped content is correct, i.e. compares the bytes\n+     * still in the input stream to those expected. The position of the input\n+     * stream before the skip and the number of bytes to skip are provided by\n+     * the caller.\n+     *\/\n+    static void checkSkippedContents(InputStreamProvider_2G inputStreamProvider,\n+            Path inBytes, long posIn, long count, boolean mustNotSkipAnything)\n+            throws Exception {\n+        try (InputStream in = inputStreamProvider.input(inBytes)) {\n+            \/\/ consume bytes until starting position\n+            for (long bytesToConsume = posIn; bytesToConsume > 0;\n+                    bytesToConsume -= in.readNBytes(Math.toIntExact(\n+                            Math.min(Integer.MAX_VALUE, bytesToConsume))).length);\n+\n+            long reported = in.skip(count);\n+\n+            if (mustNotSkipAnything)\n+                assertTrue(reported == 0,\n+                        format(\"must not skip any bytes, but skipped %d\", reported));\n+\n+            \/\/ store all remaining bytes in a file\n+            Path actualRemainderFile = CWD.resolve(\n+                    format(\"test3GBActual_skip%s.tmp\", RND.nextInt(Integer.MAX_VALUE)));\n+            try {\n+                try (OutputStream os = Files.newOutputStream(actualRemainderFile,\n+                        CREATE_NEW, WRITE, SPARSE)) {\n+                    in.transferTo(os);\n+                }\n+\n+                assertTrue(reported >= 0 && reported <= count,\n+                        format(\"reported %d bytes but should report between 0 and %d\", reported, count));\n+\n+                long expectedRemainderLength = Files.size(inBytes) - posIn - reported;\n+                long actualRemainderLength = Files.size(actualRemainderFile);\n+                assertEquals(actualRemainderLength, expectedRemainderLength,\n+                        format(\"remaining %d bytes but should remain %d\", actualRemainderLength, expectedRemainderLength));\n+\n+                \/\/ store expected remaining bytes in a file\n+                Path expectedRemainderFile = CWD.resolve(\n+                        format(\"test3GBExpected_skip%s.tmp\", RND.nextInt(Integer.MAX_VALUE)));\n+                try (OutputStream os = Files.newOutputStream(expectedRemainderFile,\n+                        CREATE_NEW, WRITE, SPARSE)) {\n+                    try (FileChannel fc = FileChannel.open(inBytes)) {\n+                        fc.position(posIn + reported);\n+                        try (InputStream is = Channels.newInputStream(fc)) {\n+                            is.transferTo(os);\n+                        }\n+                    }\n+\n+                    \/\/ Check similarity of content\n+                    assertEquals(Files.mismatch(expectedRemainderFile,\n+                            actualRemainderFile), -1, \"remaining bytes are dissimilar\");\n+                } finally {\n+                    Files.deleteIfExists(expectedRemainderFile);\n+                }\n+            } finally {\n+                Files.deleteIfExists(actualRemainderFile);\n+            }\n+        }\n+    }\n+\n+    interface InputStreamProvider_2G {\n+        InputStream input(Path bytes) throws Exception;\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a file channel\n+     *\/\n+    private static InputStreamProvider_2G fileChannelInput_2G() {\n+        return bytes -> {\n+            FileChannel fileChannel = FileChannel.open(bytes);\n+            return Channels.newInputStream(fileChannel);\n+        };\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a pipe channel\n+     *\/\n+    private static InputStreamProvider_2G sourceChannelImplInput_2G() {\n+        return bytes -> {\n+            Pipe pipe = Pipe.open();\n+            new Thread(() -> {\n+                try (OutputStream os = Channels.newOutputStream(pipe.sink());\n+                        InputStream is = Files.newInputStream(bytes)) {\n+                    is.transferTo(os);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }).start();\n+            return Channels.newInputStream(pipe.source());\n+        };\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a socket channel\n+     *\/\n+    private static InputStreamProvider_2G socketChannelInput_2G() {\n+        return bytes -> {\n+            try {\n+                SocketAddress loopback = new InetSocketAddress(\n+                        InetAddress.getLoopbackAddress(), 0);\n+                ServerSocketChannel serverSocket = ServerSocketChannel.open()\n+                        .bind(loopback);\n+                new Thread(() -> {\n+                    try (SocketChannel client = SocketChannel.open(\n+                                serverSocket.getLocalAddress());\n+                            OutputStream os = Channels.newOutputStream(client);\n+                            InputStream is = Files.newInputStream(bytes)) {\n+                        is.transferTo(os);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    } finally {\n+                        try {\n+                            serverSocket.close();\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }).start();\n+                return Channels.newInputStream(serverSocket.accept());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+    }\n+\n+    \/*\n+     * Creates a provider for an input stream which wraps a readable byte\n+     * channel but is not a file channel.\n+     *\/\n+    static InputStreamProvider_2G readableByteChannelInput_2G() {\n+        return bytes -> Channels.newInputStream(Channels.newChannel(\n+                new BufferedInputStream(Files.newInputStream(bytes))));\n+    }\n+\n+    \/*\n+     * Creates a sparse file of random size (between min and min + maxRandomAdditive)\n+     * filled with random bytes starting at the provided position.\n+     *\/\n+    static Path createRandomBytesFile(long pos, long min, long maxRandomAdditive) throws IOException {\n+        Path randomBytesFile = CWD.resolve(\n+            format(\"test3GBSource_skip%s.tmp\", RND.nextInt(Integer.MAX_VALUE)));\n+        try (FileChannel fc = FileChannel.open(randomBytesFile, CREATE_NEW, WRITE, SPARSE)) {\n+            fc.position(pos);\n+            try (OutputStream os = Channels.newOutputStream(fc)) {\n+                long remaining = min +\n+                        (maxRandomAdditive == 0 ? 0 : RND.nextLong(maxRandomAdditive)) - pos;\n+                while (remaining > 0) {\n+                    int n = Math.toIntExact(Math.min(16384, remaining));\n+                    byte[] bytes = createRandomBytes(n, 0);\n+                    os.write(bytes);\n+                    remaining -= n;\n+                }\n+            }\n+        }\n+        return randomBytesFile;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/Skip_2GB.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"}]}