{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @bug 8179502\n+ * @bug 8179502 8337826\n@@ -39,11 +39,11 @@\n- * @run main\/othervm OCSPTimeout 1000 true\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=5\n- *      OCSPTimeout 1000 true\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1\n- *      OCSPTimeout 5000 false\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1s\n- *      OCSPTimeout 5000 false\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1500ms\n- *      OCSPTimeout 5000 false\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=4500ms\n- *      OCSPTimeout 1000 true\n+ * @run main\/othervm -Djava.security.debug=certpath OCSPTimeout 1000 true\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=5 OCSPTimeout 1000 true\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=1 OCSPTimeout 5000 false\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=1s OCSPTimeout 5000 false\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=1500ms OCSPTimeout 5000 false\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=4500ms OCSPTimeout 1000 true\n@@ -85,1 +85,1 @@\n-    public static void main(String args[]) throws Exception {\n+    public static void main(String[] args) throws Exception {\n@@ -91,26 +91,3 @@\n-        if (args[0] != null) {\n-            ocspTimeout = Integer.parseInt(args[0]);\n-        }\n-        rootOcsp.setDelay(ocspTimeout);\n-\n-        expected = (args[1] != null && Boolean.parseBoolean(args[1]));\n-        log(\"Test case expects to \" + (expected ? \"pass\" : \"fail\"));\n-\n-        \/\/ validate chain\n-        CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n-        PKIXRevocationChecker prc =\n-                (PKIXRevocationChecker) cpv.getRevocationChecker();\n-        prc.setOptions(EnumSet.of(NO_FALLBACK, SOFT_FAIL));\n-        PKIXParameters params =\n-                new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n-        params.addCertPathChecker(prc);\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        CertPath cp = cf.generateCertPath(List.of(eeCert));\n-        cpv.validate(cp, params);\n-\n-        \/\/ unwrap soft fail exceptions and check for SocketTimeoutException\n-        List<CertPathValidatorException> softExc = prc.getSoftFailExceptions();\n-        if (expected) {\n-            if (softExc.size() > 0) {\n-                throw new RuntimeException(\"Expected to pass, found \" +\n-                        softExc.size() + \" soft fail exceptions\");\n+        try {\n+            if (args[0] != null) {\n+                ocspTimeout = Integer.parseInt(args[0]);\n@@ -118,12 +95,25 @@\n-        } else {\n-            \/\/ If we expect to fail the validation then there should be a\n-            \/\/ SocketTimeoutException\n-            boolean found = false;\n-            for (CertPathValidatorException softFail : softExc) {\n-                log(\"CPVE: \" + softFail);\n-                Throwable cause = softFail.getCause();\n-                log(\"Cause: \" + cause);\n-                while (cause != null) {\n-                    if (cause instanceof SocketTimeoutException) {\n-                        found = true;\n-                        break;\n+            rootOcsp.setDelay(ocspTimeout);\n+\n+            expected = (args[1] != null && Boolean.parseBoolean(args[1]));\n+            log(\"Test case expects to \" + (expected ? \"pass\" : \"fail\"));\n+\n+            \/\/ validate chain\n+            CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n+            PKIXRevocationChecker prc =\n+                    (PKIXRevocationChecker) cpv.getRevocationChecker();\n+            prc.setOptions(EnumSet.of(NO_FALLBACK, SOFT_FAIL));\n+            PKIXParameters params =\n+                    new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n+            params.addCertPathChecker(prc);\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            CertPath cp = cf.generateCertPath(List.of(eeCert));\n+            cpv.validate(cp, params);\n+\n+            \/\/ unwrap soft fail exceptions and check for SocketTimeoutException\n+            List<CertPathValidatorException> softExc = prc.getSoftFailExceptions();\n+            if (expected) {\n+                if (!softExc.isEmpty()) {\n+                    log(\"Expected to pass, found \" + softExc.size() +\n+                            \" soft fail exceptions\");\n+                    for (CertPathValidatorException cpve : softExc) {\n+                        log(\"Exception: \" + cpve);\n@@ -131,1 +121,2 @@\n-                    cause = cause.getCause();\n+                    throw new RuntimeException(\"Expected to pass, found \" +\n+                            softExc.size() + \" soft fail exceptions\");\n@@ -133,2 +124,18 @@\n-                if (found) {\n-                    break;\n+            } else {\n+                \/\/ If we expect to fail the validation then there should be a\n+                \/\/ SocketTimeoutException\n+                boolean found = false;\n+                for (CertPathValidatorException softFail : softExc) {\n+                    log(\"CPVE: \" + softFail);\n+                    Throwable cause = softFail.getCause();\n+                    log(\"Cause: \" + cause);\n+                    while (cause != null) {\n+                        if (cause instanceof SocketTimeoutException) {\n+                            found = true;\n+                            break;\n+                        }\n+                        cause = cause.getCause();\n+                    }\n+                    if (found) {\n+                        break;\n+                    }\n@@ -136,1 +143,0 @@\n-            }\n@@ -138,2 +144,3 @@\n-            if (!found) {\n-                throw new RuntimeException(\"SocketTimeoutException not thrown\");\n+                if (!found) {\n+                    throw new RuntimeException(\"SocketTimeoutException not thrown\");\n+                }\n@@ -141,0 +148,3 @@\n+        } finally {\n+            rootOcsp.stop();\n+            rootOcsp.shutdownNow();\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/OCSPTimeout.java","additions":68,"deletions":58,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -575,2 +575,2 @@\n-            System.out.println(\"[\" + Thread.currentThread().getName() + \"]: \" +\n-                    message);\n+            System.out.println(\"[\" + Thread.currentThread().getName() + \"][\" +\n+                    System.currentTimeMillis() + \"]: \" + message);\n@@ -730,0 +730,1 @@\n+                    log(\"Delaying response for \" + delayMsec + \" milliseconds.\");\n@@ -911,0 +912,7 @@\n+            \/\/ Display the whole request\n+            StringBuilder sb = new StringBuilder(\"OCSP GET REQUEST\\n\");\n+            for (String hTok : headerTokens) {\n+                sb.append(hTok).append(\"\\n\");\n+            }\n+            log(sb.toString());\n+\n@@ -1003,0 +1011,4 @@\n+            \/\/ Display the DER encoding before parsing\n+            log(\"Local OCSP Request Constructor, parsing bytes:\\n\" +\n+                    dumpHexBytes(requestBytes));\n+\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}