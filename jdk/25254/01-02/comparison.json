{"files":[{"patch":"@@ -1206,1 +1206,1 @@\n-const Type* ModINode::Value(PhaseGVN* phase) const {\n+static const Type* mod_value(const PhaseGVN* phase, const Node* in1, const Node* in2, const BasicType bt, const Type* bottom) {\n@@ -1208,4 +1208,4 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP) return Type::TOP;\n+  if (t2 == Type::TOP) return Type::TOP;\n@@ -1215,1 +1215,2 @@\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n+  if (t1 == TypeInteger::zero(bt)) return t1;\n+\n@@ -1217,2 +1218,2 @@\n-  if (in(1) == in(2)) {\n-    return TypeInt::ZERO;\n+  if (in1 == in2) {\n+    return TypeInteger::zero(bt);\n@@ -1221,6 +1222,0 @@\n-  const TypeInt *i1 = t1->isa_int();\n-  const TypeInt *i2 = t2->isa_int();\n-\n-  if (i1 == nullptr || i2 == nullptr) {\n-    return bottom_type();\n-  }\n@@ -1228,1 +1223,1 @@\n-  if (i2->is_con() && i2->get_con() == 0) {\n+  if (t2 == TypeInteger::zero(bt)) {\n@@ -1231,0 +1226,6 @@\n+\n+  const TypeInteger* i1 = t1->isa_integer(bt);\n+  const TypeInteger* i2 = t2->isa_integer(bt);\n+  if (i1 == nullptr || i2 == nullptr) {\n+    return bottom;\n+  }\n@@ -1233,3 +1234,4 @@\n-    \/\/ Check for min_jint % '-1', result is defined to be '0'.\n-    if (i1->get_con() == min_jint && i2->get_con() == -1) {\n-      return TypeInt::ZERO;\n+    \/\/ Check for min_jlong % '-1', result is defined to be '0'\n+    \/\/ We don't need to check for min_jint % '-1' as its result is defined when using jlong.\n+    if (i1->get_con_as_long(bt) == min_jlong && i2->get_con_as_long(bt) == -1) {\n+      return TypeInteger::zero(bt);\n@@ -1237,1 +1239,1 @@\n-    return TypeInt::make(i1->get_con() % i2->get_con());\n+    return TypeInteger::make(i1->get_con_as_long(bt) % i2->get_con_as_long(bt), bt);\n@@ -1239,2 +1241,1 @@\n-\n-  \/\/ The magnitude of the divisor is in range [1, 2^31].\n+  \/\/ The magnitude of the divisor is in range [1, 2^63].\n@@ -1243,6 +1244,6 @@\n-  juint divisor_magnitude = MAX2(g_uabs(i2->_lo), g_uabs(i2->_hi));\n-  \/\/ JVMS irem bytecode: \"the magnitude of the result is always less than the magnitude of the divisor\"\n-  \/\/ \"less than\" means we can subtract 1 to get an inclusive upper bound in [0, 2^31-1]\n-  jint hi = static_cast<jint>(divisor_magnitude - 1);\n-  jint lo = -hi;\n-  \/\/ JVMS irem bytecode: \"the result of the remainder operation can be negative only if the dividend\n+  julong divisor_magnitude = MAX2(g_uabs(i2->lo_as_long()), g_uabs(i2->hi_as_long()));\n+  \/\/ JVMS lrem bytecode: \"the magnitude of the result is always less than the magnitude of the divisor\"\n+  \/\/ \"less than\" means we can subtract 1 to get an inclusive upper bound in [0, 2^63-1]\n+  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n+  jlong lo = -hi;\n+  \/\/ JVMS lrem bytecode: \"the result of the remainder operation can be negative only if the dividend\n@@ -1253,1 +1254,1 @@\n-  if (i1->_hi <= 0) {\n+  if (i1->hi_as_long() <= 0) {\n@@ -1257,2 +1258,2 @@\n-    lo = MAX2(lo, i1->_lo);\n-  } else if (i1->_lo >= 0) {\n+    lo = MAX2(lo, i1->lo_as_long());\n+  } else if (i1->lo_as_long() >= 0) {\n@@ -1262,1 +1263,1 @@\n-    hi = MIN2(hi, i1->_hi);\n+    hi = MIN2(hi, i1->hi_as_long());\n@@ -1264,1 +1265,1 @@\n-    \/\/ Mixed signs, so  we don't know the sign of the result, but the result is\n+    \/\/ Mixed signs, so we don't know the sign of the result, but the result is\n@@ -1268,2 +1269,2 @@\n-    lo = MAX2(lo, i1->_lo);\n-    hi = MIN2(hi, i1->_hi);\n+    lo = MAX2(lo, i1->lo_as_long());\n+    hi = MIN2(hi, i1->hi_as_long());\n@@ -1271,1 +1272,5 @@\n-  return TypeInt::make(lo, hi, MAX2(i1->_widen,i2->_widen));\n+  return TypeInteger::make(lo, hi, MAX2(i1->_widen,i2->_widen), bt);\n+}\n+\n+const Type* ModINode::Value(PhaseGVN* phase) const {\n+  return mod_value(phase, in(1), in(2), T_INT, bottom_type());\n@@ -1500,65 +1505,1 @@\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ We always generate the dynamic check for 0.\n-  \/\/ 0 MOD X is 0\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ X MOD X is 0\n-  if (in(1) == in(2)) {\n-    return TypeLong::ZERO;\n-  }\n-\n-  const TypeLong *i1 = t1->isa_long();\n-  const TypeLong *i2 = t2->isa_long();\n-\n-  if (i1 == nullptr || i2 == nullptr) {\n-    return bottom_type();\n-  }\n-\n-  \/\/ Mod by zero?  Throw exception at runtime!\n-  if (i2->is_con() && i2->get_con() == 0) {\n-    return TypeLong::TOP;\n-  }\n-  if (i1->is_con() && i2->is_con()) {\n-    \/\/ We must be modulo'ing 2 long constants.\n-    \/\/ Check for min_jlong % '-1', result is defined to be '0'.\n-    if (i1->get_con() == min_jint && i2->get_con() == -1) {\n-      return TypeLong::ZERO;\n-    }\n-    return TypeLong::make(i1->get_con() % i2->get_con());\n-  }\n-  \/\/ The magnitude of the divisor is in range [1, 2^63].\n-  \/\/ We know it isn't 0 as we handled that above.\n-  \/\/ That means at least one value is nonzero, so its absolute value is bigger than zero.\n-  julong divisor_magnitude = MAX2(g_uabs(i2->_lo), g_uabs(i2->_hi));\n-  \/\/ JVMS lrem bytecode: \"the magnitude of the result is always less than the magnitude of the divisor\"\n-  \/\/ \"less than\" means we can subtract 1 to get an inclusive upper bound in [0, 2^63-1]\n-  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n-  jlong lo = -hi;\n-  \/\/ JVMS lrem bytecode: \"the result of the remainder operation can be negative only if the dividend\n-  \/\/ is negative and can be positive only if the dividend is positive\"\n-  \/\/ Note that with a dividend with bounds e.g. lo == -4 and hi == -1 can still result in values\n-  \/\/ below lo; i.e., -3 % 3 == 0.\n-  \/\/ That means we cannot restrict the bound that is closer to zero beyond knowing its sign (or zero).\n-  if (i1->_hi <= 0) {\n-    \/\/ all dividends are not positive, so the result is not positive\n-    hi = 0;\n-    \/\/ if the dividend is known to be closer to zero, use that as a lower limit\n-    lo = MAX2(lo, i1->_lo);\n-  } else if (i1->_lo >= 0) {\n-    \/\/ all dividends are not negative, so the result is not negative\n-    lo = 0;\n-    \/\/ if the dividend is known to be closer to zero, use that as an upper limit\n-    hi = MIN2(hi, i1->_hi);\n-  } else {\n-    \/\/ Mixed signs, so we don't know the sign of the result, but the result is\n-    \/\/ either the dividend itself or a value closer to zero than the dividend,\n-    \/\/ and it is closer to zero than the divisor.\n-    \/\/ As we know i1->_lo < 0 and i1->_hi > 0, we can use these bounds directly.\n-    lo = MAX2(lo, i1->_lo);\n-    hi = MIN2(hi, i1->_hi);\n-  }\n-  return TypeLong::make(lo, hi, MAX2(i1->_widen,i2->_widen));\n+  return mod_value(phase, in(1), in(2), T_LONG, bottom_type());\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":41,"deletions":100,"binary":false,"changes":141,"status":"modified"}]}