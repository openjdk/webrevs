{"files":[{"patch":"@@ -1201,1 +1201,2 @@\n-const Type* ModINode::Value(PhaseGVN* phase) const {\n+static const Type* mod_value(const PhaseGVN* phase, const Node* in1, const Node* in2, const BasicType bt) {\n+  assert(bt == T_INT || bt == T_LONG, \"unexpected basic type\");\n@@ -1203,4 +1204,4 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP) { return Type::TOP; }\n+  if (t2 == Type::TOP) { return Type::TOP; }\n@@ -1210,1 +1211,2 @@\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n+  if (t1 == TypeInteger::zero(bt)) { return t1; }\n+\n@@ -1212,2 +1214,2 @@\n-  if (in(1) == in(2)) {\n-    return TypeInt::ZERO;\n+  if (in1 == in2) {\n+    return TypeInteger::zero(bt);\n@@ -1216,14 +1218,0 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  const TypeInt *i1 = t1->is_int();\n-  const TypeInt *i2 = t2->is_int();\n-  if( !i1->is_con() || !i2->is_con() ) {\n-    if( i1->_lo >= 0 && i2->_lo >= 0 )\n-      return TypeInt::POS;\n-    \/\/ If both numbers are not constants, we know little.\n-    return TypeInt::INT;\n-  }\n@@ -1231,1 +1219,3 @@\n-  if( !i2->get_con() ) return TypeInt::POS;\n+  if (t2 == TypeInteger::zero(bt)) {\n+    return Type::TOP;\n+  }\n@@ -1233,4 +1223,45 @@\n-  \/\/ We must be modulo'ing 2 float constants.\n-  \/\/ Check for min_jint % '-1', result is defined to be '0'.\n-  if( i1->get_con() == min_jint && i2->get_con() == -1 )\n-    return TypeInt::ZERO;\n+  const TypeInteger* i1 = t1->is_integer(bt);\n+  const TypeInteger* i2 = t2->is_integer(bt);\n+  if (i1->is_con() && i2->is_con()) {\n+    \/\/ We must be modulo'ing 2 int constants.\n+    \/\/ Special case: min_jlong % '-1' is UB, and e.g., x86 triggers a division error.\n+    \/\/ Any value % -1 is 0, so we can return 0 and avoid that scenario.\n+    if (i2->get_con_as_long(bt) == -1) {\n+      return TypeInteger::zero(bt);\n+    }\n+    return TypeInteger::make(i1->get_con_as_long(bt) % i2->get_con_as_long(bt), bt);\n+  }\n+  \/\/ We checked that t2 is not the zero constant. Hence, at least i2->_lo or i2->_hi must be non-zero,\n+  \/\/ and hence its absoute value is bigger than zero. Hence, the magnitude of the divisor (i.e. the\n+  \/\/ largest absolute value for any value in i2) must be in the range [1, 2^31] or [1, 2^63], depending\n+  \/\/ on the BasicType.\n+  julong divisor_magnitude = MAX2(g_uabs(i2->lo_as_long()), g_uabs(i2->hi_as_long()));\n+  \/\/ JVMS lrem bytecode: \"the magnitude of the result is always less than the magnitude of the divisor\"\n+  \/\/ \"less than\" means we can subtract 1 to get an inclusive upper bound in [0, 2^31-1] or [0, 2^63-1], respectively\n+  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n+  jlong lo = -hi;\n+  \/\/ JVMS lrem bytecode: \"the result of the remainder operation can be negative only if the dividend\n+  \/\/ is negative and can be positive only if the dividend is positive\"\n+  \/\/ Note that with a dividend with bounds e.g. lo == -4 and hi == -1 can still result in values\n+  \/\/ below lo; i.e., -3 % 3 == 0.\n+  \/\/ That means we cannot restrict the bound that is closer to zero beyond knowing its sign (or zero).\n+  if (i1->hi_as_long() <= 0) {\n+    \/\/ all dividends are not positive, so the result is not positive\n+    hi = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as a lower limit\n+    lo = MAX2(lo, i1->lo_as_long());\n+  } else if (i1->lo_as_long() >= 0) {\n+    \/\/ all dividends are not negative, so the result is not negative\n+    lo = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as an upper limit\n+    hi = MIN2(hi, i1->hi_as_long());\n+  } else {\n+    \/\/ Mixed signs, so we don't know the sign of the result, but the result is\n+    \/\/ either the dividend itself or a value closer to zero than the dividend,\n+    \/\/ and it is closer to zero than the divisor.\n+    \/\/ As we know i1->_lo < 0 and i1->_hi > 0, we can use these bounds directly.\n+    lo = MAX2(lo, i1->lo_as_long());\n+    hi = MIN2(hi, i1->hi_as_long());\n+  }\n+  return TypeInteger::make(lo, hi, MAX2(i1->_widen, i2->_widen), bt);\n+}\n@@ -1238,1 +1269,2 @@\n-  return TypeInt::make( i1->get_con() % i2->get_con() );\n+const Type* ModINode::Value(PhaseGVN* phase) const {\n+  return mod_value(phase, in(1), in(2), T_INT);\n@@ -1467,37 +1499,1 @@\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ We always generate the dynamic check for 0.\n-  \/\/ 0 MOD X is 0\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ X MOD X is 0\n-  if (in(1) == in(2)) {\n-    return TypeLong::ZERO;\n-  }\n-\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  const TypeLong *i1 = t1->is_long();\n-  const TypeLong *i2 = t2->is_long();\n-  if( !i1->is_con() || !i2->is_con() ) {\n-    if( i1->_lo >= CONST64(0) && i2->_lo >= CONST64(0) )\n-      return TypeLong::POS;\n-    \/\/ If both numbers are not constants, we know little.\n-    return TypeLong::LONG;\n-  }\n-  \/\/ Mod by zero?  Throw exception at runtime!\n-  if( !i2->get_con() ) return TypeLong::POS;\n-\n-  \/\/ We must be modulo'ing 2 float constants.\n-  \/\/ Check for min_jint % '-1', result is defined to be '0'.\n-  if( i1->get_con() == min_jlong && i2->get_con() == -1 )\n-    return TypeLong::ZERO;\n-\n-  return TypeLong::make( i1->get_con() % i2->get_con() );\n+  return mod_value(phase, in(1), in(2), T_LONG);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":61,"deletions":65,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.ForceInline;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8356813\n+ * @summary Test that Value method of ModINode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.ModINodeValueTests\n+ *\/\n+public class ModINodeValueTests {\n+    private static final RestrictableGenerator<Integer> INT_GEN = Generators.G.ints();\n+    private static final int POS_INT = INT_GEN.restricted(1, Integer.MAX_VALUE).next();\n+    private static final int NEG_INT = INT_GEN.restricted(Integer.MIN_VALUE, -1).next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"nonNegativeDividend\", \"nonNegativeDividendInRange\",\n+        \"negativeDividend\", \"negativeDividendInRange\",\n+        \"modByKnownBoundsUpper\", \"modByKnownBoundsUpperInRange\",\n+        \"modByKnownBoundsLower\", \"modByKnownBoundsLowerInRange\",\n+        \"modByKnownBoundsLimitedByDividendUpper\", \"modByKnownBoundsLimitedByDividendUpperInRange\",\n+        \"modByKnownBoundsLimitedByDividendLower\", \"modByKnownBoundsLimitedByDividendLowerInRange\",\n+        \"testRandomLimits\"\n+    })\n+    public void runMethod() {\n+        int a = INT_GEN.next();\n+        int b = INT_GEN.next();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x, int y) {\n+        Asserts.assertEQ(x != 0 && POS_INT % x < 0, nonNegativeDividend(x));\n+        Asserts.assertEQ(x != 0 && POS_INT % x <= 0, nonNegativeDividendInRange(x));\n+        Asserts.assertEQ(x != 0 && NEG_INT % x > 0, negativeDividend(x));\n+        Asserts.assertEQ(x != 0 && NEG_INT % x >= 0, negativeDividendInRange(x));\n+        Asserts.assertEQ(x % (((byte) y) + 129) > 255, modByKnownBoundsUpper(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) >= 255, modByKnownBoundsUpperInRange(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) < -255, modByKnownBoundsLower(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) <= -255, modByKnownBoundsLowerInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) > 127, modByKnownBoundsLimitedByDividendUpper(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) >= 127, modByKnownBoundsLimitedByDividendUpperInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) < -128, modByKnownBoundsLimitedByDividendLower(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) <= -128, modByKnownBoundsLimitedByDividendLowerInRange(x, y));\n+\n+        int res;\n+        try {\n+            res = testRandomLimitsInterpreted(x, y);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testRandomLimits(x, y);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testRandomLimits(x, y));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., POS_INT % x < 0 => false.\n+    public boolean nonNegativeDividend(int x) {\n+        return x != 0 && POS_INT % x < 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., POS_INT % x < 0 => false.\n+    \/\/ This uses <= to verify the % is not optimized away\n+    public boolean nonNegativeDividendInRange(int x) {\n+        return x != 0 && POS_INT % x <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., NEG_INT % x > 0 => false.\n+    public boolean negativeDividend(int x) {\n+        return x != 0 && NEG_INT % x > 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., NEG_INT % x > 0 => false.\n+    \/\/ This uses >= to verify the % is not optimized away\n+    public boolean negativeDividendInRange(int x) {\n+        return x != 0 && NEG_INT % x >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpper(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129) > 255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpperInRange(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129) >= 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLower(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129) < -255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLowerInRange(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129) <= -255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpper(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1) > 127;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpperInRange(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1) >= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLower(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1) < -128;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLowerInRange(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1) <= -128;\n+    }\n+\n+    private static final int LIMIT_1 = INT_GEN.next();\n+    private static final int LIMIT_2 = INT_GEN.next();\n+    private static final int LIMIT_3 = INT_GEN.next();\n+    private static final int LIMIT_4 = INT_GEN.next();\n+    private static final int LIMIT_5 = INT_GEN.next();\n+    private static final int LIMIT_6 = INT_GEN.next();\n+    private static final int LIMIT_7 = INT_GEN.next();\n+    private static final int LIMIT_8 = INT_GEN.next();\n+    private static final Range RANGE_1 = Range.generate(INT_GEN);\n+    private static final Range RANGE_2 = Range.generate(INT_GEN);\n+\n+    @Test\n+    public int testRandomLimits(int x, int y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        int z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @DontCompile\n+    public int testRandomLimitsInterpreted(int x, int y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        int z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    record Range(int lo, int hi) {\n+        Range {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        @ForceInline\n+        int clamp(int v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static Range generate(Generator<Integer> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new Range(a, b);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModINodeValueTests.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.ForceInline;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8356813\n+ * @summary Test that Value method of ModLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.ModLNodeValueTests\n+ *\/\n+public class ModLNodeValueTests {\n+    private static final Generator<Long> LONG_GEN = Generators.G.longs();\n+    private static final long POS_LONG = Generators.G.longs().restricted(1L, Long.MAX_VALUE).next();\n+    private static final long NEG_LONG = Generators.G.longs().restricted(Long.MIN_VALUE, -1L).next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"nonNegativeDividend\", \"nonNegativeDividendInRange\",\n+        \"negativeDividend\", \"negativeDividendInRange\",\n+        \"modByKnownBoundsUpper\", \"modByKnownBoundsUpperInRange\",\n+        \"modByKnownBoundsLower\", \"modByKnownBoundsLowerInRange\",\n+        \"modByKnownBoundsLimitedByDividendUpper\", \"modByKnownBoundsLimitedByDividendUpperInRange\",\n+        \"modByKnownBoundsLimitedByDividendLower\", \"modByKnownBoundsLimitedByDividendLowerInRange\",\n+        \"testRandomLimits\"\n+    })\n+    public void runMethod() {\n+        long a = LONG_GEN.next();\n+        long b = LONG_GEN.next();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long x, long y) {\n+        Asserts.assertEQ(x != 0 && POS_LONG % x < 0, nonNegativeDividend(x));\n+        Asserts.assertEQ(x != 0 && POS_LONG % x <= 0, nonNegativeDividendInRange(x));\n+        Asserts.assertEQ(x != 0 && NEG_LONG % x > 0, negativeDividend(x));\n+        Asserts.assertEQ(x != 0 && NEG_LONG % x >= 0, negativeDividendInRange(x));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) > 255, modByKnownBoundsUpper(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) >= 255, modByKnownBoundsUpperInRange(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) < -255, modByKnownBoundsLower(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) <= -255, modByKnownBoundsLowerInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) > 127, modByKnownBoundsLimitedByDividendUpper(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) >= 127, modByKnownBoundsLimitedByDividendUpperInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) < -128, modByKnownBoundsLimitedByDividendLower(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) <= -128, modByKnownBoundsLimitedByDividendLowerInRange(x, y));\n+\n+        int res;\n+        try {\n+            res = testRandomLimitsInterpreted(x, y);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testRandomLimits(x, y);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testRandomLimits(x, y));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    public boolean nonNegativeDividend(long x) {\n+        return x != 0 && POS_LONG % x < 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    \/\/ This uses <= to verify the % is not optimized away\n+    public boolean nonNegativeDividendInRange(long x) {\n+        return x != 0 && POS_LONG % x <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    public boolean negativeDividend(long x) {\n+        return x != 0 && NEG_LONG % x > 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    \/\/ This uses >= to verify the % is not optimized away\n+    public boolean negativeDividendInRange(long x) {\n+        return x != 0 && NEG_LONG % x >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpper(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129L) > 255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpperInRange(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129L) >= 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLower(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129L) < -255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLowerInRange(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129L) <= -255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpper(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1L) > 127;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpperInRange(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1L) >= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLower(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1L) < -128;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLowerInRange(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1L) <= -128;\n+    }\n+\n+\n+    private static final long LIMIT_1 = LONG_GEN.next();\n+    private static final long LIMIT_2 = LONG_GEN.next();\n+    private static final long LIMIT_3 = LONG_GEN.next();\n+    private static final long LIMIT_4 = LONG_GEN.next();\n+    private static final long LIMIT_5 = LONG_GEN.next();\n+    private static final long LIMIT_6 = LONG_GEN.next();\n+    private static final long LIMIT_7 = LONG_GEN.next();\n+    private static final long LIMIT_8 = LONG_GEN.next();\n+    private static final Range RANGE_1 = Range.generate(LONG_GEN);\n+    private static final Range RANGE_2 = Range.generate(LONG_GEN);\n+\n+    @Test\n+    public int testRandomLimits(long x, long y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        long z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @DontCompile\n+    public int testRandomLimitsInterpreted(long x, long y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        long z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    record Range(long lo, long hi) {\n+        Range {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        @ForceInline\n+        long clamp(long v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static Range generate(Generator<Long> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new Range(a, b);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModLNodeValueTests.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"}]}