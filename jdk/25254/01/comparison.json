{"files":[{"patch":"@@ -1221,5 +1221,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  const TypeInt *i1 = t1->isa_int();\n+  const TypeInt *i2 = t2->isa_int();\n@@ -1227,7 +1224,2 @@\n-  const TypeInt *i1 = t1->is_int();\n-  const TypeInt *i2 = t2->is_int();\n-  if( !i1->is_con() || !i2->is_con() ) {\n-    if( i1->_lo >= 0 && i2->_lo >= 0 )\n-      return TypeInt::POS;\n-    \/\/ If both numbers are not constants, we know little.\n-    return TypeInt::INT;\n+  if (i1 == nullptr || i2 == nullptr) {\n+    return bottom_type();\n@@ -1236,6 +1228,11 @@\n-  if( !i2->get_con() ) return TypeInt::POS;\n-\n-  \/\/ We must be modulo'ing 2 float constants.\n-  \/\/ Check for min_jint % '-1', result is defined to be '0'.\n-  if( i1->get_con() == min_jint && i2->get_con() == -1 )\n-    return TypeInt::ZERO;\n+  if (i2->is_con() && i2->get_con() == 0) {\n+    return TypeInt::TOP;\n+  }\n+  if (i1->is_con() && i2->is_con()) {\n+    \/\/ We must be modulo'ing 2 int constants.\n+    \/\/ Check for min_jint % '-1', result is defined to be '0'.\n+    if (i1->get_con() == min_jint && i2->get_con() == -1) {\n+      return TypeInt::ZERO;\n+    }\n+    return TypeInt::make(i1->get_con() % i2->get_con());\n+  }\n@@ -1243,1 +1240,32 @@\n-  return TypeInt::make( i1->get_con() % i2->get_con() );\n+  \/\/ The magnitude of the divisor is in range [1, 2^31].\n+  \/\/ We know it isn't 0 as we handled that above.\n+  \/\/ That means at least one value is nonzero, so its absolute value is bigger than zero.\n+  juint divisor_magnitude = MAX2(g_uabs(i2->_lo), g_uabs(i2->_hi));\n+  \/\/ JVMS irem bytecode: \"the magnitude of the result is always less than the magnitude of the divisor\"\n+  \/\/ \"less than\" means we can subtract 1 to get an inclusive upper bound in [0, 2^31-1]\n+  jint hi = static_cast<jint>(divisor_magnitude - 1);\n+  jint lo = -hi;\n+  \/\/ JVMS irem bytecode: \"the result of the remainder operation can be negative only if the dividend\n+  \/\/ is negative and can be positive only if the dividend is positive\"\n+  \/\/ Note that with a dividend with bounds e.g. lo == -4 and hi == -1 can still result in values\n+  \/\/ below lo; i.e., -3 % 3 == 0.\n+  \/\/ That means we cannot restrict the bound that is closer to zero beyond knowing its sign (or zero).\n+  if (i1->_hi <= 0) {\n+    \/\/ all dividends are not positive, so the result is not positive\n+    hi = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as a lower limit\n+    lo = MAX2(lo, i1->_lo);\n+  } else if (i1->_lo >= 0) {\n+    \/\/ all dividends are not negative, so the result is not negative\n+    lo = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as an upper limit\n+    hi = MIN2(hi, i1->_hi);\n+  } else {\n+    \/\/ Mixed signs, so  we don't know the sign of the result, but the result is\n+    \/\/ either the dividend itself or a value closer to zero than the dividend,\n+    \/\/ and it is closer to zero than the divisor.\n+    \/\/ As we know i1->_lo < 0 and i1->_hi > 0, we can use these bounds directly.\n+    lo = MAX2(lo, i1->_lo);\n+    hi = MIN2(hi, i1->_hi);\n+  }\n+  return TypeInt::make(lo, hi, MAX2(i1->_widen,i2->_widen));\n@@ -1486,5 +1514,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  const TypeLong *i1 = t1->isa_long();\n+  const TypeLong *i2 = t2->isa_long();\n@@ -1492,7 +1517,2 @@\n-  const TypeLong *i1 = t1->is_long();\n-  const TypeLong *i2 = t2->is_long();\n-  if( !i1->is_con() || !i2->is_con() ) {\n-    if( i1->_lo >= CONST64(0) && i2->_lo >= CONST64(0) )\n-      return TypeLong::POS;\n-    \/\/ If both numbers are not constants, we know little.\n-    return TypeLong::LONG;\n+  if (i1 == nullptr || i2 == nullptr) {\n+    return bottom_type();\n@@ -1500,2 +1520,0 @@\n-  \/\/ Mod by zero?  Throw exception at runtime!\n-  if( !i2->get_con() ) return TypeLong::POS;\n@@ -1503,6 +1521,44 @@\n-  \/\/ We must be modulo'ing 2 float constants.\n-  \/\/ Check for min_jint % '-1', result is defined to be '0'.\n-  if( i1->get_con() == min_jlong && i2->get_con() == -1 )\n-    return TypeLong::ZERO;\n-\n-  return TypeLong::make( i1->get_con() % i2->get_con() );\n+  \/\/ Mod by zero?  Throw exception at runtime!\n+  if (i2->is_con() && i2->get_con() == 0) {\n+    return TypeLong::TOP;\n+  }\n+  if (i1->is_con() && i2->is_con()) {\n+    \/\/ We must be modulo'ing 2 long constants.\n+    \/\/ Check for min_jlong % '-1', result is defined to be '0'.\n+    if (i1->get_con() == min_jint && i2->get_con() == -1) {\n+      return TypeLong::ZERO;\n+    }\n+    return TypeLong::make(i1->get_con() % i2->get_con());\n+  }\n+  \/\/ The magnitude of the divisor is in range [1, 2^63].\n+  \/\/ We know it isn't 0 as we handled that above.\n+  \/\/ That means at least one value is nonzero, so its absolute value is bigger than zero.\n+  julong divisor_magnitude = MAX2(g_uabs(i2->_lo), g_uabs(i2->_hi));\n+  \/\/ JVMS lrem bytecode: \"the magnitude of the result is always less than the magnitude of the divisor\"\n+  \/\/ \"less than\" means we can subtract 1 to get an inclusive upper bound in [0, 2^63-1]\n+  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n+  jlong lo = -hi;\n+  \/\/ JVMS lrem bytecode: \"the result of the remainder operation can be negative only if the dividend\n+  \/\/ is negative and can be positive only if the dividend is positive\"\n+  \/\/ Note that with a dividend with bounds e.g. lo == -4 and hi == -1 can still result in values\n+  \/\/ below lo; i.e., -3 % 3 == 0.\n+  \/\/ That means we cannot restrict the bound that is closer to zero beyond knowing its sign (or zero).\n+  if (i1->_hi <= 0) {\n+    \/\/ all dividends are not positive, so the result is not positive\n+    hi = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as a lower limit\n+    lo = MAX2(lo, i1->_lo);\n+  } else if (i1->_lo >= 0) {\n+    \/\/ all dividends are not negative, so the result is not negative\n+    lo = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as an upper limit\n+    hi = MIN2(hi, i1->_hi);\n+  } else {\n+    \/\/ Mixed signs, so we don't know the sign of the result, but the result is\n+    \/\/ either the dividend itself or a value closer to zero than the dividend,\n+    \/\/ and it is closer to zero than the divisor.\n+    \/\/ As we know i1->_lo < 0 and i1->_hi > 0, we can use these bounds directly.\n+    lo = MAX2(lo, i1->_lo);\n+    hi = MIN2(hi, i1->_hi);\n+  }\n+  return TypeLong::make(lo, hi, MAX2(i1->_widen,i2->_widen));\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":95,"deletions":39,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8356813\n+ * @summary Test that Value method of ModINode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.ModINodeValueTests\n+ *\/\n+public class ModINodeValueTests {\n+    private static final Generator<Integer> INT_GEN = Generators.G.ints();\n+    private static final int POS_INT = Generators.G.ints().restricted(1, Integer.MAX_VALUE).next();\n+    private static final int NEG_INT = Generators.G.ints().restricted(Integer.MIN_VALUE, -1).next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"nonNegativeDividend\", \"nonNegativeDividendInRange\",\n+        \"negativeDividend\", \"negativeDividendInRange\",\n+        \"modByKnownBoundsUpper\", \"modByKnownBoundsUpperInRange\",\n+        \"modByKnownBoundsLower\", \"modByKnownBoundsLowerInRange\",\n+        \"modByKnownBoundsLimitedByDividendUpper\", \"modByKnownBoundsLimitedByDividendUpperInRange\",\n+        \"modByKnownBoundsLimitedByDividendLower\", \"modByKnownBoundsLimitedByDividendLowerInRange\"\n+    })\n+    public void runMethod() {\n+        int a = INT_GEN.next();\n+        int b = INT_GEN.next();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x, int y) {\n+        Asserts.assertEQ(x != 0 && POS_INT % x < 0, nonNegativeDividend(x));\n+        Asserts.assertEQ(x != 0 && POS_INT % x <= 0, nonNegativeDividendInRange(x));\n+        Asserts.assertEQ(x != 0 && NEG_INT % x > 0, negativeDividend(x));\n+        Asserts.assertEQ(x != 0 && NEG_INT % x >= 0, negativeDividendInRange(x));\n+        Asserts.assertEQ(x % (((byte) y) + 129) > 255, modByKnownBoundsUpper(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) >= 255, modByKnownBoundsUpperInRange(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) < -255, modByKnownBoundsLower(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) <= -255, modByKnownBoundsLowerInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) > 127, modByKnownBoundsLimitedByDividendUpper(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) >= 127, modByKnownBoundsLimitedByDividendUpperInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) < -128, modByKnownBoundsLimitedByDividendLower(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) <= -128, modByKnownBoundsLimitedByDividendLowerInRange(x, y));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    public boolean nonNegativeDividend(int x) {\n+        return x != 0 && POS_INT % x < 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    \/\/ This uses <= to verify the % is not optimized away\n+    public boolean nonNegativeDividendInRange(int x) {\n+        return x != 0 && POS_INT % x <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    public boolean negativeDividend(int x) {\n+        return x != 0 && NEG_INT % x > 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    \/\/ This uses >= to verify the % is not optimized away\n+    public boolean negativeDividendInRange(int x) {\n+        return x != 0 && NEG_INT % x >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpper(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129) > 255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpperInRange(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129) >= 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLower(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129) < -255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLowerInRange(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129) <= -255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpper(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1) > 127;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpperInRange(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1) >= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLower(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1) < -128;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLowerInRange(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1) <= -128;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModINodeValueTests.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8356813\n+ * @summary Test that Value method of ModLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.ModLNodeValueTests\n+ *\/\n+public class ModLNodeValueTests {\n+    private static final Generator<Long> LONG_GEN = Generators.G.longs();\n+    private static final long POS_LONG = Generators.G.longs().restricted(1L, Long.MAX_VALUE).next();\n+    private static final long NEG_LONG = Generators.G.longs().restricted(Long.MIN_VALUE, -1L).next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"nonNegativeDividend\", \"nonNegativeDividendInRange\",\n+        \"negativeDividend\", \"negativeDividendInRange\",\n+        \"modByKnownBoundsUpper\", \"modByKnownBoundsUpperInRange\",\n+        \"modByKnownBoundsLower\", \"modByKnownBoundsLowerInRange\",\n+        \"modByKnownBoundsLimitedByDividendUpper\", \"modByKnownBoundsLimitedByDividendUpperInRange\",\n+        \"modByKnownBoundsLimitedByDividendLower\", \"modByKnownBoundsLimitedByDividendLowerInRange\"\n+    })\n+    public void runMethod() {\n+        long a = LONG_GEN.next();\n+        long b = LONG_GEN.next();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long x, long y) {\n+        Asserts.assertEQ(x != 0 && POS_LONG % x < 0, nonNegativeDividend(x));\n+        Asserts.assertEQ(x != 0 && POS_LONG % x <= 0, nonNegativeDividendInRange(x));\n+        Asserts.assertEQ(x != 0 && NEG_LONG % x > 0, negativeDividend(x));\n+        Asserts.assertEQ(x != 0 && NEG_LONG % x >= 0, negativeDividendInRange(x));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) > 255, modByKnownBoundsUpper(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) >= 255, modByKnownBoundsUpperInRange(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) < -255, modByKnownBoundsLower(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) <= -255, modByKnownBoundsLowerInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) > 127, modByKnownBoundsLimitedByDividendUpper(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) >= 127, modByKnownBoundsLimitedByDividendUpperInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) < -128, modByKnownBoundsLimitedByDividendLower(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) <= -128, modByKnownBoundsLimitedByDividendLowerInRange(x, y));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    public boolean nonNegativeDividend(long x) {\n+        return x != 0 && POS_LONG % x < 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    \/\/ This uses <= to verify the % is not optimized away\n+    public boolean nonNegativeDividendInRange(long x) {\n+        return x != 0 && POS_LONG % x <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    public boolean negativeDividend(long x) {\n+        return x != 0 && NEG_LONG % x > 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    \/\/ This uses >= to verify the % is not optimized away\n+    public boolean negativeDividendInRange(long x) {\n+        return x != 0 && NEG_LONG % x >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpper(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129L) > 255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpperInRange(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129L) >= 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLower(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129L) < -255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLowerInRange(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129L) <= -255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpper(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1L) > 127;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpperInRange(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1L) >= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLower(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1L) < -128;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLowerInRange(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1L) <= -128;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModLNodeValueTests.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}