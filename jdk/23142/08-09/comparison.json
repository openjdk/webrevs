{"files":[{"patch":"@@ -41,0 +41,16 @@\n+    public long currentOffset() {\n+        return sp;\n+    }\n+\n+    public void resetTo(long offset) {\n+        if (offset < 0 || offset > sp)\n+            throw new IllegalArgumentException(String.format(\"offset %d should be in [0, %d] \", offset, sp));\n+        this.sp = offset;\n+    }\n+\n+    public boolean canAllocate(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        return start + byteSize <= segment.byteSize();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,4 @@\n+import jdk.internal.foreign.SlicingAllocator;\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n@@ -5,0 +9,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -8,3 +13,1 @@\n-    private final MemorySegment backingSegment;\n-    private final ReentrantLock lock = new ReentrantLock();\n-    private long offset = 0;\n+    private final long size;\n@@ -12,2 +15,2 @@\n-    public BufferStack(MemorySegment backingSegment) {\n-        this.backingSegment = backingSegment;\n+    public BufferStack(long size) {\n+        this.size = size;\n@@ -16,5 +19,4 @@\n-    public Arena reserve(long size) {\n-        if (!lock.tryLock()) {\n-            \/\/ Rare: another virtual thread on the same carrier was preparing or just\n-            \/\/ finished an FFM call, but got unscheduled while holding this stack.\n-            return Arena.ofConfined();\n+    private final TerminatingThreadLocal<PerThread> tl = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread(size);\n@@ -22,4 +24,4 @@\n-        if (offset + size > backingSegment.byteSize()) {\n-            \/\/ Rare: we've running out of stack space due to recursion or unusually large buffers.\n-            lock.unlock();\n-            return Arena.ofConfined();\n+\n+        @Override\n+        protected void threadTerminated(PerThread value) {\n+            value.close();\n@@ -27,0 +29,1 @@\n+    };\n@@ -28,1 +31,3 @@\n-        return new Frame();\n+    @ForceInline\n+    public Arena pushFrame(long size, long byteAlignment) {\n+        return tl.get().pushFrame(size, byteAlignment);\n@@ -31,3 +36,4 @@\n-    private class Frame implements Arena {\n-        final long parentOffset = offset;\n-        final Arena scope = Arena.ofConfined();\n+    private static final class PerThread {\n+        private final ReentrantLock lock = new ReentrantLock();\n+        private final Arena owner = Arena.ofConfined();\n+        private final SlicingAllocator stack;\n@@ -35,6 +41,2 @@\n-        @Override\n-        @SuppressWarnings(\"restricted\")\n-        public MemorySegment allocate(long byteSize, long byteAlignment) {\n-            MemorySegment slice = backingSegment.asSlice(offset, byteSize, byteAlignment);\n-            offset += byteSize;\n-            return slice.reinterpret(scope, null);\n+        public PerThread(long size) {\n+            this.stack = new SlicingAllocator(owner.allocate(size));\n@@ -43,3 +45,2 @@\n-        @Override\n-        public MemorySegment.Scope scope() {\n-            return scope.scope();\n+        void close() {\n+            owner.close();\n@@ -48,5 +49,58 @@\n-        @Override\n-        public void close() {\n-            scope.close();\n-            offset = parentOffset;\n-            lock.unlock();\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                \/\/ Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        private class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long tos;\n+            private final Arena scope = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                tos = stack.currentOffset();\n+                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+            }\n+\n+            private void assertOrder() {\n+                if (tos != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not TOS\");\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                assertOrder();\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return scope.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                scope.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+            }\n@@ -55,1 +109,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferStack.java","additions":87,"deletions":33,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -386,6 +386,1 @@\n-    private static final CarrierThreadLocal<BufferStack> BUFFER_STACK = new CarrierThreadLocal<>() {\n-        @Override\n-        protected BufferStack initialValue() {\n-            return new BufferStack(Arena.ofAuto().allocate(256));\n-        }\n-    };\n+    private static final BufferStack LINKER_STACK = new BufferStack(256);\n@@ -393,0 +388,1 @@\n+    @ForceInline\n@@ -394,1 +390,1 @@\n-        return BUFFER_STACK.get().reserve(size);\n+        return LINKER_STACK.pushFrame(size, 8);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}