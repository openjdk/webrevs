{"files":[{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.Continuation;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+\/**\n+ * Provides carrier-thread-local storage for up to two small buffers.\n+ *\/\n+public final class CallBufferCache {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    static class PerThread {\n+        \/\/ Two-elements to support downcall + upcall.\n+        \/\/ Storing addresses, not MemorySegments turns out to be slightly faster (write barrier?).\n+        private long address1;\n+        private long address2;\n+\n+        long pop() {\n+            if (address1 != 0) {\n+                long result = address1;\n+                address1 = 0;\n+                return result;\n+            }\n+            if (address2 != 0) {\n+                long result = address2;\n+                address2 = 0;\n+                return result;\n+            }\n+            return 0;\n+        }\n+\n+        boolean push(long address) {\n+            if (address1 == 0) {\n+                address1 = address;\n+                return true;\n+            }\n+            if (address2 == 0) {\n+                address2 = address;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        void free() {\n+            if (address1 != 0) UNSAFE.freeMemory(address1);\n+            if (address2 != 0) UNSAFE.freeMemory(address2);\n+        }\n+    }\n+\n+    private static final TerminatingThreadLocal<PerThread> tl = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread();\n+        }\n+\n+        @Override\n+        protected void threadTerminated(PerThread cache) {\n+            cache.free();\n+        }\n+    };\n+\n+    \/\/ acquire\/release visible only for tests\n+\n+    public static long acquire() {\n+        \/\/ Protect against vthread unmount.\n+        Continuation.pin();\n+        try {\n+            return tl.get().pop();\n+        } finally {\n+            Continuation.unpin();\n+        }\n+    }\n+\n+    public static boolean release(long address) {\n+        \/\/ Protect against vthread unmount.\n+        Continuation.pin();\n+        try {\n+            return tl.get().push(address);\n+        } finally {\n+            Continuation.unpin();\n+        }\n+    }\n+\n+    private static final long CACHED_BUFFER_SIZE = 256;\n+\n+    @SuppressWarnings(\"restricted\")\n+    public static MemorySegment acquireOrAllocate(long requestedSize) {\n+        final long bufferSize = Math.max(requestedSize, CACHED_BUFFER_SIZE);\n+        long address = (bufferSize == CACHED_BUFFER_SIZE) ? acquire() : 0;\n+        if (address == 0) {\n+            \/\/ Either size was too large or cache empty.\n+            address = UNSAFE.allocateMemory(bufferSize);\n+        }\n+        return MemorySegment.ofAddress(address).reinterpret(requestedSize);\n+    }\n+\n+    public static void releaseOrFree(MemorySegment segment) {\n+        if (segment.byteSize() > CACHED_BUFFER_SIZE || !release(segment.address())) {\n+            \/\/ Either size was too large or cache full.\n+            UNSAFE.freeMemory(segment.address());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallBufferCache.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -63,0 +63,1 @@\n+import java.util.function.Consumer;\n@@ -385,0 +386,2 @@\n+    @ForceInline\n+    @SuppressWarnings(\"restricted\")\n@@ -386,3 +389,9 @@\n-        return new Arena() {\n-            final Arena arena = Arena.ofConfined();\n-            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+        \/\/ JDK-8347997: buffer cache pinned section needs to happen outside of constructor and before\n+        \/\/ confined session, otherwise scalar replacement breaks.\n+        MemorySegment unscoped = CallBufferCache.acquireOrAllocate(size);\n+        Arena scope = Arena.ofConfined();\n+        MemorySegment source = unscoped.reinterpret(scope, null);\n+        \/\/ Preferable we'd like to register this cleanup in the line above\n+        \/\/ but it breaks scalar replacement.\n+        return new BoundedArena(scope, source, CallBufferCache::releaseOrFree);\n+    }\n@@ -390,4 +399,14 @@\n-            @Override\n-            public Scope scope() {\n-                return arena.scope();\n-            }\n+    \/** A confined arena slicing off an (unscoped) source segment. *\/\n+    static final class BoundedArena implements Arena {\n+        private final Arena scope;\n+        private final MemorySegment source;\n+        private final SegmentAllocator allocator;\n+        private final Consumer<MemorySegment> cleanup;\n+\n+        @ForceInline\n+        public BoundedArena(Arena scope, MemorySegment source, Consumer<MemorySegment> cleanup) {\n+            this.scope = scope;\n+            this.source = source;\n+            this.allocator = SegmentAllocator.slicingAllocator(source);\n+            this.cleanup = cleanup;\n+        }\n@@ -395,4 +414,5 @@\n-            @Override\n-            public void close() {\n-                arena.close();\n-            }\n+        @Override\n+        @ForceInline\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n+        }\n@@ -400,5 +420,11 @@\n-            @Override\n-            public MemorySegment allocate(long byteSize, long byteAlignment) {\n-                return slicingAllocator.allocate(byteSize, byteAlignment);\n-            }\n-        };\n+        @Override\n+        public Scope scope() {\n+            return scope.scope();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void close() {\n+            scope.close();\n+            cleanup.accept(source);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":42,"deletions":16,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign.abi  java.base\/jdk.internal.misc\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED CallBufferCacheTest\n+ *\/\n+\n+import jdk.internal.foreign.abi.CallBufferCache;\n+import jdk.internal.misc.Unsafe;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class CallBufferCacheTest {\n+    Unsafe UNSAFE = Unsafe.getUnsafe();\n+    \n+    @Test\n+    public void testEmpty() {\n+        assertEquals(CallBufferCache.acquire(), 0);\n+    }\n+\n+    @Test\n+    public void testCacheSize() {\n+        assertEquals(CallBufferCache.acquire(), 0);\n+\n+        \/\/ Three nested calls.\n+        long address1 = UNSAFE.allocateMemory(128);\n+        long address2 = UNSAFE.allocateMemory(128);\n+        long address3 = UNSAFE.allocateMemory(128);\n+\n+        \/\/ Two buffers go into the cache.\n+        assertTrue(CallBufferCache.release(address3));\n+        assertTrue(CallBufferCache.release(address2));\n+        assertFalse(CallBufferCache.release(address1));\n+\n+        \/\/ Next acquisition is either of them.\n+        long first = CallBufferCache.acquire();\n+        assertTrue(first == address3 || first == address2);\n+        assertTrue(CallBufferCache.release(first));\n+\n+        \/\/ Can re-acquire both.\n+        first = CallBufferCache.acquire();\n+        long second = CallBufferCache.acquire();\n+        assertNotEquals(first, second);\n+        assertTrue(first == address2 || first == address3);\n+        assertTrue(second == address2 || second == address3);\n+        \/\/ Now the cache is empty again.\n+        assertEquals(CallBufferCache.acquire(), 0);\n+\n+        UNSAFE.freeMemory(address1);\n+        UNSAFE.freeMemory(address2);\n+        UNSAFE.freeMemory(address3);\n+    }\n+\n+    @Test\n+    public void testThreadLocal() throws InterruptedException {\n+        long address = UNSAFE.allocateMemory(128);\n+        assertTrue(CallBufferCache.release(address));\n+        Thread.ofPlatform().start(() -> {\n+            \/\/ Not visible in other thread.\n+            assertEquals(CallBufferCache.acquire(), 0);\n+        }).join();\n+        \/\/ Only here.\n+        assertEquals(address, CallBufferCache.acquire());\n+        UNSAFE.freeMemory(address);\n+    }\n+\n+    @Test\n+    public void testMigrateThread() throws InterruptedException {\n+        long address = UNSAFE.allocateMemory(128);\n+        assertTrue(CallBufferCache.release(address));\n+        assertEquals(address, CallBufferCache.acquire());\n+        Thread.ofPlatform().start(() -> {\n+            \/\/ A buffer can migrate to another thread due to VThread scheduling.\n+            CallBufferCache.release(address);\n+            assertEquals(address, CallBufferCache.acquire());\n+            CallBufferCache.release(address);\n+            \/\/ freed by TL.\n+        }).join();\n+        assertEquals(CallBufferCache.acquire(), 0);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/CallBufferCacheTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgs = {\"-Xlog:gc\", \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\"})\n+public class CallOverheadByValue {\n+\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE, C_DOUBLE\n+    );\n+    private static final MethodHandle MH_UNIT_ROTATED_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_ROTATED_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"CallOverheadByValue\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_ROTATED_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_rotated\"),\n+                FunctionDescriptor.of(POINT_LAYOUT, C_DOUBLE)\n+        );\n+        MH_UNIT_ROTATED_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_rotated_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, C_DOUBLE)\n+        );\n+    }\n+\n+    static final int NUM_CIRCLE_POINTS = 100;\n+\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment points = arena.allocate(POINT_LAYOUT, NUM_CIRCLE_POINTS);\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n+    public MemorySegment byValue() throws Throwable {\n+        for (int i = 0; i < NUM_CIRCLE_POINTS; i++) {\n+            double phi = 2 * Math.PI * i \/ NUM_CIRCLE_POINTS;\n+            \/\/ points[i] = unit_rotated(phi);\n+            MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n+            MemorySegment unused =\n+                    (MemorySegment) MH_UNIT_ROTATED_BY_VALUE.invokeExact(\n+                            (SegmentAllocator) (_, _) -> dest,\n+                            phi);\n+        }\n+        return points;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n+    public MemorySegment byPtr() throws Throwable {\n+        for (int i = 0; i < NUM_CIRCLE_POINTS; i++) {\n+            double phi = 2 * Math.PI * i \/ NUM_CIRCLE_POINTS;\n+            \/\/ unit_rotated_ptr(&points[i], phi);\n+            MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n+            MH_UNIT_ROTATED_BY_PTR.invokeExact(dest, phi);\n+        }\n+        return points;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+#include \"math.h\"\n+\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n+EXPORT DoublePoint unit_rotated(double phi) {\n+    DoublePoint result = { cos(phi), sin(phi) };\n+    return result;\n+}\n+\n+EXPORT void unit_rotated_ptr(DoublePoint* out, double phi) {\n+  *out = unit_rotated(phi);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadByValue.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"}]}