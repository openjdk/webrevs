{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,16 @@\n+    public long currentOffset() {\n+        return sp;\n+    }\n+\n+    public void resetTo(long offset) {\n+        if (offset < 0 || offset > sp)\n+            throw new IllegalArgumentException(String.format(\"offset %d should be in [0, %d] \", offset, sp));\n+        this.sp = offset;\n+    }\n+\n+    public boolean canAllocate(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        return start + byteSize <= segment.byteSize();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.foreign.SlicingAllocator;\n+import jdk.internal.misc.CarrierThreadLocal;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class BufferStack {\n+    private final long size;\n+\n+    public BufferStack(long size) {\n+        this.size = size;\n+    }\n+\n+    private final ThreadLocal<PerThread> tl = new CarrierThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread(size);\n+        }\n+    };\n+\n+    @ForceInline\n+    public Arena pushFrame(long size, long byteAlignment) {\n+        return tl.get().pushFrame(size, byteAlignment);\n+    }\n+\n+    private static final class PerThread {\n+        private final ReentrantLock lock = new ReentrantLock();\n+        private final SlicingAllocator stack;\n+\n+        public PerThread(long size) {\n+            this.stack = new SlicingAllocator(Arena.ofAuto().allocate(size));\n+        }\n+\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                \/\/ Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        private class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long topOfStack;\n+            private final Arena scope = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                topOfStack = stack.currentOffset();\n+                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+            }\n+\n+            private void assertOrder() {\n+                if (topOfStack != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not top-of-stack\");\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return scope.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                scope.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferStack.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -385,14 +385,2 @@\n-    public static Arena newBoundedArena(long size) {\n-        return new Arena() {\n-            final Arena arena = Arena.ofConfined();\n-            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n-\n-            @Override\n-            public Scope scope() {\n-                return arena.scope();\n-            }\n-\n-            @Override\n-            public void close() {\n-                arena.close();\n-            }\n+    private static final int LINKER_STACK_SIZE = Integer.getInteger(\"jdk.internal.foreign.LINKER_STACK_SIZE\", 256);\n+    private static final BufferStack LINKER_STACK = new BufferStack(LINKER_STACK_SIZE);\n@@ -400,5 +388,3 @@\n-            @Override\n-            public MemorySegment allocate(long byteSize, long byteAlignment) {\n-                return slicingAllocator.allocate(byteSize, byteAlignment);\n-            }\n-        };\n+    @ForceInline\n+    public static Arena newBoundedArena(long size) {\n+        return LINKER_STACK.pushFrame(size, 8);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign.abi\n+ * @build NativeTestHelper TestBufferStack\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestBufferStack\n+ *\/\n+\n+import jdk.internal.foreign.abi.BufferStack;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+import static java.lang.foreign.MemoryLayout.structLayout;\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+\n+public class TestBufferStack extends NativeTestHelper {\n+    @Test\n+    public void testScopedAllocation() {\n+        int stackSize = 128;\n+        BufferStack stack = new BufferStack(stackSize);\n+        MemorySegment stackSegment;\n+        try (Arena frame1 = stack.pushFrame(3 * JAVA_INT.byteSize(), JAVA_INT.byteAlignment())) {\n+            \/\/ Segments have expected sizes and are accessible and allocated consecutively in the same scope.\n+            MemorySegment segment11 = frame1.allocate(JAVA_INT);\n+            Assert.assertEquals(segment11.scope(), frame1.scope());\n+            Assert.assertEquals(segment11.byteSize(), JAVA_INT.byteSize());\n+            segment11.set(JAVA_INT, 0, 1);\n+            stackSegment = segment11.reinterpret(stackSize);\n+\n+            MemorySegment segment12 = frame1.allocate(JAVA_INT);\n+            Assert.assertEquals(segment12.address(), segment11.address() + JAVA_INT.byteSize());\n+            Assert.assertEquals(segment12.byteSize(), JAVA_INT.byteSize());\n+            Assert.assertEquals(segment12.scope(), frame1.scope());\n+            segment12.set(JAVA_INT, 0, 1);\n+\n+            MemorySegment segment2;\n+            try (Arena frame2 = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n+                Assert.assertNotEquals(frame2.scope(), frame1.scope());\n+                \/\/ same here, but a new scope.\n+                segment2 = frame2.allocate(JAVA_LONG);\n+                Assert.assertEquals(segment2.address(), segment12.address() + \/*segment12 size + frame 1 spare + alignment constraint*\/ 3 * JAVA_INT.byteSize());\n+                Assert.assertEquals(segment2.byteSize(), JAVA_LONG.byteSize());\n+                Assert.assertEquals(segment2.scope(), frame2.scope());\n+                segment2.set(JAVA_LONG, 0, 1);\n+\n+                \/\/ Frames must be closed in stack order.\n+                Assert.assertThrows(IllegalStateException.class, frame1::close);\n+            }\n+            \/\/ Scope is closed here, inner segments throw.\n+            Assert.assertThrows(IllegalStateException.class, () -> segment2.get(JAVA_INT, 0));\n+            \/\/ A new stack frame allocates at the same location (but different scope) as the previous did.\n+            try (Arena frame3 = stack.pushFrame(2 * JAVA_INT.byteSize(), JAVA_INT.byteAlignment())) {\n+                MemorySegment segment3 = frame3.allocate(JAVA_INT);\n+                Assert.assertEquals(segment3.scope(), frame3.scope());\n+                Assert.assertEquals(segment3.address(), segment12.address() + 2 * JAVA_INT.byteSize());\n+            }\n+\n+            \/\/ Fallback arena behaves like regular stack frame.\n+            MemorySegment outOfStack;\n+            try (Arena hugeFrame = stack.pushFrame(1024, 4)) {\n+                outOfStack = hugeFrame.allocate(4);\n+                Assert.assertEquals(outOfStack.scope(), hugeFrame.scope());\n+                Assert.assertTrue(outOfStack.asOverlappingSlice(stackSegment).isEmpty());\n+            }\n+            Assert.assertThrows(IllegalStateException.class, () -> outOfStack.get(JAVA_INT, 0));\n+\n+            \/\/ Outer segments are still accessible.\n+            segment11.get(JAVA_INT, 0);\n+            segment12.get(JAVA_INT, 0);\n+        }\n+    }\n+\n+    @Test\n+    public void stress() throws InterruptedException {\n+        BufferStack stack = new BufferStack(256);\n+        Thread[] vThreads = IntStream.range(0, 1024).mapToObj(_ ->\n+                Thread.ofVirtual().start(() -> {\n+                    long threadId = Thread.currentThread().threadId();\n+                    while (true) {\n+                        try (Arena arena = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n+                            \/\/ Try to assert no two vThreads get allocated the same stack space.\n+                            MemorySegment segment = arena.allocate(JAVA_LONG);\n+                            JAVA_LONG.varHandle().setVolatile(segment, 0L, threadId);\n+                            Assert.assertEquals(threadId, (long) JAVA_LONG.varHandle().getVolatile(segment, 0L));\n+                        }\n+                    }\n+                })).toArray(Thread[]::new);\n+        Thread.sleep(Duration.of(10, SECONDS));\n+        Arrays.stream(vThreads).forEach(\n+                thread -> Assert.assertTrue(thread.isAlive()));\n+    }\n+\n+    static {\n+        System.loadLibrary(\"TestBufferStack\");\n+    }\n+\n+    private static final MemoryLayout HVAPoint3D = structLayout(NativeTestHelper.C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+    private static final MemorySegment UPCALL_MH = upcallStub(TestBufferStack.class, \"recurse\", FunctionDescriptor.of(HVAPoint3D, C_INT));\n+    private static final MethodHandle DOWNCALL_MH = downcallHandle(\"recurse\", FunctionDescriptor.of(HVAPoint3D, C_INT, ADDRESS));\n+\n+    public static MemorySegment recurse(int depth) {\n+        try {\n+            return (MemorySegment) DOWNCALL_MH.invokeExact((SegmentAllocator) Arena.ofAuto(), depth, UPCALL_MH);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void testDeepStack() throws Throwable {\n+        \/\/ Each downcall and upcall require 48 bytes of stack.\n+        \/\/ After five allocations we start falling back.\n+        MemorySegment point = recurse(10);\n+        Assert.assertEquals(point.getAtIndex(C_DOUBLE, 0), 12.0);\n+        Assert.assertEquals(point.getAtIndex(C_DOUBLE, 1), 11.0);\n+        Assert.assertEquals(point.getAtIndex(C_DOUBLE, 2), 10.0);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct { double x, y, z; } HVAPoint3D;\n+\n+EXPORT HVAPoint3D recurse(int depth, HVAPoint3D (*cb)(int)) {\n+  if (depth == 0) {\n+    HVAPoint3D result = { 2, 1, 0};\n+    return result;\n+  }\n+\n+  HVAPoint3D result = cb(depth - 1);\n+  result.x += 1;\n+  result.y += 1;\n+  result.z += 1;\n+  return result;\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestBufferStack.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class CallOverheadByValue {\n+\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE, C_DOUBLE\n+    );\n+    private static final MethodHandle MH_UNIT_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"CallOverheadByValue\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit\"),\n+                FunctionDescriptor.of(POINT_LAYOUT)\n+        );\n+        MH_UNIT_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)\n+        );\n+    }\n+\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment point = arena.allocate(POINT_LAYOUT);\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void byValue() throws Throwable {\n+        \/\/ point = unit();\n+        MemorySegment unused = (MemorySegment) MH_UNIT_BY_VALUE.invokeExact(\n+                (SegmentAllocator) (_, _) -> point);\n+    }\n+\n+    @Benchmark\n+    public void byPtr() throws Throwable {\n+        \/\/ unit_ptr(&point);\n+        MH_UNIT_BY_PTR.invokeExact(point);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n+EXPORT DoublePoint unit() {\n+    DoublePoint result = { 1, 0 };\n+    return result;\n+}\n+\n+EXPORT void unit_ptr(DoublePoint* out) {\n+  *out = unit();\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadByValue.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}