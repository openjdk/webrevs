{"files":[{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.Continuation;\n+\n+\/**\n+ * Provides thread-local storage for up to two buffer addresses.\n+ * It is caller's responsibility to store homogeneous segment sizes.\n+ * Storing addresses, not MemorySegments turns out to be slightly faster (write barrier?).\n+ *\/\n+public final class CallBufferCache {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    static class PerThread {\n+        \/\/ Two-elements to support downcall + upcall.\n+        private long address1;\n+        private long address2;\n+\n+        long pop() {\n+            if (address1 != 0) {\n+                long result = address1;\n+                address1 = 0;\n+                return result;\n+            }\n+            if (address2 != 0) {\n+                long result = address2;\n+                address2 = 0;\n+                return result;\n+            }\n+            return 0;\n+        }\n+\n+        boolean push(long address) {\n+            if (address1 == 0) {\n+                address1 = address;\n+                return true;\n+            }\n+            if (address2 == 0) {\n+                address2 = address;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        void free() {\n+            if (address1 != 0) CallBufferCache.free(address1);\n+            if (address2 != 0) CallBufferCache.free(address2);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    public static long allocate(long size) {\n+        return UNSAFE.allocateMemory(size);\n+    }\n+\n+    public static void free(long address) {\n+        UNSAFE.freeMemory(address);\n+    }\n+\n+    private static final TerminatingThreadLocal<PerThread> tl = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread();\n+        }\n+\n+        @Override\n+        protected void threadTerminated(PerThread cache) {\n+            cache.free();\n+        }\n+    };\n+\n+    public static long acquire() {\n+        Continuation.pin();\n+        try {\n+            return tl.get().pop();\n+        } finally {\n+            Continuation.unpin();\n+        }\n+    }\n+\n+    public static boolean release(long address) {\n+        Continuation.pin();\n+        try {\n+            return tl.get().push(address);\n+        } finally {\n+            Continuation.unpin();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallBufferCache.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -140,1 +140,1 @@\n-     *\n+     * <p>\n@@ -145,1 +145,1 @@\n-     * @param cDesc the function descriptor of the native function (with actual return layout)\n+     * @param cDesc  the function descriptor of the native function (with actual return layout)\n@@ -261,2 +261,2 @@\n-                        .boxed()\n-                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n+                .boxed()\n+                .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n@@ -293,1 +293,1 @@\n-        for (int i = 0 ; i < perms.length ; i++) {\n+        for (int i = 0; i < perms.length; i++) {\n@@ -385,0 +385,5 @@\n+    \/\/ Minimum allocation size = maximum cached size\n+    private static final int CACHED_BUFFER_SIZE = 256;\n+\n+    @ForceInline\n+    @SuppressWarnings(\"restricted\")\n@@ -386,3 +391,5 @@\n-        return new Arena() {\n-            final Arena arena = Arena.ofConfined();\n-            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+        long bufferSize = Math.max(size, CACHED_BUFFER_SIZE);\n+        long fromCache = bufferSize == CACHED_BUFFER_SIZE ? CallBufferCache.acquire() : 0;\n+        long address = fromCache != 0 ? fromCache : CallBufferCache.allocate(bufferSize);\n+        return new BoundedArena(MemorySegment.ofAddress(address).reinterpret(size));\n+    }\n@@ -390,4 +397,12 @@\n-            @Override\n-            public Scope scope() {\n-                return arena.scope();\n-            }\n+    \/** A confined arena slicing off an (unscoped) source segment. *\/\n+    static final class BoundedArena implements Arena {\n+        private final Arena scope = Arena.ofConfined();\n+        private final MemorySegment scoped;\n+        private final SegmentAllocator allocator;\n+\n+        @ForceInline\n+        @SuppressWarnings(\"restricted\")\n+        public BoundedArena(MemorySegment source) {\n+            scoped = source.reinterpret(scope, null);\n+            allocator = SegmentAllocator.slicingAllocator(scoped);\n+        }\n@@ -395,4 +410,5 @@\n-            @Override\n-            public void close() {\n-                arena.close();\n-            }\n+        @Override\n+        @ForceInline\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n+        }\n@@ -400,5 +416,13 @@\n-            @Override\n-            public MemorySegment allocate(long byteSize, long byteAlignment) {\n-                return slicingAllocator.allocate(byteSize, byteAlignment);\n-            }\n-        };\n+        @Override\n+        public Scope scope() {\n+            return scope.scope();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void close() {\n+            scope.close();\n+            \/\/ All segments we handed out are now invalid, we can release source to the cache or free it.\n+            if (scoped.byteSize() > CACHED_BUFFER_SIZE || !CallBufferCache.release(scoped.address()))\n+                CallBufferCache.free(scoped.address());\n+        }\n@@ -445,2 +469,2 @@\n-            boolean b = (boolean)o;\n-            ptr.set(JAVA_LONG_UNALIGNED, 0, b ? (long)1 : (long)0);\n+            boolean b = (boolean) o;\n+            ptr.set(JAVA_LONG_UNALIGNED, 0, b ? (long) 1 : (long) 0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":47,"deletions":23,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign.abi\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED CallBufferCacheTest\n+ *\/\n+\n+import jdk.internal.foreign.abi.CallBufferCache;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class CallBufferCacheTest {\n+\n+    @Test\n+    public void testEmpty() {\n+        assertEquals(CallBufferCache.acquire(), 0);\n+    }\n+\n+    @Test\n+    public void testAllocate() {\n+        long address1 = CallBufferCache.allocate(123);\n+        long address2 = CallBufferCache.allocate(123);\n+        assertNotEquals(address1, address2);\n+        CallBufferCache.free(address1);\n+        CallBufferCache.free(address2);\n+    }\n+\n+    @Test\n+    public void testCacheSize() {\n+        assertEquals(CallBufferCache.acquire(), 0);\n+\n+        \/\/ Three nested calls.\n+        long address1 = CallBufferCache.allocate(128);\n+        long address2 = CallBufferCache.allocate(128);\n+        long address3 = CallBufferCache.allocate(128);\n+\n+        \/\/ Two buffers go into the cache.\n+        assertTrue(CallBufferCache.release(address3));\n+        assertTrue(CallBufferCache.release(address2));\n+        assertFalse(CallBufferCache.release(address1));\n+\n+        \/\/ Next acquisition is either of them.\n+        long first = CallBufferCache.acquire();\n+        assertTrue(first == address3 || first == address2);\n+        assertTrue(CallBufferCache.release(first));\n+\n+        \/\/ Can re-acquire both.\n+        first = CallBufferCache.acquire();\n+        long second = CallBufferCache.acquire();\n+        assertNotEquals(first, second);\n+        assertTrue(first == address2 || first == address3);\n+        assertTrue(second == address2 || second == address3);\n+        \/\/ Now the cache is empty again.\n+        assertEquals(CallBufferCache.acquire(), 0);\n+\n+        CallBufferCache.free(address1);\n+        CallBufferCache.free(address2);\n+        CallBufferCache.free(address3);\n+    }\n+\n+    @Test\n+    public void testThreadLocal() throws InterruptedException {\n+        long address = CallBufferCache.allocate(128);\n+        assertTrue(CallBufferCache.release(address));\n+        Thread.ofPlatform().start(() -> {\n+            \/\/ Not visible in other thread.\n+            assertEquals(CallBufferCache.acquire(), 0);\n+        }).join();\n+        \/\/ Only here.\n+        assertEquals(address, CallBufferCache.acquire());\n+        CallBufferCache.free(address);\n+    }\n+\n+    @Test\n+    public void testMigrateThread() throws InterruptedException {\n+        long address = CallBufferCache.allocate(128);\n+        assertTrue(CallBufferCache.release(address));\n+        assertEquals(address, CallBufferCache.acquire());\n+        Thread.ofPlatform().start(() -> {\n+            \/\/ A buffer can migrate to another thread due to VThread scheduling.\n+            CallBufferCache.release(address);\n+            assertEquals(address, CallBufferCache.acquire());\n+            CallBufferCache.release(address);\n+            \/\/ freed by TL.\n+        }).join();\n+        assertEquals(CallBufferCache.acquire(), 0);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/CallBufferCacheTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n@@ -34,0 +35,1 @@\n+import org.openjdk.bench.java.lang.foreign.points.support.Circle;\n@@ -37,0 +39,1 @@\n+import java.lang.foreign.Arena;\n@@ -62,0 +65,17 @@\n+    static final int NUM_CIRCLE_POINTS = 100;\n+\n+    @Benchmark\n+    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n+    public Object circle_by_value() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            return Circle.byValue(arena, NUM_CIRCLE_POINTS);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n+    public Object circle_by_ptr() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            return Circle.byPtr(arena, NUM_CIRCLE_POINTS);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsAlloc.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign.points.support;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+public class Circle {\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE.withName(\"x\"),\n+            C_DOUBLE.withName(\"y\")\n+    );\n+    private static final MethodHandle MH_UNIT_ROTATED_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_ROTATED_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"Point\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_ROTATED_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_rotated\"),\n+                FunctionDescriptor.of(POINT_LAYOUT, C_DOUBLE)\n+        );\n+        MH_UNIT_ROTATED_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_rotated_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, C_DOUBLE)\n+        );\n+    }\n+\n+    private final MemorySegment points;\n+\n+    private Circle(MemorySegment points) {\n+        this.points = points;\n+    }\n+\n+    public static Circle byValue(SegmentAllocator allocator, int numPoints) {\n+        try {\n+            MemorySegment points = allocator.allocate(POINT_LAYOUT, numPoints);\n+            for (int i = 0; i < numPoints; i++) {\n+                double phi = 2 * Math.PI * i \/ numPoints;\n+                \/\/ points[i] = unit_rotated(phi);\n+                MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n+                MemorySegment unused =\n+                        (MemorySegment) MH_UNIT_ROTATED_BY_VALUE.invokeExact(\n+                                (SegmentAllocator) (_, _) -> dest,\n+                                phi);\n+            }\n+            return new Circle(points);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static Circle byPtr(SegmentAllocator allocator, int numPoints) {\n+        try {\n+            MemorySegment points = allocator.allocate(POINT_LAYOUT, numPoints);\n+            for (int i = 0; i < numPoints; i++) {\n+                double phi = 2 * Math.PI * i \/ numPoints;\n+                \/\/ unit_rotated_ptr(&points[i], phi);\n+                MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n+                MH_UNIT_ROTATED_BY_PTR.invokeExact(dest, phi);\n+            }\n+            return new Circle(points);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/Circle.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,9 @@\n+\n+EXPORT DoublePoint unit_rotated(double phi) {\n+    DoublePoint result = { cos(phi), sin(phi) };\n+    return result;\n+}\n+\n+EXPORT void unit_rotated_ptr(DoublePoint* out, double phi) {\n+  *out = unit_rotated(phi);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/libPoint.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,5 @@\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/points.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}