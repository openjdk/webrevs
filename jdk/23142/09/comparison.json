{"files":[{"patch":"@@ -41,0 +41,16 @@\n+    public long currentOffset() {\n+        return sp;\n+    }\n+\n+    public void resetTo(long offset) {\n+        if (offset < 0 || offset > sp)\n+            throw new IllegalArgumentException(String.format(\"offset %d should be in [0, %d] \", offset, sp));\n+        this.sp = offset;\n+    }\n+\n+    public boolean canAllocate(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        return start + byteSize <= segment.byteSize();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.foreign.SlicingAllocator;\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class BufferStack {\n+    private final long size;\n+\n+    public BufferStack(long size) {\n+        this.size = size;\n+    }\n+\n+    private final TerminatingThreadLocal<PerThread> tl = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected PerThread initialValue() {\n+            return new PerThread(size);\n+        }\n+\n+        @Override\n+        protected void threadTerminated(PerThread value) {\n+            value.close();\n+        }\n+    };\n+\n+    @ForceInline\n+    public Arena pushFrame(long size, long byteAlignment) {\n+        return tl.get().pushFrame(size, byteAlignment);\n+    }\n+\n+    private static final class PerThread {\n+        private final ReentrantLock lock = new ReentrantLock();\n+        private final Arena owner = Arena.ofConfined();\n+        private final SlicingAllocator stack;\n+\n+        public PerThread(long size) {\n+            this.stack = new SlicingAllocator(owner.allocate(size));\n+        }\n+\n+        void close() {\n+            owner.close();\n+        }\n+\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                \/\/ Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        private class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long tos;\n+            private final Arena scope = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                tos = stack.currentOffset();\n+                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+            }\n+\n+            private void assertOrder() {\n+                if (tos != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not TOS\");\n+            }\n+\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                assertOrder();\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return scope.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                scope.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferStack.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.misc.CarrierThreadLocal;\n@@ -385,14 +386,1 @@\n-    public static Arena newBoundedArena(long size) {\n-        return new Arena() {\n-            final Arena arena = Arena.ofConfined();\n-            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n-\n-            @Override\n-            public Scope scope() {\n-                return arena.scope();\n-            }\n-\n-            @Override\n-            public void close() {\n-                arena.close();\n-            }\n+    private static final BufferStack LINKER_STACK = new BufferStack(256);\n@@ -400,5 +388,3 @@\n-            @Override\n-            public MemorySegment allocate(long byteSize, long byteAlignment) {\n-                return slicingAllocator.allocate(byteSize, byteAlignment);\n-            }\n-        };\n+    @ForceInline\n+    public static Arena newBoundedArena(long size) {\n+        return LINKER_STACK.pushFrame(size, 8);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class CallOverheadByValue {\n+\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE, C_DOUBLE\n+    );\n+    private static final MethodHandle MH_UNIT_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"CallOverheadByValue\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit\"),\n+                FunctionDescriptor.of(POINT_LAYOUT)\n+        );\n+        MH_UNIT_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)\n+        );\n+    }\n+\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment point = arena.allocate(POINT_LAYOUT);\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void byValue() throws Throwable {\n+        \/\/ point = unit();\n+        MemorySegment unused = (MemorySegment) MH_UNIT_BY_VALUE.invokeExact(\n+                (SegmentAllocator) (_, _) -> point);\n+    }\n+\n+    @Benchmark\n+    public void byPtr() throws Throwable {\n+        \/\/ unit_ptr(&point);\n+        MH_UNIT_BY_PTR.invokeExact(point);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n+EXPORT DoublePoint unit() {\n+    DoublePoint result = { 1, 0 };\n+    return result;\n+}\n+\n+EXPORT void unit_ptr(DoublePoint* out) {\n+  *out = unit();\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadByValue.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}