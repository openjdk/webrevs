{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.foreign.MemorySegment;\n+\n@@ -30,3 +32,1 @@\n- * Provides carrier-thread-local storage for up to two buffer addresses.\n- * It is caller's responsibility to store homogeneous segment sizes.\n- * Storing addresses, not MemorySegments turns out to be slightly faster (write barrier?).\n+ * Provides carrier-thread-local storage for up to two small buffers.\n@@ -39,0 +39,1 @@\n+        \/\/ Storing addresses, not MemorySegments turns out to be slightly faster (write barrier?).\n@@ -95,0 +96,2 @@\n+    \/\/ visible only for tests\n+\n@@ -114,0 +117,20 @@\n+\n+    private static final long CACHED_BUFFER_SIZE = 256;\n+\n+    @SuppressWarnings(\"restricted\")\n+    public static MemorySegment acquireOrAllocate(long requestedSize) {\n+        final long bufferSize = Math.max(requestedSize, CACHED_BUFFER_SIZE);\n+        long address = (bufferSize == CACHED_BUFFER_SIZE) ? acquire() : 0;\n+        if (address == 0) {\n+            \/\/ Either size was too large or cache empty.\n+            address = allocate(bufferSize);\n+        }\n+        return MemorySegment.ofAddress(address).reinterpret(requestedSize);\n+    }\n+\n+    public static void releaseOrFree(MemorySegment segment) {\n+        if (segment.byteSize() > CACHED_BUFFER_SIZE || !release(segment.address())) {\n+            \/\/ Either size was too large or cache full.\n+            free(segment.address());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallBufferCache.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import java.util.function.Consumer;\n@@ -140,1 +141,1 @@\n-     * <p>\n+     *\n@@ -145,1 +146,1 @@\n-     * @param cDesc  the function descriptor of the native function (with actual return layout)\n+     * @param cDesc the function descriptor of the native function (with actual return layout)\n@@ -261,2 +262,2 @@\n-                .boxed()\n-                .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n+                        .boxed()\n+                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n@@ -293,1 +294,1 @@\n-        for (int i = 0; i < perms.length; i++) {\n+        for (int i = 0 ; i < perms.length ; i++) {\n@@ -385,3 +386,0 @@\n-    \/\/ Minimum allocation size = maximum cached size\n-    private static final int CACHED_BUFFER_SIZE = 256;\n-\n@@ -391,5 +389,8 @@\n-        \/\/ JDK-8347997: buffer cache pinned section needs to happen outside of constructor.\n-        long bufferSize = Math.max(size, CACHED_BUFFER_SIZE);\n-        long fromCache = bufferSize == CACHED_BUFFER_SIZE ? CallBufferCache.acquire() : 0;\n-        long address = fromCache != 0 ? fromCache : CallBufferCache.allocate(bufferSize);\n-        return new BoundedArena(MemorySegment.ofAddress(address).reinterpret(size));\n+        \/\/ JDK-8347997: buffer cache pinned section needs to happen outside of constructor and before\n+        \/\/ confined session, otherwise scalar replacement breaks.\n+        MemorySegment unscoped = CallBufferCache.acquireOrAllocate(size);\n+        Arena scope = Arena.ofConfined();\n+        MemorySegment source = unscoped.reinterpret(scope, null);\n+        \/\/ Preferable we'd like to register this cleanup in the line above\n+        \/\/ but it breaks scalar replacement.\n+        return new BoundedArena(scope, source, CallBufferCache::releaseOrFree);\n@@ -400,2 +401,2 @@\n-        private final Arena scope = Arena.ofConfined();\n-        private final MemorySegment scoped;\n+        private final Arena scope;\n+        private final MemorySegment source;\n@@ -403,0 +404,1 @@\n+        private final Consumer<MemorySegment> cleanup;\n@@ -405,4 +407,5 @@\n-        @SuppressWarnings(\"restricted\")\n-        public BoundedArena(MemorySegment source) {\n-            scoped = source.reinterpret(scope, null);\n-            allocator = SegmentAllocator.slicingAllocator(scoped);\n+        public BoundedArena(Arena scope, MemorySegment source, Consumer<MemorySegment> cleanup) {\n+            this.scope = scope;\n+            this.source = source;\n+            this.allocator = SegmentAllocator.slicingAllocator(source);\n+            this.cleanup = cleanup;\n@@ -426,4 +429,1 @@\n-            \/\/ All segments we handed out are now invalid, we can release source to the cache or free it.\n-            \/\/ Due to VThread scheduling we may be returning ownership to a different platform thread.\n-            if (scoped.byteSize() > CACHED_BUFFER_SIZE || !CallBufferCache.release(scoped.address()))\n-                CallBufferCache.free(scoped.address());\n+            cleanup.accept(source);\n@@ -471,2 +471,2 @@\n-            boolean b = (boolean) o;\n-            ptr.set(JAVA_LONG_UNALIGNED, 0, b ? (long) 1 : (long) 0);\n+            boolean b = (boolean)o;\n+            ptr.set(JAVA_LONG_UNALIGNED, 0, b ? (long)1 : (long)0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgs = {\"-Xlog:gc\", \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\"})\n+public class CallOverheadByValue {\n+\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE, C_DOUBLE\n+    );\n+    private static final MethodHandle MH_UNIT_ROTATED_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_ROTATED_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"CallOverheadByValue\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_ROTATED_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_rotated\"),\n+                FunctionDescriptor.of(POINT_LAYOUT, C_DOUBLE)\n+        );\n+        MH_UNIT_ROTATED_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_rotated_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, C_DOUBLE)\n+        );\n+    }\n+\n+    static final int NUM_CIRCLE_POINTS = 100;\n+\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment points = arena.allocate(POINT_LAYOUT, NUM_CIRCLE_POINTS);\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n+    public MemorySegment byValue() throws Throwable {\n+        for (int i = 0; i < NUM_CIRCLE_POINTS; i++) {\n+            double phi = 2 * Math.PI * i \/ NUM_CIRCLE_POINTS;\n+            \/\/ points[i] = unit_rotated(phi);\n+            MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n+            MemorySegment unused =\n+                    (MemorySegment) MH_UNIT_ROTATED_BY_VALUE.invokeExact(\n+                            (SegmentAllocator) (_, _) -> dest,\n+                            phi);\n+        }\n+        return points;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n+    public MemorySegment byPtr() throws Throwable {\n+        for (int i = 0; i < NUM_CIRCLE_POINTS; i++) {\n+            double phi = 2 * Math.PI * i \/ NUM_CIRCLE_POINTS;\n+            \/\/ unit_rotated_ptr(&points[i], phi);\n+            MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n+            MH_UNIT_ROTATED_BY_PTR.invokeExact(dest, phi);\n+        }\n+        return points;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+#include \"math.h\"\n+\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n+EXPORT DoublePoint unit_rotated(double phi) {\n+    DoublePoint result = { cos(phi), sin(phi) };\n+    return result;\n+}\n+\n+EXPORT void unit_rotated_ptr(DoublePoint* out, double phi) {\n+  *out = unit_rotated(phi);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadByValue.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n@@ -35,1 +34,0 @@\n-import org.openjdk.bench.java.lang.foreign.points.support.Circle;\n@@ -39,1 +37,0 @@\n-import java.lang.foreign.Arena;\n@@ -65,17 +62,0 @@\n-    static final int NUM_CIRCLE_POINTS = 100;\n-\n-    @Benchmark\n-    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n-    public Object circle_by_value() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            return Circle.byValue(arena, NUM_CIRCLE_POINTS);\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(NUM_CIRCLE_POINTS)\n-    public Object circle_by_ptr() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            return Circle.byPtr(arena, NUM_CIRCLE_POINTS);\n-        }\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsAlloc.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.foreign.points.support;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-\n-import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n-\n-public class Circle {\n-    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n-            C_DOUBLE.withName(\"x\"),\n-            C_DOUBLE.withName(\"y\")\n-    );\n-    private static final MethodHandle MH_UNIT_ROTATED_BY_VALUE;\n-    private static final MethodHandle MH_UNIT_ROTATED_BY_PTR;\n-\n-    static {\n-        Linker abi = Linker.nativeLinker();\n-        System.loadLibrary(\"Point\");\n-        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n-        MH_UNIT_ROTATED_BY_VALUE = abi.downcallHandle(\n-                loaderLibs.findOrThrow(\"unit_rotated\"),\n-                FunctionDescriptor.of(POINT_LAYOUT, C_DOUBLE)\n-        );\n-        MH_UNIT_ROTATED_BY_PTR = abi.downcallHandle(\n-                loaderLibs.findOrThrow(\"unit_rotated_ptr\"),\n-                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, C_DOUBLE)\n-        );\n-    }\n-\n-    private final MemorySegment points;\n-\n-    private Circle(MemorySegment points) {\n-        this.points = points;\n-    }\n-\n-    public static Circle byValue(SegmentAllocator allocator, int numPoints) {\n-        try {\n-            MemorySegment points = allocator.allocate(POINT_LAYOUT, numPoints);\n-            for (int i = 0; i < numPoints; i++) {\n-                double phi = 2 * Math.PI * i \/ numPoints;\n-                \/\/ points[i] = unit_rotated(phi);\n-                MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n-                MemorySegment unused =\n-                        (MemorySegment) MH_UNIT_ROTATED_BY_VALUE.invokeExact(\n-                                (SegmentAllocator) (_, _) -> dest,\n-                                phi);\n-            }\n-            return new Circle(points);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static Circle byPtr(SegmentAllocator allocator, int numPoints) {\n-        try {\n-            MemorySegment points = allocator.allocate(POINT_LAYOUT, numPoints);\n-            for (int i = 0; i < numPoints; i++) {\n-                double phi = 2 * Math.PI * i \/ numPoints;\n-                \/\/ unit_rotated_ptr(&points[i], phi);\n-                MemorySegment dest = points.asSlice(i * POINT_LAYOUT.byteSize(), POINT_LAYOUT.byteSize());\n-                MH_UNIT_ROTATED_BY_PTR.invokeExact(dest, phi);\n-            }\n-            return new Circle(points);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/Circle.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,9 +39,0 @@\n-\n-EXPORT DoublePoint unit_rotated(double phi) {\n-    DoublePoint result = { cos(phi), sin(phi) };\n-    return result;\n-}\n-\n-EXPORT void unit_rotated_ptr(DoublePoint* out, double phi) {\n-  *out = unit_rotated(phi);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/libPoint.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,5 +31,0 @@\n-typedef struct {\n-    double x;\n-    double y;\n-} DoublePoint;\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/points.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}