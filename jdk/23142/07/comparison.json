{"files":[{"patch":"@@ -0,0 +1,55 @@\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class BufferStack {\n+    private final MemorySegment backingSegment;\n+    private final ReentrantLock lock = new ReentrantLock();\n+    private long offset = 0;\n+\n+    public BufferStack(MemorySegment backingSegment) {\n+        this.backingSegment = backingSegment;\n+    }\n+\n+    public Arena reserve(long size) {\n+        if (!lock.tryLock()) {\n+            \/\/ Rare: another virtual thread on the same carrier was preparing or just\n+            \/\/ finished an FFM call, but got unscheduled while holding this stack.\n+            return Arena.ofConfined();\n+        }\n+        if (offset + size > backingSegment.byteSize()) {\n+            \/\/ Rare: we've running out of stack space due to recursion or unusually large buffers.\n+            lock.unlock();\n+            return Arena.ofConfined();\n+        }\n+\n+        return new Frame();\n+    }\n+\n+    private class Frame implements Arena {\n+        final long parentOffset = offset;\n+        final Arena scope = Arena.ofConfined();\n+\n+        @Override\n+        @SuppressWarnings(\"restricted\")\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment slice = backingSegment.asSlice(offset, byteSize, byteAlignment);\n+            offset += byteSize;\n+            return slice.reinterpret(scope, null);\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return scope.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            scope.close();\n+            offset = parentOffset;\n+            lock.unlock();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferStack.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.misc.CarrierThreadLocal;\n@@ -385,14 +386,6 @@\n-    public static Arena newBoundedArena(long size) {\n-        return new Arena() {\n-            final Arena arena = Arena.ofConfined();\n-            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n-\n-            @Override\n-            public Scope scope() {\n-                return arena.scope();\n-            }\n-\n-            @Override\n-            public void close() {\n-                arena.close();\n-            }\n+    private static final CarrierThreadLocal<BufferStack> BUFFER_STACK = new CarrierThreadLocal<>() {\n+        @Override\n+        protected BufferStack initialValue() {\n+            return new BufferStack(Arena.ofAuto().allocate(256));\n+        }\n+    };\n@@ -400,5 +393,4 @@\n-            @Override\n-            public MemorySegment allocate(long byteSize, long byteAlignment) {\n-                return slicingAllocator.allocate(byteSize, byteAlignment);\n-            }\n-        };\n+    @ForceInline\n+    @SuppressWarnings(\"restricted\")\n+    public static Arena newBoundedArena(long size) {\n+        return BUFFER_STACK.get().reserve(size);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class CallOverheadByValue {\n+\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE, C_DOUBLE\n+    );\n+    private static final MethodHandle MH_UNIT_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"CallOverheadByValue\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit\"),\n+                FunctionDescriptor.of(POINT_LAYOUT)\n+        );\n+        MH_UNIT_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)\n+        );\n+    }\n+\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment point = arena.allocate(POINT_LAYOUT);\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void byValue() throws Throwable {\n+        \/\/ point = unit();\n+        MemorySegment unused = (MemorySegment) MH_UNIT_BY_VALUE.invokeExact(\n+                (SegmentAllocator) (_, _) -> point);\n+    }\n+\n+    @Benchmark\n+    public void byPtr() throws Throwable {\n+        \/\/ unit_ptr(&point);\n+        MH_UNIT_BY_PTR.invokeExact(point);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n+EXPORT DoublePoint unit() {\n+    DoublePoint result = { 1, 0 };\n+    return result;\n+}\n+\n+EXPORT void unit_ptr(DoublePoint* out) {\n+  *out = unit();\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadByValue.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}