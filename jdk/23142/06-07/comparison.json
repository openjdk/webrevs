{"files":[{"patch":"@@ -0,0 +1,55 @@\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+public class BufferStack {\n+    private final MemorySegment backingSegment;\n+    private final ReentrantLock lock = new ReentrantLock();\n+    private long offset = 0;\n+\n+    public BufferStack(MemorySegment backingSegment) {\n+        this.backingSegment = backingSegment;\n+    }\n+\n+    public Arena reserve(long size) {\n+        if (!lock.tryLock()) {\n+            \/\/ Rare: another virtual thread on the same carrier was preparing or just\n+            \/\/ finished an FFM call, but got unscheduled while holding this stack.\n+            return Arena.ofConfined();\n+        }\n+        if (offset + size > backingSegment.byteSize()) {\n+            \/\/ Rare: we've running out of stack space due to recursion or unusually large buffers.\n+            lock.unlock();\n+            return Arena.ofConfined();\n+        }\n+\n+        return new Frame();\n+    }\n+\n+    private class Frame implements Arena {\n+        final long parentOffset = offset;\n+        final Arena scope = Arena.ofConfined();\n+\n+        @Override\n+        @SuppressWarnings(\"restricted\")\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment slice = backingSegment.asSlice(offset, byteSize, byteAlignment);\n+            offset += byteSize;\n+            return slice.reinterpret(scope, null);\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return scope.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            scope.close();\n+            offset = parentOffset;\n+            lock.unlock();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferStack.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi;\n-\n-import jdk.internal.misc.TerminatingThreadLocal;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.Continuation;\n-\n-import java.lang.foreign.MemorySegment;\n-\n-\/**\n- * Provides carrier-thread-local storage for up to two small buffers.\n- *\/\n-public final class CallBufferCache {\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    static class PerThread {\n-        \/\/ Two-elements to support downcall + upcall.\n-        \/\/ Storing addresses, not MemorySegments turns out to be slightly faster (write barrier?).\n-        private long address1;\n-        private long address2;\n-\n-        long pop() {\n-            if (address1 != 0) {\n-                long result = address1;\n-                address1 = 0;\n-                return result;\n-            }\n-            if (address2 != 0) {\n-                long result = address2;\n-                address2 = 0;\n-                return result;\n-            }\n-            return 0;\n-        }\n-\n-        boolean push(long address) {\n-            if (address1 == 0) {\n-                address1 = address;\n-                return true;\n-            }\n-            if (address2 == 0) {\n-                address2 = address;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        void free() {\n-            if (address1 != 0) UNSAFE.freeMemory(address1);\n-            if (address2 != 0) UNSAFE.freeMemory(address2);\n-        }\n-    }\n-\n-    private static final TerminatingThreadLocal<PerThread> tl = new TerminatingThreadLocal<>() {\n-        @Override\n-        protected PerThread initialValue() {\n-            return new PerThread();\n-        }\n-\n-        @Override\n-        protected void threadTerminated(PerThread cache) {\n-            cache.free();\n-        }\n-    };\n-\n-    \/\/ acquire\/release visible only for tests\n-\n-    public static long acquire() {\n-        \/\/ Protect against vthread unmount.\n-        Continuation.pin();\n-        try {\n-            return tl.get().pop();\n-        } finally {\n-            Continuation.unpin();\n-        }\n-    }\n-\n-    public static boolean release(long address) {\n-        \/\/ Protect against vthread unmount.\n-        Continuation.pin();\n-        try {\n-            return tl.get().push(address);\n-        } finally {\n-            Continuation.unpin();\n-        }\n-    }\n-\n-    private static final long CACHED_BUFFER_SIZE = 256;\n-\n-    @SuppressWarnings(\"restricted\")\n-    public static MemorySegment acquireOrAllocate(long requestedSize) {\n-        final long bufferSize = Math.max(requestedSize, CACHED_BUFFER_SIZE);\n-        long address = (bufferSize == CACHED_BUFFER_SIZE) ? acquire() : 0;\n-        if (address == 0) {\n-            \/\/ Either size was too large or cache empty.\n-            address = UNSAFE.allocateMemory(bufferSize);\n-        }\n-        return MemorySegment.ofAddress(address).reinterpret(requestedSize);\n-    }\n-\n-    public static void releaseOrFree(MemorySegment segment) {\n-        if (segment.byteSize() > CACHED_BUFFER_SIZE || !release(segment.address())) {\n-            \/\/ Either size was too large or cache full.\n-            UNSAFE.freeMemory(segment.address());\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallBufferCache.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.misc.CarrierThreadLocal;\n@@ -63,1 +64,0 @@\n-import java.util.function.Consumer;\n@@ -386,28 +386,1 @@\n-    @ForceInline\n-    @SuppressWarnings(\"restricted\")\n-    public static Arena newBoundedArena(long size) {\n-        \/\/ JDK-8347997: buffer cache pinned section needs to happen outside of constructor and before\n-        \/\/ confined session, otherwise scalar replacement breaks.\n-        MemorySegment unscoped = CallBufferCache.acquireOrAllocate(size);\n-        Arena scope = Arena.ofConfined();\n-        MemorySegment source = unscoped.reinterpret(scope, null);\n-        \/\/ Preferable we'd like to register this cleanup in the line above\n-        \/\/ but it breaks scalar replacement.\n-        return new BoundedArena(scope, source, CallBufferCache::releaseOrFree);\n-    }\n-\n-    \/** A confined arena slicing off an (unscoped) source segment. *\/\n-    static final class BoundedArena implements Arena {\n-        private final Arena scope;\n-        private final MemorySegment source;\n-        private final SegmentAllocator allocator;\n-        private final Consumer<MemorySegment> cleanup;\n-\n-        @ForceInline\n-        public BoundedArena(Arena scope, MemorySegment source, Consumer<MemorySegment> cleanup) {\n-            this.scope = scope;\n-            this.source = source;\n-            this.allocator = SegmentAllocator.slicingAllocator(source);\n-            this.cleanup = cleanup;\n-        }\n-\n+    private static final CarrierThreadLocal<BufferStack> BUFFER_STACK = new CarrierThreadLocal<>() {\n@@ -415,8 +388,2 @@\n-        @ForceInline\n-        public MemorySegment allocate(long byteSize, long byteAlignment) {\n-            return allocator.allocate(byteSize, byteAlignment);\n-        }\n-\n-        @Override\n-        public Scope scope() {\n-            return scope.scope();\n+        protected BufferStack initialValue() {\n+            return new BufferStack(Arena.ofAuto().allocate(256));\n@@ -424,0 +391,1 @@\n+    };\n@@ -425,6 +393,4 @@\n-        @Override\n-        @ForceInline\n-        public void close() {\n-            scope.close();\n-            cleanup.accept(source);\n-        }\n+    @ForceInline\n+    @SuppressWarnings(\"restricted\")\n+    public static Arena newBoundedArena(long size) {\n+        return BUFFER_STACK.get().reserve(size);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":9,"deletions":43,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.foreign.abi  java.base\/jdk.internal.misc\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED CallBufferCacheTest\n- *\/\n-\n-import jdk.internal.foreign.abi.CallBufferCache;\n-import jdk.internal.misc.Unsafe;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.*;\n-\n-public class CallBufferCacheTest {\n-    Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    @Test\n-    public void testEmpty() {\n-        assertEquals(CallBufferCache.acquire(), 0);\n-    }\n-\n-    @Test\n-    public void testCacheSize() {\n-        assertEquals(CallBufferCache.acquire(), 0);\n-\n-        \/\/ Three nested calls.\n-        long address1 = UNSAFE.allocateMemory(128);\n-        long address2 = UNSAFE.allocateMemory(128);\n-        long address3 = UNSAFE.allocateMemory(128);\n-\n-        \/\/ Two buffers go into the cache.\n-        assertTrue(CallBufferCache.release(address3));\n-        assertTrue(CallBufferCache.release(address2));\n-        assertFalse(CallBufferCache.release(address1));\n-\n-        \/\/ Next acquisition is either of them.\n-        long first = CallBufferCache.acquire();\n-        assertTrue(first == address3 || first == address2);\n-        assertTrue(CallBufferCache.release(first));\n-\n-        \/\/ Can re-acquire both.\n-        first = CallBufferCache.acquire();\n-        long second = CallBufferCache.acquire();\n-        assertNotEquals(first, second);\n-        assertTrue(first == address2 || first == address3);\n-        assertTrue(second == address2 || second == address3);\n-        \/\/ Now the cache is empty again.\n-        assertEquals(CallBufferCache.acquire(), 0);\n-\n-        UNSAFE.freeMemory(address1);\n-        UNSAFE.freeMemory(address2);\n-        UNSAFE.freeMemory(address3);\n-    }\n-\n-    @Test\n-    public void testThreadLocal() throws InterruptedException {\n-        long address = UNSAFE.allocateMemory(128);\n-        assertTrue(CallBufferCache.release(address));\n-        Thread.ofPlatform().start(() -> {\n-            \/\/ Not visible in other thread.\n-            assertEquals(CallBufferCache.acquire(), 0);\n-        }).join();\n-        \/\/ Only here.\n-        assertEquals(address, CallBufferCache.acquire());\n-        UNSAFE.freeMemory(address);\n-    }\n-\n-    @Test\n-    public void testMigrateThread() throws InterruptedException {\n-        long address = UNSAFE.allocateMemory(128);\n-        assertTrue(CallBufferCache.release(address));\n-        assertEquals(address, CallBufferCache.acquire());\n-        Thread.ofPlatform().start(() -> {\n-            \/\/ A buffer can migrate to another thread due to VThread scheduling.\n-            CallBufferCache.release(address);\n-            assertEquals(address, CallBufferCache.acquire());\n-            CallBufferCache.release(address);\n-            \/\/ freed by TL.\n-        }).join();\n-        assertEquals(CallBufferCache.acquire(), 0);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/CallBufferCacheTest.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"}]}