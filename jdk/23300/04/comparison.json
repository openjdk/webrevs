{"files":[{"patch":"@@ -2555,0 +2555,5 @@\n+  INSN1(ld1, 0b001101010, 0b0000);\n+  INSN2(ld2, 0b001101011, 0b0000);\n+  INSN3(ld3, 0b001101010, 0b0010);\n+  INSN4(ld4, 0b001101011, 0b0010);\n+\n@@ -2589,0 +2594,1 @@\n+    if (strcmp(#NAME, \"sqdmulh\") == 0) guarantee(T != T8B && T != T16B, \"incorrect arrangement\");   \\\n@@ -2612,0 +2618,2 @@\n+  INSN(sqdmulh,0, 0b101101, false); \/\/ accepted arrangements: T4H, T8H, T2S, T4S\n+  INSN(shsubv, 0, 0b001001, false); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  do_arch_blob(compiler, 30000 ZGC_ONLY(+10000))                        \\\n+  do_arch_blob(compiler, 50000 ZGC_ONLY(+10000))                        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/stubDeclarations_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4066,0 +4066,87 @@\n+  \/\/ Execute on round of keccak of two computations in parallel.\n+  \/\/ One of the states should be loaded into the lower halves of\n+  \/\/ the vector registers v0-v24, the other should be loaded into\n+  \/\/ the upper halves of those registers. The ld1r instruction loads\n+  \/\/ the round constant into both halves.\n+  \/\/ All vector instructions that are used operate on both register\n+  \/\/ halves in parallel.\n+  \/\/ If only a single computation is needed, one can only load the lower halves.\n+  void keccak_round(Register rscratch1) {\n+    __ eor3(v29, __ T16B, v4, v9, v14);\n+    __ eor3(v26, __ T16B, v1, v6, v11);\n+    __ eor3(v28, __ T16B, v3, v8, v13);\n+    __ eor3(v25, __ T16B, v0, v5, v10);\n+    __ eor3(v27, __ T16B, v2, v7, v12);\n+    __ eor3(v29, __ T16B, v29, v19, v24);\n+    __ eor3(v26, __ T16B, v26, v16, v21);\n+    __ eor3(v28, __ T16B, v28, v18, v23);\n+    __ eor3(v25, __ T16B, v25, v15, v20);\n+    __ eor3(v27, __ T16B, v27, v17, v22);\n+\n+    __ rax1(v30, __ T2D, v29, v26);\n+    __ rax1(v26, __ T2D, v26, v28);\n+    __ rax1(v28, __ T2D, v28, v25);\n+    __ rax1(v25, __ T2D, v25, v27);\n+    __ rax1(v27, __ T2D, v27, v29);\n+\n+    __ eor(v0, __ T16B, v0, v30);\n+    __ xar(v29, __ T2D, v1,  v25, (64 - 1));\n+    __ xar(v1,  __ T2D, v6,  v25, (64 - 44));\n+    __ xar(v6,  __ T2D, v9,  v28, (64 - 20));\n+    __ xar(v9,  __ T2D, v22, v26, (64 - 61));\n+    __ xar(v22, __ T2D, v14, v28, (64 - 39));\n+    __ xar(v14, __ T2D, v20, v30, (64 - 18));\n+    __ xar(v31, __ T2D, v2,  v26, (64 - 62));\n+    __ xar(v2,  __ T2D, v12, v26, (64 - 43));\n+    __ xar(v12, __ T2D, v13, v27, (64 - 25));\n+    __ xar(v13, __ T2D, v19, v28, (64 - 8));\n+    __ xar(v19, __ T2D, v23, v27, (64 - 56));\n+    __ xar(v23, __ T2D, v15, v30, (64 - 41));\n+    __ xar(v15, __ T2D, v4,  v28, (64 - 27));\n+    __ xar(v28, __ T2D, v24, v28, (64 - 14));\n+    __ xar(v24, __ T2D, v21, v25, (64 - 2));\n+    __ xar(v8,  __ T2D, v8,  v27, (64 - 55));\n+    __ xar(v4,  __ T2D, v16, v25, (64 - 45));\n+    __ xar(v16, __ T2D, v5,  v30, (64 - 36));\n+    __ xar(v5,  __ T2D, v3,  v27, (64 - 28));\n+    __ xar(v27, __ T2D, v18, v27, (64 - 21));\n+    __ xar(v3,  __ T2D, v17, v26, (64 - 15));\n+    __ xar(v25, __ T2D, v11, v25, (64 - 10));\n+    __ xar(v26, __ T2D, v7,  v26, (64 - 6));\n+    __ xar(v30, __ T2D, v10, v30, (64 - 3));\n+\n+    __ bcax(v20, __ T16B, v31, v22, v8);\n+    __ bcax(v21, __ T16B, v8,  v23, v22);\n+    __ bcax(v22, __ T16B, v22, v24, v23);\n+    __ bcax(v23, __ T16B, v23, v31, v24);\n+    __ bcax(v24, __ T16B, v24, v8,  v31);\n+\n+    __ ld1r(v31, __ T2D, __ post(rscratch1, 8));\n+\n+    __ bcax(v17, __ T16B, v25, v19, v3);\n+    __ bcax(v18, __ T16B, v3,  v15, v19);\n+    __ bcax(v19, __ T16B, v19, v16, v15);\n+    __ bcax(v15, __ T16B, v15, v25, v16);\n+    __ bcax(v16, __ T16B, v16, v3,  v25);\n+\n+    __ bcax(v10, __ T16B, v29, v12, v26);\n+    __ bcax(v11, __ T16B, v26, v13, v12);\n+    __ bcax(v12, __ T16B, v12, v14, v13);\n+    __ bcax(v13, __ T16B, v13, v29, v14);\n+    __ bcax(v14, __ T16B, v14, v26, v29);\n+\n+    __ bcax(v7, __ T16B, v30, v9,  v4);\n+    __ bcax(v8, __ T16B, v4,  v5,  v9);\n+    __ bcax(v9, __ T16B, v9,  v6,  v5);\n+    __ bcax(v5, __ T16B, v5,  v30, v6);\n+    __ bcax(v6, __ T16B, v6,  v4,  v30);\n+\n+    __ bcax(v3, __ T16B, v27, v0,  v28);\n+    __ bcax(v4, __ T16B, v28, v1,  v0);\n+    __ bcax(v0, __ T16B, v0,  v2,  v1);\n+    __ bcax(v1, __ T16B, v1,  v27, v2);\n+    __ bcax(v2, __ T16B, v2,  v28, v27);\n+\n+    __ eor(v0, __ T16B, v0, v31);\n+  }\n+\n@@ -4170,1 +4257,1 @@\n-    \/\/ block_size == 144, bit5 == 0, SHA3-244\n+    \/\/ block_size == 144, bit5 == 0, SHA3-224\n@@ -4199,76 +4286,1 @@\n-    __ eor3(v29, __ T16B, v4, v9, v14);\n-    __ eor3(v26, __ T16B, v1, v6, v11);\n-    __ eor3(v28, __ T16B, v3, v8, v13);\n-    __ eor3(v25, __ T16B, v0, v5, v10);\n-    __ eor3(v27, __ T16B, v2, v7, v12);\n-    __ eor3(v29, __ T16B, v29, v19, v24);\n-    __ eor3(v26, __ T16B, v26, v16, v21);\n-    __ eor3(v28, __ T16B, v28, v18, v23);\n-    __ eor3(v25, __ T16B, v25, v15, v20);\n-    __ eor3(v27, __ T16B, v27, v17, v22);\n-\n-    __ rax1(v30, __ T2D, v29, v26);\n-    __ rax1(v26, __ T2D, v26, v28);\n-    __ rax1(v28, __ T2D, v28, v25);\n-    __ rax1(v25, __ T2D, v25, v27);\n-    __ rax1(v27, __ T2D, v27, v29);\n-\n-    __ eor(v0, __ T16B, v0, v30);\n-    __ xar(v29, __ T2D, v1,  v25, (64 - 1));\n-    __ xar(v1,  __ T2D, v6,  v25, (64 - 44));\n-    __ xar(v6,  __ T2D, v9,  v28, (64 - 20));\n-    __ xar(v9,  __ T2D, v22, v26, (64 - 61));\n-    __ xar(v22, __ T2D, v14, v28, (64 - 39));\n-    __ xar(v14, __ T2D, v20, v30, (64 - 18));\n-    __ xar(v31, __ T2D, v2,  v26, (64 - 62));\n-    __ xar(v2,  __ T2D, v12, v26, (64 - 43));\n-    __ xar(v12, __ T2D, v13, v27, (64 - 25));\n-    __ xar(v13, __ T2D, v19, v28, (64 - 8));\n-    __ xar(v19, __ T2D, v23, v27, (64 - 56));\n-    __ xar(v23, __ T2D, v15, v30, (64 - 41));\n-    __ xar(v15, __ T2D, v4,  v28, (64 - 27));\n-    __ xar(v28, __ T2D, v24, v28, (64 - 14));\n-    __ xar(v24, __ T2D, v21, v25, (64 - 2));\n-    __ xar(v8,  __ T2D, v8,  v27, (64 - 55));\n-    __ xar(v4,  __ T2D, v16, v25, (64 - 45));\n-    __ xar(v16, __ T2D, v5,  v30, (64 - 36));\n-    __ xar(v5,  __ T2D, v3,  v27, (64 - 28));\n-    __ xar(v27, __ T2D, v18, v27, (64 - 21));\n-    __ xar(v3,  __ T2D, v17, v26, (64 - 15));\n-    __ xar(v25, __ T2D, v11, v25, (64 - 10));\n-    __ xar(v26, __ T2D, v7,  v26, (64 - 6));\n-    __ xar(v30, __ T2D, v10, v30, (64 - 3));\n-\n-    __ bcax(v20, __ T16B, v31, v22, v8);\n-    __ bcax(v21, __ T16B, v8,  v23, v22);\n-    __ bcax(v22, __ T16B, v22, v24, v23);\n-    __ bcax(v23, __ T16B, v23, v31, v24);\n-    __ bcax(v24, __ T16B, v24, v8,  v31);\n-\n-    __ ld1r(v31, __ T2D, __ post(rscratch1, 8));\n-\n-    __ bcax(v17, __ T16B, v25, v19, v3);\n-    __ bcax(v18, __ T16B, v3,  v15, v19);\n-    __ bcax(v19, __ T16B, v19, v16, v15);\n-    __ bcax(v15, __ T16B, v15, v25, v16);\n-    __ bcax(v16, __ T16B, v16, v3,  v25);\n-\n-    __ bcax(v10, __ T16B, v29, v12, v26);\n-    __ bcax(v11, __ T16B, v26, v13, v12);\n-    __ bcax(v12, __ T16B, v12, v14, v13);\n-    __ bcax(v13, __ T16B, v13, v29, v14);\n-    __ bcax(v14, __ T16B, v14, v26, v29);\n-\n-    __ bcax(v7, __ T16B, v30, v9,  v4);\n-    __ bcax(v8, __ T16B, v4,  v5,  v9);\n-    __ bcax(v9, __ T16B, v9,  v6,  v5);\n-    __ bcax(v5, __ T16B, v5,  v30, v6);\n-    __ bcax(v6, __ T16B, v6,  v4,  v30);\n-\n-    __ bcax(v3, __ T16B, v27, v0,  v28);\n-    __ bcax(v4, __ T16B, v28, v1,  v0);\n-    __ bcax(v0, __ T16B, v0,  v2,  v1);\n-    __ bcax(v1, __ T16B, v1,  v27, v2);\n-    __ bcax(v2, __ T16B, v2,  v28, v27);\n-\n-    __ eor(v0, __ T16B, v0, v31);\n+    keccak_round(rscratch1);\n@@ -4293,0 +4305,1 @@\n+    \/\/ restore callee-saved registers\n@@ -4303,0 +4316,90 @@\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - long[]  state0\n+  \/\/   c_rarg1   - long[]  state1\n+  address generate_double_keccak() {\n+    static const uint64_t round_consts[24] = {\n+      0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n+      0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n+      0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n+      0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n+      0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n+      0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n+      0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n+      0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n+    };\n+\n+    \/\/ Implements the double_keccak() method of the\n+    \/\/ sun.secyrity.provider.SHA3Parallel class\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"double_keccak\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register state0        = c_rarg0;\n+    Register state1        = c_rarg1;\n+\n+    Label rounds24_loop;\n+\n+    \/\/ save callee-saved registers\n+    __ stpd(v8, v9, __ pre(sp, -64));\n+    __ stpd(v10, v11, Address(sp, 16));\n+    __ stpd(v12, v13, Address(sp, 32));\n+    __ stpd(v14, v15, Address(sp, 48));\n+\n+    \/\/ load states\n+    __ add(rscratch1, state0, 32);\n+    __ ld4(v0, v1, v2,  v3, __ D, 0,  state0);\n+    __ ld4(v4, v5, v6,  v7, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v8, v9, v10, v11, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v12, v13, v14, v15, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v16, v17, v18, v19, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v20, v21, v22, v23, __ D, 0, __ post(rscratch1, 32));\n+    __ ld1(v24, __ D, 0, rscratch1);\n+    __ add(rscratch1, state1, 32);\n+    __ ld4(v0, v1, v2,  v3,  __ D, 1, state1);\n+    __ ld4(v4, v5, v6,  v7, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v8, v9, v10, v11, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v12, v13, v14, v15, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v16, v17, v18, v19, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v20, v21, v22, v23, __ D, 1, __ post(rscratch1, 32));\n+    __ ld1(v24, __ D, 1, rscratch1);\n+\n+    \/\/ 24 keccak rounds\n+    __ movw(rscratch2, 24);\n+\n+    \/\/ load round_constants base\n+    __ lea(rscratch1, ExternalAddress((address) round_consts));\n+\n+    __ BIND(rounds24_loop);\n+    __ subw(rscratch2, rscratch2, 1);\n+    keccak_round(rscratch1);\n+    __ cbnzw(rscratch2, rounds24_loop);\n+\n+    __ st4(v0, v1, v2,  v3,  __ D, 0, __ post(state0, 32));\n+    __ st4(v4, v5, v6,  v7,  __ D, 0, __ post(state0, 32));\n+    __ st4(v8, v9, v10, v11, __ D, 0, __ post(state0, 32));\n+    __ st4(v12, v13, v14, v15, __ D, 0, __ post(state0, 32));\n+    __ st4(v16, v17, v18, v19, __ D, 0, __ post(state0, 32));\n+    __ st4(v20, v21, v22, v23, __ D, 0, __ post(state0, 32));\n+    __ st1(v24, __ D, 0, state0);\n+    __ st4(v0, v1, v2,  v3,  __ D, 1, __ post(state1, 32));\n+    __ st4(v4, v5, v6,  v7, __ D, 1, __ post(state1, 32));\n+    __ st4(v8, v9, v10, v11, __ D, 1, __ post(state1, 32));\n+    __ st4(v12, v13, v14, v15, __ D, 1, __ post(state1, 32));\n+    __ st4(v16, v17, v18, v19, __ D, 1, __ post(state1, 32));\n+    __ st4(v20, v21, v22, v23, __ D, 1, __ post(state1, 32));\n+    __ st1(v24, __ D, 1, state1);\n+\n+    \/\/ restore callee-saved vector registers\n+    __ ldpd(v14, v15, Address(sp, 48));\n+    __ ldpd(v12, v13, Address(sp, 32));\n+    __ ldpd(v10, v11, Address(sp, 16));\n+    __ ldpd(v8, v9, __ post(sp, 64));\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -4471,0 +4574,939 @@\n+  void dilithium_load4zetas(int o0, Register zetas) {\n+    __ ldpq(as_FloatRegister(o0), as_FloatRegister(o0 + 1), __ post (zetas, 32));\n+    __ ldpq(as_FloatRegister(o0 + 2), as_FloatRegister(o0 + 3), __ post (zetas, 32));\n+\n+  }\n+\n+  void dilithium_load8zetas(Register zetas) {\n+    dilithium_load4zetas(16, zetas);\n+    dilithium_load4zetas(20, zetas);\n+  }\n+\n+  \/\/ 2x16 32-bit Montgomery multiplications in parallel\n+  \/\/ See the montMul() method of the sun.security.provider.ML_DSA class.\n+  \/\/ Here MONT_R_BITS is 32, so the right shift by it is implicit.\n+  \/\/ The constants MONT_Q_INV_MOD_R and MONT_Q are loaded in (all 32-bit\n+  \/\/ chunks of) vector registers v30 and v31, resp.\n+  \/\/ The inputs are in v0-v7 and v16-v23 and the results go to v16-v23,\n+  \/\/ four 32-bit values in each register\n+  void dilithium_montmul32(bool by_constant) {\n+    FloatRegister vr0 = by_constant ? v29 : v0;\n+    FloatRegister vr1 = by_constant ? v29 : v1;\n+    FloatRegister vr2 = by_constant ? v29 : v2;\n+    FloatRegister vr3 = by_constant ? v29 : v3;\n+    FloatRegister vr4 = by_constant ? v29 : v4;\n+    FloatRegister vr5 = by_constant ? v29 : v5;\n+    FloatRegister vr6 = by_constant ? v29 : v6;\n+    FloatRegister vr7 = by_constant ? v29 : v7;\n+\n+    __ sqdmulh(v24, __ T4S, vr0, v16);\n+    __ mulv(v16, __ T4S, vr0, v16);\n+    __ sqdmulh(v25, __ T4S, vr1, v17);\n+    __ mulv(v17, __ T4S, vr1, v17);\n+    __ sqdmulh(v26, __ T4S, vr2, v18);\n+    __ mulv(v18, __ T4S, vr2, v18);\n+    __ sqdmulh(v27, __ T4S, vr3, v19);\n+    __ mulv(v19, __ T4S, vr3, v19);\n+\n+    __ mulv(v16, __ T4S, v16, v30);\n+    __ mulv(v17, __ T4S, v17, v30);\n+    __ mulv(v18, __ T4S, v18, v30);\n+    __ mulv(v19, __ T4S, v19, v30);\n+\n+    __ sqdmulh(v16, __ T4S, v16, v31);\n+    __ sqdmulh(v17, __ T4S, v17, v31);\n+    __ sqdmulh(v18, __ T4S, v18, v31);\n+    __ sqdmulh(v19, __ T4S, v19, v31);\n+\n+    __ shsubv(v16, __ T4S, v24, v16);\n+    __ shsubv(v17, __ T4S, v25, v17);\n+    __ shsubv(v18, __ T4S, v26, v18);\n+    __ shsubv(v19, __ T4S, v27, v19);\n+\n+    __ sqdmulh(v24, __ T4S, vr4, v20);\n+    __ mulv(v20, __ T4S, vr4, v20);\n+    __ sqdmulh(v25, __ T4S, vr5, v21);\n+    __ mulv(v21, __ T4S, vr5, v21);\n+    __ sqdmulh(v26, __ T4S, vr6, v22);\n+    __ mulv(v22, __ T4S, vr6, v22);\n+    __ sqdmulh(v27, __ T4S, vr7, v23);\n+    __ mulv(v23, __ T4S, vr7, v23);\n+\n+    __ mulv(v20, __ T4S, v20, v30);\n+    __ mulv(v21, __ T4S, v21, v30);\n+    __ mulv(v22, __ T4S, v22, v30);\n+    __ mulv(v23, __ T4S, v23, v30);\n+\n+    __ sqdmulh(v20, __ T4S, v20, v31);\n+    __ sqdmulh(v21, __ T4S, v21, v31);\n+    __ sqdmulh(v22, __ T4S, v22, v31);\n+    __ sqdmulh(v23, __ T4S, v23, v31);\n+\n+    __ shsubv(v20, __ T4S, v24, v20);\n+    __ shsubv(v21, __ T4S, v25, v21);\n+    __ shsubv(v22, __ T4S, v26, v22);\n+    __ shsubv(v23, __ T4S, v27, v23);\n+  }\n+\n+  void dilithium_add_sub32() {\n+    __ addv(v24, __ T4S, v0, v16);\n+    __ addv(v25, __ T4S, v1, v17);\n+    __ addv(v26, __ T4S, v2, v18);\n+    __ addv(v27, __ T4S, v3, v19);\n+    __ addv(v28, __ T4S, v4, v20);\n+    __ addv(v29, __ T4S, v5, v21);\n+    __ addv(v30, __ T4S, v6, v22);\n+    __ addv(v31, __ T4S, v7, v23);\n+\n+    __ subv(v0, __ T4S, v0, v16);\n+    __ subv(v1, __ T4S, v1, v17);\n+    __ subv(v2, __ T4S, v2, v18);\n+    __ subv(v3, __ T4S, v3, v19);\n+    __ subv(v4, __ T4S, v4, v20);\n+    __ subv(v5, __ T4S, v5, v21);\n+    __ subv(v6, __ T4S, v6, v22);\n+    __ subv(v7, __ T4S, v7, v23);\n+  }\n+\n+  void dilithium_montmul_sub_add16() {\n+    __ sqdmulh(v24, __ T4S, v1, v16);\n+    __ mulv(v16, __ T4S, v1, v16);\n+    __ sqdmulh(v25, __ T4S, v3, v17);\n+    __ mulv(v17, __ T4S, v3, v17);\n+    __ sqdmulh(v26, __ T4S, v5, v18);\n+    __ mulv(v18, __ T4S, v5, v18);\n+    __ sqdmulh(v27, __ T4S, v7, v19);\n+    __ mulv(v19, __ T4S, v7, v19);\n+\n+    __ mulv(v16, __ T4S, v16, v30);\n+    __ mulv(v17, __ T4S, v17, v30);\n+    __ mulv(v18, __ T4S, v18, v30);\n+    __ mulv(v19, __ T4S, v19, v30);\n+\n+    __ sqdmulh(v16, __ T4S, v16, v31);\n+    __ sqdmulh(v17, __ T4S, v17, v31);\n+    __ sqdmulh(v18, __ T4S, v18, v31);\n+    __ sqdmulh(v19, __ T4S, v19, v31);\n+\n+    __ shsubv(v16, __ T4S, v24, v16);\n+    __ shsubv(v17, __ T4S, v25, v17);\n+    __ shsubv(v18, __ T4S, v26, v18);\n+    __ shsubv(v19, __ T4S, v27, v19);\n+\n+    __ subv(v1, __ T4S, v0, v16);\n+    __ subv(v3, __ T4S, v2, v17);\n+    __ subv(v5, __ T4S, v4, v18);\n+    __ subv(v7, __ T4S, v6, v19);\n+\n+    __ addv(v0, __ T4S, v0, v16);\n+    __ addv(v2, __ T4S, v2, v17);\n+    __ addv(v4, __ T4S, v4, v18);\n+    __ addv(v6, __ T4S, v6, v19);\n+  }\n+\n+  \/\/ At these levels, the indices that correspond to the 'j's (and 'j+l's)\n+  \/\/ in the Java implementation come in sequences of at least 8, so we\n+  \/\/ can use ldpq to collect the corresponding data into pairs of vector\n+  \/\/ registers.\n+  \/\/ We collect the coefficients corresponding to the 'j+l' indexes into\n+  \/\/ the vector registers v0-v7, the zetas into the vector registers v16-v23\n+  \/\/ then we do the (Montgomery) multiplications by the zetas in parallel\n+  \/\/ into v16-v23, load the coeffs corresponding to the 'j' indexes into\n+  \/\/ v0-v7, then do the additions into v24-v31 and the subtractions into\n+  \/\/ v0-v7 and finally save the results back to the coeffs array.\n+  void dilithiumNttLevel0_4(const Register dilithiumConsts,\n+    const Register coeffs, const Register zetas) {\n+    int c1 = 0;\n+    int c2 = 512;\n+    int startIncr;\n+    int incr1 = 32;\n+    int incr2 = 64;\n+    int incr3 = 96;\n+\n+    for (int level = 0; level < 5; level++) {\n+      int c1Start = c1;\n+      int c2Start = c2;\n+      if (level == 3) {\n+        incr1 = 32;\n+        incr2 = 128;\n+        incr3 = 160;\n+      } else if (level == 4) {\n+        incr1 = 64;\n+        incr2 = 128;\n+        incr3 = 192;\n+      }\n+\n+      for (int i = 0; i < 4; i++) {\n+        __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+        __ ldpq(v0, v1, Address(coeffs, c2Start));\n+        __ ldpq(v2, v3, Address(coeffs, c2Start + incr1));\n+        __ ldpq(v4, v5, Address(coeffs, c2Start + incr2));\n+        __ ldpq(v6, v7, Address(coeffs, c2Start + incr3));\n+        dilithium_load8zetas(zetas);\n+        dilithium_montmul32(false);\n+        __ ldpq(v0, v1, Address(coeffs, c1Start));\n+        __ ldpq(v2, v3, Address(coeffs, c1Start + incr1));\n+        __ ldpq(v4, v5, Address(coeffs, c1Start + incr2));\n+        __ ldpq(v6, v7, Address(coeffs, c1Start + incr3));\n+        dilithium_add_sub32();\n+        __ stpq(v24, v25, Address(coeffs, c1Start));\n+        __ stpq(v26, v27, Address(coeffs, c1Start + incr1));\n+        __ stpq(v28, v29, Address(coeffs, c1Start + incr2));\n+        __ stpq(v30, v31, Address(coeffs, c1Start + incr3));\n+        __ stpq(v0, v1, Address(coeffs, c2Start));\n+        __ stpq(v2, v3, Address(coeffs, c2Start + incr1));\n+        __ stpq(v4, v5, Address(coeffs, c2Start + incr2));\n+        __ stpq(v6, v7, Address(coeffs, c2Start + incr3));\n+\n+        int k = 4 * level + i;\n+\n+        if (k > 7) {\n+          startIncr = 256;\n+        } else if (k == 5) {\n+          startIncr = 384;\n+        } else {\n+          startIncr = 128;\n+        }\n+\n+        c1Start += startIncr;\n+        c2Start += startIncr;\n+      }\n+\n+      c2 \/= 2;\n+    }\n+  }\n+\n+  \/\/ Dilithium NTT function except for the final \"normalization\" to |coeff| < Q.\n+  \/\/ Implements the method\n+  \/\/ static int implDilithiumAlmostNtt(int[] coeffs, int zetas[]) {}\n+  \/\/ of the Java class sun.security.provider\n+  \/\/\n+  \/\/ coeffs (int[256]) = c_rarg0\n+  \/\/ zetas (int[256]) = c_rarg1\n+  address generate_dilithiumAlmostNtt() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostNtt_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    const Register coeffs = c_rarg0;\n+    const Register zetas = c_rarg1;\n+\n+    const Register tmpAddr = r9;\n+    const Register dilithiumConsts = r10;\n+    const Register result = r11;\n+\n+    __ add(result, coeffs, 0);\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    \/\/ Each level represents one iteration of the outer for loop of the Java version\n+\n+    \/\/ level 0-4\n+    dilithiumNttLevel0_4(dilithiumConsts, coeffs, zetas);\n+\n+    \/\/ level 5\n+    for (int i = 0; i < 1024; i += 256) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+      __ ldr(v0, __ Q, Address(coeffs, i + 16));\n+      __ ldr(v1, __ Q, Address(coeffs, i + 48));\n+      __ ldr(v2, __ Q, Address(coeffs, i + 80));\n+      __ ldr(v3, __ Q, Address(coeffs, i + 112));\n+      __ ldr(v4, __ Q, Address(coeffs, i + 144));\n+      __ ldr(v5, __ Q, Address(coeffs, i + 176));\n+      __ ldr(v6, __ Q, Address(coeffs, i + 208));\n+      __ ldr(v7, __ Q, Address(coeffs, i + 240));\n+      dilithium_load8zetas(zetas);\n+      dilithium_montmul32(false);\n+      __ ldr(v0, __ Q, Address(coeffs, i));\n+      __ ldr(v1, __ Q, Address(coeffs, i + 32));\n+      __ ldr(v2, __ Q, Address(coeffs, i + 64));\n+      __ ldr(v3, __ Q, Address(coeffs, i + 96));\n+      __ ldr(v4, __ Q, Address(coeffs, i + 128));\n+      __ ldr(v5, __ Q, Address(coeffs, i + 160));\n+      __ ldr(v6, __ Q, Address(coeffs, i + 192));\n+      __ ldr(v7, __ Q, Address(coeffs, i + 224));\n+      dilithium_add_sub32();\n+      __ str(v24, __ Q, Address(coeffs, i));\n+      __ str(v25, __ Q, Address(coeffs, i + 32));\n+      __ str(v26, __ Q, Address(coeffs, i + 64));\n+      __ str(v27, __ Q, Address(coeffs, i + 96));\n+      __ str(v28, __ Q, Address(coeffs, i + 128));\n+      __ str(v29, __ Q, Address(coeffs, i + 160));\n+      __ str(v30, __ Q, Address(coeffs, i + 192));\n+      __ str(v31, __ Q, Address(coeffs, i + 224));\n+      __ str(v0, __ Q, Address(coeffs, i + 16));\n+      __ str(v1, __ Q, Address(coeffs, i + 48));\n+      __ str(v2, __ Q, Address(coeffs, i + 80));\n+      __ str(v3, __ Q, Address(coeffs, i + 112));\n+      __ str(v4, __ Q, Address(coeffs, i + 144));\n+      __ str(v5, __ Q, Address(coeffs, i + 176));\n+      __ str(v6, __ Q, Address(coeffs, i + 208));\n+      __ str(v7, __ Q, Address(coeffs, i + 240));\n+    }\n+\n+    \/\/ level 6\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T2D, tmpAddr);\n+      dilithium_load4zetas(16, zetas);\n+      dilithium_montmul_sub_add16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T2D, tmpAddr);\n+    }\n+\n+    \/\/ level 7\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T4S, tmpAddr);\n+      dilithium_load4zetas(16, zetas);\n+      dilithium_montmul_sub_add16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T4S, tmpAddr);\n+    }\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+\n+  }\n+\n+  void dilithium_sub_add_montmul16() {\n+    __ subv(v20, __ T4S, v0, v1);\n+    __ subv(v21, __ T4S, v2, v3);\n+    __ subv(v22, __ T4S, v4, v5);\n+    __ subv(v23, __ T4S, v6, v7);\n+\n+    __ addv(v0, __ T4S, v0, v1);\n+    __ addv(v2, __ T4S, v2, v3);\n+    __ addv(v4, __ T4S, v4, v5);\n+    __ addv(v6, __ T4S, v6, v7);\n+\n+    __ sqdmulh(v24, __ T4S, v20, v16);\n+    __ mulv(v1, __ T4S, v20, v16);\n+    __ sqdmulh(v25, __ T4S, v21, v17);\n+    __ mulv(v3, __ T4S, v21, v17);\n+    __ sqdmulh(v26, __ T4S, v22, v18);\n+    __ mulv(v5, __ T4S, v22, v18);\n+    __ sqdmulh(v27, __ T4S, v23, v19);\n+    __ mulv(v7, __ T4S, v23, v19);\n+\n+    __ mulv(v1, __ T4S, v1, v30);\n+    __ mulv(v3, __ T4S, v3, v30);\n+    __ mulv(v5, __ T4S, v5, v30);\n+    __ mulv(v7, __ T4S, v7, v30);\n+\n+    __ sqdmulh(v1, __ T4S, v1, v31);\n+    __ sqdmulh(v3, __ T4S, v3, v31);\n+    __ sqdmulh(v5, __ T4S, v5, v31);\n+    __ sqdmulh(v7, __ T4S, v7, v31);\n+\n+    __ shsubv(v1, __ T4S, v24, v1);\n+    __ shsubv(v3, __ T4S, v25, v3);\n+    __ shsubv(v5, __ T4S, v26, v5);\n+    __ shsubv(v7, __ T4S, v27, v7);\n+  }\n+\n+  \/\/ At these levels, the indices that correspond to the 'j's (and 'j+l's)\n+  \/\/ in the Java implementation come in sequences of at least 8, so we\n+  \/\/ can use ldpq to collect the corresponding data into pairs of vector\n+  \/\/ registers\n+  \/\/ We collect the coefficients that correspond to the 'j's into v0-v7\n+  \/\/ the coefficiets that correspond to the 'j+l's into v16-v23 then\n+  \/\/ do the additions into v24-v31 and the subtractions into v0-v7 then\n+  \/\/ save the result of the additions, load the zetas into v16-v23\n+  \/\/ do the (Montgomery) multiplications by zeta in parallel into v16-v23\n+  \/\/ finally save the results back to the coeffs array\n+  void dilithiumInverseNttLevel3_7(const Register dilithiumConsts,\n+    const Register coeffs, const Register zetas) {\n+    int c1 = 0;\n+    int c2 = 32;\n+    int startIncr;\n+    int incr1;\n+    int incr2;\n+    int incr3;\n+\n+    for (int level = 3; level < 8; level++) {\n+      int c1Start = c1;\n+      int c2Start = c2;\n+      if (level == 3) {\n+        incr1 = 64;\n+        incr2 = 128;\n+        incr3 = 192;\n+      } else if (level == 4) {\n+        incr1 = 32;\n+        incr2 = 128;\n+        incr3 = 160;\n+      } else {\n+        incr1 = 32;\n+        incr2 = 64;\n+        incr3 = 96;\n+      }\n+\n+      for (int i = 0; i < 4; i++) {\n+        __ ldpq(v0, v1, Address(coeffs, c1Start));\n+        __ ldpq(v2, v3, Address(coeffs, c1Start + incr1));\n+        __ ldpq(v4, v5, Address(coeffs, c1Start + incr2));\n+        __ ldpq(v6, v7, Address(coeffs, c1Start + incr3));\n+        __ ldpq(v16, v17, Address(coeffs, c2Start));\n+        __ ldpq(v18, v19, Address(coeffs, c2Start + incr1));\n+        __ ldpq(v20, v21, Address(coeffs, c2Start + incr2));\n+        __ ldpq(v22, v23, Address(coeffs, c2Start + incr3));\n+        dilithium_add_sub32();\n+        __ stpq(v24, v25, Address(coeffs, c1Start));\n+        __ stpq(v26, v27, Address(coeffs, c1Start + incr1));\n+        __ stpq(v28, v29, Address(coeffs, c1Start + incr2));\n+        __ stpq(v30, v31, Address(coeffs, c1Start + incr3));\n+        __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+        dilithium_load8zetas(zetas);\n+        dilithium_montmul32(false);\n+        __ stpq(v16, v17, Address(coeffs, c2Start));\n+        __ stpq(v18, v19, Address(coeffs, c2Start + incr1));\n+        __ stpq(v20, v21, Address(coeffs, c2Start + incr2));\n+        __ stpq(v22, v23, Address(coeffs, c2Start + incr3));\n+\n+        int k = 4 * level + i;\n+\n+        if (k < 24) {\n+          startIncr = 256;\n+        } else if (k == 25) {\n+          startIncr = 384;\n+        } else {\n+          startIncr = 128;\n+        }\n+\n+        c1Start += startIncr;\n+        c2Start += startIncr;\n+      }\n+\n+      c2 *= 2;\n+    }\n+  }\n+\n+  \/\/ Dilithium Inverse NTT function except the final mod Q division by 2^256.\n+  \/\/ Implements the method\n+  \/\/ static int implDilithiumAlmostInverseNtt(int[] coeffs, int[] zetas) {} of\n+  \/\/ the sun.security.provider.ML_DSA class.\n+  \/\/\n+  \/\/ coeffs (int[256]) = c_rarg0\n+  \/\/ zetas (int[256]) = c_rarg1\n+  address generate_dilithiumAlmostInverseNtt() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostInverseNtt_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    const Register coeffs = c_rarg0;\n+    const Register zetas = c_rarg1;\n+\n+    const Register tmpAddr = r9;\n+    const Register dilithiumConsts = r10;\n+    const Register result = r11;\n+\n+    __ add(result, coeffs, 0);\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    \/\/ Each level represents one iteration of the outer for loop of the Java version\n+    \/\/ level0\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T4S, tmpAddr);\n+      dilithium_load4zetas(16, zetas);\n+      dilithium_sub_add_montmul16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T4S, tmpAddr);\n+    }\n+\n+    \/\/ level 1\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T2D, tmpAddr);\n+      dilithium_load4zetas(16, zetas);\n+      dilithium_sub_add_montmul16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T2D, tmpAddr);\n+    }\n+\n+    \/\/level 2\n+    for (int i = 0; i < 1024; i += 256) {\n+      __ ldr(v0, __ Q, Address(coeffs, i));\n+      __ ldr(v1, __ Q, Address(coeffs, i + 32));\n+      __ ldr(v2, __ Q, Address(coeffs, i + 64));\n+      __ ldr(v3, __ Q, Address(coeffs, i + 96));\n+      __ ldr(v4, __ Q, Address(coeffs, i + 128));\n+      __ ldr(v5, __ Q, Address(coeffs, i + 160));\n+      __ ldr(v6, __ Q, Address(coeffs, i + 192));\n+      __ ldr(v7, __ Q, Address(coeffs, i + 224));\n+      __ ldr(v16, __ Q, Address(coeffs, i + 16));\n+      __ ldr(v17, __ Q, Address(coeffs, i + 48));\n+      __ ldr(v18, __ Q, Address(coeffs, i + 80));\n+      __ ldr(v19, __ Q, Address(coeffs, i + 112));\n+      __ ldr(v20, __ Q, Address(coeffs, i + 144));\n+      __ ldr(v21, __ Q, Address(coeffs, i + 176));\n+      __ ldr(v22, __ Q, Address(coeffs, i + 208));\n+      __ ldr(v23, __ Q, Address(coeffs, i + 240));\n+      dilithium_add_sub32();\n+      __ str(v24, __ Q, Address(coeffs, i));\n+      __ str(v25, __ Q, Address(coeffs, i + 32));\n+      __ str(v26, __ Q, Address(coeffs, i + 64));\n+      __ str(v27, __ Q, Address(coeffs, i + 96));\n+      __ str(v28, __ Q, Address(coeffs, i + 128));\n+      __ str(v29, __ Q, Address(coeffs, i + 160));\n+      __ str(v30, __ Q, Address(coeffs, i + 192));\n+      __ str(v31, __ Q, Address(coeffs, i + 224));\n+      dilithium_load8zetas(zetas);\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+      dilithium_montmul32(false);\n+      __ str(v16, __ Q, Address(coeffs, i + 16));\n+      __ str(v17, __ Q, Address(coeffs, i + 48));\n+      __ str(v18, __ Q, Address(coeffs, i + 80));\n+      __ str(v19, __ Q, Address(coeffs, i + 112));\n+      __ str(v20, __ Q, Address(coeffs, i + 144));\n+      __ str(v21, __ Q, Address(coeffs, i + 176));\n+      __ str(v22, __ Q, Address(coeffs, i + 208));\n+      __ str(v23, __ Q, Address(coeffs, i + 240));\n+    }\n+\n+    \/\/ level 3-7\n+    dilithiumInverseNttLevel3_7(dilithiumConsts, coeffs, zetas);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+\n+  }\n+\n+  \/\/ Dilithium multiply polynomials in the NTT domain.\n+  \/\/ Straightforward implementation of the method\n+  \/\/ static int implDilithiumNttMult(\n+  \/\/              int[] result, int[] ntta, int[] nttb {} of\n+  \/\/ the sun.security.provider.ML_DSA class.\n+  \/\/\n+  \/\/ result (int[256]) = c_rarg0\n+  \/\/ poly1 (int[256]) = c_rarg1\n+  \/\/ poly2 (int[256]) = c_rarg2\n+  address generate_dilithiumNttMult() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumNttMult_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_loop;\n+\n+    const Register result = c_rarg0;\n+    const Register poly1 = c_rarg1;\n+    const Register poly2 = c_rarg2;\n+\n+    const Register dilithiumConsts = r10;\n+    const Register len = r11;\n+\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+    __ ldr(v29, __ Q, Address(dilithiumConsts, 48));\n+\n+    __ mov(len, zr);\n+    __ add(len, len, 1024);\n+\n+    __ BIND(L_loop);\n+\n+    __ ldpq(v0, v1, __ post(poly1, 32));\n+    __ ldpq(v2, v3, __ post(poly1, 32));\n+    __ ldpq(v4, v5, __ post(poly1, 32));\n+    __ ldpq(v6, v7, __ post(poly1, 32));\n+    __ ldpq(v16, v17, __ post(poly2, 32));\n+    __ ldpq(v18, v19, __ post(poly2, 32));\n+    __ ldpq(v20, v21, __ post(poly2, 32));\n+    __ ldpq(v22, v23, __ post(poly2, 32));\n+    dilithium_montmul32(false);\n+    dilithium_montmul32(true);\n+    __ stpq(v16, v17, __ post(result, 32));\n+    __ stpq(v18, v19, __ post(result, 32));\n+    __ stpq(v20, v21, __ post(result, 32));\n+    __ stpq(v22, v23, __ post(result, 32));\n+\n+    __ sub(len, len, 128);\n+    __ cmp(len, (u1)128);\n+    __ br(Assembler::GE, L_loop);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+\n+  }\n+\n+  \/\/ Dilithium Motgomery multiply an array by a constant.\n+  \/\/ A straightforward implementation of the method\n+  \/\/ static int implDilithiumMontMulByConstant(int[] coeffs, int constant) {}\n+  \/\/ of the sun.security.provider.MLDSA class\n+  \/\/\n+  \/\/ coeffs (int[256]) = c_rarg0\n+  \/\/ constant (int) = c_rarg1\n+  address generate_dilithiumMontMulByConstant() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumMontMulByConstant_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_loop;\n+\n+    const Register coeffs = c_rarg0;\n+    const Register constant = c_rarg1;\n+\n+    const Register dilithiumConsts = r10;\n+    const Register result = r11;\n+    const Register len = r12;\n+\n+    __ add(result, coeffs, 0);\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    __ ldpq(v30, v31, Address(dilithiumConsts, 0));\n+    __ dup(v29, __ T4S, constant);\n+    __ mov(len, zr);\n+    __ add(len, len, 1024);\n+\n+    __ BIND(L_loop);\n+\n+    __ ldpq(v16, v17, __ post(coeffs, 32));\n+    __ ldpq(v18, v19, __ post(coeffs, 32));\n+    __ ldpq(v20, v21, __ post(coeffs, 32));\n+    __ ldpq(v22, v23, __ post(coeffs, 32));\n+    dilithium_montmul32(true);\n+    __ stpq(v16, v17, __ post(result, 32));\n+    __ stpq(v18, v19, __ post(result, 32));\n+    __ stpq(v20, v21, __ post(result, 32));\n+    __ stpq(v22, v23, __ post(result, 32));\n+\n+    __ sub(len, len, 128);\n+    __ cmp(len, (u1)128);\n+    __ br(Assembler::GE, L_loop);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Dilithium decompose poly.\n+  \/\/ Implements the method\n+  \/\/ static int implDilithiumDecomposePoly(int[] coeffs, int constant) {}\n+  \/\/ of the sun.security.provider.ML_DSA class\n+  \/\/\n+  \/\/ input (int[256]) = c_rarg0\n+  \/\/ lowPart (int[256]) = c_rarg1\n+  \/\/ highPart (int[256]) = c_rarg2\n+  \/\/ twoGamma2  (int) = c_rarg3\n+  \/\/ multiplier (int) = c_rarg4\n+  address generate_dilithiumDecomposePoly() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumDecomposePoly_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_loop;\n+\n+    const Register input = c_rarg0;\n+    const Register lowPart = c_rarg1;\n+    const Register highPart = c_rarg2;\n+    const Register twoGamma2 = c_rarg3;\n+    const Register multiplier = c_rarg4;\n+\n+    const Register len = r9;\n+    const Register dilithiumConsts = r10;\n+    const Register tmp = r11;\n+\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    \/\/ save callee-saved registers\n+    __ stpd(v8, v9, __ pre(sp, -64));\n+    __ stpd(v10, v11, Address(sp, 16));\n+    __ stpd(v12, v13, Address(sp, 32));\n+    __ stpd(v14, v15, Address(sp, 48));\n+\n+\n+    __ mov(tmp, zr);\n+    __ add(tmp, tmp, 1);\n+    __ dup(v25, __ T4S, tmp); \/\/ 1\n+    __ ldr(v30, __ Q, Address(dilithiumConsts, 16)); \/\/ q\n+    __ ldr(v31, __ Q, Address(dilithiumConsts, 64)); \/\/ addend for mod q reduce\n+    __ dup(v28, __ T4S, twoGamma2); \/\/ 2 * gamma2\n+    __ dup(v29, __ T4S, multiplier); \/\/ multiplier for mod 2 * gamma reduce\n+    __ subv(v26, __ T4S, v30, v25); \/\/ q - 1\n+    __ sshr(v27, __ T4S, v28, 1); \/\/ gamma2\n+\n+    __ mov(len, zr);\n+    __ add(len, len, 1024);\n+\n+    __ BIND(L_loop);\n+\n+    __ ld4(v0, v1, v2, v3, __ T4S, __ post(input, 64));\n+\n+    \/\/ rplus in v0\n+    \/\/  rplus = rplus - ((rplus + 5373807) >> 23) * dilithium_q;\n+    __ addv(v4, __ T4S, v0, v31);\n+    __ addv(v5, __ T4S, v1, v31);\n+    __ addv(v6, __ T4S, v2, v31);\n+    __ addv(v7, __ T4S, v3, v31);\n+\n+    __ sshr(v4, __ T4S, v4, 23);\n+    __ sshr(v5, __ T4S, v5, 23);\n+    __ sshr(v6, __ T4S, v6, 23);\n+    __ sshr(v7, __ T4S, v7, 23);\n+\n+    __ mulv(v4, __ T4S, v4, v30);\n+    __ mulv(v5, __ T4S, v5, v30);\n+    __ mulv(v6, __ T4S, v6, v30);\n+    __ mulv(v7, __ T4S, v7, v30);\n+\n+    __ subv(v0, __ T4S, v0, v4);\n+    __ subv(v1, __ T4S, v1, v5);\n+    __ subv(v2, __ T4S, v2, v6);\n+    __ subv(v3, __ T4S, v3, v7);\n+\n+    \/\/ rplus in v0\n+    \/\/ rplus = rplus + ((rplus >> 31) & dilithium_q);\n+    __ sshr(v4, __ T4S, v0, 31);\n+    __ sshr(v5, __ T4S, v1, 31);\n+    __ sshr(v6, __ T4S, v2, 31);\n+    __ sshr(v7, __ T4S, v3, 31);\n+\n+    __ andr(v4, __ T16B, v4, v30);\n+    __ andr(v5, __ T16B, v5, v30);\n+    __ andr(v6, __ T16B, v6, v30);\n+    __ andr(v7, __ T16B, v7, v30);\n+\n+    __ addv(v0, __ T4S, v0, v4);\n+    __ addv(v1, __ T4S, v1, v5);\n+    __ addv(v2, __ T4S, v2, v6);\n+    __ addv(v3, __ T4S, v3, v7);\n+\n+    \/\/ rplus in v0\n+    \/\/ int quotient = (rplus * multiplier) >> 22;\n+    __ mulv(v4, __ T4S, v0, v29);\n+    __ mulv(v5, __ T4S, v1, v29);\n+    __ mulv(v6, __ T4S, v2, v29);\n+    __ mulv(v7, __ T4S, v3, v29);\n+\n+    __ sshr(v4, __ T4S, v4, 22);\n+    __ sshr(v5, __ T4S, v5, 22);\n+    __ sshr(v6, __ T4S, v6, 22);\n+    __ sshr(v7, __ T4S, v7, 22);\n+\n+    \/\/ quotient in v4\n+    \/\/ int r0 = rplus - quotient * twoGamma2;\n+    __ mulv(v8, __ T4S, v4, v28);\n+    __ mulv(v9, __ T4S, v5, v28);\n+    __ mulv(v10, __ T4S, v6, v28);\n+    __ mulv(v11, __ T4S, v7, v28);\n+\n+    __ subv(v8, __ T4S, v0, v8);\n+    __ subv(v9, __ T4S, v1, v9);\n+    __ subv(v10, __ T4S, v2, v10);\n+    __ subv(v11, __ T4S, v3, v11);\n+\n+    \/\/ r0 in v8\n+    \/\/ int mask = (twoGamma2 - r0) >> 22;\n+    __ subv(v12, __ T4S, v28, v8);\n+    __ subv(v13, __ T4S, v28, v9);\n+    __ subv(v14, __ T4S, v28, v10);\n+    __ subv(v15, __ T4S, v28, v11);\n+\n+    __ sshr(v12, __ T4S, v12, 22);\n+    __ sshr(v13, __ T4S, v13, 22);\n+    __ sshr(v14, __ T4S, v14, 22);\n+    __ sshr(v15, __ T4S, v15, 22);\n+\n+    \/\/ mask in v12\n+    \/\/ r0 -= (mask & twoGamma2);\n+    __ andr(v16, __ T16B, v12, v28);\n+    __ andr(v17, __ T16B, v13, v28);\n+    __ andr(v18, __ T16B, v14, v28);\n+    __ andr(v19, __ T16B, v15, v28);\n+\n+    __ subv(v8, __ T4S, v8, v16);\n+    __ subv(v9, __ T4S, v9, v17);\n+    __ subv(v10, __ T4S, v10, v18);\n+    __ subv(v11, __ T4S, v11, v19);\n+\n+    \/\/ r0 in v8\n+    \/\/  quotient += (mask & 1);\n+    __ andr(v16, __ T16B, v12, v25);\n+    __ andr(v17, __ T16B, v13, v25);\n+    __ andr(v18, __ T16B, v14, v25);\n+    __ andr(v19, __ T16B, v15, v25);\n+\n+    __ addv(v4, __ T4S, v4, v16);\n+    __ addv(v5, __ T4S, v5, v17);\n+    __ addv(v6, __ T4S, v6, v18);\n+    __ addv(v7, __ T4S, v7, v19);\n+\n+    \/\/ mask = (twoGamma2 \/ 2 - r0) >> 31;\n+    __ subv(v12, __ T4S, v27, v8);\n+    __ subv(v13, __ T4S, v27, v9);\n+    __ subv(v14, __ T4S, v27, v10);\n+    __ subv(v15, __ T4S, v27, v11);\n+\n+    __ sshr(v12, __ T4S, v12, 31);\n+    __ sshr(v13, __ T4S, v13, 31);\n+    __ sshr(v14, __ T4S, v14, 31);\n+    __ sshr(v15, __ T4S, v15, 31);\n+\n+    \/\/ r0 -= (mask & twoGamma2);\n+    __ andr(v16, __ T16B, v12, v28);\n+    __ andr(v17, __ T16B, v13, v28);\n+    __ andr(v18, __ T16B, v14, v28);\n+    __ andr(v19, __ T16B, v15, v28);\n+\n+    __ subv(v8, __ T4S, v8, v16);\n+    __ subv(v9, __ T4S, v9, v17);\n+    __ subv(v10, __ T4S, v10, v18);\n+    __ subv(v11, __ T4S, v11, v19);\n+\n+    \/\/ quotient += (mask & 1);\n+    __ andr(v16, __ T16B, v12, v25);\n+    __ andr(v17, __ T16B, v13, v25);\n+    __ andr(v18, __ T16B, v14, v25);\n+    __ andr(v19, __ T16B, v15, v25);\n+\n+    __ addv(v4, __ T4S, v4, v16);\n+    __ addv(v5, __ T4S, v5, v17);\n+    __ addv(v6, __ T4S, v6, v18);\n+    __ addv(v7, __ T4S, v7, v19);\n+\n+    \/\/ int r1 = rplus - r0 - (dilithium_q - 1);\n+    __ subv(v16, __ T4S, v0, v8);\n+    __ subv(v17, __ T4S, v1, v9);\n+    __ subv(v18, __ T4S, v2, v10);\n+    __ subv(v19, __ T4S, v3, v11);\n+\n+    __ subv(v16, __ T4S, v16, v26);\n+    __ subv(v17, __ T4S, v17, v26);\n+    __ subv(v18, __ T4S, v18, v26);\n+    __ subv(v19, __ T4S, v19, v26);\n+\n+    \/\/ r1 in v16\n+    \/\/ r1 = (r1 | (-r1)) >> 31; \/\/ 0 if rplus - r0 == (dilithium_q - 1), -1 otherwise\n+    __ negr(v20, __ T4S, v16);\n+    __ negr(v21, __ T4S, v17);\n+    __ negr(v22, __ T4S, v18);\n+    __ negr(v23, __ T4S, v19);\n+\n+    __ orr(v16, __ T16B, v16, v20);\n+    __ orr(v17, __ T16B, v17, v21);\n+    __ orr(v18, __ T16B, v18, v22);\n+    __ orr(v19, __ T16B, v19, v23);\n+\n+    __ sshr(v0, __ T4S, v16, 31);\n+    __ sshr(v1, __ T4S, v17, 31);\n+    __ sshr(v2, __ T4S, v18, 31);\n+    __ sshr(v3, __ T4S, v19, 31);\n+\n+    \/\/ r1 in v0\n+    \/\/ r0 += ~r1;\n+    __ notr(v20, __ T16B, v0);\n+    __ notr(v21, __ T16B, v1);\n+    __ notr(v22, __ T16B, v2);\n+    __ notr(v23, __ T16B, v3);\n+\n+    __ addv(v8, __ T4S, v8, v20);\n+    __ addv(v9, __ T4S, v9, v21);\n+    __ addv(v10, __ T4S, v10, v22);\n+    __ addv(v11, __ T4S, v11, v23);\n+\n+    \/\/ r0 in v8\n+    \/\/ r1 = r1 & quotient;\n+    __ andr(v0, __ T16B, v4, v0);\n+    __ andr(v1, __ T16B, v5, v1);\n+    __ andr(v2, __ T16B, v6, v2);\n+    __ andr(v3, __ T16B, v7, v3);\n+\n+    \/\/ r1 in v0\n+    \/\/ lowPart[m] = r0;\n+    \/\/ highPart[m] = r1;\n+    __ st4(v8, v9, v10, v11, __ T4S, __ post(lowPart, 64));\n+    __ st4(v0, v1, v2, v3, __ T4S, __ post(highPart, 64));\n+\n+\n+    __ sub(len, len, 64);\n+    __ cmp(len, (u1)64);\n+    __ br(Assembler::GE, L_loop);\n+\n+    \/\/ restore callee-saved vector registers\n+    __ ldpd(v14, v15, Address(sp, 48));\n+    __ ldpd(v12, v13, Address(sp, 32));\n+    __ ldpd(v10, v11, Address(sp, 16));\n+    __ ldpd(v8, v9, __ post(sp, 64));\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8872,0 +9914,8 @@\n+    if (UseDilithiumIntrinsics) {\n+      StubRoutines::_dilithiumAlmostNtt = generate_dilithiumAlmostNtt();\n+      StubRoutines::_dilithiumAlmostInverseNtt = generate_dilithiumAlmostInverseNtt();\n+      StubRoutines::_dilithiumNttMult = generate_dilithiumNttMult();\n+      StubRoutines::_dilithiumMontMulByConstant = generate_dilithiumMontMulByConstant();\n+      StubRoutines::_dilithiumDecomposePoly = generate_dilithiumDecomposePoly();\n+    }\n+\n@@ -8914,0 +9964,1 @@\n+      StubRoutines::_double_keccak         = generate_double_keccak();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1128,"deletions":77,"binary":false,"changes":1205,"status":"modified"},{"patch":"@@ -51,0 +51,9 @@\n+ATTRIBUTE_ALIGNED(64) uint32_t StubRoutines::aarch64::_dilithiumConsts[] =\n+{\n+    58728449, 58728449, 58728449, 58728449, \/\/ montQInvModR\n+    8380417, 8380417, 8380417, 8380417, \/\/ dilithium_q\n+    16382, 16382, 16382, 16382, \/\/ toMont((dilithium_n)^-1 (mod dilithium_q))\n+    2365951, 2365951, 2365951, 2365951, \/\/ montRSquareModQ\n+    5373807, 5373807, 5373807, 5373807 \/\/ addend for modular reduce\n+};\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  static uint32_t _dilithiumConsts[];\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -417,0 +417,11 @@\n+  if (_features & CPU_ASIMD) {\n+      if (FLAG_IS_DEFAULT(UseDilithiumIntrinsics)) {\n+          UseDilithiumIntrinsics = true;\n+      }\n+  } else if (UseDilithiumIntrinsics) {\n+      if (!FLAG_IS_DEFAULT(UseDilithiumIntrinsics)) {\n+          warning(\"Dilithium intrinsic requires ASIMD instructions\");\n+      }\n+      FLAG_SET_DEFAULT(UseDilithiumIntrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -482,0 +482,1 @@\n+  case vmIntrinsics::_double_keccak:\n@@ -494,0 +495,7 @@\n+  case vmIntrinsics::_dilithiumAlmostNtt:\n+  case vmIntrinsics::_dilithiumAlmostInverseNtt:\n+  case vmIntrinsics::_dilithiumNttMult:\n+  case vmIntrinsics::_dilithiumMontMulByConstant:\n+  case vmIntrinsics::_dilithiumDecomposePoly:\n+    if (!UseDilithiumIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -527,0 +527,6 @@\n+  \/* support for sun.security.provider.SHAKE128Parallel *\/                                                              \\\n+  do_class(sun_security_provider_sha3_parallel,                \"sun\/security\/provider\/SHA3Parallel\")                    \\\n+   do_intrinsic(_double_keccak, sun_security_provider_sha3_parallel, double_keccak_name, double_keccak_signature, F_S)   \\\n+   do_name(     double_keccak_name,                                 \"doubleKeccak\")                                     \\\n+   do_signature(double_keccak_signature,                            \"([J[J)I\")                                          \\\n+                                                                                                                        \\\n@@ -572,0 +578,20 @@\n+  \/* support for sun.security.provider.ML_DSA *\/                                                                        \\\n+ do_class(sun_security_provider_ML_DSA,      \"sun\/security\/provider\/ML_DSA\")                                            \\\n+   do_signature(IaII_signature, \"([II)I\")                                                                               \\\n+   do_signature(IaIaI_signature, \"([I[I)I\")                                                                             \\\n+   do_signature(IaIaIaI_signature, \"([I[I[I)I\")                                                                         \\\n+   do_signature(IaIaIaIII_signature, \"([I[I[III)I\")                                                                     \\\n+  do_intrinsic(_dilithiumAlmostNtt, sun_security_provider_ML_DSA, dilithiumAlmostNtt_name, IaIaI_signature, F_S)        \\\n+   do_name(dilithiumAlmostNtt_name,                            \"implDilithiumAlmostNtt\")                                \\\n+  do_intrinsic(_dilithiumAlmostInverseNtt, sun_security_provider_ML_DSA,                                                \\\n+                dilithiumAlmostInverseNtt_name, IaIaI_signature, F_S)                                                   \\\n+   do_name(dilithiumAlmostInverseNtt_name,                     \"implDilithiumAlmostInverseNtt\")                         \\\n+  do_intrinsic(_dilithiumNttMult, sun_security_provider_ML_DSA, dilithiumNttMult_name, IaIaIaI_signature, F_S)          \\\n+   do_name(dilithiumNttMult_name,                              \"implDilithiumNttMult\")                                  \\\n+  do_intrinsic(_dilithiumMontMulByConstant, sun_security_provider_ML_DSA,                                               \\\n+                dilithiumMontMulByConstant_name, IaII_signature, F_S)                                                   \\\n+   do_name(dilithiumMontMulByConstant_name,                    \"implDilithiumMontMulByConstant\")                        \\\n+  do_intrinsic(_dilithiumDecomposePoly, sun_security_provider_ML_DSA,                                                   \\\n+                dilithiumDecomposePoly_name, IaIaIaIII_signature, F_S)                                                  \\\n+   do_name(dilithiumDecomposePoly_name,                    \"implDilithiumDecomposePoly\")                                \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -398,0 +398,1 @@\n+  static_field(StubRoutines,                _double_keccak,                                   address)                               \\\n@@ -399,0 +400,5 @@\n+  static_field(StubRoutines,                _dilithiumAlmostNtt,                              address)                               \\\n+  static_field(StubRoutines,                _dilithiumAlmostInverseNtt,                       address)                               \\\n+  static_field(StubRoutines,                _dilithiumNttMult,                                address)                               \\\n+  static_field(StubRoutines,                _dilithiumMontMulByConstant,                      address)                               \\\n+  static_field(StubRoutines,                _dilithiumDecomposePoly,                          address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -781,0 +781,1 @@\n+  case vmIntrinsics::_double_keccak:\n@@ -790,0 +791,5 @@\n+  case vmIntrinsics::_dilithiumAlmostNtt:\n+  case vmIntrinsics::_dilithiumAlmostInverseNtt:\n+  case vmIntrinsics::_dilithiumNttMult:\n+  case vmIntrinsics::_dilithiumMontMulByConstant:\n+  case vmIntrinsics::_dilithiumDecomposePoly:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2195,0 +2195,5 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumAlmostNtt\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumAlmostInverseNtt\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumNttMult\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumMontMulByConstant\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumDecomposePoly\") == 0 ||\n@@ -2206,0 +2211,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"double_keccak\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -599,0 +599,2 @@\n+  case vmIntrinsics::_double_keccak:\n+    return inline_double_keccak();\n@@ -629,0 +631,10 @@\n+  case vmIntrinsics::_dilithiumAlmostNtt:\n+    return inline_dilithiumAlmostNtt();\n+  case vmIntrinsics::_dilithiumAlmostInverseNtt:\n+    return inline_dilithiumAlmostInverseNtt();\n+  case vmIntrinsics::_dilithiumNttMult:\n+    return inline_dilithiumNttMult();\n+  case vmIntrinsics::_dilithiumMontMulByConstant:\n+    return inline_dilithiumMontMulByConstant();\n+  case vmIntrinsics::_dilithiumDecomposePoly:\n+    return inline_dilithiumDecomposePoly();\n@@ -7635,0 +7647,170 @@\n+\/\/------------------------------inline_dilithiumAlmostNtt\n+bool LibraryCallKit::inline_dilithiumAlmostNtt() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumAlmostNtt has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumAlmostNtt();\n+  stubName = \"dilithiumAlmostNtt\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* ntt_zetas        = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+  ntt_zetas = must_be_not_null(ntt_zetas, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* ntt_zetas_start  = array_element_address(ntt_zetas, intcon(0), T_INT);\n+  assert(ntt_zetas_start, \"ntt_zetas is null\");\n+  Node* dilithiumAlmostNtt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumAlmostNtt_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, ntt_zetas_start);\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumAlmostNtt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumAlmostInverseNtt\n+bool LibraryCallKit::inline_dilithiumAlmostInverseNtt() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumAlmostInverseNtt has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumAlmostInverseNtt();\n+  stubName = \"dilithiumAlmostInverseNtt\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* zetas           = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+  zetas = must_be_not_null(zetas, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* zetas_start  = array_element_address(zetas, intcon(0), T_INT);\n+  assert(zetas_start, \"inverseNtt_zetas is null\");\n+  Node* dilithiumAlmostInverseNtt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumAlmostInverseNtt_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, zetas_start);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumAlmostInverseNtt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumNttMult\n+bool LibraryCallKit::inline_dilithiumNttMult() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"dilithiumNttMult has 3 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumNttMult();\n+  stubName = \"dilithiumNttMult\";\n+  if (!stubAddr) return false;\n+\n+  Node* result          = argument(0);\n+  Node* ntta            = argument(1);\n+  Node* nttb            = argument(2);\n+\n+  result = must_be_not_null(result, true);\n+  ntta = must_be_not_null(ntta, true);\n+  nttb = must_be_not_null(nttb, true);\n+\n+  Node* result_start  = array_element_address(result, intcon(0), T_INT);\n+  assert(result_start, \"result is null\");\n+  Node* ntta_start  = array_element_address(ntta, intcon(0), T_INT);\n+  assert(ntta_start, \"ntta is null\");\n+  Node* nttb_start  = array_element_address(nttb, intcon(0), T_INT);\n+  assert(nttb_start, \"nttb is null\");\n+  Node* dilithiumNttMult = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumNttMult_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  result_start, ntta_start, nttb_start);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumNttMult, TypeFunc::Parms));\n+  set_result(retvalue);\n+\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumMontMulByConstant\n+bool LibraryCallKit::inline_dilithiumMontMulByConstant() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumMontMulByConstant has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumMontMulByConstant();\n+  stubName = \"dilithiumMontMulByConstant\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* constant        = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* dilithiumMontMulByConstant = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumMontMulByConstant_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, constant);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumMontMulByConstant, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_dilithiumDecomposePoly\n+bool LibraryCallKit::inline_dilithiumDecomposePoly() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 5, \"dilithiumDecomposePoly has 5 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumDecomposePoly();\n+  stubName = \"dilithiumDecomposePoly\";\n+  if (!stubAddr) return false;\n+\n+  Node* input          = argument(0);\n+  Node* lowPart        = argument(1);\n+  Node* highPart       = argument(2);\n+  Node* twoGamma2      = argument(3);\n+  Node* multiplier     = argument(4);\n+\n+  input = must_be_not_null(input, true);\n+  lowPart = must_be_not_null(lowPart, true);\n+  highPart = must_be_not_null(highPart, true);\n+\n+  Node* input_start  = array_element_address(input, intcon(0), T_INT);\n+  assert(input_start, \"input is null\");\n+  Node* lowPart_start  = array_element_address(lowPart, intcon(0), T_INT);\n+  assert(lowPart_start, \"lowPart is null\");\n+  Node* highPart_start  = array_element_address(highPart, intcon(0), T_INT);\n+  assert(highPart_start, \"highPart is null\");\n+\n+  Node* dilithiumDecomposePoly = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumDecomposePoly_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  input_start, lowPart_start, highPart_start,\n+                                  twoGamma2, multiplier);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumDecomposePoly, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n@@ -7898,0 +8080,32 @@\n+\/\/------------------------------inline_double_keccak\n+bool LibraryCallKit::inline_double_keccak() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseSHA3Intrinsics, \"need SHA3 intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"double_keccak has 2 parameters\");\n+\n+  stubAddr = StubRoutines::double_keccak();\n+  stubName = \"double_keccak\";\n+  if (!stubAddr) return false;\n+\n+  Node* status0        = argument(0);\n+  Node* status1        = argument(1);\n+\n+  status0 = must_be_not_null(status0, true);\n+  status1 = must_be_not_null(status1, true);\n+\n+  Node* status0_start  = array_element_address(status0, intcon(0), T_LONG);\n+  assert(status0_start, \"status0 is null\");\n+  Node* status1_start  = array_element_address(status1, intcon(0), T_LONG);\n+  assert(status1_start, \"status1 is null\");\n+  Node* double_keccak = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::double_keccak_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  status0_start, status1_start);\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(double_keccak, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":214,"deletions":0,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -316,0 +316,5 @@\n+  bool inline_dilithiumAlmostNtt();\n+  bool inline_dilithiumAlmostInverseNtt();\n+  bool inline_dilithiumNttMult();\n+  bool inline_dilithiumMontMulByConstant();\n+  bool inline_dilithiumDecomposePoly();\n@@ -322,0 +327,1 @@\n+  bool inline_double_keccak();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -232,0 +232,1 @@\n+const TypeFunc* OptoRuntime::_double_keccak_Type                  = nullptr;\n@@ -241,0 +242,7 @@\n+\n+const TypeFunc* OptoRuntime::_dilithiumAlmostNtt_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumAlmostInverseNtt_Type      = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumNttMult_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumMontMulByConstant_Type     = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumDecomposePoly_Type         = nullptr;\n+\n@@ -1172,0 +1180,3 @@\n+\/*\n+ * int implCompressMultiBlock(byte[] b, int ofs, int limit)\n+ *\/\n@@ -1193,0 +1204,19 @@\n+\/\/ SHAKE128Parallel doubleKeccak function\n+static const TypeFunc* make_double_keccak_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ status0\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ status1\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1378,0 +1408,99 @@\n+\/\/ Dilithium NTT function except for the final \"normalization\" to |coeff| < Q\n+static const TypeFunc* make_dilithiumAlmostNtt_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ NTT zetas\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium inverse NTT function except the final mod Q division by 2^256\n+static const TypeFunc* make_dilithiumAlmostInverseNtt_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ inverse NTT zetas\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium NTT multiply function\n+static const TypeFunc* make_dilithiumNttMult_Type() {\n+    int argcnt = 3;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ ntta\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ nttb\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium Montgomery multiply a polynome coefficient array by a constant\n+static const TypeFunc* make_dilithiumMontMulByConstant_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypeInt::INT;          \/\/ constant multiplier\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium decompose polynomial\n+static const TypeFunc* make_dilithiumDecomposePoly_Type() {\n+    int argcnt = 5;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ input\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ lowPart\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ highPart\n+    fields[argp++] = TypeInt::INT;          \/\/ 2 * gamma2\n+    fields[argp++] = TypeInt::INT;          \/\/ multiplier\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1981,0 +2110,1 @@\n+  _double_keccak_Type                 = make_double_keccak_Type();\n@@ -1990,0 +2120,7 @@\n+\n+  _dilithiumAlmostNtt_Type            = make_dilithiumAlmostNtt_Type();\n+  _dilithiumAlmostInverseNtt_Type     = make_dilithiumAlmostInverseNtt_Type();\n+  _dilithiumNttMult_Type              = make_dilithiumNttMult_Type();\n+  _dilithiumMontMulByConstant_Type    = make_dilithiumMontMulByConstant_Type();\n+  _dilithiumDecomposePoly_Type        = make_dilithiumDecomposePoly_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":137,"deletions":0,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+  static const TypeFunc* _double_keccak_Type;\n@@ -182,0 +183,5 @@\n+  static const TypeFunc* _dilithiumAlmostNtt_Type;\n+  static const TypeFunc* _dilithiumAlmostInverseNtt_Type;\n+  static const TypeFunc* _dilithiumNttMult_Type;\n+  static const TypeFunc* _dilithiumMontMulByConstant_Type;\n+  static const TypeFunc* _dilithiumDecomposePoly_Type;\n@@ -528,0 +534,5 @@\n+  static inline const TypeFunc* double_keccak_Type() {\n+    assert(_double_keccak_Type != nullptr, \"should be initialized\");\n+    return _double_keccak_Type;\n+  }\n+\n@@ -576,0 +587,25 @@\n+  static inline const TypeFunc* dilithiumAlmostNtt_Type() {\n+    assert(_dilithiumAlmostNtt_Type != nullptr, \"should be initialized\");\n+    return _dilithiumAlmostNtt_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumAlmostInverseNtt_Type() {\n+    assert(_dilithiumAlmostInverseNtt_Type != nullptr, \"should be initialized\");\n+    return _dilithiumAlmostInverseNtt_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumNttMult_Type() {\n+    assert(_dilithiumNttMult_Type != nullptr, \"should be initialized\");\n+    return _dilithiumNttMult_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumMontMulByConstant_Type() {\n+    assert(_dilithiumMontMulByConstant_Type != nullptr, \"should be initialized\");\n+    return _dilithiumMontMulByConstant_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumDecomposePoly_Type() {\n+    assert(_dilithiumDecomposePoly_Type != nullptr, \"should be initialized\");\n+    return _dilithiumDecomposePoly_Type;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -328,0 +328,3 @@\n+  product(bool, UseDilithiumIntrinsics, false, DIAGNOSTIC,                  \\\n+          \"Use intrinsics for the vectorized version of Dilithium\")         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-\/\/ relevant template macros ahve been defined\n+\/\/ relevant template macros have been defined\n@@ -680,0 +680,15 @@\n+  do_stub(compiler, dilithiumAlmostNtt)                                 \\\n+  do_entry(compiler, dilithiumAlmostNtt,                                \\\n+           dilithiumAlmostNtt, dilithiumAlmostNtt)                      \\\n+  do_stub(compiler, dilithiumAlmostInverseNtt)                          \\\n+  do_entry(compiler, dilithiumAlmostInverseNtt,                         \\\n+           dilithiumAlmostInverseNtt, dilithiumAlmostInverseNtt)        \\\n+  do_stub(compiler, dilithiumNttMult)                                   \\\n+  do_entry(compiler, dilithiumNttMult,                                  \\\n+           dilithiumNttMult, dilithiumNttMult)                          \\\n+  do_stub(compiler, dilithiumMontMulByConstant)                         \\\n+  do_entry(compiler, dilithiumMontMulByConstant,                        \\\n+           dilithiumMontMulByConstant, dilithiumMontMulByConstant)      \\\n+  do_stub(compiler, dilithiumDecomposePoly)                             \\\n+  do_entry(compiler, dilithiumDecomposePoly,                            \\\n+           dilithiumDecomposePoly, dilithiumDecomposePoly)              \\\n@@ -730,0 +745,2 @@\n+  do_stub(compiler, double_keccak)                                      \\\n+  do_entry(compiler, double_keccak, double_keccak, double_keccak)       \\\n@@ -1045,1 +1062,0 @@\n-\n@@ -1067,1 +1083,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -30,0 +31,1 @@\n+import sun.security.provider.SHA3Parallel.Shake128Parallel;\n@@ -31,0 +33,1 @@\n+import java.security.InvalidAlgorithmParameterException;\n@@ -47,1 +50,1 @@\n-\n+    private static final int SHAKE128_BLOCK_SIZE = 168; \/\/ the block length for SHAKE128\n@@ -101,33 +104,274 @@\n-    private static final int[] MONT_ZETAS_FOR_INVERSE_NTT = new int[]{\n-        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n-        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n-        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n-        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n-        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n-        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n-        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n-        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n-        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n-        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n-        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n-        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n-        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n-        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n-        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n-        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n-        -3839961, 3628969, 3881060, 3019102, 1439742, 812732, 1584928, -1285669,\n-        -1341330, -1315589, 177440, 2409325, 1851402, -3159746, 3553272, -189548,\n-        1316856, -759969, 210977, -2389356, 3249728, -1653064, 8578, 3724342,\n-        -3958618, -904516, 1100098, -44288, -3097992, -508951, -264944, 3343383,\n-        1430430, -1852771, -1349076, 381987, 1308169, 22981, 1228525, 671102,\n-        2477047, 411027, 3693493, 2967645, -2715295, -2147896, 983419, -3412210,\n-        -126922, 3632928, 3157330, 3190144, 1000202, 4083598, -1939314, 1257611,\n-        1585221, -2176455, -3475950, 1452451, 3041255, 3677745, 1528703, 3930395,\n-        2797779, -2071892, 2556880, -3900724, -3881043, -954230, -531354, -811944,\n-        -3699596, 1600420, 2140649, -3507263, 3821735, -3505694, 1643818, 1699267,\n-        539299, -2348700, 300467, -3539968, 2867647, -3574422, 3043716, 3861115,\n-        -3915439, 2537516, 3592148, 1661693, -3530437, -3077325, -95776, -2706023,\n-        -280005, -4010497, 19422, -1757237, 3277672, 1399561, 3859737, 2118186,\n-        2108549, -2619752, 1119584, 549488, -3585928, 1079900, -1024112, -2725464,\n-        -2680103, -3111497, 2884855, -3119733, 2091905, 359251, -2353451, -1826347,\n-        -466468, 876248, 777960, -237124, 518909, 2608894, -25847\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_NTT = new int[]{\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+\n+            1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+            1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+            2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+            2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+            -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+            -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+            -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+            -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+            3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+            3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+            -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+            -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+            3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+            3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+            2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+            2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+\n+            2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464,\n+            1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112,\n+            -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900,\n+            3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928,\n+            -549488, -549488, -549488, -549488, -549488, -549488, -549488, -549488,\n+            -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584,\n+            2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752,\n+            -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549,\n+            -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186,\n+            -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737,\n+            -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561,\n+            -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672,\n+            1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237,\n+            -19422, -19422, -19422, -19422, -19422, -19422, -19422, -19422,\n+            4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497,\n+            280005, 280005, 280005, 280005, 280005, 280005, 280005, 280005,\n+\n+            2706023, 2706023, 2706023, 2706023, 95776, 95776, 95776, 95776,\n+            3077325, 3077325, 3077325, 3077325, 3530437, 3530437, 3530437, 3530437,\n+            -1661693, -1661693, -1661693, -1661693, -3592148, -3592148, -3592148, -3592148,\n+            -2537516, -2537516, -2537516, -2537516, 3915439, 3915439, 3915439, 3915439,\n+            -3861115, -3861115, -3861115, -3861115, -3043716, -3043716, -3043716, -3043716,\n+            3574422, 3574422, 3574422, 3574422, -2867647, -2867647, -2867647, -2867647,\n+            3539968, 3539968, 3539968, 3539968, -300467, -300467, -300467, -300467,\n+            2348700, 2348700, 2348700, 2348700, -539299, -539299, -539299, -539299,\n+            -1699267, -1699267, -1699267, -1699267, -1643818, -1643818, -1643818, -1643818,\n+            3505694, 3505694, 3505694, 3505694, -3821735, -3821735, -3821735, -3821735,\n+            3507263, 3507263, 3507263, 3507263, -2140649, -2140649, -2140649, -2140649,\n+            -1600420, -1600420, -1600420, -1600420, 3699596, 3699596, 3699596, 3699596,\n+            811944, 811944, 811944, 811944, 531354, 531354, 531354, 531354,\n+            954230, 954230, 954230, 954230, 3881043, 3881043, 3881043, 3881043,\n+            3900724, 3900724, 3900724, 3900724, -2556880, -2556880, -2556880, -2556880,\n+            2071892, 2071892, 2071892, 2071892, -2797779, -2797779, -2797779, -2797779,\n+\n+            -3930395, -3930395, -1528703, -1528703, -3677745, -3677745, -3041255, -3041255,\n+            -1452451, -1452451, 3475950, 3475950, 2176455, 2176455, -1585221, -1585221,\n+            -1257611, -1257611, 1939314, 1939314, -4083598, -4083598, -1000202, -1000202,\n+            -3190144, -3190144, -3157330, -3157330, -3632928, -3632928, 126922, 126922,\n+            3412210, 3412210, -983419, -983419, 2147896, 2147896, 2715295, 2715295,\n+            -2967645, -2967645, -3693493, -3693493, -411027, -411027, -2477047, -2477047,\n+            -671102, -671102, -1228525, -1228525, -22981, -22981, -1308169, -1308169,\n+            -381987, -381987, 1349076, 1349076, 1852771, 1852771, -1430430, -1430430,\n+            -3343383, -3343383, 264944, 264944, 508951, 508951, 3097992, 3097992,\n+            44288, 44288, -1100098, -1100098, 904516, 904516, 3958618, 3958618,\n+            -3724342, -3724342, -8578, -8578, 1653064, 1653064, -3249728, -3249728,\n+            2389356, 2389356, -210977, -210977, 759969, 759969, -1316856, -1316856,\n+            189548, 189548, -3553272, -3553272, 3159746, 3159746, -1851402, -1851402,\n+            -2409325, -2409325, -177440, -177440, 1315589, 1315589, 1341330, 1341330,\n+            1285669, 1285669, -1584928, -1584928, -812732, -812732, -1439742, -1439742,\n+            -3019102, -3019102, -3881060, -3881060, -3628969, -3628969, 3839961, 3839961,\n+\n+            2091667, 3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462,\n+            266997, 2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378,\n+            900702, 1859098, 909542, 819034, 495491, -1613174, -43260, -522500,\n+            -655327, -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838,\n+            342297, 286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044,\n+            2842341, 2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974,\n+            -3767016, 1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970,\n+            -1333058, 1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642,\n+            -1279661, 1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031,\n+            -542412, -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993,\n+            -2013608, 2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385,\n+            -3183426, 162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107,\n+            -3038916, 3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078,\n+            -426683, 1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893,\n+            -2939036, -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687,\n+            -554416, 3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_INVERSE_NTT = new int[]{\n+            -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+            3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+            3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+            -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+            1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+            1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+            3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+            -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+            1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+            1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+            -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+            -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+            3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+            522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+            3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+            3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+\n+            -3839961, -3839961, 3628969, 3628969, 3881060, 3881060, 3019102, 3019102,\n+            1439742, 1439742, 812732, 812732, 1584928, 1584928, -1285669, -1285669,\n+            -1341330, - 1341330, -1315589, -1315589, 177440, 177440, 2409325, 2409325,\n+            1851402, 1851402, -3159746, -3159746, 3553272, 3553272, -189548, -189548,\n+            1316856, 1316856, -759969, -759969, 210977, 210977, -2389356, -2389356,\n+            3249728, 3249728, -1653064, -1653064, 8578, 8578, 3724342, 3724342,\n+            -3958618, -3958618, -904516, -904516, 1100098, 1100098, -44288, -44288,\n+            -3097992, -3097992, -508951, -508951, -264944, -264944, 3343383, 3343383,\n+            1430430, 1430430, -1852771, -1852771, -1349076, -1349076, 381987, 381987,\n+            1308169, 1308169, 22981, 22981, 1228525, 1228525, 671102, 671102,\n+            2477047, 2477047, 411027, 411027, 3693493, 3693493, 2967645, 2967645,\n+            -2715295, -2715295, -2147896, -2147896, 983419, 983419, -3412210, -3412210,\n+            -126922, -126922, 3632928, 3632928, 3157330, 3157330, 3190144, 3190144,\n+            1000202, 1000202, 4083598, 4083598, -1939314, -1939314, 1257611, 1257611,\n+            1585221, 1585221, -2176455, -2176455, -3475950, -3475950, 1452451, 1452451,\n+            3041255, 3041255, 3677745, 3677745, 1528703, 1528703, 3930395, 3930395,\n+\n+            2797779, 2797779, 2797779, 2797779, -2071892, -2071892, -2071892, -2071892,\n+            2556880, 2556880, 2556880, 2556880, -3900724, -3900724, -3900724, -3900724,\n+            -3881043, -3881043, -3881043, -3881043, -954230, -954230, -954230, -954230,\n+            -531354, -531354, -531354, -531354, -811944, -811944, -811944, -811944,\n+            -3699596, -3699596, -3699596, -3699596, 1600420, 1600420, 1600420, 1600420,\n+            2140649, 2140649, 2140649, 2140649, -3507263, -3507263, -3507263, -3507263,\n+            3821735, 3821735, 3821735, 3821735, -3505694, -3505694, -3505694, -3505694,\n+            1643818, 1643818, 1643818, 1643818, 1699267, 1699267, 1699267, 1699267,\n+            539299, 539299, 539299, 539299, -2348700, -2348700, -2348700, -2348700,\n+            300467, 300467, 300467, 300467, -3539968, -3539968, -3539968, -3539968,\n+            2867647, 2867647, 2867647, 2867647, -3574422, -3574422, -3574422, -3574422,\n+            3043716, 3043716, 3043716, 3043716, 3861115, 3861115, 3861115, 3861115,\n+            -3915439, -3915439, -3915439, -3915439, 2537516, 2537516, 2537516, 2537516,\n+            3592148, 3592148, 3592148, 3592148, 1661693, 1661693, 1661693, 1661693,\n+            -3530437, -3530437, -3530437, -3530437, -3077325, -3077325, -3077325, -3077325,\n+            -95776, -95776, -95776, -95776, -2706023, -2706023, -2706023, -2706023,\n+\n+            -280005, -280005, -280005, -280005, -280005, -280005, -280005, -280005,\n+            -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497,\n+            19422, 19422, 19422, 19422, 19422, 19422, 19422, 19422,\n+            -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237,\n+            3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672,\n+            1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561,\n+            3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737,\n+            2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186,\n+            2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549,\n+            -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752,\n+            1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584,\n+            549488, 549488, 549488, 549488, 549488, 549488, 549488, 549488,\n+            -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928,\n+            1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900,\n+            -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112,\n+            -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464,\n+\n+            -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+            -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+            -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+            -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+            2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+            2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+            -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+            -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+            2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+            2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+            359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+            359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+            -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+            -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+            -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+            -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847\n@@ -851,5 +1095,1 @@\n-    int[][][] generateA(byte[] seed) {\n-        int blockSize = 168;  \/\/ the size of one block of SHAKE128 output\n-        var xof = new SHAKE128(0);\n-        byte[] xofSeed = new byte[A_SEED_LEN + 2];\n-        System.arraycopy(seed, 0, xofSeed, 0, A_SEED_LEN);\n+    private int[][][] generateA(byte[] seed) {\n@@ -858,25 +1098,68 @@\n-        for (int i = 0; i < mlDsa_k; i++) {\n-            for (int j = 0; j < mlDsa_l; j++) {\n-                xofSeed[A_SEED_LEN] = (byte) j;\n-                xofSeed[A_SEED_LEN + 1] = (byte) i;\n-                xof.reset();\n-                xof.update(xofSeed);\n-\n-                byte[] rawAij = new byte[blockSize];\n-                int[] aij = new int[ML_DSA_N];\n-                int ofs = 0;\n-                int rawOfs = blockSize;\n-                int tmp;\n-                while (ofs < ML_DSA_N) {\n-                    if (rawOfs == blockSize) {\n-                        \/\/ works because 3 divides blockSize (=168)\n-                        xof.squeeze(rawAij, 0, blockSize);\n-                        rawOfs = 0;\n-                    }\n-                    tmp = (rawAij[rawOfs] & 0xFF) +\n-                            ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n-                            ((rawAij[rawOfs + 2] & 0x7F) << 16);\n-                    rawOfs += 3;\n-                    if (tmp < ML_DSA_Q) {\n-                        aij[ofs] = tmp;\n-                        ofs++;\n+        int nrPar = 2;\n+        int rhoLen = seed.length;\n+        byte[] seedBuf = new byte[SHAKE128_BLOCK_SIZE];\n+        System.arraycopy(seed, 0, seedBuf, 0, seed.length);\n+        seedBuf[rhoLen + 2] = 0x1F;\n+        seedBuf[SHAKE128_BLOCK_SIZE - 1] = (byte)0x80;\n+        byte[][] xofBufArr = new byte[nrPar][SHAKE128_BLOCK_SIZE];\n+        int[] iIndex = new int[nrPar];\n+        int[] jIndex = new int[nrPar];\n+\n+        int[] parsedBuf = new int[SHAKE128_BLOCK_SIZE \/ 3];\n+\n+        int parInd = 0;\n+        boolean allDone;\n+        int[] ofs = new int[nrPar];\n+        Arrays.fill(ofs, 0);\n+        int[][] aij = new int[nrPar][];\n+        try {\n+            Shake128Parallel parXof = new Shake128Parallel(xofBufArr);\n+\n+            for (int i = 0; i < mlDsa_k; i++) {\n+                for (int j = 0; j < mlDsa_l; j++) {\n+                    xofBufArr[parInd] = seedBuf.clone();\n+                    xofBufArr[parInd][rhoLen] = (byte) j;\n+                    xofBufArr[parInd][rhoLen + 1] = (byte) i;\n+                    iIndex[parInd] = i;\n+                    jIndex[parInd] = j;\n+                    ofs[parInd] = 0;\n+                    aij[parInd] = new int[ML_DSA_N];\n+                    parInd++;\n+\n+                    if ((parInd == nrPar) ||\n+                            ((i == mlDsa_k - 1) && (j == mlDsa_l - 1))) {\n+                        parXof.reset(xofBufArr);\n+\n+                        allDone = false;\n+                        while (!allDone) {\n+                            allDone = true;\n+                            parXof.squeezeBlock();\n+                            for (int k = 0; k < parInd; k++) {\n+                                int parsedOfs = 0;\n+                                int tmp;\n+                                if (ofs[k] < ML_DSA_N) {\n+                                    for (int l = 0; l < SHAKE128_BLOCK_SIZE; l += 3) {\n+                                        byte[] rawBuf = xofBufArr[k];\n+                                        parsedBuf[l \/ 3] = (rawBuf[l] & 0xFF) +\n+                                                ((rawBuf[l + 1] & 0xFF) << 8) +\n+                                                ((rawBuf[l + 2] & 0x7F) << 16);\n+                                    }\n+                                }\n+                                while ((ofs[k] < ML_DSA_N) &&\n+                                        (parsedOfs < SHAKE128_BLOCK_SIZE \/ 3)) {\n+                                    tmp = parsedBuf[parsedOfs++];\n+                                    if (tmp < ML_DSA_Q) {\n+                                        aij[k][ofs[k]] = tmp;\n+                                        ofs[k]++;\n+                                    }\n+                                }\n+                                if (ofs[k] < ML_DSA_N) {\n+                                    allDone = false;\n+                                }\n+                            }\n+                        }\n+\n+                        for (int k = 0; k < parInd; k++) {\n+                            a[iIndex[k]][jIndex[k]] = aij[k];\n+                        }\n+                        parInd = 0;\n@@ -885,1 +1168,0 @@\n-                a[i][j] = aij;\n@@ -887,0 +1169,3 @@\n+        } catch (InvalidAlgorithmParameterException e) {\n+            \/\/ This should never happen since xofBufArr is of the correct size\n+            throw new RuntimeException(\"Internal error.\");\n@@ -888,0 +1173,1 @@\n+\n@@ -982,1 +1268,1 @@\n-            ML_DSA.mlDsaDecomposePoly(input[i], lowPart[i],\n+            mlDsaDecomposePoly(input[i], lowPart[i],\n@@ -1014,1 +1300,1 @@\n-        int[][] lowPart = new int[mlDsa_k][ML_DSA_N];\n+        int[][] lowPart = r;\n@@ -1033,1 +1319,12 @@\n-    public static int[] mlDsaNtt(int[] coeffs) {\n+    public static void mlDsaNtt(int[] coeffs) {\n+        implDilithiumAlmostNtt(coeffs, MONT_ZETAS_FOR_VECTOR_NTT);\n+        implDilithiumMontMulByConstant(coeffs,  MONT_R_MOD_Q);\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implDilithiumAlmostNtt(int[] coeffs, int[] zetas) {\n+        implDilithiumAlmostNttJava(coeffs);\n+        return 1;\n+    }\n+\n+    static void implDilithiumAlmostNttJava(int[] coeffs) {\n@@ -1046,2 +1343,0 @@\n-        montMulByConstant(coeffs,  MONT_R_MOD_Q);\n-        return coeffs;\n@@ -1050,1 +1345,12 @@\n-    public static int[] mlDsaInverseNtt(int[] coeffs) {\n+    public static void mlDsaInverseNtt(int[] coeffs) {\n+        implDilithiumAlmostInverseNtt(coeffs, MONT_ZETAS_FOR_VECTOR_INVERSE_NTT);\n+        implDilithiumMontMulByConstant(coeffs, MONT_DIM_INVERSE);\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implDilithiumAlmostInverseNtt(int[] coeffs, int[] zetas) {\n+        implDilithiumAlmostInverseNttJava(coeffs);\n+        return 1;\n+    }\n+\n+    static void implDilithiumAlmostInverseNttJava(int[] coeffs) {\n@@ -1052,1 +1358,1 @@\n-        int m = 0;\n+        int m = MONT_ZETAS_FOR_NTT.length - 1;\n@@ -1059,1 +1365,1 @@\n-                            MONT_ZETAS_FOR_INVERSE_NTT[m]);\n+                            -MONT_ZETAS_FOR_NTT[m]);\n@@ -1061,1 +1367,1 @@\n-                m++;\n+                m--;\n@@ -1064,2 +1370,0 @@\n-        montMulByConstant(coeffs, MONT_DIM_INVERSE);\n-        return coeffs;\n@@ -1081,0 +1385,11 @@\n+        implDilithiumNttMult(product, coeffs1, coeffs2);\n+    }\n+\n+\n+    @IntrinsicCandidate\n+    static int implDilithiumNttMult(int[] product, int[] coeffs1, int[] coeffs2) {\n+        implDilithiumNttMultJava(product, coeffs1, coeffs2);\n+        return 1;\n+    }\n+\n+    static void implDilithiumNttMultJava(int[] product, int[] coeffs1, int[] coeffs2) {\n@@ -1086,1 +1401,7 @@\n-    public static void montMulByConstant(int[] coeffs, int constant) {\n+    @IntrinsicCandidate\n+    static int implDilithiumMontMulByConstant(int[] coeffs, int constant) {\n+        implDilithiumMontMulByConstantJava(coeffs, constant);\n+        return 1;\n+    }\n+\n+    static void implDilithiumMontMulByConstantJava(int[] coeffs, int constant) {\n@@ -1094,0 +1415,13 @@\n+        implDilithiumDecomposePoly(input, lowPart, highPart,twoGamma2, multiplier);\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implDilithiumDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n+                                          int twoGamma2, int multiplier) {\n+        decomposePolyJava(input, lowPart, highPart, twoGamma2, multiplier);\n+        return 1;\n+    }\n+\n+    static void decomposePolyJava(int[] input, int[] lowPart, int[] highPart,\n+                                 int twoGamma2, int multiplier) {\n+        int dilithiumBarrettAddend = 5373807;\n@@ -1096,5 +1430,12 @@\n-            rplus = rplus - ((rplus + 5373807) >> 23) * ML_DSA_Q;\n-            rplus = rplus + ((rplus >> 31) & ML_DSA_Q);\n-            int r0 = rplus - ((rplus * multiplier) >> 22) * twoGamma2;\n-            r0 -= (((twoGamma2 - r0) >> 22) & twoGamma2);\n-            r0 -= (((twoGamma2 \/ 2 - r0) >> 31) & twoGamma2);\n+            rplus -= ((rplus + dilithiumBarrettAddend) >> 23) * ML_DSA_Q;\n+            rplus += ((rplus >> 31) & ML_DSA_Q);\n+\n+            int quotient = (rplus * multiplier) >> 22;\n+            int r0 = rplus - quotient * twoGamma2;\n+            int mask = (twoGamma2 - r0) >> 22;\n+            r0 -= (mask & twoGamma2);\n+            quotient += (mask & 1);\n+            mask = (twoGamma2 \/ 2 - r0) >> 31;\n+            r0 -= (mask & twoGamma2);\n+            quotient += (mask & 1);\n+\n@@ -1102,1 +1443,1 @@\n-            r1 = (r1 | (-r1)) >> 31;\n+            r1 = (r1 | (-r1)) >> 31; \/\/ 0 if rplus - r0 == (dilithium_q - 1), -1 otherwise\n@@ -1104,1 +1445,3 @@\n-            r1 = r1 & ((rplus - r0) \/ twoGamma2);\n+            \/\/ quotient = (rplus - r0) \/ twoGamma2;\n+            r1 = r1 & quotient;\n+\n@@ -1210,0 +1553,1 @@\n+    \/\/ see e.g. Algorithm 3 in https:\/\/eprint.iacr.org\/2018\/039.pdf\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":428,"deletions":84,"binary":false,"changes":512,"status":"modified"},{"patch":"@@ -38,0 +38,14 @@\n+\/*\n+ * This class is for making it possible that NRPAR (= 2) (rather restricted)\n+ * SHAKE computations execute in parallel.\n+ * The restrictions are:\n+ *  1. The messages processed should be such that the absorb phase should\n+ * execute a single keccak() call and the byte arrays passed to the constructor\n+ * (or reset() method) of this class should be the message padded with the\n+ * appropriate padding described in\n+ * https:\/\/nvlpubs.nist.gov\/nistpubs\/fips\/nist.fips.202.pdf.\n+ *  2. The only available way for extracting data is the squeeze() method\n+ * that extracts exactly 1 block of data of each computation, delivering it\n+ * in the arrays that were passed to the class in the constructor (or the\n+ * reset() call).\n+ *\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3Parallel.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}