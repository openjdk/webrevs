{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import sun.security.provider.SHA3Parallel.Shake128Parallel;\n@@ -32,0 +33,1 @@\n+import java.security.InvalidAlgorithmParameterException;\n@@ -48,1 +50,1 @@\n-\n+    private static final int SHAKE128_BLOCK_SIZE = 168; \/\/ the block length for SHAKE128\n@@ -1093,5 +1095,1 @@\n-    int[][][] generateA(byte[] seed) {\n-        int blockSize = 168;  \/\/ the size of one block of SHAKE128 output\n-        var xof = new SHAKE128(0);\n-        byte[] xofSeed = new byte[A_SEED_LEN + 2];\n-        System.arraycopy(seed, 0, xofSeed, 0, A_SEED_LEN);\n+    private int[][][] generateA(byte[] seed) {\n@@ -1100,25 +1098,68 @@\n-        for (int i = 0; i < mlDsa_k; i++) {\n-            for (int j = 0; j < mlDsa_l; j++) {\n-                xofSeed[A_SEED_LEN] = (byte) j;\n-                xofSeed[A_SEED_LEN + 1] = (byte) i;\n-                xof.reset();\n-                xof.update(xofSeed);\n-\n-                byte[] rawAij = new byte[blockSize];\n-                int[] aij = new int[ML_DSA_N];\n-                int ofs = 0;\n-                int rawOfs = blockSize;\n-                int tmp;\n-                while (ofs < ML_DSA_N) {\n-                    if (rawOfs == blockSize) {\n-                        \/\/ works because 3 divides blockSize (=168)\n-                        xof.squeeze(rawAij, 0, blockSize);\n-                        rawOfs = 0;\n-                    }\n-                    tmp = (rawAij[rawOfs] & 0xFF) +\n-                            ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n-                            ((rawAij[rawOfs + 2] & 0x7F) << 16);\n-                    rawOfs += 3;\n-                    if (tmp < ML_DSA_Q) {\n-                        aij[ofs] = tmp;\n-                        ofs++;\n+        int nrPar = 2;\n+        int rhoLen = seed.length;\n+        byte[] seedBuf = new byte[SHAKE128_BLOCK_SIZE];\n+        System.arraycopy(seed, 0, seedBuf, 0, seed.length);\n+        seedBuf[rhoLen + 2] = 0x1F;\n+        seedBuf[SHAKE128_BLOCK_SIZE - 1] = (byte)0x80;\n+        byte[][] xofBufArr = new byte[nrPar][SHAKE128_BLOCK_SIZE];\n+        int[] iIndex = new int[nrPar];\n+        int[] jIndex = new int[nrPar];\n+\n+        int[] parsedBuf = new int[SHAKE128_BLOCK_SIZE \/ 3];\n+\n+        int parInd = 0;\n+        boolean allDone;\n+        int[] ofs = new int[nrPar];\n+        Arrays.fill(ofs, 0);\n+        int[][] aij = new int[nrPar][];\n+        try {\n+            Shake128Parallel parXof = new Shake128Parallel(xofBufArr);\n+\n+            for (int i = 0; i < mlDsa_k; i++) {\n+                for (int j = 0; j < mlDsa_l; j++) {\n+                    xofBufArr[parInd] = seedBuf.clone();\n+                    xofBufArr[parInd][rhoLen] = (byte) j;\n+                    xofBufArr[parInd][rhoLen + 1] = (byte) i;\n+                    iIndex[parInd] = i;\n+                    jIndex[parInd] = j;\n+                    ofs[parInd] = 0;\n+                    aij[parInd] = new int[ML_DSA_N];\n+                    parInd++;\n+\n+                    if ((parInd == nrPar) ||\n+                            ((i == mlDsa_k - 1) && (j == mlDsa_l - 1))) {\n+                        parXof.reset(xofBufArr);\n+\n+                        allDone = false;\n+                        while (!allDone) {\n+                            allDone = true;\n+                            parXof.squeezeBlock();\n+                            for (int k = 0; k < parInd; k++) {\n+                                int parsedOfs = 0;\n+                                int tmp;\n+                                if (ofs[k] < ML_DSA_N) {\n+                                    for (int l = 0; l < SHAKE128_BLOCK_SIZE; l += 3) {\n+                                        byte[] rawBuf = xofBufArr[k];\n+                                        parsedBuf[l \/ 3] = (rawBuf[l] & 0xFF) +\n+                                                ((rawBuf[l + 1] & 0xFF) << 8) +\n+                                                ((rawBuf[l + 2] & 0x7F) << 16);\n+                                    }\n+                                }\n+                                while ((ofs[k] < ML_DSA_N) &&\n+                                        (parsedOfs < SHAKE128_BLOCK_SIZE \/ 3)) {\n+                                    tmp = parsedBuf[parsedOfs++];\n+                                    if (tmp < ML_DSA_Q) {\n+                                        aij[k][ofs[k]] = tmp;\n+                                        ofs[k]++;\n+                                    }\n+                                }\n+                                if (ofs[k] < ML_DSA_N) {\n+                                    allDone = false;\n+                                }\n+                            }\n+                        }\n+\n+                        for (int k = 0; k < parInd; k++) {\n+                            a[iIndex[k]][jIndex[k]] = aij[k];\n+                        }\n+                        parInd = 0;\n@@ -1127,1 +1168,0 @@\n-                a[i][j] = aij;\n@@ -1129,0 +1169,3 @@\n+        } catch (InvalidAlgorithmParameterException e) {\n+            \/\/ This should never happen since xofBufArr is of the correct size\n+            throw new RuntimeException(\"Internal error.\");\n@@ -1130,0 +1173,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":76,"deletions":32,"binary":false,"changes":108,"status":"modified"}]}