{"files":[{"patch":"@@ -130,0 +130,20 @@\n+  \/\/ If the GC was cancelled just before final mark (but after the preceding cancellation check),\n+  \/\/ then the safepoint operation will do nothing and the concurrent mark will still be in progress.\n+  \/\/ In this case it is safe (and necessary) to resume the degenerated cycle from the marking phase.\n+  \/\/\n+  \/\/ On the other hand, if the GC is cancelled after final mark (but before this check), then the\n+  \/\/ final mark safepoint operation will have finished the mark (setting concurrent mark in progress\n+  \/\/ to false). In this case (final mark has completed), we need control to fall past the next\n+  \/\/ cancellation check and resume the degenerated cycle from the evacuation phase.\n+  if (heap->is_concurrent_mark_in_progress()) {\n+    \/\/ If the concurrent mark is still in progress after the final mark safepoint, then the GC has\n+    \/\/ been cancelled. The degenerated cycle must resume from the marking phase. Without this check,\n+    \/\/ the non-generational mode may fall all the way to the end of this collect routine without\n+    \/\/ having done anything (besides mark most of the heap). Without having collected anything, we\n+    \/\/ can expect an 'out of cycle' degenerated GC which will again mark the entire heap. This is\n+    \/\/ not optimal.\n+    bool cancelled = check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_mark);\n+    assert(cancelled, \"GC must have been cancelled between concurrent and final mark\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}