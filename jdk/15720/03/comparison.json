{"files":[{"patch":"@@ -1921,0 +1921,3 @@\n+  \/\/ clone_loop() above changes the exit projection\n+  main_exit = outer_main_end->proj_out(false);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1550,1 +1550,1 @@\n-  void sink_use( Node *use, Node *post_loop );\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2067,11 +2067,0 @@\n-\/\/------------------------------sink_use---------------------------------------\n-\/\/ If 'use' was in the loop-exit block, it now needs to be sunk\n-\/\/ below the post-loop merge point.\n-void PhaseIdealLoop::sink_use( Node *use, Node *post_loop ) {\n-  if (!use->is_CFG() && get_ctrl(use) == post_loop->in(2)) {\n-    set_ctrl(use, post_loop);\n-    for (DUIterator j = use->outs(); use->has_out(j); j++)\n-      sink_use(use->out(j), post_loop);\n-  }\n-}\n-\n@@ -2144,1 +2133,1 @@\n-      Node *cfg = prev->_idx >= new_counter\n+      Node* cfg = (prev->_idx >= new_counter && prev->is_Region())\n@@ -2168,1 +2157,1 @@\n-        cfg = cfg->_idx >= new_counter ? cfg->in(2) : idom(cfg);\n+        cfg = (cfg->_idx >= new_counter && cfg->is_Region()) ? cfg->in(2) : idom(cfg);\n@@ -2226,4 +2215,0 @@\n-\n-      \/\/ If 'use' was in the loop-exit block, it now needs to be sunk\n-      \/\/ below the post-loop merge point.\n-      sink_use( use, prev );\n@@ -2596,2 +2581,0 @@\n-        \/\/ Map the old use to the new merge point\n-        old_new.map( use->_idx, r );\n@@ -2633,0 +2616,9 @@\n+        assert(use->is_Proj(), \"loop exit should be projection\");\n+        \/\/ lazy_replace() below moves all nodes that are:\n+        \/\/ - control dependent on the loop exit or\n+        \/\/ - have control set to the loop exit\n+        \/\/ below the post-loop merge point. lazy_replace() takes a dead control as first input. To make it\n+        \/\/ possible to use it, the loop exit projection is cloned and becomes the new exit projection. The initial one\n+        \/\/ becomes dead and is \"replaced\" by the region.\n+        Node* use_clone = use->clone();\n+        register_control(use_clone, use_loop, idom(use), dom_depth(use));\n@@ -2635,1 +2627,1 @@\n-        r->set_req(2,    use);\n+        r->set_req(2, use_clone);\n@@ -2639,0 +2631,3 @@\n+        lazy_replace(use, r);\n+        \/\/ Map the (cloned) old use to the new merge point\n+        old_new.map(use_clone->_idx, r);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8315920\n+ * @summary C2: \"control input must dominate current control\" assert failure\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseLoopPredicate -XX:-DoEscapeAnalysis TestBadControlAfterPreMainPost\n+ *\/\n+\n+public class TestBadControlAfterPreMainPost {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array2 = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(1, array2);\n+        }\n+    }\n+\n+    private static int test(int j, int[] array2) {\n+        int[] array = new int[10];\n+        array[j] = 42;\n+        float f = 1;\n+        for (int i = 0; i < 100; i++) {\n+            for (int k = 0; k < 10; k++) {\n+            }\n+            f = f * 2;\n+        }\n+        int v = array[0];\n+        int i = 0;\n+        do {\n+            synchronized (new Object()) {\n+            }\n+            array2[i + v] = 42;\n+            i++;\n+        } while (i < 100);\n+        return (int)f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestBadControlAfterPreMainPost.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}