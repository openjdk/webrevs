{"files":[{"patch":"@@ -414,30 +414,0 @@\n-\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs.  Guaranteed never\n-\/\/ to be passed a TOP or BOTTOM type, these are filtered out by\n-\/\/ pre-check.\n-const Type *AddINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int lo = java_add(r0->_lo, r1->_lo);\n-  int hi = java_add(r0->_hi, r1->_hi);\n-  if( !(r0->is_con() && r1->is_con()) ) {\n-    \/\/ Not both constants, compute approximate result\n-    if( (r0->_lo & r1->_lo) < 0 && lo >= 0 ) {\n-      lo = min_jint; hi = max_jint; \/\/ Underflow on the low side\n-    }\n-    if( (~(r0->_hi | r1->_hi)) < 0 && hi < 0 ) {\n-      lo = min_jint; hi = max_jint; \/\/ Overflow on the high side\n-    }\n-    if( lo > hi ) {               \/\/ Handle overflow\n-      lo = min_jint; hi = max_jint;\n-    }\n-  } else {\n-    \/\/ both constants, compute precise result using 'lo' and 'hi'\n-    \/\/ Semantics define overflow and underflow for integer addition\n-    \/\/ as expected.  In particular: 0x80000000 + 0x80000000 --> 0x0\n-  }\n-  return TypeInt::make( lo, hi, MAX2(r0->_widen,r1->_widen) );\n-}\n-\n-\n@@ -462,20 +432,44 @@\n-\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs.  Guaranteed never\n-\/\/ to be passed a TOP or BOTTOM type, these are filtered out by\n-\/\/ pre-check.\n-const Type *AddLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-  jlong lo = java_add(r0->_lo, r1->_lo);\n-  jlong hi = java_add(r0->_hi, r1->_hi);\n-  if( !(r0->is_con() && r1->is_con()) ) {\n-    \/\/ Not both constants, compute approximate result\n-    if( (r0->_lo & r1->_lo) < 0 && lo >= 0 ) {\n-      lo =min_jlong; hi = max_jlong; \/\/ Underflow on the low side\n-    }\n-    if( (~(r0->_hi | r1->_hi)) < 0 && hi < 0 ) {\n-      lo = min_jlong; hi = max_jlong; \/\/ Overflow on the high side\n-    }\n-    if( lo > hi ) {               \/\/ Handle overflow\n-      lo = min_jlong; hi = max_jlong;\n+template <class CT>\n+static const Type* add_add_ring(const Type* t1, const Type* t2) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  constexpr juint W = sizeof(T) * 8;\n+  const CT* i1 = CT::cast(t1);\n+  const CT* i2 = CT::cast(t2);\n+\n+  T lo = U(i1->_lo) + U(i2->_lo);\n+  T hi = U(i1->_hi) + U(i2->_hi);\n+  bool lo_novf = i2->_lo < 0 && lo >= i1->_lo;\n+  bool hi_novf = i2->_hi < 0 && hi >= i1->_hi;\n+  bool lo_povf = i2->_lo > 0 && lo <= i1->_lo;\n+  bool hi_povf = i2->_hi > 0 && hi <= i1->_hi;\n+  if ((lo_novf && !hi_novf) || (hi_povf && !lo_povf)) {\n+    lo = std::numeric_limits<T>::min();\n+    hi = std::numeric_limits<T>::max();\n+  }\n+\n+  U ulo = i1->_ulo + i2->_ulo;\n+  U uhi = i1->_uhi + i2->_uhi;\n+  bool lo_uovf = ulo < i1->_ulo;\n+  bool hi_uovf = uhi < i1->_uhi;\n+  if (hi_uovf && !lo_uovf) {\n+    ulo = 0;\n+    uhi = std::numeric_limits<U>::max();\n+  }\n+\n+  U zeros = 0;\n+  U ones = 0;\n+  bool carry = false;\n+  bool no_carry = true;\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << i;\n+    jint min = ((i1->_ones & mask) != 0) + ((i2->_ones & mask) != 0) + carry;\n+    jint max = ((i1->_zeros & mask) == 0) + ((i2->_zeros & mask) == 0) + !no_carry;\n+    carry = min >= 2;\n+    no_carry = max < 2;\n+    if (min == max) {\n+      if ((min & 1) == 0) {\n+        zeros |= mask;\n+      } else {\n+        ones |= mask;\n+      }\n@@ -483,4 +477,0 @@\n-  } else {\n-    \/\/ both constants, compute precise result using 'lo' and 'hi'\n-    \/\/ Semantics define overflow and underflow for integer addition\n-    \/\/ as expected.  In particular: 0x80000000 + 0x80000000 --> 0x0\n@@ -488,1 +478,6 @@\n-  return TypeLong::make( lo, hi, MAX2(r0->_widen,r1->_widen) );\n+\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, MAX2(i1->_widen, i2->_widen));\n+}\n+\n+const Type* AddINode::add_ring(const Type* t1, const Type* t2) const {\n+  return add_add_ring<TypeInt>(t1, t2);\n@@ -491,0 +486,3 @@\n+const Type* AddLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return add_add_ring<TypeLong>(t1, t2);\n+}\n@@ -722,10 +720,0 @@\n-\/\/------------------------------Identity---------------------------------------\n-Node* OrINode::Identity(PhaseGVN* phase) {\n-  \/\/ x | x => x\n-  if (in(1) == in(2)) {\n-    return in(1);\n-  }\n-\n-  return AddNode::Identity(phase);\n-}\n-\n@@ -778,41 +766,0 @@\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs IN THE CURRENT RING.  For\n-\/\/ the logical operations the ring's ADD is really a logical OR function.\n-\/\/ This also type-checks the inputs for sanity.  Guaranteed never to\n-\/\/ be passed a TOP or BOTTOM type, these are filtered out by pre-check.\n-const Type *OrINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ If both args are bool, can figure out better types\n-  if ( r0 == TypeInt::BOOL ) {\n-    if ( r1 == TypeInt::ONE) {\n-      return TypeInt::ONE;\n-    } else if ( r1 == TypeInt::BOOL ) {\n-      return TypeInt::BOOL;\n-    }\n-  } else if ( r0 == TypeInt::ONE ) {\n-    if ( r1 == TypeInt::BOOL ) {\n-      return TypeInt::ONE;\n-    }\n-  }\n-\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeInt::INT;        \/\/ Any integer, but still no symbols.\n-\n-  \/\/ Otherwise just OR them bits.\n-  return TypeInt::make( r0->get_con() | r1->get_con() );\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* OrLNode::Identity(PhaseGVN* phase) {\n-  \/\/ x | x => x\n-  if (in(1) == in(2)) {\n-    return in(1);\n-  }\n-\n-  return AddNode::Identity(phase);\n-}\n-\n@@ -844,4 +791,66 @@\n-\/\/------------------------------add_ring---------------------------------------\n-const Type *OrLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n+template <class CT>\n+static Node* or_id(Node* n, PhaseGVN* phase) {\n+  Node* in1 = n->in(1);\n+  Node* in2 = n->in(2);\n+\n+  \/\/ x | x => x\n+  if (in1 == in2) {\n+    return in1;\n+  }\n+\n+  const CT* i1 = CT::try_cast(phase->type(in1));\n+  const CT* i2 = CT::try_cast(phase->type(in2));\n+  if (i1 == nullptr || i2 == nullptr) {\n+    return n;\n+  }\n+\n+  \/\/ If all set bits of x are set in y then return y\n+  if ((~i1->_zeros & ~i2->_ones) == 0) {\n+    return in2;\n+  }\n+  if ((~i2->_zeros & ~i1->_ones) == 0) {\n+    return in1;\n+  }\n+  return n;\n+}\n+\n+Node* OrINode::Identity(PhaseGVN* phase) {\n+  return or_id<TypeInt>(this, phase);\n+}\n+\n+Node* OrLNode::Identity(PhaseGVN* phase) {\n+  return or_id<TypeLong>(this, phase);\n+}\n+\n+template <class CT>\n+static const Type* or_add_ring(const Type* t1, const Type* t2) {\n+  using T = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+  const CT* i1 = CT::cast(t1);\n+  const CT* i2 = CT::cast(t2);\n+\n+  \/\/ Identity, if all set bits of x are set in y then return y\n+  if ((~i1->_zeros & ~i2->_ones) == 0) {\n+    return i2;\n+  }\n+  if ((~i2->_zeros & ~i1->_ones) == 0) {\n+    return i1;\n+  }\n+\n+  T lo = std::numeric_limits<T>::min();\n+  T hi = std::numeric_limits<T>::max();\n+  U ulo = MAX2(i1->_ulo, i2->_ulo);\n+  U uhi = std::numeric_limits<U>::max();\n+  U zeros = i1->_zeros & i2->_zeros;\n+  U ones = i1->_ones | i2->_ones;\n+  int w = MAX2(i1->_widen, i2->_widen);\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, w);\n+}\n+\n+template <class CT>\n+static const Type* or_value(const Node* in1, const Node* in2, PhaseGVN* phase) {\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -849,3 +858,10 @@\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ Any integer, but still no symbols.\n+  return or_add_ring<CT>(t1, t2);\n+}\n+\n+const Type* OrINode::Value(PhaseGVN* phase) const {\n+  return or_value<TypeInt>(in(1), in(2), phase);\n+}\n+\n+const Type* OrLNode::Value(PhaseGVN* phase) const {\n+  return or_value<TypeLong>(in(1), in(2), phase);\n+}\n@@ -853,2 +869,6 @@\n-  \/\/ Otherwise just OR them bits.\n-  return TypeLong::make( r0->get_con() | r1->get_con() );\n+const Type* OrINode::add_ring(const Type* t1, const Type* t2) const {\n+  return or_add_ring<TypeInt>(t1, t2);\n+}\n+\n+const Type* OrLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return or_add_ring<TypeLong>(t1, t2);\n@@ -871,1 +891,0 @@\n-\/\/------------------------------Idealize---------------------------------------\n@@ -921,64 +940,0 @@\n-const Type* XorINode::Value(PhaseGVN* phase) const {\n-  Node* in1 = in(1);\n-  Node* in2 = in(2);\n-  const Type* t1 = phase->type(in1);\n-  const Type* t2 = phase->type(in2);\n-  if (t1 == Type::TOP || t2 == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  \/\/ x ^ x ==> 0\n-  if (in1->eqv_uncast(in2)) {\n-    return add_id();\n-  }\n-  \/\/ result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-  const TypeInt* t1i = t1->is_int();\n-  const TypeInt* t2i = t2->is_int();\n-  if ((t1i->_lo >= 0) &&\n-      (t1i->_hi > 0)  &&\n-      (t2i->_lo >= 0) &&\n-      (t2i->_hi > 0)) {\n-    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n-    const TypeInt* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n-    const TypeInt* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n-    return t1x->meet(t2x);\n-  }\n-  return AddNode::Value(phase);\n-}\n-\n-\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs IN THE CURRENT RING.  For\n-\/\/ the logical operations the ring's ADD is really a logical OR function.\n-\/\/ This also type-checks the inputs for sanity.  Guaranteed never to\n-\/\/ be passed a TOP or BOTTOM type, these are filtered out by pre-check.\n-const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Complementing a boolean?\n-  if( r0 == TypeInt::BOOL && ( r1 == TypeInt::ONE\n-                               || r1 == TypeInt::BOOL))\n-    return TypeInt::BOOL;\n-\n-  if( !r0->is_con() || !r1->is_con() ) \/\/ Not constants\n-    return TypeInt::INT;        \/\/ Any integer, but still no symbols.\n-\n-  \/\/ Otherwise just XOR them bits.\n-  return TypeInt::make( r0->get_con() ^ r1->get_con() );\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------add_ring---------------------------------------\n-const Type *XorLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ Any integer, but still no symbols.\n-\n-  \/\/ Otherwise just OR them bits.\n-  return TypeLong::make( r0->get_con() ^ r1->get_con() );\n-}\n-\n@@ -1006,3 +961,16 @@\n-const Type* XorLNode::Value(PhaseGVN* phase) const {\n-  Node* in1 = in(1);\n-  Node* in2 = in(2);\n+template <class CT>\n+static const Type* xor_add_ring(const Type* t1, const Type* t2) {\n+  using T = decltype(CT::_lo);\n+  const CT* i1 = CT::cast(t1);\n+  const CT* i2 = CT::cast(t2);\n+  const Type* res = CT::make_bits((i1->_zeros & i2->_zeros) | (i1->_ones & i2->_ones),\n+                                  (i1->_zeros & i2->_ones) | (i1->_ones & i2->_zeros), MAX2(i1->_widen, i2->_widen));\n+  \/\/ If inputs do not overlap, result cannot be 0\n+  if (CT::cast(res)->contains(T(0)) && i1->filter(i2) == Type::TOP) {\n+    res = res->filter(CT::NON_ZERO);\n+  }\n+  return res;\n+}\n+\n+template <class CT>\n+static const Type* xor_value(const Node* in1, const Node* in2, PhaseGVN* phase) {\n@@ -1014,1 +982,1 @@\n-  \/\/ x ^ x ==> 0\n+\n@@ -1016,14 +984,1 @@\n-    return add_id();\n-  }\n-  \/\/ result of xor can only have bits sets where any of the\n-  \/\/ inputs have bits set. lo can always become 0.\n-  const TypeLong* t1l = t1->is_long();\n-  const TypeLong* t2l = t2->is_long();\n-  if ((t1l->_lo >= 0) &&\n-      (t1l->_hi > 0)  &&\n-      (t2l->_lo >= 0) &&\n-      (t2l->_hi > 0)) {\n-    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n-    const TypeLong* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n-    const TypeLong* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n-    return t1x->meet(t2x);\n+    return CT::ZERO;\n@@ -1031,1 +986,18 @@\n-  return AddNode::Value(phase);\n+\n+  return xor_add_ring<CT>(t1, t2);\n+}\n+\n+const Type* XorINode::Value(PhaseGVN* phase) const {\n+  return xor_value<TypeInt>(in(1), in(2), phase);\n+}\n+\n+const Type* XorLNode::Value(PhaseGVN* phase) const {\n+  return xor_value<TypeLong>(in(1), in(2), phase);\n+}\n+\n+const Type* XorINode::add_ring(const Type* t1, const Type* t2) const {\n+  return xor_add_ring<TypeInt>(t1, t2);\n+}\n+\n+const Type* XorLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return xor_add_ring<TypeLong>(t1, t2);\n@@ -1034,0 +1006,1 @@\n+\/\/=============================================================================\n@@ -1209,11 +1182,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs.\n-const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Otherwise just MAX them bits.\n-  return TypeInt::make( MAX2(r0->_lo,r1->_lo), MAX2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n-}\n-\n@@ -1228,10 +1190,0 @@\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs.\n-const Type *MinINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Otherwise just MIN them bits.\n-  return TypeInt::make( MIN2(r0->_lo,r1->_lo), MIN2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n-}\n-\n@@ -1306,7 +1258,0 @@\n-const Type* MaxLNode::add_ring(const Type* t0, const Type* t1) const {\n-  const TypeLong* r0 = t0->is_long();\n-  const TypeLong* r1 = t1->is_long();\n-\n-  return TypeLong::make(MAX2(r0->_lo, r1->_lo), MAX2(r0->_hi, r1->_hi), MAX2(r0->_widen, r1->_widen));\n-}\n-\n@@ -1338,7 +1283,0 @@\n-const Type* MinLNode::add_ring(const Type* t0, const Type* t1) const {\n-  const TypeLong* r0 = t0->is_long();\n-  const TypeLong* r1 = t1->is_long();\n-\n-  return TypeLong::make(MIN2(r0->_lo, r1->_lo), MIN2(r0->_hi, r1->_hi), MIN2(r0->_widen, r1->_widen));\n-}\n-\n@@ -1370,0 +1308,33 @@\n+template <class CT, bool is_max>\n+static const Type* minmax_add_ring(const Type* t1, const Type* t2) {\n+  using T = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+  const CT* i1 = CT::cast(t1);\n+  const CT* i2 = CT::cast(t2);\n+\n+  T lo = is_max ? MAX2(i1->_lo, i2->_lo) : MIN2(i1->_lo, i2->_lo);\n+  T hi = is_max ? MAX2(i1->_hi, i2->_hi) : MIN2(i1->_hi, i2->_hi);\n+  U ulo = MIN2(i1->_ulo, i2->_ulo);\n+  U uhi = MAX2(i1->_uhi, i2->_uhi);\n+  U zeros = i1->_zeros & i2->_zeros;\n+  U ones = i1->_ones & i2->_ones;\n+\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, MAX2(i1->_widen, i2->_widen));\n+}\n+\n+const Type* MinINode::add_ring(const Type* t1, const Type* t2) const {\n+  return minmax_add_ring<TypeInt, false>(t1, t2);\n+}\n+\n+const Type* MinLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return minmax_add_ring<TypeLong, false>(t1, t2);\n+}\n+\n+const Type* MaxINode::add_ring(const Type* t1, const Type* t2) const {\n+  return minmax_add_ring<TypeInt, true>(t1, t2);\n+}\n+\n+const Type* MaxLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return minmax_add_ring<TypeLong, true>(t1, t2);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":205,"deletions":234,"binary":false,"changes":439,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  OrINode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}\n+  OrINode(Node* in1, Node* in2) : AddNode(in1, in2) {}\n@@ -190,3 +190,6 @@\n-  virtual const Type *add_ring( const Type *, const Type * ) const;\n-  virtual const Type *add_id() const { return TypeInt::ZERO; }\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* add_ring(const Type* t1, const Type* t2) const;\n+  virtual const Type* add_id() const { return TypeInt::ZERO; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -195,1 +198,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n@@ -197,1 +199,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -207,3 +208,6 @@\n-  virtual const Type *add_ring( const Type *, const Type * ) const;\n-  virtual const Type *add_id() const { return TypeLong::ZERO; }\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* add_ring(const Type* t1, const Type* t2) const;\n+  virtual const Type* add_id() const { return TypeLong::ZERO; }\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n@@ -212,1 +216,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n@@ -214,1 +217,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -221,1 +223,1 @@\n-  XorINode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}\n+  XorINode(Node* in1, Node* in2) : AddNode(in1, in2) {}\n@@ -223,4 +225,5 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *add_ring( const Type *, const Type * ) const;\n-  virtual const Type *add_id() const { return TypeInt::ZERO; }\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* add_ring(const Type* t1, const Type* t2) const;\n+  virtual const Type* add_id() const { return TypeInt::ZERO; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -229,1 +232,0 @@\n-  virtual const Type *Value(PhaseGVN *phase) const;\n@@ -237,1 +239,1 @@\n-  XorLNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}\n+  XorLNode(Node* in1, Node* in2) : AddNode(in1, in2) {}\n@@ -239,4 +241,5 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *add_ring( const Type *, const Type * ) const;\n-  virtual const Type *add_id() const { return TypeLong::ZERO; }\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* add_ring(const Type* t1, const Type* t2) const;\n+  virtual const Type* add_id() const { return TypeLong::ZERO; }\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n@@ -245,1 +248,0 @@\n-  virtual const Type *Value(PhaseGVN *phase) const;\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -215,0 +215,23 @@\n+\/\/ Similar to ConvI2LNode::Value() for the same reasons\n+\/\/ see if we can remove type assertion after loop opts\n+template <class CT>\n+static const Type* widen_type_after_loop_opts(const CT* t, const CT* t1, const PhaseGVN* phase) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+\n+  if (!phase->C->post_loop_opts_phase()) {\n+    return t;\n+  }\n+\n+  assert(t1->contains(t), \"\");\n+  if (t1->properly_contains(t)) {\n+    T lo = t->_lo >= 0 ? 0 : std::numeric_limits<T>::min();\n+    T hi = t->_hi < 0 ? -1 : std::numeric_limits<T>::max();\n+    return CT::make(MAX2(t1->_lo, lo),\n+                    MIN2(t1->_hi, hi),\n+                    t1->_ulo, t1->_uhi, t1->_zeros, t1->_ones,\n+                    MAX2(t1->_widen, t->_widen));\n+  }\n+\n+  return t;\n+}\n+\n@@ -222,3 +245,0 @@\n-  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n-  \/\/ see if we can remove type assertion after loop opts\n-  \/\/ But here we have to pay extra attention:\n@@ -229,1 +249,1 @@\n-    res = widen_type(phase, res, T_INT);\n+    res = widen_type_after_loop_opts(res->is_int(), phase->type(in(1))->is_int(), phase);\n@@ -372,1 +392,1 @@\n-  return widen_type(phase, res, T_LONG);\n+  return res = widen_type_after_loop_opts(res->is_long(), phase->type(in(1))->is_long(), phase);\n@@ -393,2 +413,1 @@\n-      assert(tl->_lo >= t_in_l->_lo && tl->_hi <= t_in_l->_hi, \"CastLL type should be narrower than or equal to the type of its input\");\n-      assert((tl != t_in_l) == (tl->_lo > t_in_l->_lo || tl->_hi < t_in_l->_hi), \"if type differs then this nodes's type must be narrower\");\n+      assert(t_in_l->contains(tl), \"CastLL type should be narrower than or equal to the type of its input\");\n@@ -396,1 +415,2 @@\n-        const TypeInt* ti = TypeInt::make(checked_cast<jint>(tl->_lo), checked_cast<jint>(tl->_hi), tl->_widen);\n+        assert(t_in_l->properly_contains(tl), \"if type differs then this nodes's type must be narrower\");\n+        const TypeInt* ti = TypeInt::make(checked_cast<jint>(tl->_lo), checked_cast<jint>(tl->_hi), tl->_widen)->is_int();\n@@ -547,1 +567,5 @@\n-  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  const TypeInteger* this_type = this->type()->isa_integer(bt);\n+  if (this_type == nullptr) {\n+    return nullptr;\n+  }\n+\n@@ -575,28 +599,0 @@\n-\n-const Type* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n-  if (!phase->C->post_loop_opts_phase()) {\n-    return res;\n-  }\n-  const TypeInteger* this_type = res->is_integer(bt);\n-  const TypeInteger* in_type = phase->type(in(1))->isa_integer(bt);\n-  if (in_type != nullptr &&\n-      (in_type->lo_as_long() != this_type->lo_as_long() ||\n-       in_type->hi_as_long() != this_type->hi_as_long())) {\n-    jlong lo1 = this_type->lo_as_long();\n-    jlong hi1 = this_type->hi_as_long();\n-    int w1 = this_type->_widen;\n-    if (lo1 >= 0) {\n-      \/\/ Keep a range assertion of >=0.\n-      lo1 = 0;        hi1 = max_signed_integer(bt);\n-    } else if (hi1 < 0) {\n-      \/\/ Keep a range assertion of <0.\n-      lo1 = min_signed_integer(bt); hi1 = -1;\n-    } else {\n-      lo1 = min_signed_integer(bt); hi1 = max_signed_integer(bt);\n-    }\n-    return TypeInteger::make(MAX2(in_type->lo_as_long(), lo1),\n-                             MIN2(in_type->hi_as_long(), hi1),\n-                             MAX2((int)in_type->_widen, w1), bt);\n-  }\n-  return res;\n-}\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":33,"deletions":37,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  const Type* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4427,2 +4427,4 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n-  const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax);\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n+  const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax)->is_int();\n@@ -4446,1 +4448,1 @@\n-  const TypeLong* ltype = TypeLong::make(itype->_lo, itype->_hi, itype->_widen);\n+  const TypeLong* ltype = TypeLong::make(itype->_lo, itype->_hi, itype->_widen)->is_long();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -308,2 +308,2 @@\n-  const Type *t = phase->type( in(1) );\n-  if (t == Type::TOP) {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) {\n@@ -312,2 +312,3 @@\n-  const TypeInt *ti = t->is_int();\n-  const Type* tl = TypeLong::make(ti->_lo, ti->_hi, ti->_widen);\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeLong* before = TypeLong::make(i1->_lo, i1->_hi, jlong(jint(i1->_ulo)), jlong(jint(i1->_uhi)),\n+                                          i1->_zeros, i1->_ones, i1->_widen)->is_long();;\n@@ -315,3 +316,4 @@\n-  tl = tl->filter(_type);\n-  if (!tl->isa_long()) {\n-    return tl;\n+  const Type* t = before->filter(_type);\n+  const TypeLong* after = t->isa_long();\n+  if (after == nullptr) {\n+    return t;\n@@ -319,1 +321,1 @@\n-  const TypeLong* this_type = tl->is_long();\n+\n@@ -321,27 +323,16 @@\n-  if (phase->C->post_loop_opts_phase()) {\n-    const TypeInt* in_type = phase->type(in(1))->isa_int();\n-    if (in_type != nullptr &&\n-        (in_type->_lo != this_type->_lo ||\n-         in_type->_hi != this_type->_hi)) {\n-      \/\/ Although this WORSENS the type, it increases GVN opportunities,\n-      \/\/ because I2L nodes with the same input will common up, regardless\n-      \/\/ of slightly differing type assertions.  Such slight differences\n-      \/\/ arise routinely as a result of loop unrolling, so this is a\n-      \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n-      \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n-      jlong lo1 = this_type->_lo;\n-      jlong hi1 = this_type->_hi;\n-      int   w1  = this_type->_widen;\n-      if (lo1 >= 0) {\n-        \/\/ Keep a range assertion of >=0.\n-        lo1 = 0;        hi1 = max_jint;\n-      } else if (hi1 < 0) {\n-        \/\/ Keep a range assertion of <0.\n-        lo1 = min_jint; hi1 = -1;\n-      } else {\n-        lo1 = min_jint; hi1 = max_jint;\n-      }\n-      return TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n-                            MIN2((jlong)in_type->_hi, hi1),\n-                            MAX2((int)in_type->_widen, w1));\n-    }\n+  if (!phase->C->post_loop_opts_phase()) {\n+    return after;\n+  }\n+\n+  assert(before->contains(after), \"\");\n+  if (before->properly_contains(after)) {\n+    \/\/ Although this WORSENS the type, it increases GVN opportunities,\n+    \/\/ because I2L nodes with the same input will common up, regardless\n+    \/\/ of slightly differing type assertions.  Such slight differences\n+    \/\/ arise routinely as a result of loop unrolling, so this is a\n+    \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n+    \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n+    jlong lo = (after->_lo >= 0) ? 0 : min_jint;\n+    jlong hi = (after->_hi < 0) ? -1 : max_jint;\n+    return TypeLong::make(MAX2(lo, before->_lo), MIN2(hi, before->_hi), before->_ulo, before->_uhi,\n+                          before->_zeros, before->_ones, MAX2(before->_widen, after->_widen));\n@@ -349,1 +340,2 @@\n-  return this_type;\n+\n+  return after;\n@@ -601,2 +593,3 @@\n-  rx = TypeInteger::make(rxlo, rxhi, widen, out_bt);\n-  ry = TypeInteger::make(rylo, ryhi, widen, out_bt);\n+  assert(rxlo <= rxhi && rylo <= ryhi, \"\");\n+  rx = TypeInteger::make(rxlo, rxhi, widen, out_bt)->is_integer(out_bt);\n+  ry = TypeInteger::make(rylo, ryhi, widen, out_bt)->is_integer(out_bt);\n@@ -736,9 +729,3 @@\n-  const Type *t = phase->type( in(1) );\n-  if( t == Type::TOP ) return Type::TOP;\n-  const TypeLong *tl = t->is_long();\n-  const TypeInt* ti = TypeInt::INT;\n-  if (tl->is_con()) {\n-    \/\/ Easy case.\n-    ti = TypeInt::make((jint)tl->get_con());\n-  } else if (tl->_lo >= min_jint && tl->_hi <= max_jint) {\n-    ti = TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n@@ -746,1 +733,41 @@\n-  return ti->filter(_type);\n+  const TypeLong* i1 = t1->is_long();\n+\n+  auto cast_range = [](jint& lo, jint& hi, juint& ulo, juint& uhi, julong min, julong max) {\n+    lo = min;\n+    hi = max;\n+    ulo = min;\n+    uhi = max;\n+    if (julong(jlong(lo)) - min != julong(jlong(hi)) - max) {\n+      lo = min_jint;\n+      hi = max_jint;\n+    }\n+    if (julong(ulo) - min != julong(uhi) - max) {\n+      ulo = 0;\n+      uhi = max_juint;\n+    }\n+  };\n+\n+  jint lo;\n+  jint hi;\n+  juint ulo;\n+  juint uhi;\n+  if (i1->_lo == jlong(i1->_ulo)) {\n+    cast_range(lo, hi, ulo, uhi, i1->_ulo, i1->_uhi);\n+  } else {\n+    \/\/ Analyze 2 intervals [lo, uhi] and [ulo, hi] separately and union the results\n+    jint lo1, hi1;\n+    juint ulo1, uhi1;\n+    cast_range(lo1, hi1, ulo1, uhi1, i1->_lo, i1->_uhi);\n+\n+    jint lo2, hi2;\n+    juint ulo2, uhi2;\n+    cast_range(lo2, hi2, ulo2, uhi2, i1->_ulo, i1->_hi);\n+\n+    lo = MIN2(lo1, lo2);\n+    hi = MAX2(hi1, hi2);\n+    ulo = MIN2(ulo1, ulo2);\n+    uhi = MAX2(uhi1, uhi2);\n+  }\n+\n+  const Type* t = TypeInt::make(lo, hi, ulo, uhi, i1->_zeros, i1->_ones, i1->_widen);\n+  return t->filter(_type);\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":75,"deletions":48,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <limits>\n@@ -31,18 +32,8 @@\n-\/\/------------------------------Value------------------------------------------\n-const Type* CountLeadingZerosINode::Value(PhaseGVN* phase) const {\n-  const Type* t = phase->type(in(1));\n-  if (t == Type::TOP) return Type::TOP;\n-  const TypeInt* ti = t->isa_int();\n-  if (ti && ti->is_con()) {\n-    jint i = ti->get_con();\n-    \/\/ HD, Figure 5-6\n-    if (i == 0)\n-    return TypeInt::make(BitsPerInt);\n-    int n = 1;\n-    unsigned int x = i;\n-    if (x >> 16 == 0) { n += 16; x <<= 16; }\n-    if (x >> 24 == 0) { n +=  8; x <<=  8; }\n-    if (x >> 28 == 0) { n +=  4; x <<=  4; }\n-    if (x >> 30 == 0) { n +=  2; x <<=  2; }\n-    n -= x >> 31;\n-    return TypeInt::make(n);\n+template <class CT>\n+const Type* clz_value(const Node* in, PhaseGVN* phase) {\n+  using U = decltype(CT::_ulo);\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  const Type* t = phase->type(in);\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n@@ -50,1 +41,9 @@\n-  return TypeInt::INT;\n+\n+  const CT* i = CT::cast(t);\n+  juint lo = (~i->_zeros) == 0 ? W : count_leading_zeros(~i->_zeros);\n+  juint hi = i->_ones == 0 ? W : count_leading_zeros(i->_ones);\n+  return TypeInt::make(lo, hi, i->_widen);\n+}\n+\n+const Type* CountLeadingZerosINode::Value(PhaseGVN* phase) const {\n+  return clz_value<TypeInt>(in(1), phase);\n@@ -53,1 +52,0 @@\n-\/\/------------------------------Value------------------------------------------\n@@ -55,17 +53,11 @@\n-  const Type* t = phase->type(in(1));\n-  if (t == Type::TOP) return Type::TOP;\n-  const TypeLong* tl = t->isa_long();\n-  if (tl && tl->is_con()) {\n-    jlong l = tl->get_con();\n-    \/\/ HD, Figure 5-6\n-    if (l == 0)\n-    return TypeInt::make(BitsPerLong);\n-    int n = 1;\n-    unsigned int x = (((julong) l) >> 32);\n-    if (x == 0) { n += 32; x = (int) l; }\n-    if (x >> 16 == 0) { n += 16; x <<= 16; }\n-    if (x >> 24 == 0) { n +=  8; x <<=  8; }\n-    if (x >> 28 == 0) { n +=  4; x <<=  4; }\n-    if (x >> 30 == 0) { n +=  2; x <<=  2; }\n-    n -= x >> 31;\n-    return TypeInt::make(n);\n+  return clz_value<TypeLong>(in(1), phase);\n+}\n+\n+template <class CT>\n+const Type* ctz_value(const Node* in, PhaseGVN* phase) {\n+  using U = decltype(CT::_ulo);\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  const Type* t = phase->type(in);\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n@@ -73,1 +65,5 @@\n-  return TypeInt::INT;\n+\n+  const CT* i = CT::cast(t);\n+  juint lo = (~i->_zeros) == 0 ? W : count_trailing_zeros(~i->_zeros);\n+  juint hi = i->_ones == 0 ? W : count_trailing_zeros(i->_ones);\n+  return TypeInt::make(lo, hi, i->_widen);\n@@ -76,1 +72,0 @@\n-\/\/------------------------------Value------------------------------------------\n@@ -78,18 +73,1 @@\n-  const Type* t = phase->type(in(1));\n-  if (t == Type::TOP) return Type::TOP;\n-  const TypeInt* ti = t->isa_int();\n-  if (ti && ti->is_con()) {\n-    jint i = ti->get_con();\n-    \/\/ HD, Figure 5-14\n-    int y;\n-    if (i == 0)\n-    return TypeInt::make(BitsPerInt);\n-    int n = 31;\n-    y = i << 16; if (y != 0) { n = n - 16; i = y; }\n-    y = i <<  8; if (y != 0) { n = n -  8; i = y; }\n-    y = i <<  4; if (y != 0) { n = n -  4; i = y; }\n-    y = i <<  2; if (y != 0) { n = n -  2; i = y; }\n-    y = i <<  1; if (y != 0) { n = n -  1; }\n-    return TypeInt::make(n);\n-  }\n-  return TypeInt::INT;\n+  return ctz_value<TypeInt>(in(1), phase);\n@@ -98,1 +76,0 @@\n-\/\/------------------------------Value------------------------------------------\n@@ -100,17 +77,8 @@\n-  const Type* t = phase->type(in(1));\n-  if (t == Type::TOP) return Type::TOP;\n-  const TypeLong* tl = t->isa_long();\n-  if (tl && tl->is_con()) {\n-    jlong l = tl->get_con();\n-    \/\/ HD, Figure 5-14\n-    int x, y;\n-    if (l == 0)\n-    return TypeInt::make(BitsPerLong);\n-    int n = 63;\n-    y = (int) l; if (y != 0) { n = n - 32; x = y; } else x = (((julong) l) >> 32);\n-    y = x << 16; if (y != 0) { n = n - 16; x = y; }\n-    y = x <<  8; if (y != 0) { n = n -  8; x = y; }\n-    y = x <<  4; if (y != 0) { n = n -  4; x = y; }\n-    y = x <<  2; if (y != 0) { n = n -  2; x = y; }\n-    y = x <<  1; if (y != 0) { n = n -  1; }\n-    return TypeInt::make(n);\n+  return ctz_value<TypeLong>(in(1), phase);\n+}\n+\n+template <class CT>\n+const Type* popcnt_value(const Node* in, PhaseGVN* phase) {\n+  const Type* t = phase->type(in);\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n@@ -118,1 +86,11 @@\n-  return TypeInt::INT;\n+\n+  const CT* i = CT::cast(t);\n+  return TypeInt::make(population_count(i->_ones), population_count(~i->_zeros), i->_widen);\n+}\n+\n+const Type* PopCountINode::Value(PhaseGVN* phase) const {\n+  return popcnt_value<TypeInt>(in(1), phase);\n+}\n+\n+const Type* PopCountLNode::Value(PhaseGVN* phase) const {\n+  return popcnt_value<TypeLong>(in(1), phase);\n","filename":"src\/hotspot\/share\/opto\/countbitsnode.cpp","additions":54,"deletions":76,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -91,0 +92,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/countbitsnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3822,2 +3822,4 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n-      const TypeInt* tlcon = TypeInt::make(0, size_max, Type::WidenMin);\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n+      const TypeInt* tlcon = TypeInt::make(0, size_max, Type::WidenMin)->is_int();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);\n+                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen)->is_int();\n@@ -640,1 +640,1 @@\n-                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);\n+                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen)->is_int();\n@@ -670,1 +670,1 @@\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n+            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen)->is_int();\n@@ -1010,2 +1010,1 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->_lo > failtype->_hi) {\n+        if (failtype->filter(type2) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -829,1 +829,1 @@\n-      idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type->_widen);\n+      idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type->_widen)->is_int();\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax);\n+  const TypeLong* lidxtype = TypeLong::make(CONST64(0), index_max, Type::WidenMax)->is_long();\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,78 +528,0 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Supplied function returns the product of the inputs IN THE CURRENT RING.\n-\/\/ For the logical operations the ring's MUL is really a logical AND function.\n-\/\/ This also type-checks the inputs for sanity.  Guaranteed never to\n-\/\/ be passed a TOP or BOTTOM type, these are filtered out by pre-check.\n-const Type *AndINode::mul_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeInt::INT;        \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeInt::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeInt::make(0, r0->get_con(), widen);\n-\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeInt::make(0, r1->get_con(), widen);\n-\n-  if( r0 == TypeInt::BOOL || r1 == TypeInt::BOOL ) {\n-    return TypeInt::BOOL;\n-  }\n-\n-  return TypeInt::INT;          \/\/ No constants to be had\n-}\n-\n-const Type* AndINode::Value(PhaseGVN* phase) const {\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n-    return TypeInt::ZERO;\n-  }\n-\n-  return MulNode::Value(phase);\n-}\n-\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ Masking off the high bits of an unsigned load is not required\n-Node* AndINode::Identity(PhaseGVN* phase) {\n-\n-  \/\/ x & x => x\n-  if (in(1) == in(2)) {\n-    return in(1);\n-  }\n-\n-  Node* in1 = in(1);\n-  uint op = in1->Opcode();\n-  const TypeInt* t2 = phase->type(in(2))->isa_int();\n-  if (t2 && t2->is_con()) {\n-    int con = t2->get_con();\n-    \/\/ Masking off high bits which are always zero is useless.\n-    const TypeInt* t1 = phase->type(in(1))->isa_int();\n-    if (t1 != nullptr && t1->_lo >= 0) {\n-      jint t1_support = right_n_bits(1 + log2i_graceful(t1->_hi));\n-      if ((t1_support & con) == t1_support)\n-        return in1;\n-    }\n-    \/\/ Masking off the high bits of a unsigned-shift-right is not\n-    \/\/ needed either.\n-    if (op == Op_URShiftI) {\n-      const TypeInt* t12 = phase->type(in1->in(2))->isa_int();\n-      if (t12 && t12->is_con()) {  \/\/ Shift is by a constant\n-        int shift = t12->get_con();\n-        shift &= BitsPerJavaInteger - 1;  \/\/ semantics of Java shifts\n-        int mask = max_juint >> shift;\n-        if ((mask & con) == mask)  \/\/ If AND is useless, skip it\n-          return in1;\n-      }\n-    }\n-  }\n-  return MulNode::Identity(phase);\n-}\n-\n-\/\/------------------------------Ideal------------------------------------------\n@@ -670,76 +592,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Supplied function returns the product of the inputs IN THE CURRENT RING.\n-\/\/ For the logical operations the ring's MUL is really a logical AND function.\n-\/\/ This also type-checks the inputs for sanity.  Guaranteed never to\n-\/\/ be passed a TOP or BOTTOM type, these are filtered out by pre-check.\n-const Type *AndLNode::mul_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeLong::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r0->get_con(), widen);\n-\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r1->get_con(), widen);\n-\n-  return TypeLong::LONG;        \/\/ No constants to be had\n-}\n-\n-const Type* AndLNode::Value(PhaseGVN* phase) const {\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_LONG, true)) {\n-    return TypeLong::ZERO;\n-  }\n-\n-  return MulNode::Value(phase);\n-}\n-\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ Masking off the high bits of an unsigned load is not required\n-Node* AndLNode::Identity(PhaseGVN* phase) {\n-\n-  \/\/ x & x => x\n-  if (in(1) == in(2)) {\n-    return in(1);\n-  }\n-\n-  Node *usr = in(1);\n-  const TypeLong *t2 = phase->type( in(2) )->isa_long();\n-  if( t2 && t2->is_con() ) {\n-    jlong con = t2->get_con();\n-    \/\/ Masking off high bits which are always zero is useless.\n-    const TypeLong* t1 = phase->type( in(1) )->isa_long();\n-    if (t1 != nullptr && t1->_lo >= 0) {\n-      int bit_count = log2i_graceful(t1->_hi) + 1;\n-      jlong t1_support = jlong(max_julong >> (BitsPerJavaLong - bit_count));\n-      if ((t1_support & con) == t1_support)\n-        return usr;\n-    }\n-    uint lop = usr->Opcode();\n-    \/\/ Masking off the high bits of a unsigned-shift-right is not\n-    \/\/ needed either.\n-    if( lop == Op_URShiftL ) {\n-      const TypeInt *t12 = phase->type( usr->in(2) )->isa_int();\n-      if( t12 && t12->is_con() ) {  \/\/ Shift is by a constant\n-        int shift = t12->get_con();\n-        shift &= BitsPerJavaLong - 1;  \/\/ semantics of Java shifts\n-        jlong mask = max_julong >> shift;\n-        if( (mask&con) == mask )  \/\/ If AND is useless, skip it\n-          return usr;\n-      }\n-    }\n-  }\n-  return MulNode::Identity(phase);\n-}\n-\n-\/\/------------------------------Ideal------------------------------------------\n@@ -792,0 +638,88 @@\n+template <class CT>\n+static Node* and_id(Node* n, PhaseGVN* phase) {\n+  Node* in1 = n->in(1);\n+  Node* in2 = n->in(2);\n+\n+  \/\/ x | x => x\n+  if (in1 == in2) {\n+    return in1;\n+  }\n+\n+  const CT* i1 = CT::try_cast(phase->type(in1));\n+  const CT* i2 = CT::try_cast(phase->type(in2));\n+  if (i1 == nullptr || i2 == nullptr) {\n+    return n;\n+  }\n+\n+  \/\/ If all unset bits of x are unset in y then return y\n+  if ((~i1->_ones & ~i2->_zeros) == 0) {\n+    return in2;\n+  }\n+  if ((~i2->_ones & ~i1->_zeros) == 0) {\n+    return in1;\n+  }\n+  return n;\n+}\n+\n+Node* AndINode::Identity(PhaseGVN* phase) {\n+  return and_id<TypeInt>(this, phase);\n+}\n+\n+Node* AndLNode::Identity(PhaseGVN* phase) {\n+  return and_id<TypeLong>(this, phase);\n+}\n+\n+template <class CT>\n+static const Type* and_mul_ring(const Type* t1, const Type* t2) {\n+  using T = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+  const CT* i1 = CT::cast(t1);\n+  const CT* i2 = CT::cast(t2);\n+\n+  \/\/ Identity, if all unset bits of x are unset in y then return y\n+  if ((~i1->_ones & ~i2->_zeros) == 0) {\n+    return i2;\n+  }\n+  if ((~i2->_ones & ~i1->_zeros) == 0) {\n+    return i1;\n+  }\n+\n+  T lo = std::numeric_limits<T>::min();\n+  T hi = std::numeric_limits<T>::max();\n+  U ulo = 0;\n+  U uhi = MIN2(i1->_uhi, i2->_uhi);\n+  U zeros = i1->_zeros | i2->_zeros;\n+  U ones = i1->_ones & i2->_ones;\n+  int w = MAX2(i1->_widen, i2->_widen);\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, w);\n+}\n+\n+template <class CT>\n+static const Type* and_value(Node* in1, Node* in2, PhaseGVN* phase) {\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  return and_mul_ring<CT>(t1, t2);\n+}\n+\n+const Type* AndINode::mul_ring(const Type* t1, const Type* t2) const {\n+  return and_mul_ring<TypeInt>(t1, t2);\n+}\n+\n+const Type* AndLNode::mul_ring(const Type* t1, const Type* t2) const {\n+  return and_mul_ring<TypeLong>(t1, t2);\n+}\n+\n+const Type* AndINode::Value(PhaseGVN* phase) const {\n+  return and_value<TypeInt>(in(1), in(2), phase);\n+}\n+\n+const Type* AndLNode::Value(PhaseGVN* phase) const {\n+  return and_value<TypeLong>(in(1), in(2), phase);\n+}\n+\n+\/\/=============================================================================\n+\n@@ -836,10 +770,0 @@\n-\/\/------------------------------Identity---------------------------------------\n-Node* LShiftINode::Identity(PhaseGVN* phase) {\n-  int count = 0;\n-  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaInteger - 1)) == 0) {\n-    \/\/ Shift by a multiple of 32 does nothing\n-    return in(1);\n-  }\n-  return this;\n-}\n-\n@@ -964,61 +888,0 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A LShiftINode shifts its input2 left by input1 amount.\n-const Type* LShiftINode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if( (t1 == TypeInt::INT) || (t2 == TypeInt::INT) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return TypeInt::INT;\n-\n-  const TypeInt *r1 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r2 = t2->is_int(); \/\/ Handy access\n-\n-  if (!r2->is_con())\n-    return TypeInt::INT;\n-\n-  uint shift = r2->get_con();\n-  shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n-  \/\/ Shift by a multiple of 32 does nothing:\n-  if (shift == 0)  return t1;\n-\n-  \/\/ If the shift is a constant, shift the bounds of the type,\n-  \/\/ unless this could lead to an overflow.\n-  if (!r1->is_con()) {\n-    jint lo = r1->_lo, hi = r1->_hi;\n-    if (((lo << shift) >> shift) == lo &&\n-        ((hi << shift) >> shift) == hi) {\n-      \/\/ No overflow.  The range shifts up cleanly.\n-      return TypeInt::make((jint)lo << (jint)shift,\n-                           (jint)hi << (jint)shift,\n-                           MAX2(r1->_widen,r2->_widen));\n-    }\n-    return TypeInt::INT;\n-  }\n-\n-  return TypeInt::make( (jint)r1->get_con() << (jint)shift );\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* LShiftLNode::Identity(PhaseGVN* phase) {\n-  int count = 0;\n-  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaLong - 1)) == 0) {\n-    \/\/ Shift by a multiple of 64 does nothing\n-    return in(1);\n-  }\n-  return this;\n-}\n-\n-\/\/------------------------------Ideal------------------------------------------\n-\/\/ If the right input is a constant, and the left input is an add of a\n-\/\/ constant, flatten the tree: (X+con1)<<con0 ==> X<<con0 + con1<<con0\n@@ -1140,13 +1003,8 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A LShiftLNode shifts its input2 left by input1 amount.\n-const Type* LShiftLNode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n+template <class CT>\n+static Node* lshift_id(Node* n, PhaseGVN* phase) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  constexpr juint W = sizeof(T) * 8;\n+  const TypeInt* i2 = TypeInt::try_cast(phase->type(n->in(2)));\n+  if (i2 == nullptr) {\n+    return n;\n+  }\n@@ -1154,28 +1012,3 @@\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if( (t1 == TypeLong::LONG) || (t2 == TypeInt::INT) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return TypeLong::LONG;\n-\n-  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n-  const TypeInt  *r2 = t2->is_int();  \/\/ Handy access\n-\n-  if (!r2->is_con())\n-    return TypeLong::LONG;\n-\n-  uint shift = r2->get_con();\n-  shift &= BitsPerJavaLong - 1;  \/\/ semantics of Java shifts\n-  \/\/ Shift by a multiple of 64 does nothing:\n-  if (shift == 0)  return t1;\n-\n-  \/\/ If the shift is a constant, shift the bounds of the type,\n-  \/\/ unless this could lead to an overflow.\n-  if (!r1->is_con()) {\n-    jlong lo = r1->_lo, hi = r1->_hi;\n-    if (((lo << shift) >> shift) == lo &&\n-        ((hi << shift) >> shift) == hi) {\n-      \/\/ No overflow.  The range shifts up cleanly.\n-      return TypeLong::make((jlong)lo << (jint)shift,\n-                            (jlong)hi << (jint)shift,\n-                            MAX2(r1->_widen,r2->_widen));\n-    }\n-    return TypeLong::LONG;\n+  i2 = and_mul_ring<TypeInt>(i2, TypeInt::make(W - 1))->is_int();\n+  if (i2 == TypeInt::ZERO) {\n+    return n->in(1);\n@@ -1183,0 +1016,2 @@\n+  return n;\n+}\n@@ -1184,1 +1019,2 @@\n-  return TypeLong::make( (jlong)r1->get_con() << (jint)shift );\n+Node* LShiftINode::Identity(PhaseGVN* phase) {\n+  return lshift_id<TypeInt>(this, phase);\n@@ -1187,8 +1023,39 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* RShiftINode::Identity(PhaseGVN* phase) {\n-  int count = 0;\n-  if (const_shift_count(phase, this, &count)) {\n-    if ((count & (BitsPerJavaInteger - 1)) == 0) {\n-      \/\/ Shift by a multiple of 32 does nothing\n-      return in(1);\n+Node* LShiftLNode::Identity(PhaseGVN* phase) {\n+  return lshift_id<TypeLong>(this, phase);\n+}\n+\n+template <class CT>\n+static const Type* lshift_value(const Node* in1, const Node* in2, PhaseGVN* phase) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  constexpr juint W = sizeof(U) * 8;\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  const CT* i1 = CT::cast(t1);\n+  const TypeInt* i2 = TypeInt::cast(t2);\n+  i2 = and_mul_ring<TypeInt>(i2, TypeInt::make(W - 1))->is_int();\n+\n+  T lo = std::numeric_limits<T>::min();\n+  T hi = std::numeric_limits<T>::max();\n+  if ((std::numeric_limits<T>::min() >> i2->_uhi) <= i1->_lo &&\n+      (std::numeric_limits<T>::max() >> i2->_uhi) >= i1->_hi) {\n+    lo = i1->_lo < 0 ? (i1->_lo << i2->_uhi) : (i1->_lo << i2->_ulo);\n+    hi = i1->_hi < 0 ? (i1->_hi << i2->_ulo) : (i1->_hi << i2->_uhi);\n+  }\n+\n+  U ulo = 0;\n+  U uhi = std::numeric_limits<U>::max();\n+  if ((std::numeric_limits<U>::max() >> i2->_uhi) >= i1->_uhi) {\n+    ulo = i1->_ulo << i2->_ulo;\n+    uhi = i1->_uhi << i2->_uhi;\n+  }\n+\n+  U zeros = std::numeric_limits<U>::max();\n+  U ones = zeros;\n+  for (juint s = i2->_ulo; s <= i2->_uhi; s++) {\n+    if (!i2->contains(s)) {\n+      continue;\n@@ -1196,16 +1063,4 @@\n-    \/\/ Check for useless sign-masking\n-    if (in(1)->Opcode() == Op_LShiftI &&\n-        in(1)->req() == 3 &&\n-        in(1)->in(2) == in(2)) {\n-      count &= BitsPerJavaInteger-1; \/\/ semantics of Java shifts\n-      \/\/ Compute masks for which this shifting doesn't change\n-      int lo = (-1 << (BitsPerJavaInteger - ((uint)count)-1)); \/\/ FFFF8000\n-      int hi = ~lo;               \/\/ 00007FFF\n-      const TypeInt* t11 = phase->type(in(1)->in(1))->isa_int();\n-      if (t11 == nullptr) {\n-        return this;\n-      }\n-      \/\/ Does actual value fit inside of mask?\n-      if (lo <= t11->_lo && t11->_hi <= hi) {\n-        return in(1)->in(1);      \/\/ Then shifting is a nop\n-      }\n+\n+    U current_zeros = i1->_zeros;\n+    if (s > 0) {\n+      current_zeros = (i1->_zeros << s) | (std::numeric_limits<U>::max() >> (W - s));\n@@ -1213,0 +1068,4 @@\n+    zeros &= current_zeros;\n+\n+    U current_ones = i1->_ones << s;\n+    ones &= current_ones;\n@@ -1214,1 +1073,2 @@\n-  return this;\n+\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, MAX2(i1->_widen, i2->_widen));\n@@ -1217,1 +1077,9 @@\n-\/\/------------------------------Ideal------------------------------------------\n+const Type* LShiftINode::Value(PhaseGVN* phase) const {\n+  return lshift_value<TypeInt>(in(1), in(2), phase);\n+}\n+\n+const Type* LShiftLNode::Value(PhaseGVN* phase) const {\n+  return lshift_value<TypeLong>(in(1), in(2), phase);\n+}\n+\n+\/\/=============================================================================\n@@ -1282,8 +1150,9 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftINode shifts its input2 right by input1 amount.\n-const Type* RShiftINode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+template <class CT, bool is_signed>\n+static Node* rshift_id(Node* n, PhaseGVN* phase) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  constexpr juint W = sizeof(T) * 8;\n+  const TypeInt* i2 = TypeInt::try_cast(phase->type(n->in(2)));\n+  if (i2 == nullptr) {\n+    return n;\n+  }\n@@ -1291,34 +1160,28 @@\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeInt::INT;\n-\n-  if (t2 == TypeInt::INT)\n-    return TypeInt::INT;\n-\n-  const TypeInt *r1 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r2 = t2->is_int(); \/\/ Handy access\n-\n-  \/\/ If the shift is a constant, just shift the bounds of the type.\n-  \/\/ For example, if the shift is 31, we just propagate sign bits.\n-  if (r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 32 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    \/\/ This is necessary if we are to correctly type things\n-    \/\/ like (x<<24>>24) == ((byte)x).\n-    jint lo = (jint)r1->_lo >> (jint)shift;\n-    jint hi = (jint)r1->_hi >> (jint)shift;\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-#ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == BitsPerJavaInteger-1) {\n-      if (r1->_lo >= 0) assert(ti == TypeInt::ZERO,    \">>31 of + is  0\");\n-      if (r1->_hi <  0) assert(ti == TypeInt::MINUS_1, \">>31 of - is -1\");\n+  i2 = and_mul_ring<TypeInt>(i2, TypeInt::make(W - 1))->is_int();\n+  if (i2 == TypeInt::ZERO) {\n+    return n->in(1);\n+  }\n+\n+  auto lshift_no_ovf = [](const CT* i1, const TypeInt* i2){\n+    if (is_signed) {\n+      return (std::numeric_limits<T>::min() >> i2->_uhi) <= i1->_lo &&\n+             (std::numeric_limits<T>::max() >> i2->_uhi) >= i1->_hi;\n+    } else {\n+      return (std::numeric_limits<U>::max() >> i2->_uhi) >= i1->_uhi;\n+    }\n+  };\n+\n+  constexpr int Op_LShift = std::is_same<CT, TypeInt>::value ? Op_LShiftI : Op_LShiftL;\n+  constexpr int Op_Add = std::is_same<CT, TypeInt>::value ? Op_AddI : Op_AddL;\n+  constexpr int Op_Sub = std::is_same<CT, TypeInt>::value ? Op_SubI : Op_SubL;\n+  int op1 = n->in(1)->Opcode();\n+\n+  \/\/ Check for useless sign-masking\n+  \/\/ (X << Y) >> Y = X if X << Y does not overflow\n+  if (op1 == Op_LShift && n->in(1)->in(2) == n->in(2)) {\n+    const CT* i11 = CT::try_cast(phase->type(n->in(1)->in(1)));\n+    if (i11 == nullptr) {\n+      return n;\n+    }\n+    if (lshift_no_ovf(i11, i2)) {\n+      return n->in(1)->in(1);\n@@ -1326,2 +1189,0 @@\n-#endif\n-    return ti;\n@@ -1330,2 +1191,18 @@\n-  if( !r1->is_con() || !r2->is_con() )\n-    return TypeInt::INT;\n+  \/\/ ((X << Y) + Z) >> Y = X if X << Y does not overflow and Z < (1 << Y)\n+  if ((op1 == Op_Add || op1 == Op_Sub) &&\n+      n->in(1)->in(1)->Opcode() == Op_LShift &&\n+      n->in(1)->in(1)->in(2) == n->in(2)) {\n+    const CT* i111 = CT::try_cast(phase->type(n->in(1)->in(1)->in(1)));\n+    const CT* i12 = CT::try_cast(phase->type(n->in(1)->in(2)));\n+    if (i111 == nullptr || i12 == nullptr) {\n+      return n;\n+    }\n+    if (!lshift_no_ovf(i111, i2)) {\n+      return n;\n+    }\n+    U bound = i2->_ulo;\n+    if ((op1 == Op_Add && i12->_uhi < bound) ||\n+        (op1 == Op_Sub && i12->_hi <= 0 && -U(i12->_lo) < bound)) {\n+      return n->in(1)->in(1)->in(1);\n+    }\n+  }\n@@ -1333,2 +1210,1 @@\n-  \/\/ Signed shift right\n-  return TypeInt::make( r1->get_con() >> (r2->get_con()&31) );\n+  return n;\n@@ -1337,5 +1213,2 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* RShiftLNode::Identity(PhaseGVN* phase) {\n-  const TypeInt *ti = phase->type(in(2))->isa_int(); \/\/ Shift count is an int.\n-  return (ti && ti->is_con() && (ti->get_con() & (BitsPerJavaLong - 1)) == 0) ? in(1) : this;\n+Node* RShiftINode::Identity(PhaseGVN* phase) {\n+  return rshift_id<TypeInt, true>(this, phase);\n@@ -1344,8 +1217,3 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftLNode shifts its input2 right by input1 amount.\n-const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+Node* RShiftLNode::Identity(PhaseGVN* phase) {\n+  return rshift_id<TypeLong, true>(this, phase);\n+}\n@@ -1353,37 +1221,9 @@\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeLong::LONG;\n-\n-  if (t2 == TypeInt::INT)\n-    return TypeLong::LONG;\n-\n-  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n-  const TypeInt  *r2 = t2->is_int (); \/\/ Handy access\n-\n-  \/\/ If the shift is a constant, just shift the bounds of the type.\n-  \/\/ For example, if the shift is 63, we just propagate sign bits.\n-  if (r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= (2*BitsPerJavaInteger)-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 64 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    \/\/ This is necessary if we are to correctly type things\n-    \/\/ like (x<<24>>24) == ((byte)x).\n-    jlong lo = (jlong)r1->_lo >> (jlong)shift;\n-    jlong hi = (jlong)r1->_hi >> (jlong)shift;\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-    #ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == (2*BitsPerJavaInteger)-1) {\n-      if (r1->_lo >= 0) assert(tl == TypeLong::ZERO,    \">>63 of + is 0\");\n-      if (r1->_hi < 0)  assert(tl == TypeLong::MINUS_1, \">>63 of - is -1\");\n-    }\n-    #endif\n-    return tl;\n+template <class CT>\n+static const Type* rshift_value(const Node* in1, const Node* in2, PhaseGVN* phase) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  constexpr juint W = sizeof(U) * 8;\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n@@ -1392,2 +1232,3 @@\n-  return TypeLong::LONG;                \/\/ Give up\n-}\n+  const CT* i1 = CT::cast(t1);\n+  const TypeInt* i2 = TypeInt::cast(t2);\n+  i2 = and_mul_ring<TypeInt>(i2, TypeInt::make(W - 1))->is_int();\n@@ -1395,8 +1236,2 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* URShiftINode::Identity(PhaseGVN* phase) {\n-  int count = 0;\n-  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaInteger - 1)) == 0) {\n-    \/\/ Shift by a multiple of 32 does nothing\n-    return in(1);\n-  }\n+  T lo = i1->_lo < 0 ? (i1->_lo >> i2->_ulo) : (i1->_lo >> i2->_uhi);\n+  T hi = i1->_hi < 0 ? (i1->_hi >> i2->_uhi) : (i1->_hi >> i2->_ulo);\n@@ -1404,19 +1239,8 @@\n-  \/\/ Check for \"((x << LogBytesPerWord) + (wordSize-1)) >> LogBytesPerWord\" which is just \"x\".\n-  \/\/ Happens during new-array length computation.\n-  \/\/ Safe if 'x' is in the range [0..(max_int>>LogBytesPerWord)]\n-  Node *add = in(1);\n-  if (add->Opcode() == Op_AddI) {\n-    const TypeInt *t2 = phase->type(add->in(2))->isa_int();\n-    if (t2 && t2->is_con(wordSize - 1) &&\n-        add->in(1)->Opcode() == Op_LShiftI) {\n-      \/\/ Check that shift_counts are LogBytesPerWord.\n-      Node          *lshift_count   = add->in(1)->in(2);\n-      const TypeInt *t_lshift_count = phase->type(lshift_count)->isa_int();\n-      if (t_lshift_count && t_lshift_count->is_con(LogBytesPerWord) &&\n-          t_lshift_count == phase->type(in(2))) {\n-        Node          *x   = add->in(1)->in(1);\n-        const TypeInt *t_x = phase->type(x)->isa_int();\n-        if (t_x != nullptr && 0 <= t_x->_lo && t_x->_hi <= (max_jint>>LogBytesPerWord)) {\n-          return x;\n-        }\n-      }\n+  U ulo = T(i1->_ulo) >= 0 ? (i1->_ulo >> i2->_uhi) : (T(i1->_ulo) >> i2->_ulo);\n+  U uhi = T(i1->_uhi) >= 0 ? (i1->_uhi >> i2->_ulo) : (T(i1->_uhi) >> i2->_uhi);\n+\n+  U zeros = std::numeric_limits<U>::max();\n+  U ones = zeros;\n+  for (juint s = i2->_ulo; s <= i2->_uhi; s++) {\n+    if (!i2->contains(s)) {\n+      continue;\n@@ -1424,0 +1248,6 @@\n+\n+    U current_zeros = T(i1->_zeros) >> s;\n+    zeros &= current_zeros;\n+\n+    U current_ones = T(i1->_ones) >> s;\n+    ones &= current_ones;\n@@ -1426,1 +1256,1 @@\n-  return (phase->type(in(2))->higher_equal(TypeInt::ZERO)) ? in(1) : this;\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, MAX2(i1->_widen, i2->_widen));\n@@ -1429,1 +1259,9 @@\n-\/\/------------------------------Ideal------------------------------------------\n+const Type* RShiftINode::Value(PhaseGVN* phase) const {\n+  return rshift_value<TypeInt>(in(1), in(2), phase);\n+}\n+\n+const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n+  return rshift_value<TypeLong>(in(1), in(2), phase);\n+}\n+\n+\/\/=============================================================================\n@@ -1508,86 +1346,0 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A URShiftINode shifts its input2 right by input1 amount.\n-const Type* URShiftINode::Value(PhaseGVN* phase) const {\n-  \/\/ (This is a near clone of RShiftINode::Value.)\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeInt::INT;\n-\n-  if (t2 == TypeInt::INT)\n-    return TypeInt::INT;\n-\n-  const TypeInt *r1 = t1->is_int();     \/\/ Handy access\n-  const TypeInt *r2 = t2->is_int();     \/\/ Handy access\n-\n-  if (r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 32 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    jint lo = (juint)r1->_lo >> (juint)shift;\n-    jint hi = (juint)r1->_hi >> (juint)shift;\n-    if (r1->_hi >= 0 && r1->_lo < 0) {\n-      \/\/ If the type has both negative and positive values,\n-      \/\/ there are two separate sub-domains to worry about:\n-      \/\/ The positive half and the negative half.\n-      jint neg_lo = lo;\n-      jint neg_hi = (juint)-1 >> (juint)shift;\n-      jint pos_lo = (juint) 0 >> (juint)shift;\n-      jint pos_hi = hi;\n-      lo = MIN2(neg_lo, pos_lo);  \/\/ == 0\n-      hi = MAX2(neg_hi, pos_hi);  \/\/ == -1 >>> shift;\n-    }\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-    #ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == BitsPerJavaInteger-1) {\n-      if (r1->_lo >= 0) assert(ti == TypeInt::ZERO, \">>>31 of + is 0\");\n-      if (r1->_hi < 0)  assert(ti == TypeInt::ONE,  \">>>31 of - is +1\");\n-    }\n-    #endif\n-    return ti;\n-  }\n-\n-  \/\/\n-  \/\/ Do not support shifted oops in info for GC\n-  \/\/\n-  \/\/ else if( t1->base() == Type::InstPtr ) {\n-  \/\/\n-  \/\/   const TypeInstPtr *o = t1->is_instptr();\n-  \/\/   if( t1->singleton() )\n-  \/\/     return TypeInt::make( ((uint32_t)o->const_oop() + o->_offset) >> shift );\n-  \/\/ }\n-  \/\/ else if( t1->base() == Type::KlassPtr ) {\n-  \/\/   const TypeKlassPtr *o = t1->is_klassptr();\n-  \/\/   if( t1->singleton() )\n-  \/\/     return TypeInt::make( ((uint32_t)o->const_oop() + o->_offset) >> shift );\n-  \/\/ }\n-\n-  return TypeInt::INT;\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* URShiftLNode::Identity(PhaseGVN* phase) {\n-  int count = 0;\n-  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaLong - 1)) == 0) {\n-    \/\/ Shift by a multiple of 64 does nothing\n-    return in(1);\n-  }\n-  return this;\n-}\n-\n-\/\/------------------------------Ideal------------------------------------------\n@@ -1653,9 +1405,3 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A URShiftINode shifts its input2 right by input1 amount.\n-const Type* URShiftLNode::Value(PhaseGVN* phase) const {\n-  \/\/ (This is a near clone of RShiftLNode::Value.)\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+Node* URShiftINode::Identity(PhaseGVN* phase) {\n+  return rshift_id<TypeInt, false>(this, phase);\n+}\n@@ -1663,35 +1409,31 @@\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeLong::LONG;\n-\n-  if (t2 == TypeInt::INT)\n-    return TypeLong::LONG;\n-\n-  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n-  const TypeInt  *r2 = t2->is_int (); \/\/ Handy access\n-\n-  if (r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= BitsPerJavaLong - 1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 64 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    jlong lo = (julong)r1->_lo >> (juint)shift;\n-    jlong hi = (julong)r1->_hi >> (juint)shift;\n-    if (r1->_hi >= 0 && r1->_lo < 0) {\n-      \/\/ If the type has both negative and positive values,\n-      \/\/ there are two separate sub-domains to worry about:\n-      \/\/ The positive half and the negative half.\n-      jlong neg_lo = lo;\n-      jlong neg_hi = (julong)-1 >> (juint)shift;\n-      jlong pos_lo = (julong) 0 >> (juint)shift;\n-      jlong pos_hi = hi;\n-      \/\/lo = MIN2(neg_lo, pos_lo);  \/\/ == 0\n-      lo = neg_lo < pos_lo ? neg_lo : pos_lo;\n-      \/\/hi = MAX2(neg_hi, pos_hi);  \/\/ == -1 >>> shift;\n-      hi = neg_hi > pos_hi ? neg_hi : pos_hi;\n+Node* URShiftLNode::Identity(PhaseGVN* phase) {\n+  return rshift_id<TypeLong, false>(this, phase);\n+}\n+\n+template <class CT>\n+static const Type* urshift_value(const Node* in1, const Node* in2, PhaseGVN* phase) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  constexpr juint W = sizeof(U) * 8;\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  const CT* i1 = CT::cast(t1);\n+  const TypeInt* i2 = TypeInt::cast(t2);\n+  i2 = and_mul_ring<TypeInt>(i2, TypeInt::make(W - 1))->is_int();\n+\n+  T lo = (i1->_lo < 0 && i2->_ulo == 0) ? i1->_lo : (i1->_ulo >> i2->_uhi);\n+  T hi = (i2->_uhi == 0) ? i1->_hi\n+                         : ((i2->_ulo == 0) ? MAX2<T>(i1->_hi, i1->_uhi >> 1) : (i1->_uhi >> i2->_ulo));\n+\n+  U ulo = i1->_ulo >> i2->_uhi;\n+  U uhi = i1->_uhi >> i2->_ulo;\n+\n+  U zeros = std::numeric_limits<U>::max();\n+  U ones = zeros;\n+  for (juint s = i2->_ulo; s <= i2->_uhi; s++) {\n+    if (!i2->contains(s)) {\n+      continue;\n@@ -1699,7 +1441,4 @@\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-    #ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == BitsPerJavaLong - 1) {\n-      if (r1->_lo >= 0) assert(tl == TypeLong::ZERO, \">>>63 of + is 0\");\n-      if (r1->_hi < 0)  assert(tl == TypeLong::ONE,  \">>>63 of - is +1\");\n+\n+    U current_zeros = i1->_zeros;\n+    if (s > 0) {\n+      current_zeros = (i1->_zeros >> s) | (std::numeric_limits<U>::max() << (W - s));\n@@ -1707,2 +1446,4 @@\n-    #endif\n-    return tl;\n+    zeros &= current_zeros;\n+\n+    U current_ones = i1->_ones >> s;\n+    ones &= current_ones;\n@@ -1711,1 +1452,9 @@\n-  return TypeLong::LONG;                \/\/ Give up\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, MAX2(i1->_widen, i2->_widen));\n+}\n+\n+const Type* URShiftINode::Value(PhaseGVN* phase) const {\n+  return urshift_value<TypeInt>(in(1), in(2), phase);\n+}\n+\n+const Type* URShiftLNode::Value(PhaseGVN* phase) const {\n+  return urshift_value<TypeLong>(in(1), in(2), phase);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":311,"deletions":562,"binary":false,"changes":873,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-  AndINode( Node *in1, Node *in2 ) : MulINode(in1,in2) {}\n+  AndINode(Node* in1, Node* in2) : MulINode(in1, in2) {}\n@@ -195,1 +195,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -198,3 +198,3 @@\n-  virtual const Type *mul_ring( const Type *, const Type * ) const;\n-  const Type *mul_id() const { return TypeInt::MINUS_1; }\n-  const Type *add_id() const { return TypeInt::ZERO; }\n+  virtual const Type* mul_ring(const Type* t1, const Type* t2) const;\n+  const Type* mul_id() const { return TypeInt::MINUS_1; }\n+  const Type* add_id() const { return TypeInt::ZERO; }\n@@ -213,1 +213,1 @@\n-  AndLNode( Node *in1, Node *in2 ) : MulLNode(in1,in2) {}\n+  AndLNode(Node* in1, Node* in2 ) : MulLNode(in1, in2) {}\n@@ -215,1 +215,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -218,3 +218,3 @@\n-  virtual const Type *mul_ring( const Type *, const Type * ) const;\n-  const Type *mul_id() const { return TypeLong::MINUS_1; }\n-  const Type *add_id() const { return TypeLong::ZERO; }\n+  virtual const Type* mul_ring(const Type* t1, const Type* t2) const;\n+  const Type* mul_id() const { return TypeLong::MINUS_1; }\n+  const Type* add_id() const { return TypeLong::ZERO; }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <limits>\n+#include <type_traits>\n@@ -321,19 +323,0 @@\n-\/\/------------------------------sub--------------------------------------------\n-\/\/ A subtract node differences it's two inputs.\n-const Type *SubINode::sub( const Type *t1, const Type *t2 ) const {\n-  const TypeInt *r0 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t2->is_int();\n-  int32_t lo = java_subtract(r0->_lo, r1->_hi);\n-  int32_t hi = java_subtract(r0->_hi, r1->_lo);\n-\n-  \/\/ We next check for 32-bit overflow.\n-  \/\/ If that happens, we just assume all integers are possible.\n-  if( (((r0->_lo ^ r1->_hi) >= 0) ||    \/\/ lo ends have same signs OR\n-       ((r0->_lo ^      lo) >= 0)) &&   \/\/ lo results have same signs AND\n-      (((r0->_hi ^ r1->_lo) >= 0) ||    \/\/ hi ends have same signs OR\n-       ((r0->_hi ^      hi) >= 0)) )    \/\/ hi results have same signs\n-    return TypeInt::make(lo,hi,MAX2(r0->_widen,r1->_widen));\n-  else                          \/\/ Overflow; assume all integers\n-    return TypeInt::INT;\n-}\n-\n@@ -498,2 +481,54 @@\n-\/\/------------------------------sub--------------------------------------------\n-\/\/ A subtract node differences it's two inputs.\n+template <class CT>\n+static const Type* sub_sub(const Type* t1, const Type* t2) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+  constexpr juint W = sizeof(T) * 8;\n+  const CT* i1 = CT::cast(t1);\n+  const CT* i2 = CT::cast(t2);\n+\n+  T lo = U(i1->_lo) - U(i2->_hi);\n+  T hi = U(i1->_hi) - U(i2->_lo);\n+  bool lo_novf = i2->_hi > 0 && lo >= i1->_lo;\n+  bool hi_novf = i2->_lo > 0 && hi >= i1->_hi;\n+  bool lo_povf = i2->_hi < 0 && lo <= i1->_lo;\n+  bool hi_povf = i2->_lo < 0 && hi <= i1->_hi;\n+  if ((lo_novf && !hi_novf) || (hi_povf && !lo_povf)) {\n+    lo = std::numeric_limits<T>::min();\n+    hi = std::numeric_limits<T>::max();\n+  }\n+\n+  U ulo = i1->_ulo - i2->_uhi;\n+  U uhi = i1->_uhi - i2->_ulo;\n+  bool lo_uovf = ulo > i1->_ulo;\n+  bool hi_uovf = uhi > i1->_uhi;\n+  if (lo_uovf && !hi_uovf) {\n+    ulo = 0;\n+    uhi = std::numeric_limits<U>::max();\n+  }\n+\n+  U zeros = 0;\n+  U ones = 0;\n+  bool carry = false;\n+  bool no_carry = true;\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << i;\n+    jint min = ((i1->_ones & mask) != 0) - ((i2->_zeros & mask) == 0) - !no_carry;\n+    jint max = ((i1->_zeros & mask) == 0) - ((i2->_ones & mask) != 0) - carry;\n+    no_carry = min >= 0;\n+    carry = max < 0;\n+    if (min == max) {\n+      if ((min & 1) == 0) {\n+        zeros |= mask;\n+      } else {\n+        ones |= mask;\n+      }\n+    }\n+  }\n+\n+  return CT::make(lo, hi, ulo, uhi, zeros, ones, MAX2(i1->_widen, i2->_widen));\n+}\n+\n+const Type* SubINode::sub(const Type* t1, const Type* t2) const {\n+  return sub_sub<TypeInt>(t1, t2);\n+}\n+\n@@ -501,14 +536,1 @@\n-  const TypeLong *r0 = t1->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t2->is_long();\n-  jlong lo = java_subtract(r0->_lo, r1->_hi);\n-  jlong hi = java_subtract(r0->_hi, r1->_lo);\n-\n-  \/\/ We next check for 32-bit overflow.\n-  \/\/ If that happens, we just assume all integers are possible.\n-  if( (((r0->_lo ^ r1->_hi) >= 0) ||    \/\/ lo ends have same signs OR\n-       ((r0->_lo ^      lo) >= 0)) &&   \/\/ lo results have same signs AND\n-      (((r0->_hi ^ r1->_lo) >= 0) ||    \/\/ hi ends have same signs OR\n-       ((r0->_hi ^      hi) >= 0)) )    \/\/ hi results have same signs\n-    return TypeLong::make(lo,hi,MAX2(r0->_widen,r1->_widen));\n-  else                          \/\/ Overflow; assume all integers\n-    return TypeLong::LONG;\n+  return sub_sub<TypeLong>(t1, t2);\n@@ -643,22 +665,0 @@\n-\/\/------------------------------cmp--------------------------------------------\n-\/\/ Simplify a CmpI (compare 2 integers) node, based on local information.\n-\/\/ If both inputs are constants, compare them.\n-const Type *CmpINode::sub( const Type *t1, const Type *t2 ) const {\n-  const TypeInt *r0 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t2->is_int();\n-\n-  if( r0->_hi < r1->_lo )       \/\/ Range is always low?\n-    return TypeInt::CC_LT;\n-  else if( r0->_lo > r1->_hi )  \/\/ Range is always high?\n-    return TypeInt::CC_GT;\n-\n-  else if( r0->is_con() && r1->is_con() ) { \/\/ comparing constants?\n-    assert(r0->get_con() == r1->get_con(), \"must be equal\");\n-    return TypeInt::CC_EQ;      \/\/ Equal results.\n-  } else if( r0->_hi == r1->_lo ) \/\/ Range is never high?\n-    return TypeInt::CC_LE;\n-  else if( r0->_lo == r1->_hi ) \/\/ Range is never low?\n-    return TypeInt::CC_GE;\n-  return TypeInt::CC;           \/\/ else use worst case results\n-}\n-\n@@ -705,64 +705,0 @@\n-\n-\/\/ Simplify a CmpU (compare 2 integers) node, based on local information.\n-\/\/ If both inputs are constants, compare them.\n-const Type *CmpUNode::sub( const Type *t1, const Type *t2 ) const {\n-  assert(!t1->isa_ptr(), \"obsolete usage of CmpU\");\n-\n-  \/\/ comparing two unsigned ints\n-  const TypeInt *r0 = t1->is_int();   \/\/ Handy access\n-  const TypeInt *r1 = t2->is_int();\n-\n-  \/\/ Current installed version\n-  \/\/ Compare ranges for non-overlap\n-  juint lo0 = r0->_lo;\n-  juint hi0 = r0->_hi;\n-  juint lo1 = r1->_lo;\n-  juint hi1 = r1->_hi;\n-\n-  \/\/ If either one has both negative and positive values,\n-  \/\/ it therefore contains both 0 and -1, and since [0..-1] is the\n-  \/\/ full unsigned range, the type must act as an unsigned bottom.\n-  bool bot0 = ((jint)(lo0 ^ hi0) < 0);\n-  bool bot1 = ((jint)(lo1 ^ hi1) < 0);\n-\n-  if (bot0 || bot1) {\n-    \/\/ All unsigned values are LE -1 and GE 0.\n-    if (lo0 == 0 && hi0 == 0) {\n-      return TypeInt::CC_LE;            \/\/   0 <= bot\n-    } else if ((jint)lo0 == -1 && (jint)hi0 == -1) {\n-      return TypeInt::CC_GE;            \/\/ -1 >= bot\n-    } else if (lo1 == 0 && hi1 == 0) {\n-      return TypeInt::CC_GE;            \/\/ bot >= 0\n-    } else if ((jint)lo1 == -1 && (jint)hi1 == -1) {\n-      return TypeInt::CC_LE;            \/\/ bot <= -1\n-    }\n-  } else {\n-    \/\/ We can use ranges of the form [lo..hi] if signs are the same.\n-    assert(lo0 <= hi0 && lo1 <= hi1, \"unsigned ranges are valid\");\n-    \/\/ results are reversed, '-' > '+' for unsigned compare\n-    if (hi0 < lo1) {\n-      return TypeInt::CC_LT;            \/\/ smaller\n-    } else if (lo0 > hi1) {\n-      return TypeInt::CC_GT;            \/\/ greater\n-    } else if (hi0 == lo1 && lo0 == hi1) {\n-      return TypeInt::CC_EQ;            \/\/ Equal results\n-    } else if (lo0 >= hi1) {\n-      return TypeInt::CC_GE;\n-    } else if (hi0 <= lo1) {\n-      \/\/ Check for special case in Hashtable::get.  (See below.)\n-      if ((jint)lo0 >= 0 && (jint)lo1 >= 0 && is_index_range_check())\n-        return TypeInt::CC_LT;\n-      return TypeInt::CC_LE;\n-    }\n-  }\n-  \/\/ Check for special case in Hashtable::get - the hash index is\n-  \/\/ mod'ed to the table size so the following range check is useless.\n-  \/\/ Check for: (X Mod Y) CmpU Y, where the mod result and Y both have\n-  \/\/ to be positive.\n-  \/\/ (This is a gross hack, since the sub method never\n-  \/\/ looks at the structure of the node in any other case.)\n-  if ((jint)lo0 >= 0 && (jint)lo1 >= 0 && is_index_range_check())\n-    return TypeInt::CC_LT;\n-  return TypeInt::CC;                   \/\/ else use worst case results\n-}\n-\n@@ -774,8 +710,0 @@\n-  const Node* in1 = in(1);\n-  const Node* in2 = in(2);\n-  const Type* t1 = phase->type(in1);\n-  const Type* t2 = phase->type(in2);\n-  assert(t1->isa_int(), \"CmpU has only Int type inputs\");\n-  if (t2 == TypeInt::INT) { \/\/ Compare to bottom?\n-    return bottom_type();\n-  }\n@@ -783,60 +711,9 @@\n-  const Type* t_sub = sub(t1, t2); \/\/ compare based on immediate inputs\n-\n-  uint in1_op = in1->Opcode();\n-  if (in1_op == Op_AddI || in1_op == Op_SubI) {\n-    \/\/ The problem rise when result of AddI(SubI) may overflow\n-    \/\/ signed integer value. Let say the input type is\n-    \/\/ [256, maxint] then +128 will create 2 ranges due to\n-    \/\/ overflow: [minint, minint+127] and [384, maxint].\n-    \/\/ But C2 type system keep only 1 type range and as result\n-    \/\/ it use general [minint, maxint] for this case which we\n-    \/\/ can't optimize.\n-    \/\/\n-    \/\/ Make 2 separate type ranges based on types of AddI(SubI) inputs\n-    \/\/ and compare results of their compare. If results are the same\n-    \/\/ CmpU node can be optimized.\n-    const Node* in11 = in1->in(1);\n-    const Node* in12 = in1->in(2);\n-    const Type* t11 = (in11 == in1) ? Type::TOP : phase->type(in11);\n-    const Type* t12 = (in12 == in1) ? Type::TOP : phase->type(in12);\n-    \/\/ Skip cases when input types are top or bottom.\n-    if ((t11 != Type::TOP) && (t11 != TypeInt::INT) &&\n-        (t12 != Type::TOP) && (t12 != TypeInt::INT)) {\n-      const TypeInt *r0 = t11->is_int();\n-      const TypeInt *r1 = t12->is_int();\n-      jlong lo_r0 = r0->_lo;\n-      jlong hi_r0 = r0->_hi;\n-      jlong lo_r1 = r1->_lo;\n-      jlong hi_r1 = r1->_hi;\n-      if (in1_op == Op_SubI) {\n-        jlong tmp = hi_r1;\n-        hi_r1 = -lo_r1;\n-        lo_r1 = -tmp;\n-        \/\/ Note, for substructing [minint,x] type range\n-        \/\/ long arithmetic provides correct overflow answer.\n-        \/\/ The confusion come from the fact that in 32-bit\n-        \/\/ -minint == minint but in 64-bit -minint == maxint+1.\n-      }\n-      jlong lo_long = lo_r0 + lo_r1;\n-      jlong hi_long = hi_r0 + hi_r1;\n-      int lo_tr1 = min_jint;\n-      int hi_tr1 = (int)hi_long;\n-      int lo_tr2 = (int)lo_long;\n-      int hi_tr2 = max_jint;\n-      bool underflow = lo_long != (jlong)lo_tr2;\n-      bool overflow  = hi_long != (jlong)hi_tr1;\n-      \/\/ Use sub(t1, t2) when there is no overflow (one type range)\n-      \/\/ or when both overflow and underflow (too complex).\n-      if ((underflow != overflow) && (hi_tr1 < lo_tr2)) {\n-        \/\/ Overflow only on one boundary, compare 2 separate type ranges.\n-        int w = MAX2(r0->_widen, r1->_widen); \/\/ _widen does not matter here\n-        const TypeInt* tr1 = TypeInt::make(lo_tr1, hi_tr1, w);\n-        const TypeInt* tr2 = TypeInt::make(lo_tr2, hi_tr2, w);\n-        const TypeInt* cmp1 = sub(tr1, t2)->is_int();\n-        const TypeInt* cmp2 = sub(tr2, t2)->is_int();\n-        \/\/ Compute union, so that cmp handles all possible results from the two cases\n-        const Type* t_cmp = cmp1->meet(cmp2);\n-        \/\/ Pick narrowest type, based on overflow computation and on immediate inputs\n-        return t_sub->filter(t_cmp);\n-      }\n-    }\n+  const TypeInt* i1 = phase->type(in(1))->is_int();\n+  const TypeInt* i2 = phase->type(in(2))->is_int();\n+\n+  \/\/ Check for special case in Hashtable::get - the hash index is\n+  \/\/ mod'ed to the table size so the following range check is useless.\n+  \/\/ Check for: (X Mod Y) CmpU Y, where the mod result and Y both have\n+  \/\/ to be positive.\n+  if (i1->_lo >= 0 && i2->_lo >= 0 && is_index_range_check()) {\n+    return TypeInt::CC_LT;\n@@ -845,1 +722,1 @@\n-  return t_sub;\n+  return sub(i1, i2);\n@@ -888,6 +765,10 @@\n-\/\/=============================================================================\n-\/\/ Simplify a CmpL (compare 2 longs ) node, based on local information.\n-\/\/ If both inputs are constants, compare them.\n-const Type *CmpLNode::sub( const Type *t1, const Type *t2 ) const {\n-  const TypeLong *r0 = t1->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t2->is_long();\n+template <class CT, bool is_signed>\n+static const Type* cmp_sub(const Type* t1, const Type* t2) {\n+  const CT* i1 = CT::cast(t1);\n+  const CT* i2 = CT::cast(t2);\n+\n+  using T = std::conditional_t<is_signed, decltype(CT::_lo), decltype(CT::_ulo)>;\n+  T lo1 = is_signed ? i1->_lo : i1->_ulo;\n+  T lo2 = is_signed ? i2->_lo : i2->_ulo;\n+  T hi1 = is_signed ? i1->_hi : i1->_uhi;\n+  T hi2 = is_signed ? i2->_hi : i2->_uhi;\n@@ -895,1 +776,1 @@\n-  if( r0->_hi < r1->_lo )       \/\/ Range is always low?\n+  if (hi1 < lo2) {\n@@ -897,1 +778,1 @@\n-  else if( r0->_lo > r1->_hi )  \/\/ Range is always high?\n+  } else if (lo1 > hi2) {\n@@ -899,5 +780,4 @@\n-\n-  else if( r0->is_con() && r1->is_con() ) { \/\/ comparing constants?\n-    assert(r0->get_con() == r1->get_con(), \"must be equal\");\n-    return TypeInt::CC_EQ;      \/\/ Equal results.\n-  } else if( r0->_hi == r1->_lo ) \/\/ Range is never high?\n+  } else if (lo1 == hi2 && lo2 == hi1) {\n+    \/\/ We may encounter this during CCP\n+    return TypeInt::CC_EQ;\n+  } else if (hi1 == lo2) {\n@@ -905,1 +785,1 @@\n-  else if( r0->_lo == r1->_hi ) \/\/ Range is never low?\n+  } else if (lo1 == hi2) {\n@@ -907,1 +787,4 @@\n-  return TypeInt::CC;           \/\/ else use worst case results\n+  } else if (i1->filter(i2) == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+  return TypeInt::CC;\n@@ -910,0 +793,3 @@\n+const Type* CmpINode::sub(const Type* t1, const Type* t2) const {\n+  return cmp_sub<TypeInt, true>(t1, t2);\n+}\n@@ -911,49 +797,3 @@\n-\/\/ Simplify a CmpUL (compare 2 unsigned longs) node, based on local information.\n-\/\/ If both inputs are constants, compare them.\n-const Type* CmpULNode::sub(const Type* t1, const Type* t2) const {\n-  assert(!t1->isa_ptr(), \"obsolete usage of CmpUL\");\n-\n-  \/\/ comparing two unsigned longs\n-  const TypeLong* r0 = t1->is_long();   \/\/ Handy access\n-  const TypeLong* r1 = t2->is_long();\n-\n-  \/\/ Current installed version\n-  \/\/ Compare ranges for non-overlap\n-  julong lo0 = r0->_lo;\n-  julong hi0 = r0->_hi;\n-  julong lo1 = r1->_lo;\n-  julong hi1 = r1->_hi;\n-\n-  \/\/ If either one has both negative and positive values,\n-  \/\/ it therefore contains both 0 and -1, and since [0..-1] is the\n-  \/\/ full unsigned range, the type must act as an unsigned bottom.\n-  bool bot0 = ((jlong)(lo0 ^ hi0) < 0);\n-  bool bot1 = ((jlong)(lo1 ^ hi1) < 0);\n-\n-  if (bot0 || bot1) {\n-    \/\/ All unsigned values are LE -1 and GE 0.\n-    if (lo0 == 0 && hi0 == 0) {\n-      return TypeInt::CC_LE;            \/\/   0 <= bot\n-    } else if ((jlong)lo0 == -1 && (jlong)hi0 == -1) {\n-      return TypeInt::CC_GE;            \/\/ -1 >= bot\n-    } else if (lo1 == 0 && hi1 == 0) {\n-      return TypeInt::CC_GE;            \/\/ bot >= 0\n-    } else if ((jlong)lo1 == -1 && (jlong)hi1 == -1) {\n-      return TypeInt::CC_LE;            \/\/ bot <= -1\n-    }\n-  } else {\n-    \/\/ We can use ranges of the form [lo..hi] if signs are the same.\n-    assert(lo0 <= hi0 && lo1 <= hi1, \"unsigned ranges are valid\");\n-    \/\/ results are reversed, '-' > '+' for unsigned compare\n-    if (hi0 < lo1) {\n-      return TypeInt::CC_LT;            \/\/ smaller\n-    } else if (lo0 > hi1) {\n-      return TypeInt::CC_GT;            \/\/ greater\n-    } else if (hi0 == lo1 && lo0 == hi1) {\n-      return TypeInt::CC_EQ;            \/\/ Equal results\n-    } else if (lo0 >= hi1) {\n-      return TypeInt::CC_GE;\n-    } else if (hi0 <= lo1) {\n-      return TypeInt::CC_LE;\n-    }\n-  }\n+const Type *CmpUNode::sub( const Type *t1, const Type *t2 ) const {\n+  return cmp_sub<TypeInt, false>(t1, t2);\n+}\n@@ -961,1 +801,6 @@\n-  return TypeInt::CC;                   \/\/ else use worst case results\n+const Type* CmpLNode::sub(const Type* t1, const Type* t2) const {\n+  return cmp_sub<TypeLong, true>(t1, t2);\n+}\n+\n+const Type* CmpULNode::sub(const Type* t1, const Type* t2) const {\n+  return cmp_sub<TypeLong, false>(t1, t2);\n@@ -1317,9 +1162,3 @@\n-const Type *BoolTest::cc2logical( const Type *CC ) const {\n-  if( CC == Type::TOP ) return Type::TOP;\n-  if( CC->base() != Type::Int ) return TypeInt::BOOL; \/\/ Bottom or worse\n-  const TypeInt *ti = CC->is_int();\n-  if( ti->is_con() ) {          \/\/ Only 1 kind of condition codes set?\n-    \/\/ Match low order 2 bits\n-    int tmp = ((ti->get_con()&3) == (_test&3)) ? 1 : 0;\n-    if( _test & 4 ) tmp = 1-tmp;     \/\/ Optionally complement result\n-    return TypeInt::make(tmp);       \/\/ Boolean result\n+const Type* BoolTest::cc2logical(const Type* cc) const {\n+  if (cc == Type::TOP) {\n+    return Type::TOP;\n@@ -1328,3 +1167,6 @@\n-  if( CC == TypeInt::CC_GE ) {\n-    if( _test == ge ) return TypeInt::ONE;\n-    if( _test == lt ) return TypeInt::ZERO;\n+  if (cc == TypeInt::CC_EQ) {\n+    return (_test == eq || _test == le || _test == ge) ? TypeInt::ONE : TypeInt::ZERO;\n+  } else if (cc == TypeInt::CC_LT) {\n+    return (_test == lt || _test == le || _test == ne) ? TypeInt::ONE : TypeInt::ZERO;\n+  } else if (cc == TypeInt::CC_GT) {\n+    return (_test == gt || _test == ge || _test == ne) ? TypeInt::ONE : TypeInt::ZERO;\n@@ -1332,3 +1174,19 @@\n-  if( CC == TypeInt::CC_LE ) {\n-    if( _test == le ) return TypeInt::ONE;\n-    if( _test == gt ) return TypeInt::ZERO;\n+\n+  if (cc == TypeInt::CC_LE) {\n+    if (_test == le) {\n+      return TypeInt::ONE;\n+    } else if (_test == gt) {\n+      return TypeInt::ZERO;\n+    }\n+  } else if (cc == TypeInt::CC_GE) {\n+    if (_test == ge) {\n+      return TypeInt::ONE;\n+    } else if (_test == lt) {\n+      return TypeInt::ZERO;\n+    }\n+  } else if (cc == TypeInt::CC_NE) {\n+    if (_test == ne) {\n+      return TypeInt::ONE;\n+    } else if (_test == eq) {\n+      return TypeInt::ZERO;\n+    }\n@@ -1445,2 +1303,2 @@\n-        const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w);\n-        const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w);\n+        const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w)->is_int();\n+        const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w)->is_int();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":130,"deletions":272,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n+constexpr juint SMALLINT = 3;  \/\/ a value too insignificant to consider widening\n@@ -470,16 +470,18 @@\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::BOOL    = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin)->is_int();  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin)->is_int();  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin)->is_int();  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin)->is_int();  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE   = TypeInt::make(-1, 1, 1, -1, 0, 1, WidenMin)->is_int();\n+  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin)->is_int();\n+  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin)->is_int();  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE    = TypeInt::make(-128, 127,    WidenMin)->is_int(); \/\/ Bytes\n+  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin)->is_int(); \/\/ Unsigned Bytes\n+  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin)->is_int(); \/\/ Java chars\n+  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin)->is_int(); \/\/ Java shorts\n+  TypeInt::NON_ZERO= TypeInt::make(min_jint, max_jint, 1, -1, 0, 0, WidenMin)->is_int();\n+  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin)->is_int(); \/\/ Non-neg values\n+  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin)->is_int(); \/\/ Positive values\n+  TypeInt::INT     = TypeInt::make(min_jint, max_jint, WidenMax)->is_int(); \/\/ 32-bit integers\n+  TypeInt::SYMINT  = TypeInt::make(-max_jint, max_jint, WidenMin)->is_int(); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -500,4 +502,6 @@\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n+  TypeLong::NON_ZERO= TypeLong::make(min_jlong, max_jlong, 1, -1, 0, 0, WidenMin)->is_long();\n+  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin)->is_long(); \/\/ Non-neg values\n+  TypeLong::NEG     = TypeLong::make(min_jlong, -1, WidenMin)->is_long();\n+  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax)->is_long(); \/\/ 64-bit integers\n+  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin)->is_long();\n+  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin)->is_long();\n@@ -1511,1 +1515,1 @@\n-const TypeInteger* TypeInteger::make(jlong lo, jlong hi, int w, BasicType bt) {\n+const Type* TypeInteger::make(jlong lo, jlong hi, int w, BasicType bt) {\n@@ -1559,26 +1563,87 @@\n-\/\/=============================================================================\n-\/\/ Convenience common pre-built types.\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n+template <class T>\n+static bool adjust_bounds_from_bits(bool& empty, T& lo, T& hi, T zeros, T ones) {\n+  static_assert(std::is_unsigned<T>::value, \"\");\n+\n+  auto adjust_lo = [](T lo, T zeros, T ones) {\n+    constexpr size_t W = sizeof(T) * 8;\n+    T zero_violation = lo & zeros;\n+    T one_violation = ~lo & ones;\n+    if (zero_violation == 0 && one_violation == 0) {\n+      return lo;\n+    }\n+\n+    if (zero_violation < one_violation) {\n+      \/\/ Align the last violation of ones unset all the lower bits\n+      \/\/ so we don't care about violations of zeros\n+      juint last_violation = W - 1 - count_leading_zeros(one_violation);\n+      T alignment = T(1) << last_violation;\n+      lo = (lo & -alignment) + alignment;\n+      return lo | ones;\n+    }\n+\n+    \/\/ Suppose lo = 00110010, zeros = 01010010, ones = 10001000\n+    \/\/ Since the 4-th bit must be 0, we need to align up the lower bound.\n+    \/\/ This results in lo = 01000000, but then the 6-th bit does not match,\n+    \/\/ align up again gives us 10000000.\n+    \/\/ We can align up directly to 10000000 by finding the first place after\n+    \/\/ the highest mismatch such that both the corresponding bits are unset.\n+    \/\/ Since all bits lower than the alignment are unset we don't need to\n+    \/\/ align for the violations of ones anymore.\n+    juint last_violation = W - 1 - count_leading_zeros(zero_violation);\n+    T find_mask = std::numeric_limits<T>::max() << last_violation;\n+    T either = lo | zeros;\n+    T tmp = ~either & find_mask;\n+    T alignment = tmp & (-tmp);\n+    lo = (lo & -alignment) + alignment;\n+    return lo | ones;\n+  };\n+\n+  T new_lo = adjust_lo(lo, zeros, ones);\n+  if (new_lo < lo) {\n+    empty = true;\n+    return true;\n+  }\n+\n+  T new_hi = ~adjust_lo(~hi, ones, zeros);\n+  if (new_hi > hi) {\n+    empty = true;\n+    return true;\n+  }\n+  bool progress = (new_lo != lo) || (new_hi != hi);\n+  lo = new_lo;\n+  hi = new_hi;\n+  empty = lo > hi;\n+  return progress;\n+}\n+\n+template <class T>\n+static bool adjust_bits_from_bounds(bool& empty, T& zeros, T& ones, T lo, T hi) {\n+  static_assert(std::is_unsigned<T>::value, \"\");\n+  T mismatch = lo ^ hi;\n+  T match_mask = mismatch == 0 ? std::numeric_limits<T>::max()\n+                               : ~(std::numeric_limits<T>::max() >> count_leading_zeros(mismatch));\n+  T new_zeros = zeros | (match_mask &~ lo);\n+  T new_ones = ones | (match_mask & lo);\n+  bool progress = (new_zeros != zeros) || (new_ones != ones);\n+  zeros = new_zeros;\n+  ones = new_ones;\n+  empty = ((zeros & ones) != 0);\n+  return progress;\n+}\n+\n+template <class T>\n+static void normalize_constraints_simple(bool& empty, T& lo, T& hi, T& zeros, T& ones) {\n+  adjust_bits_from_bounds(empty, zeros, ones, lo, hi);\n+  if (empty) {\n+    return;\n+  }\n+  while (true) {\n+    bool progress = adjust_bounds_from_bits(empty, lo, hi, zeros, ones);\n+    if (!progress || empty) {\n+      return;\n+    }\n+    progress = adjust_bits_from_bounds(empty, zeros, ones, lo, hi);\n+    if (!progress || empty) {\n+      return;\n+    }\n+  }\n@@ -1587,3 +1652,123 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+template <class T, class U>\n+static void normalize_constraints(bool& empty, T& lo, T& hi, U& ulo, U& uhi, U& zeros, U& ones) {\n+  static_assert(std::is_signed<T>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(sizeof(T) == sizeof(U), \"\");\n+\n+  if (lo > hi || ulo > uhi || (zeros & ones) != 0) {\n+    empty = true;\n+    return;\n+  }\n+\n+  if (T(ulo) > T(uhi)) {\n+    if (T(uhi) < lo) {\n+      uhi = std::numeric_limits<T>::max();\n+    } else if (T(ulo) > hi) {\n+      ulo = std::numeric_limits<T>::min();\n+    }\n+  }\n+\n+  if (T(ulo) <= T(uhi)) {\n+    ulo = MAX2<T>(ulo, lo);\n+    uhi = MIN2<T>(uhi, hi);\n+    if (ulo > uhi) {\n+      empty = true;\n+      return;\n+    }\n+\n+    normalize_constraints_simple(empty, ulo, uhi, zeros, ones);\n+    lo = ulo;\n+    hi = uhi;\n+    return;\n+  }\n+\n+  bool empty1 = false;\n+  U lo1 = lo;\n+  U hi1 = uhi;\n+  U zeros1 = zeros;\n+  U ones1 = ones;\n+  normalize_constraints_simple(empty1, lo1, hi1, zeros1, ones1);\n+\n+  bool empty2 = false;\n+  U lo2 = ulo;\n+  U hi2 = hi;\n+  U zeros2 = zeros;\n+  U ones2 = ones;\n+  normalize_constraints_simple(empty2, lo2, hi2, zeros2, ones2);\n+\n+  if (empty1 & empty2) {\n+    empty = true;\n+  } else if (empty1) {\n+    lo = lo2;\n+    hi = hi2;\n+    ulo = lo2;\n+    uhi = hi2;\n+    zeros = zeros2;\n+    ones = ones2;\n+  } else if (empty2) {\n+    lo = lo1;\n+    hi = hi1;\n+    ulo = lo1;\n+    uhi = hi1;\n+    zeros = zeros1;\n+    ones = ones1;\n+  } else {\n+    lo = lo1;\n+    hi = hi2;\n+    ulo = lo2;\n+    uhi = hi1;\n+    zeros = zeros1 & zeros2;\n+    ones = ones1 & ones2;\n+  }\n+}\n+\n+#ifdef ASSERT\n+template <class T, class U>\n+static void verify_constraints(T lo, T hi, U ulo, U uhi, U zeros, U ones) {\n+  static_assert(std::is_signed<T>::value, \"\");\n+  static_assert(std::is_unsigned<U>::value, \"\");\n+  static_assert(sizeof(T) == sizeof(U), \"\");\n+\n+  \/\/ Assert that the bounds cannot be further tightened\n+  assert(lo <= hi && U(lo) >= ulo && U(lo) <= uhi && (lo & zeros) == 0 && (~lo & ones) == 0, \"\");\n+  assert(hi >= lo && U(hi) >= ulo && U(hi) <= uhi && (hi & zeros) == 0 && (~hi & ones) == 0, \"\");\n+  assert(T(ulo) >= lo && T(ulo) <= hi && ulo <= uhi && (ulo & zeros) == 0 && (~ulo & ones) == 0, \"\");\n+  assert(T(uhi) >= lo && T(uhi) <= hi && uhi >= ulo && (uhi & zeros) == 0 && (~uhi & ones) == 0, \"\");\n+\n+  \/\/ Assert that the bits cannot be further tightened\n+  if (U(lo) == ulo) {\n+    bool empty = false;\n+    assert(!adjust_bits_from_bounds(empty, zeros, ones, ulo, uhi), \"\");\n+  } else {\n+    bool empty1 = false;\n+    U lo1 = lo;\n+    U hi1 = uhi;\n+    U zeros1 = zeros;\n+    U ones1 = ones;\n+    adjust_bits_from_bounds(empty1, zeros1, ones1, lo1, hi1);\n+    assert(!empty1, \"\");\n+    assert(!adjust_bounds_from_bits(empty1, lo1, hi1, zeros1, ones1), \"\");\n+\n+    bool empty2 = false;\n+    U lo2 = ulo;\n+    U hi2 = hi;\n+    U zeros2 = zeros;\n+    U ones2 = ones;\n+    adjust_bits_from_bounds(empty2, zeros2, ones2, lo2, hi2);\n+    assert(!empty2, \"\");\n+    assert(!adjust_bounds_from_bits(empty2, lo2, hi2, zeros2, ones2), \"\");\n+\n+    assert((zeros1 & zeros2) == zeros && (ones1 & ones2) == ones, \"\");\n+  }\n+}\n+#endif\n+\n+\/\/ The result is tuned down by one since we do not have empty type\n+\/\/ and this is not required to be accurate\n+template <class T, class U>\n+static U cardinality_from_bounds(T lo, T hi, U ulo, U uhi) {\n+  if (U(lo) == ulo) {\n+    return uhi - ulo;\n+  }\n+\n+  return uhi - U(lo) + U(hi) - ulo + 1;\n@@ -1592,1 +1777,2 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n+template <class T, class U>\n+static int normalize_widen(T lo, T hi, U ulo, U uhi, U zeros, U ones, int w) {\n@@ -1595,6 +1781,8 @@\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+  if (cardinality_from_bounds(lo, hi, ulo, uhi) <= SMALLINT) {\n+    return Type::WidenMin;\n+  }\n+  if (lo == std::numeric_limits<T>::min() && hi == std::numeric_limits<T>::max() &&\n+      ulo == std::numeric_limits<U>::min() && uhi == std::numeric_limits<U>::max() &&\n+      zeros == 0 && ones == 0) {\n+    \/\/ bottom type\n+    return Type::WidenMax;\n@@ -1605,3 +1793,187 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+template <class CT>\n+static bool int_type_equal(const CT* t1, const CT* t2) {\n+  return t1->_lo == t2->_lo && t1->_hi == t2->_hi && t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n+         t1->_zeros == t2->_zeros && t1->_ones == t2->_ones;\n+}\n+\n+template <class CT>\n+static bool int_type_subset(const CT* super, const CT* sub) {\n+  return super->_lo <= sub->_lo && super->_hi >= sub->_hi && super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n+         (super->_zeros &~ sub->_zeros) == 0 && (super->_ones &~ sub->_ones) == 0;\n+}\n+\n+\/\/ Called in PhiNode::Value during CCP, monotically widen the value set, do so rigorously\n+\/\/ first, after WidenMax attempts, if the type has still not converged we speed up the\n+\/\/ convergence by abandoning the bounds\n+template <class CT>\n+static const Type* int_type_widen(const CT* nt, const CT* ot, const CT* lt, const CT* bot) {\n+  using T = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+  if (ot == nullptr) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no widening\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy contains new, then we probably widened too far & dropped to\n+  \/\/ bottom. Return the wider fellow.\n+  if (int_type_subset(ot, nt)) {\n+    return ot;\n+  }\n+\n+  \/\/ Neither contains each other, weird?\n+  \/\/ fatal(\"Integer value range is not subset\");\n+  \/\/ return this;\n+  if (!int_type_subset(nt, ot)) {\n+    return bot;\n+  }\n+\n+  \/\/ If old guy was a constant, do not bother\n+  if (ot->singleton()) {\n+    return nt;\n+  }\n+\n+  \/\/ If new guy contains old, then we widened\n+  \/\/ If new guy is already wider than old, no widening\n+  if (nt->_widen > ot->_widen) {\n+    return nt;\n+  }\n+\n+  if (nt->_widen < Type::WidenMax) {\n+    \/\/ Returned widened new guy\n+    return CT::make(nt->_lo, nt->_hi, nt->_ulo, nt->_uhi, nt->_zeros, nt->_ones, nt->_widen + 1);\n+  }\n+\n+  \/\/ Speed up the convergence by abandoning the bounds, there are only a couple of bits so\n+  \/\/ they converge fast\n+  T min = std::numeric_limits<T>::min();\n+  T max = std::numeric_limits<T>::max();\n+  U umin = std::numeric_limits<U>::min();\n+  U umax = std::numeric_limits<U>::max();\n+  U zeros = nt->_zeros;\n+  U ones = nt->_ones;\n+  if (lt != nullptr) {\n+    min = lt->_lo;\n+    max = lt->_hi;\n+    umin = lt->_ulo;\n+    umax = lt->_uhi;\n+    zeros |= lt->_zeros;\n+    ones |= lt->_ones;\n+  }\n+  return CT::make(min, max, umin, umax, zeros, ones, Type::WidenMax);\n+}\n+\n+\/\/ Called by PhiNode::Value during GVN, monotonically narrow the value set, only\n+\/\/ narrow if the bits change or if the bounds are tightened enough to avoid\n+\/\/ slow convergence\n+template <class CT>\n+static const Type* int_type_narrow(const CT* nt, const CT* ot, const CT* bot) {\n+  using T = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+\n+  if (nt->singleton()) {\n+    return nt;\n+  }\n+  if (ot == nullptr) {\n+    return ot;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no narrowing\n+  if (int_type_equal(nt, ot)) {\n+    return ot;\n+  }\n+\n+  \/\/ If old guy was maximum range, allow the narrowing\n+  if (int_type_equal(ot, bot)) {\n+    return nt;\n+  }\n+\n+  \/\/ Doesn't narrow; pretty weird\n+  if (!int_type_subset(ot, nt)) {\n+    return nt;\n+  }\n+\n+  \/\/ Bits change\n+  if (ot->_zeros != nt->_zeros || ot->_ones != nt->_ones) {\n+    return nt;\n+  }\n+\n+  \/\/ Only narrow if the range shrinks a lot\n+  U oc = cardinality_from_bounds(ot->_lo, ot->_hi, ot->_ulo, ot->_uhi);\n+  U nc = cardinality_from_bounds(nt->_lo, nt->_hi, nt->_ulo, nt->_uhi);\n+  return (nc > (oc >> 1) + (SMALLINT * 2)) ? ot : nt;\n+}\n+\n+\/\/=============================================================================\n+\/\/ Convenience common pre-built types.\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+\n+TypeInt::TypeInt(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual)\n+  : TypeInteger(Int, normalize_widen(lo, hi, ulo, uhi, zeros, ones, w), dual),\n+    _lo(lo), _hi(hi), _ulo(ulo), _uhi(uhi), _zeros(zeros), _ones(ones) {\n+  DEBUG_ONLY(verify_constraints(lo, hi, ulo, uhi, zeros, ones));\n+}\n+\n+const Type* TypeInt::make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual) {\n+  bool empty = false;\n+  normalize_constraints(empty, lo, hi, ulo, uhi, zeros, ones);\n+  if (empty) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n+  }\n+  return (new TypeInt(lo, hi, ulo, uhi, zeros, ones, w, dual))->hashcons()->is_int();\n+}\n+\n+const TypeInt* TypeInt::make(jint lo) {\n+  return (new TypeInt(lo, lo, lo, lo, ~lo, lo, WidenMin, false))->hashcons()->is_int();\n+}\n+\n+const Type* TypeInt::make(jint lo, jint hi, int w) {\n+  return make(lo, hi, 0, max_juint, 0, 0, w);\n+}\n+\n+const Type* TypeInt::make_bits(juint zeros, juint ones, int w) {\n+  return make(min_jint, max_jint, 0, max_juint, zeros, ones, w);\n+}\n+\n+const Type* TypeInt::make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w) {\n+  return make(lo, hi, ulo, uhi, zeros, ones, w, false);\n+}\n+\n+bool TypeInt::contains(jint i) const {\n+  juint u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n+         (u & _zeros) == 0 && (~u & _ones) == 0;\n+}\n+\n+bool TypeInt::contains(const TypeInt* t) const {\n+  return int_type_subset(this, t);\n+}\n+\n+bool TypeInt::properly_contains(const TypeInt* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n@@ -1614,1 +1986,1 @@\n-const Type *TypeInt::xmeet( const Type *t ) const {\n+const Type* TypeInt::xmeet(const Type* t) const {\n@@ -1616,1 +1988,3 @@\n-  if( this == t ) return this;  \/\/ Meeting same type?\n+  if (this == t) {\n+    return this;\n+  }\n@@ -1649,2 +2023,10 @@\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+  const TypeInt* i = t->is_int();\n+  assert(_dual == i->_dual, \"\");\n+  if (!_dual) {\n+    \/\/ meet\n+    return make(MIN2(_lo, i->_lo), MAX2(_hi, i->_hi), MIN2(_ulo, i->_ulo), MAX2(_uhi, i->_uhi),\n+                _zeros & i->_zeros, _ones & i->_ones, MAX2(_widen, i->_widen), false);\n+  }\n+  \/\/ join\n+  return make(MAX2(_lo, i->_lo), MIN2(_hi, i->_hi), MAX2(_ulo, i->_ulo), MIN2(_uhi, i->_uhi),\n+              _zeros | i->_zeros, _ones | i->_ones, MIN2(_widen, i->_widen), true);\n@@ -1653,5 +2035,2 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(_lo, _hi, _ulo, _uhi, _zeros, _ones, _widen, !_dual);\n@@ -1660,52 +2039,3 @@\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n-\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_dual, \"\");\n+  return int_type_widen(this, old->isa_int(), limit->isa_int(), TypeInt::INT);\n@@ -1714,27 +2044,4 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n-\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n-\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n-\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n-\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_dual, \"\");\n+  if (old == nullptr) {\n+    return this;\n@@ -1743,1 +2050,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_int(), TypeInt::INT);\n@@ -1747,1 +2054,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_dual, \"\");\n@@ -1749,1 +2057,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -1751,0 +2059,2 @@\n+  }\n+  assert(!ft->_dual, \"\");\n@@ -1754,1 +2064,2 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(ft->_lo, ft->_hi, ft->_ulo, ft->_uhi,\n+                        ft->_zeros, ft->_ones, this->_widen, false))->hashcons();\n@@ -1761,3 +2072,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n@@ -1769,1 +2080,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Int;\n@@ -1778,43 +2090,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -1825,1 +2094,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -1829,1 +2098,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -1834,10 +2103,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -1845,2 +2116,4 @@\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n+TypeLong::TypeLong(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual)\n+  : TypeInteger(Long, normalize_widen(lo, hi, ulo, uhi, zeros, ones, w), dual),\n+    _lo(lo), _hi(hi), _ulo(ulo), _uhi(uhi), _zeros(zeros), _ones(ones) {\n+  DEBUG_ONLY(verify_constraints(lo, hi, ulo, uhi, zeros, ones));\n@@ -1849,3 +2122,7 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n+const Type* TypeLong::make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual) {\n+  bool empty = false;\n+  normalize_constraints(empty, lo, hi, ulo, uhi, zeros, ones);\n+  if (empty) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n+  }\n+  return (new TypeLong(lo, hi, ulo, uhi, zeros, ones, w, dual))->hashcons()->is_long();\n@@ -1854,11 +2131,2 @@\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n-  }\n-  return w;\n+const TypeLong* TypeLong::make(jlong lo ) {\n+  return (new TypeLong(lo, lo, lo, lo, ~lo, lo, WidenMin, false))->hashcons()->is_long();\n@@ -1867,3 +2135,2 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const Type* TypeLong::make(jlong lo, jlong hi, int w) {\n+  return make(lo, hi, 0, max_julong, 0, 0, w);\n@@ -1872,0 +2139,21 @@\n+const Type* TypeLong::make_bits(julong zeros, julong ones, int w) {\n+  return make(min_jlong, max_jlong, 0, max_julong, zeros, ones, w);\n+}\n+\n+const Type* TypeLong::make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w) {\n+  return make(lo, hi, ulo, uhi, zeros, ones, w, false);\n+}\n+\n+bool TypeLong::contains(jlong i) const {\n+  julong u = i;\n+  return i >= _lo && i <= _hi && u >= _ulo && u <= _uhi &&\n+         (u & _zeros) == 0 && (~u & _ones) == 0;\n+}\n+\n+bool TypeLong::contains(const TypeLong* t) const {\n+  return int_type_subset(this, t);\n+}\n+\n+bool TypeLong::properly_contains(const TypeLong* t) const {\n+  return int_type_subset(this, t) && !int_type_equal(this, t);\n+}\n@@ -1912,2 +2200,10 @@\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+  const TypeLong* i = t->is_long();\n+  assert(_dual == i->_dual, \"\");\n+  if (!_dual) {\n+    \/\/ meet\n+    return make(MIN2(_lo, i->_lo), MAX2(_hi, i->_hi), MIN2(_ulo, i->_ulo), MAX2(_uhi, i->_uhi),\n+                _zeros & i->_zeros, _ones & i->_ones, MAX2(_widen, i->_widen), false);\n+  }\n+  \/\/ join\n+  return make(MAX2(_lo, i->_lo), MIN2(_hi, i->_hi), MAX2(_ulo, i->_ulo), MIN2(_uhi, i->_uhi),\n+              _zeros | i->_zeros, _ones | i->_ones, MIN2(_widen, i->_widen), true);\n@@ -1916,5 +2212,2 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(_lo, _hi, _ulo, _uhi, _zeros, _ones, _widen, !_dual);\n@@ -1923,55 +2216,3 @@\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n-\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_dual, \"\");\n+  return int_type_widen(this, old->isa_long(), limit->isa_long(), TypeLong::LONG);\n@@ -1980,27 +2221,4 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n-\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n-\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n-\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n-\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_dual, \"\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2009,1 +2227,1 @@\n-  return this;\n+  return int_type_narrow(this, old->isa_long(), TypeLong::LONG);\n@@ -2013,1 +2231,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_dual, \"\");\n@@ -2015,1 +2234,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2017,0 +2236,2 @@\n+  }\n+  assert(!ft->_dual, \"\");\n@@ -2020,1 +2241,2 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(ft->_lo, ft->_hi, ft->_ulo, ft->_uhi,\n+                         ft->_zeros, ft->_ones, this->_widen, false))->hashcons();\n@@ -2027,3 +2249,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return int_type_equal(this, r) && _widen == r->_widen && _dual == r->_dual;\n@@ -2035,1 +2257,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_zeros + (uint)_ones + (uint)_widen + (uint)_dual + (uint)Type::Long;\n@@ -2044,0 +2267,11 @@\n+\/\/------------------------------singleton--------------------------------------\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ constants\n+bool TypeLong::singleton(void) const {\n+  return _lo == _hi;\n+}\n+\n+bool TypeLong::empty(void) const {\n+  return false;\n+}\n+\n@@ -2045,1 +2279,0 @@\n-\/\/ Dump TypeLong\n@@ -2047,7 +2280,12 @@\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n+template <class T>\n+static const char* intnamenear(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n+  if (n < origin) {\n+    if (n <= origin - 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s-\" INT32_FORMAT, xname, jint(origin - n));\n+  } else if (n > origin) {\n+    if (n >= origin + 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s+\" INT32_FORMAT, xname, jint(n - origin));\n@@ -2060,0 +2298,30 @@\n+static const char* intname(char* buf, size_t buf_size, jint n) {\n+  const char* str = intnamenear<jint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jint>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n+  return buf;\n+}\n+\n+static const char* uintname(char* buf, size_t buf_size, juint n) {\n+  const char* str = intnamenear<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<juint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, UINT32_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n@@ -2061,10 +2329,2 @@\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n+  const char* str = intnamenear<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n@@ -2072,1 +2332,4 @@\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n+  }\n+\n+  str = intnamenear<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n@@ -2074,1 +2337,4 @@\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n+  }\n+\n+  str = intnamenear<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n@@ -2076,2 +2342,13 @@\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n+  }\n+\n+  str = intnamenear<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<jlong>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n@@ -2081,12 +2358,15 @@\n-void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n-    st->print(\"long\");\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n+static const char* ulongname(char* buf, size_t buf_size, julong n) {\n+  const char* str = intnamenear<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = intnamenear<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n@@ -2094,2 +2374,7 @@\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n+  str = intnamenear<julong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JULONG_FORMAT\"u\", n);\n+  return buf;\n@@ -2097,1 +2382,0 @@\n-#endif\n@@ -2099,5 +2383,20 @@\n-\/\/------------------------------singleton--------------------------------------\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n-\/\/ constants\n-bool TypeLong::singleton(void) const {\n-  return _lo >= _hi;\n+template <class U>\n+static const char* bitname(char* buf, size_t buf_size, U zeros, U ones) {\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  if (buf_size < W + 1) {\n+    return \"#####\";\n+  }\n+\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << (W - 1 - i);\n+    if ((zeros & mask) != 0) {\n+      buf[i] = '0';\n+    } else if ((ones & mask) != 0) {\n+      buf[i] = '1';\n+    } else {\n+      buf[i] = '*';\n+    }\n+  }\n+  buf[W] = 0;\n+  return buf;\n@@ -2106,2 +2405,42 @@\n-bool TypeLong::empty(void) const {\n-  return _lo > _hi;\n+void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n+  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n+  if (int_type_equal(this, TypeInt::INT)) {\n+    st->print(\"int\");\n+  } else if (is_con()) {\n+    st->print(\"int:%s\", intname(buf1, sizeof(buf1), get_con()));\n+  } else if (int_type_equal(this, TypeInt::BOOL)) {\n+    st->print(\"bool\");\n+  } else if (int_type_equal(this, TypeInt::BYTE)) {\n+    st->print(\"byte\");\n+  } else if (int_type_equal(this, TypeInt::CHAR)) {\n+    st->print(\"char\");\n+  } else if (int_type_equal(this, TypeInt::SHORT)) {\n+    st->print(\"short\");\n+  } else {\n+    st->print(\"int:%s..%s ^ %s..%s, bits:%s\",\n+              intname(buf1, sizeof(buf1), _lo), intname(buf2, sizeof(buf2), _hi),\n+              uintname(buf3, sizeof(buf3), _ulo), uintname(buf4, sizeof(buf4), _uhi),\n+              bitname(buf5, sizeof(buf5), _zeros, _ones));\n+  }\n+\n+  if (_widen > 0 && this != TypeInt::INT) {\n+    st->print(\", widen: %d\", _widen);\n+  }\n+}\n+\n+void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n+  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n+  if (int_type_equal(this, TypeLong::LONG)) {\n+    st->print(\"long\");\n+  } else if (is_con()) {\n+    st->print(\"long:%s\", longname(buf1, sizeof(buf1), get_con()));\n+  } else {\n+    st->print(\"long:%s..%s ^ %s..%s, bits:%s\",\n+              longname(buf1, sizeof(buf1), _lo), longname(buf2,sizeof(buf2),  _hi),\n+              ulongname(buf3, sizeof(buf3), _ulo), ulongname(buf4, sizeof(buf4), _uhi),\n+              bitname(buf5, sizeof(buf5), _zeros, _ones));\n+  }\n+\n+  if (_widen > 0 && this != TypeLong::LONG) {\n+    st->print(\", widen: %d\", _widen);\n+  }\n@@ -2109,0 +2448,1 @@\n+#endif\n@@ -2331,1 +2671,1 @@\n-    return TypeInt::make(size->_lo, size->_hi, Type::WidenMin);\n+    return TypeInt::make(size->_lo, size->_hi, Type::WidenMin)->is_int();\n@@ -2361,1 +2701,6 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      return size;\n+    }\n@@ -2363,2 +2708,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable);\n+                         isize, _stable && a->_stable);\n@@ -4771,1 +5115,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -4773,1 +5117,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -4775,1 +5120,2 @@\n-  return TypeInt::make(lo, hi, Type::WidenMin);\n+  }\n+  return TypeInt::make(lo, hi, Type::WidenMin)->is_int();\n@@ -4936,1 +5282,5 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":730,"deletions":380,"binary":false,"changes":1110,"status":"modified"},{"patch":"@@ -552,1 +552,4 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _dual(dual), _widen(w) {}\n+\n+  \/\/ Use to compute join of 2 sets\n+  const bool _dual;\n@@ -563,1 +566,1 @@\n-  static const TypeInteger* make(jlong lo, jlong hi, int w, BasicType bt);\n+  static const Type* make(jlong lo, jlong hi, int w, BasicType bt);\n@@ -577,1 +580,2 @@\n-  TypeInt( jint lo, jint hi, int w );\n+  TypeInt(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual);\n+  static const Type* make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w, bool dual);\n@@ -579,1 +583,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -583,1 +587,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -588,0 +592,2 @@\n+  const juint _ulo, _uhi;\n+  const juint _zeros, _ones;\n@@ -589,1 +595,3 @@\n-  static const TypeInt *make(jint lo);\n+  static const TypeInt* cast(const Type* t) { return t->is_int(); }\n+  static const TypeInt* try_cast(const Type* t) { return t->isa_int(); }\n+  static const TypeInt* make(jint lo);\n@@ -591,1 +599,3 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const Type* make(jint lo, jint hi, int w);\n+  static const Type* make_bits(juint zeros, juint ones, int w);\n+  static const Type* make(jint lo, jint hi, juint ulo, juint uhi, juint zeros, juint ones, int w);\n@@ -594,1 +604,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -596,1 +606,4 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n+  bool properly_contains(const TypeInt* t) const;\n@@ -598,1 +611,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -600,4 +613,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -610,21 +623,23 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -643,1 +658,2 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+  TypeLong(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual);\n+  static const Type* make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w, bool dual);\n@@ -646,1 +662,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -655,0 +671,2 @@\n+  const julong _ulo, _uhi;\n+  const julong _zeros, _ones;\n@@ -656,1 +674,3 @@\n-  static const TypeLong *make(jlong lo);\n+  static const TypeLong* cast(const Type* t) { return t->is_long(); }\n+  static const TypeLong* try_cast(const Type* t) { return t->isa_long(); }\n+  static const TypeLong* make(jlong lo);\n@@ -658,1 +678,3 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const Type* make(jlong lo, jlong hi, int w);\n+  static const Type* make_bits(julong zeros, julong ones, int w);\n+  static const Type* make(jlong lo, jlong hi, julong ulo, julong uhi, julong zeros, julong ones, int w);\n@@ -661,1 +683,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -664,0 +686,3 @@\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n+  bool properly_contains(const TypeLong* t) const;\n@@ -673,4 +698,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -678,10 +703,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":81,"deletions":54,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8267265\n+ * @bug 8267265 8315066\n@@ -48,1 +48,4 @@\n-                 \"test23\", \"test24\", \"test25\"})\n+                 \"test23\", \"test24\", \"test25\",\n+                 \"test26\", \"test27\", \"test28\",\n+                 \"test29\", \"test30\", \"test31\",\n+                 \"test32\"})\n@@ -93,0 +96,12 @@\n+        Asserts.assertEQ((a >> 2) + (b >> 2) >= Integer.MIN_VALUE >> 1 &&\n+                (a >> 2) + (b >> 2) < Integer.MAX_VALUE >> 1 ? 1 : 0, test26(a, b));\n+        Asserts.assertEQ((a >>> 1) + (b >>> 1) >= 0 ? 1 : 0, test27(a, b));\n+        Asserts.assertEQ(((a | Integer.MIN_VALUE) >>> 1) +\n+                ((b | Integer.MIN_VALUE) >>> 1) < -1 ? 1 : 0, test28(a, b));\n+        Asserts.assertEQ((Integer.compareUnsigned((a >>> 2) + (b >>> 2) + 1000, 1000) >= 0 &&\n+                          Integer.compareUnsigned((a >>> 2) + (b >>> 2) + 1000, Integer.MIN_VALUE + 1000) < 0) ? 1 : 0, test29(a, b));\n+        Asserts.assertEQ(Integer.compareUnsigned((a | (Integer.MIN_VALUE >>> 2)) +\n+                (b | (Integer.MIN_VALUE >>> 2)), Integer.MIN_VALUE >>> 1) >= 0 ? 1 : 0, test30(a, b));\n+        Asserts.assertEQ(Integer.compareUnsigned((a | Integer.MIN_VALUE) + ((b >>> 2) | Integer.MIN_VALUE),\n+                Integer.MIN_VALUE >> 1) < 0 ? 1 : 0, test31(a, b));\n+        Asserts.assertEQ(((a << 5) + (b << 5)) & 31     , test32(a, b));\n@@ -314,0 +329,56 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.RSHIFT_I})\n+    \/\/ Signed bounds\n+    public int test26(int a, int b) {\n+        int sum = (a >> 2) + (b >> 2);\n+        return sum >= Integer.MIN_VALUE >> 1 && sum < Integer.MAX_VALUE >> 1 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_I, \"1\", IRNode.URSHIFT_I, \"2\"})\n+    \/\/ Signed bounds cannot be inferred if overflow\n+    public int test27(int a, int b) {\n+        int sum = (a >>> 1) + (b >>> 1);\n+        return sum >= 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.URSHIFT_I})\n+    \/\/ Signed bounds, both lo and hi overflow\n+    public int test28(int a, int b) {\n+        int sum = ((a | Integer.MIN_VALUE) >>> 1) + ((b | Integer.MIN_VALUE) >>> 1);\n+        return sum < -1 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.URSHIFT_I})\n+    \/\/ Unsigned bounds\n+    public int test29(int a, int b) {\n+        int sum = (a >>> 2) + (b >>> 2) + 1000;\n+        return (Integer.compareUnsigned(sum, 1000) >= 0 &&\n+                Integer.compareUnsigned(sum, Integer.MIN_VALUE + 1000) < 0) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n+    \/\/ Unsigned bounds cannot be inferred if overflow\n+    public int test30(int a, int b) {\n+        int sum = (a | (Integer.MIN_VALUE >>> 2)) + (b | (Integer.MIN_VALUE >>> 2));\n+        return Integer.compareUnsigned(sum, Integer.MIN_VALUE >>> 1) >= 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.URSHIFT_I})\n+    \/\/ Unsigned bounds, both ulo and uhi overflow\n+    public int test31(int a, int b) {\n+        int sum = (a | Integer.MIN_VALUE) + ((b >>> 2) | Integer.MIN_VALUE);\n+        return Integer.compareUnsigned(sum, Integer.MIN_VALUE >> 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.LSHIFT_I})\n+    \/\/ Bits\n+    public int test32(int a, int b) {\n+        return ((a << 5) + (b << 5)) & 31;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddINodeIdealizationTests.java","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8267265\n+ * @bug 8267265 8315066\n@@ -48,1 +48,3 @@\n-                 \"test23\", \"test24\"})\n+                 \"test23\", \"test24\", \"test25\",\n+                 \"test26\", \"test27\", \"test28\",\n+                 \"test29\", \"test30\", \"test31\"})\n@@ -92,0 +94,11 @@\n+        Asserts.assertEQ((a >> 2) + (b >> 2) >= Long.MIN_VALUE >> 1 &&\n+                (a >> 2) + (b >> 2) < Long.MAX_VALUE >> 1 ? 1L : 0L, test25(a, b));\n+        Asserts.assertEQ((a >>> 1) + (b >>> 1) >= 0 ? 1L : 0L, test26(a, b));\n+        Asserts.assertEQ(((a | Long.MIN_VALUE) >>> 1) +\n+                ((b | Long.MIN_VALUE) >>> 1) < -1 ? 1L : 0L, test27(a, b));\n+        Asserts.assertEQ((Long.compareUnsigned((a >>> 2) + (b >>> 2) + 1000, 1000) >= 0 &&\n+                Long.compareUnsigned((a >>> 2) + (b >>> 2) + 1000, Long.MIN_VALUE + 1000) < 0) ? 1L : 0L, test28(a, b));\n+        Asserts.assertEQ(Long.compareUnsigned((a | (Long.MIN_VALUE >>> 2)) + (b | (Long.MIN_VALUE >>> 2)), Long.MIN_VALUE >>> 1) >= 0 ? 1L : 0L, test29(a, b));\n+        Asserts.assertEQ(Long.compareUnsigned((a | Long.MIN_VALUE) + ((b >>> 2) | Long.MIN_VALUE),\n+                Long.MIN_VALUE >> 1) < 0 ? 1L : 0L, test30(a, b));\n+        Asserts.assertEQ(((a << 5) + (b << 5)) & 31     , test31(a, b));\n@@ -309,0 +322,56 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.RSHIFT_L})\n+    \/\/ Signed bounds\n+    public long test25(long a, long b) {\n+        long sum = (a >> 2) + (b >> 2);\n+        return sum >= Long.MIN_VALUE >> 1 && sum < Long.MAX_VALUE >> 1 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_L, \"1\", IRNode.URSHIFT_L, \"2\"})\n+    \/\/ Signed bounds cannot be inferred if overflow\n+    public long test26(long a, long b) {\n+        long sum = (a >>> 1) + (b >>> 1);\n+        return sum >= 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.URSHIFT_L})\n+    \/\/ Signed bounds, both lo and hi overflow\n+    public long test27(long a, long b) {\n+        long sum = ((a | Long.MIN_VALUE) >>> 1) + ((b | Long.MIN_VALUE) >>> 1);\n+        return sum < -1 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.URSHIFT_L})\n+    \/\/ Unsigned bounds\n+    public long test28(long a, long b) {\n+        long sum = (a >>> 2) + (b >>> 2) + 1000;\n+        return (Long.compareUnsigned(sum, 1000) >= 0 &&\n+                Long.compareUnsigned(sum, Long.MIN_VALUE + 1000) < 0) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    \/\/ Unsigned bounds cannot be inferred if overflow\n+    public long test29(long a, long b) {\n+        long sum = (a | (Long.MIN_VALUE >>> 2)) + (b | (Long.MIN_VALUE >>> 2));\n+        return Long.compareUnsigned(sum, Long.MIN_VALUE >>> 1) >= 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.URSHIFT_L})\n+    \/\/ Unsigned bounds, both ulo and uhi overflow\n+    public long test30(long a, long b) {\n+        long sum = (a | Long.MIN_VALUE) + ((b >>> 2) | Long.MIN_VALUE);\n+        return Long.compareUnsigned(sum, Long.MIN_VALUE >> 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.LSHIFT_L})\n+    \/\/ Bits\n+    public long test31(long a, long b) {\n+        return ((a << 5) + (b << 5)) & 31;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":72,"deletions":3,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8297384\n+ * @bug 8297384 8315066\n@@ -41,1 +41,2 @@\n-    @Run(test = { \"test1\" })\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\"})\n@@ -44,0 +45,1 @@\n+        int b = RunInfo.getRandom().nextInt();\n@@ -48,4 +50,4 @@\n-        assertResult(0);\n-        assertResult(a);\n-        assertResult(min);\n-        assertResult(max);\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n@@ -55,1 +57,1 @@\n-    public void assertResult(int a) {\n+    public void assertResult(int a, int b) {\n@@ -57,0 +59,4 @@\n+        Asserts.assertEQ(b << 8, test2(a, b));\n+        Asserts.assertEQ(1, test3(a, b));\n+        Asserts.assertEQ(0, test4(a, b));\n+        Asserts.assertEQ(1, test5(a, b));\n@@ -66,0 +72,28 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_I, IRNode.OR_I})\n+    \/\/ All bits that can be unset in one operand is known to be unset in the other\n+    public int test2(int x, int y) {\n+        return (x | -256) & (y << 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_I, IRNode.OR_I})\n+    \/\/ Bits set in both are set in the result\n+    public int test3(int x, int y) {\n+        return ((x | 3) & (y | 101)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_I})\n+    \/\/ Bits unset in either are unset in the result\n+    public int test4(int x, int y) {\n+        return (x & (y & 6)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_I})\n+    \/\/ The unsigned value of the result is smaller than both operands\n+    public int test5(int x, int y) {\n+        return Integer.compareUnsigned(((byte)x + 150) & y, 300) < 0 ? 1 : 0;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndINodeIdealizationTests.java","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8315066\n+ * @summary Test that Ideal transformations of AndLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AndLNodeIdealizationTests\n+ *\/\n+public class AndLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEQ(b << 8, test1(a, b));\n+        Asserts.assertEQ(1L, test2(a, b));\n+        Asserts.assertEQ(0L, test3(a, b));\n+        Asserts.assertEQ(1L, test4(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_L, IRNode.OR_L})\n+    \/\/ All bits that can be unset in one operand is known to be unset in the other\n+    public long test1(long x, long y) {\n+        return (x | -256) & (y << 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_L, IRNode.OR_L})\n+    \/\/ Bits set in both are set in the result\n+    public long test2(long x, long y) {\n+        return ((x | 3) & (y | 101)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_L})\n+    \/\/ Bits unset in either are unset in the result\n+    public long test3(long x, long y) {\n+        return (x & (y & 6)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_L})\n+    \/\/ The unsigned value of the result is smaller than both operands\n+    public long test4(long x, long y) {\n+        return Long.compareUnsigned(((byte)x + 150L) & y, 300) < 0 ? 1 : 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndLNodeIdealizationTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- * @bug 8297384 8303238\n+ * @bug 8297384 8303238 8315066\n@@ -40,1 +40,4 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\", \"test6\",\n+                 \"test7\", \"test8\", \"test9\",\n+                 \"test10\", \"test11\"})\n@@ -44,2 +47,0 @@\n-        int c = RunInfo.getRandom().nextInt();\n-        int d = RunInfo.getRandom().nextInt();\n@@ -50,7 +51,4 @@\n-        assertResult(0);\n-        assertResult(a);\n-        assertResult(b);\n-        assertResult(c);\n-        assertResult(d);\n-        assertResult(min);\n-        assertResult(max);\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n@@ -60,1 +58,1 @@\n-    public void assertResult(int a) {\n+    public void assertResult(int a, int b) {\n@@ -69,0 +67,3 @@\n+        Asserts.assertEQ(1, test9(a, b));\n+        Asserts.assertEQ(1, test10(a, b));\n+        Asserts.assertEQ(0, test11(a, b));\n@@ -134,0 +135,21 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.CMP_I})\n+    \/\/ Signed bounds\n+    public int test9(int x, int y) {\n+        return (Math.max(Math.min(x, 100), -100) << (y & 8)) <= (100 << 8) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.CMP_U})\n+    \/\/ Unsigned bounds\n+    public int test10(int x, int y) {\n+        return Integer.compareUnsigned(Math.max(Math.min(x, 100), 0) << (y & 8), (100 << 8) + 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT_I, IRNode.AND_I})\n+    \/\/ Bits\n+    public int test11(int x, int y) {\n+        return (x << (y | 3)) & 7;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @bug 8303238\n+ * @bug 8303238 8315066\n@@ -40,1 +40,3 @@\n-    @Run(test = { \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test3\", \"test4\", \"test5\",\n+                 \"test6\", \"test7\", \"test8\",\n+                 \"test9\", \"test10\", \"test11\"})\n@@ -44,2 +46,0 @@\n-        long c = RunInfo.getRandom().nextLong();\n-        long d = RunInfo.getRandom().nextLong();\n@@ -50,7 +50,4 @@\n-        assertResult(0);\n-        assertResult(a);\n-        assertResult(b);\n-        assertResult(c);\n-        assertResult(d);\n-        assertResult(min);\n-        assertResult(max);\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n@@ -60,1 +57,1 @@\n-    public void assertResult(long a) {\n+    public void assertResult(long a, long b) {\n@@ -67,0 +64,3 @@\n+        Asserts.assertEQ(1L, test9(a, b));\n+        Asserts.assertEQ(1L, test10(a, b));\n+        Asserts.assertEQ(0L, test11(a, b));\n@@ -116,0 +116,21 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT_L, IRNode.CMP_L})\n+    \/\/ Signed bounds\n+    public long test9(long x, long y) {\n+        return ((long)Math.max(Math.min((int)x, 100), -100) << (y & 8)) <= (100 << 8) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT_L, IRNode.CMP_UL})\n+    \/\/ Unsigned bounds\n+    public long test10(long x, long y) {\n+        return Long.compareUnsigned((long)Math.max(Math.min((int)x, 100), 0) << (y & 8), (100 << 8) + 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT_L, IRNode.AND_L})\n+    \/\/ Bits\n+    public long test11(long x, long y) {\n+        return (x << (y | 3)) & 7;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @bug 8290248 8312547\n+ * @bug 8290248 8312547 8315066\n@@ -292,0 +292,18 @@\n+    @Run(test = {\"testMaxSigned\",\n+                 \"testMaxBits\",\n+                 \"testMinSigned\",\n+                 \"testMinBits\"})\n+    public void runConstantPropagation() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertConstantPropagation(a, b);\n+        assertConstantPropagation(0, a);\n+        assertConstantPropagation(a, 0);\n+        assertConstantPropagation(a, min);\n+        assertConstantPropagation(min, a);\n+        assertConstantPropagation(a, max);\n+        assertConstantPropagation(max, a);\n+    }\n@@ -293,0 +311,31 @@\n+    @DontCompile\n+    public void assertConstantPropagation(int a, int b) {\n+        Asserts.assertEQ(1, testMaxSigned(a, b));\n+        Asserts.assertEQ(1, testMaxBits(a, b));\n+        Asserts.assertEQ(1, testMinSigned(a, b));\n+        Asserts.assertEQ(1, testMinBits(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX_I, IRNode.CMP_I})\n+    public int testMaxSigned(int x, int y) {\n+        return Math.max((x >>> 1) | 19, y) >= 19 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MAX_I, IRNode.CMP_I})\n+    public int testMaxBits(int x, int y) {\n+        return Math.max(x | 1, y | 17) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MIN_I, IRNode.CMP_I})\n+    public int testMinSigned(int x, int y) {\n+        return Math.min(x | Integer.MIN_VALUE, y) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MIN_I, IRNode.CMP_I})\n+    public int testMinBits(int x, int y) {\n+        return Math.min(x | 1, y | 17) & 1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MaxMinINodeIdealizationTests.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8315066\n+ * @summary Test that Ideal transformations of OrINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.OrINodeIdealizationTests\n+ *\/\n+public class OrINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b) {\n+        Asserts.assertEQ(b | 15, test1(a, b));\n+        Asserts.assertEQ(0, test2(a, b));\n+        Asserts.assertEQ(1, test3(a, b));\n+        Asserts.assertEQ(1, test4(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_I})\n+    @IR(counts = {IRNode.OR_I, \"1\"})\n+    \/\/ All bits that can be set in one operand is known to be set in the other\n+    public int test1(int x, int y) {\n+        return (x & 7) | (y | 15);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR_I, IRNode.AND_I})\n+    \/\/ Bits unset in both are unset in the result\n+    public int test2(int x, int y) {\n+        return ((x & -2) | (y & -6)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR_I})\n+    \/\/ Bits set in either are set in the result\n+    public int test3(int x, int y) {\n+        return (x | (y | 5)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR_I})\n+    \/\/ The unsigned value of the result is larger than both operands\n+    public int test4(int x, int y) {\n+        return Integer.compareUnsigned(((byte)x + 150) | y, 20) > 0 ? 1 : 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/OrINodeIdealizationTests.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8315066\n+ * @summary Test that Ideal transformations of OrLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.OrLNodeIdealizationTests\n+ *\/\n+public class OrLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEQ(b | 15, test1(a, b));\n+        Asserts.assertEQ(0L, test2(a, b));\n+        Asserts.assertEQ(1L, test3(a, b));\n+        Asserts.assertEQ(1L, test4(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.AND_L})\n+    @IR(counts = {IRNode.OR_L, \"1\"})\n+    \/\/ All bits that can be set in one operand is known to be set in the other\n+    public long test1(long x, long y) {\n+        return (x & 7) | (y | 15);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR_L, IRNode.AND_L})\n+    \/\/ Bits unset in both are unset in the result\n+    public long test2(long x, long y) {\n+        return ((x & -2) | (y & -6)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR_L})\n+    \/\/ Bits set in either are set in the result\n+    public long test3(long x, long y) {\n+        return (x | (y | 5)) & 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.OR_L})\n+    \/\/ The unsigned value of the result is larger than both operands\n+    public long test4(long x, long y) {\n+        return Long.compareUnsigned(((byte)x + 150) | y, 20) > 0 ? 1 : 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/OrLNodeIdealizationTests.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8315066\n+ * @summary Test that Ideal transformations of RShiftINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.RShiftINodeIdealizationTests\n+ *\/\n+public class RShiftINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b) {\n+        Asserts.assertEQ(1, test1(a, b));\n+        Asserts.assertEQ(1, test2(a, b));\n+        Asserts.assertEQ(Integer.MIN_VALUE >> 4, test3(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.RSHIFT_I})\n+    public int test1(int x, int y) {\n+        return (Math.max(x, -100) >> (y | 3)) >= (-100 >> 3) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.RSHIFT_I})\n+    public int test2(int x, int y) {\n+        return Integer.compareUnsigned((x >>> 1) >> (y | 8), (Integer.MAX_VALUE >> 8) + 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.RSHIFT_I})\n+    public int test3(int x, int y) {\n+        return ((x | Integer.MIN_VALUE) >> (y | 8)) & (Integer.MIN_VALUE >> 4);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftINodeIdealizationTests.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8315066\n+ * @summary Test that Ideal transformations of RShiftLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.RShiftLNodeIdealizationTests\n+ *\/\n+public class RShiftLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEQ(1L, test1(a, b));\n+        Asserts.assertEQ(1L, test2(a, b));\n+        Asserts.assertEQ(Long.MIN_VALUE >> 4, test3(a, b));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.RSHIFT_I})\n+    public long test1(long x, long y) {\n+        return ((long)Math.max((int)x, -100) >> (y | 3)) >= (-100L >> 3) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.RSHIFT_L})\n+    public long test2(long x, long y) {\n+        return Long.compareUnsigned((x >>> 1) >> (y | 8), (Long.MAX_VALUE >> 8) + 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.RSHIFT_L})\n+    public long test3(long x, long y) {\n+        return ((x | Long.MIN_VALUE) >> (y | 8)) & (Long.MIN_VALUE >> 4);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftLNodeIdealizationTests.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8267265\n+ * @bug 8267265 8315066\n@@ -46,1 +46,4 @@\n-                 \"test19\", \"test20\", \"test21\"})\n+                 \"test19\", \"test20\", \"test21\",\n+                 \"test22\", \"test23\", \"test24\",\n+                 \"test25\", \"test26\", \"test27\",\n+                 \"test28\"})\n@@ -84,0 +87,11 @@\n+        Asserts.assertEQ((a >> 2) - (b >> 2) > Integer.MIN_VALUE >> 1 &&\n+                (a >> 2) - (b >> 2) <= Integer.MAX_VALUE >> 1 ? 1 : 0, test22(a, b));\n+        Asserts.assertEQ((a | Integer.MIN_VALUE) - (b >>> 1) < 0 ? 1 : 0, test23(a, b));\n+        Asserts.assertEQ(((a | Integer.MIN_VALUE) >>> 1) -\n+                ((b >>> 2)| Integer.MIN_VALUE) < 0 ? 1 : 0, test24(a, b));\n+        Asserts.assertEQ(Integer.compareUnsigned((a | (Integer.MIN_VALUE >> 1)) -\n+                (b >>> 1), Integer.MIN_VALUE >>> 1) > 0 ? 1 : 0, test25(a, b));\n+        Asserts.assertEQ(Integer.compareUnsigned((a >>> 1) - (b >>> 1), Integer.MIN_VALUE) < 0 ? 1 : 0, test26(a, b));\n+        Asserts.assertEQ(Integer.compareUnsigned((a >>> 1) -\n+                (b | (Integer.MIN_VALUE >> 1)), Integer.MIN_VALUE >> 1) <= 0 ? 1 : 0, test27(a, b));\n+        Asserts.assertEQ(((a << 5) - (b << 5)) & 31, test28(a, b));\n@@ -252,0 +266,55 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_I, IRNode.RSHIFT_I})\n+    \/\/ Signed bounds\n+    public int test22(int a, int b) {\n+        int sum = (a >> 2) - (b >> 2);\n+        return sum > Integer.MIN_VALUE >> 1 && sum <= Integer.MAX_VALUE >> 1 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    \/\/ Signed bounds cannot be inferred if overflow\n+    public int test23(int a, int b) {\n+        int sum = (a | Integer.MIN_VALUE) - (b >>> 1);\n+        return sum < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_I, IRNode.URSHIFT_I})\n+    \/\/ Signed bounds, both lo and hi overflow\n+    public int test24(int a, int b) {\n+        int sum = ((a | Integer.MIN_VALUE) >>> 1) - ((b >>> 2)| Integer.MIN_VALUE);\n+        return sum < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_I, IRNode.URSHIFT_I})\n+    \/\/ Unsigned bounds\n+    public int test25(int a, int b) {\n+        int sum = (a | (Integer.MIN_VALUE >> 1)) - (b >>> 1);\n+        return Integer.compareUnsigned(sum, Integer.MIN_VALUE >>> 1) > 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    \/\/ Unsigned bounds cannot be inferred if overflow\n+    public int test26(int a, int b) {\n+        int sum = (a >>> 1) - (b >>> 1);\n+        return Integer.compareUnsigned(sum, Integer.MIN_VALUE) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_I, IRNode.URSHIFT_I})\n+    \/\/ Unsigned bounds, both ulo and uhi overflow\n+    public int test27(int a, int b) {\n+        int sum = (a >>> 1) - (b | (Integer.MIN_VALUE >> 1));\n+        return Integer.compareUnsigned(sum, Integer.MIN_VALUE >> 1) <= 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_I, IRNode.LSHIFT_I})\n+    \/\/ Bits\n+    public int test28(int a, int b) {\n+        return ((a << 5) - (b << 5)) & 31;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubINodeIdealizationTests.java","additions":72,"deletions":3,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8267265 8272735\n+ * @bug 8267265 8272735 8315066\n@@ -46,1 +46,4 @@\n-                 \"test19\", \"test20\", \"test21\"})\n+                 \"test19\", \"test20\", \"test21\",\n+                 \"test22\", \"test23\", \"test24\",\n+                 \"test25\", \"test26\", \"test27\",\n+                 \"test28\"})\n@@ -84,0 +87,11 @@\n+        Asserts.assertEQ((a >> 2) - (b >> 2) > Long.MIN_VALUE >> 1 &&\n+                (a >> 2) - (b >> 2) <= Long.MAX_VALUE >> 1 ? 1L : 0L, test22(a, b));\n+        Asserts.assertEQ((a | Long.MIN_VALUE) - (b >>> 1) < 0 ? 1L : 0L, test23(a, b));\n+        Asserts.assertEQ(((a | Long.MIN_VALUE) >>> 1) -\n+                ((b >>> 2)| Long.MIN_VALUE) < 0 ? 1L : 0L, test24(a, b));\n+        Asserts.assertEQ(Long.compareUnsigned((a | (Long.MIN_VALUE >> 1)) -\n+                (b >>> 1), Long.MIN_VALUE >>> 1) > 0 ? 1L : 0L, test25(a, b));\n+        Asserts.assertEQ(Long.compareUnsigned((a >>> 1) - (b >>> 1), Long.MIN_VALUE) < 0 ? 1L : 0L, test26(a, b));\n+        Asserts.assertEQ(Long.compareUnsigned((a >>> 1) -\n+                (b | (Long.MIN_VALUE >> 1)), Long.MIN_VALUE >> 1) <= 0 ? 1L : 0L, test27(a, b));\n+        Asserts.assertEQ(((a << 5) - (b << 5)) & 31, test28(a, b));\n@@ -252,0 +266,55 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_L, IRNode.RSHIFT_L})\n+    \/\/ Signed bounds\n+    public long test22(long a, long b) {\n+        long sum = (a >> 2) - (b >> 2);\n+        return sum > Long.MIN_VALUE >> 1 && sum <= Long.MAX_VALUE >> 1 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    \/\/ Signed bounds cannot be inferred if overflow\n+    public long test23(long a, long b) {\n+        long sum = (a | Long.MIN_VALUE) - (b >>> 1);\n+        return sum < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_L, IRNode.URSHIFT_L})\n+    \/\/ Signed bounds, both lo and hi overflow\n+    public long test24(long a, long b) {\n+        long sum = ((a | Long.MIN_VALUE) >>> 1) - ((b >>> 2)| Long.MIN_VALUE);\n+        return sum < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_L, IRNode.URSHIFT_L})\n+    \/\/ Unsigned bounds\n+    public long test25(long a, long b) {\n+        long sum = (a | (Long.MIN_VALUE >> 1)) - (b >>> 1);\n+        return Long.compareUnsigned(sum, Long.MIN_VALUE >>> 1) > 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    \/\/ Unsigned bounds cannot be inferred if overflow\n+    public long test26(long a, long b) {\n+        long sum = (a >>> 1) - (b >>> 1);\n+        return Long.compareUnsigned(sum, Long.MIN_VALUE) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_L, IRNode.URSHIFT_L})\n+    \/\/ Unsigned bounds, both ulo and uhi overflow\n+    public long test27(long a, long b) {\n+        long sum = (a >>> 1) - (b | (Long.MIN_VALUE >> 1));\n+        return Long.compareUnsigned(sum, Long.MIN_VALUE >> 1) <= 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_L, IRNode.LSHIFT_L})\n+    \/\/ Bits\n+    public long test28(long a, long b) {\n+        return ((a << 5) - (b << 5)) & 31;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubLNodeIdealizationTests.java","additions":72,"deletions":3,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8297384\n+ * @bug 8297384 8315066\n@@ -41,1 +41,2 @@\n-    @Run(test = { \"test1\", \"test2\" })\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\"})\n@@ -44,0 +45,1 @@\n+        int b = RunInfo.getRandom().nextInt();\n@@ -48,4 +50,4 @@\n-        assertResult(0);\n-        assertResult(a);\n-        assertResult(min);\n-        assertResult(max);\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n@@ -55,1 +57,1 @@\n-    public void assertResult(int a) {\n+    public void assertResult(int a, int b) {\n@@ -58,0 +60,3 @@\n+        Asserts.assertEQ(1, test3(a, b));\n+        Asserts.assertEQ(1, test4(a, b));\n+        Asserts.assertEQ(0, test5(a, b));\n@@ -75,0 +80,18 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.URSHIFT_I})\n+    public int test3(int x, int y) {\n+        return (Math.max(x, -100) >>> y) >= -100 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.URSHIFT_I})\n+    public int test4(int x, int y) {\n+        return Integer.compareUnsigned(x >>> (y | 8), (-1 >>> 8) + 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.URSHIFT_I})\n+    public int test5(int x, int y) {\n+        return (x >>> (y | 2)) & (Integer.MIN_VALUE >>> 1);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/URShiftINodeIdealizationTests.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8297384\n+ * @bug 8297384 8315066\n@@ -41,1 +41,2 @@\n-    @Run(test = { \"test1\", \"test2\" })\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\"})\n@@ -43,1 +44,2 @@\n-        long a = RunInfo.getRandom().nextInt();\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n@@ -48,4 +50,4 @@\n-        assertResult(0);\n-        assertResult(a);\n-        assertResult(min);\n-        assertResult(max);\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n@@ -55,1 +57,1 @@\n-    public void assertResult(long a) {\n+    public void assertResult(long a, long b) {\n@@ -58,0 +60,3 @@\n+        Asserts.assertEQ(1L, test3(a, b));\n+        Asserts.assertEQ(1L, test4(a, b));\n+        Asserts.assertEQ(0L, test5(a, b));\n@@ -75,0 +80,18 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.URSHIFT_L})\n+    public long test3(long x, long y) {\n+        return ((long)Math.max((int)x, -100) >>> y) >= -100 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.URSHIFT_L})\n+    public long test4(long x, long y) {\n+        return Long.compareUnsigned(x >>> (y | 8), (-1L >>> 8) + 1) < 0 ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.URSHIFT_L})\n+    public long test5(long x, long y) {\n+        return (x >>> (y | 2)) & (Long.MIN_VALUE >>> 1);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/URShiftLNodeIdealizationTests.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8281453\n+ * @bug 8281453 8315066\n@@ -45,1 +45,2 @@\n-                 \"test16\", \"test17\"})\n+                 \"test16\", \"test17\", \"test18\",\n+                 \"test19\"})\n@@ -80,0 +81,2 @@\n+        Asserts.assertEQ(0b0110             , test18(a, b));\n+        Asserts.assertEQ(1                  , test19(a, b));\n@@ -220,0 +223,14 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR_I, IRNode.AND_I, IRNode.OR_I})\n+    \/\/ Bits known in both inputs are known in the result\n+    public int test18(int x, int y) {\n+        return (((x & -4) | 12) ^ ((y & -6) | 10)) & 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR_I, IRNode.AND_I, IRNode.OR_I, IRNode.CMP_I})\n+    \/\/ Inputs do not overlap, results cannot be 0\n+    public int test19(int x, int y) {\n+        return ((x & -2) ^ (y | 1)) != 0 ? 1 : 0;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorINodeIdealizationTests.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8281453\n+ * @bug 8281453 8315066\n@@ -45,1 +45,2 @@\n-                 \"test16\", \"test17\"})\n+                 \"test16\", \"test17\", \"test18\",\n+                 \"test19\"})\n@@ -80,0 +81,2 @@\n+        Asserts.assertEQ(0b0110L            , test18(a, b));\n+        Asserts.assertEQ(1L                 , test19(a, b));\n@@ -220,0 +223,14 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR_L, IRNode.AND_L, IRNode.OR_L})\n+    \/\/ Bits known in both inputs are known in the result\n+    public long test18(long x, long y) {\n+        return (((x & -4) | 12) ^ ((y & -6) | 10)) & 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR_L, IRNode.AND_L, IRNode.OR_L, IRNode.CMP_L})\n+    \/\/ Inputs do not overlap, results cannot be 0\n+    public long test19(long x, long y) {\n+        return ((x & -2) ^ (y | 1)) != 0 ? 1 : 0;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorLNodeIdealizationTests.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1015,0 +1015,10 @@\n+    public static final String OR_I = PREFIX + \"OR_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OR_I, \"OrI\");\n+    }\n+\n+    public static final String OR_L = PREFIX + \"OR_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OR_L, \"OrL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,3 +74,1 @@\n-    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n-        counts = {IRNode.AND_VB, \">0\"})\n-    @IR(applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n@@ -78,2 +76,0 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n-        counts = {IRNode.MACRO_LOGIC_V, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}