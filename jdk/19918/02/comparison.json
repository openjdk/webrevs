{"files":[{"patch":"@@ -5492,0 +5492,32 @@\n+\/\/ Common checks for array sorting intrinsics arguments.\n+\/\/ Returns `true` if checks passed.\n+bool LibraryCallKit::check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt) {\n+  \/\/ check address of the class\n+  if (elementType == nullptr || elementType->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  if (elem_klass == nullptr) {\n+    return false;  \/\/ dead path\n+  }\n+  \/\/ java_mirror_type() returns non-null for compile-time Class constants only\n+  ciType* elem_type = elem_klass->java_mirror_type();\n+  if (elem_type == nullptr) {\n+    return false;\n+  }\n+  bt = elem_type->basic_type();\n+  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n+  if (!Matcher::supports_simd_sort(bt)) {\n+    return false;\n+  }\n+  \/\/ check address of the array\n+  if (obj == nullptr || obj->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM) {\n+    return false; \/\/ failed input validation\n+  }\n+  return true;\n+}\n+\n@@ -5494,0 +5526,5 @@\n+  address stubAddr = StubRoutines::select_array_partition_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 9, \"arrayPartition has 8 parameters (one long)\");\n@@ -5495,1 +5532,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5497,1 +5535,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5502,0 +5540,1 @@\n+  \/\/ PartitionOperation:  argument(8) is ignored\n@@ -5504,0 +5543,1 @@\n+  BasicType bt = T_ILLEGAL;\n@@ -5505,0 +5545,8 @@\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n+    return false;\n+  }\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -5510,18 +5558,0 @@\n-    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-    BasicType bt = elem_type->basic_type();\n-    \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-    if (!Matcher::supports_simd_sort(bt)) {\n-      return false;\n-    }\n-    address stubAddr = nullptr;\n-    stubAddr = StubRoutines::select_array_partition_function();\n-    \/\/ stub not loaded\n-    if (stubAddr == nullptr) {\n-      return false;\n-    }\n-    \/\/ get the address of the array\n-    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-      return false; \/\/ failed input validation\n-    }\n@@ -5560,0 +5590,5 @@\n+  address stubAddr = StubRoutines::select_arraysort_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 7, \"arraySort has 6 parameters (one long)\");\n@@ -5561,1 +5596,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5563,1 +5599,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5566,0 +5602,1 @@\n+  \/\/ SortOperation:       argument(6) is ignored\n@@ -5567,11 +5604,3 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType bt = elem_type->basic_type();\n-  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-  if (!Matcher::supports_simd_sort(bt)) {\n-    return false;\n-  }\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_arraysort_function();\n-  \/\/stub not loaded\n-  if (stubAddr == nullptr) {\n+  BasicType bt = T_ILLEGAL;\n+\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n@@ -5580,5 +5609,4 @@\n-\n-  \/\/ get address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":66,"deletions":38,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -282,0 +282,1 @@\n+  bool check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}