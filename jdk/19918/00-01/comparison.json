{"files":[{"patch":"@@ -5492,13 +5492,7 @@\n-\/\/------------------------------inline_array_partition-----------------------\n-bool LibraryCallKit::inline_array_partition() {\n-\n-  Node* elementType     = argument(0);\n-  Node* obj             = argument(1);\n-  Node* offset          = argument(2);\n-  Node* fromIndex       = argument(4);\n-  Node* toIndex         = argument(5);\n-  Node* indexPivot1     = argument(6);\n-  Node* indexPivot2     = argument(7);\n-\n-  Node* pivotIndices = nullptr;\n-\n+\/\/ Common checks for array sorting intrinsics arguments.\n+\/\/ Returns `true` if checks passed.\n+bool LibraryCallKit::check_array_sort_arguments(Node* elementType, Node* obj, BasicType* bt) {\n+  \/\/ check address of the class\n+  if (elementType == nullptr || elementType->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n@@ -5507,3 +5501,0 @@\n-    return false;  \/\/ dead path (elementType->is_top()).\n-  }\n-  if (obj == nullptr || obj->is_top()) {\n@@ -5512,1 +5503,1 @@\n-  \/\/ java_mirror_type() returns non-null for compile-time Class constants only.\n+  \/\/ java_mirror_type() returns non-null for compile-time Class constants only\n@@ -5517,1 +5508,1 @@\n-  BasicType bt = elem_type->basic_type();\n+  BasicType ebt = elem_type->basic_type();\n@@ -5519,1 +5510,1 @@\n-  if (!Matcher::supports_simd_sort(bt)) {\n+  if (!Matcher::supports_simd_sort(ebt)) {\n@@ -5522,5 +5513,3 @@\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_array_partition_function();\n-  \/\/ stub not loaded\n-  if (stubAddr == nullptr) {\n-    return false;\n+  \/\/ check address of the array\n+  if (obj == nullptr || obj->is_top()) {\n+    return false;  \/\/ dead path\n@@ -5528,1 +5517,0 @@\n-  \/\/ get the address of the array\n@@ -5530,1 +5518,1 @@\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM) {\n@@ -5533,0 +5521,24 @@\n+  *bt = ebt;\n+  return true;\n+}\n+\n+\/\/------------------------------inline_array_partition-----------------------\n+bool LibraryCallKit::inline_array_partition() {\n+  address stubAddr = StubRoutines::select_array_partition_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 9, \"arrayPartition has 8 parameters (one long)\");\n+\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2); \/\/ long\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+  Node* indexPivot1     = argument(6);\n+  Node* indexPivot2     = argument(7);\n+  \/\/ PartitionOperation:  argument(8) is ignored\n+\n+  Node* pivotIndices = nullptr;\n+  BasicType bt = T_ILLEGAL;\n@@ -5534,0 +5546,3 @@\n+  if (!check_array_sort_arguments(elementType, obj, &bt)) {\n+    return false;\n+  }\n@@ -5536,2 +5551,3 @@\n-  if (stopped())  return true;\n-\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -5575,0 +5591,5 @@\n+  address stubAddr = StubRoutines::select_arraysort_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 7, \"arraySort has 6 parameters (one long)\");\n@@ -5576,0 +5597,1 @@\n+  \/\/ no receiver because it is a static method\n@@ -5578,1 +5600,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5581,0 +5603,1 @@\n+  \/\/ SortOperation:       argument(6) is ignored\n@@ -5582,23 +5605,1 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  if (elem_klass == nullptr) {\n-    return false;  \/\/ dead path (elementType->is_top()).\n-  }\n-  if (obj == nullptr || obj->is_top()) {\n-    return false;  \/\/ dead path\n-  }\n-  \/\/ java_mirror_type() returns non-null for compile-time Class constants only.\n-  ciType* elem_type = elem_klass->java_mirror_type();\n-  if (elem_type == nullptr) {\n-    return false;\n-  }\n-  BasicType bt = elem_type->basic_type();\n-  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-  if (!Matcher::supports_simd_sort(bt)) {\n-    return false;\n-  }\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_arraysort_function();\n-  \/\/stub not loaded\n-  if (stubAddr == nullptr) {\n-    return false;\n-  }\n+  BasicType bt = T_ILLEGAL;\n@@ -5606,4 +5607,2 @@\n-  \/\/ get address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n+  if (!check_array_sort_arguments(elementType, obj, &bt)) {\n+    return false;\n@@ -5611,1 +5610,0 @@\n-\n@@ -5614,2 +5612,3 @@\n-  if (stopped())  return true;\n-\n+  if (stopped()) {\n+    return true;\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":58,"deletions":59,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -282,0 +282,1 @@\n+  bool check_array_sort_arguments(Node* elementType, Node* obj, BasicType* bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}