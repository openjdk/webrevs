{"files":[{"patch":"@@ -3169,1 +3169,1 @@\n-  \/\/ Check if a%b and a\/b both exist\n+  \/\/ Check if \"a % b\" and \"a \/ b\" both exist\n@@ -3171,1 +3171,1 @@\n-  if (!d) {\n+  if (d == nullptr) {\n@@ -3181,1 +3181,1 @@\n-    \/\/ replace a%b with a-((a\/b)*b)\n+    \/\/ replace \"a % b\" with \"a - ((a \/ b) *b)\"\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.util.function.BiFunction;\n+import java.util.Random;\n@@ -33,1 +33,1 @@\n- * @summary Test DIV and MOD nodes are converted into DIVMOD where possible\n+ * @summary Test that DIV and MOD nodes are converted into DIVMOD where possible\n@@ -35,2 +35,2 @@\n- * @run main\/othervm -XX:+UseDivMod compiler.c2.TestDivModNodes\n- * @run main\/othervm -XX:-UseDivMod compiler.c2.TestDivModNodes\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.TestDivModNodes\n@@ -39,0 +39,7 @@\n+    private static final Random RANDOM = AbstractInfo.getRandom();\n+\n+    private static int intQuotient;\n+    private static int intRemainder;\n+    private static long longQuotient;\n+    private static long longRemainder;\n+\n@@ -40,1 +47,2 @@\n-        TestFramework.run();\n+        TestFramework.runWithFlags(\"-XX:-UseDivMod\");\n+        TestFramework.runWithFlags(\"-XX:+UseDivMod\");\n@@ -44,1 +52,0 @@\n-    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -54,2 +61,9 @@\n-        int q = dividend \/ divisor;\n-        int r = dividend % divisor;\n+        intQuotient = dividend \/ divisor;\n+        intRemainder = dividend % divisor;\n+    }\n+\n+    @Run(test = \"testSignedIntDivMod\")\n+    private static void runSignedIntDivMod() {\n+        int dividend = RANDOM.nextInt();\n+        int divisor = RANDOM.nextInt();\n+        testSignedIntDivMod(dividend, divisor);\n@@ -57,1 +71,3 @@\n-        verifyResult(dividend, divisor, q, r, TestDivModNodes::signedIntDiv, TestDivModNodes::signedIntMod);\n+        verifyResult(dividend, divisor,\n+                intQuotient, intRemainder,\n+                dividend \/ divisor, dividend % divisor);\n@@ -60,0 +76,1 @@\n+\n@@ -61,1 +78,0 @@\n-    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -71,2 +87,9 @@\n-        long q = dividend \/ divisor;\n-        long r = dividend % divisor;\n+        longQuotient = dividend \/ divisor;\n+        longRemainder = dividend % divisor;\n+    }\n+\n+    @Run(test = \"testSignedLongDivMod\")\n+    private static void runSignedLongDivMod() {\n+        long dividend = RANDOM.nextLong();\n+        long divisor = RANDOM.nextLong();\n+        testSignedLongDivMod(dividend, divisor);\n@@ -74,1 +97,3 @@\n-        verifyResult(dividend, divisor, q, r, TestDivModNodes::signedLongDiv, TestDivModNodes::signedLongMod);\n+        verifyResult(dividend, divisor,\n+                longQuotient, longRemainder,\n+                dividend \/ divisor, dividend % divisor);\n@@ -78,1 +103,0 @@\n-    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -88,2 +112,9 @@\n-        int q = Integer.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n-        int r = Integer.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+        intQuotient = Integer.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+        intRemainder = Integer.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+    }\n+\n+    @Run(test = \"testUnsignedIntDivMod\")\n+    private static void runUnsignedIntDivMod() {\n+        int dividend = RANDOM.nextInt();\n+        int divisor = RANDOM.nextInt();\n+        testUnsignedIntDivMod(dividend, divisor);\n@@ -91,1 +122,3 @@\n-        verifyResult(dividend, divisor, q, r, TestDivModNodes::unsignedIntDiv, TestDivModNodes::unsignedIntMod);\n+        verifyResult(dividend, divisor,\n+                intQuotient, intRemainder,\n+                Integer.divideUnsigned(dividend, divisor), Integer.remainderUnsigned(dividend, divisor));\n@@ -95,1 +128,0 @@\n-    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -105,4 +137,2 @@\n-        long q = Long.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n-        long r = Long.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n-\n-        verifyResult(dividend, divisor, q, r, TestDivModNodes::unsignedLongDiv, TestDivModNodes::unsignedLongMod);\n+        longQuotient = Long.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+        longRemainder = Long.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n@@ -111,4 +141,5 @@\n-    private static <T extends Number> void verifyResult(T dividend, T divisor, T quotient, T remainder,\n-            BiFunction<T, T, T> quotientFunc, BiFunction<T, T, T> remainderFunc) {\n-        T expectedQ = quotientFunc.apply(dividend, divisor);\n-        T expectedR = remainderFunc.apply(dividend, divisor);\n+    @Run(test = \"testUnsignedLongDivMod\")\n+    private static void runUnsignedLongDivMod() {\n+        long dividend = RANDOM.nextLong();\n+        long divisor = RANDOM.nextLong();\n+        testUnsignedLongDivMod(dividend, divisor);\n@@ -116,0 +147,8 @@\n+        verifyResult(dividend, divisor,\n+                longQuotient, longRemainder,\n+                Long.divideUnsigned(dividend, divisor), Long.remainderUnsigned(dividend, divisor));\n+    }\n+\n+    private static <T extends Number> void verifyResult(T dividend, T divisor,\n+                                                        T quotient, T remainder,\n+                                                        T expectedQ, T expectedR) {\n@@ -123,42 +162,0 @@\n-\n-    \/\/ By spreading div and mod into different, not inlined methods, we can confuse the compiler enough to not perform\n-    \/\/ the divmod optimization, so we can test for correctness.\n-    @DontInline\n-    private static int signedIntDiv(int dividend, int divisor) {\n-        return dividend \/ divisor;\n-    }\n-\n-    @DontInline\n-    private static int signedIntMod(int dividend, int divisor) {\n-        return dividend % divisor;\n-    }\n-\n-    @DontInline\n-    private static int unsignedIntDiv(int dividend, int divisor) {\n-        return Integer.divideUnsigned(dividend, divisor);\n-    }\n-\n-    @DontInline\n-    private static int unsignedIntMod(int dividend, int divisor) {\n-        return Integer.remainderUnsigned(dividend, divisor);\n-    }\n-\n-    @DontInline\n-    private static long signedLongDiv(long dividend, long divisor) {\n-        return dividend \/ divisor;\n-    }\n-\n-    @DontInline\n-    private static long signedLongMod(long dividend, long divisor) {\n-        return dividend % divisor;\n-    }\n-\n-    @DontInline\n-    private static long unsignedLongDiv(long dividend, long divisor) {\n-        return Long.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n-    }\n-\n-    @DontInline\n-    private static long unsignedLongMod(long dividend, long divisor) {\n-        return Long.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestDivModNodes.java","additions":65,"deletions":68,"binary":false,"changes":133,"status":"modified"}]}