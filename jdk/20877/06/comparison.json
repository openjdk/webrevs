{"files":[{"patch":"@@ -3164,0 +3164,24 @@\n+void Compile::handle_div_mod_op(Node* n, BasicType bt, bool is_unsigned) {\n+  if (!UseDivMod) {\n+    return;\n+  }\n+\n+  \/\/ Check if \"a % b\" and \"a \/ b\" both exist\n+  Node* d = n->find_similar(Op_DivIL(bt, is_unsigned));\n+  if (d == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ Replace them with a fused divmod if supported\n+  if (Matcher::has_match_rule(Op_DivModIL(bt, is_unsigned))) {\n+    DivModNode* divmod = DivModNode::make(n, bt, is_unsigned);\n+    d->subsume_by(divmod->div_proj(), this);\n+    n->subsume_by(divmod->mod_proj(), this);\n+  } else {\n+    \/\/ Replace \"a % b\" with \"a - ((a \/ b) * b)\"\n+    Node* mult = MulNode::make(d, d->in(2), bt);\n+    Node* sub = SubNode::make(d->in(1), mult, bt);\n+    n->subsume_by(sub, this);\n+  }\n+}\n+\n@@ -3612,17 +3636,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_DivI);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_DivModI)) {\n-          DivModINode* divmod = DivModINode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulINode(d, d->in(2));\n-          Node* sub  = new SubINode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_INT, false);\n@@ -3632,17 +3640,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_DivL);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_DivModL)) {\n-          DivModLNode* divmod = DivModLNode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulLNode(d, d->in(2));\n-          Node* sub  = new SubLNode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_LONG, false);\n@@ -3652,17 +3644,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_UDivI);\n-      if (d) {\n-        \/\/ Replace them with a fused unsigned divmod if supported\n-        if (Matcher::has_match_rule(Op_UDivModI)) {\n-          UDivModINode* divmod = UDivModINode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulINode(d, d->in(2));\n-          Node* sub  = new SubINode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_INT, true);\n@@ -3672,17 +3648,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_UDivL);\n-      if (d) {\n-        \/\/ Replace them with a fused unsigned divmod if supported\n-        if (Matcher::has_match_rule(Op_UDivModL)) {\n-          UDivModLNode* divmod = UDivModLNode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulLNode(d, d->in(2));\n-          Node* sub  = new SubLNode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_LONG, true);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":28,"deletions":68,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+  void handle_div_mod_op(Node* n, BasicType bt, bool is_unsigned);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1363,0 +1363,18 @@\n+DivModNode* DivModNode::make(Node* div_or_mod, BasicType bt, bool is_unsigned) {\n+  assert(bt == T_INT || bt == T_LONG, \"only int or long input pattern accepted\");\n+\n+  if (bt == T_INT) {\n+    if (is_unsigned) {\n+      return UDivModINode::make(div_or_mod);\n+    } else {\n+      return DivModINode::make(div_or_mod);\n+    }\n+  } else {\n+    if (is_unsigned) {\n+      return UDivModLNode::make(div_or_mod);\n+    } else {\n+      return DivModLNode::make(div_or_mod);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -205,0 +205,2 @@\n+  static DivModNode* make(Node* div_or_mod, BasicType bt, bool is_unsigned);\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2069,0 +2069,32 @@\n+inline int Op_DivIL(BasicType bt, bool is_unsigned) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    if (is_unsigned) {\n+      return Op_UDivI;\n+    } else {\n+      return Op_DivI;\n+    }\n+  }\n+  if (is_unsigned) {\n+    return Op_UDivL;\n+  } else {\n+    return Op_DivL;\n+  }\n+}\n+\n+inline int Op_DivModIL(BasicType bt, bool is_unsigned) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    if (is_unsigned) {\n+      return Op_UDivModI;\n+    } else {\n+      return Op_DivModI;\n+    }\n+  }\n+  if (is_unsigned) {\n+    return Op_UDivModL;\n+  } else {\n+    return Op_DivModL;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Test;\n+\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8332442\n+ * @summary Test that DIV and MOD nodes are converted into DIVMOD where possible\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.TestDivModNodes\n+ *\/\n+public class TestDivModNodes {\n+    private static final Random RANDOM = AbstractInfo.getRandom();\n+\n+    private static int intQuotient;\n+    private static int intRemainder;\n+    private static long longQuotient;\n+    private static long longRemainder;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-UseDivMod\");\n+        TestFramework.runWithFlags(\"-XX:+UseDivMod\");\n+    }\n+\n+    private static int nextNonZeroInt() {\n+        int i;\n+        do {\n+            i = RANDOM.nextInt();\n+        } while (i == 0);\n+        return i;\n+    }\n+\n+    private static long nextNonZeroLong() {\n+        long i;\n+        do {\n+            i = RANDOM.nextLong();\n+        } while (i == 0);\n+        return i;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"x64\", \"true\"},\n+            counts = {IRNode.DIV_MOD_I, \"1\"},\n+            failOn = {IRNode.DIV_I, IRNode.MOD_I})\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"aarch64\", \"true\"},\n+            counts = {IRNode.DIV_I, \"1\", IRNode.MUL_I, \"1\", IRNode.SUB_I, \"1\"},\n+            failOn = {IRNode.MOD_I})\n+    @IR(applyIf = {\"UseDivMod\", \"false\"},\n+            counts = {IRNode.DIV_I, \"1\", IRNode.MOD_I, \"1\"})\n+    private static void testSignedIntDivMod(int dividend, int divisor) {\n+        intQuotient = dividend \/ divisor;\n+        intRemainder = dividend % divisor;\n+    }\n+\n+    @Run(test = \"testSignedIntDivMod\")\n+    private static void runSignedIntDivMod() {\n+        int dividend = RANDOM.nextInt();\n+        int divisor = nextNonZeroInt();\n+        testSignedIntDivMod(dividend, divisor);\n+\n+        verifyResult(dividend, divisor,\n+                intQuotient, intRemainder,\n+                dividend \/ divisor, dividend % divisor);\n+    }\n+\n+\n+    @Test\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"x64\", \"true\"},\n+            counts = {IRNode.DIV_MOD_L, \"1\"},\n+            failOn = {IRNode.DIV_L, IRNode.MOD_L})\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"aarch64\", \"true\"},\n+            counts = {IRNode.DIV_L, \"1\", IRNode.MUL_L, \"1\", IRNode.SUB_L, \"1\"},\n+            failOn = {IRNode.MOD_L})\n+    @IR(applyIf = {\"UseDivMod\", \"false\"},\n+            counts = {IRNode.DIV_L, \"1\", IRNode.MOD_L, \"1\"})\n+    private static void testSignedLongDivMod(long dividend, long divisor) {\n+        longQuotient = dividend \/ divisor;\n+        longRemainder = dividend % divisor;\n+    }\n+\n+    @Run(test = \"testSignedLongDivMod\")\n+    private static void runSignedLongDivMod() {\n+        long dividend = RANDOM.nextLong();\n+        long divisor = nextNonZeroLong();\n+        testSignedLongDivMod(dividend, divisor);\n+\n+        verifyResult(dividend, divisor,\n+                longQuotient, longRemainder,\n+                dividend \/ divisor, dividend % divisor);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"x64\", \"true\"},\n+            counts = {IRNode.UDIV_MOD_I, \"1\"},\n+            failOn = {IRNode.UDIV_I, IRNode.UMOD_I})\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"aarch64\", \"true\"},\n+            counts = {IRNode.UDIV_I, \"1\", IRNode.MUL_I, \"1\", IRNode.SUB_I, \"1\"},\n+            failOn = {IRNode.UMOD_I})\n+    @IR(applyIf = {\"UseDivMod\", \"false\"},\n+            counts = {IRNode.UDIV_I, \"1\", IRNode.UMOD_I, \"1\"})\n+    private static void testUnsignedIntDivMod(int dividend, int divisor) {\n+        intQuotient = Integer.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+        intRemainder = Integer.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+    }\n+\n+    @Run(test = \"testUnsignedIntDivMod\")\n+    private static void runUnsignedIntDivMod() {\n+        int dividend = RANDOM.nextInt();\n+        int divisor = nextNonZeroInt();\n+        testUnsignedIntDivMod(dividend, divisor);\n+\n+        verifyResult(dividend, divisor,\n+                intQuotient, intRemainder,\n+                Integer.divideUnsigned(dividend, divisor), Integer.remainderUnsigned(dividend, divisor));\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"x64\", \"true\"},\n+            counts = {IRNode.UDIV_MOD_L, \"1\"},\n+            failOn = {IRNode.UDIV_L, IRNode.UMOD_L})\n+    @IR(applyIf = {\"UseDivMod\", \"true\"}, applyIfPlatform = {\"aarch64\", \"true\"},\n+            counts = {IRNode.UDIV_L, \"1\", IRNode.MUL_L, \"1\", IRNode.SUB_L, \"1\"},\n+            failOn = {IRNode.MOD_L})\n+    @IR(applyIf = {\"UseDivMod\", \"false\"},\n+            counts = {IRNode.UDIV_L, \"1\", IRNode.UMOD_L, \"1\"})\n+    private static void testUnsignedLongDivMod(long dividend, long divisor) {\n+        longQuotient = Long.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+        longRemainder = Long.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+    }\n+\n+    @Run(test = \"testUnsignedLongDivMod\")\n+    private static void runUnsignedLongDivMod() {\n+        long dividend = RANDOM.nextLong();\n+        long divisor = nextNonZeroLong();\n+        testUnsignedLongDivMod(dividend, divisor);\n+\n+        verifyResult(dividend, divisor,\n+                longQuotient, longRemainder,\n+                Long.divideUnsigned(dividend, divisor), Long.remainderUnsigned(dividend, divisor));\n+    }\n+\n+    private static <T extends Number> void verifyResult(T dividend, T divisor,\n+                                                        T quotient, T remainder,\n+                                                        T expectedQ, T expectedR) {\n+        if (!expectedQ.equals(quotient) || !expectedR.equals(remainder)) {\n+            throw new AssertionError(String.format(\"Mismatched result from %d \/ %d. \" +\n+                    \"Expected: quotient = %d remainder = %d, \" +\n+                    \"but got: quotient = %d remainder = %d\",\n+                    dividend, divisor, expectedQ, expectedR, quotient, remainder));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestDivModNodes.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -517,0 +517,5 @@\n+    public static final String DIV_I = PREFIX + \"DIV_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_I, \"DivI\");\n+    }\n+\n@@ -522,0 +527,10 @@\n+    public static final String DIV_MOD_I = PREFIX + \"DIV_MOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_MOD_I, \"DivModI\");\n+    }\n+\n+    public static final String DIV_MOD_L = PREFIX + \"DIV_MOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_MOD_L, \"DivModL\");\n+    }\n+\n@@ -1000,0 +1015,10 @@\n+    public static final String MOD_I = PREFIX + \"MOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOD_I, \"ModI\");\n+    }\n+\n+    public static final String MOD_L = PREFIX + \"MOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOD_L, \"ModL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"}]}