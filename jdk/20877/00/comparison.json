{"files":[{"patch":"@@ -3163,0 +3163,26 @@\n+void Compile::handle_div_mod_op(Node* n, int div_op, int div_mod_op, bool is_unsigned) {\n+  if (!UseDivMod) {\n+    return;\n+  }\n+\n+  \/\/ Check if a%b and a\/b both exist\n+  Node* d = n->find_similar(div_op);\n+  if (!d) {\n+    return;\n+  }\n+\n+  BasicType bt = div_op == Op_DivI || div_op == Op_UDivI ? T_INT : T_LONG;\n+\n+  \/\/ Replace them with a fused divmod if supported\n+  if (Matcher::has_match_rule(div_mod_op)) {\n+    DivModNode* divmod = DivModNode::make(n, bt, is_unsigned);\n+    d->subsume_by(divmod->div_proj(), this);\n+    n->subsume_by(divmod->mod_proj(), this);\n+  } else {\n+    \/\/ replace a%b with a-((a\/b)*b)\n+    Node* mult = MulNode::make(d, d->in(2), bt);\n+    Node* sub = SubNode::make(d->in(1), mult, bt);\n+    n->subsume_by(sub, this);\n+  }\n+}\n+\n@@ -3611,17 +3637,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_DivI);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_DivModI)) {\n-          DivModINode* divmod = DivModINode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulINode(d, d->in(2));\n-          Node* sub  = new SubINode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, Op_DivI, Op_DivModI, false);\n@@ -3631,17 +3641,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_DivL);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_DivModL)) {\n-          DivModLNode* divmod = DivModLNode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulLNode(d, d->in(2));\n-          Node* sub  = new SubLNode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, Op_DivL, Op_DivModL, false);\n@@ -3651,17 +3645,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_UDivI);\n-      if (d) {\n-        \/\/ Replace them with a fused unsigned divmod if supported\n-        if (Matcher::has_match_rule(Op_UDivModI)) {\n-          UDivModINode* divmod = UDivModINode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulINode(d, d->in(2));\n-          Node* sub  = new SubINode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, Op_UDivI, Op_UDivModI, true);\n@@ -3671,17 +3649,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_UDivL);\n-      if (d) {\n-        \/\/ Replace them with a fused unsigned divmod if supported\n-        if (Matcher::has_match_rule(Op_UDivModL)) {\n-          UDivModLNode* divmod = UDivModLNode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulLNode(d, d->in(2));\n-          Node* sub  = new SubLNode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, Op_UDivL, Op_UDivModL, true);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":30,"deletions":68,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+  void handle_div_mod_op(Node* n, int div_op, int div_mod_op, bool is_unsigned);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1363,0 +1363,18 @@\n+DivModNode* DivModNode::make(Node* div_or_mod, BasicType bt, bool is_unsigned) {\n+  assert(bt == T_INT || bt == T_LONG, \"only int or long input pattern accepted\");\n+\n+  if (bt == T_INT) {\n+    if (is_unsigned) {\n+      return UDivModINode::make(div_or_mod);\n+    } else {\n+      return DivModINode::make(div_or_mod);\n+    }\n+  } else {\n+    if (is_unsigned) {\n+      return UDivModLNode::make(div_or_mod);\n+    } else {\n+      return DivModLNode::make(div_or_mod);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -205,0 +205,2 @@\n+  static DivModNode* make(Node* div_or_mod, BasicType bt, bool is_unsigned);\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Test;\n+\n+import java.util.function.BiFunction;\n+\n+\/*\n+ * @test\n+ * @summary Test DIV and MOD nodes are converted into DIVMOD where possible\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestDivModNodes\n+ *\/\n+public class TestDivModNodes {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.DIV_MOD_I, \"1\" })\n+    private static void testSignedIntDivMod(int dividend, int divisor) {\n+        int q = dividend \/ divisor;\n+        int r = dividend % divisor;\n+\n+        verifyResult(dividend, divisor, q, r, TestDivModNodes::signedIntDiv, TestDivModNodes::signedIntMod);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.DIV_MOD_L, \"1\" })\n+    private static void testSignedLongDivMod(long dividend, long divisor) {\n+        long q = dividend \/ divisor;\n+        long r = dividend % divisor;\n+\n+        verifyResult(dividend, divisor, q, r, TestDivModNodes::signedLongDiv, TestDivModNodes::signedLongMod);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.UDIV_MOD_I, \"1\" })\n+    private static void testUnsignedIntDivMod(int dividend, int divisor) {\n+        int q = Integer.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+        int r = Integer.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+\n+        verifyResult(dividend, divisor, q, r, TestDivModNodes::unsignedIntDiv, TestDivModNodes::unsignedIntMod);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.UDIV_MOD_L, \"1\" })\n+    private static void testUnsignedLongDivMod(long dividend, long divisor) {\n+        long q = Long.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+        long r = Long.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+\n+        verifyResult(dividend, divisor, q, r, TestDivModNodes::unsignedLongDiv, TestDivModNodes::unsignedLongMod);\n+    }\n+\n+    private static <T extends Number> void verifyResult(T dividend, T divisor, T quotient, T remainder,\n+            BiFunction<T, T, T> quotientFunc, BiFunction<T, T, T> remainderFunc) {\n+        T expectedQ = quotientFunc.apply(dividend, divisor);\n+        T expectedR = remainderFunc.apply(dividend, divisor);\n+\n+        if (!expectedQ.equals(quotient) || !expectedR.equals(remainder)) {\n+            throw new AssertionError(String.format(\"Mismatched result from %d \/ %d. \" +\n+                    \"Expected: quotient = %d remainder = %d, \" +\n+                    \"but got: quotient = %d remainder = %d\",\n+                    dividend, divisor, expectedQ, expectedR, quotient, remainder));\n+        }\n+    }\n+\n+    \/\/ By spreading div and mod into different, not inlined methods, we can confuse the compiler enough to not perform\n+    \/\/ the divmod optimization, so we can test for correctness.\n+    @DontInline\n+    private static int signedIntDiv(int dividend, int divisor) {\n+        return dividend \/ divisor;\n+    }\n+\n+    @DontInline\n+    private static int signedIntMod(int dividend, int divisor) {\n+        return dividend % divisor;\n+    }\n+\n+    @DontInline\n+    private static int unsignedIntDiv(int dividend, int divisor) {\n+        return Integer.divideUnsigned(dividend, divisor);\n+    }\n+\n+    @DontInline\n+    private static int unsignedIntMod(int dividend, int divisor) {\n+        return Integer.remainderUnsigned(dividend, divisor);\n+    }\n+\n+    @DontInline\n+    private static long signedLongDiv(long dividend, long divisor) {\n+        return dividend \/ divisor;\n+    }\n+\n+    @DontInline\n+    private static long signedLongMod(long dividend, long divisor) {\n+        return dividend % divisor;\n+    }\n+\n+    @DontInline\n+    private static long unsignedLongDiv(long dividend, long divisor) {\n+        return Long.divideUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+    }\n+\n+    @DontInline\n+    private static long unsignedLongMod(long dividend, long divisor) {\n+        return Long.remainderUnsigned(dividend, divisor); \/\/ intrinsified on x86\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestDivModNodes.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -522,0 +522,10 @@\n+    public static final String DIV_MOD_I = PREFIX + \"DIV_MOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_MOD_I, \"DivModI\");\n+    }\n+\n+    public static final String DIV_MOD_L = PREFIX + \"DIV_MOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_MOD_L, \"DivModL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}