{"files":[{"patch":"@@ -521,181 +521,0 @@\n-\/\/ EMIT_RM()\n-void emit_rm(CodeBuffer &cbuf, int f1, int f2, int f3) {\n-  unsigned char c = (unsigned char) ((f1 << 6) | (f2 << 3) | f3);\n-  cbuf.insts()->emit_int8(c);\n-}\n-\n-\/\/ EMIT_CC()\n-void emit_cc(CodeBuffer &cbuf, int f1, int f2) {\n-  unsigned char c = (unsigned char) (f1 | f2);\n-  cbuf.insts()->emit_int8(c);\n-}\n-\n-\/\/ EMIT_OPCODE()\n-void emit_opcode(CodeBuffer &cbuf, int code) {\n-  cbuf.insts()->emit_int8((unsigned char) code);\n-}\n-\n-\/\/ EMIT_OPCODE() w\/ relocation information\n-void emit_opcode(CodeBuffer &cbuf,\n-                 int code, relocInfo::relocType reloc, int offset, int format)\n-{\n-  cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);\n-  emit_opcode(cbuf, code);\n-}\n-\n-\/\/ EMIT_D8()\n-void emit_d8(CodeBuffer &cbuf, int d8) {\n-  cbuf.insts()->emit_int8((unsigned char) d8);\n-}\n-\n-\/\/ EMIT_D16()\n-void emit_d16(CodeBuffer &cbuf, int d16) {\n-  cbuf.insts()->emit_int16(d16);\n-}\n-\n-\/\/ EMIT_D32()\n-void emit_d32(CodeBuffer &cbuf, int d32) {\n-  cbuf.insts()->emit_int32(d32);\n-}\n-\n-\/\/ EMIT_D64()\n-void emit_d64(CodeBuffer &cbuf, int64_t d64) {\n-  cbuf.insts()->emit_int64(d64);\n-}\n-\n-\/\/ emit 32 bit value and construct relocation entry from relocInfo::relocType\n-void emit_d32_reloc(CodeBuffer& cbuf,\n-                    int d32,\n-                    relocInfo::relocType reloc,\n-                    int format)\n-{\n-  assert(reloc != relocInfo::external_word_type, \"use 2-arg emit_d32_reloc\");\n-  cbuf.relocate(cbuf.insts_mark(), reloc, format);\n-  cbuf.insts()->emit_int32(d32);\n-}\n-\n-\/\/ emit 32 bit value and construct relocation entry from RelocationHolder\n-void emit_d32_reloc(CodeBuffer& cbuf, int d32, RelocationHolder const& rspec, int format) {\n-#ifdef ASSERT\n-  if (rspec.reloc()->type() == relocInfo::oop_type &&\n-      d32 != 0 && d32 != (intptr_t) Universe::non_oop_word()) {\n-    assert(Universe::heap()->is_in((address)(intptr_t)d32), \"should be real oop\");\n-    assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), \"cannot embed broken oops in code\");\n-  }\n-#endif\n-  cbuf.relocate(cbuf.insts_mark(), rspec, format);\n-  cbuf.insts()->emit_int32(d32);\n-}\n-\n-void emit_d32_reloc(CodeBuffer& cbuf, address addr) {\n-  address next_ip = cbuf.insts_end() + 4;\n-  emit_d32_reloc(cbuf, (int) (addr - next_ip),\n-                 external_word_Relocation::spec(addr),\n-                 RELOC_DISP32);\n-}\n-\n-\n-\/\/ emit 64 bit value and construct relocation entry from relocInfo::relocType\n-void emit_d64_reloc(CodeBuffer& cbuf, int64_t d64, relocInfo::relocType reloc, int format) {\n-  cbuf.relocate(cbuf.insts_mark(), reloc, format);\n-  cbuf.insts()->emit_int64(d64);\n-}\n-\n-\/\/ emit 64 bit value and construct relocation entry from RelocationHolder\n-void emit_d64_reloc(CodeBuffer& cbuf, int64_t d64, RelocationHolder const& rspec, int format) {\n-#ifdef ASSERT\n-  if (rspec.reloc()->type() == relocInfo::oop_type &&\n-      d64 != 0 && d64 != (int64_t) Universe::non_oop_word()) {\n-    assert(Universe::heap()->is_in((address)d64), \"should be real oop\");\n-    assert(oopDesc::is_oop(cast_to_oop(d64)), \"cannot embed broken oops in code\");\n-  }\n-#endif\n-  cbuf.relocate(cbuf.insts_mark(), rspec, format);\n-  cbuf.insts()->emit_int64(d64);\n-}\n-\n-\/\/ Access stack slot for load or store\n-void store_to_stackslot(CodeBuffer &cbuf, int opcode, int rm_field, int disp)\n-{\n-  emit_opcode(cbuf, opcode);                  \/\/ (e.g., FILD   [RSP+src])\n-  if (-0x80 <= disp && disp < 0x80) {\n-    emit_rm(cbuf, 0x01, rm_field, RSP_enc);   \/\/ R\/M byte\n-    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    \/\/ SIB byte\n-    emit_d8(cbuf, disp);     \/\/ Displacement  \/\/ R\/M byte\n-  } else {\n-    emit_rm(cbuf, 0x02, rm_field, RSP_enc);   \/\/ R\/M byte\n-    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    \/\/ SIB byte\n-    emit_d32(cbuf, disp);     \/\/ Displacement \/\/ R\/M byte\n-  }\n-}\n-\n-   \/\/ rRegI ereg, memory mem) %{    \/\/ emit_reg_mem\n-void encode_RegMem(CodeBuffer &cbuf,\n-                   int reg,\n-                   int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)\n-{\n-  assert(disp_reloc == relocInfo::none, \"cannot have disp\");\n-  int regenc = reg & 7;\n-  int baseenc = base & 7;\n-  int indexenc = index & 7;\n-\n-  \/\/ There is no index & no scale, use form without SIB byte\n-  if (index == 0x4 && scale == 0 && base != RSP_enc && base != R12_enc) {\n-    \/\/ If no displacement, mode is 0x0; unless base is [RBP] or [R13]\n-    if (disp == 0 && base != RBP_enc && base != R13_enc) {\n-      emit_rm(cbuf, 0x0, regenc, baseenc); \/\/ *\n-    } else if (-0x80 <= disp && disp < 0x80 && disp_reloc == relocInfo::none) {\n-      \/\/ If 8-bit displacement, mode 0x1\n-      emit_rm(cbuf, 0x1, regenc, baseenc); \/\/ *\n-      emit_d8(cbuf, disp);\n-    } else {\n-      \/\/ If 32-bit displacement\n-      if (base == -1) { \/\/ Special flag for absolute address\n-        emit_rm(cbuf, 0x0, regenc, 0x5); \/\/ *\n-        if (disp_reloc != relocInfo::none) {\n-          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);\n-        } else {\n-          emit_d32(cbuf, disp);\n-        }\n-      } else {\n-        \/\/ Normal base + offset\n-        emit_rm(cbuf, 0x2, regenc, baseenc); \/\/ *\n-        if (disp_reloc != relocInfo::none) {\n-          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);\n-        } else {\n-          emit_d32(cbuf, disp);\n-        }\n-      }\n-    }\n-  } else {\n-    \/\/ Else, encode with the SIB byte\n-    \/\/ If no displacement, mode is 0x0; unless base is [RBP] or [R13]\n-    if (disp == 0 && base != RBP_enc && base != R13_enc) {\n-      \/\/ If no displacement\n-      emit_rm(cbuf, 0x0, regenc, 0x4); \/\/ *\n-      emit_rm(cbuf, scale, indexenc, baseenc);\n-    } else {\n-      if (-0x80 <= disp && disp < 0x80 && disp_reloc == relocInfo::none) {\n-        \/\/ If 8-bit displacement, mode 0x1\n-        emit_rm(cbuf, 0x1, regenc, 0x4); \/\/ *\n-        emit_rm(cbuf, scale, indexenc, baseenc);\n-        emit_d8(cbuf, disp);\n-      } else {\n-        \/\/ If 32-bit displacement\n-        if (base == 0x04 ) {\n-          emit_rm(cbuf, 0x2, regenc, 0x4);\n-          emit_rm(cbuf, scale, indexenc, 0x04); \/\/ XXX is this valid???\n-        } else {\n-          emit_rm(cbuf, 0x2, regenc, 0x4);\n-          emit_rm(cbuf, scale, indexenc, baseenc); \/\/ *\n-        }\n-        if (disp_reloc != relocInfo::none) {\n-          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);\n-        } else {\n-          emit_d32(cbuf, disp);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n@@ -999,10 +818,1 @@\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    if (framesize < 0x80) {\n-      emit_opcode(cbuf, 0x83); \/\/ addq rsp, #framesize\n-      emit_rm(cbuf, 0x3, 0x00, RSP_enc);\n-      emit_d8(cbuf, framesize);\n-    } else {\n-      emit_opcode(cbuf, 0x81); \/\/ addq rsp, #framesize\n-      emit_rm(cbuf, 0x3, 0x00, RSP_enc);\n-      emit_d32(cbuf, framesize);\n-    }\n+    __ addq(rsp, framesize);\n@@ -1011,2 +821,1 @@\n-  \/\/ popq rbp\n-  emit_opcode(cbuf, 0x58 | RBP_enc);\n+  __ popq(rbp);\n@@ -1649,13 +1458,3 @@\n-  if (offset >= 0x80) {\n-    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);\n-    emit_opcode(cbuf, 0x8D); \/\/ LEA  reg,[SP+offset]\n-    emit_rm(cbuf, 0x2, reg & 7, 0x04);\n-    emit_rm(cbuf, 0x0, 0x04, RSP_enc);\n-    emit_d32(cbuf, offset);\n-  } else {\n-    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);\n-    emit_opcode(cbuf, 0x8D); \/\/ LEA  reg,[SP+offset]\n-    emit_rm(cbuf, 0x1, reg & 7, 0x04);\n-    emit_rm(cbuf, 0x0, 0x04, RSP_enc);\n-    emit_d8(cbuf, offset);\n-  }\n+\n+  MacroAssembler masm(&cbuf);\n+  masm.lea(as_Register(reg), Address(rsp, offset));\n@@ -1860,54 +1659,0 @@\n-  \/\/ Build emit functions for each basic byte or larger field in the\n-  \/\/ intel encoding scheme (opcode, rm, sib, immediate), and call them\n-  \/\/ from C++ code in the enc_class source block.  Emit functions will\n-  \/\/ live in the main source block for now.  In future, we can\n-  \/\/ generalize this by adding a syntax that specifies the sizes of\n-  \/\/ fields in an order, so that the adlc can build the emit functions\n-  \/\/ automagically\n-\n-  \/\/ Emit primary opcode\n-  enc_class OpcP\n-  %{\n-    emit_opcode(cbuf, $primary);\n-  %}\n-\n-  \/\/ Emit secondary opcode\n-  enc_class OpcS\n-  %{\n-    emit_opcode(cbuf, $secondary);\n-  %}\n-\n-  \/\/ Emit tertiary opcode\n-  enc_class OpcT\n-  %{\n-    emit_opcode(cbuf, $tertiary);\n-  %}\n-\n-  \/\/ Emit opcode directly\n-  enc_class Opcode(immI d8)\n-  %{\n-    emit_opcode(cbuf, $d8$$constant);\n-  %}\n-\n-  \/\/ Emit size prefix\n-  enc_class SizePrefix\n-  %{\n-    emit_opcode(cbuf, 0x66);\n-  %}\n-\n-  enc_class reg(rRegI reg)\n-  %{\n-    emit_rm(cbuf, 0x3, 0, $reg$$reg & 7);\n-  %}\n-\n-  enc_class reg_reg(rRegI dst, rRegI src)\n-  %{\n-    emit_rm(cbuf, 0x3, $dst$$reg & 7, $src$$reg & 7);\n-  %}\n-\n-  enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)\n-  %{\n-    emit_opcode(cbuf, $opcode$$constant);\n-    emit_rm(cbuf, 0x3, $dst$$reg & 7, $src$$reg & 7);\n-  %}\n-\n@@ -2031,91 +1776,0 @@\n-  \/\/ Opcde enc_class for 8\/32 bit immediate instructions with sign-extension\n-  enc_class OpcSE(immI imm)\n-  %{\n-    \/\/ Emit primary opcode and set sign-extend bit\n-    \/\/ Check for 8-bit immediate, and set sign extend bit in opcode\n-    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {\n-      emit_opcode(cbuf, $primary | 0x02);\n-    } else {\n-      \/\/ 32-bit immediate\n-      emit_opcode(cbuf, $primary);\n-    }\n-  %}\n-\n-  enc_class OpcSErm(rRegI dst, immI imm)\n-  %{\n-    \/\/ OpcSEr\/m\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    }\n-    \/\/ Emit primary opcode and set sign-extend bit\n-    \/\/ Check for 8-bit immediate, and set sign extend bit in opcode\n-    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {\n-      emit_opcode(cbuf, $primary | 0x02);\n-    } else {\n-      \/\/ 32-bit immediate\n-      emit_opcode(cbuf, $primary);\n-    }\n-    \/\/ Emit r\/m byte with secondary opcode, after primary opcode.\n-    emit_rm(cbuf, 0x3, $secondary, dstenc);\n-  %}\n-\n-  enc_class OpcSErm_wide(rRegL dst, immI imm)\n-  %{\n-    \/\/ OpcSEr\/m\n-    int dstenc = $dst$$reg;\n-    if (dstenc < 8) {\n-      emit_opcode(cbuf, Assembler::REX_W);\n-    } else {\n-      emit_opcode(cbuf, Assembler::REX_WB);\n-      dstenc -= 8;\n-    }\n-    \/\/ Emit primary opcode and set sign-extend bit\n-    \/\/ Check for 8-bit immediate, and set sign extend bit in opcode\n-    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {\n-      emit_opcode(cbuf, $primary | 0x02);\n-    } else {\n-      \/\/ 32-bit immediate\n-      emit_opcode(cbuf, $primary);\n-    }\n-    \/\/ Emit r\/m byte with secondary opcode, after primary opcode.\n-    emit_rm(cbuf, 0x3, $secondary, dstenc);\n-  %}\n-\n-  enc_class Con8or32(immI imm)\n-  %{\n-    \/\/ Check for 8-bit immediate, and set sign extend bit in opcode\n-    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {\n-      $$$emit8$imm$$constant;\n-    } else {\n-      \/\/ 32-bit immediate\n-      $$$emit32$imm$$constant;\n-    }\n-  %}\n-\n-  enc_class opc2_reg(rRegI dst)\n-  %{\n-    \/\/ BSWAP\n-    emit_cc(cbuf, $secondary, $dst$$reg);\n-  %}\n-\n-  enc_class opc3_reg(rRegI dst)\n-  %{\n-    \/\/ BSWAP\n-    emit_cc(cbuf, $tertiary, $dst$$reg);\n-  %}\n-\n-  enc_class reg_opc(rRegI div)\n-  %{\n-    \/\/ INC, DEC, IDIV, IMOD, JMP indirect, ...\n-    emit_rm(cbuf, 0x3, $secondary, $div$$reg & 7);\n-  %}\n-\n-  enc_class enc_cmov(cmpOp cop)\n-  %{\n-    \/\/ CMOV\n-    $$$emit8$primary;\n-    emit_cc(cbuf, $secondary, $cop$$cmpcode);\n-  %}\n-\n@@ -2168,1 +1822,0 @@\n-    cbuf.set_insts_mark();\n@@ -2171,4 +1824,1 @@\n-      $$$emit8$primary;\n-      emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),\n-                     runtime_call_Relocation::spec(),\n-                     RELOC_DISP32);\n+      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, $meth$$method)));\n@@ -2181,1 +1831,0 @@\n-      $$$emit8$primary;\n@@ -2185,3 +1834,2 @@\n-      emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),\n-                     rspec, RELOC_DISP32);\n-      address mark = cbuf.insts_mark();\n+      address mark = cbuf.insts()->end();\n+      __ call(AddressLiteral(CAST_FROM_FN_PTR(address, $meth$$method), rspec));\n@@ -2191,1 +1839,1 @@\n-        cbuf.shared_stub_to_interp_for(_method, cbuf.insts()->mark_off());\n+        cbuf.shared_stub_to_interp_for(_method, mark - cbuf.insts()->start());\n@@ -2201,1 +1849,0 @@\n-    _masm.clear_inst_mark();\n@@ -2211,523 +1858,0 @@\n-  enc_class reg_opc_imm(rRegI dst, immI8 shift)\n-  %{\n-    \/\/ SAL, SAR, SHR\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    }\n-    $$$emit8$primary;\n-    emit_rm(cbuf, 0x3, $secondary, dstenc);\n-    $$$emit8$shift$$constant;\n-  %}\n-\n-  enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)\n-  %{\n-    \/\/ SAL, SAR, SHR\n-    int dstenc = $dst$$reg;\n-    if (dstenc < 8) {\n-      emit_opcode(cbuf, Assembler::REX_W);\n-    } else {\n-      emit_opcode(cbuf, Assembler::REX_WB);\n-      dstenc -= 8;\n-    }\n-    $$$emit8$primary;\n-    emit_rm(cbuf, 0x3, $secondary, dstenc);\n-    $$$emit8$shift$$constant;\n-  %}\n-\n-  enc_class load_immI(rRegI dst, immI src)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    }\n-    emit_opcode(cbuf, 0xB8 | dstenc);\n-    $$$emit32$src$$constant;\n-  %}\n-\n-  enc_class load_immL(rRegL dst, immL src)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc < 8) {\n-      emit_opcode(cbuf, Assembler::REX_W);\n-    } else {\n-      emit_opcode(cbuf, Assembler::REX_WB);\n-      dstenc -= 8;\n-    }\n-    emit_opcode(cbuf, 0xB8 | dstenc);\n-    emit_d64(cbuf, $src$$constant);\n-  %}\n-\n-  enc_class load_immUL32(rRegL dst, immUL32 src)\n-  %{\n-    \/\/ same as load_immI, but this time we care about zeroes in the high word\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    }\n-    emit_opcode(cbuf, 0xB8 | dstenc);\n-    $$$emit32$src$$constant;\n-  %}\n-\n-  enc_class load_immL32(rRegL dst, immL32 src)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc < 8) {\n-      emit_opcode(cbuf, Assembler::REX_W);\n-    } else {\n-      emit_opcode(cbuf, Assembler::REX_WB);\n-      dstenc -= 8;\n-    }\n-    emit_opcode(cbuf, 0xC7);\n-    emit_rm(cbuf, 0x03, 0x00, dstenc);\n-    $$$emit32$src$$constant;\n-  %}\n-\n-  enc_class load_immP31(rRegP dst, immP32 src)\n-  %{\n-    \/\/ same as load_immI, but this time we care about zeroes in the high word\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    }\n-    emit_opcode(cbuf, 0xB8 | dstenc);\n-    $$$emit32$src$$constant;\n-  %}\n-\n-  enc_class load_immP(rRegP dst, immP src)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc < 8) {\n-      emit_opcode(cbuf, Assembler::REX_W);\n-    } else {\n-      emit_opcode(cbuf, Assembler::REX_WB);\n-      dstenc -= 8;\n-    }\n-    emit_opcode(cbuf, 0xB8 | dstenc);\n-    \/\/ This next line should be generated from ADLC\n-    if ($src->constant_reloc() != relocInfo::none) {\n-      emit_d64_reloc(cbuf, $src$$constant, $src->constant_reloc(), RELOC_IMM64);\n-    } else {\n-      emit_d64(cbuf, $src$$constant);\n-    }\n-  %}\n-\n-  enc_class Con32(immI src)\n-  %{\n-    \/\/ Output immediate\n-    $$$emit32$src$$constant;\n-  %}\n-\n-  enc_class Con32F_as_bits(immF src)\n-  %{\n-    \/\/ Output Float immediate bits\n-    jfloat jf = $src$$constant;\n-    jint jf_as_bits = jint_cast(jf);\n-    emit_d32(cbuf, jf_as_bits);\n-  %}\n-\n-  enc_class Con16(immI src)\n-  %{\n-    \/\/ Output immediate\n-    $$$emit16$src$$constant;\n-  %}\n-\n-  \/\/ How is this different from Con32??? XXX\n-  enc_class Con_d32(immI src)\n-  %{\n-    emit_d32(cbuf,$src$$constant);\n-  %}\n-\n-  enc_class conmemref (rRegP t1) %{    \/\/ Con32(storeImmI)\n-    \/\/ Output immediate memory reference\n-    emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );\n-    emit_d32(cbuf, 0x00);\n-  %}\n-\n-  enc_class lock_prefix()\n-  %{\n-    emit_opcode(cbuf, 0xF0); \/\/ lock\n-  %}\n-\n-  enc_class REX_mem(memory mem)\n-  %{\n-    if ($mem$$base >= 8) {\n-      if ($mem$$index < 8) {\n-        emit_opcode(cbuf, Assembler::REX_B);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_XB);\n-      }\n-    } else {\n-      if ($mem$$index >= 8) {\n-        emit_opcode(cbuf, Assembler::REX_X);\n-      }\n-    }\n-  %}\n-\n-  enc_class REX_mem_wide(memory mem)\n-  %{\n-    if ($mem$$base >= 8) {\n-      if ($mem$$index < 8) {\n-        emit_opcode(cbuf, Assembler::REX_WB);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_WXB);\n-      }\n-    } else {\n-      if ($mem$$index < 8) {\n-        emit_opcode(cbuf, Assembler::REX_W);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_WX);\n-      }\n-    }\n-  %}\n-\n-  \/\/ for byte regs\n-  enc_class REX_breg(rRegI reg)\n-  %{\n-    if ($reg$$reg >= 4) {\n-      emit_opcode(cbuf, $reg$$reg < 8 ? Assembler::REX : Assembler::REX_B);\n-    }\n-  %}\n-\n-  \/\/ for byte regs\n-  enc_class REX_reg_breg(rRegI dst, rRegI src)\n-  %{\n-    if ($dst$$reg < 8) {\n-      if ($src$$reg >= 4) {\n-        emit_opcode(cbuf, $src$$reg < 8 ? Assembler::REX : Assembler::REX_B);\n-      }\n-    } else {\n-      if ($src$$reg < 8) {\n-        emit_opcode(cbuf, Assembler::REX_R);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_RB);\n-      }\n-    }\n-  %}\n-\n-  \/\/ for byte regs\n-  enc_class REX_breg_mem(rRegI reg, memory mem)\n-  %{\n-    if ($reg$$reg < 8) {\n-      if ($mem$$base < 8) {\n-        if ($mem$$index >= 8) {\n-          emit_opcode(cbuf, Assembler::REX_X);\n-        } else if ($reg$$reg >= 4) {\n-          emit_opcode(cbuf, Assembler::REX);\n-        }\n-      } else {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_B);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_XB);\n-        }\n-      }\n-    } else {\n-      if ($mem$$base < 8) {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_R);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_RX);\n-        }\n-      } else {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_RB);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_RXB);\n-        }\n-      }\n-    }\n-  %}\n-\n-  enc_class REX_reg(rRegI reg)\n-  %{\n-    if ($reg$$reg >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-    }\n-  %}\n-\n-  enc_class REX_reg_wide(rRegI reg)\n-  %{\n-    if ($reg$$reg < 8) {\n-      emit_opcode(cbuf, Assembler::REX_W);\n-    } else {\n-      emit_opcode(cbuf, Assembler::REX_WB);\n-    }\n-  %}\n-\n-  enc_class REX_reg_reg(rRegI dst, rRegI src)\n-  %{\n-    if ($dst$$reg < 8) {\n-      if ($src$$reg >= 8) {\n-        emit_opcode(cbuf, Assembler::REX_B);\n-      }\n-    } else {\n-      if ($src$$reg < 8) {\n-        emit_opcode(cbuf, Assembler::REX_R);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_RB);\n-      }\n-    }\n-  %}\n-\n-  enc_class REX_reg_reg_wide(rRegI dst, rRegI src)\n-  %{\n-    if ($dst$$reg < 8) {\n-      if ($src$$reg < 8) {\n-        emit_opcode(cbuf, Assembler::REX_W);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_WB);\n-      }\n-    } else {\n-      if ($src$$reg < 8) {\n-        emit_opcode(cbuf, Assembler::REX_WR);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_WRB);\n-      }\n-    }\n-  %}\n-\n-  enc_class REX_reg_mem(rRegI reg, memory mem)\n-  %{\n-    if ($reg$$reg < 8) {\n-      if ($mem$$base < 8) {\n-        if ($mem$$index >= 8) {\n-          emit_opcode(cbuf, Assembler::REX_X);\n-        }\n-      } else {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_B);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_XB);\n-        }\n-      }\n-    } else {\n-      if ($mem$$base < 8) {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_R);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_RX);\n-        }\n-      } else {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_RB);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_RXB);\n-        }\n-      }\n-    }\n-  %}\n-\n-  enc_class REX_reg_mem_wide(rRegL reg, memory mem)\n-  %{\n-    if ($reg$$reg < 8) {\n-      if ($mem$$base < 8) {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_W);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_WX);\n-        }\n-      } else {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_WB);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_WXB);\n-        }\n-      }\n-    } else {\n-      if ($mem$$base < 8) {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_WR);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_WRX);\n-        }\n-      } else {\n-        if ($mem$$index < 8) {\n-          emit_opcode(cbuf, Assembler::REX_WRB);\n-        } else {\n-          emit_opcode(cbuf, Assembler::REX_WRXB);\n-        }\n-      }\n-    }\n-  %}\n-\n-  enc_class reg_mem(rRegI ereg, memory mem)\n-  %{\n-    \/\/ High registers handle in encode_RegMem\n-    int reg = $ereg$$reg;\n-    int base = $mem$$base;\n-    int index = $mem$$index;\n-    int scale = $mem$$scale;\n-    int disp = $mem$$disp;\n-    relocInfo::relocType disp_reloc = $mem->disp_reloc();\n-\n-    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);\n-  %}\n-\n-  enc_class RM_opc_mem(immI rm_opcode, memory mem)\n-  %{\n-    int rm_byte_opcode = $rm_opcode$$constant;\n-\n-    \/\/ High registers handle in encode_RegMem\n-    int base = $mem$$base;\n-    int index = $mem$$index;\n-    int scale = $mem$$scale;\n-    int displace = $mem$$disp;\n-\n-    relocInfo::relocType disp_reloc = $mem->disp_reloc();       \/\/ disp-as-oop when\n-                                            \/\/ working with static\n-                                            \/\/ globals\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,\n-                  disp_reloc);\n-  %}\n-\n-  enc_class reg_lea(rRegI dst, rRegI src0, immI src1)\n-  %{\n-    int reg_encoding = $dst$$reg;\n-    int base         = $src0$$reg;      \/\/ 0xFFFFFFFF indicates no base\n-    int index        = 0x04;            \/\/ 0x04 indicates no index\n-    int scale        = 0x00;            \/\/ 0x00 indicates no scale\n-    int displace     = $src1$$constant; \/\/ 0x00 indicates no displacement\n-    relocInfo::relocType disp_reloc = relocInfo::none;\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,\n-                  disp_reloc);\n-  %}\n-\n-  enc_class neg_reg(rRegI dst)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    }\n-    \/\/ NEG $dst\n-    emit_opcode(cbuf, 0xF7);\n-    emit_rm(cbuf, 0x3, 0x03, dstenc);\n-  %}\n-\n-  enc_class neg_reg_wide(rRegI dst)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc < 8) {\n-      emit_opcode(cbuf, Assembler::REX_W);\n-    } else {\n-      emit_opcode(cbuf, Assembler::REX_WB);\n-      dstenc -= 8;\n-    }\n-    \/\/ NEG $dst\n-    emit_opcode(cbuf, 0xF7);\n-    emit_rm(cbuf, 0x3, 0x03, dstenc);\n-  %}\n-\n-  enc_class setLT_reg(rRegI dst)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    } else if (dstenc >= 4) {\n-      emit_opcode(cbuf, Assembler::REX);\n-    }\n-    \/\/ SETLT $dst\n-    emit_opcode(cbuf, 0x0F);\n-    emit_opcode(cbuf, 0x9C);\n-    emit_rm(cbuf, 0x3, 0x0, dstenc);\n-  %}\n-\n-  enc_class setNZ_reg(rRegI dst)\n-  %{\n-    int dstenc = $dst$$reg;\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-      dstenc -= 8;\n-    } else if (dstenc >= 4) {\n-      emit_opcode(cbuf, Assembler::REX);\n-    }\n-    \/\/ SETNZ $dst\n-    emit_opcode(cbuf, 0x0F);\n-    emit_opcode(cbuf, 0x95);\n-    emit_rm(cbuf, 0x3, 0x0, dstenc);\n-  %}\n-\n-\n-  \/\/ Compare the lonogs and set -1, 0, or 1 into dst\n-  enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)\n-  %{\n-    int src1enc = $src1$$reg;\n-    int src2enc = $src2$$reg;\n-    int dstenc = $dst$$reg;\n-\n-    \/\/ cmpq $src1, $src2\n-    if (src1enc < 8) {\n-      if (src2enc < 8) {\n-        emit_opcode(cbuf, Assembler::REX_W);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_WB);\n-      }\n-    } else {\n-      if (src2enc < 8) {\n-        emit_opcode(cbuf, Assembler::REX_WR);\n-      } else {\n-        emit_opcode(cbuf, Assembler::REX_WRB);\n-      }\n-    }\n-    emit_opcode(cbuf, 0x3B);\n-    emit_rm(cbuf, 0x3, src1enc & 7, src2enc & 7);\n-\n-    \/\/ movl $dst, -1\n-    if (dstenc >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-    }\n-    emit_opcode(cbuf, 0xB8 | (dstenc & 7));\n-    emit_d32(cbuf, -1);\n-\n-    \/\/ jl,s done\n-    emit_opcode(cbuf, 0x7C);\n-    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);\n-\n-    \/\/ setne $dst\n-    if (dstenc >= 4) {\n-      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);\n-    }\n-    emit_opcode(cbuf, 0x0F);\n-    emit_opcode(cbuf, 0x95);\n-    emit_opcode(cbuf, 0xC0 | (dstenc & 7));\n-\n-    \/\/ movzbl $dst, $dst\n-    if (dstenc >= 4) {\n-      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);\n-    }\n-    emit_opcode(cbuf, 0x0F);\n-    emit_opcode(cbuf, 0xB6);\n-    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);\n-  %}\n-\n-  enc_class Push_ResultXD(regD dst) %{\n-    MacroAssembler _masm(&cbuf);\n-    __ fstp_d(Address(rsp, 0));\n-    __ movdbl($dst$$XMMRegister, Address(rsp, 0));\n-    __ addptr(rsp, 8);\n-  %}\n-\n-  enc_class Push_SrcXD(regD src) %{\n-    MacroAssembler _masm(&cbuf);\n-    __ subptr(rsp, 8);\n-    __ movdbl(Address(rsp, 0), $src$$XMMRegister);\n-    __ fld_d(Address(rsp, 0));\n-  %}\n-\n-\n-  enc_class enc_rethrow()\n-  %{\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf, 0xE9); \/\/ jmp entry\n-    emit_d32_reloc(cbuf,\n-                   (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),\n-                   runtime_call_Relocation::spec(),\n-                   RELOC_DISP32);\n-  %}\n-\n@@ -4591,11 +3715,0 @@\n-\/\/ XXX\n-\/\/ \/\/ Conditional move double reg-reg\n-\/\/ pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)\n-\/\/ %{\n-\/\/     single_instruction;\n-\/\/     dst    : S4(write);\n-\/\/     src    : S3(read);\n-\/\/     cr     : S3(read);\n-\/\/     DECODE : S0;     \/\/ any decoder\n-\/\/ %}\n-\n@@ -5912,1 +5025,1 @@\n-    __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);\n+    __ xorpd($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -5923,2 +5036,3 @@\n-  opcode(0x8B);\n-  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$Address);\n+  %}\n@@ -5934,2 +5048,3 @@\n-  opcode(0x8B);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ movq($dst$$Register, $src$$Address);\n+  %}\n@@ -5945,2 +5060,3 @@\n-  opcode(0x8B);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ movq($dst$$Register, $src$$Address);\n+  %}\n@@ -6404,2 +5520,3 @@\n-  opcode(0x89);\n-  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ movl($dst$$Address, $src$$Register);\n+  %}\n@@ -6415,2 +5532,3 @@\n-  opcode(0x89);\n-  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ movq($dst$$Address, $src$$Register);\n+  %}\n@@ -6426,2 +5544,3 @@\n-  opcode(0x89);\n-  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ movq($dst$$Address, $src$$Register);\n+  %}\n@@ -7382,27 +6501,0 @@\n-\/\/ DISABLED: Requires the ADLC to emit a bottom_type call that\n-\/\/ correctly meets the two pointer arguments; one is an incoming\n-\/\/ register but the other is a memory operand.  ALSO appears to\n-\/\/ be buggy with implicit null checks.\n-\/\/\n-\/\/\/\/ Conditional move\n-\/\/instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)\n-\/\/%{\n-\/\/  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));\n-\/\/  ins_cost(250);\n-\/\/  format %{ \"CMOV$cop $dst,$src\\t# ptr\" %}\n-\/\/  opcode(0x0F,0x40);\n-\/\/  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );\n-\/\/  ins_pipe( pipe_cmov_mem );\n-\/\/%}\n-\/\/\n-\/\/\/\/ Conditional move\n-\/\/instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)\n-\/\/%{\n-\/\/  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));\n-\/\/  ins_cost(250);\n-\/\/  format %{ \"CMOV$cop $dst,$src\\t# ptr\" %}\n-\/\/  opcode(0x0F,0x40);\n-\/\/  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );\n-\/\/  ins_pipe( pipe_cmov_mem );\n-\/\/%}\n-\n@@ -7563,12 +6655,0 @@\n-\/\/ instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)\n-\/\/ %{\n-\/\/   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));\n-\n-\/\/   ins_cost(200); \/\/ XXX\n-\/\/   format %{ \"jn$cop    skip\\t# signed cmove float\\n\\t\"\n-\/\/             \"movss     $dst, $src\\n\"\n-\/\/     \"skip:\" %}\n-\/\/   ins_encode(enc_cmovf_mem_branch(cop, dst, src));\n-\/\/   ins_pipe(pipe_slow);\n-\/\/ %}\n-\n@@ -8655,2 +7735,3 @@\n-  opcode(0x2B);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ subq($dst$$Register, $src$$Register);\n+  %}\n@@ -11308,17 +10389,0 @@\n-\/\/ instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)\n-\/\/ %{\n-\/\/   match(Set dst (ConvI2L src));\n-\/\/ \/\/   predicate(_kids[0]->_leaf->as_Type()->type()->is_int()->_lo >= 0 &&\n-\/\/ \/\/             _kids[0]->_leaf->as_Type()->type()->is_int()->_hi >= 0);\n-\/\/   predicate(((const TypeNode*) n)->type()->is_long()->_hi ==\n-\/\/             (unsigned int) ((const TypeNode*) n)->type()->is_long()->_hi &&\n-\/\/             ((const TypeNode*) n)->type()->is_long()->_lo ==\n-\/\/             (unsigned int) ((const TypeNode*) n)->type()->is_long()->_lo);\n-\n-\/\/   format %{ \"movl    $dst, $src\\t# unsigned i2l\" %}\n-\/\/   ins_encode(enc_copy(dst, src));\n-\/\/ \/\/   opcode(0x63); \/\/ needs REX.W\n-\/\/ \/\/   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));\n-\/\/   ins_pipe(ialu_reg_reg);\n-\/\/ %}\n-\n@@ -12603,11 +11667,0 @@\n-\/\/ \/\/ \/\/ Cisc-spilled version of cmpU_rReg\n-\/\/ \/\/instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)\n-\/\/ \/\/%{\n-\/\/ \/\/  match(Set cr (CmpU (LoadI op1) op2));\n-\/\/ \/\/\n-\/\/ \/\/  format %{ \"CMPu   $op1,$op2\" %}\n-\/\/ \/\/  ins_cost(500);\n-\/\/ \/\/  opcode(0x39);  \/* Opcode 39 \/r *\/\n-\/\/ \/\/  ins_encode( OpcP, reg_mem( op1, op2) );\n-\/\/ \/\/%}\n-\n@@ -12649,11 +11702,0 @@\n-\/\/ \/\/ \/\/ Cisc-spilled version of cmpP_rReg\n-\/\/ \/\/instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)\n-\/\/ \/\/%{\n-\/\/ \/\/  match(Set cr (CmpP (LoadP op1) op2));\n-\/\/ \/\/\n-\/\/ \/\/  format %{ \"CMPu   $op1,$op2\" %}\n-\/\/ \/\/  ins_cost(500);\n-\/\/ \/\/  opcode(0x39);  \/* Opcode 39 \/r *\/\n-\/\/ \/\/  ins_encode( OpcP, reg_mem( op1, op2) );\n-\/\/ \/\/%}\n-\n@@ -13636,1 +12678,3 @@\n-  ins_encode(enc_rethrow);\n+  ins_encode %{\n+    __ jump(RuntimeAddress(OptoRuntime::rethrow_stub()), noreg);\n+  %}\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":34,"deletions":990,"binary":false,"changes":1024,"status":"modified"}]}