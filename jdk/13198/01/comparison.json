{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.io.Flushable;\n@@ -345,1 +346,2 @@\n-     * turn cause the stream to be closed.  <\/p>\n+     * turn cause the stream to be closed.  The returned channel implements\n+     * {@linkplain Flushable}; flushing the channel will flush the stream. <\/p>\n@@ -359,1 +361,28 @@\n-        return new WritableByteChannelImpl(out);\n+        return new WritableByteChannelImpl(out, false);\n+    }\n+\n+    \/**\n+     * Constructs a channel that writes bytes to the given stream.\n+     *\n+     * <p> The resulting channel will not be buffered; it will simply redirect\n+     * its I\/O operations to the given stream.  Closing the channel will in\n+     * turn cause the stream to be closed.  The stream will be flushed after\n+     * each write if the {@code autoFlush} parameter is {@code true}. <\/p>\n+     *\n+     * @param  out\n+     *         The stream to which bytes are to be written\n+     *\n+     * @param  autoFlush\n+     *         Whether to flush the stream after each write to the channel\n+     *\n+     * @return  A new writable byte channel\n+     *\/\n+    public static WritableByteChannel newChannel(OutputStream out,\n+                                                 boolean autoFlush) {\n+        Objects.requireNonNull(out, \"out\");\n+\n+        if (out.getClass() == FileOutputStream.class) {\n+            return ((FileOutputStream) out).getChannel();\n+        }\n+\n+        return new WritableByteChannelImpl(out, autoFlush);\n@@ -364,1 +393,1 @@\n-        implements WritableByteChannel\n+        implements Flushable, WritableByteChannel\n@@ -367,0 +396,1 @@\n+        private final boolean autoFlush;\n@@ -371,1 +401,1 @@\n-        WritableByteChannelImpl(OutputStream out) {\n+        WritableByteChannelImpl(OutputStream out, boolean autoFlush) {\n@@ -373,0 +403,1 @@\n+            this.autoFlush = autoFlush;\n@@ -398,0 +429,2 @@\n+                if (autoFlush)\n+                    out.flush();\n@@ -402,0 +435,4 @@\n+        public void flush() throws IOException {\n+            out.flush();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4417152 4481572 6248930 6725399 6884800 8220477 8275149\n+ * @bug 4417152 4481572 4670339 6248930 6725399 6884800 8220477 8275149\n@@ -27,0 +27,4 @@\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main Basic\n+ * @key randomness\n@@ -33,0 +37,3 @@\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.RandomFactory;\n@@ -35,0 +42,1 @@\n+    private static final Random RND = RandomFactory.getRandom();\n@@ -189,0 +197,2 @@\n+            testNewChannelOutFlush();\n+\n@@ -291,0 +301,26 @@\n+    private static void testNewChannelOutFlush() throws Exception {\n+        final int size = 8192;\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream(size);\n+        try (BufferedOutputStream bos = new BufferedOutputStream(baos, size);\n+             WritableByteChannel wbc = Channels.newChannel(bos, true);) {\n+            int max = size + 1 + RND.nextInt(size);\n+            byte[] expected = new byte[max];\n+            RND.nextBytes(expected);\n+            int offset = 0;\n+            while (offset < max) {\n+                int length = 1 + RND.nextInt(max - offset);\n+                ByteBuffer buf = ByteBuffer.wrap(expected, offset, length);\n+                int n = wbc.write(buf);\n+                if (n < 0)\n+                    break;\n+                offset += n;\n+                long baosSize = baos.size();\n+                if (baosSize != offset)\n+                    throw new RuntimeException(baosSize + \" != \" + offset);\n+            }\n+            if (!Arrays.equals(expected, baos.toByteArray()))\n+                throw new RuntimeException(\"Arrays are not equal\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/Basic.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"}]}