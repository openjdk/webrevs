{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,2 +344,5 @@\n-     * its I\/O operations to the given stream.  Closing the channel will in\n-     * turn cause the stream to be closed.  <\/p>\n+     * its I\/O operations to the given stream.  Upon returning from the\n+     * channel's {@linkplain WritableByteChannel#write write} method, the\n+     * state of the stream will be as if its {@linkplain OutputStream#flush\n+     * flush} method had been invoked.  Closing the channel will in turn cause\n+     * the stream to be closed. <\/p>\n@@ -398,0 +401,1 @@\n+                out.flush();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4417152 4481572 6248930 6725399 6884800 8220477 8275149\n+ * @bug 4417152 4481572 4670339 6248930 6725399 6884800 8220477 8275149\n@@ -27,0 +27,4 @@\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main Basic\n+ * @key randomness\n@@ -33,0 +37,3 @@\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.RandomFactory;\n@@ -35,0 +42,1 @@\n+    private static final Random RND = RandomFactory.getRandom();\n@@ -189,0 +197,2 @@\n+            testNewChannelOutFlush();\n+\n@@ -291,0 +301,26 @@\n+    private static void testNewChannelOutFlush() throws Exception {\n+        final int size = 8192;\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream(size);\n+        try (BufferedOutputStream bos = new BufferedOutputStream(baos, size);\n+             WritableByteChannel wbc = Channels.newChannel(bos);) {\n+            int max = size + 1 + RND.nextInt(size);\n+            byte[] expected = new byte[max];\n+            RND.nextBytes(expected);\n+            int offset = 0;\n+            while (offset < max) {\n+                int length = 1 + RND.nextInt(max - offset);\n+                ByteBuffer buf = ByteBuffer.wrap(expected, offset, length);\n+                int n = wbc.write(buf);\n+                if (n < 0)\n+                    break;\n+                offset += n;\n+                long baosSize = baos.size();\n+                if (baosSize != offset)\n+                    throw new RuntimeException(baosSize + \" != \" + offset);\n+            }\n+            if (!Arrays.equals(expected, baos.toByteArray()))\n+                throw new RuntimeException(\"Arrays are not equal\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/Basic.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"}]}