{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1797,3 +1797,2 @@\n-    \/** Return tree simulating the assignment {@code this.this$n = this$n}.\n-     *\/\n-    JCStatement initOuterThis(int pos, VarSymbol rhs) {\n+    \/** Return tree simulating null checking outer this and assigning. *\/\n+    JCStatement initOuterThis(int pos, VarSymbol rhs, boolean stores) {\n@@ -1801,2 +1800,0 @@\n-        VarSymbol lhs = outerThisStack.head;\n-        Assert.check(rhs.owner.owner == lhs.owner);\n@@ -1804,3 +1801,6 @@\n-        return\n-            make.Exec(\n-                make.Assign(\n+        var nullCheck = attr.makeNullCheck(make.Ident(rhs));\n+        JCExpression expression;\n+        if (stores) {\n+            VarSymbol lhs = outerThisStack.head;\n+            Assert.check(rhs.owner.owner == lhs.owner);\n+            expression = make.Assign(\n@@ -1808,1 +1808,5 @@\n-                    make.Ident(rhs)).setType(lhs.erasure(types)));\n+                    nullCheck).setType(lhs.erasure(types));\n+        } else {\n+            expression = nullCheck;\n+        }\n+        return make.Exec(expression);\n@@ -2213,3 +2217,7 @@\n-        if (currentClass.hasOuterInstance() && shouldEmitOuterThis(currentClass)) {\n-            tree.defs = tree.defs.prepend(otdef);\n-            enterSynthetic(tree.pos(), otdef.sym, currentClass.members());\n+        \/\/ otherwise just prepend enclosing instance null check code\n+        if (currentClass.hasOuterInstance()) {\n+            boolean storesThis = shouldEmitOuterThis(currentClass);\n+            if (storesThis) {\n+                tree.defs = tree.defs.prepend(otdef);\n+                enterSynthetic(tree.pos(), otdef.sym, currentClass.members());\n+            }\n@@ -2221,1 +2229,1 @@\n-                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym, storesThis)) ;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        if (!javapOut.contains(\"0: #21(): CLASS_EXTENDS, type_index=65535\"))\n+        if (!javapOut.contains(\"0: #27(): CLASS_EXTENDS, type_index=65535\"))\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnnotatedExtendsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,3 +92,3 @@\n-                        \"1: getfield      #1                  \/\/ Field this$1:LCheckNestmateAttrs$Inner;\",\n-                        \"4: getfield      #13                 \/\/ Field CheckNestmateAttrs$Inner.this$0:LCheckNestmateAttrs;\",\n-                        \"7: invokevirtual #19                 \/\/ Method CheckNestmateAttrs.test:()V\",\n+                        \"1: getfield      #7                  \/\/ Field this$1:LCheckNestmateAttrs$Inner;\",\n+                        \"4: getfield      #19                 \/\/ Field CheckNestmateAttrs$Inner.this$0:LCheckNestmateAttrs;\",\n+                        \"7: invokevirtual #25                 \/\/ Method CheckNestmateAttrs.test:()V\",\n","filename":"test\/langtools\/tools\/javac\/nestmates\/CheckNestmateAttrs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8164714\n+ * @summary No null check for immediate enclosing instance for VM\/reflective\n+ *          invocation of inner classes\n+ *\n+ * @clean *\n+ * @compile OuterThisNullChecks.java\n+ * @run junit OuterThisNullChecks\n+ *\n+ * @clean *\n+ * @compile --release 17 OuterThisNullChecks.java\n+ * @run junit OuterThisNullChecks\n+ *\/\n+class OuterThisNullChecks {\n+    static Stream<Class<?>> testClasses() {\n+        return Stream.of(NoOuterThis.class, OuterThisField.class);\n+    }\n+\n+    @MethodSource(\"testClasses\")\n+    @ParameterizedTest\n+    void testNoOuter(Class<?> clz) {\n+        var ite = assertThrows(InvocationTargetException.class, () -> clz.getDeclaredConstructor(OuterThisNullChecks.class).newInstance((Object) null));\n+        assertInstanceOf(NullPointerException.class, ite.getCause());\n+\n+        MethodHandle mh = assertDoesNotThrow(() -> MethodHandles.lookup().findConstructor(clz, MethodType.methodType(void.class, OuterThisNullChecks.class)))\n+                .asType(MethodType.methodType(Object.class, Object.class));\n+        assertThrows(NullPointerException.class, () -> {\n+            Object stub = mh.invokeExact((Object) null);\n+        });\n+    }\n+\n+    class NoOuterThis {}\n+    class OuterThisField {\n+        @Override\n+        public String toString() {\n+            return \"outer this = \" + OuterThisNullChecks.this;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/outerThisNull\/OuterThisNullChecks.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}