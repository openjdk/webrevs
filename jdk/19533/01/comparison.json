{"files":[{"patch":"@@ -1739,1 +1739,1 @@\n-        if (isParseIntegerOnly()\n+        if (isParseIntegerOnly() && position < text.length()\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485\n+ * @bug 8327640 8331485 8333456\n@@ -212,0 +212,12 @@\n+    \/\/ 8333456: Parse values with no compact suffix -> which allows parsing to iterate\n+    \/\/ position to the same value as string length which throws\n+    \/\/ StringIndexOutOfBoundsException upon charAt invocation\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidNoSuffixParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseIntOnlyTest(String toParse, double expectedValue) {\n+        cmpctFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+        cmpctFmt.setParseIntegerOnly(false);\n+    }\n+\n@@ -410,0 +422,12 @@\n+    \/\/ No compact suffixes\n+    private static Stream<Arguments> compactValidNoSuffixParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"5\", 5),\n+                Arguments.of(\"50\", 50),\n+                Arguments.of(\"50.\", 50),\n+                Arguments.of(\"5,000\", 5000),\n+                Arguments.of(\"5,000.\", 5000),\n+                Arguments.of(\"5,000.00\", 5000)\n+        );\n+    }\n+\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}