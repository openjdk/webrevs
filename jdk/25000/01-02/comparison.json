{"files":[{"patch":"@@ -340,2 +340,2 @@\n-\n-      if (is_gc_overhead_limit_reached()) {\n+      \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator should return null as well for global consistency.\n+      if (_gc_overhead_counter >= GCOverheadLimitThreshold) {\n@@ -363,1 +363,3 @@\n-bool ParallelScavengeHeap::is_gc_overhead_limit_reached() {\n+bool ParallelScavengeHeap::check_gc_overhead_limit() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+\n@@ -373,1 +375,0 @@\n-        log_info(gc)(\"GCOverheadLimitThreshold %zu reached.\", GCOverheadLimitThreshold);\n@@ -404,10 +405,6 @@\n-    if (is_gc_overhead_limit_reached()) {\n-      \/\/ Apps expect soft-refs cleared before OOM\n-      const bool clear_all_soft_refs = true;\n-      PSParallelCompact::invoke(clear_all_soft_refs);\n-      return nullptr;\n-    }\n-\n-    result = expand_heap_and_allocate(size, is_tlab);\n-    if (result != nullptr) {\n-      return result;\n+    \/\/ If gc-overhead is reached, we will skip allocation.\n+    if (!check_gc_overhead_limit()) {\n+      result = expand_heap_and_allocate(size, is_tlab);\n+      if (result != nullptr) {\n+        return result;\n+      }\n@@ -434,1 +431,2 @@\n-  if (is_gc_overhead_limit_reached()) {\n+  if (check_gc_overhead_limit()) {\n+    log_info(gc)(\"GCOverheadLimitThreshold %zu reached.\", GCOverheadLimitThreshold);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  bool is_gc_overhead_limit_reached();\n+  bool check_gc_overhead_limit();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}