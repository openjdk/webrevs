{"files":[{"patch":"@@ -512,1 +512,41 @@\n-#end[char]\n+    public $Type$Buffer put(int index, CharSequence csq, int start, int end) {\n+#if[rw]\n+        Objects.checkFromToIndex(start, end, csq.length());\n+        Objects.checkIndex(index, limit());\n+        if (end - start > limit() - index)\n+            throw new BufferOverflowException();\n+\n+        \/\/\n+        \/\/ Cannot delegate to put(int,CharBuffer,int,int) until after the check\n+        \/\/ for BufferOverflowException as that method would instead throw an\n+        \/\/ IndexOutOfBoundsException for the same condition\n+        \/\/\n+        if (csq instanceof CharBuffer cb)\n+            return put(index, cb, start, end - start);\n+\n+        if (csq instanceof String ||\n+            csq instanceof StringBuilder ||\n+            csq instanceof StringBuffer) {\n+\n+            char[] buf = new char[Math.min(APPEND_BUF_SIZE, end - start)];\n+            while (start < end) {\n+                int count = end - start;\n+                if (count > buf.length)\n+                    count = buf.length;\n+\n+                if (csq instanceof String str) {\n+                    str.getChars(start, start + count, buf, 0);\n+                } else if (csq instanceof StringBuilder sb) {\n+                    sb.getChars(start, start + count, buf, 0);\n+                } else if (csq instanceof StringBuffer sb) {\n+                    sb.getChars(start, start + count, buf, 0);\n+                }\n+\n+                putArray(index, buf, 0, count);\n+\n+                start += count;\n+                index += count;\n+            }\n+\n+            return this;\n+        }\n@@ -514,0 +554,7 @@\n+        return super.put(index, csq, start, end);\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n+    }\n+\n+#end[char]\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -355,0 +355,32 @@\n+    public $Type$Buffer put(int index, CharSequence csq, int start, int end) {\n+#if[rw]\n+        Objects.checkFromToIndex(start, end, csq.length());\n+        Objects.checkIndex(index, limit());\n+        if (end - start > limit() - index)\n+            throw new BufferOverflowException();\n+\n+        \/\/\n+        \/\/ Cannot delegate to put(int,CharBuffer,int,int) until after the check\n+        \/\/ for BufferOverflowException as that method would instead throw an\n+        \/\/ IndexOutOfBoundsException for the same condition\n+        \/\/\n+        if (csq instanceof CharBuffer cb)\n+            return put(index, cb, start, end - start);\n+\n+        if (csq instanceof String str) {\n+            str.getChars(start, end, hb, ix(index)); \n+            return this;\n+        } else if (csq instanceof StringBuffer strbuf) {\n+            strbuf.getChars(start, end, hb, ix(index));\n+            return this;\n+        } else if (csq instanceof StringBuilder strbld) {\n+            strbld.getChars(start, end, hb, ix(index));\n+            return this;\n+        }\n+\n+        return super.put(index, csq, start, end);\n+#else[rw]\n+        throw new ReadOnlyBufferException();\n+#end[rw]\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -62,2 +62,7 @@\n- *   $type$ array{#if[char]?, a string,} or some other $type$\n- *   buffer into this buffer;<\/p><\/li>\n+ *   $type$ array{#if[char]?, a string, a <code>CharSequence<\/code>,}\n+ *   or some other $type$ buffer into this buffer{#if[char]?,}{#if[!char]?;}\n+#if[char]\n+ *   with relative bulk put capability for {@linkplain CharSequence} sources\n+ *   provided in the form of the\n+ *   {@linkplain #append(CharSequence,int,int) <i>append<\/i>} methods;\n+#end[char]\n@@ -1470,0 +1475,91 @@\n+    \/**\n+     * Absolute bulk <i>put<\/i> method&nbsp;&nbsp;<i>(optional operation)<\/i>.\n+     *\n+     * <p> This method transfers {@code $type$}s from the given\n+     * {@link CharSequence} into this buffer.  If there are more {@code $type$}s\n+     * to be copied from the {@code CharSequence} than remain in this buffer,\n+     * that is, if\n+     * <code>end&nbsp;-&nbsp;start&nbsp;>&nbsp;\n+     * limit()&nbsp;-&nbsp;index<\/code>,\n+     * then no {@code $type$}s are transferred and a\n+     * {@link BufferOverflowException} is thrown.\n+     *\n+     * <p> Otherwise, this method copies\n+     * <code>n&nbsp;=&nbsp;end&nbsp;-&nbsp;start<\/code> {@code $type$}s\n+     * from the given {@code CharSequence} into this buffer, starting at the\n+     * given {@code start} index and at the given {@code index} in this buffer.\n+     * The position of this buffer is unchanged.\n+     *\n+     * <p> In other words, an invocation of this method of the form\n+     * <code>dst.put(index,&nbsp;csq,&nbsp;start,&nbsp;end)<\/code>\n+     * has exactly the same effect as the loop\n+     *\n+     * <pre>{@code\n+     *     for (int i = start, j = index; i < end; i++, j++)\n+     *         dst.put(j, csq.charAt(i));\n+     * }<\/pre>\n+     *\n+     * except that it first checks that there is sufficient space in this\n+     * buffer and it is potentially much more efficient.\n+     *\n+     * @apiNote\n+     * Unlike the other four-parameter absolute bulk put methods in this class,\n+     * this method:\n+     * <ul>\n+     * <li>defines the range of characters to be read from the source in terms\n+     * of the half-open interval <code>[start,&nbsp;end)<\/code> instead of\n+     * an {@code offset} and a {@code length};<\/li>\n+     * <li>throws a {@code BufferOverflowException} instead of an\n+     * {@code IndexOutOfBoundsException} for the condition\n+     * <code>index&nbsp;+&nbsp;end&nbsp;-&nbsp;start&nbsp;>&nbsp;limit()<\/code>.\n+     * <\/ul>\n+     *\n+     * @param  index\n+     *         The index in this buffer at which the first char will be written;\n+     *         must be non-negative and less than {@code limit()}\n+     *\n+     * @param  csq\n+     *         The {@code CharSequence} from which {@code $type$}s\n+     *         are to be read\n+     *\n+     * @param  start\n+     *         The offset within the {@code CharSequence} of the first $type$\n+     *         to be read; must be non-negative and no larger than\n+     *         {@code csq.length()}\n+     *\n+     * @param  end\n+     *         The offset within the {@code CharSequence} of the last $type$\n+     *         to be read, plus one; must be non-negative and no larger than\n+     *         {@code csq.length()}\n+     *\n+     * @return  This buffer\n+     *\n+     * @throws  BufferOverflowException\n+     *          If there is insufficient space in this buffer\n+     *\n+     * @throws  IndexOutOfBoundsException\n+     *          If the preconditions on the {@code index}, {@code start},\n+     *          and {@code end} parameters do not hold\n+     *\n+     * @throws  ReadOnlyBufferException\n+     *          If this buffer is read-only\n+     *\n+     * @see #append(CharSequence, int, int)\n+     * @see #put(int, $type$[], int, int)\n+     * @see #put(int, $Type$Buffer, int, int)\n+     * @since 22\n+     *\/\n+    public $Type$Buffer put(int index, CharSequence csq, int start, int end) {\n+        Objects.checkFromToIndex(start, end, csq.length());\n+        Objects.checkIndex(index, limit());\n+        if (end - start > limit() - index)\n+            throw new BufferOverflowException();\n+        if (isReadOnly())\n+            throw new ReadOnlyBufferException();\n+\n+        for (int i = start; i < end; i++)\n+            this.put(index++, csq.charAt(i));\n+\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":98,"deletions":2,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Random;\n@@ -48,1 +47,0 @@\n-\n@@ -504,4 +502,0 @@\n-        Random rnd = new Random();\n-        long seed = rnd.nextLong();\n-        rnd = new Random(seed);\n-\n@@ -510,1 +504,1 @@\n-            int unitSize = 1 << rnd.nextInt(maxPow2);\n+            int unitSize = 1 << RND.nextInt(maxPow2);\n@@ -512,1 +506,1 @@\n-            int index = rnd.nextInt(unitSize << 1);\n+            int index = RND.nextInt(unitSize << 1);\n@@ -633,1 +627,1 @@\n-        \/\/ 8306623 and 8306959\n+        \/\/ 8306623, 8306959, and 4860681\n@@ -671,1 +665,1 @@\n-                    tryCatch(cbIOOBE, IndexOutOfBoundsException.class, () ->\n+                    catchIndexOutOfBounds(cbIOOBE, () ->\n@@ -674,1 +668,1 @@\n-                tryCatch(cb, IndexOutOfBoundsException.class, () ->\n+                catchIndexOutOfBounds(cb, () ->\n@@ -684,0 +678,32 @@\n+\n+                \/\/ begin 4860681\n+\n+                \/\/ put() should throw NullPointerException\n+                catchNullArgument(cb, () ->\n+                    cb.put(7, (CharSequence)null, 0, 42));\n+\n+                \/\/ BufferOverflowException\n+                \/\/ put() should throw BufferOverflowException\n+                tryCatch(cbBOE, BufferOverflowException.class, () ->\n+                    cbBOE.put(0, csq, cslen\/4, cslen\/2));\n+\n+                \/\/ put() should throw IndexOutOfBoundsException\n+                for (int[] bds : bounds)\n+                    tryCatch(cbIOOBE, IndexOutOfBoundsException.class, () ->\n+                        cbIOOBE.put(0, csq, bds[0], bds[1]));\n+\n+                \/\/ Verify correct copying behavior\n+                int cap = Math.max(1, RND.nextInt(cslen));\n+                CharBuffer cbTarget = f.apply(cap);\n+                int index = RND.nextInt(cap);\n+                int afterLast = Math.max(1, RND.nextInt(cslen));\n+                int first = Math.max(0, afterLast - (cap - index));\n+                cbTarget.put(index, csq, first, afterLast);\n+                for (int j = index, i = first; i < afterLast; i++, j++) {\n+                    if (cbTarget.get(j) != csq.charAt(i)) {\n+                        String s = String.format(\"Unequal values (seed %d)%n\");\n+                        throw new RuntimeException(s);\n+                    }\n+                }\n+\n+                \/\/ end 4860681\n@@ -1063,0 +1089,3 @@\n+        \/\/ 4860681\n+        catchReadOnlyBuffer(b, () -> rb.put(0, \"123\", 1, 2));\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic-X.java.template","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -27,3 +27,7 @@\n- *      4526177 4463011 4660660 4661219 4663521 4782970 4804304 4938424 5029431\n- *      5071718 6231529 6221101 6234263 6535542 6591971 6593946 6795561 7190219\n- *      7199551 8065556 8149469 8230665 8237514 8306374 8306623 8306959\n+ *      4526177 4463011 4660660 4661219 4663521 4782970 4804304 4860681 4938424\n+ *      5029431 5071718 6231529 6221101 6234263 6535542 6591971 6593946 6795561\n+ *      7190219 7199551 8065556 8149469 8230665 8237514 8306374 8306623 8306959\n+ * @key randomness\n+ * @library ..\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -32,0 +36,1 @@\n+ * @run main Basic\n@@ -42,0 +47,3 @@\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n@@ -45,0 +53,2 @@\n+    private static final Random RND = RandomFactory.getRandom();\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -701,0 +701,35 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1065,0 +1100,3 @@\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicByte.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Random;\n@@ -48,1 +49,0 @@\n-\n@@ -633,1 +633,4 @@\n-        \/\/ 8306623 and 8306959\n+        \/\/ 8306623, 8306959, and 4860681\n+        long seed = System.nanoTime();\n+        Random rnd = new Random(seed);\n+\n@@ -671,1 +674,1 @@\n-                    tryCatch(cbIOOBE, IndexOutOfBoundsException.class, () ->\n+                    catchIndexOutOfBounds(cbIOOBE, () ->\n@@ -674,1 +677,1 @@\n-                tryCatch(cb, IndexOutOfBoundsException.class, () ->\n+                catchIndexOutOfBounds(cb, () ->\n@@ -684,0 +687,32 @@\n+\n+                \/\/ begin 4860681\n+\n+                \/\/ put() should throw NullPointerException\n+                catchNullArgument(cb, () ->\n+                    cb.put(7, (CharSequence)null, 0, 42));\n+\n+                \/\/ BufferOverflowException\n+                \/\/ put() should throw BufferOverflowException\n+                tryCatch(cbBOE, BufferOverflowException.class, () ->\n+                    cbBOE.put(0, csq, cslen\/4, cslen\/2));\n+\n+                \/\/ put() should throw IndexOutOfBoundsException\n+                for (int[] bds : bounds)\n+                    tryCatch(cbIOOBE, IndexOutOfBoundsException.class, () ->\n+                        cbIOOBE.put(0, csq, bds[0], bds[1]));\n+\n+                \/\/ Verify correct copying behavior\n+                int cap = Math.max(1, rnd.nextInt(cslen));\n+                CharBuffer cbTarget = f.apply(cap);\n+                int index = rnd.nextInt(cap);\n+                int afterLast = Math.max(1, rnd.nextInt(cslen));\n+                int first = Math.max(0, afterLast - (cap - index));\n+                cbTarget.put(index, csq, first, afterLast);\n+                for (int j = index, i = first; i < afterLast; i++, j++) {\n+                    if (cbTarget.get(j) != csq.charAt(i)) {\n+                        String s = String.format(\"Unequal values (seed %d)%n\");\n+                        throw new RuntimeException(s);\n+                    }\n+                }\n+\n+                \/\/ end 4860681\n@@ -1063,0 +1098,3 @@\n+        \/\/ 4860681\n+        catchReadOnlyBuffer(b, () -> rb.put(0, \"123\", 1, 2));\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicChar.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -701,0 +701,35 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1061,0 +1096,3 @@\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicDouble.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -701,0 +701,35 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1061,0 +1096,3 @@\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicFloat.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -701,0 +701,35 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1061,0 +1096,3 @@\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicInt.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -701,0 +701,35 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1061,0 +1096,3 @@\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicLong.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -701,0 +701,35 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1061,0 +1096,3 @@\n+\n+\n+\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicShort.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n","filename":"test\/jdk\/java\/nio\/Buffer\/CopyDirectMemory.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}