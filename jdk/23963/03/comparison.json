{"files":[{"patch":"@@ -2367,0 +2367,1 @@\n+  INSN(brev8,  0b0010011, 0b101, 0b011010000111);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  product(bool, UseZbkb, false, EXPERIMENTAL, \"Use Zbkb instructions\")           \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1899,0 +1899,4 @@\n+    case Op_ReverseI:\n+    case Op_ReverseL:\n+      return UseZbkb;\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -248,0 +248,27 @@\n+\/\/ Reverse bits instruction\n+instruct bits_reverse_I(iRegINoSp dst, iRegIorL2I src)\n+%{\n+  match(Set dst (ReverseI src));\n+  ins_cost(ALU_COST * 3);\n+  format %{ \"bits_reverse_I  $dst, $src\" %}\n+  ins_encode %{\n+    __ rev8($dst$$Register, $src$$Register);\n+    __ brev8($dst$$Register, $dst$$Register);\n+    __ srai($dst$$Register, $dst$$Register, 32);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct bits_reverse_L(iRegLNoSp dst, iRegL src)\n+%{\n+  match(Set dst (ReverseL src));\n+  ins_cost(ALU_COST * 2);\n+  format %{ \"bits_reverse_L  $dst, $src\" %}\n+  ins_encode %{\n+    __ rev8($dst$$Register, $src$$Register);\n+    __ brev8($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -159,0 +159,1 @@\n+  decl(ext_Zbkb        , \"Zbkb\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbkb))        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8318220\n+ * @summary Test ReverseI intrinsic\n+ *\n+ * @library \/test\/lib \/\n+ * @requires os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbkb.*\"\n+ * @run main\/othervm compiler.c2.riscv64.TestIntegerReverse\n+ *\/\n+\n+package compiler.c2.riscv64;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import static compiler.lib.golden.GoldenReverse.golden_reverse_integer;\n+\n+public class TestIntegerReverse {\n+\n+  static Random r = Utils.getRandomInstance();\n+  static final int ITERS  = 11000;\n+  static final int ARRLEN = 997;\n+  static int input[] = new int[ARRLEN];\n+  static int outputI[] = new int[ARRLEN];\n+  static long outputL[] = new long[ARRLEN];\n+  static int err;\n+\n+  public static void main(String args[]) {\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\",\n+                               \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseRVV\"); \/\/ Only test scalar version\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.REVERSE_I, \"> 0\"})\n+  static void test_reverse_ia(int[] input, int[] outputI) {\n+    for (int i = 0; i < input.length; i+=1) {\n+      outputI[i] = Integer.reverse(input[i]);\n+    }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.REVERSE_I, \"> 0\"})\n+  static void test_reverse_la(int[] input, long[] outputL) {\n+    for (int i = 0; i < input.length; i+=1) {\n+      outputL[i] = Integer.reverse(input[i]);\n+    }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.REVERSE_I, \"> 0\"})\n+  static void test_reverse_l(int input, long expected) {\n+    if (Integer.reverse(input) != expected) {\n+      err++;\n+      System.out.println(\"Test failure, input: \" + input +\n+                         \", actual: \" + Integer.reverse(input) +\n+                         \", expected: \" + expected);\n+    }\n+  }\n+\n+  @Run(test = {\"test_reverse_ia\", \"test_reverse_la\", \"test_reverse_l\"})\n+  @Warmup(ITERS)\n+  static void test(RunInfo runInfo) {\n+    \/\/ Initialize\n+    for (int i = 0; i < ARRLEN; i++) {\n+      input[i] = r.nextInt();\n+    }\n+    input[0] = 0;\n+    input[1] = 1;\n+    input[2] = -1;\n+    input[3] = Integer.MIN_VALUE;\n+    input[4] = Integer.MAX_VALUE;\n+\n+    test_reverse_ia(input, outputI);\n+    test_reverse_la(input, outputL);\n+    for (int i = 0; i < ARRLEN; i++) {\n+      test_reverse_l(input[i], golden_reverse_integer(input[i]));\n+    }\n+    \/\/ skip test\/verify when warming up\n+    if (runInfo.isWarmUp()) {\n+      return;\n+    }\n+\n+    test_reverse_ia(input, outputI);\n+    test_reverse_la(input, outputL);\n+\n+    for (int i = 0; i < ARRLEN; i++) {\n+      int golden_val = golden_reverse_integer(input[i]);\n+      Asserts.assertEquals(outputI[i], golden_val,\n+                          \"Test failure (integer array), input: \" + input[i] +\n+                          \", actual: \" + outputI[i] +\n+                          \", expected: \" + golden_val);\n+      Asserts.assertEquals(outputL[i], (long)golden_val,\n+                          \"Test failure (long array), input: \" + input[i] +\n+                          \", actual: \" + outputL[i] +\n+                          \", expected: \" + (long)golden_val);\n+    }\n+\n+    err = 0;\n+    for (int i = 0; i < ARRLEN; i++) {\n+      test_reverse_l(input[i], golden_reverse_integer(input[i]));\n+    }\n+    Asserts.assertTrue(err == 0, \"Some tests(\" + err + \") failed, check previous log for details\");\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/riscv64\/TestIntegerReverse.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8318221\n+ * @summary Test ReverseL intrinsic\n+ *\n+ * @library \/test\/lib \/\n+ * @requires os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbkb.*\"\n+ * @run main\/othervm compiler.c2.riscv64.TestLongReverse\n+ *\/\n+\n+package compiler.c2.riscv64;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import static compiler.lib.golden.GoldenReverse.golden_reverse_long;\n+\n+public class TestLongReverse {\n+\n+  static Random r = Utils.getRandomInstance();\n+  static final int ITERS  = 11000;\n+  static final int ARRLEN = 997;\n+  static long input[] = new long[ARRLEN];\n+  static long output[] = new long[ARRLEN];\n+\n+  public static void main(String args[]) {\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\",\n+                               \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseRVV\"); \/\/ Only test scalar version\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.REVERSE_L, \"> 0\"})\n+  static void test_reverse(long[] input, long[] output) {\n+    for (int i = 0; i < input.length; i+=1) {\n+      output[i] = Long.reverse(input[i]);\n+    }\n+  }\n+\n+  @Run(test = \"test_reverse\")\n+  @Warmup(ITERS)\n+  static void test(RunInfo runInfo) {\n+    \/\/ Initialize\n+    for (int i = 0; i < ARRLEN; i++) {\n+      input[i] = r.nextLong();\n+    }\n+    input[0] = 0L;\n+    input[1] = 1L;\n+    input[2] = -1L;\n+    input[3] = Long.MIN_VALUE;\n+    input[4] = Long.MAX_VALUE;\n+\n+    test_reverse(input, output);\n+    \/\/ skip test\/verify when warming up\n+    if (runInfo.isWarmUp()) {\n+      return;\n+    }\n+\n+    test_reverse(input, output);\n+\n+    for (int i = 0; i < ARRLEN; i++) {\n+      long golden_val = golden_reverse_long(input[i]);\n+      Asserts.assertEquals(output[i], golden_val,\n+                          \"Test failure, input: \" + input[i] +\n+                          \", actual: \" + output[i] +\n+                          \", expected: \" + golden_val);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/riscv64\/TestLongReverse.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.golden;\n+\n+public class GoldenReverse {\n+  \/\/ The code is copied from java.lang.Integer.reverse(int i)\n+  public static int golden_reverse_integer(int i) {\n+    \/\/ HD, Figure 7-1\n+    i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;\n+    i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;\n+    i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;\n+\n+    return golden_reverseBytes_integer(i);\n+  }\n+\n+  \/\/ The code is copied from java.lang.Integer.reverseBytes(int i)\n+  static int golden_reverseBytes_integer(int i) {\n+    return (i << 24)            |\n+           ((i & 0xff00) << 8)  |\n+           ((i >>> 8) & 0xff00) |\n+           (i >>> 24);\n+  }\n+\n+  \/\/ The code is copied from java.lang.Long.reverse(long i)\n+  public static long golden_reverse_long(long i) {\n+    \/\/ HD, Figure 7-1\n+    i = (i & 0x5555555555555555L) << 1 | (i >>> 1) & 0x5555555555555555L;\n+    i = (i & 0x3333333333333333L) << 2 | (i >>> 2) & 0x3333333333333333L;\n+    i = (i & 0x0f0f0f0f0f0f0f0fL) << 4 | (i >>> 4) & 0x0f0f0f0f0f0f0f0fL;\n+\n+    return golden_reverseBytes_long(i);\n+  }\n+\n+  \/\/ The code is copied from java.lang.Long.reverseBytes(long i)\n+  static long golden_reverseBytes_long(long i) {\n+    i = (i & 0x00ff00ff00ff00ffL) << 8 | (i >>> 8) & 0x00ff00ff00ff00ffL;\n+    return (i << 48) | ((i & 0xffff0000L) << 16) |\n+        ((i >>> 16) & 0xffff0000L) | (i >>> 48);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/golden\/GoldenReverse.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -113,0 +113,1 @@\n+        \"zbkb\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}