{"files":[{"patch":"@@ -1120,0 +1120,68 @@\n+\/\/ ------------------------------ Vector and not -----------------------------------\n+\n+\/\/ vector and not\n+\n+instruct vand_notI(vReg dst, vReg src2, vReg src1, immI_M1 m1) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (AndV src2 (XorV src1 (Replicate m1))));\n+  format %{ \"vand_notI $dst, $src2, $src1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src2$$reg),\n+                as_VectorRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL(vReg dst, vReg src2, vReg src1, immL_M1 m1) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (AndV src2 (XorV src1 (Replicate m1))));\n+  format %{ \"vand_notL $dst, $src2, $src1\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src2$$reg),\n+                as_VectorRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notI_masked(vReg dst_src1, vReg src2, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (Replicate m1))) v0));\n+  format %{ \"vand_notI_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_masked(vReg dst_src1, vReg src2, immL_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (Replicate m1))) v0));\n+  format %{ \"vand_notL_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2079,0 +2079,10 @@\n+    public static final String VAND_NOT_I_MASKED = PREFIX + \"VAND_NOT_I_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VAND_NOT_I_MASKED, \"vand_notI_masked\");\n+    }\n+\n+    public static final String VAND_NOT_L_MASKED = PREFIX + \"VAND_NOT_L_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VAND_NOT_L_MASKED, \"vand_notL_masked\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n- * @requires vm.cpu.features ~= \".*asimd.*\"\n- * @summary AArch64: [vector] Make all bits set vector sharable for match rules\n+ * @requires (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*asimd.*\") | (os.simpleArch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n+ * @summary [vector] Make all bits set vector sharable for match rules\n@@ -66,0 +66,3 @@\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lr;\n@@ -75,0 +78,3 @@\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lr = new long[LENGTH];\n@@ -82,0 +88,2 @@\n+            la[i] = RD.nextLong(25);\n+            lb[i] = RD.nextLong(25);\n@@ -101,2 +109,2 @@\n-    @IR(counts = { IRNode.VAND_NOT_L, \" >= 1\" }, applyIf = {\"UseSVE\", \"0\"})\n-    @IR(counts = { IRNode.VMASK_AND_NOT_L, \" >= 1\" }, applyIf = {\"UseSVE\", \"> 0\"})\n+    @IR(counts = { IRNode.VAND_NOT_L, \" >= 1\" }, applyIfPlatform = {\"aarch64\", \"true\"}, applyIf = {\"UseSVE\", \"0\"})\n+    @IR(counts = { IRNode.VMASK_AND_NOT_L, \" >= 1\" }, applyIfPlatform = {\"aarch64\", \"true\"}, applyIf = {\"UseSVE\", \"> 0\"})\n@@ -115,0 +123,48 @@\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VAND_NOT_L, \" >= 1\" })\n+    public static void testVectorVAndNotL() {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+        av.not().lanewise(VectorOperators.AND_NOT, bv).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            Asserts.assertEquals((~la[i]) & (~lb[i]), lr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VAND_NOT_I_MASKED, \" >= 1\" })\n+    public static void testVectorVAndNotIMasked() {\n+        VectorMask<Integer> avm = VectorMask.fromArray(I_SPECIES, ma, 0);\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);\n+        av.not().lanewise(VectorOperators.AND_NOT, bv, avm).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            if (ma[i] == true) {\n+                Asserts.assertEquals((~ia[i]) & (~ib[i]), ir[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VAND_NOT_L_MASKED, \" >= 1\" })\n+    public static void testVectorVAndNotLMasked() {\n+        VectorMask<Long> avm = VectorMask.fromArray(L_SPECIES, ma, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+        av.not().lanewise(VectorOperators.AND_NOT, bv, avm).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            if (ma[i] == true) {\n+                Asserts.assertEquals((~la[i]) & (~lb[i]), lr[i]);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/AllBitsSetVectorMatchRuleTest.java","additions":60,"deletions":4,"binary":false,"changes":64,"status":"modified"}]}