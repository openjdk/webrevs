{"files":[{"patch":"@@ -2842,1 +2842,1 @@\n-  \/\/ Stubs: Called via rt_call, but dest is a stub address (no function descriptor).\n+  \/\/ Stubs: Called via rt_call, but dest is a stub address (no FunctionDescriptor).\n@@ -2844,1 +2844,2 @@\n-      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   )) {\n+      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   ) ||\n+      dest == Runtime1::entry_for(C1StubId::is_instance_of_id    )) {\n@@ -2849,3 +2850,4 @@\n-    assert(info != nullptr, \"sanity\");\n-    add_call_info_here(info);\n-    __ post_call_nop();\n+    if (info != nullptr) {\n+      add_call_info_here(info);\n+      __ post_call_nop();\n+    }\n@@ -2856,0 +2858,1 @@\n+  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n@@ -2858,0 +2861,1 @@\n+    __ post_call_nop();\n@@ -2859,2 +2863,0 @@\n-  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n-  __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -614,6 +614,1 @@\n-        \/\/ Called like a C function.\n-#if !defined(ABI_ELFv2)\n-        \/\/ ABIv1 requires a FunctionDescriptor with updated entry after relocating.\n-        __ relocate(relocInfo::internal_word_type, \/* plain address *\/ 2); \/\/ entry at offset 0\n-        __ emit_fd();\n-#endif\n+        \/\/ Called like a C function, but without FunctionDescriptor (see LIR_Assembler::rt_call).\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n@@ -36,16 +36,6 @@\n-    switch (format()) {\n-      case 2: { \/\/ plain address\n-        *((address*)addr()) = x;\n-        break;\n-      }\n-      case 1: { \/\/ native move compressed\n-        assert(type() == relocInfo::oop_type, \"how to encode else?\");\n-        narrowOop no = CompressedOops::encode(cast_to_oop(x));\n-        nativeMovConstReg_at(addr())->set_narrow_oop(no, code());\n-        break;\n-      }\n-      case 0: { \/\/ normal native move\n-        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x), code());\n-        break;\n-      }\n-      default: ShouldNotReachHere();\n+    if (format() != 1) {\n+      nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x), code());\n+    } else {\n+      assert(type() == relocInfo::oop_type, \"how to encode else?\");\n+      narrowOop no = CompressedOops::encode(cast_to_oop(x));\n+      nativeMovConstReg_at(addr())->set_narrow_oop(no, code());\n@@ -54,1 +44,0 @@\n-    \/\/ Only used by DataRelocation.\n@@ -110,10 +99,1 @@\n-  switch (format()) { \/\/ plain address\n-    case 2: {\n-      return *((address*)addr());\n-    }\n-    case 0: { \/\/ normal native move\n-      return (address)(nativeMovConstReg_at(addr())->data());\n-    }\n-    default: ShouldNotReachHere();\n-  }\n-  return nullptr;\n+  return (address)(nativeMovConstReg_at(addr())->data());\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"}]}