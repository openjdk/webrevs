{"files":[{"patch":"@@ -2842,1 +2842,1 @@\n-  \/\/ Stubs: Called via rt_call, but dest is a stub address (no function descriptor).\n+  \/\/ Stubs: Called via rt_call, but dest is a stub address (no FunctionDescriptor).\n@@ -2844,1 +2844,3 @@\n-      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   )) {\n+      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   ) ||\n+      dest == Runtime1::entry_for(C1StubId::is_instance_of_id    )) {\n+    assert(CodeCache::contains(dest), \"simplified call is only for special C1 stubs\");\n@@ -2849,3 +2851,4 @@\n-    assert(info != nullptr, \"sanity\");\n-    add_call_info_here(info);\n-    __ post_call_nop();\n+    if (info != nullptr) {\n+      add_call_info_here(info);\n+      __ post_call_nop();\n+    }\n@@ -2856,0 +2859,1 @@\n+  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n@@ -2858,0 +2862,1 @@\n+    __ post_call_nop();\n@@ -2859,2 +2864,0 @@\n-  assert(__ last_calls_return_pc() == __ pc(), \"pcn not at return pc\");\n-  __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1131,0 +1131,1 @@\n+\n@@ -1133,1 +1134,1 @@\n-  return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -612,0 +612,67 @@\n+    case C1StubId::is_instance_of_id:\n+      {\n+        \/\/ Called like a C function, but without FunctionDescriptor (see LIR_Assembler::rt_call).\n+\n+        \/\/ Arguments and return value.\n+        Register mirror = R3_ARG1;\n+        Register obj    = R4_ARG2;\n+        Register result = R3_RET;\n+\n+        \/\/ Other argument registers can be used as temp registers.\n+        Register klass  = R5;\n+        Register offset = R6;\n+        Register sub_klass = R7;\n+\n+        Label is_secondary, success;\n+\n+        \/\/ Get the Klass*.\n+        __ ld(klass, java_lang_Class::klass_offset(), mirror);\n+\n+        \/\/ Return false if obj or klass is null.\n+        mirror = noreg; \/\/ killed by next instruction\n+        __ li(result, 0); \/\/ assume result is false\n+        __ cmpdi(CR0, obj, 0);\n+        __ cmpdi(CR1, klass, 0);\n+        __ cror(CR0, Assembler::equal, CR1, Assembler::equal);\n+        __ bclr(Assembler::bcondCRbiIs1, Assembler::bi0(CR0, Assembler::equal), Assembler::bhintbhBCLRisReturn);\n+\n+        __ lwz(offset, in_bytes(Klass::super_check_offset_offset()), klass);\n+        __ load_klass(sub_klass, obj);\n+        __ cmpwi(CR0, offset, in_bytes(Klass::secondary_super_cache_offset()));\n+        __ beq(CR0, is_secondary); \/\/ Klass is a secondary superclass\n+\n+        \/\/ Klass is a concrete class\n+        __ ldx(R0, sub_klass, offset);\n+        __ cmpd(CR0, klass, R0);\n+        if (VM_Version::has_brw()) {\n+          \/\/ Power10 can set the result by one instruction. No need for a branch.\n+          __ setbc(result, CR0, Assembler::equal);\n+        } else {\n+          __ beq(CR0, success);\n+        }\n+        __ blr();\n+\n+        __ bind(is_secondary);\n+\n+        \/\/ This is necessary because I am never in my own secondary_super list.\n+        __ cmpd(CR0, sub_klass, klass);\n+        __ beq(CR0, success);\n+\n+        __ lookup_secondary_supers_table_var(sub_klass, klass,\n+                                             \/*temps*\/R9, R10, R11, R12,\n+                                             \/*result*\/R8);\n+        __ cmpdi(CR0, R8, 0); \/\/ 0 means is subclass\n+        if (VM_Version::has_brw()) {\n+          \/\/ Power10 can set the result by one instruction. No need for a branch.\n+          __ setbc(result, CR0, Assembler::equal);\n+        } else {\n+          __ beq(CR0, success);\n+        }\n+        __ blr();\n+\n+        __ bind(success);\n+        __ li(result, 1);\n+        __ blr();\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2268,1 +2268,1 @@\n-  Label Lloop, Lexit;\n+  Label Lloop, Lafter_loop, Lexit;\n@@ -2270,11 +2270,3 @@\n-#ifdef ASSERT\n-  {\n-    Label ok;\n-    cmpdi(CR0, count, 0);\n-    bgt(CR0, ok);\n-    stop(\"count must be positive\");\n-    bind(ok);\n-  }\n-#endif\n-\n-  mtctr(count);\n+  srdi_(scratch, count, 1);\n+  beq(CR0, Lafter_loop);\n+  mtctr(scratch);\n@@ -2282,2 +2274,2 @@\n-  bind(Lloop);\n-  ld(scratch, 0 , addr);\n+  bind(Lloop); \/\/ 2x unrolled\n+  ld(scratch, 0, addr);\n@@ -2286,1 +2278,4 @@\n-  addi(addr, addr, wordSize);\n+  ld(scratch, 8, addr);\n+  xor_(scratch, scratch, value);\n+  beq(CR0, Lexit);\n+  addi(addr, addr, 2 * wordSize);\n@@ -2289,0 +2284,6 @@\n+  bind(Lafter_loop);\n+  andi_(scratch, count, 1);\n+  beq(CR0, Lexit); \/\/ if taken: CR0 eq and scratch == 0\n+  ld(scratch, 0, addr);\n+  xor_(scratch, scratch, value);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"}]}