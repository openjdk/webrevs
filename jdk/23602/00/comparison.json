{"files":[{"patch":"@@ -1131,0 +1131,1 @@\n+\n@@ -1133,1 +1134,1 @@\n-  return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -612,0 +612,72 @@\n+    case C1StubId::is_instance_of_id:\n+      {\n+        \/\/ Called like a C function.\n+#if !defined(ABI_ELFv2)\n+        \/\/ ABIv1 requires a FunctionDescriptor with updated entry after relocating.\n+        __ relocate(relocInfo::internal_word_type, \/* plain address *\/ 2); \/\/ entry at offset 0\n+        __ emit_fd();\n+#endif\n+\n+        \/\/ Arguments and return value.\n+        Register mirror = R3_ARG1;\n+        Register obj    = R4_ARG2;\n+        Register result = R3_RET;\n+\n+        \/\/ Other argument registers can be used as temp registers.\n+        Register klass  = R5;\n+        Register offset = R6;\n+        Register sub_klass = R7;\n+\n+        Label is_secondary, success;\n+\n+        \/\/ Get the Klass*.\n+        __ ld(klass, java_lang_Class::klass_offset(), mirror);\n+\n+        \/\/ Return false if obj or klass is null.\n+        mirror = noreg; \/\/ killed by next instruction\n+        __ li(result, 0); \/\/ assume result is false\n+        __ cmpdi(CR0, obj, 0);\n+        __ cmpdi(CR1, klass, 0);\n+        __ cror(CR0, Assembler::equal, CR1, Assembler::equal);\n+        __ bclr(Assembler::bcondCRbiIs1, Assembler::bi0(CR0, Assembler::equal), Assembler::bhintbhBCLRisReturn);\n+\n+        __ lwz(offset, in_bytes(Klass::super_check_offset_offset()), klass);\n+        __ load_klass(sub_klass, obj);\n+        __ cmpwi(CR0, offset, in_bytes(Klass::secondary_super_cache_offset()));\n+        __ beq(CR0, is_secondary); \/\/ Klass is a secondary superclass\n+\n+        \/\/ Klass is a concrete class\n+        __ ldx(R0, sub_klass, offset);\n+        __ cmpd(CR0, klass, R0);\n+        if (VM_Version::has_brw()) {\n+          \/\/ Power10 can set the result by one instruction. No need for a branch.\n+          __ setbc(result, CR0, Assembler::equal);\n+        } else {\n+          __ beq(CR0, success);\n+        }\n+        __ blr();\n+\n+        __ bind(is_secondary);\n+\n+        \/\/ This is necessary because I am never in my own secondary_super list.\n+        __ cmpd(CR0, sub_klass, klass);\n+        __ beq(CR0, success);\n+\n+        __ lookup_secondary_supers_table_var(sub_klass, klass,\n+                                             \/*temps*\/R9, R10, R11, R12,\n+                                             \/*result*\/R8);\n+        __ cmpdi(CR0, R8, 0); \/\/ 0 means is subclass\n+        if (VM_Version::has_brw()) {\n+          \/\/ Power10 can set the result by one instruction. No need for a branch.\n+          __ setbc(result, CR0, Assembler::equal);\n+        } else {\n+          __ beq(CR0, success);\n+        }\n+        __ blr();\n+\n+        __ bind(success);\n+        __ li(result, 1);\n+        __ blr();\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -36,6 +36,16 @@\n-    if (format() != 1) {\n-      nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x), code());\n-    } else {\n-      assert(type() == relocInfo::oop_type, \"how to encode else?\");\n-      narrowOop no = CompressedOops::encode(cast_to_oop(x));\n-      nativeMovConstReg_at(addr())->set_narrow_oop(no, code());\n+    switch (format()) {\n+      case 2: { \/\/ plain address\n+        *((address*)addr()) = x;\n+        break;\n+      }\n+      case 1: { \/\/ native move compressed\n+        assert(type() == relocInfo::oop_type, \"how to encode else?\");\n+        narrowOop no = CompressedOops::encode(cast_to_oop(x));\n+        nativeMovConstReg_at(addr())->set_narrow_oop(no, code());\n+        break;\n+      }\n+      case 0: { \/\/ normal native move\n+        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x), code());\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n@@ -44,0 +54,1 @@\n+    \/\/ Only used by DataRelocation.\n@@ -99,1 +110,10 @@\n-  return (address)(nativeMovConstReg_at(addr())->data());\n+  switch (format()) { \/\/ plain address\n+    case 2: {\n+      return *((address*)addr());\n+    }\n+    case 0: { \/\/ normal native move\n+      return (address)(nativeMovConstReg_at(addr())->data());\n+    }\n+    default: ShouldNotReachHere();\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"}]}