{"files":[{"patch":"@@ -39,1 +39,1 @@\n-    INCLUDES := compileproperties propertiesparser, \\\n+    INCLUDES := compileproperties flagsgenerator propertiesparser, \\\n","filename":"make\/ToolsLangtools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package flagsgenerator;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.ElementFilter;\n+import javax.tools.ToolProvider;\n+\n+public class FlagsGenerator {\n+    public static void main(String... args) throws IOException {\n+        var compiler = ToolProvider.getSystemJavaCompiler();\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            JavacTask task = (JavacTask) compiler.getTask(null, null, d -> {}, null, null, fm.getJavaFileObjects(args[0]));\n+            Trees trees = Trees.instance(task);\n+            CompilationUnitTree cut = task.parse().iterator().next();\n+\n+            task.analyze();\n+\n+            TypeElement clazz = (TypeElement) trees.getElement(new TreePath(new TreePath(cut), cut.getTypeDecls().get(0)));\n+            Map<Integer, List<String>> flag2Names = new TreeMap<>();\n+            Map<FlagTarget, Map<Integer, List<String>>> target2FlagBit2Fields = new HashMap<>();\n+            Map<String, String> customToString = new HashMap<>();\n+            Set<String> noToString = new HashSet<>();\n+\n+            for (VariableElement field : ElementFilter.fieldsIn(clazz.getEnclosedElements())) {\n+                String flagName = field.getSimpleName().toString();\n+                for (AnnotationMirror am : field.getAnnotationMirrors()) {\n+                    switch (am.getAnnotationType().toString()) {\n+                        case \"com.sun.tools.javac.code.Flags.Use\" -> {\n+                            long flagValue = ((Number) field.getConstantValue()).longValue();\n+                            int flagBit = 63 - Long.numberOfLeadingZeros(flagValue);\n+\n+                            flag2Names.computeIfAbsent(flagBit, _ -> new ArrayList<>())\n+                                      .add(flagName);\n+\n+                            List<?> originalTargets = (List<?>) valueOfValueAttribute(am);\n+                            originalTargets.stream()\n+                                           .map(value -> FlagTarget.valueOf(value.toString()))\n+                                           .forEach(target -> target2FlagBit2Fields.computeIfAbsent(target, _ -> new HashMap<>())\n+                                                                                   .computeIfAbsent(flagBit, _ -> new ArrayList<>())\n+                                                                                   .add(flagName));\n+                        }\n+                        case \"com.sun.tools.javac.code.Flags.CustomToStringValue\" -> {\n+                            customToString.put(flagName, (String) valueOfValueAttribute(am));\n+                        }\n+                        case \"com.sun.tools.javac.code.Flags.NoToStringValue\" -> {\n+                            noToString.add(flagName);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/verify there are no flag overlaps:\n+            for (Entry<FlagTarget, Map<Integer, List<String>>> targetAndFlag : target2FlagBit2Fields.entrySet()) {\n+                for (Entry<Integer, List<String>> flagAndFields : targetAndFlag.getValue().entrySet()) {\n+                    if (flagAndFields.getValue().size() > 1) {\n+                        throw new AssertionError(\"duplicate flag for target: \" + targetAndFlag.getKey() +\n+                                                 \", flag: \" + flagAndFields.getKey() +\n+                                                 \", flags fields: \" + flagAndFields.getValue());\n+                    }\n+                }\n+            }\n+\n+            try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get(args[1])))) {\n+                out.println(\"\"\"\n+                            package com.sun.tools.javac.code;\n+\n+                            public enum FlagsEnum {\n+                            \"\"\");\n+                for (Entry<Integer, List<String>> e : flag2Names.entrySet()) {\n+                    String constantName = e.getValue().stream().collect(Collectors.joining(\"_OR_\"));\n+                    String toString = e.getValue()\n+                                       .stream()\n+                                       .filter(n -> !noToString.contains(n))\n+                                       .map(n -> customToString.getOrDefault(n, n.toLowerCase(Locale.US)))\n+                                       .collect(Collectors.joining(\" or \"));\n+                    out.println(\"    \" + constantName + \"(1L<<\" + e.getKey() + \", \\\"\" + toString + \"\\\"),\");\n+                }\n+                out.println(\"\"\"\n+                                ;\n+\n+                                private final long value;\n+                                private final String toString;\n+                                private FlagsEnum(long value, String toString) {\n+                                    this.value = value;\n+                                    this.toString = toString;\n+                                }\n+                                public long value() {\n+                                    return value;\n+                                }\n+                                public String toString() {\n+                                    return toString;\n+                                }\n+                            }\n+                            \"\"\");\n+            }\n+        }\n+    }\n+\n+    private static Object valueOfValueAttribute(AnnotationMirror am) {\n+        return am.getElementValues()\n+                 .values()\n+                 .iterator()\n+                 .next()\n+                 .getValue();\n+    }\n+\n+    private enum FlagTarget {\n+        BLOCK,\n+        CLASS,\n+        METHOD,\n+        MODULE,\n+        PACKAGE,\n+        TYPE_VAR,\n+        VARIABLE;\n+    }\n+}\n","filename":"make\/langtools\/tools\/flagsgenerator\/FlagsGenerator.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        FLAG(\"flag\", \"Flag\", \"com.sun.tools.javac.code.Flags\"),\n+        FLAG(\"flag\", \"FlagsEnum\", \"com.sun.tools.javac.code\"),\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,5 +44,0 @@\n-################################################################################\n-#\n-# Compile properties files into enum-like classes using the propertiesparser tool\n-#\n-\n@@ -55,0 +50,5 @@\n+################################################################################\n+#\n+# Compile properties files into enum-like classes using the propertiesparser tool\n+#\n+\n@@ -79,0 +79,25 @@\n+\n+################################################################################\n+#\n+# Generate FlagsEnum from Flags constants:\n+#\n+\n+TOOL_FLAGSGENERATOR_CMD := $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_tools_classes \\\n+    flagsgenerator.FlagsGenerator\n+\n+FLAGS_SRC := \\\n+    $(MODULE_SRC)\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java\n+\n+FLAGS_OUT := \\\n+    $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\/com\/sun\/tools\/javac\/code\/FlagsEnum.java\n+\n+$(eval $(call SetupExecute, FLAGSGENERATOR, \\\n+    WARN := Generating FlagsEnum, \\\n+    DEPS := $(FLAGS_SRC) $(BUILD_TOOLS_LANGTOOLS), \\\n+    OUTPUT_FILE := $(FLAGS_OUT), \\\n+    COMMAND := $(TOOL_FLAGSGENERATOR_CMD) $(FLAGS_SRC) $(FLAGS_OUT), \\\n+))\n+\n+TARGETS += $(FLAGSGENERATOR)\n+\n+################################################################################\n","filename":"make\/modules\/jdk.compiler\/Gensrc.gmk","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n@@ -38,1 +40,0 @@\n-import com.sun.tools.javac.util.StringUtils;\n@@ -54,1 +55,1 @@\n-        for (Flag flag : asFlagSet(flags)) {\n+        for (FlagsEnum flag : asFlagSet(flags)) {\n@@ -62,4 +63,4 @@\n-    public static EnumSet<Flag> asFlagSet(long flags) {\n-        EnumSet<Flag> flagSet = EnumSet.noneOf(Flag.class);\n-        for (Flag flag : Flag.values()) {\n-            if ((flags & flag.value) != 0) {\n+    public static EnumSet<FlagsEnum> asFlagSet(long flags) {\n+        EnumSet<FlagsEnum> flagSet = EnumSet.noneOf(FlagsEnum.class);\n+        for (FlagsEnum flag : FlagsEnum.values()) {\n+            if ((flags & flag.value()) != 0) {\n@@ -67,1 +68,1 @@\n-                flags &= ~flag.value;\n+                flags &= ~flag.value();\n@@ -76,0 +77,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -77,0 +79,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -78,0 +81,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -79,0 +83,1 @@\n+    @Use({FlagTarget.BLOCK, FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -80,0 +85,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -81,0 +87,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -82,0 +89,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -83,0 +91,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -84,0 +93,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -85,0 +95,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -86,0 +97,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -87,0 +99,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -90,0 +103,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -93,0 +107,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -97,0 +112,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -100,0 +116,1 @@\n+    @Use({FlagTarget.MODULE, FlagTarget.VARIABLE})\n@@ -102,0 +119,1 @@\n+    @NotFlag\n@@ -108,4 +126,12 @@\n-    public static final int ACC_SUPER    = 0x0020;\n-    public static final int ACC_BRIDGE   = 0x0040;\n-    public static final int ACC_VARARGS  = 0x0080;\n-    public static final int ACC_MODULE   = 0x8000;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_SUPER    = 1<<5;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_BRIDGE   = 1<<6;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_VARARGS  = 1<<7;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_MODULE   = 1<<15;\n@@ -119,0 +145,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -124,0 +151,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -128,0 +156,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -133,0 +162,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -137,1 +167,2 @@\n-    public static final int FROM_SOURCE      = 1<<21; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int FROM_SOURCE      = 1<<21;\n@@ -146,0 +177,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -151,0 +183,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.PACKAGE})\n@@ -156,0 +189,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -160,0 +194,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -165,0 +200,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -175,0 +211,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -180,0 +217,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -184,1 +222,2 @@\n-    public static final int ANONCONSTR   = 1<<29; \/\/non-class members\n+    @Use({FlagTarget.METHOD})\n+    public static final int ANONCONSTR   = 1<<29;\n@@ -189,1 +228,2 @@\n-    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29;\n@@ -194,0 +234,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.TYPE_VAR})\n@@ -198,0 +239,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -202,0 +244,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -206,0 +249,1 @@\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -211,0 +255,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -215,0 +260,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -221,0 +267,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -226,0 +273,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -231,0 +279,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -237,0 +286,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.TYPE_VAR})\n@@ -242,0 +292,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -248,0 +299,1 @@\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -253,0 +305,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -259,0 +312,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -264,0 +318,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -269,0 +324,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -274,0 +330,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -279,0 +336,1 @@\n+    @Use({FlagTarget.TYPE_VAR})\n@@ -284,0 +342,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -289,1 +348,2 @@\n-    public static final long LAMBDA_METHOD = 1L<<49; \/\/MethodSymbols only\n+    @Use({FlagTarget.METHOD})\n+    public static final long LAMBDA_METHOD = 1L<<49;\n@@ -294,1 +354,2 @@\n-    public static final long LOCAL_CAPTURE_FIELD = 1L<<49; \/\/VarSymbols only\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long LOCAL_CAPTURE_FIELD = 1L<<49;\n@@ -299,0 +360,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -304,0 +366,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -309,1 +372,2 @@\n-    public static final long AUTOMATIC_MODULE = 1L<<52; \/\/ModuleSymbols only\n+    @Use({FlagTarget.MODULE})\n+    public static final long AUTOMATIC_MODULE = 1L<<52;\n@@ -314,1 +378,2 @@\n-    public static final long HAS_RESOURCE = 1L<<52; \/\/PackageSymbols only\n+    @Use({FlagTarget.PACKAGE})\n+    public static final long HAS_RESOURCE = 1L<<52;\n@@ -319,1 +384,2 @@\n-    public static final long NAME_FILLED = 1L<<52; \/\/ParamSymbols only\n+    @Use({FlagTarget.VARIABLE}) \/\/ParamSymbols only\n+    public static final long NAME_FILLED = 1L<<52;\n@@ -324,1 +390,2 @@\n-    public static final long SYSTEM_MODULE = 1L<<53; \/\/ModuleSymbols only\n+    @Use({FlagTarget.MODULE})\n+    public static final long SYSTEM_MODULE = 1L<<53;\n@@ -329,1 +396,2 @@\n-    public static final long VALUE_BASED = 1L<<53; \/\/ClassSymbols only\n+    @Use({FlagTarget.CLASS})\n+    public static final long VALUE_BASED = 1L<<53;\n@@ -334,0 +402,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -339,0 +408,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -344,0 +414,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -349,0 +420,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -355,1 +427,2 @@\n-    public static final long BODY_ONLY_FINALIZE = 1L<<17; \/\/blocks only\n+    @Use({FlagTarget.BLOCK})\n+    public static final long BODY_ONLY_FINALIZE = 1L<<17;\n@@ -360,0 +433,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -365,0 +439,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -370,0 +445,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -376,1 +452,2 @@\n-    public static final long RECORD = 1L<<61; \/\/ ClassSymbols, MethodSymbols and VarSymbols\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE, FlagTarget.METHOD})\n+    public static final long RECORD = 1L<<61;\n@@ -381,1 +458,2 @@\n-    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51; \/\/ MethodSymbols only\n+    @Use({FlagTarget.METHOD})\n+    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51;\n@@ -386,1 +464,2 @@\n-    public static final long UNINITIALIZED_FIELD= 1L<<51; \/\/ VarSymbols only\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long UNINITIALIZED_FIELD= 1L<<51;\n@@ -391,1 +470,2 @@\n-    public static final int GENERATED_MEMBER = 1<<24; \/\/ MethodSymbols and VarSymbols\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n+    public static final int GENERATED_MEMBER = 1<<24;\n@@ -396,1 +476,2 @@\n-    public static final long RESTRICTED = 1L<<62; \/\/ MethodSymbols\n+    @Use({FlagTarget.METHOD})\n+    public static final long RESTRICTED = 1L<<62;\n@@ -401,1 +482,2 @@\n-    public static final long REQUIRES_IDENTITY = 1L<<62; \/\/ VarSymbols (parameters)\n+    @Use({FlagTarget.VARIABLE}) \/\/ParamSymbols only\n+    public static final long REQUIRES_IDENTITY = 1L<<62;\n@@ -406,1 +488,2 @@\n-    public static final long FIELD_INIT_TYPE_ANNOTATIONS_QUEUED = 1L<<53; \/\/ VarSymbols\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long FIELD_INIT_TYPE_ANNOTATIONS_QUEUED = 1L<<53;\n@@ -411,0 +494,2 @@\n+    @Use({FlagTarget.CLASS})\n+    @CustomToStringValue(\"non-sealed\")\n@@ -425,0 +510,1 @@\n+    @NotFlag\n@@ -441,0 +527,1 @@\n+    @NotFlag\n@@ -494,0 +581,24 @@\n+    public enum FlagTarget {\n+        \/** This flag can appear the JCBlock.\n+         *\/\n+        BLOCK,\n+        \/** This flag can appear on ClassSymbols.\n+         *\/\n+        CLASS,\n+        \/** This flag can appear on ModuleSymbols.\n+         *\/\n+        MODULE,\n+        \/** This flag can appear on PackageSymbols.\n+         *\/\n+        PACKAGE,\n+        \/** This flag can appear on TypeVarSymbols.\n+         *\/\n+        TYPE_VAR,\n+        \/** This flag can appear on MethodSymbols.\n+         *\/\n+        METHOD,\n+        \/** This flag can appear on VarSymbols, includes\n+         *  including ParamSymbol, and BindingSymbol.\n+         *\/\n+        VARIABLE;\n+    }\n@@ -495,76 +606,4 @@\n-    public enum Flag {\n-        PUBLIC(Flags.PUBLIC),\n-        PRIVATE(Flags.PRIVATE),\n-        PROTECTED(Flags.PROTECTED),\n-        STATIC(Flags.STATIC),\n-        FINAL(Flags.FINAL),\n-        SYNCHRONIZED(Flags.SYNCHRONIZED),\n-        VOLATILE(Flags.VOLATILE),\n-        TRANSIENT(Flags.TRANSIENT),\n-        NATIVE(Flags.NATIVE),\n-        INTERFACE(Flags.INTERFACE),\n-        ABSTRACT(Flags.ABSTRACT),\n-        DEFAULT(Flags.DEFAULT),\n-        STRICTFP(Flags.STRICTFP),\n-        BRIDGE(Flags.BRIDGE),\n-        SYNTHETIC(Flags.SYNTHETIC),\n-        ANNOTATION(Flags.ANNOTATION),\n-        DEPRECATED(Flags.DEPRECATED),\n-        HASINIT(Flags.HASINIT),\n-        IMPLICIT_CLASS(Flags.IMPLICIT_CLASS),\n-        BLOCK(Flags.BLOCK),\n-        FROM_SOURCE(Flags.FROM_SOURCE),\n-        ENUM(Flags.ENUM),\n-        MANDATED(Flags.MANDATED),\n-        NOOUTERTHIS(Flags.NOOUTERTHIS),\n-        EXISTS(Flags.EXISTS),\n-        COMPOUND(Flags.COMPOUND),\n-        CLASS_SEEN(Flags.CLASS_SEEN),\n-        SOURCE_SEEN(Flags.SOURCE_SEEN),\n-        LOCKED(Flags.LOCKED),\n-        UNATTRIBUTED(Flags.UNATTRIBUTED),\n-        ANONCONSTR(Flags.ANONCONSTR),\n-        ACYCLIC(Flags.ACYCLIC),\n-        PARAMETER(Flags.PARAMETER),\n-        VARARGS(Flags.VARARGS),\n-        ACYCLIC_ANN(Flags.ACYCLIC_ANN),\n-        GENERATEDCONSTR(Flags.GENERATEDCONSTR),\n-        HYPOTHETICAL(Flags.HYPOTHETICAL),\n-        PROPRIETARY(Flags.PROPRIETARY),\n-        UNION(Flags.UNION),\n-        EFFECTIVELY_FINAL(Flags.EFFECTIVELY_FINAL),\n-        CLASH(Flags.CLASH),\n-        AUXILIARY(Flags.AUXILIARY),\n-        NOT_IN_PROFILE(Flags.NOT_IN_PROFILE),\n-        BAD_OVERRIDE(Flags.BAD_OVERRIDE),\n-        SIGNATURE_POLYMORPHIC(Flags.SIGNATURE_POLYMORPHIC),\n-        THROWS(Flags.THROWS),\n-        LAMBDA_METHOD(Flags.LAMBDA_METHOD),\n-        TYPE_TRANSLATED(Flags.TYPE_TRANSLATED),\n-        MODULE(Flags.MODULE),\n-        AUTOMATIC_MODULE(Flags.AUTOMATIC_MODULE),\n-        SYSTEM_MODULE(Flags.SYSTEM_MODULE),\n-        DEPRECATED_ANNOTATION(Flags.DEPRECATED_ANNOTATION),\n-        DEPRECATED_REMOVAL(Flags.DEPRECATED_REMOVAL),\n-        HAS_RESOURCE(Flags.HAS_RESOURCE),\n-        SEALED(Flags.SEALED),\n-        ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),\n-        NAME_FILLED(Flags.NAME_FILLED),\n-        PREVIEW_API(Flags.PREVIEW_API),\n-        PREVIEW_REFLECTIVE(Flags.PREVIEW_REFLECTIVE),\n-        MATCH_BINDING(Flags.MATCH_BINDING),\n-        MATCH_BINDING_TO_OUTER(Flags.MATCH_BINDING_TO_OUTER),\n-        RECORD(Flags.RECORD),\n-        RECOVERABLE(Flags.RECOVERABLE),\n-        RESTRICTED(Flags.RESTRICTED),\n-        NON_SEALED(Flags.NON_SEALED) {\n-            @Override\n-            public String toString() {\n-                return \"non-sealed\";\n-            }\n-        };\n-\n-        Flag(long flag) {\n-            this.value = flag;\n-            this.lowercaseName = StringUtils.toLowerCase(name());\n-        }\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Use {\n+        public FlagTarget[] value();\n+    }\n@@ -572,4 +611,2 @@\n-        @Override\n-        public String toString() {\n-            return lowercaseName;\n-        }\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NotFlag {}\n@@ -577,2 +614,3 @@\n-        final long value;\n-        final String lowercaseName;\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface CustomToStringValue {\n+        public String value();\n@@ -581,0 +619,3 @@\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NoToStringValue {\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":152,"deletions":111,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-import com.sun.tools.javac.code.Flags.Flag;\n+import com.sun.tools.javac.code.FlagsEnum;\n@@ -828,1 +828,1 @@\n-                        log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(Flag.STATIC)));\n+                        log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(FlagsEnum.STATIC)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import com.sun.tools.javac.code.Flags.Flag;\n+import com.sun.tools.javac.code.FlagsEnum;\n@@ -306,1 +306,1 @@\n-        if (o instanceof Flag)\n+        if (o instanceof FlagsEnum)\n","filename":"test\/langtools\/tools\/javac\/diags\/ArgTypeCompilerFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,1 @@\n- * @bug 8211138\n+ * @bug 8211138 8362885\n@@ -30,1 +31,2 @@\n- * @run main FlagsTest\n+ * @compile FlagsTest.java\n+ * @run main\/manual FlagsTest\n@@ -33,0 +35,3 @@\n+import com.sun.tools.javac.code.Flags.FlagTarget;\n+import com.sun.tools.javac.code.Flags.NotFlag;\n+import com.sun.tools.javac.code.Flags.Use;\n@@ -34,1 +39,4 @@\n-import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n@@ -37,1 +45,19 @@\n-    public static void main(String[] args) throws IllegalAccessException {\n+\n+    private static final int U2_SIZE = 16;\n+\n+    public static void main(String[] args) throws Throwable {\n+        findFreeFlags();\n+    }\n+\n+    private static void findFreeFlags() throws Throwable {\n+        Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields = computeTarget2Flag2Fields();\n+\n+        for (FlagTarget target : FlagTarget.values()) {\n+            long freeFlags = ~collectFlags(target2Flag2Fields, target);\n+\n+            printFreeFlags(target.name(), freeFlags);\n+        }\n+    }\n+\n+    private static Map<FlagTarget, Map<Long, List<Field>>> computeTarget2Flag2Fields() throws Throwable {\n+        Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields = new HashMap<>();\n@@ -39,1 +65,1 @@\n-            if (!Modifier.isStatic(f.getModifiers())) {\n+            if (f.isAnnotationPresent(NotFlag.class)) {\n@@ -42,5 +68,13 @@\n-            long flag = ((Number) f.get(null)).longValue();\n-            try {\n-                Flags.asFlagSet(flag);\n-            } catch (AssertionError e) {\n-                throw new AssertionError(\"missing Flags enum constant for: \" + f.getName(), e);\n+\n+            Use use = f.getAnnotation(Use.class);\n+\n+            if (use == null) {\n+                throw new AssertionError(\"No @Use and no @NotFlag for: \" + f.getName());\n+            }\n+\n+            long flagValue = ((Number) f.get(null)).longValue();\n+\n+            for (FlagTarget target : use.value()) {\n+                target2Flag2Fields.computeIfAbsent(target, _ -> new HashMap<>())\n+                        .computeIfAbsent(flagValue, _ -> new ArrayList<>())\n+                        .add(f);\n@@ -49,0 +83,23 @@\n+        return target2Flag2Fields;\n+    }\n+\n+    private static void printFreeFlags(String comment, long freeFlags) {\n+            System.err.print(\"free flags for \" + comment + \": \");\n+            for (int bit = U2_SIZE; bit < Long.SIZE; bit++) { \/\/lowest 16 bits are used in classfiles, never suggest adding anything there\n+                if ((freeFlags & (1L << bit)) != 0) {\n+                    System.err.print(\"1L<<\" + bit + \" \");\n+                }\n+            }\n+            System.err.println();\n+    }\n+\n+    private static long collectFlags(Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields, FlagTarget... forTargets) {\n+        long flags = 0;\n+\n+        for (FlagTarget target : forTargets) {\n+            for (long used : target2Flag2Fields.get(target).keySet()) {\n+                flags |= used;\n+            }\n+        }\n+\n+        return flags;\n","filename":"test\/langtools\/tools\/javac\/flags\/FlagsTest.java","additions":67,"deletions":10,"binary":false,"changes":77,"status":"modified"}]}