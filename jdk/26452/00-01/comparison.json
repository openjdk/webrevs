{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Arrays;\n@@ -37,0 +38,1 @@\n+import java.util.HashSet;\n@@ -41,0 +43,1 @@\n+import java.util.Set;\n@@ -62,0 +65,1 @@\n+            Map<FlagTarget, Map<Integer, List<String>>> target2FlagBit2Fields = new HashMap<>();\n@@ -63,0 +67,1 @@\n+            Set<String> noToString = new HashSet<>();\n@@ -70,0 +75,1 @@\n+                            int flagBit = 63 - Long.numberOfLeadingZeros(flagValue);\n@@ -71,1 +77,1 @@\n-                            flag2Names.computeIfAbsent(63 - Long.numberOfLeadingZeros(flagValue), _ -> new ArrayList<>())\n+                            flag2Names.computeIfAbsent(flagBit, _ -> new ArrayList<>())\n@@ -73,2 +79,0 @@\n-                        }\n-\n@@ -76,0 +80,7 @@\n+                            List<?> originalTargets = (List<?>) valueOfValueAttribute(am);\n+                            originalTargets.stream()\n+                                           .map(value -> FlagTarget.valueOf(value.toString()))\n+                                           .forEach(target -> target2FlagBit2Fields.computeIfAbsent(target, _ -> new HashMap<>())\n+                                                                                   .computeIfAbsent(flagBit, _ -> new ArrayList<>())\n+                                                                                   .add(flagName));\n+                        }\n@@ -79,0 +90,3 @@\n+                        case \"com.sun.tools.javac.code.Flags.NoToStringValue\" -> {\n+                            noToString.add(flagName);\n+                        }\n@@ -83,0 +97,15 @@\n+            \/\/verify there are no flag overlaps:\n+            for (Entry<FlagTarget, Map<Integer, List<String>>> targetAndFlag : target2FlagBit2Fields.entrySet()) {\n+                for (Entry<Integer, List<String>> flagAndFields : targetAndFlag.getValue().entrySet()) {\n+                    if (flagAndFields.getValue().size() > 1) {\n+                        throw new AssertionError(\"duplicate flag for target: \" + targetAndFlag.getKey() +\n+                                                 \", flag: \" + flagAndFields.getKey() +\n+                                                 \", flags fields: \" + flagAndFields.getValue());\n+                    }\n+                }\n+            }\n+\n+            String masks = Arrays.stream(FlagTarget.values())\n+                                 .map(target -> \"    public static final long MASK_\" + target.name() + \"_FLAGS = \" + getMask(target2FlagBit2Fields, target) + \";\")\n+                                 .collect(Collectors.joining(\"\\n\"));\n+\n@@ -87,0 +116,2 @@\n+                            import com.sun.tools.javac.util.Assert;\n+\n@@ -93,0 +124,1 @@\n+                                       .filter(n -> !noToString.contains(n))\n@@ -100,0 +132,2 @@\n+                                ${masks}\n+\n@@ -112,0 +146,5 @@\n+                                public static void assertNoUnexpectedFlags(long flags, long mask) {\n+                                    Assert.check((flags & ~mask) == 0,\n+                                                 () -> \"Unexpected flags: 0x\" + Long.toHexString(flags & ~mask) + \"L (\" +\n+                                                       Flags.asFlagSet(flags & ~mask) + \")\");\n+                                }\n@@ -113,1 +152,1 @@\n-                            \"\"\");\n+                            \"\"\".replace(\"${masks}\", masks));\n@@ -118,0 +157,11 @@\n+    private static String getMask(Map<FlagTarget, Map<Integer, List<String>>> target2FlagBit2Fields,\n+                                FlagTarget target) {\n+        long mask = target2FlagBit2Fields.get(target)\n+                                        .keySet()\n+                                        .stream()\n+                                        .mapToLong(bit -> 1L << bit)\n+                                        .reduce(0, (l, r) -> l | r);\n+\n+        return \"0x\" + Long.toHexString(mask) + \"L\";\n+    }\n+\n@@ -125,0 +175,10 @@\n+\n+    public enum FlagTarget {\n+        BLOCK,\n+        CLASS,\n+        METHOD,\n+        MODULE,\n+        PACKAGE,\n+        TYPE_VAR,\n+        VARIABLE;\n+    }\n","filename":"make\/langtools\/tools\/flagsgenerator\/FlagsGenerator.java","additions":64,"deletions":4,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -79,1 +79,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -81,1 +81,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -83,1 +83,1 @@\n-    @Use({FlagTarget.BLOCK, FlagTarget.METHOD, FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.BLOCK, FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -85,1 +85,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -95,1 +95,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -97,1 +97,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -99,1 +99,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -103,1 +103,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -107,1 +107,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -112,1 +112,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -116,1 +116,1 @@\n-    @Use({FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.MODULE, FlagTarget.VARIABLE})\n@@ -126,8 +126,12 @@\n-    @NotFlag\n-    public static final int ACC_SUPER    = 0x0020;\n-    @NotFlag\n-    public static final int ACC_BRIDGE   = 0x0040;\n-    @NotFlag\n-    public static final int ACC_VARARGS  = 0x0080;\n-    @NotFlag\n-    public static final int ACC_MODULE   = 0x8000;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_SUPER    = 1<<5;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_BRIDGE   = 1<<6;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_VARARGS  = 1<<7;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_MODULE   = 1<<15;\n@@ -141,1 +145,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -152,1 +156,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -163,2 +167,2 @@\n-    @Use({FlagTarget.TYPE})\n-    public static final int FROM_SOURCE      = 1<<21; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int FROM_SOURCE      = 1<<21;\n@@ -173,1 +177,1 @@\n-    @Use({FlagTarget.TYPE, FlagTarget.VARIABLE})\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -179,1 +183,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.PACKAGE})\n@@ -185,1 +189,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -190,1 +194,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -196,1 +200,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -207,1 +211,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -213,1 +217,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -224,2 +228,2 @@\n-    @Use({FlagTarget.TYPE})\n-    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29;\n@@ -230,1 +234,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.TYPE_VAR})\n@@ -245,1 +249,1 @@\n-    @Use({FlagTarget.METHOD})\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -251,1 +255,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -269,1 +273,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -282,1 +286,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.TYPE_VAR})\n@@ -301,1 +305,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -308,1 +312,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -314,1 +318,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -332,1 +336,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.TYPE_VAR})\n@@ -338,1 +342,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -356,1 +360,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -362,1 +366,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -368,2 +372,2 @@\n-    @Use({FlagTarget.TYPE}) \/\/ModuleSymbols only\n-    public static final long AUTOMATIC_MODULE = 1L<<57;\n+    @Use({FlagTarget.MODULE})\n+    public static final long AUTOMATIC_MODULE = 1L<<52;\n@@ -374,1 +378,1 @@\n-    @Use({FlagTarget.TYPE}) \/\/PackageSymbols only\n+    @Use({FlagTarget.PACKAGE})\n@@ -386,2 +390,2 @@\n-    @Use({FlagTarget.TYPE}) \/\/ModuleSymbols only\n-    public static final long SYSTEM_MODULE = 1L<<59;\n+    @Use({FlagTarget.MODULE})\n+    public static final long SYSTEM_MODULE = 1L<<53;\n@@ -392,1 +396,1 @@\n-    @Use({FlagTarget.TYPE}) \/\/ClassSymbols only\n+    @Use({FlagTarget.CLASS})\n@@ -398,1 +402,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE, FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -404,1 +408,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE, FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -410,1 +414,1 @@\n-    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE, FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -429,1 +433,1 @@\n-    @Use({FlagTarget.TYPE, FlagTarget.VARIABLE, FlagTarget.METHOD})\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -448,1 +452,1 @@\n-    @Use({FlagTarget.TYPE, FlagTarget.VARIABLE, FlagTarget.METHOD})\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE, FlagTarget.METHOD})\n@@ -490,1 +494,1 @@\n-    @Use({FlagTarget.TYPE})\n+    @Use({FlagTarget.CLASS})\n@@ -581,2 +585,10 @@\n-        \/** This flag can appear on TypeSymbols, includes\n-         *  ModuleSymbols, ClassSymbol, PackageSymbol and TypeVarSymbol.\n+        \/** This flag can appear on ClassSymbols.\n+         *\/\n+        CLASS,\n+        \/** This flag can appear on ModuleSymbols.\n+         *\/\n+        MODULE,\n+        \/** This flag can appear on PackageSymbols.\n+         *\/\n+        PACKAGE,\n+        \/** This flag can appear on TypeVarSymbols.\n@@ -584,1 +596,1 @@\n-        TYPE,\n+        TYPE_VAR,\n@@ -606,0 +618,4 @@\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NoToStringValue {\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":76,"deletions":60,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2130,0 +2130,3 @@\n+        FlagsEnum.assertNoUnexpectedFlags(tree.sym.flags_field,\n+                                          FlagsEnum.MASK_MODULE_FLAGS);\n+\n@@ -2148,0 +2151,7 @@\n+        FlagsEnum.assertNoUnexpectedFlags(tree.sym.flags_field,\n+                                          FlagsEnum.MASK_CLASS_FLAGS);\n+        tree.sym\n+            .getTypeParameters()\n+            .forEach(tv -> FlagsEnum.assertNoUnexpectedFlags(tv.flags_field,\n+                                                             FlagsEnum.MASK_TYPE_VAR_FLAGS));\n+\n@@ -2631,0 +2641,7 @@\n+        FlagsEnum.assertNoUnexpectedFlags(tree.sym.flags_field,\n+                                          FlagsEnum.MASK_METHOD_FLAGS);\n+        tree.sym\n+            .getTypeParameters()\n+            .forEach(tv -> FlagsEnum.assertNoUnexpectedFlags(tv.flags_field,\n+                                                             FlagsEnum.MASK_TYPE_VAR_FLAGS));\n+\n@@ -3718,0 +3735,3 @@\n+        FlagsEnum.assertNoUnexpectedFlags(tree.sym.flags_field,\n+                                          FlagsEnum.MASK_VARIABLE_FLAGS);\n+\n@@ -4352,0 +4372,3 @@\n+        FlagsEnum.assertNoUnexpectedFlags(env.toplevel.packge.flags_field,\n+                                          FlagsEnum.MASK_PACKAGE_FLAGS);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -976,0 +976,3 @@\n+        FlagsEnum.assertNoUnexpectedFlags(v.flags_field,\n+                                          FlagsEnum.MASK_VARIABLE_FLAGS);\n+\n@@ -1001,0 +1004,3 @@\n+        FlagsEnum.assertNoUnexpectedFlags(m.flags_field,\n+                                          FlagsEnum.MASK_METHOD_FLAGS);\n+\n@@ -1538,0 +1544,3 @@\n+        FlagsEnum.assertNoUnexpectedFlags(c.flags_field,\n+                                          FlagsEnum.MASK_CLASS_FLAGS);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main FlagsTest\n+ * @run main\/manual FlagsTest\n@@ -43,1 +43,0 @@\n-import java.util.Map.Entry;\n@@ -47,0 +46,2 @@\n+    private static final int U2_SIZE = 16;\n+\n@@ -48,1 +49,0 @@\n-        verifyFlagsNonOverlapping();\n@@ -52,12 +52,0 @@\n-    private static void verifyFlagsNonOverlapping() throws Throwable {\n-        Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields = computeTarget2Flag2Fields();\n-\n-        for (Entry<FlagTarget, Map<Long, List<Field>>> targetAndFlag : target2Flag2Fields.entrySet()) {\n-            for (Entry<Long, List<Field>> flagAndFields : targetAndFlag.getValue().entrySet()) {\n-                if (flagAndFields.getValue().size() > 1) {\n-                    throw new AssertionError(\"duplicate flag for target: \" + targetAndFlag.getKey() + \", flag: \" + flagAndFields.getKey() + \", flags fields: \" + flagAndFields.getValue());\n-                }\n-            }\n-        }\n-    }\n-\n@@ -67,3 +55,2 @@\n-        long freeTypeFlags = ~collectFlags(target2Flag2Fields, FlagTarget.TYPE);\n-        long freeMethodFlags = ~collectFlags(target2Flag2Fields, FlagTarget.METHOD);\n-        long freeVariableFlags = ~collectFlags(target2Flag2Fields, FlagTarget.VARIABLE);\n+        for (FlagTarget target : FlagTarget.values()) {\n+            long freeFlags = ~collectFlags(target2Flag2Fields, target);\n@@ -71,3 +58,2 @@\n-        printFreeFlags(\"TYPE\", freeTypeFlags);\n-        printFreeFlags(\"METHOD\", freeMethodFlags);\n-        printFreeFlags(\"VARIABLE\", freeVariableFlags);\n+            printFreeFlags(target.name(), freeFlags);\n+        }\n@@ -76,1 +62,1 @@\n-    private static Map<FlagTarget, Map<Long, List<Field>>> computeTarget2Flag2Fields() throws IllegalArgumentException, IllegalAccessException, AssertionError {\n+    private static Map<FlagTarget, Map<Long, List<Field>>> computeTarget2Flag2Fields() throws Throwable {\n@@ -102,1 +88,1 @@\n-            for (int bit = 16; bit < 64; bit++) { \/\/lowest 16 bits are used in classfiles, never suggest adding anything there\n+            for (int bit = U2_SIZE; bit < Long.SIZE; bit++) { \/\/lowest 16 bits are used in classfiles, never suggest adding anything there\n","filename":"test\/langtools\/tools\/javac\/flags\/FlagsTest.java","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"}]}