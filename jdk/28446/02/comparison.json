{"files":[{"patch":"@@ -95,1 +95,1 @@\n-  __ jcc(Assembler::zero, done);\n+  __ jccb(Assembler::zero, done);\n@@ -121,1 +121,1 @@\n-    __ jcc(Assembler::equal, is_clean_card);\n+    __ jccb(Assembler::equal, is_clean_card);\n@@ -130,2 +130,2 @@\n-  __ jcc(Assembler::belowEqual, loop);\n-  __ jmp(done);\n+  __ jccb(Assembler::belowEqual, loop);\n+  __ jmpb(done);\n@@ -136,1 +136,1 @@\n-  __ jmp(next_card);\n+  __ jmpb(next_card);\n@@ -160,16 +160,0 @@\n-static void generate_queue_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n-                                     const Register thread, const Register value, const Register temp) {\n-  \/\/ This code assumes that buffer index is pointer sized.\n-  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n-  \/\/ Can we store a value in the given thread's buffer?\n-  \/\/ (The index field is typed as size_t.)\n-  __ movptr(temp, Address(thread, in_bytes(index_offset)));   \/\/ temp := *(index address)\n-  __ testptr(temp, temp);                                     \/\/ index == 0?\n-  __ jcc(Assembler::zero, runtime);                           \/\/ jump to runtime if index == 0 (full buffer)\n-  \/\/ The buffer is not full, store value into it.\n-  __ subptr(temp, wordSize);                                  \/\/ temp := next index\n-  __ movptr(Address(thread, in_bytes(index_offset)), temp);   \/\/ *(index address) := next index\n-  __ addptr(temp, Address(thread, in_bytes(buffer_offset)));  \/\/ temp := buffer address + next index\n-  __ movptr(Address(temp, 0), value);                         \/\/ *(buffer address + next index) := value\n-}\n-\n@@ -193,2 +177,9 @@\n-                                           Label& done,\n-                                           Label& runtime) {\n+                                           Label& L_done) {\n+  Address index_addr(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n+  Address buffer_addr(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n+\n+  \/\/ This code assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n+\n+  Label L_null, L_runtime;\n+\n@@ -199,0 +190,1 @@\n+\n@@ -200,8 +192,20 @@\n-  __ cmpptr(pre_val, NULL_WORD);\n-  __ jcc(Assembler::equal, done);\n-  generate_queue_insertion(masm,\n-                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n-                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n-                           runtime,\n-                           thread, pre_val, tmp);\n-  __ jmp(done);\n+  __ testptr(pre_val, pre_val);\n+  __ jccb(Assembler::equal, L_null);\n+\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ movptr(tmp, index_addr);               \/\/ temp := *(index address)\n+  __ testptr(tmp, tmp);                     \/\/ index == 0?\n+  __ jccb(Assembler::zero, L_runtime);      \/\/ jump to runtime if index == 0 (full buffer)\n+\n+  \/\/ The buffer is not full, store value into it.\n+  __ subptr(tmp, wordSize);                 \/\/ temp := next index\n+  __ movptr(index_addr, tmp);               \/\/ *(index address) := next index\n+  __ addptr(tmp, buffer_addr);              \/\/ temp := buffer address + next index\n+  __ movptr(Address(tmp, 0), pre_val);      \/\/ *(buffer address + next index) := value\n+\n+  \/\/ Jump out if done, or fall-through to runtime.\n+  \/\/ \"Done\" is far away, so jump cannot be short.\n+  __ bind(L_null);\n+  __ jmp(L_done);\n+  __ bind(L_runtime);\n@@ -222,1 +226,0 @@\n-  Label runtime;\n@@ -234,3 +237,1 @@\n-  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done, runtime);\n-\n-  __ bind(runtime);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done);\n@@ -275,1 +276,0 @@\n-                                  Label& done,\n@@ -282,0 +282,1 @@\n+  Label done;\n@@ -286,1 +287,1 @@\n-  __ jcc(Assembler::equal, done);\n+  __ jccb(Assembler::equal, done);\n@@ -290,2 +291,2 @@\n-    __ cmpptr(new_val, NULL_WORD);                                \/\/ new value == null?\n-    __ jcc(Assembler::equal, done);\n+    __ testptr(new_val, new_val);                                 \/\/ new value == null?\n+    __ jccb(Assembler::equal, done);\n@@ -301,1 +302,1 @@\n-    __ jcc(Assembler::notEqual, done);\n+    __ jccb(Assembler::notEqual, done);\n@@ -306,0 +307,1 @@\n+  __ bind(done);\n@@ -312,3 +314,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp, done, true \/* new_val_may_be_null *\/);\n-  __ bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, true \/* new_val_may_be_null *\/);\n@@ -357,1 +357,0 @@\n-  Label runtime;\n@@ -365,1 +364,1 @@\n-  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation(), runtime);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation());\n@@ -367,1 +366,0 @@\n-  __ bind(runtime);\n@@ -377,3 +375,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp, done, new_val_may_be_null);\n-  __ bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, new_val_may_be_null);\n@@ -452,1 +448,1 @@\n-  __ cmpptr(pre_val_reg, NULL_WORD);\n+  __ testptr(pre_val_reg, pre_val_reg);\n@@ -468,3 +464,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp1, done, true \/* new_val_may_be_null *\/);\n-  masm->bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp1, true \/* new_val_may_be_null *\/);\n@@ -509,1 +503,1 @@\n-  __ jcc(Assembler::zero, runtime);\n+  __ jccb(Assembler::zero, runtime);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":48,"deletions":54,"binary":false,"changes":102,"status":"modified"}]}