{"files":[{"patch":"@@ -92,1 +92,1 @@\n-  Label done;\n+  Label L_done;\n@@ -95,1 +95,1 @@\n-  __ jcc(Assembler::zero, done);\n+  __ jccb(Assembler::zero, L_done);\n@@ -114,1 +114,1 @@\n-  Label loop;\n+  Label L_loop;\n@@ -116,1 +116,1 @@\n-  __ bind(loop);\n+  __ bind(L_loop);\n@@ -118,1 +118,1 @@\n-  Label is_clean_card;\n+  Label L_is_clean_card;\n@@ -121,1 +121,1 @@\n-    __ jcc(Assembler::equal, is_clean_card);\n+    __ jccb(Assembler::equal, L_is_clean_card);\n@@ -126,2 +126,2 @@\n-  Label next_card;\n-  __ bind(next_card);\n+  Label L_next_card;\n+  __ bind(L_next_card);\n@@ -130,2 +130,2 @@\n-  __ jcc(Assembler::belowEqual, loop);\n-  __ jmp(done);\n+  __ jccb(Assembler::belowEqual, L_loop);\n+  __ jmpb(L_done);\n@@ -133,2 +133,2 @@\n-  __ bind(is_clean_card);\n-  \/\/ Card was clean. Dirty card and go to next..\n+  __ bind(L_is_clean_card);\n+  \/\/ Card was clean. Dirty card and go to next.\n@@ -136,1 +136,1 @@\n-  __ jmp(next_card);\n+  __ jmpb(L_next_card);\n@@ -138,1 +138,1 @@\n-  __ bind(done);\n+  __ bind(L_done);\n@@ -160,16 +160,0 @@\n-static void generate_queue_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n-                                     const Register thread, const Register value, const Register temp) {\n-  \/\/ This code assumes that buffer index is pointer sized.\n-  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n-  \/\/ Can we store a value in the given thread's buffer?\n-  \/\/ (The index field is typed as size_t.)\n-  __ movptr(temp, Address(thread, in_bytes(index_offset)));   \/\/ temp := *(index address)\n-  __ testptr(temp, temp);                                     \/\/ index == 0?\n-  __ jcc(Assembler::zero, runtime);                           \/\/ jump to runtime if index == 0 (full buffer)\n-  \/\/ The buffer is not full, store value into it.\n-  __ subptr(temp, wordSize);                                  \/\/ temp := next index\n-  __ movptr(Address(thread, in_bytes(index_offset)), temp);   \/\/ *(index address) := next index\n-  __ addptr(temp, Address(thread, in_bytes(buffer_offset)));  \/\/ temp := buffer address + next index\n-  __ movptr(Address(temp, 0), value);                         \/\/ *(buffer address + next index) := value\n-}\n-\n@@ -193,2 +177,9 @@\n-                                           Label& done,\n-                                           Label& runtime) {\n+                                           Label& L_done) {\n+  Address index_addr(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n+  Address buffer_addr(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n+\n+  \/\/ This code assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n+\n+  Label L_runtime;\n+\n@@ -199,0 +190,1 @@\n+\n@@ -200,8 +192,19 @@\n-  __ cmpptr(pre_val, NULL_WORD);\n-  __ jcc(Assembler::equal, done);\n-  generate_queue_insertion(masm,\n-                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n-                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n-                           runtime,\n-                           thread, pre_val, tmp);\n-  __ jmp(done);\n+  __ testptr(pre_val, pre_val);\n+  __ jcc(Assembler::equal, L_done);\n+\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ movptr(tmp, index_addr);             \/\/ temp := *(index address)\n+  __ testptr(tmp, tmp);                   \/\/ index == 0?\n+  __ jccb(Assembler::zero, L_runtime);    \/\/ jump to runtime if index == 0 (full buffer)\n+\n+  \/\/ The buffer is not full, store value into it.\n+  __ subptr(tmp, wordSize);               \/\/ temp := next index\n+  __ movptr(index_addr, tmp);             \/\/ *(index address) := next index\n+  __ addptr(tmp, buffer_addr);            \/\/ temp := buffer address + next index\n+  __ movptr(Address(tmp, 0), pre_val);    \/\/ *(buffer address + next index) := value\n+\n+  \/\/ Jump out if done, or fall-through to runtime.\n+  \/\/ \"L_done\" is far away, so jump cannot be short.\n+  __ jmp(L_done);\n+  __ bind(L_runtime);\n@@ -222,1 +225,0 @@\n-  Label runtime;\n@@ -234,3 +236,1 @@\n-  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done, runtime);\n-\n-  __ bind(runtime);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done);\n@@ -275,1 +275,0 @@\n-                                  Label& done,\n@@ -282,0 +281,1 @@\n+  Label L_done;\n@@ -286,1 +286,1 @@\n-  __ jcc(Assembler::equal, done);\n+  __ jccb(Assembler::equal, L_done);\n@@ -290,2 +290,2 @@\n-    __ cmpptr(new_val, NULL_WORD);                                \/\/ new value == null?\n-    __ jcc(Assembler::equal, done);\n+    __ testptr(new_val, new_val);                                 \/\/ new value == null?\n+    __ jccb(Assembler::equal, L_done);\n@@ -301,1 +301,1 @@\n-    __ jcc(Assembler::notEqual, done);\n+    __ jccb(Assembler::notEqual, L_done);\n@@ -306,0 +306,1 @@\n+  __ bind(L_done);\n@@ -312,3 +313,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp, done, true \/* new_val_may_be_null *\/);\n-  __ bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, true \/* new_val_may_be_null *\/);\n@@ -357,1 +356,0 @@\n-  Label runtime;\n@@ -365,1 +363,1 @@\n-  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation(), runtime);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation());\n@@ -367,1 +365,0 @@\n-  __ bind(runtime);\n@@ -377,3 +374,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp, done, new_val_may_be_null);\n-  __ bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, new_val_may_be_null);\n@@ -452,1 +447,1 @@\n-  __ cmpptr(pre_val_reg, NULL_WORD);\n+  __ testptr(pre_val_reg, pre_val_reg);\n@@ -468,3 +463,1 @@\n-  Label done;\n-  generate_post_barrier(masm, store_addr, new_val, tmp1, done, true \/* new_val_may_be_null *\/);\n-  masm->bind(done);\n+  generate_post_barrier(masm, store_addr, new_val, tmp1, true \/* new_val_may_be_null *\/);\n@@ -493,2 +486,1 @@\n-  Label done;\n-  Label runtime;\n+  Label L_done, L_runtime;\n@@ -503,1 +495,1 @@\n-  __ jcc(Assembler::equal, done);\n+  __ jcc(Assembler::equal, L_done);\n@@ -509,1 +501,1 @@\n-  __ jcc(Assembler::zero, runtime);\n+  __ jccb(Assembler::zero, L_runtime);\n@@ -517,1 +509,1 @@\n-  __ jmp(done);\n+  __ jmp(L_done);\n@@ -519,1 +511,1 @@\n-  __ bind(runtime);\n+  __ bind(L_runtime);\n@@ -529,1 +521,1 @@\n-  __ bind(done);\n+  __ bind(L_done);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":61,"deletions":69,"binary":false,"changes":130,"status":"modified"}]}