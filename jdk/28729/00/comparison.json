{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+import jdk.internal.classfile.impl.Util;\n@@ -85,1 +87,36 @@\n-        return new AbstractInstruction.UnboundIncrementInstruction(slot, constant);\n+        var opcode = BytecodeHelpers.validateAndIsWideIinc(slot, constant) ? Opcode.IINC_W: Opcode.IINC;\n+        return new AbstractInstruction.UnboundIncrementInstruction(opcode, slot, constant);\n+    }\n+\n+    \/**\n+     * {@return an increment instruction}\n+     * <p>\n+     * The ranges of {@code slot} and {@code constant} are restricted by the\n+     * {@code op} and its {@linkplain Opcode#sizeIfFixed() size}:\n+     * <ul>\n+     * <li>If {@code op} has size 3, {@code slot} must be {@link\n+     *     java.lang.classfile##u1 u1} and {@code constant} must be within\n+     *     {@code [-128, 127]}.\n+     * <li>If {@code op} has size 6, {@code slot} must be {@link\n+     *     java.lang.classfile##u2 u2} and {@code constant} must be within\n+     *     {@code [-32768, 32767]}.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * The explicit {@code op} argument allows creating {@code wide} or\n+     * regular increment instructions when {@code slot} and\n+     * {@code constant} can be encoded with more optimized\n+     * increment instructions.\n+     *\n+     * @param op the opcode for the specific type of increment instruction,\n+     *           which must be of kind {@link Opcode.Kind#INCREMENT}\n+     * @param slot the local variable slot to increment\n+     * @param constant the increment constant\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#INCREMENT} or {@code slot} or\n+     *         {@code constant} is out of range\n+     *\/\n+    static IncrementInstruction of(Opcode op, int slot, int constant) {\n+        Util.checkKind(op, Opcode.Kind.INCREMENT);\n+        BytecodeHelpers.validateIncrement(op, slot, constant);\n+        return new AbstractInstruction.UnboundIncrementInstruction(op, slot, constant);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -835,4 +835,2 @@\n-        public UnboundIncrementInstruction(int slot, int constant) {\n-            super(BytecodeHelpers.validateAndIsWideIinc(slot, constant)\n-                  ? Opcode.IINC_W\n-                  : Opcode.IINC);\n+        public UnboundIncrementInstruction(Opcode op, int slot, int constant) {\n+            super(op);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -453,0 +453,9 @@\n+    public static void validateIncrement(Opcode opcode, int slot, int constant) {\n+        boolean requiresWide = validateAndIsWideIinc(slot, constant);\n+        int size = opcode.sizeIfFixed();\n+        if ((size == 3 && requiresWide)) {\n+            throw new IllegalArgumentException(\n+                    \"IINC: operands require wide encoding for %s\".formatted(opcode));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+            check(fails, () -> IncrementInstruction.of(IINC_W, i, 1));\n@@ -211,0 +212,1 @@\n+            check(fails, () -> IncrementInstruction.of(IINC, i, 1));\n@@ -261,0 +263,18 @@\n+\n+    @Test\n+    void testExplicitIincConstant() {\n+        IncrementInstruction.of(IINC, 0, 2);\n+        IncrementInstruction.of(IINC, 0, Byte.MIN_VALUE);\n+        IncrementInstruction.of(IINC, 0, Byte.MAX_VALUE);\n+\n+        IncrementInstruction.of(IINC_W, 0, 2);\n+        IncrementInstruction.of(IINC_W, 0, Short.MIN_VALUE);\n+        IncrementInstruction.of(IINC_W, 0, Short.MAX_VALUE);\n+\n+        for (int i : new int[] {Byte.MIN_VALUE - 1, Byte.MAX_VALUE + 1}) {\n+            assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(IINC, 0, i));\n+        }\n+        for (int i : new int[] {Short.MIN_VALUE - 1, Short.MAX_VALUE + 1}) {\n+            assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(IINC_W, 0, i));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}