{"files":[{"patch":"@@ -4327,0 +4327,1 @@\n+    MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,0 +212,4 @@\n+  \/\/ Enable WXWrite: the function is called directly from nmethod_entry_barrier\n+  \/\/ stub.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current()));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,1 +274,3 @@\n-  Patcher(address insn_addr) : RelocActions(insn_addr) {}\n+  Patcher(address insn_addr) : RelocActions(insn_addr) {\n+    MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,0 @@\n-  \/\/ das(uint64_t(instruction_address()),2);\n@@ -147,0 +146,1 @@\n+    MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n@@ -353,2 +353,0 @@\n-void NativeGeneralJump::verify() {  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,10 +93,12 @@\n-  jint int_at(int offset) const { return *(jint*)addr_at(offset); }\n-  juint uint_at(int offset) const { return *(juint*)addr_at(offset); }\n-  address ptr_at(int offset) const { return *(address*)addr_at(offset); }\n-  oop oop_at(int offset) const { return *(oop*)addr_at(offset); }\n-\n-  void set_char_at(int offset, char c) { *addr_at(offset) = (u_char)c; }\n-  void set_int_at(int offset, jint i) { *(jint*)addr_at(offset) = i; }\n-  void set_uint_at(int offset, jint i) { *(juint*)addr_at(offset) = i; }\n-  void set_ptr_at(int offset, address ptr) { *(address*)addr_at(offset) = ptr; }\n-  void set_oop_at(int offset, oop o) { *(oop*)addr_at(offset) = o; }\n+  jint int_at(int offset) const     { return *(jint*)addr_at(offset); }\n+  juint uint_at(int offset) const   { return *(juint*)addr_at(offset); }\n+  address ptr_at(int offset) const  { return *(address*)addr_at(offset); }\n+  oop oop_at(int offset) const      { return *(oop*)addr_at(offset); }\n+\n+#define MACOS_WX_WRITE MACOS_AARCH64_ONLY(os::thread_wx_enable_write())\n+  void set_char_at(int offset, char c)     { MACOS_WX_WRITE;  *addr_at(offset) = (u_char)c; }\n+  void set_int_at(int offset, jint i)      { MACOS_WX_WRITE;  *(jint*)addr_at(offset) = i; }\n+  void set_uint_at(int offset, jint i)     { MACOS_WX_WRITE;  *(juint*)addr_at(offset) = i; }\n+  void set_ptr_at(int offset, address ptr) { MACOS_WX_WRITE;  *(address*)addr_at(offset) = ptr; }\n+  void set_oop_at(int offset, oop o)       { MACOS_WX_WRITE;  *(oop*)addr_at(offset) = o; }\n+#undef MACOS_WX_WRITE\n@@ -383,1 +385,0 @@\n-  static void verify();\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -11809,1 +11809,3 @@\n-    StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory();\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_setMemory)) {\n+      StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory();\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -629,0 +629,4 @@\n+#ifdef __APPLE__\n+  DefaultWXWriteMode = UseOldWX ? WXWrite : WXArmedForWrite;\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#ifdef AARCH64\n@@ -38,3 +39,15 @@\n-  AARCH64_ONLY(develop(bool, AssertWXAtThreadSync, true,                \\\n-          \"Conservatively check W^X thread state at possible safepoint\" \\\n-          \"or handshake\"))\n+  develop(bool, TraceWXHealing, false,                                  \\\n+          \"track occurrences of W^X mode healing\")                      \\\n+  develop(bool, UseOldWX, false,                                        \\\n+          \"Choose old W^X implementation.\")                             \\\n+  product(bool, StressWXHealing, false, DIAGNOSTIC,                     \\\n+          \"Stress W xor X healing on MacOS\")\n+\n+#else\n+#define RUNTIME_OS_FLAGS(develop,                                       \\\n+                         develop_pd,                                    \\\n+                         product,                                       \\\n+                         product_pd,                                    \\\n+                         range,                                         \\\n+                         constraint)\n+#endif\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -826,0 +826,1 @@\n+  \/\/ https:\/\/web.archive.org\/web\/20131214182431\/https:\/\/blogs.oracle.com\/dave\/entry\/cas_and_cache_trivia_invalidate\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"utilities\/decoder.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"utilities\/nativeStackPrinter.hpp\"\n@@ -58,0 +60,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -88,0 +91,2 @@\n+WXMode DefaultWXWriteMode;\n+\n@@ -236,4 +241,0 @@\n-  \/\/ Enable WXWrite: this function is called by the signal handler at arbitrary\n-  \/\/ point of execution.\n-  ThreadWXEnable wx(WXWrite, thread);\n-\n@@ -242,2 +243,1 @@\n-\n-  address pc          = nullptr;\n+  address pc   = nullptr;\n@@ -249,0 +249,42 @@\n+#ifdef MACOS_AARCH64\n+    \/\/ If we got a SIGBUS because we tried to write into the code\n+    \/\/ cache, try enabling WXWrite mode.\n+    if (sig == SIGBUS\n+        && pc != info->si_addr\n+        && CodeCache::contains(info->si_addr)\n+        && os::address_is_in_vm(pc)) {\n+      WXMode *entry_mode = thread->_cur_wx_mode;\n+      if (entry_mode != nullptr && *entry_mode == WXArmedForWrite) {\n+        if (TraceWXHealing) {\n+          static const char *mode_names[3] = {\"WXWrite\", \"WXExec\", \"WXArmedForWrite\"};\n+          tty->print(\"Healing WXMode %s at %p to WXWrite\",\n+                        mode_names[*entry_mode], entry_mode);\n+          char name[128];\n+          int offset = 0;\n+          if (os::dll_address_to_function_name(pc, name, sizeof name, &offset)) {\n+            tty->print_cr(\"  (%s+0x%x)\", name, offset);\n+          } else {\n+            tty->cr();\n+          }\n+          if (Verbose) {\n+            char buf[O_BUFLEN];\n+            NativeStackPrinter nsp(thread);\n+            nsp.print_stack(tty, buf, sizeof(buf), pc,\n+                            true \/* print_source_info *\/, -1 \/* max stack *\/);\n+          }\n+        }\n+#ifndef PRODUCT\n+        guarantee(StressWXHealing,\n+                  \"We should not reach here unless StressWXHealing\");\n+#endif\n+        *(thread->_cur_wx_mode) = WXWrite;\n+        return thread->wx_enable_write();\n+      }\n+    }\n+\n+    \/\/ There may be cases where code after this point that we call\n+    \/\/ from the signal handler changes WX state, so we protect against\n+    \/\/ that by saving and restoring the state.\n+    ThreadWXEnable wx(thread->get_wx_state(), thread);\n+#endif\n+\n@@ -518,1 +560,6 @@\n-#ifdef __APPLE__\n+#ifdef MACOS_AARCH64\n+static THREAD_LOCAL bool os_bsd_jit_exec_enabled;\n+\/\/ This is a wrapper around the standard library function\n+\/\/ pthread_jit_write_protect_np(3). We keep track of the state of\n+\/\/ per-thread write protection on the MAP_JIT region in the\n+\/\/ thread-local variable os_bsd_jit_exec_enabled.\n@@ -520,1 +567,5 @@\n-  pthread_jit_write_protect_np(mode == WXExec);\n+  bool exec_enabled = mode != WXWrite;\n+  if (exec_enabled != os_bsd_jit_exec_enabled NOT_PRODUCT( || DefaultWXWriteMode == WXWrite)) {\n+    permit_forbidden_function::pthread_jit_write_protect_np(exec_enabled);\n+    os_bsd_jit_exec_enabled = exec_enabled;\n+  }\n@@ -522,1 +573,22 @@\n-#endif\n+\n+\/\/ If the current thread is in the WX state WXArmedForWrite, change\n+\/\/ the state to WXWrite.\n+bool Thread::wx_enable_write() {\n+  if (_wx_state == WXArmedForWrite) {\n+    _wx_state = WXWrite;\n+    os::current_thread_enable_wx(WXWrite);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ A wrapper around wx_enable_write() for when the current thread is\n+\/\/ not known.\n+void os::thread_wx_enable_write() {\n+  if (!StressWXHealing) {\n+    Thread::current()->wx_enable_write();\n+  }\n+}\n+\n+#endif \/\/ MACOS_AARCH64\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":81,"deletions":9,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -547,0 +547,1 @@\n+  MACOS_AARCH64_ONLY(current->wx_enable_write());\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+PerfCounter*    ClassLoader::_perf_change_wx_time = nullptr;\n@@ -1377,0 +1378,1 @@\n+    NEWPERFTICKCOUNTER(_perf_change_wx_time, SUN_CLS, \"changeWXTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+  static PerfCounter* _perf_change_wx_time;\n@@ -271,0 +272,3 @@\n+  static PerfCounter* perf_change_wx_time() {\n+    return _perf_change_wx_time;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -528,0 +528,2 @@\n+\n+    MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1926,0 +1926,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n@@ -2018,0 +2019,2 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n+\n@@ -2411,0 +2414,2 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,3 @@\n+\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n+\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+  \/\/ Enable WXWrite: the function is called directly from nmethod_entry_barrier\n+  \/\/ stub.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n@@ -175,0 +176,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n@@ -180,0 +182,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n@@ -193,0 +196,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n@@ -233,0 +237,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n@@ -262,0 +267,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1813,0 +1813,2 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  MACOS_AARCH64_ONLY(os::thread_wx_enable_write());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -282,1 +282,0 @@\n-\n@@ -286,1 +285,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n@@ -288,0 +286,4 @@\n+    MACOS_AARCH64_ONLY(                                              \\\n+      static WXMode wx_mode = DefaultWXWriteMode;                    \\\n+      ThreadWXEnable __wx(&wx_mode, current);                        \\\n+    )                                                                \\\n@@ -314,1 +316,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n@@ -316,0 +317,4 @@\n+    MACOS_AARCH64_ONLY(                                              \\\n+      static WXMode wx_mode = DefaultWXWriteMode;                    \\\n+      ThreadWXEnable __wx(&wx_mode, current);                        \\\n+    )                                                                \\\n@@ -324,1 +329,4 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n+    MACOS_AARCH64_ONLY(                                              \\\n+      static WXMode wx_mode = DefaultWXWriteMode;                    \\\n+      ThreadWXEnable __wx(&wx_mode, current);                        \\\n+    )                                                                \\\n@@ -361,1 +369,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -363,0 +370,4 @@\n+    MACOS_AARCH64_ONLY(                                              \\\n+      static WXMode wx_mode = DefaultWXWriteMode;                    \\\n+      ThreadWXEnable __wx(&wx_mode, thread);                         \\\n+    )                                                                \\\n@@ -386,1 +397,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -388,0 +398,4 @@\n+    MACOS_AARCH64_ONLY(                                              \\\n+      static WXMode wx_mode = DefaultWXWriteMode;                    \\\n+      ThreadWXEnable __wx(&wx_mode, thread);                         \\\n+    )                                                                \\\n@@ -396,1 +410,0 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -398,0 +411,4 @@\n+    MACOS_AARCH64_ONLY(                                              \\\n+      static WXMode wx_mode = DefaultWXWriteMode;                    \\\n+      ThreadWXEnable __wx(&wx_mode, thread);                         \\\n+    )                                                                \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-\n-  MACOS_AARCH64_ONLY(_thread->enable_wx(WXExec));\n@@ -104,2 +102,0 @@\n-  MACOS_AARCH64_ONLY(_thread->enable_wx(WXWrite));\n-\n@@ -415,11 +411,14 @@\n-      StubRoutines::call_stub()(\n-        (address)&link,\n-        \/\/ (intptr_t*)&(result->_value), \/\/ see NOTE above (compiler problem)\n-        result_val_address,          \/\/ see NOTE above (compiler problem)\n-        result_type,\n-        method(),\n-        entry_point,\n-        parameter_address,\n-        args->size_of_parameters(),\n-        CHECK\n-      );\n+      {\n+        MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n+        StubRoutines::call_stub()(\n+          (address)&link,\n+          \/\/ (intptr_t*)&(result->_value), \/\/ see NOTE above (compiler problem)\n+          result_val_address,          \/\/ see NOTE above (compiler problem)\n+          result_type,\n+          method(),\n+          entry_point,\n+          parameter_address,\n+          args->size_of_parameters(),\n+          CHECK\n+        );\n+      }\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -380,9 +380,0 @@\n-\n-  \/\/ Macos\/aarch64 should be in the right state for safepoint (e.g.\n-  \/\/ deoptimization needs WXWrite).  Crashes caused by the wrong state rarely\n-  \/\/ happens in practice, making such issues hard to find and reproduce.\n-#if defined(__APPLE__) && defined(AARCH64)\n-  if (AssertWXAtThreadSync) {\n-    assert_wx_state(WXWrite);\n-  }\n-#endif\n@@ -522,0 +513,5 @@\n+#ifdef MACOS_AARCH64\n+  _cur_wx_enable(nullptr),\n+  _cur_wx_mode(0),\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+class ThreadWXEnable;\n@@ -172,1 +173,1 @@\n- public:\n+public:\n@@ -1266,0 +1267,9 @@\n+\n+#ifdef MACOS_AARCH64\n+  friend class ThreadWXEnable;\n+  friend class PosixSignals;\n+\n+  ThreadWXEnable* _cur_wx_enable;\n+  WXMode* _cur_wx_mode;\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+#ifdef MACOS_AARCH64\n@@ -144,2 +145,3 @@\n-  WXWrite,\n-  WXExec\n+  WXWrite = 0,\n+  WXExec = 1,\n+  WXArmedForWrite = 2,\n@@ -148,0 +150,3 @@\n+extern WXMode DefaultWXWriteMode;\n+#endif \/\/ MACOS_AARCH64\n+\n@@ -1087,1 +1092,1 @@\n-#if defined(__APPLE__) && defined(AARCH64)\n+#ifdef MACOS_AARCH64\n@@ -1090,0 +1095,2 @@\n+  \/\/ Macos-AArch64 only.\n+  static void thread_wx_enable_write();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -613,1 +613,1 @@\n-#if defined(__APPLE__) && defined(AARCH64)\n+#ifdef MACOS_AARCH64\n@@ -620,1 +620,1 @@\n-\n+  bool wx_enable_write();\n@@ -624,1 +624,4 @@\n-#endif \/\/ __APPLE__ && AARCH64\n+  WXMode get_wx_state() {\n+    return _wx_state;\n+  }\n+#endif \/\/ MACOS_AARCH64\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -34,1 +35,1 @@\n-#if defined(__APPLE__) && defined(AARCH64)\n+#ifdef MACOS_AARCH64\n@@ -74,0 +75,3 @@\n+\n+static void dummy() { }\n+\n@@ -78,0 +82,1 @@\n+  permit_forbidden_function::pthread_jit_write_protect_np(false);\n@@ -79,0 +84,2 @@\n+  \/\/ Side effect: preload base address of libjvm\n+  guarantee(os::address_is_in_vm(CAST_FROM_FN_PTR(address, &dummy)), \"must be\");\n@@ -88,1 +95,9 @@\n-    os::current_thread_enable_wx(new_state);\n+    switch (new_state) {\n+      case WXWrite:\n+      case WXExec:\n+        os::current_thread_enable_wx(new_state);\n+        break;\n+      case WXArmedForWrite:\n+        break;\n+      default: ShouldNotReachHere();  break;\n+    }\n@@ -92,0 +107,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#if defined(__APPLE__) && defined(AARCH64)\n+#ifdef MACOS_AARCH64\n@@ -33,0 +33,2 @@\n+#include \"classfile\/classLoader.hpp\"\n+#include \"runtime\/perfData.inline.hpp\"\n@@ -38,0 +40,2 @@\n+  WXMode *_this_wx_mode;\n+  ThreadWXEnable *_prev;\n@@ -39,0 +43,13 @@\n+  ThreadWXEnable(WXMode* new_mode, Thread* thread) :\n+    _thread(thread), _this_wx_mode(new_mode) {\n+    NOT_PRODUCT(PerfTraceTime ptt(ClassLoader::perf_change_wx_time());)\n+    JavaThread* javaThread\n+      = _thread && _thread->is_Java_thread()\n+                ? JavaThread::cast(_thread) : nullptr;\n+    _prev = javaThread ? javaThread->_cur_wx_enable: nullptr;\n+    _old_mode = _thread ? _thread->enable_wx(*new_mode) : WXWrite;\n+    if (javaThread) {\n+      javaThread->_cur_wx_enable = this;\n+      javaThread->_cur_wx_mode = new_mode;\n+    }\n+  }\n@@ -40,3 +57,14 @@\n-    _thread(thread),\n-    _old_mode(_thread ? _thread->enable_wx(new_mode) : WXWrite)\n-  { }\n+    _thread(thread), _this_wx_mode(nullptr) {\n+    NOT_PRODUCT(PerfTraceTime ptt(ClassLoader::perf_change_wx_time());)\n+    guarantee(new_mode != WXArmedForWrite, \"need a pointer to heal\");\n+    JavaThread* javaThread\n+      = _thread && _thread->is_Java_thread()\n+        ? JavaThread::cast(_thread) : nullptr;\n+    _prev = javaThread ? javaThread->_cur_wx_enable: nullptr;\n+    _old_mode = _thread ? _thread->enable_wx(new_mode) : WXWrite;\n+    if (javaThread) {\n+      javaThread->_cur_wx_enable = this;\n+      javaThread->_cur_wx_mode = nullptr;\n+    }\n+  }\n+\n@@ -44,0 +72,1 @@\n+    NOT_PRODUCT(PerfTraceTime ptt(ClassLoader::perf_change_wx_time());)\n@@ -46,0 +75,7 @@\n+      JavaThread* javaThread\n+        = _thread && _thread->is_Java_thread()\n+          ? JavaThread::cast(_thread) : nullptr;\n+      if (javaThread) {\n+        javaThread->_cur_wx_enable = _prev;\n+        javaThread->_cur_wx_mode = _prev ? _prev->_this_wx_mode : nullptr;\n+      }\n@@ -49,1 +85,1 @@\n-#endif \/\/ __APPLE__ && AARCH64\n+#endif \/\/ MACOS_AARCH64\n","filename":"src\/hotspot\/share\/runtime\/threadWXSetters.inline.hpp","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -83,0 +83,4 @@\n+\/\/ Disallow non-wrapped raw library function.\n+MACOS_AARCH64_ONLY(FORBID_C_FUNCTION(void pthread_jit_write_protect_np(int enabled), noexcept, \\\n+                                     \"use os::current_thread_enable_wx\");)\n+\n","filename":"src\/hotspot\/share\/utilities\/forbiddenFunctions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -559,0 +559,3 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+#define MACOS_AARCH64 1\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+MACOS_AARCH64_ONLY( \\\n+  inline void pthread_jit_write_protect_np(int enabled) { return ::pthread_jit_write_protect_np(enabled); } \\\n+)\n+\n","filename":"src\/hotspot\/share\/utilities\/permitForbiddenFunctions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"mac\"\n+ * @requires os.arch == \"aarch64\"\n+ * @summary Run shell with -XX:+StressWXHealing. This tests most of\n+ * the triggers for WX mode.\n+ * @library \/test\/lib\n+ * @compile WXHealing.java\n+ * @run main TestWXHealing\n+ *\/\n+\n+import jdk.test.lib.JDKToolFinder;\n+\n+import java.io.*;\n+import java.util.regex.*;\n+import jdk.jshell.tool.*;\n+import jdk.test.lib.process.*;\n+\n+public class TestWXHealing {\n+\n+    public static void main(String[] args) throws Throwable {\n+        String[] opts = {\"-XX:+UnlockDiagnosticVMOptions\",\n+                         \"-XX:+TraceWXHealing\", \"-XX:+StressWXHealing\", \"WXHealing\"};\n+        var process = ProcessTools.createTestJavaProcessBuilder(opts).start();\n+        String output = new String(process.getInputStream().readAllBytes());\n+        System.out.println(output);\n+        var pattern = Pattern.compile(\"Healing WXMode WXArmedForWrite at 0x[0-9a-f]* to WXWrite  \");\n+        var matches = pattern.matcher(output).results().count();\n+        if (matches < 10) {\n+            throw new RuntimeException(\"Only \" + matches + \" healings in\\n\" + output);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestWXHealing.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.util.regex.*;\n+import jdk.jshell.tool.*;\n+\n+public class WXHealing {\n+\n+    \/\/ There's nothing special about jshell here: we just need an\n+    \/\/ application that does a lot of compilation and class loading.\n+    public static void main(String[] args) throws Throwable {\n+        JavaShellToolBuilder\n+            .builder()\n+            .in(new ByteArrayInputStream\n+                (\"\"\"\n+                 void main() {\n+                     System.out.println(\"Hello, World!\");\n+                 }\n+                 main()\n+                 2+2\n+                 Math.sqrt(2)\n+                 4 * Math.atan(1)\n+                 Math.exp(1)\n+                 \"\"\"\n+                 .getBytes()), null)\n+            .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/WXHealing.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}