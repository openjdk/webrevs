{"files":[{"patch":"@@ -964,1 +964,1 @@\n-  return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -592,0 +592,70 @@\n+    case C1StubId::is_instance_of_id:\n+    {\n+      \/\/ Mirror: Z_ARG1(R2)\n+      \/\/ Object: Z_ARG2\n+      \/\/ Temps: Z_ARG3, Z_ARG4, Z_ARG5, Z_R10, Z_R11\n+      \/\/ Result: Z_RET(R2)\n+\n+      \/\/ Get the Klass* into Z_ARG3\n+      Register klass = Z_ARG3 , obj = Z_ARG2, result = Z_RET;\n+      Register temp0 = Z_ARG4, temp1 = Z_ARG5, temp2 = Z_R10, temp3 = Z_R11;\n+\n+      __ z_lg(klass, Address(Z_ARG1, java_lang_Class::klass_offset()));\n+\n+      Label is_secondary;\n+\n+      __ clear_reg(result \/* Z_R2 *\/, true \/* whole_reg *\/, false \/* set_cc *\/);  \/\/ sets result=0 (failure)\n+\n+      __ z_ltgr(klass, klass); \/\/ Klass is null\n+      __ z_bcr(Assembler::bcondEqual, Z_R14);\n+\n+      __ z_ltgr(obj, obj); \/\/ obj is null\n+      __ z_bcr(Assembler::bcondEqual, Z_R14);\n+\n+      __ z_llgf(temp0, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n+      __ compare32_and_branch(temp0, in_bytes(Klass::secondary_super_cache_offset()), Assembler::bcondEqual, is_secondary); \/\/ Klass is a secondary superclass\n+\n+      \/\/ Klass is a concrete class\n+      __ load_klass(temp1, obj);\n+      __ z_cg(klass, Address(temp1, temp0));\n+\n+      \/\/ result is already holding 0, denoting NotEqual case\n+      __ z_lochi(result, 1, Assembler::bcondEqual);\n+      __ z_br(Z_R14);\n+\n+      __ bind(is_secondary);\n+\n+      __ load_klass(obj, obj);\n+\n+      \/\/ This is necessary because I am never in my own secondary_super list.\n+      __ z_cgr(obj, klass);\n+      __ z_lochi(result, 1, Assembler::bcondEqual);\n+      __ z_bcr(Assembler::bcondEqual, Z_R14);\n+\n+      const int frame_size = 2*BytesPerWord + frame::z_abi_160_size;\n+      __ save_return_pc();\n+      __ push_frame(frame_size);\n+\n+      \/\/ Z_R10 and Z_R11 are call saved, so we must push them before any use\n+      __ z_stg(temp2 \/*Z_R10*\/, 0*BytesPerWord + frame::z_abi_160_size, Z_SP);\n+      __ z_stg(temp3 \/*Z_R11*\/, 1*BytesPerWord + frame::z_abi_160_size, Z_SP);\n+      assert(2*BytesPerWord + frame::z_abi_160_size == frame_size, \"check\");\n+\n+      __ lookup_secondary_supers_table_var(obj, klass,\n+                                          \/*temps*\/ temp0, temp1, temp2, temp3,\n+                                          result);\n+\n+      \/\/ lookup_secondary_supers_table_var return 0 on success and 1 on failure.\n+      \/\/ but this method returns 0 on failure and 1 on success.\n+      \/\/ so we have to invert the result from lookup_secondary_supers_table_var.\n+      __ z_xilf(result, 1);  \/\/ invert the result\n+\n+      __ z_lg(temp2 \/*Z_R10*\/, 0*BytesPerWord + frame::z_abi_160_size, Z_SP);\n+      __ z_lg(temp3 \/*Z_R11*\/, 1*BytesPerWord + frame::z_abi_160_size, Z_SP);\n+      assert(2*BytesPerWord + frame::z_abi_160_size == frame_size, \"check\");\n+      __ pop_frame();\n+      __ restore_return_pc();\n+\n+      __ z_br(Z_R14);\n+\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -3674,1 +3674,1 @@\n-  assert_different_registers(r_sub_klass, r_super_klass, r_result, r_temp1, r_temp2, r_temp3);\n+  assert_different_registers(r_sub_klass, r_super_klass, r_result, r_temp1, r_temp2, r_temp3, Z_R0_scratch);\n@@ -3708,6 +3708,7 @@\n-  assert_different_registers(Z_ARG1, r_sub_klass, r_linear_result, r_result);\n-  lgr_if_needed(Z_ARG1, r_super_klass);\n-  assert_different_registers(Z_ARG2, r_linear_result, r_result);\n-  lgr_if_needed(Z_ARG2, r_sub_klass);\n-  assert_different_registers(Z_ARG3, r_result);\n-  z_lgr(Z_ARG3, r_linear_result);\n+  \/\/ report fatal error and terminate VM\n+\n+  \/\/ Argument shuffle. Using stack to avoid clashes.\n+  z_stg(r_super_klass, -8, Z_SP);\n+  z_stg(r_sub_klass, -16, Z_SP);\n+  z_stg(r_linear_result, -24, Z_SP);\n+\n@@ -3715,0 +3716,5 @@\n+\n+  z_lg(Z_ARG1, -8, Z_SP); \/\/ r_super_klass\n+  z_lg(Z_ARG2, -16, Z_SP); \/\/ r_sub_klass\n+  z_lg(Z_ARG3, -24, Z_SP); \/\/ r_linear_result\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}