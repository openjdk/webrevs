{"files":[{"patch":"@@ -964,1 +964,1 @@\n-  return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -592,0 +592,62 @@\n+    case C1StubId::is_instance_of_id:\n+    {\n+      \/\/ Mirror: Z_ARG1(R2)\n+      \/\/ Object: Z_ARG2\n+      \/\/ Temps: Z_ARG3, Z_ARG4, Z_ARG5, Z_R10, Z_R11\n+      \/\/ Result: Z_RET(R2)\n+\n+      \/\/ Get the Klass* into Z_ARG3\n+      Register klass = Z_ARG3 , obj = Z_ARG2, result = Z_RET;\n+      Register temp0 = Z_ARG4, temp1 = Z_ARG5, temp2 = Z_R10, temp3 = Z_R11;\n+\n+      __ z_lg(klass, Address(Z_ARG1, java_lang_Class::klass_offset()));\n+\n+      Label is_secondary;\n+\n+      __ clear_reg(result \/* Z_R2 *\/, true \/* whole_reg *\/, false \/* set_cc *\/);  \/\/ sets result=0 (failure)\n+\n+      __ z_ltgr(klass, klass); \/\/ Klass is null\n+      __ z_bcr(Assembler::bcondEqual, Z_R14);\n+\n+      __ z_ltgr(obj, obj); \/\/ obj is null\n+      __ z_bcr(Assembler::bcondEqual, Z_R14);\n+\n+      __ z_llgf(temp0, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n+      __ compare32_and_branch(temp0, in_bytes(Klass::secondary_super_cache_offset()), Assembler::bcondEqual, is_secondary); \/\/ Klass is a secondary superclass\n+\n+      \/\/ Klass is a concrete class\n+      __ load_klass(temp1, obj);\n+      __ z_cg(klass, Address(temp1, temp0));\n+\n+      \/\/ result is already holding 0, denoting NotEqual case\n+      __ load_on_condition_imm_32(result, 1, Assembler::bcondEqual);\n+      __ z_br(Z_R14);\n+\n+      __ bind(is_secondary);\n+\n+      __ load_klass(obj, obj);\n+\n+      \/\/ This is necessary because I am never in my own secondary_super list.\n+      __ z_cgr(obj, klass);\n+      __ load_on_condition_imm_32(result, 1, Assembler::bcondEqual);\n+      __ z_bcr(Assembler::bcondEqual, Z_R14);\n+\n+      \/\/ Z_R10 and Z_R11 are caller saved, so we must need to preserve them before any use\n+      __ z_ldgr(Z_F1, Z_R10);\n+      __ z_ldgr(Z_F3, Z_R11);\n+\n+      __ lookup_secondary_supers_table_var(obj, klass,\n+                                          \/*temps*\/ temp0, temp1, temp2, temp3,\n+                                          result);\n+\n+      \/\/ lookup_secondary_supers_table_var return 0 on success and 1 on failure.\n+      \/\/ but this method returns 0 on failure and 1 on success.\n+      \/\/ so we have to invert the result from lookup_secondary_supers_table_var.\n+      __ z_xilf(result, 1);  \/\/ invert the result\n+\n+      __ z_lgdr(Z_R10, Z_F1);\n+      __ z_lgdr(Z_R11, Z_F3);\n+\n+      __ z_br(Z_R14);\n+\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3682,3 +3682,0 @@\n-  const Register r_one = Z_R0_scratch;\n-  z_lghi(r_one, 1); \/\/ for locgr down there, to a load result for failure\n-\n@@ -3700,1 +3697,1 @@\n-  z_locgr(r_linear_result, r_one, bcondNotHigh); \/\/ load failure if array_length <= 0\n+  load_on_condition_imm_32(r_linear_result, 1, bcondNotHigh); \/\/ load failure if array_length <= 0\n@@ -3708,6 +3705,8 @@\n-  assert_different_registers(Z_ARG1, r_sub_klass, r_linear_result, r_result);\n-  lgr_if_needed(Z_ARG1, r_super_klass);\n-  assert_different_registers(Z_ARG2, r_linear_result, r_result);\n-  lgr_if_needed(Z_ARG2, r_sub_klass);\n-  assert_different_registers(Z_ARG3, r_result);\n-  z_lgr(Z_ARG3, r_linear_result);\n+  \/\/ report fatal error and terminate VM\n+\n+  \/\/ Argument shuffle\n+  \/\/ Z_F1, Z_F3, Z_F5 are volatile regs\n+  z_ldgr(Z_F1, r_super_klass);\n+  z_ldgr(Z_F3, r_sub_klass);\n+  z_ldgr(Z_F5, r_linear_result);\n+\n@@ -3715,0 +3714,5 @@\n+\n+  z_lgdr(Z_ARG1, Z_F1); \/\/ r_super_klass\n+  z_lgdr(Z_ARG2, Z_F3); \/\/ r_sub_klass\n+  z_lgdr(Z_ARG3, Z_F5); \/\/ r_linear_result\n+\n@@ -6956,0 +6960,26 @@\n+\n+\/\/ LOAD HALFWORD IMMEDIATE ON CONDITION (32 <- 16)\n+void MacroAssembler::load_on_condition_imm_32(Register dst, int64_t i2, branch_condition cc) {\n+  if (VM_Version::has_LoadStoreConditional2()) { \/\/ z_lochi works on z13 or above\n+    assert(Assembler::is_simm16(i2), \"sanity\");\n+    z_lochi(dst, i2, cc);\n+  } else {\n+    NearLabel done;\n+    z_brc(Assembler::inverse_condition(cc), done);\n+    z_lhi(dst, i2);\n+    bind(done);\n+  }\n+}\n+\n+\/\/ LOAD HALFWORD IMMEDIATE ON CONDITION (64 <- 16)\n+void MacroAssembler::load_on_condition_imm_64(Register dst, int64_t i2, branch_condition cc) {\n+  if (VM_Version::has_LoadStoreConditional2()) { \/\/ z_locghi works on z13 or above\n+    assert(Assembler::is_simm16(i2), \"sanity\");\n+    z_locghi(dst, i2, cc);\n+  } else {\n+    NearLabel done;\n+    z_brc(Assembler::inverse_condition(cc), done);\n+    z_lghi(dst, i2);\n+    bind(done);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1112,0 +1112,2 @@\n+  void load_on_condition_imm_32(Register dst, int64_t i2, branch_condition cc);\n+  void load_on_condition_imm_64(Register dst, int64_t i2, branch_condition cc);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}