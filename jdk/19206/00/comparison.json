{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @enablePreview\n@@ -32,8 +32,0 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.Method;\n-\n@@ -43,1 +35,5 @@\n-import java.util.Arrays;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.constant.MethodTypeDesc;\n@@ -69,1 +65,1 @@\n-    TestBCI(Class<?> c) throws ConstantPoolException, IOException {\n+    TestBCI(Class<?> c) throws IllegalArgumentException, IOException {\n@@ -73,2 +69,2 @@\n-            ClassFile cf = ClassFile.read(in);\n-            methods = Arrays.stream(cf.methods)\n+            var cf = ClassFile.of().parse(in.readAllBytes());\n+            methods = cf.methods().stream()\n@@ -132,1 +128,1 @@\n-        final Method method;\n+        final MethodModel method;\n@@ -134,2 +130,1 @@\n-        final String paramTypes;\n-        final String returnType;\n+        final MethodTypeDesc desc;\n@@ -137,1 +132,1 @@\n-        MethodInfo(ClassFile cf, Method m) {\n+        MethodInfo(ClassModel cf, MethodModel m) {\n@@ -139,24 +134,8 @@\n-\n-            String name;\n-            String paramTypes;\n-            String returnType;\n-            LineNumberTable_attribute.Entry[] lineNumberTable;\n-            try {\n-                \/\/ method name\n-                name = m.getName(cf.constant_pool);\n-                \/\/ signature\n-                paramTypes = m.descriptor.getParameterTypes(cf.constant_pool);\n-                returnType = m.descriptor.getReturnType(cf.constant_pool);\n-                Code_attribute codeAttr = (Code_attribute)\n-                    m.attributes.get(Attribute.Code);\n-                lineNumberTable = ((LineNumberTable_attribute)\n-                    codeAttr.attributes.get(Attribute.LineNumberTable)).line_number_table;\n-            } catch (ConstantPoolException|Descriptor.InvalidDescriptor e) {\n-                throw new RuntimeException(e);\n-            }\n-            this.name = name;\n-            this.paramTypes = paramTypes;\n-            this.returnType = returnType;\n-            Arrays.stream(lineNumberTable).forEach(entry ->\n-                bciToLineNumbers.computeIfAbsent(entry.start_pc, _n -> new TreeSet<>())\n-                    .add(entry.line_number));\n+            this.name = m.methodName().stringValue();\n+            this.desc = m.methodTypeSymbol();\n+            m.code().orElseThrow(() -> new IllegalArgumentException(\"Missing Code in \" + m))\n+                    .findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                    .orElseThrow(() -> new IllegalArgumentException(\"Missing LineNumberTable in \" + m))\n+                    .lineNumbers().forEach(entry ->\n+                            bciToLineNumbers.computeIfAbsent(entry.startPc(), _ -> new TreeSet<>())\n+                                    .add(entry.lineNumber()));\n@@ -181,1 +160,1 @@\n-            sb.append(paramTypes).append(returnType).append(\" \");\n+            sb.append(desc.displayDescriptor()).append(\" \");\n","filename":"test\/jdk\/java\/lang\/StackWalker\/TestBCI.java","additions":22,"deletions":43,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import com.sun.tools.classfile.*;\n-import static com.sun.tools.classfile.ConstantPool.*;\n@@ -28,1 +26,0 @@\n-import java.io.InputStream;\n@@ -30,0 +27,7 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n@@ -50,1 +54,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile jdk.jdeps\/com.sun.tools.jdeps\n+ * @enablePreview\n@@ -90,1 +94,0 @@\n-    private final ReferenceFinder finder;\n@@ -92,1 +95,0 @@\n-        this.finder = new ReferenceFinder(getFilter(), getVisitor());\n@@ -97,10 +99,29 @@\n-    private ReferenceFinder.Filter getFilter() {\n-        final String classname = \"jdk\/internal\/reflect\/Reflection\";\n-        final String method = \"getCallerClass\";\n-        return new ReferenceFinder.Filter() {\n-            public boolean accept(ConstantPool cpool, CPRefInfo cpref) {\n-                try {\n-                    CONSTANT_NameAndType_info nat = cpref.getNameAndTypeInfo();\n-                    return cpref.getClassName().equals(classname) && nat.getName().equals(method);\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n+    private void check(ClassModel clazz) {\n+        final String className = \"jdk\/internal\/reflect\/Reflection\";\n+        final String methodName = \"getCallerClass\";\n+        boolean checkMethods = false;\n+        for (var pe : clazz.constantPool()) {\n+            if (pe instanceof MethodRefEntry ref\n+                    && ref.owner().name().equalsString(className)\n+                    && ref.name().equalsString(methodName)) {\n+                checkMethods = true;\n+            }\n+        }\n+\n+        if (!checkMethods)\n+            return;\n+\n+        for (var method : clazz.methods()) {\n+            var code = method.code().orElse(null);\n+            if (code == null)\n+                continue;\n+\n+            boolean needsCsm = false;\n+            for (var element : code) {\n+                if (element instanceof InvokeInstruction invoke\n+                        && invoke.opcode() == Opcode.INVOKESTATIC\n+                        && invoke.method() instanceof MethodRefEntry ref\n+                        && ref.owner().name().equalsString(className)\n+                        && ref.name().equalsString(methodName)) {\n+                    needsCsm = true;\n+                    break;\n@@ -109,1 +130,5 @@\n-        };\n+\n+            if (needsCsm) {\n+                process(clazz, method);\n+            }\n+        }\n@@ -112,24 +137,16 @@\n-    private ReferenceFinder.Visitor getVisitor() {\n-        return new ReferenceFinder.Visitor() {\n-            public void visit(ClassFile cf, Method m,  List<CPRefInfo> refs) {\n-                try {\n-                    \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n-                    \/\/ which is a \"special\" delegate to the internal getCallerClass\n-                    if (cf.getName().equals(\"sun\/reflect\/Reflection\") &&\n-                        m.getName(cf.constant_pool).equals(\"getCallerClass\"))\n-                        return;\n-\n-                    String name = String.format(\"%s#%s %s\", cf.getName(),\n-                                                m.getName(cf.constant_pool),\n-                                                m.descriptor.getValue(cf.constant_pool));\n-                    if (!CallerSensitiveFinder.isCallerSensitive(m, cf.constant_pool)) {\n-                        csMethodsMissingAnnotation.add(name);\n-                        System.err.println(\"Missing @CallerSensitive: \" + name);\n-                    } else {\n-                        if (verbose) {\n-                            System.out.format(\"@CS  %s%n\", name);\n-                        }\n-                    }\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+    private void process(ClassModel cf, MethodModel m) {\n+        \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n+        \/\/ which is a \"special\" delegate to the internal getCallerClass\n+        if (cf.thisClass().name().equalsString(\"sun\/reflect\/Reflection\") &&\n+                m.methodName().equalsString(\"getCallerClass\"))\n+            return;\n+\n+        String name = cf.thisClass().asInternalName() + '#'\n+                + m.methodName().stringValue() + ' '\n+                + m.methodType().stringValue();\n+        if (!CallerSensitiveFinder.isCallerSensitive(m)) {\n+            csMethodsMissingAnnotation.add(name);\n+            System.err.println(\"Missing @CallerSensitive: \" + name);\n+        } else {\n+            if (verbose) {\n+                System.out.format(\"@CS  %s%n\", name);\n@@ -137,1 +154,1 @@\n-        };\n+        }\n@@ -141,1 +158,1 @@\n-            ExecutionException, ConstantPoolException\n+            ExecutionException, IllegalArgumentException\n@@ -149,5 +166,2 @@\n-    private static boolean isCallerSensitive(Method m, ConstantPool cp)\n-            throws ConstantPoolException\n-    {\n-        RuntimeAnnotations_attribute attr =\n-            (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeVisibleAnnotations);\n+    private static boolean isCallerSensitive(MethodModel m) {\n+        var attr = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n@@ -155,4 +169,2 @@\n-            for (int i = 0; i < attr.annotations.length; i++) {\n-                Annotation ann = attr.annotations[i];\n-                String annType = cp.getUTF8Value(ann.type_index);\n-                if (CALLER_SENSITIVE_ANNOTATION.equals(annType)) {\n+            for (var ann : attr.annotations()) {\n+                if (ann.className().equalsString(CALLER_SENSITIVE_ANNOTATION)) {\n@@ -177,2 +189,3 @@\n-                try (InputStream is = Files.newInputStream(p)) {\n-                    finder.parse(ClassFile.read(is));\n+                try {\n+                    var clz = ClassFile.of().parse(p); \/\/ propagate IllegalArgumentException\n+                    check(clz);\n@@ -181,2 +194,0 @@\n-                } catch (ConstantPoolException x) {\n-                    throw new RuntimeException(x);\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CallerSensitiveFinder.java","additions":68,"deletions":57,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,0 @@\n-import com.sun.tools.classfile.*;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_PRIVATE;\n-import static com.sun.tools.classfile.ConstantPool.*;\n@@ -30,1 +26,0 @@\n-import java.io.InputStream;\n@@ -32,0 +27,8 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.reflect.AccessFlag;\n@@ -38,1 +41,0 @@\n-import java.util.Arrays;\n@@ -53,0 +55,2 @@\n+import static java.lang.constant.ConstantDescs.CD_Class;\n+\n@@ -57,2 +61,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.jdeps\n+ * @enablePreview\n@@ -69,1 +72,1 @@\n-    private static Set<String> KNOWN_NON_FINAL_CSMS =\n+    private static final Set<String> KNOWN_NON_FINAL_CSMS =\n@@ -114,1 +117,0 @@\n-    private final ReferenceFinder finder;\n@@ -116,1 +118,0 @@\n-        this.finder = new ReferenceFinder(getFilter(), getVisitor());\n@@ -118,1 +119,0 @@\n-\n@@ -123,1 +123,1 @@\n-               ConstantPoolException\n+               IllegalArgumentException\n@@ -130,0 +130,11 @@\n+    private void check(ClassModel clazz) {\n+        final String className = \"jdk\/internal\/reflect\/Reflection\";\n+        final String methodName = \"getCallerClass\";\n+        boolean checkMethods = false;\n+        for (var pe : clazz.constantPool()) {\n+            if (pe instanceof MethodRefEntry ref\n+                    && ref.owner().name().equalsString(className)\n+                    && ref.name().equalsString(methodName)) {\n+                checkMethods = true;\n+            }\n+        }\n@@ -131,10 +142,17 @@\n-    private ReferenceFinder.Filter getFilter() {\n-        final String classname = \"jdk\/internal\/reflect\/Reflection\";\n-        final String method = \"getCallerClass\";\n-        return new ReferenceFinder.Filter() {\n-            public boolean accept(ConstantPool cpool, CPRefInfo cpref) {\n-                try {\n-                    CONSTANT_NameAndType_info nat = cpref.getNameAndTypeInfo();\n-                    return cpref.getClassName().equals(classname) && nat.getName().equals(method);\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n+        if (!checkMethods)\n+            return;\n+\n+        for (var method : clazz.methods()) {\n+            var code = method.code().orElse(null);\n+            if (code == null)\n+                continue;\n+\n+            boolean needsCsm = false;\n+            for (var element : code) {\n+                if (element instanceof InvokeInstruction invoke\n+                        && invoke.opcode() == Opcode.INVOKESTATIC\n+                        && invoke.method() instanceof MethodRefEntry ref\n+                        && ref.owner().name().equalsString(className)\n+                        && ref.name().equalsString(methodName)) {\n+                    needsCsm = true;\n+                    break;\n@@ -143,2 +161,0 @@\n-        };\n-    }\n@@ -146,31 +162,2 @@\n-    private ReferenceFinder.Visitor getVisitor() {\n-        return new ReferenceFinder.Visitor() {\n-            public void visit(ClassFile cf, Method m,  List<CPRefInfo> refs) {\n-                try {\n-                    \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n-                    \/\/ which is a \"special\" delegate to the internal getCallerClass\n-                    if (cf.getName().equals(\"sun\/reflect\/Reflection\") &&\n-                        m.getName(cf.constant_pool).equals(\"getCallerClass\"))\n-                        return;\n-\n-                    String name = methodSignature(cf, m);\n-                    if (!CheckCSMs.isStaticOrFinal(cf, m, cf.constant_pool)) {\n-                        System.err.println(\"Unsupported @CallerSensitive: \" + name);\n-                        nonFinalCSMs.add(name);\n-                    } else {\n-                        if (listCSMs) {\n-                            System.out.format(\"@CS  %s%n\", name);\n-                        }\n-                    }\n-\n-                    \/\/ find the adapter implementation for CSM with the caller parameter\n-                    if (!csmWithCallerParameter.containsKey(cf.getName())) {\n-                        Set<String> methods = Arrays.stream(cf.methods)\n-                                                    .filter(m0 -> csmWithCallerParameter(cf, m, m0))\n-                                                    .map(m0 -> methodSignature(cf, m0))\n-                                                    .collect(Collectors.toSet());\n-                        csmWithCallerParameter.put(cf.getName(), methods);\n-                    }\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+            if (needsCsm) {\n+                process(clazz, method);\n@@ -178,1 +165,1 @@\n-        };\n+        }\n@@ -181,7 +168,15 @@\n-    private static String methodSignature(ClassFile cf, Method m) {\n-        try {\n-            return String.format(\"%s#%s %s\", cf.getName(),\n-                                 m.getName(cf.constant_pool),\n-                                 m.descriptor.getValue(cf.constant_pool));\n-        } catch (ConstantPoolException ex) {\n-            throw new RuntimeException(ex);\n+    private void process(ClassModel cf, MethodModel m) {\n+        \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n+        \/\/ which is a \"special\" delegate to the internal getCallerClass\n+        if (cf.thisClass().name().equalsString(\"sun\/reflect\/Reflection\")\n+                && m.methodName().equalsString(\"getCallerClass\"))\n+            return;\n+\n+        String name = methodSignature(cf, m);\n+        if (!CheckCSMs.isStaticOrFinal(cf, m)) {\n+            System.err.println(\"Unsupported @CallerSensitive: \" + name);\n+            nonFinalCSMs.add(name);\n+        } else {\n+            if (listCSMs) {\n+                System.out.format(\"@CS  %s%n\", name);\n+            }\n@@ -189,0 +184,15 @@\n+\n+        \/\/ find the adapter implementation for CSM with the caller parameter\n+        if (!csmWithCallerParameter.containsKey(cf.thisClass().asInternalName())) {\n+            Set<String> methods = cf.methods().stream()\n+                    .filter(m0 -> csmWithCallerParameter(cf, m, m0))\n+                    .map(m0 -> methodSignature(cf, m0))\n+                    .collect(Collectors.toSet());\n+            csmWithCallerParameter.put(cf.thisClass().asInternalName(), methods);\n+        }\n+    }\n+\n+    private static String methodSignature(ClassModel cf, MethodModel m) {\n+        return cf.thisClass().asInternalName() + '#'\n+                + m.methodName().stringValue() + ' '\n+                + m.methodType().stringValue();\n@@ -191,9 +201,13 @@\n-    private static boolean csmWithCallerParameter(ClassFile cf, Method csm, Method m) {\n-        ConstantPool cp = cf.constant_pool;\n-        try {\n-            int csmParamCount = csm.descriptor.getParameterCount(cp);\n-            int paramCount = m.descriptor.getParameterCount(cp);\n-            \/\/ an adapter method must have the same name and return type and a trailing Class parameter\n-            if (!(csm.getName(cp).equals(m.getName(cp)) &&\n-                    paramCount == (csmParamCount+1) &&\n-                    m.descriptor.getReturnType(cp).equals(csm.descriptor.getReturnType(cp)))) {\n+    private static boolean csmWithCallerParameter(ClassModel cf, MethodModel csm, MethodModel m) {\n+        var csmType = csm.methodTypeSymbol();\n+        var mType = m.methodTypeSymbol();\n+        \/\/ an adapter method must have the same name and return type and a trailing Class parameter\n+        if (!(csm.methodName().equals(m.methodName()) &&\n+                mType.parameterCount() == (csmType.parameterCount() + 1) &&\n+                mType.returnType().equals(csmType.returnType()))) {\n+            return false;\n+        }\n+        \/\/ the descriptor of the adapter method must have the parameters\n+        \/\/ of the caller-sensitive method and an additional Class parameter\n+        for (int i = 0; i < csmType.parameterCount(); i++) {\n+            if (mType.parameterType(i) != csmType.parameterType(i)) {\n@@ -202,23 +216,0 @@\n-            \/\/ the descriptor of the adapter method must have the parameters\n-            \/\/ of the caller-sensitive method and an additional Class parameter\n-            String csmDesc = csm.descriptor.getParameterTypes(cp);\n-            String desc = m.descriptor.getParameterTypes(cp);\n-            int index = desc.indexOf(\", java.lang.Class)\");\n-            if (index == -1) {\n-                index = desc.indexOf(\"java.lang.Class)\");\n-                if (index == -1) return false;\n-            }\n-            String s = desc.substring(0, index) + \")\";\n-            if (s.equals(csmDesc)) {\n-                if (!m.access_flags.is(ACC_PRIVATE)) {\n-                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n-                            methodSignature(cf, csm) + \" must be private\");\n-                }\n-                if (!isCallerSensitiveAdapter(m, cp)) {\n-                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n-                            methodSignature(cf, csm) + \" must be annotated with @CallerSensitiveAdapter\");\n-                }\n-                return true;\n-            }\n-        } catch (ConstantPoolException|Descriptor.InvalidDescriptor e) {\n-            throw new RuntimeException(e);\n@@ -226,1 +217,14 @@\n-        return false;\n+\n+        if (!mType.parameterType(mType.parameterCount() - 1).equals(CD_Class)) {\n+            return false;\n+        }\n+\n+        if (!m.flags().has(AccessFlag.PRIVATE)) {\n+            throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                    methodSignature(cf, csm) + \" must be private\");\n+        }\n+        if (!isCallerSensitiveAdapter(m)) {\n+            throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                    methodSignature(cf, csm) + \" must be annotated with @CallerSensitiveAdapter\");\n+        }\n+        return true;\n@@ -234,2 +238,2 @@\n-    private static boolean isCallerSensitive(Method m, ConstantPool cp)\n-        throws ConstantPoolException\n+    private static boolean isCallerSensitive(MethodModel m)\n+        throws IllegalArgumentException\n@@ -237,2 +241,1 @@\n-        RuntimeAnnotations_attribute attr =\n-            (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeVisibleAnnotations);\n+        var attr = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n@@ -240,4 +243,2 @@\n-            for (int i = 0; i < attr.annotations.length; i++) {\n-                Annotation ann = attr.annotations[i];\n-                String annType = cp.getUTF8Value(ann.type_index);\n-                if (CALLER_SENSITIVE_ANNOTATION.equals(annType)) {\n+            for (var ann : attr.annotations()) {\n+                if (ann.className().equalsString(CALLER_SENSITIVE_ANNOTATION)) {\n@@ -251,5 +252,3 @@\n-    private static boolean isCallerSensitiveAdapter(Method m, ConstantPool cp)\n-            throws ConstantPoolException\n-    {\n-        RuntimeAnnotations_attribute attr =\n-                (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeInvisibleAnnotations);\n+    private static boolean isCallerSensitiveAdapter(MethodModel m) {\n+        var attr = m.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n+\n@@ -257,4 +256,2 @@\n-            for (int i = 0; i < attr.annotations.length; i++) {\n-                Annotation ann = attr.annotations[i];\n-                String annType = cp.getUTF8Value(ann.type_index);\n-                if (CALLER_SENSITIVE_ADAPTER_ANNOTATION.equals(annType)) {\n+            for (var ann : attr.annotations()) {\n+                if (ann.className().equalsString(CALLER_SENSITIVE_ADAPTER_ANNOTATION)) {\n@@ -268,4 +265,2 @@\n-    private static boolean isStaticOrFinal(ClassFile cf, Method m, ConstantPool cp)\n-        throws ConstantPoolException\n-    {\n-        if (!isCallerSensitive(m, cp))\n+    private static boolean isStaticOrFinal(ClassModel cf, MethodModel m) {\n+        if (!isCallerSensitive(m))\n@@ -275,3 +270,3 @@\n-        return m.access_flags.is(AccessFlags.ACC_STATIC) ||\n-               m.access_flags.is(AccessFlags.ACC_FINAL) ||\n-               cf.access_flags.is(AccessFlags.ACC_FINAL);\n+        return m.flags().has(AccessFlag.STATIC) ||\n+               m.flags().has(AccessFlag.FINAL) ||\n+               cf.flags().has(AccessFlag.FINAL);\n@@ -291,2 +286,3 @@\n-                try (InputStream is = Files.newInputStream(p)) {\n-                    finder.parse(ClassFile.read(is));\n+                try {\n+                    var clz = ClassFile.of().parse(p); \/\/ propagate IllegalArgumentException\n+                    check(clz);\n@@ -295,2 +291,0 @@\n-                } catch (ConstantPoolException x) {\n-                    throw new RuntimeException(x);\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CheckCSMs.java","additions":120,"deletions":126,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.jdeps\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/MissingCallerSensitive.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ * @enablePreview\n@@ -36,0 +36,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -40,1 +43,0 @@\n-import com.sun.tools.classfile.*;\n@@ -271,4 +273,4 @@\n-            ClassFile cf = ClassFile.read(in);\n-            for (ConstantPool.CPInfo cpinfo: cf.constant_pool.entries()) {\n-                if (cpinfo.getTag() == ConstantPool.CONSTANT_Utf8) {\n-                    String v = ((ConstantPool.CONSTANT_Utf8_info) cpinfo).value;\n+            ClassModel cf = ClassFile.of().parse(in.readAllBytes());\n+            for (var cpinfo : cf.constantPool()) {\n+                if (cpinfo instanceof Utf8Entry utf8Entry) {\n+                    String v = utf8Entry.stringValue();\n@@ -279,1 +281,1 @@\n-        } catch (ConstantPoolException ignore) {\n+        } catch (IllegalArgumentException ignore) {\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckResourceKeys.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,2 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -source 16 -target 16 CheckACC_STRICTFlagOnclinitTest.java\n- * @run main CheckACC_STRICTFlagOnclinitTest\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n@@ -33,0 +32,7 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.nio.file.Path;\n@@ -35,1 +41,0 @@\n-import java.io.File;\n@@ -37,7 +42,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Method;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_STRICT;\n@@ -45,1 +43,1 @@\n-public strictfp class CheckACC_STRICTFlagOnclinitTest {\n+public class CheckACC_STRICTFlagOnclinitTest {\n@@ -52,4 +50,15 @@\n-    static {\n-        class Foo {\n-            class Bar {\n-                void m11() {}\n+    private static final String SOURCE = \"\"\"\n+            public strictfp class Test {\n+                static {\n+                    class Foo {\n+                        class Bar {\n+                            void m11() {}\n+                        }\n+                        void m1() {}\n+                    }\n+                }\n+                void m2() {\n+                    class Any {\n+                        void m21() {}\n+                    }\n+                }\n@@ -57,8 +66,1 @@\n-            void m1() {}\n-        }\n-    }\n-    void m2() {\n-        class Any {\n-            void m21() {}\n-        }\n-    }\n+            \"\"\";\n@@ -66,1 +68,1 @@\n-    private List<String> errors = new ArrayList<>();\n+    private final List<String> errors = new ArrayList<>();\n@@ -69,1 +71,1 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+            throws IOException {\n@@ -74,8 +76,12 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n-        String testClasses = System.getProperty(\"test.classes\");\n-        check(testClasses,\n-              \"CheckACC_STRICTFlagOnclinitTest.class\",\n-              \"CheckACC_STRICTFlagOnclinitTest$1Foo.class\",\n-              \"CheckACC_STRICTFlagOnclinitTest$1Foo$Bar.class\",\n-              \"CheckACC_STRICTFlagOnclinitTest$1Any.class\");\n-        if (errors.size() > 0) {\n+            throws IOException {\n+        Path in = Path.of(\"in\");\n+        Path out = Path.of(\"out\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(in, SOURCE);\n+        CompilerUtils.compile(in, out, \"--release\", \"16\");\n+        check(out,\n+              \"Test.class\",\n+              \"Test$1Foo.class\",\n+              \"Test$1Foo$Bar.class\",\n+              \"Test$1Any.class\");\n+        if (!errors.isEmpty()) {\n@@ -89,5 +95,1 @@\n-    void check(String dir, String... fileNames)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n+    void check(Path dir, String... fileNames) throws IOException {\n@@ -95,1 +97,1 @@\n-            ClassFile classFileToCheck = ClassFile.read(new File(dir, fileName));\n+            ClassModel classFileToCheck = ClassFile.of().parse(dir.resolve(fileName));\n@@ -97,2 +99,2 @@\n-            for (Method method : classFileToCheck.methods) {\n-                if ((method.access_flags.flags & ACC_STRICT) == 0) {\n+            for (MethodModel method : classFileToCheck.methods()) {\n+                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n@@ -100,2 +102,2 @@\n-                            method.getName(classFileToCheck.constant_pool),\n-                            classFileToCheck.getName()));\n+                            method.methodName().stringValue(),\n+                            classFileToCheck.thisClass().asInternalName()));\n@@ -106,16 +108,0 @@\n-\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    void check(String dir, String... fileNames) throws IOException{\n-\/\/        for (String fileName : fileNames) {\n-\/\/            ClassModel classFileToCheck = ClassFile.of().parse(new File(dir, fileName).toPath());\n-\/\/\n-\/\/            for (MethodModel method : classFileToCheck.methods()) {\n-\/\/                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n-\/\/                    errors.add(String.format(offendingMethodErrorMessage,\n-\/\/                            method.methodName().stringValue(),\n-\/\/                            classFileToCheck.thisClass().asInternalName()));\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/    }\n-\n","filename":"test\/langtools\/tools\/javac\/7166455\/CheckACC_STRICTFlagOnclinitTest.java","additions":47,"deletions":61,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,2 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.BootstrapMethods_attribute.BootstrapMethodSpecifier;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodHandle_info;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n@@ -29,1 +27,10 @@\n-import java.io.File;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BootstrapMethodEntry;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.constantpool.MethodHandleEntry;\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n+import java.nio.file.Path;\n@@ -35,17 +42,3 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *\n- * @clean *\n- * @compile -source 8 -target 8 TestIndyStringConcat.java\n- * @run main TestIndyStringConcat false\n- *\n- * @clean *\n- * @compile -XDstringConcat=inline TestIndyStringConcat.java\n- * @run main TestIndyStringConcat false\n- *\n- * @clean *\n- * @compile -XDstringConcat=indy TestIndyStringConcat.java\n- * @run main TestIndyStringConcat true\n- *\n- * @clean *\n- * @compile -XDstringConcat=indyWithConstants TestIndyStringConcat.java\n- * @run main TestIndyStringConcat true\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n+ * @run main TestIndyStringConcat\n@@ -55,1 +48,3 @@\n-    static String other;\n+    private static final String SOURCE = \"\"\"\n+            public class IndyStringConcat {\n+                static String other;\n@@ -57,3 +52,5 @@\n-    public static String test() {\n-        return \"Foo\" + other;\n-    }\n+                public static String test() {\n+                    return \"Foo\" + other;\n+                }\n+            }\n+            \"\"\";\n@@ -62,11 +59,3 @@\n-        boolean expected = Boolean.valueOf(args[0]);\n-        boolean actual = hasStringConcatFactoryCall(\"test\");\n-        if (expected != actual) {\n-            throw new AssertionError(\"expected = \" + expected + \", actual = \" + actual);\n-        }\n-    }\n-\n-    public static boolean hasStringConcatFactoryCall(String methodName) throws Exception {\n-        ClassFile classFile = ClassFile.read(new File(System.getProperty(\"test.classes\", \".\"),\n-                TestIndyStringConcat.class.getName() + \".class\"));\n-        ConstantPool constantPool = classFile.constant_pool;\n+        Path src = Path.of(\"src\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(src, SOURCE);\n@@ -74,3 +63,5 @@\n-        BootstrapMethods_attribute bsm_attr =\n-                (BootstrapMethods_attribute)classFile\n-                        .getAttribute(Attribute.BootstrapMethods);\n+        int errors = 0;\n+        errors += test(false, \"java8\", \"-source\", \"8\", \"-target\", \"8\");\n+        errors += test(false, \"inline\", \"-XDstringConcat=inline\");\n+        errors += test(true, \"indy\", \"-XDstringConcat=indy\");\n+        errors += test(true, \"indyWithConstants\", \"-XDstringConcat=indyWithConstants\");\n@@ -78,8 +69,4 @@\n-        for (Method method : classFile.methods) {\n-            if (method.getName(constantPool).equals(methodName)) {\n-                Code_attribute code = (Code_attribute) method.attributes\n-                        .get(Attribute.Code);\n-                for (Instruction i : code.getInstructions()) {\n-                    if (i.getOpcode() == Opcode.INVOKEDYNAMIC) {\n-                        CONSTANT_InvokeDynamic_info indyInfo =\n-                                (CONSTANT_InvokeDynamic_info) constantPool.get(i.getUnsignedShort(1));\n+        if (errors > 0) {\n+            throw new AssertionError(errors + \" cases failed\");\n+        }\n+    }\n@@ -87,2 +74,10 @@\n-                        BootstrapMethodSpecifier bsmSpec =\n-                                bsm_attr.bootstrap_method_specifiers[indyInfo.bootstrap_method_attr_index];\n+    public static int test(boolean expected, String label, String... args) throws Exception {\n+        Path src = Path.of(\"src\");\n+        Path out = Path.of(label);\n+        CompilerUtils.compile(src, out, args);\n+        if (hasStringConcatFactoryCall(out.resolve(\"IndyStringConcat.class\"), \"test\") != expected) {\n+            System.err.println(\"Expected \" + expected + \" failed for case \" + label);\n+            return 1;\n+        }\n+        return 0;\n+    }\n@@ -90,2 +85,2 @@\n-                        CONSTANT_MethodHandle_info bsmInfo =\n-                                (CONSTANT_MethodHandle_info) constantPool.get(bsmSpec.bootstrap_method_ref);\n+    public static boolean hasStringConcatFactoryCall(Path file, String methodName) throws Exception {\n+        ClassModel classFile = ClassFile.of().parse(file);\n@@ -93,1 +88,8 @@\n-                        if (bsmInfo.getCPRefInfo().getClassName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(methodName)) {\n+                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement i : code.elementList()) {\n+                    if (i instanceof InvokeDynamicInstruction indy) {\n+                        BootstrapMethodEntry bsmSpec = indy.invokedynamic().bootstrap();\n+                        MethodHandleEntry bsmInfo = bsmSpec.bootstrapMethod();\n+                        if (bsmInfo.reference().owner().asInternalName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n@@ -103,23 +105,0 @@\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    public static boolean hasStringConcatFactoryCall(String methodName) throws Exception {\n-\/\/        ClassModel classFile = ClassFile.of().parse(new File(System.getProperty(\"test.classes\", \".\"),\n-\/\/                TestIndyStringConcat.class.getName() + \".class\").toPath());\n-\/\/\n-\/\/        for (MethodModel method : classFile.methods()) {\n-\/\/            if (method.methodName().equalsString(methodName)) {\n-\/\/                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n-\/\/                for (CodeElement i : code.elementList()) {\n-\/\/                    if (i instanceof InvokeDynamicInstruction) {\n-\/\/                        InvokeDynamicInstruction indy = (InvokeDynamicInstruction) i;\n-\/\/                        BootstrapMethodEntry bsmSpec = indy.invokedynamic().bootstrap();\n-\/\/                        MethodHandleEntry bsmInfo = bsmSpec.bootstrapMethod();\n-\/\/                        if (bsmInfo.reference().owner().asInternalName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n-\/\/                            return true;\n-\/\/                        }\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/        return false;\n-\/\/    }\n-\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/TestIndyStringConcat.java","additions":56,"deletions":77,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.SourceFile_attribute;\n-\n-import java.io.InputStream;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import javax.tools.JavaFileObject;\n-\n-import toolbox.ToolBox;\n-\n-\/**\n- * Base class for Source file attribute tests. Checks expected file name for specified classes in the SourceFile attribute.\n- * To add new tests you should extend the SourceFileTestBase class and invoke {@link #test} for static sources\n- * or {@link #compileAndTest} for generated sources. For more information see corresponding methods.\n- *\n- * @see #test\n- * @see #compileAndTest\n- *\/\n-public class SourceFileTestBase_legacy extends TestBase {\n-    \/**\n-     * Checks expected fileName for the specified class in the SourceFile attribute.\n-     *\n-     * @param classToTest class to check its SourceFile attribute\n-     * @param fileName    expected name of the file from which the test file is compiled.\n-     *\/\n-    protected void test(Class<?> classToTest, String fileName) throws Exception {\n-        assertAttributePresent(ClassFile.read(getClassFile(classToTest)), fileName);\n-    }\n-\n-    \/**\n-     * Checks expected fileName for the specified class in the SourceFile attribute.\n-     *\n-     * @param classToTest class name to check its SourceFile attribute\n-     * @param fileName    expected name of the file from which the test file is compiled.\n-     *\/\n-    protected void test(String classToTest, String fileName) throws Exception {\n-        assertAttributePresent(ClassFile.read(getClassFile(classToTest + \".class\")), fileName);\n-    }\n-\n-    \/**\n-     * Checks expected fileName for the specified class in the SourceFile attribute.\n-     *\n-     * @param classToTest path of class to check its SourceFile attribute\n-     * @param fileName    expected name of the file from which the test file is compiled.\n-     *\/\n-    protected void test(Path classToTest, String fileName) throws Exception {\n-        assertAttributePresent(ClassFile.read(classToTest), fileName);\n-    }\n-\n-    \/**\n-     * Compiles sourceCode and for each specified class name checks the SourceFile attribute.\n-     * The file name is extracted from source code.\n-     *\n-     * @param sourceCode    source code to compile\n-     * @param classesToTest class names to check their SourceFile attribute.\n-     *\/\n-    protected void compileAndTest(String sourceCode, String... classesToTest) throws Exception {\n-\n-        Map<String, ? extends JavaFileObject> classes = compile(sourceCode).getClasses();\n-        String fileName = ToolBox.getJavaFileNameFromSource(sourceCode);\n-        for (String className : classesToTest) {\n-            ClassFile classFile;\n-            try (InputStream input = classes.get(className).openInputStream()) {\n-                classFile = ClassFile.read(input);\n-            }\n-            assertAttributePresent(classFile, fileName);\n-        }\n-    }\n-\n-    private void assertAttributePresent(ClassFile classFile, String fileName) throws Exception {\n-\n-        \/\/We need to count attributes with the same names because there is no appropriate API in the ClassFile.\n-\n-        List<SourceFile_attribute> sourceFileAttributes = new ArrayList<>();\n-        for (Attribute a : classFile.attributes.attrs) {\n-            if (Attribute.SourceFile.equals(a.getName(classFile.constant_pool))) {\n-                sourceFileAttributes.add((SourceFile_attribute) a);\n-            }\n-        }\n-\n-        assertEquals(sourceFileAttributes.size(), 1, \"Should be the only SourceFile attribute\");\n-\n-        SourceFile_attribute attribute = sourceFileAttributes.get(0);\n-\n-        assertEquals(classFile.constant_pool.getUTF8Info(attribute.attribute_name_index).value,\n-                Attribute.SourceFile, \"Incorrect attribute name\");\n-        assertEquals(classFile.constant_pool.getUTF8Info(attribute.sourcefile_index).value, fileName,\n-                \"Incorrect source file name\");\n-        assertEquals(attribute.attribute_length, 2, \"Incorrect attribute length\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/SourceFileTestBase_legacy.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/tools\/lib \/tools\/javac\/lib ..\/lib_legacy\n+ * @library \/tools\/lib \/tools\/javac\/lib \/test\/lib ..\/lib\n@@ -31,7 +31,4 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n- * @build toolbox.ToolBox InMemoryFileManager TestBase SourceFileTestBase_legacy\n- * @compile -source 10 -target 10 SyntheticClassTest.java\n- * @run main SyntheticClassTest true\n- * @clean SyntheticClassTest$1\n- * @compile SyntheticClassTest.java\n- * @run main SyntheticClassTest false\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build toolbox.ToolBox InMemoryFileManager TestBase SourceFileTestBase\n+ * @enablePreview\n+ * @run main SyntheticClassTest\n@@ -40,0 +37,3 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n@@ -41,0 +41,1 @@\n+import java.nio.file.Path;\n@@ -42,1 +43,1 @@\n-public class SyntheticClassTest extends SourceFileTestBase_legacy {\n+public class SyntheticClassTest extends SourceFileTestBase {\n@@ -44,2 +45,22 @@\n-        boolean expectSynthetic = Boolean.parseBoolean(args[0]);\n-        new Inner();\n+        String sourceCode = \"\"\"\n+                public class SyntheticClass {\n+                    static class Inner {\n+                        private Inner() {\n+                        }\n+                    }\n+\n+                    public SyntheticClass() {\n+                        new Inner();\n+                    }\n+                }\n+                \"\"\";\n+        Path srcDir = Path.of(\"src\");\n+        Path v10Dir = Path.of(\"out10\");\n+        Path modernDir = Path.of(\"out\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(srcDir, sourceCode);\n+        CompilerUtils.compile(srcDir, v10Dir, \"--release\", \"10\");\n+        CompilerUtils.compile(srcDir, modernDir);\n+        test(v10Dir, true);\n+        test(modernDir, false);\n+    }\n@@ -47,0 +68,1 @@\n+    private static void test(Path path, boolean expectSynthetic) throws Exception {\n@@ -48,1 +70,1 @@\n-            new SyntheticClassTest().test(\"SyntheticClassTest$1\", \"SyntheticClassTest.java\");\n+            new SyntheticClassTest().test(path.resolve(\"SyntheticClass$1.class\"), \"SyntheticClass.java\");\n@@ -58,5 +80,0 @@\n-\n-    static class Inner {\n-        private Inner() {\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/SyntheticClassTest.java","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n- * @library \/tools\/lib \/tools\/javac\/lib ..\/lib_legacy\n- * @build toolbox.ToolBox InMemoryFileManager TestResult TestBase\n- * @build SyntheticTestDriver_legacy ExpectedClass ExpectedClasses\n+ * @library \/tools\/lib \/tools\/javac\/lib ..\/lib\n+ * @build toolbox.ToolBox InMemoryFileManager\n+ *        ExpectedClass ExpectedClasses\n+ * @compile --enable-preview --source ${jdk.version} --target ${jdk.version}\n+ *          SyntheticTestDriver.java\n+ *          ..\/lib\/TestResult.java ..\/lib\/TestBase.java\n@@ -37,1 +39,1 @@\n- * @run main SyntheticTestDriver_legacy BridgeMethodsForLambdaTargetRelease14Test\n+ * @run main\/othervm --enable-preview SyntheticTestDriver BridgeMethodsForLambdaTargetRelease14Test\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/BridgeMethodsForLambdaTargetRelease14Test.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.regex.*;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import com.sun.tools.classfile.*;\n-\n-\/**\n- * The tests work as follows. Firstly, it looks through the test cases\n- * and extracts the appropriate compiled classes. Each test case contains\n- * a set of expected classes, methods and fields. Those class members must not have\n- * the Synthetic attribute, while other found classes, methods and fields must have\n- * the Synthetic attribute if they are not in the set of expected class members.\n- *\n- * Each test executes SyntheticTestDriver specifying the name of test cases and\n- * the number of expected synthetic classes. Each test class is annotated by\n- * annotations which contains non-synthetic class members.\n- *\n- * See the appropriate class for more information about a test case.\n- *\/\n-public class SyntheticTestDriver_legacy extends TestResult {\n-\n-    private static final String ACC_SYNTHETIC = \"ACC_SYNTHETIC\";\n-\n-    private final String testCaseName;\n-    private final Map<String, ClassFile> classes;\n-    private final Map<String, ExpectedClass> expectedClasses;\n-\n-    public static void main(String[] args)\n-            throws TestFailedException, ConstantPoolException, IOException, ClassNotFoundException {\n-        if (args.length != 1 && args.length != 2) {\n-            throw new IllegalArgumentException(\"Usage: SyntheticTestDriver <class-name> [<number-of-synthetic-classes>]\");\n-        }\n-        int numberOfSyntheticClasses = args.length == 1 ? 0 : Integer.parseInt(args[1]);\n-        new SyntheticTestDriver_legacy(args[0]).test(numberOfSyntheticClasses);\n-    }\n-\n-    public SyntheticTestDriver_legacy(String testCaseName) throws IOException, ConstantPoolException, ClassNotFoundException {\n-        Class<?> clazz = Class.forName(testCaseName);\n-        this.testCaseName = testCaseName;\n-        this.expectedClasses = Stream.of(clazz.getAnnotationsByType(ExpectedClass.class))\n-                .collect(Collectors.toMap(ExpectedClass::className, Function.identity()));\n-        this.classes = new HashMap<>();\n-        Path classDir = getClassDir().toPath();\n-        Pattern filePattern = Pattern.compile(Pattern.quote(testCaseName.replace('.', File.separatorChar)) + \".*\\\\.class\");\n-        List<Path> paths = Files.walk(classDir)\n-                .map(p -> classDir.relativize(p.toAbsolutePath()))\n-                .filter(p -> filePattern.matcher(p.toString()).matches())\n-                .collect(Collectors.toList());\n-        for (Path path : paths) {\n-            String className = path.toString().replace(\".class\", \"\").replace(File.separatorChar, '.');\n-            classes.put(className, readClassFile(classDir.resolve(path).toFile()));\n-        }\n-        if (classes.isEmpty()) {\n-            throw new RuntimeException(\"Classes have not been found.\");\n-        }\n-        boolean success = classes.entrySet().stream()\n-                .allMatch(e -> e.getKey().startsWith(testCaseName));\n-        if (!success) {\n-            classes.forEach((className, $) -> printf(\"Found class: %s\\n\", className));\n-            throw new RuntimeException(\"Found classes are not from the test case : \" + testCaseName);\n-        }\n-    }\n-\n-    private String getMethodName(ClassFile classFile, Method method)\n-            throws ConstantPoolException, Descriptor.InvalidDescriptor {\n-        String methodName = method.getName(classFile.constant_pool);\n-        String parameters = method.descriptor.getParameterTypes(classFile.constant_pool);\n-        return methodName + parameters;\n-    }\n-\n-    public void test(int expectedNumberOfSyntheticClasses) throws TestFailedException {\n-        try {\n-            addTestCase(testCaseName);\n-            Set<String> foundClasses = new HashSet<>();\n-\n-            int numberOfSyntheticClasses = 0;\n-            for (Map.Entry<String, ClassFile> entry : classes.entrySet()) {\n-                String className = entry.getKey();\n-                ClassFile classFile = entry.getValue();\n-                foundClasses.add(className);\n-                if (testAttribute(\n-                        classFile,\n-                        () -> (Synthetic_attribute) classFile.getAttribute(Attribute.Synthetic),\n-                        classFile.access_flags::getClassFlags,\n-                        expectedClasses.keySet(),\n-                        className,\n-                        \"Testing class \" + className)) {\n-                    ++numberOfSyntheticClasses;\n-                }\n-                ExpectedClass expectedClass = expectedClasses.get(className);\n-                Set<String> expectedMethods = expectedClass != null\n-                        ? toSet(expectedClass.expectedMethods())\n-                        : new HashSet<>();\n-                int numberOfSyntheticMethods = 0;\n-                Set<String> foundMethods = new HashSet<>();\n-                for (Method method : classFile.methods) {\n-                    String methodName = getMethodName(classFile, method);\n-                    foundMethods.add(methodName);\n-                    if (testAttribute(\n-                            classFile,\n-                            () -> (Synthetic_attribute) method.attributes.get(Attribute.Synthetic),\n-                            method.access_flags::getMethodFlags,\n-                            expectedMethods,\n-                            methodName,\n-                            \"Testing method \" + methodName + \" in class \"\n-                                    + className)) {\n-                        ++numberOfSyntheticMethods;\n-                    }\n-                }\n-                checkContains(foundMethods, expectedMethods,\n-                        \"Checking that all methods of class \" + className\n-                                + \" without Synthetic attribute have been found\");\n-                checkEquals(numberOfSyntheticMethods,\n-                        expectedClass == null ? 0 : expectedClass.expectedNumberOfSyntheticMethods(),\n-                        \"Checking number of synthetic methods in class: \" + className);\n-\n-                Set<String> expectedFields = expectedClass != null\n-                        ? toSet(expectedClass.expectedFields())\n-                        : new HashSet<>();\n-                int numberOfSyntheticFields = 0;\n-                Set<String> foundFields = new HashSet<>();\n-                for (Field field : classFile.fields) {\n-                    String fieldName = field.getName(classFile.constant_pool);\n-                    foundFields.add(fieldName);\n-                    if (testAttribute(\n-                            classFile,\n-                            () -> (Synthetic_attribute) field.attributes.get(Attribute.Synthetic),\n-                            field.access_flags::getFieldFlags,\n-                            expectedFields,\n-                            fieldName,\n-                            \"Testing field \" + fieldName + \" in class \"\n-                                    + className)) {\n-                        ++numberOfSyntheticFields;\n-                    }\n-                }\n-                checkContains(foundFields, expectedFields,\n-                        \"Checking that all fields of class \" + className\n-                                + \" without Synthetic attribute have been found\");\n-                checkEquals(numberOfSyntheticFields,\n-                        expectedClass == null ? 0 : expectedClass.expectedNumberOfSyntheticFields(),\n-                        \"Checking number of synthetic fields in class: \" + className);\n-            }\n-            checkContains(foundClasses, expectedClasses.keySet(),\n-                    \"Checking that all classes have been found\");\n-            checkEquals(numberOfSyntheticClasses, expectedNumberOfSyntheticClasses,\n-                    \"Checking number of synthetic classes\");\n-        } catch (Exception e) {\n-            addFailure(e);\n-        } finally {\n-            checkStatus();\n-        }\n-    }\n-\n-    private boolean testAttribute(ClassFile classFile,\n-                               Supplier<Synthetic_attribute> getSyntheticAttribute,\n-                               Supplier<Set<String>> getAccessFlags,\n-                               Set<String> expectedMembers, String memberName,\n-                               String info) throws ConstantPoolException {\n-        echo(info);\n-        String className = classFile.getName();\n-        Synthetic_attribute attr = getSyntheticAttribute.get();\n-        Set<String> flags = getAccessFlags.get();\n-        if (expectedMembers.contains(memberName)) {\n-            checkNull(attr, \"Member must not have synthetic attribute : \"\n-                    + memberName);\n-            checkFalse(flags.contains(ACC_SYNTHETIC),\n-                    \"Member must not have synthetic flag : \" + memberName\n-                            + \" in class : \" + className);\n-            return false;\n-        } else {\n-            return checkNull(attr, \"Synthetic attribute should not be generated\")\n-                    && checkTrue(flags.contains(ACC_SYNTHETIC), \"Member must have synthetic flag : \"\n-                                + memberName + \" in class : \" + className);\n-        }\n-    }\n-\n-    private Set<String> toSet(String[] strings) {\n-        HashSet<String> set = new HashSet<>();\n-        Collections.addAll(set, strings);\n-        return set;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/SyntheticTestDriver_legacy.java","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -1,284 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-import javax.tools.DiagnosticCollector;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileObject;\n-import javax.tools.ToolProvider;\n-\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-\n-import toolbox.JavacTask;\n-import toolbox.ToolBox;\n-\n-\/**\n- * Base class for class file attribute tests.\n- * Contains methods for compiling generated sources in memory,\n- * for reading files from disk and a lot of assert* methods.\n- *\/\n-public class TestBase {\n-\n-    public static final String LINE_SEPARATOR = System.lineSeparator();\n-    public static final boolean isDumpOfSourceEnabled = Boolean.getBoolean(\"dump.src\");\n-\n-    private <S> InMemoryFileManager compile(\n-            List<String> options,\n-            Function<S, ? extends JavaFileObject> src2JavaFileObject,\n-            List<S> sources)\n-            throws IOException, CompilationException {\n-\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        List<? extends JavaFileObject> src = sources.stream()\n-                .map(src2JavaFileObject)\n-                .collect(Collectors.toList());\n-\n-        DiagnosticCollector<? super JavaFileObject> dc = new DiagnosticCollector<>();\n-        try (InMemoryFileManager fileManager\n-                     = new InMemoryFileManager(compiler.getStandardFileManager(null, null, null))) {\n-            JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, dc, options, null, src);\n-            boolean success = task.call();\n-            if (!success) {\n-                String errorMessage = dc.getDiagnostics().stream()\n-                        .map(Object::toString)\n-                        .collect(Collectors.joining(\"\\n\"));\n-                throw new CompilationException(\"Compilation Error\\n\\n\" + errorMessage);\n-            }\n-            return fileManager;\n-        }\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param sources to compile\n-     * @return in-memory file manager which contains class files and class loader\n-     *\/\n-    public InMemoryFileManager compile(String... sources)\n-            throws IOException, CompilationException {\n-        return compile(Collections.emptyList(), sources);\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param options compiler options.\n-     * @param sources sources to compile.\n-     * @return in-memory file manager which contains class files and class loader.\n-     *\/\n-    public InMemoryFileManager compile(List<String> options, String... sources)\n-            throws IOException, CompilationException {\n-        return compile(options, ToolBox.JavaSource::new, Arrays.asList(sources));\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param sources sources[i][0] - name of file, sources[i][1] - sources.\n-     * @return in-memory file manager which contains class files and class loader.\n-     *\/\n-    public InMemoryFileManager compile(String[]... sources) throws IOException,\n-            CompilationException {\n-        return compile(Collections.emptyList(), sources);\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param options compiler options\n-     * @param sources sources[i][0] - name of file, sources[i][1] - sources.\n-     * @return in-memory file manager which contains class files and class loader.\n-     *\/\n-    public InMemoryFileManager compile(List<String> options, String[]... sources)\n-            throws IOException, CompilationException {\n-        return compile(options, src -> new ToolBox.JavaSource(src[0], src[1]), Arrays.asList(sources));\n-    }\n-\n-    \/**\n-     * Returns class file that is read from {@code is}.\n-     *\n-     * @param is an input stream\n-     * @return class file that is read from {@code is}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(InputStream is) throws IOException, ConstantPoolException {\n-        return ClassFile.read(is);\n-    }\n-\n-    \/**\n-     * Returns class file that is read from {@code fileObject}.\n-     *\n-     * @param fileObject a file object\n-     * @return class file that is read from {@code fileObject}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(JavaFileObject fileObject) throws IOException, ConstantPoolException {\n-        try (InputStream is = fileObject.openInputStream()) {\n-            return readClassFile(is);\n-        }\n-    }\n-\n-    \/**\n-     * Returns class file that corresponds to {@code clazz}.\n-     *\n-     * @param clazz a class\n-     * @return class file that is read from {@code clazz}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(Class<?> clazz) throws IOException, ConstantPoolException {\n-        return readClassFile(getClassFile(clazz));\n-    }\n-\n-    \/**\n-     * Returns class file that corresponds to {@code className}.\n-     *\n-     * @param className a class name\n-     * @return class file that is read from {@code className}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(String className) throws IOException, ConstantPoolException {\n-        return readClassFile(getClassFile(className + \".class\"));\n-    }\n-\n-    \/**\n-     * Returns class file that is read from {@code file}.\n-     *\n-     * @param file a file\n-     * @return class file that is read from {@code file}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(File file) throws IOException, ConstantPoolException {\n-        try (InputStream is = new FileInputStream(file)) {\n-            return readClassFile(is);\n-        }\n-    }\n-\n-    public void assertEquals(Object actual, Object expected, String message) {\n-        if (!Objects.equals(actual, expected))\n-            throw new AssertionFailedException(String.format(\"%s%nGot: %s, Expected: %s\",\n-                    message, actual, expected));\n-    }\n-\n-    public void assertNull(Object actual, String message) {\n-        assertEquals(actual, null, message);\n-    }\n-\n-    public void assertNotNull(Object actual, String message) {\n-        if (Objects.isNull(actual)) {\n-            throw new AssertionFailedException(message + \" : Expected not null value\");\n-        }\n-    }\n-\n-    public void assertTrue(boolean actual, String message) {\n-        assertEquals(actual, true, message);\n-    }\n-\n-    public void assertFalse(boolean actual, String message) {\n-        assertEquals(actual, false, message);\n-    }\n-\n-    public void assertContains(Set<?> found, Set<?> expected, String message) {\n-        Set<?> copy = new HashSet<>(expected);\n-        copy.removeAll(found);\n-        assertTrue(found.containsAll(expected), message + \" : \" + copy);\n-    }\n-\n-    public void writeToFile(Path path, String source) throws IOException {\n-        try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n-            writer.write(source);\n-        }\n-    }\n-\n-    public void writeToFileIfEnabled(Path path, String source) throws IOException {\n-        if (isDumpOfSourceEnabled) {\n-            writeToFile(path, source);\n-        } else {\n-            System.err.println(\"Source dumping disabled. To enable, run the test with '-Ddump.src=true'\");\n-        }\n-    }\n-\n-    public File getSourceDir() {\n-        return new File(System.getProperty(\"test.src\", \".\"));\n-    }\n-\n-    public File getClassDir() {\n-        return new File(System.getProperty(\"test.classes\", TestBase.class.getResource(\".\").getPath()));\n-    }\n-\n-    public File getSourceFile(String fileName) {\n-        return new File(getSourceDir(), fileName);\n-    }\n-\n-    public File getClassFile(String fileName) {\n-        return new File(getClassDir(), fileName);\n-    }\n-\n-    public File getClassFile(Class clazz) {\n-        return getClassFile(clazz.getName().replace(\".\", \"\/\") + \".class\");\n-    }\n-\n-    \/**\n-     * Prints message to standard error. New lines are converted to system dependent NL.\n-     *\n-     * @param message string to print.\n-     *\/\n-    public void echo(String message) {\n-        printf(message + \"\\n\");\n-    }\n-\n-    \/**\n-     * Substitutes args in template and prints result to standard error.\n-     * New lines are converted to system dependent NL.\n-     *\n-     * @param template template in standard String.format(...) format.\n-     * @param args arguments to substitute in template.\n-     *\/\n-    public void printf(String template, Object... args) {\n-        System.err.printf(String.format(template, args).replace(\"\\n\", LINE_SEPARATOR));\n-    }\n-\n-    public static class CompilationException extends Exception {\n-\n-        public CompilationException(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    public static class AssertionFailedException extends RuntimeException {\n-        public AssertionFailedException(String message) {\n-            super(message);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/lib_legacy\/TestBase.java","additions":0,"deletions":284,"binary":false,"changes":284,"status":"deleted"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.*;\n-\n-\/**\n- * This class accumulates test results. Test results can be checked with method {@code checkStatus}.\n- *\/\n-public class TestResult extends TestBase {\n-\n-    private final List<Info> testCasesInfo;\n-\n-    public TestResult() {\n-        testCasesInfo = new ArrayList<>();\n-    }\n-\n-    \/**\n-     * Adds new test case info.\n-     *\n-     * @param info the information about test case\n-     *\/\n-    public void addTestCase(String info) {\n-        System.err.println(\"Test case: \" + info);\n-        testCasesInfo.add(new Info(info));\n-    }\n-\n-    public boolean checkEquals(Object actual, Object expected, String message) {\n-        echo(\"Testing : \" + message);\n-        if (!Objects.equals(actual, expected)) {\n-            getLastTestCase().addAssert(String.format(\"%s\\n\" +\n-                    \"Expected: %s,\\n\" +\n-                    \"     Got: %s\", message, expected, actual));\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    public boolean checkNull(Object actual, String message) {\n-        return checkEquals(actual, null, message);\n-    }\n-\n-    public boolean checkNotNull(Object actual, String message) {\n-        echo(\"Testing : \" + message);\n-        if (Objects.isNull(actual)) {\n-            getLastTestCase().addAssert(message + \" : Expected not null value\");\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    public boolean checkFalse(boolean actual, String message) {\n-        return checkEquals(actual, false, message);\n-    }\n-\n-    public boolean checkTrue(boolean actual, String message) {\n-        return checkEquals(actual, true, message);\n-    }\n-\n-    public boolean checkContains(Collection<?> found, Collection<?> expected, String message) {\n-        Set<?> copy = new HashSet<>(expected);\n-        copy.removeAll(found);\n-        if (!found.containsAll(expected)) {\n-            return checkTrue(false, message + \" FAIL : not found elements : \" + copy + \"\\n\" +\n-                    \"Actual: \" + found);\n-        } else {\n-            return checkTrue(true, message + \" PASS : all elements found\");\n-        }\n-    }\n-\n-    public void addFailure(Throwable th) {\n-        if (testCasesInfo.isEmpty()) {\n-            testCasesInfo.add(new Info(\"Dummy info\"));\n-        }\n-        getLastTestCase().addFailure(th);\n-    }\n-\n-    private Info getLastTestCase() {\n-        if (testCasesInfo.isEmpty()) {\n-            throw new IllegalStateException(\"Test case should be created\");\n-        }\n-        return testCasesInfo.get(testCasesInfo.size() - 1);\n-    }\n-\n-    \/**\n-     * Throws {@code TestFailedException} if one of the checks are failed\n-     * or an exception occurs. Prints error message of failed test cases.\n-     *\n-     * @throws TestFailedException if one of the checks are failed\n-     *                             or an exception occurs\n-     *\/\n-    public void checkStatus() throws TestFailedException {\n-        int passed = 0;\n-        int failed = 0;\n-        for (Info testCaseInfo : testCasesInfo) {\n-            if (testCaseInfo.isFailed()) {\n-                String info = testCaseInfo.info().replace(\"\\n\", LINE_SEPARATOR);\n-                String errorMessage = testCaseInfo.getMessage().replace(\"\\n\", LINE_SEPARATOR);\n-                System.err.printf(\"Failure in test case:%n%s%n%s%n\", info, errorMessage);\n-                ++failed;\n-            } else {\n-                ++passed;\n-            }\n-        }\n-        System.err.printf(\"Test cases: passed: %d, failed: %d, total: %d.%n\", passed, failed, passed + failed);\n-        if (failed > 0) {\n-            throw new TestFailedException(\"Test failed\");\n-        }\n-        if (passed + failed == 0) {\n-            throw new TestFailedException(\"Test cases were not found\");\n-        }\n-    }\n-\n-    @Override\n-    public void printf(String template, Object... args) {\n-        getLastTestCase().printf(template, args);\n-    }\n-\n-    private static class Info {\n-\n-        private final String info;\n-        private final StringWriter writer;\n-        private boolean isFailed;\n-\n-        private Info(String info) {\n-            this.info = info;\n-            writer = new StringWriter();\n-        }\n-\n-        public String info() {\n-            return info;\n-        }\n-\n-        public boolean isFailed() {\n-            return isFailed;\n-        }\n-\n-        public void printf(String template, Object... args) {\n-            writer.write(String.format(template, args));\n-        }\n-\n-        public void addFailure(Throwable th) {\n-            isFailed = true;\n-            printf(\"[ERROR] : %s\\n\", getStackTrace(th));\n-        }\n-\n-        public void addAssert(String e) {\n-            isFailed = true;\n-            printf(\"[ASSERT] : %s\\n\", e);\n-        }\n-\n-        public String getMessage() {\n-            return writer.toString();\n-        }\n-\n-        public String getStackTrace(Throwable throwable) {\n-            StringWriter stringWriter = new StringWriter();\n-            try (PrintWriter printWriter = new PrintWriter(stringWriter)) {\n-                throwable.printStackTrace(printWriter);\n-            }\n-            return stringWriter.toString();\n-        }\n-    }\n-\n-    public static class TestFailedException extends Exception {\n-        public TestFailedException(String message) {\n-            super(message);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/lib_legacy\/TestResult.java","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -source 16 -target 16 CheckACC_STRICTFlagOnDefaultMethodTest.java\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n@@ -33,0 +33,7 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.nio.file.Path;\n@@ -35,1 +42,0 @@\n-import java.io.File;\n@@ -38,8 +44,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Method;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_STRICT;\n-\n@@ -52,0 +50,6 @@\n+    private static final String SOURCE = \"\"\"\n+            strictfp interface StrictfpInterface {\n+                default void default_interface_method() {}\n+                static void static_interface_method() {}\n+            }\n+            \"\"\";\n@@ -56,1 +60,1 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+            throws IOException {\n@@ -61,5 +65,8 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n-        String testClasses = System.getProperty(\"test.classes\");\n-        check(testClasses,\n-                \"CheckACC_STRICTFlagOnDefaultMethodTest$StrictfpInterface.class\");\n-        if (errors.size() > 0) {\n+            throws IOException {\n+        Path src = Path.of(\"src\");\n+        Path out = Path.of(\"out\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(src, SOURCE);\n+        CompilerUtils.compile(src, out, \"--release\", \"16\");\n+        check(out, \"StrictfpInterface.class\");\n+        if (!errors.isEmpty()) {\n@@ -73,5 +80,1 @@\n-    void check(String dir, String... fileNames)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n+    void check(Path dir, String... fileNames) throws IOException {\n@@ -79,1 +82,1 @@\n-            ClassFile classFileToCheck = ClassFile.read(new File(dir, fileName));\n+            ClassModel classFileToCheck = ClassFile.of().parse(dir.resolve(fileName));\n@@ -81,2 +84,2 @@\n-            for (Method method : classFileToCheck.methods) {\n-                if ((method.access_flags.flags & ACC_STRICT) == 0) {\n+            for (MethodModel method : classFileToCheck.methods()) {\n+                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n@@ -84,2 +87,2 @@\n-                            method.getName(classFileToCheck.constant_pool),\n-                            classFileToCheck.getName()));\n+                            method.methodName().stringValue(),\n+                            classFileToCheck.thisClass().asInternalName()));\n@@ -90,21 +93,0 @@\n-\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    void check(String dir, String... fileNames) throws IOException {\n-\/\/        for (String fileName : fileNames) {\n-\/\/            ClassModel classFileToCheck = ClassFile.of().parse(new File(dir, fileName).toPath());\n-\/\/\n-\/\/            for (MethodModel method : classFileToCheck.methods()) {\n-\/\/                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n-\/\/                    errors.add(String.format(offendingMethodErrorMessage,\n-\/\/                            method.methodName().stringValue(),\n-\/\/                            classFileToCheck.thisClass().asInternalName()));\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/    }\n-\n-    strictfp interface StrictfpInterface {\n-        default void default_interface_method() {}\n-        static void static_interface_method() {}\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/CheckACC_STRICTFlagOnDefaultMethodTest.java","additions":31,"deletions":49,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -source 16 -target 16 LambdaTestStrictFPFlag.java\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n@@ -33,3 +33,7 @@\n-import java.io.*;\n-import java.net.URL;\n-import com.sun.tools.classfile.*;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.nio.file.Path;\n@@ -38,0 +42,12 @@\n+    private static final String SOURCE = \"\"\"\n+            class Test {\n+                strictfp void test() {\n+                    Face itf = () -> { };\n+                }\n+            }\n+\n+            interface Face {\n+                void m();\n+            }\n+            \"\"\";\n+\n@@ -43,2 +59,8 @@\n-        ClassFile cf = getClassFile(\"LambdaTestStrictFPFlag$Test.class\");\n-        ConstantPool cp = cf.constant_pool;\n+        Path src = Path.of(\"src\");\n+        Path out = Path.of(\"out\");\n+\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(src, SOURCE);\n+        CompilerUtils.compile(src, out, \"--release\", \"16\");\n+\n+        ClassModel cm = ClassFile.of().parse(out.resolve(\"Test.class\"));\n@@ -46,3 +68,3 @@\n-        for (Method meth: cf.methods) {\n-            if (meth.getName(cp).startsWith(\"lambda$\")) {\n-                if ((meth.access_flags.flags & AccessFlags.ACC_STRICT) == 0) {\n+        for (MethodModel meth: cm.methods()) {\n+            if (meth.methodName().stringValue().startsWith(\"lambda$\")) {\n+                if ((meth.flags().flagsMask() & ClassFile.ACC_STRICT) == 0){\n@@ -58,37 +80,0 @@\n-\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    void run() throws Exception {\n-\/\/        ClassModel cm = getClassFile(\"LambdaTestStrictFPFlag$Test.class\");\n-\/\/        boolean found = false;\n-\/\/        for (MethodModel meth: cm.methods()) {\n-\/\/            if (meth.methodName().stringValue().startsWith(\"lambda$\")) {\n-\/\/                if ((meth.flags().flagsMask() & ClassFile.ACC_STRICT) == 0){\n-\/\/                    throw new Exception(\"strict flag missing from lambda\");\n-\/\/                }\n-\/\/                found = true;\n-\/\/            }\n-\/\/        }\n-\/\/        if (!found) {\n-\/\/            throw new Exception(\"did not find lambda method\");\n-\/\/        }\n-\/\/    }\n-\n-    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n-        URL url = getClass().getResource(name);\n-        InputStream in = url.openStream();\n-        try {\n-            return ClassFile.read(in);\n-        } finally {\n-            in.close();\n-        }\n-    }\n-\n-    class Test {\n-        strictfp void test() {\n-            Face itf = () -> { };\n-        }\n-    }\n-\n-    interface Face {\n-        void m();\n-    }\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaTestStrictFPFlag.java","additions":33,"deletions":48,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.javap\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n@@ -33,1 +32,0 @@\n-import java.util.*;\n","filename":"test\/langtools\/tools\/javap\/T6866657.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.javap\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n@@ -32,2 +31,0 @@\n-import java.io.*;\n-import java.util.*;\n","filename":"test\/langtools\/tools\/javap\/T7186925.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n@@ -107,1 +106,1 @@\n-             new String[] {\"g.G\", \"sun.security.x509.X509CertInfo\", \"com.sun.tools.classfile.ClassFile\",\n+             new String[] {\"g.G\", \"sun.security.x509.X509CertInfo\", \"com.sun.tools.jdeps.Analyzer\",\n@@ -113,1 +112,1 @@\n-             new String[] {\"sun.security.x509.X509CertInfo\", \"com.sun.tools.classfile.ClassFile\"},\n+             new String[] {\"sun.security.x509.X509CertInfo\", \"com.sun.tools.jdeps.Analyzer\"},\n@@ -117,1 +116,1 @@\n-             new String[] {\"com.sun.tools.classfile.ClassFile\",\n+             new String[] {\"com.sun.tools.jdeps.Analyzer\",\n","filename":"test\/langtools\/tools\/jdeps\/APIDeps.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-    public com.sun.tools.classfile.ClassFile cf;     \/\/ not exported\n+    public com.sun.tools.jdeps.Analyzer analyzer;     \/\/ not exported\n","filename":"test\/langtools\/tools\/jdeps\/m\/Gee.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}