{"files":[{"patch":"@@ -1549,1 +1549,1 @@\n-  return TypeLong::make(MIN2(r0->_lo, r1->_lo), MIN2(r0->_hi, r1->_hi), MIN2(r0->_widen, r1->_widen));\n+  return TypeLong::make(MIN2(r0->_lo, r1->_lo), MIN2(r0->_hi, r1->_hi), MAX2(r0->_widen, r1->_widen));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343944\n+ * @summary Test that _widen is set correctly in MinL::add_ring() to prevent an endless widening in CCP.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.ccp.TestWrongMinLWiden::*\n+ *                   compiler.ccp.TestWrongMinLWiden\n+ *\/\n+\n+package compiler.ccp;\n+\n+public class TestWrongMinLWiden {\n+    static long lFld;\n+    static short sFld;\n+\n+    public static void main(String[] strArr) {\n+        Math.min(3,3); \/\/ Make sure Math class is loaded.\n+        test();\n+        testWithMathMin();\n+    }\n+\n+\n+    static long test() {\n+        long x = 50398;\n+        for (int i = 1; i < 100; i++) {\n+            long xMinus1 = x - 1; \/\/ x is a phi with type #long\n+            \/\/ Long comparison:\n+            \/\/     ConvI2L(sFld) <= xMinus1\n+            \/\/ First converted to\n+            \/\/     CMoveL(sFld <= xMinus1, sFld, xMinus1)\n+            \/\/     CMoveL(ConvI2L(sFld) <= long_phi, ConvI2L(sFld), long_phi)\n+            \/\/ with types\n+            \/\/     CMoveL(#short <= #long, #short, #long)\n+            \/\/ And then converted in CMoveNode::Ideal() to\n+            \/\/     MinL(sFld, xMinus1)\n+            \/\/     MinL(ConvI2L(sFld), long_phi)\n+            \/\/\n+            \/\/ We wrongly set the _widen of the new type for MinL in MinL::add_ring() to the minimum of both types which\n+            \/\/ is always 0 because the _widen of sFld is 0. As a result, we will endlessly widen the involved types\n+            \/\/ because the new type for MinL keeps resetting _widen to 0.\n+            \/\/ Instead, we should choose the maximum of both _widen fields for the new type for MinL which will then\n+            \/\/ select the _widen of xMinus1 which will grow each time we set a new type for the long_phi. Eventually,\n+            \/\/ we will saturate the type of long_phi to min_long to avoid an endless widening.\n+            x = sFld <= xMinus1 ? sFld : xMinus1;\n+        }\n+        return x;\n+    }\n+\n+    \/\/ Same as test() but with Math.min() which internally uses x <= y ? x : y which allows the CMoveL pattern to be\n+    \/\/ replaced with MinL.\n+    static long testWithMathMin() {\n+        long x = 50398;\n+        for (int i = 1; i < 100; i++) {\n+            x = Math.min(sFld, x - 1);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/hotspot\/test\/hotspot\/jtreg\/compiler\/ccp\/TestWrongMinLWiden.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}