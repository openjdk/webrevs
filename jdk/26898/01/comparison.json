{"files":[{"patch":"@@ -94,0 +94,4 @@\n+\n+  template <typename Function, typename... Args>\n+  bool next_if(T* elem, Function predicate, Args&&... args);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,0 +164,14 @@\n+template <typename T, bool Parallel>\n+template <typename Function, typename... Args>\n+inline bool ZArrayIteratorImpl<T, Parallel>::next_if(T* elem, Function predicate, Args&&... args) {\n+  size_t index;\n+  while (next_index(&index)) {\n+    if (predicate(index_to_elem(index), args...)) {\n+      *elem = index_to_elem(index);\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+  const uint32_t         _partition_id;\n@@ -111,0 +112,2 @@\n+  uint32_t partition_id() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    _partition_id(page->single_partition_id()),\n@@ -105,0 +106,4 @@\n+inline uint32_t ZForwarding::partition_id() const {\n+  return _partition_id;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -253,2 +253,2 @@\n-ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n-  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age);\n+ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n+  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age, preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -61,3 +62,5 @@\n-  \/\/ Calculate headroom needed to avoid in-place relocation. Each worker will try\n-  \/\/ to allocate a small page, and all workers will share a single medium page.\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  \/\/ Calculate headroom needed to avoid in-place relocation. For each NUMA node,\n+  \/\/ each worker will try to allocate a small page, and all workers will share a\n+  \/\/ single medium page.\n+  const size_t per_numa_headroom = (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  return per_numa_headroom * ZNUMA::count();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, _age, ZNUMA::id());\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  assert(!is_multi_partition(), \"Don't fetch single partition id if page is multi-partition\");\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age)\n+  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition)\n@@ -431,1 +431,1 @@\n-      _initiating_numa_id(ZNUMA::id()),\n+      _initiating_numa_id(preferred_partition),\n@@ -436,1 +436,3 @@\n-      _stall_result() {}\n+      _stall_result() {\n+    assert(_initiating_numa_id < ZNUMA::count(), \"Initiating NUMA id out-of-bounds (0 <= %d < %d)\", _initiating_numa_id, ZNUMA::count());\n+  }\n@@ -1400,1 +1402,1 @@\n-ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n+ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n@@ -1403,1 +1405,1 @@\n-  ZPageAllocation allocation(type, size, flags, age);\n+  ZPageAllocation allocation(type, size, flags, age, preferred_partition);\n@@ -1563,1 +1565,1 @@\n-  if (!is_multi_partition_enabled() || sum_available() < allocation->size()) {\n+  if (!is_multi_partition_allowed(allocation)) {\n@@ -2194,0 +2196,6 @@\n+bool ZPageAllocator::is_multi_partition_allowed(const ZPageAllocation* allocation) const {\n+  return allocation->type() == ZPageType::large &&\n+         is_multi_partition_enabled() &&\n+         sum_available() >= allocation->size();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  bool is_multi_partition_allowed(const ZPageAllocation* allocation) const;\n@@ -266,1 +267,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"gc\/z\/zValue.inline.hpp\"\n@@ -307,0 +309,25 @@\n+ZRelocationTargets::ZRelocationTargets()\n+  : _targets() {}\n+\n+ZPage* ZRelocationTargets::get(uint32_t partition_id, ZPageAge age) {\n+  return _targets.get(partition_id)[untype(age) - 1];\n+}\n+\n+void ZRelocationTargets::set(uint32_t partition_id, ZPageAge age, ZPage* page) {\n+  _targets.get(partition_id)[untype(age) - 1] = page;\n+}\n+\n+template <typename Function>\n+void ZRelocationTargets::apply_and_clear_targets(Function function) {\n+  ZPerNUMAIterator<TargetArray> iter(&_targets);\n+  for (TargetArray* targets; iter.next(&targets);) {\n+    for (size_t i = 0; i < ZNumRelocationAges; i++) {\n+      \/\/ Apply function\n+      function((*targets)[i]);\n+\n+      \/\/ Clear target\n+      (*targets)[i] = nullptr;\n+    }\n+  }\n+}\n+\n@@ -309,1 +336,5 @@\n-    _queue() {}\n+    _queue(),\n+    _iters(),\n+    _small_targets(),\n+    _medium_targets(),\n+    _shared_medium_targets() {}\n@@ -397,0 +428,1 @@\n+  const uint32_t preferred_partition = forwarding->partition_id();\n@@ -402,1 +434,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, age, preferred_partition);\n@@ -445,1 +477,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -470,5 +502,5 @@\n-  ZGeneration* const _generation;\n-  ZConditionLock     _lock;\n-  ZPage*             _shared[ZNumRelocationAges];\n-  bool               _in_place;\n-  volatile size_t    _in_place_count;\n+  ZGeneration* const  _generation;\n+  ZConditionLock      _lock;\n+  ZRelocationTargets* _shared_targets;\n+  bool                _in_place;\n+  volatile size_t     _in_place_count;\n@@ -477,1 +509,1 @@\n-  ZRelocateMediumAllocator(ZGeneration* generation)\n+  ZRelocateMediumAllocator(ZGeneration* generation, ZRelocationTargets* shared_targets)\n@@ -480,1 +512,1 @@\n-      _shared(),\n+      _shared_targets(shared_targets),\n@@ -485,3 +517,3 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      if (_shared[i] != nullptr) {\n-        retire_target_page(_generation, _shared[i]);\n+    _shared_targets->apply_and_clear_targets([&](ZPage* page) {\n+      if (page != nullptr) {\n+        retire_target_page(_generation, page);\n@@ -489,9 +521,1 @@\n-    }\n-  }\n-\n-  ZPage* shared(ZPageAge age) {\n-    return _shared[untype(age - 1)];\n-  }\n-\n-  void set_shared(ZPageAge age, ZPage* page) {\n-    _shared[untype(age - 1)] = page;\n+    });\n@@ -513,1 +537,2 @@\n-    if (shared(to_age) == target) {\n+    const uint32_t partition_id = forwarding->partition_id();\n+    if (_shared_targets->get(partition_id, to_age) == target) {\n@@ -515,1 +540,1 @@\n-      set_shared(to_age, to_page);\n+      _shared_targets->set(partition_id, to_age, to_page);\n@@ -527,1 +552,1 @@\n-    return shared(to_age);\n+    return _shared_targets->get(partition_id, to_age);\n@@ -530,1 +555,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -535,1 +560,1 @@\n-    assert(shared(age) == nullptr, \"Invalid state\");\n+    assert(_shared_targets->get(partition_id, age) == nullptr, \"Invalid state\");\n@@ -538,1 +563,1 @@\n-    set_shared(age, page);\n+    _shared_targets->set(partition_id, age, page);\n@@ -566,1 +591,1 @@\n-  ZPage*              _target[ZNumRelocationAges];\n+  ZRelocationTargets* _targets;\n@@ -572,9 +597,0 @@\n-\n-  ZPage* target(ZPageAge age) {\n-    return _target[untype(age - 1)];\n-  }\n-\n-  void set_target(ZPageAge age, ZPage* page) {\n-    _target[untype(age - 1)] = page;\n-  }\n-\n@@ -594,1 +610,1 @@\n-  zaddress try_relocate_object_inner(zaddress from_addr) {\n+  zaddress try_relocate_object_inner(zaddress from_addr, uint32_t partition_id) {\n@@ -598,1 +614,1 @@\n-    ZPage* const to_page = target(_forwarding->to_age());\n+    ZPage* const to_page = _targets->get(partition_id, _forwarding->to_age());\n@@ -809,2 +825,2 @@\n-  bool try_relocate_object(zaddress from_addr) {\n-    const zaddress to_addr = try_relocate_object_inner(from_addr);\n+  bool try_relocate_object(zaddress from_addr, uint32_t partition_id) {\n+    const zaddress to_addr = try_relocate_object_inner(from_addr, partition_id);\n@@ -891,7 +907,12 @@\n-    while (!try_relocate_object(addr)) {\n-      \/\/ Allocate a new target page, or if that fails, use the page being\n-      \/\/ relocated as the new target, which will cause it to be relocated\n-      \/\/ in-place.\n-      const ZPageAge to_age = _forwarding->to_age();\n-      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target(to_age));\n-      set_target(to_age, to_page);\n+    const ZPageAge to_age = _forwarding->to_age();\n+    const uint32_t partition_id = _forwarding->partition_id();\n+\n+    while (!try_relocate_object(addr, partition_id)) {\n+      \/\/ Failed to relocate object, try to allocate a new target page,\n+      \/\/ or if that fails, use the page being relocated as the new target,\n+      \/\/ which will cause it to be relocated in-place.\n+      ZPage* const target_page = _targets->get(partition_id, to_age);\n+      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target_page);\n+      _targets->set(partition_id, to_age, to_page);\n+\n+      \/\/ We got a new page, retry relocation\n@@ -906,1 +927,1 @@\n-      set_target(to_age, to_page);\n+      _targets->set(partition_id, to_age, to_page);\n@@ -911,1 +932,1 @@\n-  ZRelocateWork(Allocator* allocator, ZGeneration* generation)\n+  ZRelocateWork(Allocator* allocator, ZRelocationTargets* targets, ZGeneration* generation)\n@@ -914,1 +935,1 @@\n-      _target(),\n+      _targets(targets),\n@@ -920,3 +941,4 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      _allocator->free_target_page(_target[i]);\n-    }\n+    _targets->apply_and_clear_targets([&](ZPage* page) {\n+        _allocator->free_target_page(page);\n+    });\n+\n@@ -1015,2 +1037,3 @@\n-      ZPage* const target_page = target(_forwarding->to_age());\n-      _allocator->share_target_page(target_page);\n+      const uint32_t target_partition = _forwarding->partition_id();\n+      ZPage* const target_page = _targets->get(target_partition, _forwarding->to_age());\n+      _allocator->share_target_page(target_page, target_partition);\n@@ -1060,5 +1083,9 @@\n-  ZRelocationSetParallelIterator _iter;\n-  ZGeneration* const             _generation;\n-  ZRelocateQueue* const          _queue;\n-  ZRelocateSmallAllocator        _small_allocator;\n-  ZRelocateMediumAllocator       _medium_allocator;\n+  ZGeneration* const                        _generation;\n+  ZRelocateQueue* const                     _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator>* _iters;\n+  ZPerWorker<ZRelocationTargets>*           _small_targets;\n+  ZPerWorker<ZRelocationTargets>*           _medium_targets;\n+  ZRelocateSmallAllocator                   _small_allocator;\n+  ZRelocateMediumAllocator                  _medium_allocator;\n+  const size_t                              _total_forwardings;\n+  size_t                                    _numa_local_forwardings;\n@@ -1067,1 +1094,6 @@\n-  ZRelocateTask(ZRelocationSet* relocation_set, ZRelocateQueue* queue)\n+  ZRelocateTask(ZRelocationSet* relocation_set,\n+                ZRelocateQueue* queue,\n+                ZPerNUMA<ZRelocationSetParallelIterator>* iters,\n+                ZPerWorker<ZRelocationTargets>* small_targets,\n+                ZPerWorker<ZRelocationTargets>* medium_targets,\n+                ZRelocationTargets* shared_medium_targets)\n@@ -1069,1 +1101,0 @@\n-      _iter(relocation_set),\n@@ -1072,0 +1103,3 @@\n+      _iters(iters),\n+      _small_targets(small_targets),\n+      _medium_targets(medium_targets),\n@@ -1073,1 +1107,15 @@\n-      _medium_allocator(_generation) {}\n+      _medium_allocator(_generation, shared_medium_targets),\n+      _total_forwardings(relocation_set->_nforwardings),\n+      _numa_local_forwardings(0) {\n+\n+    for (uint32_t i = 0; i < ZNUMA::count(); i++) {\n+      ZRelocationSetParallelIterator* const iter = _iters->addr(i);\n+\n+      \/\/ Destruct iterator from previous GC-cycle, or the temporary\n+      \/\/ iterators if this is the first GC-cycle.\n+      iter->~ZRelocationSetParallelIterator();\n+\n+      \/\/ In-place construct the iterator with the current relocation set\n+      ::new (iter) ZRelocationSetParallelIterator(relocation_set);\n+    }\n+  }\n@@ -1080,0 +1128,5 @@\n+\n+    if (ZNUMA::is_enabled()) {\n+      log_debug(gc, reloc, numa)(\"Forwardings relocated NUMA-locally: %zu \/ %zu (%.0f%%)\",\n+                                 _numa_local_forwardings, _total_forwardings, percent_of(_numa_local_forwardings, _total_forwardings));\n+    }\n@@ -1083,2 +1136,4 @@\n-    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _generation);\n-    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _generation);\n+    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _small_targets->addr(), _generation);\n+    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _medium_targets->addr(), _generation);\n+    const uint32_t num_nodes = ZNUMA::count();\n+    uint32_t numa_local_forwardings_worker = 0;\n@@ -1110,0 +1165,4 @@\n+    const auto check_numa_local = [&](ZForwarding* forwarding, uint32_t numa_id) {\n+      return forwarding->partition_id() == numa_id;\n+    };\n+\n@@ -1112,0 +1171,6 @@\n+      const uint32_t start_node = ZNUMA::id();\n+      uint32_t current_node = start_node;\n+\n+      for (uint32_t i = 0; i < num_nodes; i++) {\n+        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n+          claim_and_do_forwarding(forwarding);\n@@ -1113,3 +1178,10 @@\n-      if (_iter.next(&forwarding)) {\n-        claim_and_do_forwarding(forwarding);\n-        return true;\n+          if (current_node == start_node) {\n+            \/\/ Track if this forwarding was relocated on the local NUMA node\n+            numa_local_forwardings_worker++;\n+          }\n+\n+          return true;\n+        }\n+\n+        \/\/ Check next node.\n+        current_node = (current_node + 1) % num_nodes;\n@@ -1141,0 +1213,4 @@\n+    if (ZNUMA::is_enabled()) {\n+      Atomic::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n+    }\n+\n@@ -1221,1 +1297,1 @@\n-    ZRelocateTask relocate_task(relocation_set, &_queue);\n+    ZRelocateTask relocate_task(relocation_set, &_queue, &_iters, &_small_targets, &_medium_targets, &_shared_medium_targets);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":147,"deletions":71,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zValue.hpp\"\n@@ -77,0 +78,16 @@\n+class ZRelocationTargets {\n+private:\n+  using TargetArray = ZPage*[ZNumRelocationAges];\n+\n+  ZPerNUMA<TargetArray> _targets;\n+\n+public:\n+  ZRelocationTargets();\n+\n+  ZPage* get(uint32_t partition_id, ZPageAge age);\n+  void set(uint32_t partition_id, ZPageAge age, ZPage* page);\n+\n+  template <typename Function>\n+  void apply_and_clear_targets(Function function);\n+};\n+\n@@ -81,2 +98,6 @@\n-  ZGeneration* const _generation;\n-  ZRelocateQueue     _queue;\n+  ZGeneration* const                       _generation;\n+  ZRelocateQueue                           _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator> _iters;\n+  ZPerWorker<ZRelocationTargets>           _small_targets;\n+  ZPerWorker<ZRelocationTargets>           _medium_targets;\n+  ZRelocationTargets                       _shared_medium_targets;\n@@ -85,1 +106,0 @@\n-  void work(ZRelocationSetParallelIterator* iter);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+  friend class ZRelocateTask;\n@@ -67,0 +68,1 @@\n+  ZRelocationSetIteratorImpl();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+template <bool Parallel>\n+inline ZRelocationSetIteratorImpl<Parallel>::ZRelocationSetIteratorImpl()\n+  : ZArrayIteratorImpl<ZForwarding*, Parallel>(nullptr, 0) {}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}