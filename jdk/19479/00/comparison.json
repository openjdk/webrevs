{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import java.io.UncheckedIOException;\n@@ -54,12 +53,128 @@\n-        try {\n-            Terminal terminal = TerminalBuilder.builder().encoding(charset)\n-                                               .exec(false)\n-                                               .systemOutput(SystemOutput.SysOut)\n-                                               .build();\n-            return new JdkConsoleImpl(terminal);\n-        } catch (IllegalStateException ise) {\n-            \/\/cannot create a non-dumb, non-exec terminal,\n-            \/\/use the standard Console:\n-            return null;\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(ioe);\n+        return new LazyDelegatingJdkConsoleImpl(charset);\n+    }\n+\n+    private static class LazyDelegatingJdkConsoleImpl implements JdkConsole {\n+        private final Charset charset;\n+        private volatile boolean jlineInitialized;\n+        private volatile JdkConsole delegate;\n+\n+        public LazyDelegatingJdkConsoleImpl(Charset charset) {\n+            this.charset = charset;\n+            this.delegate = new jdk.internal.io.JdkConsoleImpl(charset);\n+        }\n+\n+        @Override\n+        public PrintWriter writer() {\n+            return getDelegate(true).writer();\n+        }\n+\n+        @Override\n+        public Reader reader() {\n+            return getDelegate(true).reader();\n+        }\n+\n+        @Override\n+        public JdkConsole println(Object obj) {\n+            JdkConsole delegate = getDelegate(false);\n+\n+            delegate.println(obj);\n+            flushOldDelegateIfNeeded(delegate);\n+\n+            return this;\n+        }\n+\n+        @Override\n+        public JdkConsole print(Object obj) {\n+            JdkConsole delegate = getDelegate(false);\n+\n+            delegate.print(obj);\n+            flushOldDelegateIfNeeded(delegate);\n+\n+            return this;\n+        }\n+\n+        @Override\n+        public String readln(String prompt) {\n+            return getDelegate(true).readln(prompt);\n+        }\n+\n+        @Override\n+        public JdkConsole format(Locale locale, String format, Object... args) {\n+            JdkConsole delegate = getDelegate(false);\n+\n+            delegate.format(locale, format, args);\n+            flushOldDelegateIfNeeded(delegate);\n+\n+            return this;\n+        }\n+\n+        @Override\n+        public String readLine(Locale locale, String format, Object... args) {\n+            return getDelegate(true).readLine(locale, format, args);\n+        }\n+\n+        @Override\n+        public String readLine() {\n+            return getDelegate(true).readLine();\n+        }\n+\n+        @Override\n+        public char[] readPassword(Locale locale, String format, Object... args) {\n+            return getDelegate(true).readPassword(locale, format, args);\n+        }\n+\n+        @Override\n+        public char[] readPassword() {\n+            return getDelegate(true).readPassword();\n+        }\n+\n+        @Override\n+        public void flush() {\n+            getDelegate(false).flush();\n+        }\n+\n+        @Override\n+        public Charset charset() {\n+            return charset;\n+        }\n+\n+        private void flushOldDelegateIfNeeded(JdkConsole oldDelegate) {\n+            if (oldDelegate != getDelegate(false)) {\n+                \/\/if the delegate changed in the mean time, make sure the original\n+                \/\/delegate is flushed:\n+                oldDelegate.flush();\n+            }\n+        }\n+\n+        private JdkConsole getDelegate(boolean needsJLine) {\n+            if (!needsJLine || jlineInitialized) {\n+                return delegate;\n+            }\n+\n+            return initializeJLineDelegate();\n+        }\n+\n+        private synchronized JdkConsole initializeJLineDelegate() {\n+            JdkConsole newDelegate = delegate;\n+\n+            if (jlineInitialized) {\n+                return newDelegate;\n+            }\n+\n+            try {\n+                Terminal terminal = TerminalBuilder.builder().encoding(charset)\n+                                                   .exec(false)\n+                                                   .systemOutput(SystemOutput.SysOut)\n+                                                   .build();\n+                newDelegate = new JdkConsoleImpl(terminal);\n+            } catch (IllegalStateException ise) {\n+                \/\/cannot create a non-dumb, non-exec terminal,\n+                \/\/use the standard Console:\n+            } catch (IOException ioe) {\n+                \/\/something went wrong, keep the existing delegate\n+            }\n+\n+            delegate = newDelegate;\n+            jlineInitialized = true;\n+\n+            return newDelegate;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":128,"deletions":13,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8333086\n+ * @summary Verify the JLine backend is not initialized for simple printing.\n+ * @enablePreview\n+ * @modules jdk.internal.le\/jdk.internal.org.jline.reader\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal\n+ * @library \/test\/lib\n+ * @run main LazyJdkConsoleProvider\n+ *\/\n+\n+import java.io.IO;\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.terminal.Terminal;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LazyJdkConsoleProvider {\n+\n+    public static void main(String... args) throws Throwable {\n+        switch (args.length > 0 ? args[0] : \"default\") {\n+            case \"write\" -> {\n+                System.console().println(\"Hello!\");\n+                System.console().print(\"Hello!\");\n+                System.console().format(\"\\nHello!\\n\");\n+                System.console().flush();\n+                IO.println(\"Hello!\");\n+                IO.print(\"Hello!\");\n+            }\n+            case \"read\" -> System.console().readLine(\"Hello!\");\n+            case \"IO-read\" -> {\n+                IO.readln(\"Hello!\");\n+            }\n+            case \"default\" -> {\n+                new LazyJdkConsoleProvider().runTest();\n+            }\n+        }\n+    }\n+\n+    void runTest() throws Exception {\n+        record TestCase(String testKey, String expected, String notExpected) {}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"write\", null, Terminal.class.getName()),\n+            new TestCase(\"read\", LineReader.class.getName(), null),\n+            new TestCase(\"IO-read\", LineReader.class.getName(), null)\n+        };\n+        for (TestCase tc : testCases) {\n+            ProcessBuilder builder =\n+                    ProcessTools.createTestJavaProcessBuilder(\"--enable-preview\",\n+                                                              \"-verbose:class\",\n+                                                              LazyJdkConsoleProvider.class.getName(),\n+                                                              tc.testKey());\n+            OutputAnalyzer output = ProcessTools.executeProcess(builder, \"\");\n+\n+            output.waitFor();\n+\n+            if (output.getExitValue() != 0) {\n+                throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n+                                         \", actualOut: \" + output.getStdout() +\n+                                         \", actualErr: \" + output.getStderr());\n+            }\n+            if (tc.expected() != null) {\n+                output.shouldContain(tc.expected());\n+            }\n+\n+            if (tc.notExpected() != null) {\n+                output.shouldNotContain(tc.notExpected());\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/LazyJdkConsoleProvider.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}