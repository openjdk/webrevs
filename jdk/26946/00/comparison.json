{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,27 @@\n+  \/\/ Notes on copy constructor, copy assignment operator, and copy_from().\n+  \/\/ These are necessary for generating deterministic CDS archives.\n+  \/\/\n+  \/\/ We have some unused padding on 64-bit platforms (4 bytes at the tail end).\n+  \/\/\n+  \/\/ When ResolvedFieldEntries in a ConstantPoolCache are allocated from the metaspace,\n+  \/\/ their entire content (including the padding) is filled with zeros. They are\n+  \/\/ then initialized with initialize_resolved_entries_array() in cpCache.cpp from a\n+  \/\/ GrowableArray.\n+  \/\/\n+  \/\/ The GrowableArray is initialized in rewriter.cpp, using ResolvedFieldEntries that\n+  \/\/ are originally allocated from the C++ stack. Functions like GrowableArray::expand_to()\n+  \/\/ will also allocate ResolvedFieldEntries from the stack. These may have random bits\n+  \/\/ in the padding as the C++ compiler is allowed to leave the padding in uninitialized\n+  \/\/ states.\n+  \/\/\n+  \/\/ If we use the default copy constructor and\/or default copy assignment operator,\n+  \/\/ the random padding will be copied into the GrowableArray, from there\n+  \/\/ to the ConstantPoolCache, and eventually to the CDS archive. As a result, the\n+  \/\/ CDS archive will contain random bits, causing failures in\n+  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java (usually on Windows).\n+  \/\/\n+  \/\/ By using copy_from(), we can prevent the random padding from being copied,\n+  \/\/ ensuring that the ResolvedFieldEntries in a ConstantPoolCache (and thus the\n+  \/\/ CDS archive) will have all zeros in the padding.\n+\n+  \/\/ Copy constructor\n@@ -87,0 +114,1 @@\n+  \/\/ Copy assignment operator\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,3 @@\n+  \/\/ The copy_from() pattern in resolvedFieldEntry.hpp is not necessary\n+  \/\/ as we have no unused padding (on 32- or 64-bit platforms).\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,2 @@\n+  \/\/ See comments in resolvedFieldEntry.hpp about copy_from and padding.\n+  \/\/ We have unused padding on debug builds.\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}