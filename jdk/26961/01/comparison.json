{"files":[{"patch":"@@ -30,0 +30,1 @@\n+ * @modules java.base\/sun.nio.ch:+open java.base\/java.io:+open\n@@ -35,0 +36,1 @@\n+import java.lang.reflect.Field;\n@@ -50,0 +52,18 @@\n+    private static final int TRIES = 3;\n+\n+    public static int getFD(FileChannel channel) throws Exception {\n+        Field fFdFd = channel.getClass().getDeclaredField(\"fd\");\n+        fFdFd.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) fFdFd.get(channel);\n+\n+        Field fFd = FileDescriptor.class.getDeclaredField(\"fd\");\n+        fFd.setAccessible(true);\n+        return fFd.getInt(fd);\n+    }\n+\n+    private static void testWrite(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                StandardOpenOption.WRITE,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n@@ -51,3 +71,0 @@\n-    private static int testWrite(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, StandardOpenOption.WRITE,\n-             ExtendedOpenOption.DIRECT)) {\n@@ -63,3 +80,17 @@\n-            src.flip();\n-            fc.write(src);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                src.flip();\n+                fc.position(0);\n+                fc.write(src);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"write. File still exists in cache!\");\n@@ -69,2 +100,6 @@\n-    private static int testRead(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, ExtendedOpenOption.DIRECT)) {\n+    private static void testRead(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n+\n@@ -77,2 +112,17 @@\n-            fc.read(dest);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                dest.clear();\n+                fc.position(0);\n+                fc.read(dest);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"read. File still exists in cache!\");\n@@ -87,6 +137,2 @@\n-    private static boolean isFileInCache(int size, Path p) {\n-        String path = p.toString();\n-        return isFileInCache0(size, path);\n-    }\n-\n-    private static native boolean isFileInCache0(int size, String path);\n+    private static native boolean flushFileCache(int size, int fd);\n+    private static native boolean isFileInCache(int size, int fd);\n@@ -101,10 +147,2 @@\n-            int size = testWrite(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"write. File still exists in cache!\");\n-            }\n-            size = testRead(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"read. File still exists in cache!\");\n-            }\n+            testWrite(p, blockSize);\n+            testRead(p, blockSize);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/DirectIOTest.java","additions":64,"deletions":26,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n- * Method:    isFileInCache0\n- * Signature: (ILjava\/lang\/String;)Z\n+ * Method:    flushFileCache\n+ * Signature: (II;)V\n@@ -51,1 +51,1 @@\n-JNIEXPORT jboolean Java_DirectIOTest_isFileInCache0(JNIEnv *env,\n+JNIEXPORT void Java_DirectIOTest_flushFileCache(JNIEnv *env,\n@@ -54,1 +54,15 @@\n-                                                jstring file_path) {\n+                                                jint fd) {\n+#ifdef __linux__\n+    posix_fadvise(fd, 0, file_size, POSIX_FADV_DONTNEED);\n+#endif\n+}\n+\n+\/*\n+ * Class:     DirectIO\n+ * Method:    isFileInCache\n+ * Signature: (II;)Z\n+ *\/\n+JNIEXPORT jboolean Java_DirectIOTest_isFileInCache(JNIEnv *env,\n+                                                jclass cls,\n+                                                jint file_size,\n+                                                jint fd) {\n@@ -72,6 +86,0 @@\n-    const char* path = (*env)->GetStringUTFChars(env, file_path, JNI_FALSE);\n-\n-    int fd = open(path, O_RDWR);\n-\n-    (*env)->ReleaseStringUTFChars(env, file_path, path);\n-\n@@ -80,1 +88,0 @@\n-        close(fd);\n@@ -82,1 +89,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: mmap failed\");\n@@ -98,1 +105,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: malloc failed\");\n@@ -100,1 +107,0 @@\n-    close(fd);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/libDirectIO.c","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"}]}