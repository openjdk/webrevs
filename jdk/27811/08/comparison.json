{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -36,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -706,1 +708,1 @@\n-        if (!isFinite(d) )\n+        if (!isFinite(d) ) {\n@@ -709,3 +711,10 @@\n-        else {\n-            \/\/ Initialized to maximum size of output.\n-            StringBuilder answer = new StringBuilder(24);\n+        }\n+\n+        boolean negative = Double.doubleToLongBits(d) < 0;\n+\n+        if (d == 0.0) {\n+            return negative ? \"-0x0.0p0\" : \"0x0.0p0\";\n+        }\n+        d = Math.abs(d);\n+        \/\/ Check if the value is subnormal (less than the smallest normal value)\n+        boolean subnormal = d < Double.MIN_NORMAL;\n@@ -713,2 +722,4 @@\n-            if (Math.copySign(1.0, d) == -1.0)    \/\/ value is negative,\n-                answer.append(\"-\");                  \/\/ so append sign info\n+        \/\/ Isolate significand bits and OR in a high-order bit\n+        \/\/ so that the string representation has a known length.\n+        \/\/ This ensures we always have 13 hex digits to work with (52 bits \/ 4 bits per hex digit)\n+        long signifBits = Double.doubleToLongBits(d) & DoubleConsts.SIGNIF_BIT_MASK;\n@@ -716,1 +727,5 @@\n-            answer.append(\"0x\");\n+        \/\/ Calculate the number of trailing zeros in the significand (in groups of 4 bits)\n+        \/\/ This is used to remove trailing zeros from the hex representation\n+        \/\/ We limit to 12 because we want to keep at least 1 hex digit (13 total - 12 = 1)\n+        \/\/ assert 0 <= trailingZeros && trailingZeros <= 12\n+        int trailingZeros = Long.numberOfTrailingZeros(signifBits | 1L << 4 * 12) >> 2;\n@@ -718,1 +733,3 @@\n-            d = Math.abs(d);\n+        \/\/ Determine the exponent value based on whether the number is subnormal or normal\n+        \/\/ Subnormal numbers use the minimum exponent, normal numbers use the actual exponent\n+        int exp = subnormal ? Double.MIN_EXPONENT : Math.getExponent(d);\n@@ -720,4 +737,8 @@\n-            if(d == 0.0) {\n-                answer.append(\"0.0p0\");\n-            } else {\n-                boolean subnormal = (d < Double.MIN_NORMAL);\n+        \/\/ Calculate the total length of the resulting string:\n+        \/\/ Sign (optional) + prefix \"0x\" + implicit bit + \".\" + hex digits + \"p\" + exponent\n+        int charlen = (negative ? 1 : 0) \/\/ sign character\n+                + 4 \/\/ \"0x1.\" or \"0x0.\"\n+                + 13 - trailingZeros \/\/ hex digits (13 max, minus trailing zeros)\n+                + 1 \/\/ \"p\"\n+                + DecimalDigits.stringSize(exp) \/\/ exponent\n+                ;\n@@ -725,6 +746,3 @@\n-                \/\/ Isolate significand bits and OR in a high-order bit\n-                \/\/ so that the string representation has a known\n-                \/\/ length.\n-                long signifBits = (Double.doubleToLongBits(d)\n-                                   & DoubleConsts.SIGNIF_BIT_MASK) |\n-                    0x1000000000000000L;\n+        \/\/ Create a byte array to hold the result characters\n+        byte[] chars = new byte[charlen];\n+        int index = 0;\n@@ -732,3 +750,4 @@\n-                \/\/ Subnormal values have a 0 implicit bit; normal\n-                \/\/ values have a 1 implicit bit.\n-                answer.append(subnormal ? \"0.\" : \"1.\");\n+        \/\/ Add the sign character if the number is negative\n+        if (negative) {  \/\/ value is negative\n+            chars[index++] = '-';\n+        }\n@@ -736,8 +755,7 @@\n-                \/\/ Isolate the low-order 13 digits of the hex\n-                \/\/ representation.  If all the digits are zero,\n-                \/\/ replace with a single 0; otherwise, remove all\n-                \/\/ trailing zeros.\n-                String signif = Long.toHexString(signifBits).substring(3,16);\n-                answer.append(signif.equals(\"0000000000000\") ? \/\/ 13 zeros\n-                              \"0\":\n-                              signif.replaceFirst(\"0{1,12}$\", \"\"));\n+        \/\/ Add the prefix and the implicit bit ('1' for normal, '0' for subnormal)\n+        \/\/ Subnormal values have a 0 implicit bit; normal values have a 1 implicit bit.\n+        chars[index    ] = '0';      \/\/ Hex prefix\n+        chars[index + 1] = 'x';  \/\/ Hex prefix\n+        chars[index + 2] = (byte) (subnormal ? '0' : '1');  \/\/ Implicit bit\n+        chars[index + 3] = '.';  \/\/ Decimal point\n+        index += 4;\n@@ -745,10 +763,8 @@\n-                answer.append('p');\n-                \/\/ If the value is subnormal, use the E_min exponent\n-                \/\/ value for double; otherwise, extract and report d's\n-                \/\/ exponent (the representation of a subnormal uses\n-                \/\/ E_min -1).\n-                answer.append(subnormal ?\n-                              Double.MIN_EXPONENT:\n-                              Math.getExponent(d));\n-            }\n-            return answer.toString();\n+        \/\/ Convert significand to hex digits manually to avoid creating temporary strings\n+        \/\/ Extract the 13 hex digits (52 bits) from signifBits\n+        \/\/ We need to extract bits 48-51, 44-47, ..., 0-3 (13 groups of 4 bits)\n+        for (int i = 0, end = 13 - trailingZeros; i < end; i++) {\n+            \/\/ Extract 4 bits at a time from left to right\n+            \/\/ Shift right by (12 - i) * 4 positions and mask with 0xF\n+            \/\/ Integer.digits maps values 0-15 to '0'-'f' characters\n+            chars[index++] = Integer.digits[((int)(signifBits >> ((12 - i) << 2))) & 0xF];\n@@ -756,0 +772,9 @@\n+\n+        \/\/ Add the exponent indicator\n+        chars[index] = 'p';\n+\n+        \/\/ Append the exponent value to the character array\n+        \/\/ This method writes the decimal representation of exp directly into the byte array\n+        DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n+\n+        return String.newStringWithLatin1Bytes(chars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":64,"deletions":39,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -178,0 +178,16 @@\n+            \/\/ Test cases for trailing zeros in significand\n+            \/\/ These test the removal of trailing zeros in the hexadecimal representation\n+            {\"0x1.1p1\",                                 \"4001000000000000\"}, \/\/ Maximum trailing zeros (all zeros after '1')\n+            {\"0x1.0p1\",                                 \"4000000000000000\"}, \/\/ Maximum trailing zeros (all zeros after '0')\n+            {\"0x1.01p1\",                                \"4000100000000000\"}, \/\/ 1  trailing zero removed\n+            {\"0x1.001p1\",                               \"4000010000000000\"}, \/\/ 2  trailing zeros removed\n+            {\"0x1.0001p1\",                              \"4000001000000000\"}, \/\/ 3  trailing zeros removed\n+            {\"0x1.00001p1\",                             \"4000000100000000\"}, \/\/ 4  trailing zeros removed\n+            {\"0x1.000001p1\",                            \"4000000010000000\"}, \/\/ 5  trailing zeros removed\n+            {\"0x1.0000001p1\",                           \"4000000001000000\"}, \/\/ 6  trailing zeros removed\n+            {\"0x1.00000001p1\",                          \"4000000000100000\"}, \/\/ 7  trailing zeros removed\n+            {\"0x1.000000001p1\",                         \"4000000000010000\"}, \/\/ 8  trailing zeros removed\n+            {\"0x1.0000000001p1\",                        \"4000000000001000\"}, \/\/ 9  trailing zeros removed\n+            {\"0x1.00000000001p1\",                       \"4000000000000100\"}, \/\/ 10 trailing zeros removed\n+            {\"0x1.000000000001p1\",                      \"4000000000000010\"}, \/\/ 11 trailing zeros removed (minimum)\n+\n","filename":"test\/jdk\/java\/lang\/Double\/ToHexString.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-public class FloatingDecimal {\n+public class Doubles {\n@@ -68,0 +68,8 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void toHexString(Blackhole bh) {\n+        for (double d : randomArray) {\n+            bh.consume(Double.toHexString(d));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Doubles.java","additions":9,"deletions":1,"binary":false,"changes":10,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatingDecimal.java","status":"renamed"}]}