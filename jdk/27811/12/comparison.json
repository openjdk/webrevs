{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -36,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -702,1 +704,1 @@\n-        if (!isFinite(d) )\n+        if (!isFinite(d)) {\n@@ -705,3 +707,11 @@\n-        else {\n-            \/\/ Initialized to maximum size of output.\n-            StringBuilder answer = new StringBuilder(24);\n+        }\n+\n+        long doubleToLongBits = Double.doubleToLongBits(d);\n+        boolean negative = doubleToLongBits < 0;\n+\n+        if (d == 0.0) {\n+            return negative ? \"-0x0.0p0\" : \"0x0.0p0\";\n+        }\n+        d = Math.abs(d);\n+        \/\/ Check if the value is subnormal (less than the smallest normal value)\n+        boolean subnormal = d < Double.MIN_NORMAL;\n@@ -709,2 +719,4 @@\n-            if (Math.copySign(1.0, d) == -1.0)    \/\/ value is negative,\n-                answer.append(\"-\");                  \/\/ so append sign info\n+        \/\/ Isolate significand bits and OR in a high-order bit\n+        \/\/ so that the string representation has a known length.\n+        \/\/ This ensures we always have 13 hex digits to work with (52 bits \/ 4 bits per hex digit)\n+        long signifBits = doubleToLongBits & DoubleConsts.SIGNIF_BIT_MASK;\n@@ -712,1 +724,5 @@\n-            answer.append(\"0x\");\n+        \/\/ Calculate the number of trailing zeros in the significand (in groups of 4 bits)\n+        \/\/ This is used to remove trailing zeros from the hex representation\n+        \/\/ We limit to 12 because we want to keep at least 1 hex digit (13 total - 12 = 1)\n+        \/\/ assert 0 <= trailingZeros && trailingZeros <= 12\n+        int trailingZeros = Long.numberOfTrailingZeros(signifBits | 1L << 4 * 12) >> 2;\n@@ -714,1 +730,3 @@\n-            d = Math.abs(d);\n+        \/\/ Determine the exponent value based on whether the number is subnormal or normal\n+        \/\/ Subnormal numbers use the minimum exponent, normal numbers use the actual exponent\n+        int exp = subnormal ? Double.MIN_EXPONENT : Math.getExponent(d);\n@@ -716,4 +734,8 @@\n-            if(d == 0.0) {\n-                answer.append(\"0.0p0\");\n-            } else {\n-                boolean subnormal = (d < Double.MIN_NORMAL);\n+        \/\/ Calculate the total length of the resulting string:\n+        \/\/ Sign (optional) + prefix \"0x\" + implicit bit + \".\" + hex digits + \"p\" + exponent\n+        int charlen = (negative ? 1 : 0) \/\/ sign character\n+                + 4 \/\/ \"0x1.\" or \"0x0.\"\n+                + 13 - trailingZeros \/\/ hex digits (13 max, minus trailing zeros)\n+                + 1 \/\/ \"p\"\n+                + DecimalDigits.stringSize(exp) \/\/ exponent\n+                ;\n@@ -721,6 +743,3 @@\n-                \/\/ Isolate significand bits and OR in a high-order bit\n-                \/\/ so that the string representation has a known\n-                \/\/ length.\n-                long signifBits = (Double.doubleToLongBits(d)\n-                                   & DoubleConsts.SIGNIF_BIT_MASK) |\n-                    0x1000000000000000L;\n+        \/\/ Create a byte array to hold the result characters\n+        byte[] chars = new byte[charlen];\n+        int index = 0;\n@@ -728,3 +747,4 @@\n-                \/\/ Subnormal values have a 0 implicit bit; normal\n-                \/\/ values have a 1 implicit bit.\n-                answer.append(subnormal ? \"0.\" : \"1.\");\n+        \/\/ Add the sign character if the number is negative\n+        if (negative) {  \/\/ value is negative\n+            chars[index++] = '-';\n+        }\n@@ -732,8 +752,7 @@\n-                \/\/ Isolate the low-order 13 digits of the hex\n-                \/\/ representation.  If all the digits are zero,\n-                \/\/ replace with a single 0; otherwise, remove all\n-                \/\/ trailing zeros.\n-                String signif = Long.toHexString(signifBits).substring(3,16);\n-                answer.append(signif.equals(\"0000000000000\") ? \/\/ 13 zeros\n-                              \"0\":\n-                              signif.replaceFirst(\"0{1,12}$\", \"\"));\n+        \/\/ Add the prefix and the implicit bit ('1' for normal, '0' for subnormal)\n+        \/\/ Subnormal values have a 0 implicit bit; normal values have a 1 implicit bit.\n+        chars[index    ] = '0';      \/\/ Hex prefix\n+        chars[index + 1] = 'x';  \/\/ Hex prefix\n+        chars[index + 2] = (byte) (subnormal ? '0' : '1');  \/\/ Implicit bit\n+        chars[index + 3] = '.';  \/\/ Decimal point\n+        index += 4;\n@@ -741,10 +760,8 @@\n-                answer.append('p');\n-                \/\/ If the value is subnormal, use the E_min exponent\n-                \/\/ value for double; otherwise, extract and report d's\n-                \/\/ exponent (the representation of a subnormal uses\n-                \/\/ E_min -1).\n-                answer.append(subnormal ?\n-                              Double.MIN_EXPONENT:\n-                              Math.getExponent(d));\n-            }\n-            return answer.toString();\n+        \/\/ Convert significand to hex digits manually to avoid creating temporary strings\n+        \/\/ Extract the 13 hex digits (52 bits) from signifBits\n+        \/\/ We need to extract bits 48-51, 44-47, ..., 0-3 (13 groups of 4 bits)\n+        for (int sh = 48, end = 4 * trailingZeros; sh >= end; sh -= 4) {\n+            \/\/ Extract 4 bits at a time from left to right\n+            \/\/ Shift right by sh positions and mask with 0xF\n+            \/\/ Integer.digits maps values 0-15 to '0'-'f' characters\n+            chars[index++] = Integer.digits[((int)(signifBits >> sh)) & 0xF];\n@@ -752,0 +769,9 @@\n+\n+        \/\/ Add the exponent indicator\n+        chars[index] = 'p';\n+\n+        \/\/ Append the exponent value to the character array\n+        \/\/ This method writes the decimal representation of exp directly into the byte array\n+        DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n+\n+        return String.newStringWithLatin1Bytes(chars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":65,"deletions":39,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -177,0 +178,20 @@\n+            \/\/ Test cases for trailing zeros in significand\n+            \/\/ These test the removal of trailing zeros in the hexadecimal representation\n+            \/\/ The comments indicate the number of trailing zeros removed from the significand\n+            \/\/ For \"0x1.0p1\", there are 13 trailing zeros in the significand, but only 12 are removed\n+            \/\/ as we always keep at least one hex digit in the significand\n+            {\"0x1.0p1\",                                 \"4000000000000000\"}, \/\/ 12 trailing zeros removed (13 total, but only 12 removed)\n+            {\"0x1.1p1\",                                 \"4001000000000000\"}, \/\/ 12 trailing zeros removed (all zeros after '1')\n+            {\"0x1.01p1\",                                \"4000100000000000\"}, \/\/ 11 trailing zeros removed\n+            {\"0x1.001p1\",                               \"4000010000000000\"}, \/\/ 10 trailing zeros removed\n+            {\"0x1.0001p1\",                              \"4000001000000000\"}, \/\/ 9  trailing zeros removed\n+            {\"0x1.00001p1\",                             \"4000000100000000\"}, \/\/ 8  trailing zeros removed\n+            {\"0x1.000001p1\",                            \"4000000010000000\"}, \/\/ 7  trailing zeros removed\n+            {\"0x1.0000001p1\",                           \"4000000001000000\"}, \/\/ 6  trailing zeros removed\n+            {\"0x1.00000001p1\",                          \"4000000000100000\"}, \/\/ 5  trailing zeros removed\n+            {\"0x1.000000001p1\",                         \"4000000000010000\"}, \/\/ 4  trailing zeros removed\n+            {\"0x1.0000000001p1\",                        \"4000000000001000\"}, \/\/ 3  trailing zeros removed\n+            {\"0x1.00000000001p1\",                       \"4000000000000100\"}, \/\/ 2  trailing zeros removed\n+            {\"0x1.000000000001p1\",                      \"4000000000000010\"}, \/\/ 1  trailing zero  removed (minimum)\n+            {\"0x1.0000000000001p1\",                     \"4000000000000001\"}, \/\/ 0  trailing zeros removed (no trailing zeros to remove)\n+\n","filename":"test\/jdk\/java\/lang\/Double\/ToHexString.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests for sun.misc.FloatingDecimal. Performs floating point number to String conversions.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(3)\n+public class Doubles {\n+\n+    private double[] randomArray, twoDecimalsArray, integerArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+        randomArray = new double[TESTSIZE];\n+        twoDecimalsArray = new double[TESTSIZE];\n+        integerArray = new double[TESTSIZE];\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            randomArray[i] = r.nextDouble() * 10000.0D;\n+            twoDecimalsArray[i] = ((double) (10000 - r.nextInt(20000))) \/ 100;\n+            integerArray[i] = (double) (100 - r.nextInt(200));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void toHexString(Blackhole bh) {\n+        for (double d : randomArray) {\n+            bh.consume(Double.toHexString(d));\n+        }\n+    }\n+\n+    \/** Tests Double.toString on double values generated from Random.nextDouble() *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void randomDoubleToString(Blackhole bh) {\n+        for (double d : randomArray) {\n+            bh.consume(Double.toString(d));\n+        }\n+    }\n+\n+    \/** Tests Double.toString on double values that are integers between -100 and 100. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void integerDoubleToString(Blackhole bh) {\n+        for (double d : integerArray) {\n+            bh.consume(Double.toString(d));\n+        }\n+    }\n+\n+    \/** Tests Double.toString on double values that are between -100 and 100 and have two decimal digits. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void twoDecimalsDoubleToString(Blackhole bh) {\n+        for (double d : twoDecimalsArray) {\n+            bh.consume(Double.toString(d));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Doubles.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Tests for sun.misc.FloatingDecimal. Performs floating point number to String conversions.\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@Fork(3)\n-public class FloatingDecimal {\n-\n-    private double[] randomArray, twoDecimalsArray, integerArray;\n-    private static final int TESTSIZE = 1000;\n-\n-    @Setup\n-    public void setup() {\n-        Random r = new Random(1123);\n-        randomArray = new double[TESTSIZE];\n-        twoDecimalsArray = new double[TESTSIZE];\n-        integerArray = new double[TESTSIZE];\n-        for (int i = 0; i < TESTSIZE; i++) {\n-            randomArray[i] = r.nextDouble() * 10000.0D;\n-            twoDecimalsArray[i] = ((double) (10000 - r.nextInt(20000))) \/ 100;\n-            integerArray[i] = (double) (100 - r.nextInt(200));\n-        }\n-    }\n-\n-    \/** Tests Double.toString on double values generated from Random.nextDouble() *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TESTSIZE)\n-    public void randomDoubleToString(Blackhole bh) {\n-        for (double d : randomArray) {\n-            bh.consume(Double.toString(d));\n-        }\n-    }\n-\n-    \/** Tests Double.toString on double values that are integers between -100 and 100. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TESTSIZE)\n-    public void integerDoubleToString(Blackhole bh) {\n-        for (double d : integerArray) {\n-            bh.consume(Double.toString(d));\n-        }\n-    }\n-\n-    \/** Tests Double.toString on double values that are between -100 and 100 and have two decimal digits. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TESTSIZE)\n-    public void twoDecimalsDoubleToString(Blackhole bh) {\n-        for (double d : twoDecimalsArray) {\n-            bh.consume(Double.toString(d));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatingDecimal.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"}]}