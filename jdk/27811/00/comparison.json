{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -36,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -710,8 +712,1 @@\n-            \/\/ Initialized to maximum size of output.\n-            StringBuilder answer = new StringBuilder(24);\n-\n-            if (Math.copySign(1.0, d) == -1.0)    \/\/ value is negative,\n-                answer.append(\"-\");                  \/\/ so append sign info\n-\n-            answer.append(\"0x\");\n-\n+            boolean negative = Math.copySign(1.0, d) == -1.0;\n@@ -720,2 +715,2 @@\n-            if(d == 0.0) {\n-                answer.append(\"0.0p0\");\n+            if (d == 0.0) {\n+                return negative ? \"-0x0.0p0\" : \"0x0.0p0\";\n@@ -723,0 +718,1 @@\n+                \/\/ Check if the value is subnormal (less than the smallest normal value)\n@@ -726,2 +722,2 @@\n-                \/\/ so that the string representation has a known\n-                \/\/ length.\n+                \/\/ so that the string representation has a known length.\n+                \/\/ This ensures we always have 13 hex digits to work with (52 bits \/ 4 bits per hex digit)\n@@ -729,2 +725,47 @@\n-                                   & DoubleConsts.SIGNIF_BIT_MASK) |\n-                    0x1000000000000000L;\n+                        & DoubleConsts.SIGNIF_BIT_MASK) |\n+                        0x1000000000000000L;\n+\n+                \/\/ Calculate the number of trailing zeros in the significand (in groups of 4 bits)\n+                \/\/ This is used to remove trailing zeros from the hex representation\n+                \/\/ We limit to 12 because we want to keep at least 1 hex digit (13 total - 12 = 1)\n+                int trailingZeros = Math.min(12, ((Long.numberOfTrailingZeros(signifBits) & 0xFC) >> 2));\n+\n+                \/\/ Determine the exponent value based on whether the number is subnormal or normal\n+                \/\/ Subnormal numbers use the minimum exponent, normal numbers use the actual exponent\n+                int exp = subnormal ? Double.MIN_EXPONENT : Math.getExponent(d);\n+\n+                \/\/ Calculate the total length of the resulting string:\n+                \/\/ Sign (optional) + prefix \"0x\" + implicit bit + \".\" + hex digits + \"p\" + exponent\n+                int charlen = (negative ? 1 : 0) \/\/ sign character\n+                        + 4 \/\/ \"0x1.\" or \"0x0.\"\n+                        + 13 - trailingZeros \/\/ hex digits (13 max, minus trailing zeros)\n+                        + 1 \/\/ \"p\"\n+                        + DecimalDigits.stringSize(exp) \/\/ exponent\n+                        ;\n+\n+                \/\/ Create a byte array to hold the result characters\n+                byte[] chars = new byte[charlen];\n+                int index = 0;\n+\n+                \/\/ Add the sign character if the number is negative\n+                if (negative) {  \/\/ value is negative\n+                    chars[index++] = '-';\n+                }\n+\n+                \/\/ Add the prefix and the implicit bit ('1' for normal, '0' for subnormal)\n+                \/\/ Subnormal values have a 0 implicit bit; normal values have a 1 implicit bit.\n+                chars[index    ] = '0';      \/\/ Hex prefix\n+                chars[index + 1] = 'x';  \/\/ Hex prefix\n+                chars[index + 2] = (byte) (subnormal ? '0' : '1');  \/\/ Implicit bit\n+                chars[index + 3] = '.';  \/\/ Decimal point\n+                index += 4;\n+\n+                \/\/ Convert significand to hex digits manually to avoid creating temporary strings\n+                \/\/ Extract the 13 hex digits (52 bits) from signifBits\n+                \/\/ We need to extract bits 48-51, 44-47, ..., 0-3 (13 groups of 4 bits)\n+                for (int i = 0, end = 13 - trailingZeros; i < end; i++) {\n+                    \/\/ Extract 4 bits at a time from left to right\n+                    \/\/ Shift right by (12 - i) * 4 positions and mask with 0xF\n+                    \/\/ Integer.digits maps values 0-15 to '0'-'f' characters\n+                    chars[index++] = Integer.digits[((int)(signifBits >> ((12 - i) << 2))) & 0xF];\n+                }\n@@ -732,3 +773,2 @@\n-                \/\/ Subnormal values have a 0 implicit bit; normal\n-                \/\/ values have a 1 implicit bit.\n-                answer.append(subnormal ? \"0.\" : \"1.\");\n+                \/\/ Add the exponent indicator\n+                chars[index] = 'p';\n@@ -736,8 +776,3 @@\n-                \/\/ Isolate the low-order 13 digits of the hex\n-                \/\/ representation.  If all the digits are zero,\n-                \/\/ replace with a single 0; otherwise, remove all\n-                \/\/ trailing zeros.\n-                String signif = Long.toHexString(signifBits).substring(3,16);\n-                answer.append(signif.equals(\"0000000000000\") ? \/\/ 13 zeros\n-                              \"0\":\n-                              signif.replaceFirst(\"0{1,12}$\", \"\"));\n+                \/\/ Append the exponent value to the character array\n+                \/\/ This method writes the decimal representation of exp directly into the byte array\n+                DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n@@ -745,8 +780,1 @@\n-                answer.append('p');\n-                \/\/ If the value is subnormal, use the E_min exponent\n-                \/\/ value for double; otherwise, extract and report d's\n-                \/\/ exponent (the representation of a subnormal uses\n-                \/\/ E_min -1).\n-                answer.append(subnormal ?\n-                              Double.MIN_EXPONENT:\n-                              Math.getExponent(d));\n+                return String.newStringWithLatin1Bytes(chars);\n@@ -754,1 +782,0 @@\n-            return answer.toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":61,"deletions":34,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-public class FloatingDecimal {\n+public class Doubles {\n@@ -68,0 +68,8 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void toHexString(Blackhole bh) {\n+        for (double d : randomArray) {\n+            bh.consume(Double.toHexString(d));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Doubles.java","additions":9,"deletions":1,"binary":false,"changes":10,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatingDecimal.java","status":"renamed"}]}