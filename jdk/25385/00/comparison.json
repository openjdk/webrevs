{"files":[{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zIndexDistributor.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/z\/zIndexDistributor.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/z\/zPageTable.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"logging\/log.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -37,0 +40,6 @@\n+#define ZINDEXDISTRIBUTOR_LOGGING 0\n+\n+inline int zfetch_then_inc(volatile int* addr) {\n+  return Atomic::fetch_then_add(addr, 1, memory_order_relaxed);\n+}\n+\n@@ -48,1 +57,1 @@\n-    return Atomic::fetch_then_add(&_claim_stripe, 1, memory_order_relaxed);\n+    return zfetch_then_inc(&_claim_stripe);\n@@ -69,1 +78,1 @@\n-      for (int index; (index = Atomic::fetch_then_add(claim_addr(i), 1, memory_order_relaxed)) < stripe_max;) {\n+      for (int index; (index = zfetch_then_inc(claim_addr(i))) < stripe_max;) {\n@@ -78,1 +87,1 @@\n-      for (int index; (index = Atomic::fetch_then_add(claim_addr(i), 1, memory_order_relaxed)) < stripe_max;) {\n+      for (int index; (index = zfetch_then_inc(claim_addr(i))) < stripe_max;) {\n@@ -101,7 +110,0 @@\n-  \/\/ Describes the how the number of indices increases when going up from the given level\n-  static constexpr int level_multiplier(int level) {\n-    assert(level < ClaimLevels, \"Must be\");\n-    constexpr int array[ClaimLevels]{16, 16, 16};\n-    return array[level];\n-  }\n-\n@@ -117,7 +119,5 @@\n-  \/\/ Claim index functions\n-\n-  \/\/ Number of claim entries at the given level\n-  static constexpr int claim_level_size(int level) {\n-    if (level == 0) {\n-      return 1;\n-    }\n+  \/\/ Describes the how the number of indices increases when going up from the given level\n+  template <int level>\n+  static constexpr int level_multiplier() {\n+    STATIC_ASSERT(level >= 0);\n+    STATIC_ASSERT(level < ClaimLevels);\n@@ -125,1 +125,3 @@\n-    return level_multiplier(level - 1) * claim_level_size(level - 1);\n+    constexpr int array[ClaimLevels]{16, 16, 16};\n+    constexpr int result = array[level];\n+    return result;\n@@ -128,7 +130,3 @@\n-  \/\/ The index the next level starts at\n-  static constexpr int claim_level_end_index(int level) {\n-    if (level == 0) {\n-\n-      \/\/ First level uses padding\n-      return ZCacheLineSize \/ sizeof(int);\n-    }\n+  \/\/ Number of claim entries at the given level\n+  template <int level>\n+  inline static constexpr int claim_level_size();\n@@ -136,2 +134,3 @@\n-    return claim_level_size(level) + claim_level_end_index(level - 1);\n-  }\n+  \/\/ The index the next level starts at\n+  template <int level>\n+  inline static constexpr int claim_level_end_index();\n@@ -139,3 +138,2 @@\n-  static constexpr int claim_level_start_index(int level) {\n-    return claim_level_end_index(level - 1);\n-  }\n+  template <int level>\n+  inline static constexpr int claim_level_start_index();\n@@ -144,3 +142,1 @@\n-  static size_t claim_variables_size() {\n-    return sizeof(int) * (size_t)claim_level_end_index(ClaimLevels);\n-  }\n+  inline static size_t claim_variables_size();\n@@ -149,7 +145,2 @@\n-  static constexpr int claim_level_index_accumulate(int* indices, int level, int acc = 1) {\n-    if (level == 0) {\n-      return acc * indices[level];\n-    }\n-\n-    return acc * indices[level] + claim_level_index_accumulate(indices, level - 1, acc * level_multiplier(level));\n-  }\n+  template <int level>\n+  inline static constexpr int claim_level_index_accumulate(int* indices, int acc = 1);\n@@ -157,2 +148,3 @@\n-  static constexpr int claim_level_index(int* indices, int level) {\n-    assert(level > 0, \"Must be\");\n+  template <int level>\n+  inline static constexpr int claim_level_index(int* indices) {\n+    STATIC_ASSERT(level > 0);\n@@ -161,1 +153,1 @@\n-    return claim_level_index_accumulate(indices, level - 1);\n+    return claim_level_index_accumulate<level - 1>(indices);\n@@ -164,7 +156,2 @@\n-  static constexpr int claim_index(int* indices, int level) {\n-    if (level == 0) {\n-      return 0;\n-    }\n-\n-    return claim_level_start_index(level) + claim_level_index(indices, level);\n-  }\n+  template <int level>\n+  inline static constexpr int claim_index(int* indices);\n@@ -174,2 +161,2 @@\n-  int claim(int index) {\n-    return Atomic::fetch_then_add(&_claim_array[index], 1, memory_order_relaxed);\n+  inline int claim(int index) {\n+    return zfetch_then_inc(&_claim_array[index]);\n@@ -178,12 +165,2 @@\n-  int claim_at(int* indices, int level) {\n-    const int index = claim_index(indices, level);\n-    const int value = claim(index);\n-#if 0\n-    if      (level == 0) { tty->print_cr(\"Claim at: %d index: %d got: %d\",             indices[0], index, value); }\n-    else if (level == 1) { tty->print_cr(\"Claim at: %d %d index: %d got: %d\",          indices[0], indices[1], index, value); }\n-    else if (level == 2) { tty->print_cr(\"Claim at: %d %d %d index: %d got: %d\",       indices[0], indices[1], indices[2], index, value); }\n-    else if (level == 3) { tty->print_cr(\"Claim at: %d %d %d %d index: %d got: %d\",    indices[0], indices[1], indices[2], indices[3], index, value); }\n-    else if (level == 4) { tty->print_cr(\"Claim at: %d %d %d %d %d index: %d got: %d\", indices[0], indices[1], indices[2], indices[3], indices[4], index, value); }\n-#endif\n-    return value;\n-  }\n+  template <int level>\n+  inline int level_segment_size();\n@@ -192,10 +169,1 @@\n-  void claim_and_do(Function function, int* indices, int level) {\n-    if (level < N) {\n-      \/\/ Visit ClaimLevels and the last level\n-      const int ci = claim_index(indices, level);\n-      for (indices[level] = 0; (indices[level] = claim(ci)) < level_segment_size(level);) {\n-        claim_and_do(function, indices, level + 1);\n-      }\n-      return;\n-    }\n-\n+  inline void claim_and_do_N(Function function, int* indices) {\n@@ -205,10 +173,8 @@\n-  template <typename Function>\n-  void steal_and_do(Function function, int* indices, int level) {\n-    for (indices[level] = 0; indices[level] < level_segment_size(level); indices[level]++) {\n-      const int next_level = level + 1;\n-      \/\/ First try to claim at next level\n-      claim_and_do(function, indices, next_level);\n-      \/\/ Then steal at next level\n-      if (next_level < ClaimLevels) {\n-        steal_and_do(function, indices, next_level);\n-      }\n+  template <int level, typename Function>\n+  inline void claim_and_do_lt_N(Function function, int* indices) {\n+    STATIC_ASSERT(level < N);\n+\n+    \/\/ Visit ClaimLevels and the last level\n+    const int ci = claim_index<level>(indices);\n+    for (indices[level] = 0; (indices[level] = claim(ci)) < level_segment_size<level>();) {\n+      claim_and_do<level + 1>(function, indices);\n@@ -218,1 +184,2 @@\n-  \/\/ Functions to claimed values to an index\n+  template <int level, typename Function>\n+  struct ClaimAndDo;\n@@ -220,6 +187,4 @@\n-  static constexpr int levels_size(int level) {\n-    if (level == 0) {\n-      return level_multiplier(0);\n-    }\n-\n-    return level_multiplier(level) * levels_size(level - 1);\n+  template <int level, typename Function>\n+  inline void claim_and_do(Function function, int* indices) {\n+    \/\/ Dispatch depending on value of level\n+    ClaimAndDo<level, Function>::dispatch(*this, function, indices);\n@@ -228,3 +193,3 @@\n-  static int constexpr level_to_last_level_count_coverage(int level) {\n-    return levels_size(ClaimLevels - 1) \/ levels_size(level);\n-  }\n+  template <typename Function>\n+  void steal_and_do_ClaimLevels_minus_1(Function function, int* indices) {\n+    constexpr int level = ClaimLevels - 1;\n@@ -232,3 +197,4 @@\n-  static int constexpr calculate_last_level_count(int* indices, int level = 0) {\n-    if (level == N - 1) {\n-      return 0;\n+    for (indices[level] = 0; indices[level] < level_segment_size<level>(); indices[level]++) {\n+      constexpr int next_level = level + 1;\n+      \/\/ First try to claim at next level\n+      claim_and_do<next_level>(function, indices);\n@@ -236,2 +202,0 @@\n-\n-    return indices[level] * level_to_last_level_count_coverage(level) + calculate_last_level_count(indices, level + 1);\n@@ -240,4 +204,3 @@\n-  int calculate_index(int* indices) {\n-    const int segment_start = calculate_last_level_count(indices) << _last_level_segment_size_shift;\n-    return segment_start + indices[N - 1];\n-  }\n+  template <int level, typename Function>\n+  void steal_and_do_lt_ClaimLevels_minus_1(Function function, int* indices) {\n+    STATIC_ASSERT(level < ClaimLevels - 1);\n@@ -245,3 +208,6 @@\n-  int level_segment_size(int level) {\n-    if (level == ClaimLevels) {\n-      return 1 << _last_level_segment_size_shift;\n+    for (indices[level] = 0; indices[level] < level_segment_size<level>(); indices[level]++) {\n+      constexpr int next_level = level + 1;\n+      \/\/ First try to claim at next level\n+      claim_and_do<next_level>(function, indices);\n+      \/\/ Then steal at next level\n+      steal_and_do<next_level>(function, indices);\n@@ -249,2 +215,0 @@\n-\n-    return level_multiplier(level);\n@@ -253,10 +217,2 @@\n-  template <typename Function>\n-  void doit(Function function, int* indices) {\n-    \/\/const int index = first_level * second_level_max * _third_level_max + second_level * _third_level_max + third_level;\n-    const int index = calculate_index(indices);\n-\n-#if 0\n-    tty->print_cr(\"doit Thread: \" PTR_FORMAT \": %d %d %d %d => %d\",\n-        p2i(Thread::current()),\n-        indices[0], indices[1], indices[2], indices[3], index);\n-#endif\n+  template <int level, typename Function>\n+  struct StealAndDo;\n@@ -264,1 +220,4 @@\n-    function(index);\n+  template <int level, typename Function>\n+  inline void steal_and_do(Function function, int* indices) {\n+    \/\/ Dispatch depending on value of level\n+    StealAndDo<level, Function>::dispatch(*this, function, indices);\n@@ -267,3 +226,8 @@\n-  static int last_level_segment_size_shift(int count) {\n-    const int last_level_size = count \/ levels_size(ClaimLevels - 1);\n-    assert(levels_size(ClaimLevels - 1) * last_level_size == count, \"Not exactly divisible\");\n+  template <int level>\n+  inline static constexpr int levels_size();\n+\n+  template <int level>\n+  inline static int constexpr level_to_last_level_count_coverage();\n+\n+  template <int level = 0>\n+  inline static int constexpr calculate_last_level_count(int* indices);\n@@ -271,1 +235,29 @@\n-    return log2i_exact(last_level_size);\n+  inline int calculate_index(int* indices);\n+\n+  template <typename Function>\n+  inline void doit(Function function, int* indices);\n+\n+#if  ZINDEXDISTRIBUTOR_LOGGING\n+  void log_claim_array() {\n+    log_info(gc, reloc)(\"_claim_array[0]: %d\", _claim_array[0]);\n+\n+    for (int i = level_segment_size<0>(); i < claim_level_end_index<ClaimLevels>(); i += 16) {\n+      log_info(gc, reloc)(\"_claim_array[%d-%d]: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\",\n+          i, i + 15,\n+          _claim_array[i],\n+          _claim_array[i + 1],\n+          _claim_array[i + 2],\n+          _claim_array[i + 3],\n+          _claim_array[i + 4],\n+          _claim_array[i + 5],\n+          _claim_array[i + 6],\n+          _claim_array[i + 7],\n+          _claim_array[i + 8],\n+          _claim_array[i + 9],\n+          _claim_array[i + 10],\n+          _claim_array[i + 11],\n+          _claim_array[i + 12],\n+          _claim_array[i + 13],\n+          _claim_array[i + 14],\n+          _claim_array[i + 15]);\n+    }\n@@ -273,0 +265,3 @@\n+#endif\n+\n+  inline static int calculate_last_level_segment_size_shift(int count);\n@@ -276,1 +271,1 @@\n-    : _last_level_segment_size_shift(last_level_segment_size_shift(count)),\n+    : _last_level_segment_size_shift(calculate_last_level_segment_size_shift(count)),\n@@ -280,5 +275,1 @@\n-    assert((levels_size(ClaimLevels - 1) << _last_level_segment_size_shift) == count, \"Incorrectly setup\");\n-\n-#if 0\n-    tty->print_cr(\"ZIndexDistributorClaimTree count: %d byte size: %zu\", count, claim_variables_size() + os::vm_page_size());\n-#endif\n+    assert((levels_size<ClaimLevels - 1>() << _last_level_segment_size_shift) == count, \"Incorrectly setup\");\n@@ -287,1 +278,5 @@\n-  }\n+\n+#if ZINDEXDISTRIBUTOR_LOGGING\n+    tty->print_cr(\"ZIndexDistributorClaimTree count: %d byte size: \" SIZE_FORMAT, count, claim_variables_size() + os::vm_page_size());\n+#endif\n+}\n@@ -296,2 +291,2 @@\n-    claim_and_do(function, indices, 0 \/* level *\/);\n-    steal_and_do(function, indices, 0 \/* level *\/);\n+    claim_and_do<0>(function, indices);\n+    steal_and_do<0>(function, indices);\n@@ -302,1 +297,1 @@\n-    const size_t min_count = claim_level_size(ClaimLevels);\n+    const size_t min_count = claim_level_size<ClaimLevels>();\n@@ -307,11 +302,0 @@\n-\/\/ Using dynamically allocated objects just to be able to evaluate\n-\/\/ different strategies. Revert when one has been choosen.\n-\n-inline void* ZIndexDistributor::create_strategy(int count) {\n-  switch (ZIndexDistributorStrategy) {\n-  case 0: return new ZIndexDistributorClaimTree(count);\n-  case 1: return new ZIndexDistributorStriped(count);\n-  default: fatal(\"Unknown ZIndexDistributorStrategy\"); return nullptr;\n-  };\n-}\n-\n@@ -329,0 +313,11 @@\n+\/\/ Using dynamically allocated objects just to be able to evaluate\n+\/\/ different strategies. Revert when one has been chosen.\n+\n+inline void* ZIndexDistributor::create_strategy(int count) {\n+  switch (ZIndexDistributorStrategy) {\n+  case 0: return new ZIndexDistributorClaimTree(count);\n+  case 1: return new ZIndexDistributorStriped(count);\n+  default: fatal(\"Unknown ZIndexDistributorStrategy\"); return nullptr;\n+  };\n+}\n+\n@@ -356,0 +351,145 @@\n+template <>\n+constexpr int ZIndexDistributorClaimTree::claim_level_size<0>() {\n+  return 1;\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::claim_level_size() {\n+  STATIC_ASSERT(level > 0);\n+\n+  return level_multiplier<level - 1>() * claim_level_size<level - 1>();\n+}\n+\n+template <>\n+constexpr int ZIndexDistributorClaimTree::claim_level_end_index<0>() {\n+  \/\/ First level uses padding\n+  return ZCacheLineSize \/ sizeof(int);\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::claim_level_end_index() {\n+  STATIC_ASSERT(level > 0);\n+\n+  return claim_level_size<level>() + claim_level_end_index<level - 1>();\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::claim_level_start_index() {\n+  return claim_level_end_index<level - 1>();\n+}\n+\n+inline size_t ZIndexDistributorClaimTree::claim_variables_size() {\n+  return sizeof(int) * (size_t)claim_level_end_index<ClaimLevels>();\n+}\n+\n+template <>\n+inline int ZIndexDistributorClaimTree::level_segment_size<ZIndexDistributorClaimTree::ClaimLevels>() {\n+  return 1 << _last_level_segment_size_shift;\n+}\n+\n+template <int level>\n+inline int ZIndexDistributorClaimTree::level_segment_size() {\n+  return level_multiplier<level>();\n+}\n+\n+template <>\n+constexpr int ZIndexDistributorClaimTree::levels_size<0>() {\n+  return level_multiplier<0>();\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::levels_size() {\n+  STATIC_ASSERT(level > 0);\n+\n+  return level_multiplier<level>() * levels_size<level - 1>();\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::level_to_last_level_count_coverage() {\n+  return levels_size<ClaimLevels - 1>() \/ levels_size<level>();\n+}\n+\n+template <>\n+constexpr int ZIndexDistributorClaimTree::calculate_last_level_count<ZIndexDistributorClaimTree::N - 1>(int* indices) {\n+  return 0;\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::calculate_last_level_count(int* indices) {\n+  return indices[level] * level_to_last_level_count_coverage<level>() + calculate_last_level_count<level + 1>(indices);\n+}\n+\n+inline int ZIndexDistributorClaimTree::calculate_index(int* indices) {\n+  const int segment_start = calculate_last_level_count(indices) << _last_level_segment_size_shift;\n+  return segment_start + indices[N - 1];\n+}\n+\n+template <typename Function>\n+inline void ZIndexDistributorClaimTree::doit(Function function, int* indices) {\n+  const int index = calculate_index(indices);\n+\n+#if ZINDEXDISTRIBUTOR_LOGGING\n+  log_debug(gc, reloc)(\"doit Thread: \" PTR_FORMAT \": %d %d %d %d => %d\",\n+      p2i(Thread::current()),\n+      indices[0], indices[1], indices[2], indices[3], index);\n+#endif\n+\n+  function(index);\n+}\n+\n+inline int ZIndexDistributorClaimTree::calculate_last_level_segment_size_shift(int count) {\n+  const int last_level_size = count \/ levels_size<ClaimLevels - 1>();\n+\n+  assert(levels_size<ClaimLevels - 1>() * last_level_size == count, \"Not exactly divisible\");\n+\n+  return log2i_exact(last_level_size);\n+}\n+\n+template <>\n+constexpr int ZIndexDistributorClaimTree::claim_index<0>(int* indices) {\n+  return 0;\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::claim_index(int* indices) {\n+  return claim_level_start_index<level>() + claim_level_index<level>(indices);\n+}\n+\n+template <>\n+constexpr int ZIndexDistributorClaimTree::claim_level_index_accumulate<0>(int* indices, int acc) {\n+  return acc * indices[0];\n+}\n+\n+template <int level>\n+constexpr int ZIndexDistributorClaimTree::claim_level_index_accumulate(int* indices, int acc) {\n+  return acc * indices[level] + claim_level_index_accumulate<level - 1>(indices, acc * level_multiplier<level>());\n+}\n+\n+template <typename Function>\n+struct ZIndexDistributorClaimTree::ClaimAndDo<ZIndexDistributorClaimTree::N, Function> {\n+  inline static void dispatch(ZIndexDistributorClaimTree& instance, Function function, int* indices) {\n+    instance.claim_and_do_N(function, indices);\n+  }\n+};\n+\n+template <int level, typename Function>\n+struct ZIndexDistributorClaimTree::ClaimAndDo {\n+  inline static void dispatch(ZIndexDistributorClaimTree& instance, Function function, int* indices) {\n+    instance.claim_and_do_lt_N<level>(function, indices);\n+  }\n+};\n+\n+template <typename Function>\n+struct ZIndexDistributorClaimTree::StealAndDo<ZIndexDistributorClaimTree::ClaimLevels - 1, Function> {\n+  inline static void dispatch(ZIndexDistributorClaimTree& instance, Function function, int* indices) {\n+    instance.steal_and_do_ClaimLevels_minus_1(function, indices);\n+  }\n+};\n+\n+template <int level, typename Function>\n+struct ZIndexDistributorClaimTree::StealAndDo {\n+  inline static void dispatch(ZIndexDistributorClaimTree& instance, Function function, int* indices) {\n+    instance.steal_and_do_lt_ClaimLevels_minus_1<level>(function, indices);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zIndexDistributor.inline.hpp","additions":284,"deletions":144,"binary":false,"changes":428,"status":"modified"},{"patch":"@@ -79,0 +79,8 @@\n+ZPageTableParallelIterator::ZPageTableParallelIterator(const ZPageTable* table)\n+  : _table(table),\n+    _index_distributor(table->count()) {}\n+\n+ZPageTableParallelIterator::~ZPageTableParallelIterator() {\n+  \/\/ Explicit destructor because dependency on the inline ZIndexDistributor destructor\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  ~ZPageTableParallelIterator();\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,4 +74,0 @@\n-inline ZPageTableParallelIterator::ZPageTableParallelIterator(const ZPageTable* table)\n-  : _table(table),\n-    _index_distributor(table->count()) {}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/z\/zIndexDistributor.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size(0), 1);\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size(1), 16);\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size(2), 16 * 16);\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size(3), 16 * 16 * 16);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size<0>(), 1);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size<1>(), 16);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size<2>(), 16 * 16);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_size<3>(), 16 * 16 * 16);\n@@ -41,4 +41,4 @@\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index(0), first_level_end);\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index(1), first_level_end + 16);\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index(2), first_level_end + 16 + 16 * 16);\n-    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index(3), first_level_end + 16 + 16 * 16 + 16 * 16 * 16);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index<0>(), first_level_end);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index<1>(), first_level_end + 16);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index<2>(), first_level_end + 16 + 16 * 16);\n+    ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_end_index<3>(), first_level_end + 16 + 16 * 16 + 16 * 16 * 16);\n@@ -51,1 +51,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 0), 0);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<0>(indices), 0);\n@@ -55,1 +55,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 0), 0);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<0>(indices), 0);\n@@ -59,1 +59,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 0), 0);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<0>(indices), 0);\n@@ -63,1 +63,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 0), 0);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<0>(indices), 0);\n@@ -73,1 +73,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 1), second_level_start);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<1>(indices), second_level_start);\n@@ -77,1 +77,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 1), second_level_start + 1);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<1>(indices), second_level_start + 1);\n@@ -81,1 +81,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 1), second_level_start + 15);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<1>(indices), second_level_start + 15);\n@@ -90,1 +90,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 2), third_level_start);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<2>(indices), third_level_start);\n@@ -94,1 +94,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 2), third_level_start + 1 * 16);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<2>(indices), third_level_start + 1 * 16);\n@@ -98,1 +98,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 2), third_level_start + 15 * 16);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<2>(indices), third_level_start + 15 * 16);\n@@ -102,1 +102,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 2), third_level_start + 1 * 16 + 2);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<2>(indices), third_level_start + 1 * 16 + 2);\n@@ -106,1 +106,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index(indices, 2), third_level_start + 15 * 16 + 14);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_index<2>(indices), third_level_start + 15 * 16 + 14);\n@@ -114,1 +114,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 1), 0);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<1>(indices), 0);\n@@ -118,1 +118,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 1), 1);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<1>(indices), 1);\n@@ -123,1 +123,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 2), 0);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<2>(indices), 0);\n@@ -127,1 +127,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 2), 1 * 16);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<2>(indices), 1 * 16);\n@@ -131,1 +131,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 2), 2 * 16);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<2>(indices), 2 * 16);\n@@ -135,1 +135,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 2), 2 * 16 + 1);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<2>(indices), 2 * 16 + 1);\n@@ -140,1 +140,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 3), 0);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<3>(indices), 0);\n@@ -144,1 +144,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 3), 1 * 16 * 16);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<3>(indices), 1 * 16 * 16);\n@@ -148,1 +148,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 3), 1 * 16 * 16 + 2 * 16);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<3>(indices), 1 * 16 * 16 + 2 * 16);\n@@ -152,1 +152,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 3), 1 * 16 * 16 + 2 * 16 + 1);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<3>(indices), 1 * 16 * 16 + 2 * 16 + 1);\n@@ -156,1 +156,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 3), 1 * 16 * 16 + 2 * 16 + 3);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<3>(indices), 1 * 16 * 16 + 2 * 16 + 3);\n@@ -160,1 +160,1 @@\n-      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index(indices, 2), 1 * 16 + 2);\n+      ASSERT_EQ(ZIndexDistributorClaimTree::claim_level_index<2>(indices), 1 * 16 + 2);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zIndexDistributor.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"}]}