{"files":[{"patch":"@@ -212,4 +212,2 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock); \/\/ add_to_hierarchy asserts this.\n-    SystemDictionary::add_to_hierarchy(result);\n-  }\n+  SystemDictionary::add_to_hierarchy(THREAD, result);\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -902,6 +903,3 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-    \/\/ But, do not add to dictionary.\n-  }\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n+  \/\/ But, do not add to dictionary.\n@@ -1492,1 +1490,3 @@\n-  \/\/ Add the new class. We need recompile lock during update of CHA.\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n+\n@@ -1495,4 +1495,0 @@\n-\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-\n@@ -1615,2 +1611,1 @@\n-\/\/ is held, to ensure that the compiler is not using the class hierarchy, and that deoptimization will kick in\n-\/\/ before a new class is used.\n+\/\/ is grabbed, to ensure that the compiler is not using the class hierarchy.\n@@ -1618,1 +1613,1 @@\n-void SystemDictionary::add_to_hierarchy(InstanceKlass* k) {\n+void SystemDictionary::add_to_hierarchy(JavaThread* current, InstanceKlass* k) {\n@@ -1620,3 +1615,4 @@\n-  if (Universe::is_fully_initialized()) {\n-    assert_locked_or_safepoint(Compile_lock);\n-  }\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"must NOT be at safepoint\");\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker ml(current, Compile_lock);\n@@ -1624,4 +1620,4 @@\n-  k->set_init_state(InstanceKlass::loaded);\n-  \/\/ make sure init_state store is already done.\n-  \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n-  \/\/ Access ordering is used to add to hierarchy.\n+    k->set_init_state(InstanceKlass::loaded);\n+    \/\/ make sure init_state store is already done.\n+    \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n+    \/\/ Access ordering is used to add to hierarchy.\n@@ -1629,3 +1625,3 @@\n-  \/\/ Link into hierarchy.\n-  k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n-  k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n+    \/\/ Link into hierarchy.\n+    k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n+    k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n@@ -1633,4 +1629,5 @@\n-  \/\/ Now flush all code that depended on old class hierarchy.\n-  \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n-  if (Universe::is_fully_initialized()) {\n-    CodeCache::flush_dependents_on(k);\n+    \/\/ Now mark all code that depended on old class hierarchy.\n+    \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n+    if (Universe::is_fully_initialized()) {\n+      CodeCache::mark_dependents_on(&deopt_scope, k);\n+    }\n@@ -1638,0 +1635,2 @@\n+  \/\/ Perform the deopt handshake outside Compile_lock.\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":27,"deletions":28,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -369,2 +369,2 @@\n-  \/\/ Setup link to hierarchy\n-  static void add_to_hierarchy(InstanceKlass* k);\n+  \/\/ Setup link to hierarchy and deoptimize\n+  static void add_to_hierarchy(JavaThread* current, InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -853,2 +853,0 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n@@ -856,4 +854,4 @@\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    SystemDictionary::add_to_hierarchy(loaded_lambda);\n-    \/\/ But, do not add to dictionary.\n-  }\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  SystemDictionary::add_to_hierarchy(THREAD, loaded_lambda);\n+  \/\/ But, do not add to dictionary.\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  SystemDictionary::add_to_hierarchy(klass);\n+  SystemDictionary::add_to_hierarchy(THREAD, klass);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1246,1 +1246,1 @@\n-int CodeCache::mark_for_deoptimization(KlassDepChange& changes) {\n+void CodeCache::mark_for_deoptimization(DeoptimizationScope* deopt_scope, KlassDepChange& changes) {\n@@ -1248,1 +1248,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1260,1 +1259,1 @@\n-    number_of_marked_CodeBlobs += InstanceKlass::cast(d)->mark_dependent_nmethods(changes);\n+    InstanceKlass::cast(d)->mark_dependent_nmethods(deopt_scope, changes);\n@@ -1272,2 +1271,0 @@\n-\n-  return number_of_marked_CodeBlobs;\n@@ -1328,1 +1325,1 @@\n-int CodeCache::mark_dependents_for_evol_deoptimization() {\n+void CodeCache::mark_dependents_for_evol_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1334,1 +1331,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1342,1 +1338,1 @@\n-      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n@@ -1344,1 +1340,0 @@\n-      number_of_marked_CodeBlobs++;\n@@ -1347,4 +1342,0 @@\n-\n-  \/\/ return total count of nmethods marked for deoptimization, if zero the caller\n-  \/\/ can skip deoptimization\n-  return number_of_marked_CodeBlobs;\n@@ -1353,1 +1344,1 @@\n-void CodeCache::mark_all_nmethods_for_evol_deoptimization() {\n+void CodeCache::mark_all_nmethods_for_evol_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1360,1 +1351,1 @@\n-        nm->mark_for_deoptimization();\n+        deopt_scope->mark(nm);\n@@ -1369,13 +1360,0 @@\n-\/\/ Flushes compiled methods dependent on redefined classes, that have already been\n-\/\/ marked for deoptimization.\n-void CodeCache::flush_evol_dependents() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-\n-  \/\/ CodeCache can only be updated by a thread_in_VM and they will all be\n-  \/\/ stopped during the safepoint so CodeCache will be safe to update without\n-  \/\/ holding the CodeCache_lock.\n-\n-  \/\/ At least one nmethod has been marked for deoptimization\n-\n-  Deoptimization::deoptimize_all_marked();\n-}\n@@ -1385,1 +1363,1 @@\n-void CodeCache::mark_all_nmethods_for_deoptimization() {\n+void CodeCache::mark_all_nmethods_for_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1391,1 +1369,1 @@\n-      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n@@ -1396,1 +1374,1 @@\n-int CodeCache::mark_for_deoptimization(Method* dependee) {\n+void CodeCache::mark_for_deoptimization(DeoptimizationScope* deopt_scope, Method* dependee) {\n@@ -1398,1 +1376,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1404,3 +1381,1 @@\n-      ResourceMark rm;\n-      nm->mark_for_deoptimization();\n-      number_of_marked_CodeBlobs++;\n+      deopt_scope->mark(nm);\n@@ -1409,2 +1384,0 @@\n-\n-  return number_of_marked_CodeBlobs;\n@@ -1419,1 +1392,1 @@\n-      make_nmethod_deoptimized(nm);\n+      nm->make_deoptimized();\n@@ -1424,8 +1397,2 @@\n-void CodeCache::make_nmethod_deoptimized(CompiledMethod* nm) {\n-  if (nm->is_marked_for_deoptimization() && nm->can_be_deoptimized()) {\n-    nm->make_deoptimized();\n-  }\n-}\n-\n-\/\/ Flushes compiled methods dependent on dependee.\n-void CodeCache::flush_dependents_on(InstanceKlass* dependee) {\n+\/\/ Marks compiled methods dependent on dependee.\n+void CodeCache::mark_dependents_on(DeoptimizationScope* deopt_scope, InstanceKlass* dependee) {\n@@ -1438,1 +1405,0 @@\n-  int marked = 0;\n@@ -1442,1 +1408,1 @@\n-    marked = mark_for_deoptimization(changes);\n+    mark_for_deoptimization(deopt_scope, changes);\n@@ -1446,6 +1412,1 @@\n-    marked = mark_for_deoptimization(changes);\n-  }\n-\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization\n-    Deoptimization::deoptimize_all_marked();\n+    mark_for_deoptimization(deopt_scope, changes);\n@@ -1455,4 +1416,3 @@\n-\/\/ Flushes compiled methods dependent on dependee\n-void CodeCache::flush_dependents_on_method(const methodHandle& m_h) {\n-  \/\/ --- Compile_lock is not held. However we are at a safepoint.\n-  assert_locked_or_safepoint(Compile_lock);\n+\/\/ Marks compiled methods dependent on dependee\n+void CodeCache::mark_dependents_on_method_for_breakpoint(const methodHandle& m_h) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n@@ -1460,0 +1420,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1461,3 +1422,2 @@\n-  if (mark_for_deoptimization(m_h()) > 0) {\n-    Deoptimization::deoptimize_all_marked();\n-  }\n+  mark_for_deoptimization(&deopt_scope, m_h());\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":21,"deletions":61,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+class DeoptimizationScope;\n@@ -304,1 +305,1 @@\n-  static int  mark_for_deoptimization(KlassDepChange& changes);\n+  static void mark_for_deoptimization(DeoptimizationScope* deopt_scope, KlassDepChange& changes);\n@@ -307,2 +308,2 @@\n-  static void mark_all_nmethods_for_deoptimization();\n-  static int  mark_for_deoptimization(Method* dependee);\n+  static void mark_all_nmethods_for_deoptimization(DeoptimizationScope* deopt_scope);\n+  static void mark_for_deoptimization(DeoptimizationScope* deopt_scope, Method* dependee);\n@@ -310,1 +311,0 @@\n-  static void make_nmethod_deoptimized(CompiledMethod* nm);\n@@ -312,2 +312,2 @@\n-  \/\/ Flushing and deoptimization\n-  static void flush_dependents_on(InstanceKlass* dependee);\n+  \/\/ Marks dependents during classloading\n+  static void mark_dependents_on(DeoptimizationScope* deopt_scope, InstanceKlass* dependee);\n@@ -316,4 +316,3 @@\n-  \/\/ Flushing and deoptimization in case of evolution\n-  static int  mark_dependents_for_evol_deoptimization();\n-  static void mark_all_nmethods_for_evol_deoptimization();\n-  static void flush_evol_dependents();\n+  \/\/ Marks in case of evolution\n+  static void mark_dependents_for_evol_deoptimization(DeoptimizationScope* deopt_scope);\n+  static void mark_all_nmethods_for_evol_deoptimization(DeoptimizationScope* deopt_scope);\n@@ -324,1 +323,1 @@\n-  static void flush_dependents_on_method(const methodHandle& dependee);\n+  static void mark_dependents_on_method_for_breakpoint(const methodHandle& dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _deoptimization_status(not_marked),\n+    _deoptimization_generation(0),\n@@ -69,1 +70,2 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _deoptimization_status(not_marked),\n+    _deoptimization_generation(0),\n@@ -116,6 +118,4 @@\n-void CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n-  \/\/ assert(can_be_deoptimized(), \"\"); \/\/ in some places we check before marking, in others not.\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n-  if (_mark_for_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n-     _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);\n+void CompiledMethod::set_deoptimized_done() {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  if (_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n+    Atomic::store(&_deoptimization_status, deoptimize_done);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-\n+  friend class DeoptimizationScope;\n@@ -146,1 +146,1 @@\n-  enum MarkForDeoptimizationStatus : u1 {\n+  enum DeoptimizationStatus : u1 {\n@@ -153,1 +153,3 @@\n-  MarkForDeoptimizationStatus _mark_for_deoptimization_status; \/\/ Used for stack deoptimization\n+  volatile DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n+  \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n+  uint64_t                      _deoptimization_generation;\n@@ -177,0 +179,5 @@\n+private:\n+  DeoptimizationStatus deoptimization_status() const {\n+    return Atomic::load(&_deoptimization_status);\n+  }\n+\n@@ -239,5 +246,3 @@\n-  bool  is_marked_for_deoptimization() const { return _mark_for_deoptimization_status != not_marked; }\n-  void  mark_for_deoptimization(bool inc_recompile_counts = true);\n-\n-  bool  has_been_deoptimized() const { return _mark_for_deoptimization_status == deoptimize_done; }\n-  void  mark_deoptimized() { _mark_for_deoptimization_status = deoptimize_done; }\n+  bool  is_marked_for_deoptimization() const { return deoptimization_status() != not_marked; }\n+  bool  has_been_deoptimized() const { return deoptimization_status() == deoptimize_done; }\n+  void  set_deoptimized_done();\n@@ -251,2 +256,2 @@\n-    return _mark_for_deoptimization_status != deoptimize_noupdate &&\n-           _mark_for_deoptimization_status != deoptimize_done;\n+    DeoptimizationStatus status = deoptimization_status();\n+    return status != deoptimize_noupdate && status != deoptimize_done;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -685,2 +685,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) = 0;\n-\n@@ -783,4 +781,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/true);\n-  }\n-\n@@ -825,4 +819,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/false);\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -65,1 +66,1 @@\n-\/\/ deoptimization.  Returns the number of nmethods found.\n+\/\/ deoptimization.\n@@ -67,2 +68,1 @@\n-int DependencyContext::mark_dependent_nmethods(DepChange& changes) {\n-  int found = 0;\n+void DependencyContext::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, DepChange& changes) {\n@@ -73,3 +73,1 @@\n-        \/\/ Also count already (concurrently) marked nmethods to make sure\n-        \/\/ deoptimization is triggered before execution in this thread continues.\n-        found++;\n+        deopt_scope->dependent(nm);\n@@ -84,2 +82,1 @@\n-        changes.mark_for_deoptimization(nm);\n-        found++;\n+        deopt_scope->mark(nm, !changes.is_call_site_change());\n@@ -89,1 +86,0 @@\n-  return found;\n@@ -192,1 +188,1 @@\n-int DependencyContext::remove_and_mark_for_deoptimization_all_dependents() {\n+void DependencyContext::remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope) {\n@@ -195,1 +191,0 @@\n-  int marked = 0;\n@@ -201,2 +196,1 @@\n-      nm->mark_for_deoptimization();\n-      marked++;\n+      deopt_scope->mark(nm);\n@@ -206,1 +200,0 @@\n-  return marked;\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class DeoptimizationScope;\n@@ -120,1 +121,1 @@\n-  int  mark_dependent_nmethods(DepChange& changes);\n+  void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, DepChange& changes);\n@@ -123,1 +124,1 @@\n-  int  remove_and_mark_for_deoptimization_all_dependents();\n+  void remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1163,0 +1163,2 @@\n+    \/\/ Don't deopt this again.\n+    set_deoptimized_done();\n@@ -1170,0 +1172,6 @@\n+\n+  \/\/ If post call nops have been already patched, we can just bail-out.\n+  if (has_been_deoptimized()) {\n+    return;\n+  }\n+\n@@ -1205,1 +1213,1 @@\n-  mark_deoptimized();\n+  set_deoptimized_done();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1594,1 +1594,5 @@\n-    Deoptimization::deoptimize_all_marked(nm);\n+    DeoptimizationScope deopt_scope;\n+    deopt_scope.mark(nm);\n+    nm->make_not_entrant();\n+    nm->make_deoptimized();\n+    deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -1181,2 +1182,0 @@\n-  \/\/ Now flush all code that assume the class is not linked.\n-  \/\/ Set state under the Compile_lock also.\n@@ -1184,1 +1183,5 @@\n-    MutexLocker ml(current, Compile_lock);\n+    DeoptimizationScope deopt_scope;\n+    {\n+      \/\/ Now mark all code that assumes the class is not linked.\n+      \/\/ Set state under the Compile_lock also.\n+      MutexLocker ml(current, Compile_lock);\n@@ -1186,2 +1189,2 @@\n-    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-    set_init_state(state);\n+      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+      set_init_state(state);\n@@ -1189,1 +1192,4 @@\n-    CodeCache::flush_dependents_on(this);\n+      CodeCache::mark_dependents_on(&deopt_scope, this);\n+    }\n+    \/\/ Perform the deopt handshake outside Compile_lock.\n+    deopt_scope.deoptimize_marked();\n@@ -2328,2 +2334,2 @@\n-int InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes) {\n-  return dependencies().mark_dependent_nmethods(changes);\n+void InstanceKlass::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes) {\n+  dependencies().mark_dependent_nmethods(deopt_scope, changes);\n@@ -3275,1 +3281,1 @@\n-int InstanceKlass::mark_osr_nmethods(const Method* m) {\n+int InstanceKlass::mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m) {\n@@ -3283,1 +3289,1 @@\n-      osr->mark_for_deoptimization();\n+      deopt_scope->mark(osr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+class DeoptimizationScope;\n@@ -864,1 +865,1 @@\n-  int  mark_dependent_nmethods(KlassDepChange& changes);\n+  void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes);\n@@ -873,1 +874,1 @@\n-  int mark_osr_nmethods(const Method* m);\n+  int mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2011,1 +2011,1 @@\n-    CodeCache::flush_dependents_on_method(mh);\n+    CodeCache::mark_dependents_on_method_for_breakpoint(mh);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -908,4 +908,0 @@\n-  int mark_osr_nmethods() {\n-    return method_holder()->mark_osr_nmethods(this);\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4097,1 +4097,1 @@\n-  bool deopt_needed;\n+  DeoptimizationScope deopt_scope;\n@@ -4101,0 +4101,1 @@\n+    CodeCache::mark_all_nmethods_for_evol_deoptimization(&deopt_scope);\n@@ -4102,2 +4103,0 @@\n-    CodeCache::mark_all_nmethods_for_evol_deoptimization();\n-    deopt_needed = true;\n@@ -4105,3 +4104,2 @@\n-    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();\n-    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt);\n-    deopt_needed = (deopt != 0);\n+    CodeCache::mark_dependents_for_evol_deoptimization(&deopt_scope);\n+    log_debug(redefine, class, nmethod)(\"Marked dependent nmethods for deopt\");\n@@ -4110,3 +4108,1 @@\n-  if (deopt_needed) {\n-    CodeCache::flush_evol_dependents();\n-  }\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -953,1 +953,1 @@\n-void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {\n+void MethodHandles::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, Handle call_site, Handle target) {\n@@ -956,1 +956,0 @@\n-  int marked = 0;\n@@ -960,1 +959,1 @@\n-    MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -964,5 +963,1 @@\n-    marked = deps.mark_dependent_nmethods(changes);\n-  }\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization.\n-    Deoptimization::deoptimize_all_marked();\n+    deps.mark_dependent_nmethods(deopt_scope, changes);\n@@ -1221,0 +1216,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1224,1 +1220,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1226,0 +1222,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1233,0 +1232,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1236,1 +1236,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1238,0 +1238,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1327,0 +1330,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1328,14 +1332,7 @@\n-    \/\/ Walk all nmethods depending on this call site.\n-    MutexLocker mu1(thread, Compile_lock);\n-\n-    int marked = 0;\n-    {\n-      NoSafepointVerifier nsv;\n-      MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n-      marked = deps.remove_and_mark_for_deoptimization_all_dependents();\n-    }\n-    if (marked > 0) {\n-      \/\/ At least one nmethod has been marked for deoptimization\n-      Deoptimization::deoptimize_all_marked();\n-    }\n+    NoSafepointVerifier nsv;\n+    MutexLocker ml(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n+    deps.remove_and_mark_for_deoptimization_all_dependents(&deopt_scope);\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  static void flush_dependent_nmethods(Handle call_site, Handle target);\n+  static void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, Handle call_site, Handle target);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -781,2 +781,3 @@\n-  CodeCache::mark_all_nmethods_for_deoptimization();\n-  Deoptimization::deoptimize_all_marked();\n+  DeoptimizationScope deopt_scope;\n+  CodeCache::mark_all_nmethods_for_deoptimization(&deopt_scope);\n+  deopt_scope.deoptimize_marked();\n@@ -789,11 +790,12 @@\n-  MutexLocker mu(Compile_lock);\n-  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n-  if (is_osr) {\n-    result += mh->mark_osr_nmethods();\n-  } else if (mh->code() != nullptr) {\n-    mh->code()->mark_for_deoptimization();\n-    ++result;\n-  }\n-  result += CodeCache::mark_for_deoptimization(mh());\n-  if (result > 0) {\n-    Deoptimization::deoptimize_all_marked();\n+\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker mu(Compile_lock);\n+    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+    if (is_osr) {\n+      result += mh->method_holder()->mark_osr_nmethods(&deopt_scope, mh());\n+    } else if (mh->code() != nullptr) {\n+      deopt_scope.mark(mh->code());\n+      ++result;\n+    }\n+    CodeCache::mark_for_deoptimization(&deopt_scope, mh());\n@@ -801,0 +803,3 @@\n+\n+  deopt_scope.deoptimize_marked();\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -101,0 +101,115 @@\n+uint64_t DeoptimizationScope::_committed_deopt_gen = 0;\n+uint64_t DeoptimizationScope::_active_deopt_gen    = 1;\n+bool     DeoptimizationScope::_committing_in_progress = false;\n+\n+DeoptimizationScope::DeoptimizationScope() : _required_gen(0) {\n+  DEBUG_ONLY(_deopted = false;)\n+\n+  MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ If there is nothing to deopt _required_gen is the same as comitted.\n+  _required_gen = DeoptimizationScope::_committed_deopt_gen;\n+}\n+\n+DeoptimizationScope::~DeoptimizationScope() {\n+  assert(_deopted, \"Deopt not executed\");\n+}\n+\n+void DeoptimizationScope::mark(CompiledMethod* cm, bool inc_recompile_counts) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ If it's already marked but we still need it to be deopted.\n+  if (cm->is_marked_for_deoptimization()) {\n+    dependent(cm);\n+    return;\n+  }\n+\n+  CompiledMethod::DeoptimizationStatus status =\n+    inc_recompile_counts ? CompiledMethod::deoptimize : CompiledMethod::deoptimize_noupdate;\n+  Atomic::store(&cm->_deoptimization_status, status);\n+\n+  \/\/ Make sure active is not committed\n+  assert(DeoptimizationScope::_committed_deopt_gen < DeoptimizationScope::_active_deopt_gen, \"Must be\");\n+  assert(cm->_deoptimization_generation == 0, \"Is already marked\");\n+\n+  cm->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n+  _required_gen                  = DeoptimizationScope::_active_deopt_gen;\n+}\n+\n+void DeoptimizationScope::dependent(CompiledMethod* cm) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+  \/\/ A method marked by someone else may have a _required_gen lower than what we marked with.\n+  \/\/ Therefore only store it if it's higher than _required_gen.\n+  if (_required_gen < cm->_deoptimization_generation) {\n+    _required_gen = cm->_deoptimization_generation;\n+  }\n+}\n+\n+void DeoptimizationScope::deoptimize_marked() {\n+  assert(!_deopted, \"Already deopted\");\n+\n+  \/\/ We are not alive yet.\n+  if (!Universe::is_fully_initialized()) {\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  \/\/ Safepoints are a special case, handled here.\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    DeoptimizationScope::_committed_deopt_gen = DeoptimizationScope::_active_deopt_gen;\n+    DeoptimizationScope::_active_deopt_gen++;\n+    Deoptimization::deoptimize_all_marked();\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  uint64_t comitting = 0;\n+  bool wait = false;\n+  while (true) {\n+    {\n+      MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+      \/\/ First we check if we or someone else already deopted the gen we want.\n+      if (DeoptimizationScope::_committed_deopt_gen >= _required_gen) {\n+        DEBUG_ONLY(_deopted = true;)\n+        return;\n+      }\n+      if (!_committing_in_progress) {\n+        \/\/ The version we are about to commit.\n+        comitting = DeoptimizationScope::_active_deopt_gen;\n+        \/\/ Make sure new marks use a higher gen.\n+        DeoptimizationScope::_active_deopt_gen++;\n+        _committing_in_progress = true;\n+        wait = false;\n+      } else {\n+        \/\/ Another thread is handshaking and committing a gen.\n+        wait = true;\n+      }\n+    }\n+    if (wait) {\n+      \/\/ Wait and let the concurrent handshake be performed.\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      os::naked_yield();\n+    } else {\n+      \/\/ Performs the handshake.\n+      Deoptimization::deoptimize_all_marked(); \/\/ May safepoint and an additional deopt may have occurred.\n+      DEBUG_ONLY(_deopted = true;)\n+      {\n+        MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                       Mutex::_no_safepoint_check_flag);\n+        \/\/ Make sure that committed doesn't go backwards.\n+        \/\/ Should only happen if we did a deopt during a safepoint above.\n+        if (DeoptimizationScope::_committed_deopt_gen < comitting) {\n+          DeoptimizationScope::_committed_deopt_gen = comitting;\n+        }\n+        _committing_in_progress = false;\n+\n+        assert(DeoptimizationScope::_committed_deopt_gen >= _required_gen, \"Must be\");\n+\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n@@ -918,1 +1033,1 @@\n-void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {\n+void Deoptimization::deoptimize_all_marked() {\n@@ -922,7 +1037,1 @@\n-  if (nmethod_only != nullptr) {\n-    nmethod_only->mark_for_deoptimization();\n-    nmethod_only->make_not_entrant();\n-    CodeCache::make_nmethod_deoptimized(nmethod_only);\n-  } else {\n-    CodeCache::make_marked_nmethods_deoptimized();\n-  }\n+  CodeCache::make_marked_nmethods_deoptimized();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":117,"deletions":8,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -43,0 +43,26 @@\n+class DeoptimizationScope {\n+ private:\n+  \/\/ What gen we have done the deopt handshake for.\n+  static uint64_t _committed_deopt_gen;\n+  \/\/ What gen to mark a method with, hence larger than _committed_deopt_gen.\n+  static uint64_t _active_deopt_gen;\n+  \/\/ Indicate an in-progress deopt handshake.\n+  static bool     _committing_in_progress;\n+\n+  \/\/ The required gen we need to execute\/wait for\n+  uint64_t _required_gen;\n+  DEBUG_ONLY(bool _deopted;)\n+\n+ public:\n+  DeoptimizationScope();\n+  ~DeoptimizationScope();\n+  \/\/ Mark a method, if already marked as dependent.\n+  void mark(CompiledMethod* cm, bool inc_recompile_counts = true);\n+  \/\/ Record this as a dependent method.\n+  void dependent(CompiledMethod* cm);\n+\n+  \/\/ Execute the deoptimization.\n+  \/\/ Make the nmethods not entrant, stackwalks and patch return pcs and sets post call nops.\n+  void deoptimize_marked();\n+};\n+\n@@ -152,2 +178,1 @@\n-  \/\/ activations using those nmethods.  If an nmethod is passed as an argument then it is\n-  \/\/ marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to\n+  \/\/ activations using those nmethods. Scan of the code cache is done to\n@@ -155,1 +180,1 @@\n-  static void deoptimize_all_marked(nmethod* nmethod_only = nullptr);\n+  static void deoptimize_all_marked();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"}]}