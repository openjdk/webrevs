{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import jdk.internal.net.http.common.Log;\n@@ -496,1 +495,1 @@\n-    private boolean removeFromPool(HttpConnection c) {\n+    private void removeFromPool(HttpConnection c) {\n@@ -499,1 +498,1 @@\n-            return removeFromPool(c, plainPool);\n+            removeFromPool(c, plainPool);\n@@ -502,1 +501,1 @@\n-            return removeFromPool(c, sslPool);\n+            removeFromPool(c, sslPool);\n@@ -533,1 +532,0 @@\n-        boolean removed;\n@@ -535,1 +533,1 @@\n-            removed = removeFromPool(c);\n+            removeFromPool(c);\n@@ -540,16 +538,1 @@\n-        if (!removed) {\n-            \/\/ this should not happen; the cleanup may have consumed\n-            \/\/ some data that wasn't supposed to be consumed, so\n-            \/\/ the only thing we can do is log it and close the\n-            \/\/ connection.\n-            if (Log.errors()) {\n-                Log.logError(\"WARNING: CleanupTrigger triggered for\" +\n-                        \" a connection not found in the pool: closing {0}\", c);\n-            } else if (debug.on()) {\n-                debug.log(\"WARNING: CleanupTrigger triggered for\" +\n-                        \" a connection not found in the pool: closing %s\", c);\n-            }\n-            c.close(new IOException(\"Unexpected cleanup triggered for non pooled connection\"));\n-        } else {\n-            c.close();\n-        }\n+        c.close();\n@@ -569,1 +552,0 @@\n-        private volatile boolean dropped;\n@@ -587,1 +569,0 @@\n-            if (dropped || done) return;\n@@ -608,5 +589,0 @@\n-\n-        @Override\n-        public void dropSubscription() {\n-            dropped = true;\n-        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -576,2 +576,0 @@\n-                \/\/ make sure no data will be routed to the old subscriber.\n-                previous.stopReading();\n@@ -611,1 +609,0 @@\n-            volatile boolean stopped;\n@@ -629,1 +626,1 @@\n-                if (!cancelled && !stopped) {\n+                if (!cancelled) {\n@@ -633,1 +630,1 @@\n-                        debug.log(\"subscription stopped or cancelled, ignoring request %d\", n);\n+                        debug.log(\"subscription cancelled, ignoring request %d\", n);\n@@ -667,14 +664,0 @@\n-\n-            \/**\n-             * Called when switching subscriber on the {@link InternalReadSubscription}.\n-             * This subscriber is the old subscriber. Demand on the internal\n-             * subscription will be reset and reading will be paused until the\n-             * new subscriber is subscribed.\n-             * This should ensure that no data is routed to this subscriber\n-             * until the new subscriber is subscribed.\n-             *\/\n-            void stopReading() {\n-                stopped = true;\n-                impl.demand.reset();\n-                impl.pauseReadEvent();\n-            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @bug 8087112 8336655\n+ * @bug 8087112\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}