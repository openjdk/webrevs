{"files":[{"patch":"@@ -1836,0 +1836,11 @@\n+\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+  \/\/ Get address of invokedynamic array\n+  ldr(cache, Address(rcpool, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  lsl(index, index, log2i_exact(sizeof(ResolvedIndyEntry)));\n+  add(cache, cache, Array<ResolvedIndyEntry>::base_offset_in_bytes());\n+  lea(cache, Address(cache, index));\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -322,0 +322,2 @@\n+\n+  void load_resolved_indy_entry(Register cache, Register index);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -482,4 +482,2 @@\n-  \/\/ Pop N words from the stack\n-  __ get_cache_and_index_at_bcp(r1, r2, 1, index_size);\n-  __ ldr(r1, Address(r1, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n-  __ andr(r1, r1, ConstantPoolCacheEntry::parameter_size_mask);\n+  const Register cache = r1;\n+  const Register index = r2;\n@@ -487,1 +485,12 @@\n-  __ add(esp, esp, r1, Assembler::LSL, 3);\n+  if (index_size == sizeof(u4)) {\n+    __ load_resolved_indy_entry(cache, index);\n+    __ load_unsigned_short(cache, Address(cache, in_bytes(ResolvedIndyEntry::num_parameters_offset())));\n+    __ add(esp, esp, cache, Assembler::LSL, 3);\n+  } else {\n+    \/\/ Pop N words from the stack\n+    __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n+    __ ldr(cache, Address(cache, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+    __ andr(cache, cache, ConstantPoolCacheEntry::parameter_size_mask);\n+\n+    __ add(esp, esp, cache, Assembler::LSL, 3);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2323,0 +2323,71 @@\n+\/\/ The rmethod register is input and overwritten to be the adapter method for the\n+\/\/ indy call. Link Register (lr) is set to the return address for the adapter and\n+\/\/ an appendix may be pushed to the stack. Registers r0-r3 are clobbered\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  \/\/ setup registers\n+  const Register appendix = r0;\n+  const Register cache = r2;\n+  const Register index = r3;\n+  assert_different_registers(method, appendix, cache, index, rcpool);\n+\n+  __ save_bcp();\n+\n+  Label resolved;\n+\n+  __ load_resolved_indy_entry(cache, index);\n+  \/\/ Load-acquire the adapter method to match store-release in ResolvedIndyEntry::fill_in()\n+  __ lea(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  __ ldar(method, method);\n+\n+  \/\/ Compare the method to zero\n+  __ tst(method, method);\n+  __ br(Assembler::NE, resolved);\n+\n+  Bytecodes::Code code = bytecode();\n+\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mov(method, code); \/\/ this is essentially Bytecodes::_invokedynamic\n+  __ call_VM(noreg, entry, method);\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  \/\/ Load-acquire the adapter method to match store-release in ResolvedIndyEntry::fill_in()\n+  __ lea(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  __ ldar(method, method);\n+\n+#ifdef ASSERT\n+  __ tst(method, method);\n+  __ br(Assembler::NE, resolved);\n+  __ stop(\"Should be resolved by now\");\n+#endif \/\/ ASSERT\n+  __ bind(resolved);\n+\n+  Label L_no_push;\n+  \/\/ Check if there is an appendix\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::flags_offset())));\n+  __ tbz(index, ResolvedIndyEntry::has_appendix_shift, L_no_push);\n+\n+  \/\/ Get appendix\n+  __ load_unsigned_short(index, Address(cache, in_bytes(ResolvedIndyEntry::resolved_references_index_offset())));\n+  \/\/ Push the appendix as a trailing parameter\n+  \/\/ since the parameter_size includes it.\n+  __ push(method);\n+  __ mov(method, index);\n+  __ load_resolved_reference_at_index(appendix, method);\n+  __ verify_oop(appendix);\n+  __ pop(method);\n+  __ push(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  \/\/ compute return type\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::result_type_offset())));\n+  \/\/ load return address\n+  \/\/ Return address is loaded into link register(lr) and not pushed to the stack\n+  \/\/ like x86\n+  {\n+    const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);\n+    __ mov(rscratch1, table_addr);\n+    __ ldr(lr, Address(rscratch1, index, Address::lsl(3)));\n+  }\n+}\n+\n@@ -2329,1 +2400,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/*unused*\/) {\n@@ -2350,1 +2421,1 @@\n-  size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+  size_t index_size = sizeof(u2);\n@@ -3170,1 +3241,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -3441,1 +3512,1 @@\n-  prepare_invoke(byte_no, rmethod, r0);\n+  load_invokedynamic_entry(rmethod);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":76,"deletions":5,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -130,0 +130,1 @@\n+  void load_resolved_indy_entry(Register cache, Register index);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -481,0 +481,12 @@\n+}\n+\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+\n+  \/\/ Get address of invokedynamic array\n+  ld_ptr(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset()), R27_constPoolCache);\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  sldi(index, index, log2i_exact(sizeof(ResolvedIndyEntry)));\n+  addi(index, index, Array<ResolvedIndyEntry>::base_offset_in_bytes());\n+  add(cache, cache, index);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2015, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2015, 2023 SAP SE. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -56,1 +57,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -645,1 +646,10 @@\n-  __ get_cache_and_index_at_bcp(cache, 1, index_size);\n+  if (index_size == sizeof(u4)) {\n+    __ get_cache_index_at_bcp(size, 1, index_size);  \/\/ Load index.\n+    \/\/ Get address of invokedynamic array\n+    __ ld_ptr(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset()), R27_constPoolCache);\n+    \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+    __ sldi(size, size, log2i_exact(sizeof(ResolvedIndyEntry)));\n+    __ add(cache, cache, size);\n+    __ lhz(size, Array<ResolvedIndyEntry>::base_offset_in_bytes() + in_bytes(ResolvedIndyEntry::num_parameters_offset()), cache);\n+  } else {\n+    __ get_cache_and_index_at_bcp(cache, 1, index_size);\n@@ -647,1 +657,1 @@\n-  \/\/ Get least significant byte of 64 bit value:\n+    \/\/ Get least significant byte of 64 bit value:\n@@ -649,1 +659,1 @@\n-  __ lbz(size, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()), cache);\n+    __ lbz(size, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()), cache);\n@@ -651,1 +661,1 @@\n-  __ lbz(size, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()) + 7, cache);\n+    __ lbz(size, in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()) + 7, cache);\n@@ -653,0 +663,1 @@\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2013, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2013, 2023 SAP SE. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -52,1 +53,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -2276,0 +2277,67 @@\n+\/\/ Sets registers:\n+\/\/   `method`   Target method for invokedynamic\n+\/\/   R3_RET     Return address for invoke\n+\/\/\n+\/\/ Kills: R11, R21, R30, R31\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  \/\/ setup registers\n+  const Register ret_addr = R3_RET;\n+  const Register appendix = R30;\n+  const Register cache    = R31;\n+  const Register index    = R21_tmp1;\n+  const Register tmp      = R11_scratch1;\n+  assert_different_registers(method, appendix, cache, index, tmp);\n+\n+  Label resolved;\n+\n+  __ load_resolved_indy_entry(cache, index);\n+  __ ld_ptr(method, in_bytes(ResolvedIndyEntry::method_offset()), cache);\n+\n+  \/\/ The invokedynamic is unresolved iff method is NULL\n+  __ cmpdi(CCR0, method, 0);\n+  __ bne(CCR0, resolved);\n+\n+  Bytecodes::Code code = bytecode();\n+\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ li(R4_ARG2, code);\n+  __ call_VM(noreg, entry, R4_ARG2, true);\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  __ ld_ptr(method, in_bytes(ResolvedIndyEntry::method_offset()), cache);\n+\n+  DEBUG_ONLY(__ cmpdi(CCR0, method, 0));\n+  __ asm_assert_ne(\"Should be resolved by now\");\n+  __ bind(resolved);\n+  __ isync(); \/\/ Order load wrt. succeeding loads.\n+\n+  Label L_no_push;\n+  \/\/ Check if there is an appendix\n+  __ lbz(index, in_bytes(ResolvedIndyEntry::flags_offset()), cache);\n+  __ rldicl_(R0, index, 64-ResolvedIndyEntry::has_appendix_shift, 63);\n+  __ beq(CCR0, L_no_push);\n+\n+  \/\/ Get appendix\n+  __ lhz(index, in_bytes(ResolvedIndyEntry::resolved_references_index_offset()), cache);\n+  \/\/ Push the appendix as a trailing parameter\n+  assert(cache->is_nonvolatile(), \"C-call in resolve_oop_handle\");\n+  __ load_resolved_reference_at_index(appendix, index, \/* temp *\/ ret_addr, tmp);\n+  __ verify_oop(appendix);\n+  __ push_ptr(appendix);   \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  \/\/ load return address\n+  {\n+    Register Rtable_addr = tmp;\n+    address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);\n+\n+    \/\/ compute return type\n+    __ lbz(index, in_bytes(ResolvedIndyEntry::result_type_offset()), cache);\n+    __ load_dispatch_table(Rtable_addr, (address*)table_addr);\n+    __ sldi(index, index, LogBytesPerWord);\n+    \/\/ Get return address.\n+    __ ldx(ret_addr, Rtable_addr, index);\n+  }\n+}\n+\n@@ -2296,1 +2364,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/*unused*\/) {\n@@ -2313,1 +2381,1 @@\n-    resolve_cache_and_index(byte_no, Rcache, \/* temp *\/ Rmethod, is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+    resolve_cache_and_index(byte_no, Rcache, \/* temp *\/ Rmethod, sizeof(u2));\n@@ -3330,1 +3398,1 @@\n-  const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;\n+  const bool is_invokedynamic    = false; \/\/ should not reach here with invokedynamic\n@@ -3346,1 +3414,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -3656,6 +3724,4 @@\n-  const Register Rret_addr = R3_ARG1,\n-                 Rflags    = R31,\n-                 Rmethod   = R22_tmp2,\n-                 Rscratch1 = R30,\n-                 Rscratch2 = R11_scratch1,\n-                 Rscratch3 = R12_scratch2;\n+  const Register Rret_addr = R3_RET;\n+  const Register Rmethod   = R22_tmp2;\n+  const Register Rscratch1 = R30;\n+  const Register Rscratch2 = R11_scratch1;\n@@ -3663,1 +3729,2 @@\n-  prepare_invoke(byte_no, Rmethod, Rret_addr, Rscratch1, noreg, Rflags, Rscratch2, Rscratch3);\n+  \/\/ Returns target method in Rmethod and return address in R3_RET. Kills all argument registers.\n+  load_invokedynamic_entry(Rmethod);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":80,"deletions":13,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1919,0 +1919,12 @@\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+  \/\/ Get address of invokedynamic array\n+  ld(cache, Address(xcpool, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  slli(index, index, log2i_exact(sizeof(ResolvedIndyEntry)));\n+  add(cache, cache, Array<ResolvedIndyEntry>::base_offset_in_bytes());\n+  add(cache, cache, index);\n+  la(cache, Address(cache, 0));\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -302,0 +302,2 @@\n+  void load_resolved_indy_entry(Register cache, Register index);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,4 +443,2 @@\n-  \/\/ Pop N words from the stack\n-  __ get_cache_and_index_at_bcp(x11, x12, 1, index_size);\n-  __ ld(x11, Address(x11, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n-  __ andi(x11, x11, ConstantPoolCacheEntry::parameter_size_mask);\n+  const Register cache = x11;\n+  const Register index = x12;\n@@ -448,1 +446,12 @@\n-  __ shadd(esp, x11, esp, t0, 3);\n+  if (index_size == sizeof(u4)) {\n+    __ load_resolved_indy_entry(cache, index);\n+    __ load_unsigned_short(cache, Address(cache, in_bytes(ResolvedIndyEntry::num_parameters_offset())));\n+    __ shadd(esp, cache, esp, t0, 3);\n+  } else {\n+    \/\/ Pop N words from the stack\n+    __ get_cache_and_index_at_bcp(x11, x12, 1, index_size);\n+    __ ld(x11, Address(x11, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+    __ andi(x11, x11, ConstantPoolCacheEntry::parameter_size_mask);\n+\n+    __ shadd(esp, x11, esp, t0, 3);\n+  }\n@@ -453,2 +462,2 @@\n- __ check_and_handle_popframe(xthread);\n- __ check_and_handle_earlyret(xthread);\n+  __ check_and_handle_popframe(xthread);\n+  __ check_and_handle_earlyret(xthread);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2218,0 +2218,72 @@\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  \/\/ setup registers\n+  const Register appendix = x10;\n+  const Register cache = x12;\n+  const Register index = x13;\n+  assert_different_registers(method, appendix, cache, index, xcpool);\n+\n+  __ save_bcp();\n+\n+  Label resolved;\n+\n+  __ load_resolved_indy_entry(cache, index);\n+  __ membar(MacroAssembler::AnyAny);\n+  __ ld(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+\n+  \/\/ Compare the method to zero\n+  __ andr(t0, method, method);\n+  __ bnez(t0, resolved);\n+\n+  Bytecodes::Code code = bytecode();\n+\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mv(method, code); \/\/ this is essentially Bytecodes::_invokedynamic\n+  __ call_VM(noreg, entry, method); \/\/ Example uses temp = rbx. In this case rbx is method\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  __ membar(MacroAssembler::AnyAny);\n+  __ ld(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+\n+#ifdef ASSERT\n+  __ andr(t0, method, method);\n+  __ bnez(t0, resolved);\n+  __ stop(\"Should be resolved by now\");\n+#endif \/\/ ASSERT\n+  __ bind(resolved);\n+\n+  Label L_no_push;\n+  \/\/ Check if there is an appendix\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::flags_offset())));\n+  __ slli(index, index, XLEN - (ResolvedIndyEntry::has_appendix_shift + 1));\n+  __ srli(index, index, XLEN - 1);\n+  __ andr(t0, index, index);\n+  __ beqz(t0, L_no_push);\n+\n+  \/\/ Get appendix\n+  __ load_unsigned_short(index, Address(cache, in_bytes(ResolvedIndyEntry::resolved_references_index_offset())));\n+  \/\/ Push the appendix as a trailing parameter\n+  \/\/ since the parameter_size includes it.\n+  __ push_reg(method);\n+  __ mv(method, index);\n+  __ load_resolved_reference_at_index(appendix, method);\n+  __ verify_oop(appendix);\n+  __ pop_reg(method);\n+  __ push_reg(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  \/\/ compute return type\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::result_type_offset())));\n+  \/\/ load return address\n+  \/\/ Return address is loaded into link register(lr) and not pushed to the stack\n+  \/\/ like x86\n+  {\n+    const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);\n+    __ mv(t0, table_addr);\n+    __ shadd(t0, index, t0, index, 3);\n+    __ ld(ra, Address(t0, 0));\n+  }\n+}\n+\n@@ -2224,1 +2296,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/*unused*\/) {\n@@ -2244,1 +2316,1 @@\n-  const size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+  size_t index_size = sizeof(u2);\n@@ -3089,1 +3161,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -3350,1 +3422,1 @@\n-  prepare_invoke(byte_no, xmethod, x10);\n+  load_invokedynamic_entry(xmethod);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":76,"deletions":4,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2068,0 +2068,14 @@\n+\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+  \/\/ Get address of invokedynamic array\n+  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));\n+  movptr(cache, Address(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+  if (is_power_of_2(sizeof(ResolvedIndyEntry))) {\n+    shll(index, log2i_exact(sizeof(ResolvedIndyEntry))); \/\/ Scale index by power of 2\n+  } else {\n+    imull(index, index, sizeof(ResolvedIndyEntry)); \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  }\n+  lea(cache, Address(cache, index, Address::times_1, Array<ResolvedIndyEntry>::base_offset_in_bytes()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -309,0 +309,2 @@\n+  void load_resolved_indy_entry(Register cache, Register index);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,6 +223,11 @@\n-  __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n-\n-  const Register flags = cache;\n-  __ movl(flags, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n-  __ andl(flags, ConstantPoolCacheEntry::parameter_size_mask);\n-  __ lea(rsp, Address(rsp, flags, Interpreter::stackElementScale()));\n+  if (index_size == sizeof(u4)) {\n+    __ load_resolved_indy_entry(cache, index);\n+    __ load_unsigned_short(cache, Address(cache, in_bytes(ResolvedIndyEntry::num_parameters_offset())));\n+    __ lea(rsp, Address(rsp, cache, Interpreter::stackElementScale()));\n+  } else {\n+    __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n+    Register flags = cache;\n+    __ movl(flags, Address(cache, index, Address::times_ptr, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+    __ andl(flags, ConstantPoolCacheEntry::parameter_size_mask);\n+    __ lea(rsp, Address(rsp, flags, Interpreter::stackElementScale()));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2724,0 +2724,68 @@\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  \/\/ setup registers\n+  const Register appendix = rax;\n+  const Register cache = rcx;\n+  const Register index = rdx;\n+  assert_different_registers(method, appendix, cache, index);\n+\n+  __ save_bcp();\n+\n+  Label resolved;\n+\n+  __ load_resolved_indy_entry(cache, index);\n+  __ movptr(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+\n+  \/\/ Compare the method to zero\n+  __ testptr(method, method);\n+  __ jcc(Assembler::notZero, resolved);\n+\n+  Bytecodes::Code code = bytecode();\n+\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ movl(method, code); \/\/ this is essentially Bytecodes::_invokedynamic\n+  __ call_VM(noreg, entry, method);\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  __ movptr(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+\n+#ifdef ASSERT\n+  __ testptr(method, method);\n+  __ jcc(Assembler::notZero, resolved);\n+  __ stop(\"Should be resolved by now\");\n+#endif \/\/ ASSERT\n+  __ bind(resolved);\n+\n+  Label L_no_push;\n+  \/\/ Check if there is an appendix\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::flags_offset())));\n+  __ testl(index, (1 << ResolvedIndyEntry::has_appendix_shift));\n+  __ jcc(Assembler::zero, L_no_push);\n+\n+  \/\/ Get appendix\n+  __ load_unsigned_short(index, Address(cache, in_bytes(ResolvedIndyEntry::resolved_references_index_offset())));\n+  \/\/ Push the appendix as a trailing parameter\n+  \/\/ since the parameter_size includes it.\n+  __ load_resolved_reference_at_index(appendix, index);\n+  __ verify_oop(appendix);\n+  __ push(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  \/\/ compute return type\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedIndyEntry::result_type_offset())));\n+  \/\/ load return address\n+  {\n+    const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);\n+    ExternalAddress table(table_addr);\n+#ifdef _LP64\n+    __ lea(rscratch1, table);\n+    __ movptr(index, Address(rscratch1, index, Address::times_ptr));\n+#else\n+    __ movptr(index, ArrayAddress(table, Address(noreg, index, Address::times_ptr)));\n+#endif \/\/ _LP64\n+  }\n+\n+  \/\/ push return address\n+  __ push(index);\n+}\n+\n@@ -2730,1 +2798,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/*unused*\/) {\n@@ -2746,1 +2814,1 @@\n-  size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+  size_t index_size = sizeof(u2);\n@@ -3573,1 +3641,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -3896,2 +3964,1 @@\n-  prepare_invoke(byte_no, rbx_method, rax_callsite);\n-\n+  load_invokedynamic_entry(rbx_method);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":73,"deletions":6,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1065,3 +1065,2 @@\n-        ConstantPoolCacheEntry* cpce = pool->invokedynamic_cp_cache_entry_at(index);\n-        cpce->set_dynamic_call(pool, info);\n-        appendix = Handle(current, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n+        int indy_index = pool->decode_invokedynamic_index(index);\n+        appendix = Handle(current, pool->cache()->set_dynamic_call(info, indy_index));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -573,4 +573,2 @@\n-    for (int cpcindex = 0; cpcindex < cpcache->length(); cpcindex ++) {\n-      int indy_index = ConstantPool::encode_invokedynamic_index(cpcindex);\n-      ConstantPoolCacheEntry* cpce = cpcache->entry_at(cpcindex);\n-      int pool_index = cpce->constant_pool_index();\n+    for (int indy_index = 0; indy_index < cpcache->resolved_indy_entries_length(); indy_index++) {\n+      int pool_index = cpcache->resolved_indy_entry_at(indy_index)->constant_pool_index();\n@@ -578,19 +576,20 @@\n-      if (pool->tag_at(pool_index).is_invoke_dynamic()) {\n-        BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n-        Handle bsm = bootstrap_specifier.resolve_bsm(CHECK);\n-        if (!SystemDictionaryShared::is_supported_invokedynamic(&bootstrap_specifier)) {\n-          log_debug(cds, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n-          continue;\n-        }\n-        bool matched = is_matching_cp_entry(pool, pool_index, CHECK);\n-        if (matched) {\n-          found = true;\n-          CallInfo info;\n-          bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, CHECK);\n-          if (!is_done) {\n-            \/\/ resolve it\n-            Handle recv;\n-            LinkResolver::resolve_invoke(info, recv, pool, indy_index, Bytecodes::_invokedynamic, CHECK);\n-            break;\n-          }\n-          cpce->set_dynamic_call(pool, info);\n+      BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n+      Handle bsm = bootstrap_specifier.resolve_bsm(CHECK);\n+      if (!SystemDictionaryShared::is_supported_invokedynamic(&bootstrap_specifier)) {\n+        log_debug(cds, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n+        continue;\n+      }\n+      bool matched = is_matching_cp_entry(pool, pool_index, CHECK);\n+      if (matched) {\n+        found = true;\n+        CallInfo info;\n+        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(info, CHECK);\n+        if (!is_done) {\n+          \/\/ resolve it\n+          Handle recv;\n+          LinkResolver::resolve_invoke(info,\n+                                       recv,\n+                                       pool,\n+                                       ConstantPool::encode_invokedynamic_index(indy_index),\n+                                       Bytecodes::_invokedynamic, CHECK);\n+          break;\n@@ -598,0 +597,1 @@\n+        cpcache->set_dynamic_call(info, indy_index);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -875,2 +875,0 @@\n-    ConstantPoolCacheEntry* cpce = cpool->invokedynamic_cp_cache_entry_at(index);\n-    bool is_resolved = !cpce->is_f1_null();\n@@ -884,5 +882,6 @@\n-\n-    if (is_resolved) {\n-      \/\/ Get the invoker Method* from the constant pool.\n-      \/\/ (The appendix argument, if any, will be noted in the method's signature.)\n-      Method* adapter = cpce->f1_as_method();\n+    int indy_index = cpool->decode_invokedynamic_index(index);\n+    assert (indy_index >= 0, \"should be\");\n+    assert(indy_index < cpool->cache()->resolved_indy_entries_length(), \"impossible\");\n+    Method* adapter = cpool->resolved_indy_entry_at(indy_index)->method();\n+    \/\/ Resolved if the adapter is non null.\n+    if (adapter != nullptr) {\n@@ -1525,2 +1524,3 @@\n-  ConstantPoolCacheEntry* cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(indy_index);\n-  if (cp_cache_entry->is_resolved(Bytecodes::_invokedynamic)) {\n+  int index = cp->decode_invokedynamic_index(indy_index);\n+  ResolvedIndyEntry* indy_info = cp->resolved_indy_entry_at(index);\n+  if (indy_info->method() != nullptr) {\n@@ -1528,1 +1528,1 @@\n-    Method* adapter = cp_cache_entry->f1_as_method();\n+    Method* adapter = indy_info->method();\n@@ -1531,1 +1531,1 @@\n-    oop appendix = cp_cache_entry->appendix_if_resolved(cp);\n+    oop appendix = cp->resolved_reference_from_indy(index);\n@@ -1537,2 +1537,2 @@\n-    int pool_index = cp_cache_entry->constant_pool_index();\n-    BootstrapInfo bootstrap_specifier(cp, pool_index, indy_index);\n+    int pool_index = indy_info->constant_pool_index();\n+    BootstrapInfo bootstrap_specifier(cp, pool_index, index);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -413,0 +413,9 @@\n+\n+      \/\/ ResolvedIndyEntry and ConstantPoolCacheEntry must currently coexist.\n+      \/\/ To address this, the variables below contain the values that *might*\n+      \/\/ be used to avoid multiple blocks of similar code. When CPCE is obsoleted\n+      \/\/ these can be removed\n+      oop appendix = nullptr;\n+      Method* adapter_method = nullptr;\n+      int pool_index = 0;\n+\n@@ -414,2 +423,6 @@\n-        cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(index);\n-        cp_cache_entry->set_dynamic_call(cp, callInfo);\n+        index = cp->decode_invokedynamic_index(index);\n+        cp->cache()->set_dynamic_call(callInfo, index);\n+\n+        appendix = cp->resolved_reference_from_indy(index);\n+        adapter_method = cp->resolved_indy_entry_at(index)->method();\n+        pool_index = cp->resolved_indy_entry_at(index)->constant_pool_index();\n@@ -424,0 +437,4 @@\n+\n+        appendix = cp_cache_entry->appendix_if_resolved(cp);\n+        adapter_method = cp_cache_entry->f1_as_method();\n+        pool_index = cp_cache_entry->constant_pool_index();\n@@ -430,1 +447,1 @@\n-        obj = cp_cache_entry->appendix_if_resolved(cp);\n+        obj = appendix;\n@@ -436,1 +453,1 @@\n-        Method* adapter = cp_cache_entry->f1_as_method();\n+        Method* adapter = adapter_method;\n@@ -443,1 +460,0 @@\n-        int pool_index = cp_cache_entry->constant_pool_index();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -264,2 +264,2 @@\n-        int method_index = invoke_bc.get_index_u4(code);\n-        return cpool->invokedynamic_cp_cache_entry_at(method_index)->is_f1_null();\n+        int method_index = cpool->decode_invokedynamic_index(invoke_bc.get_index_u4(code));\n+        return cpool->resolved_indy_entry_at(method_index)->is_resolved();\n@@ -397,1 +397,2 @@\n-        method->constants()->invokedynamic_cp_cache_entry_at(index)->set_parameter_size(callee_parameters);\n+        int indy_index = method->constants()->decode_invokedynamic_index(index);\n+        method->constants()->resolved_indy_entry_at(indy_index)->set_num_parameters(callee_parameters);\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  assert(indy_index == -1 || pool->invokedynamic_bootstrap_ref_index_at(indy_index) == bss_index, \"invalid bootstrap specifier index\");\n+  assert(indy_index == -1 || pool->resolved_indy_entry_at(indy_index)->constant_pool_index() == bss_index, \"invalid bootstrap specifier index\");\n@@ -66,4 +66,5 @@\n-  ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();\n-  if (!cpce->is_f1_null()) {\n-    methodHandle method(     THREAD, cpce->f1_as_method());\n-    Handle       appendix(   THREAD, cpce->appendix_if_resolved(_pool));\n+  \/\/ Check if method is not null\n+  ResolvedIndyEntry* indy_entry = _pool->resolved_indy_entry_at(_indy_index);\n+  if (indy_entry->method() != nullptr) {\n+    methodHandle method(THREAD, indy_entry->method());\n+    Handle appendix(THREAD, _pool->resolved_reference_from_indy(_indy_index));\n@@ -73,3 +74,3 @@\n-  } else if (cpce->indy_resolution_failed()) {\n-    int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);\n-    ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false);\n+  } else if (indy_entry->resolution_failed()) {\n+    int encoded_index = ResolutionErrorTable::encode_cpcache_index(ConstantPool::encode_invokedynamic_index(_indy_index));\n+    ConstantPool::throw_resolution_error(_pool, encoded_index, CHECK_false); \/\/ Doesn't necessarily need to be resolved yet\n@@ -213,6 +214,5 @@\n-  ConstantPoolCacheEntry* cpce = invokedynamic_cp_cache_entry();\n-  int encoded_index = ResolutionErrorTable::encode_cpcache_index(_indy_index);\n-  bool recorded_res_status = cpce->save_and_throw_indy_exc(_pool, _bss_index,\n-                                                           encoded_index,\n-                                                           pool()->tag_at(_bss_index),\n-                                                           CHECK_false);\n+  assert(_indy_index >= 0, \"Indy index must be decoded by now\");\n+  bool recorded_res_status = _pool->cache()->save_and_throw_indy_exc(_pool, _bss_index,\n+                                                                     _indy_index,\n+                                                                     pool()->tag_at(_bss_index),\n+                                                                     CHECK_false);\n@@ -232,3 +232,3 @@\n-  if (_indy_index != -1)\n-    os::snprintf_checked(what, sizeof(what), \"indy#%d\", decode_indy_index());\n-  else\n+  if (_indy_index > -1) {\n+    os::snprintf_checked(what, sizeof(what), \"indy#%d\", _indy_index);\n+  } else {\n@@ -236,0 +236,1 @@\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -85,6 +85,0 @@\n-  \/\/ CP cache entry for call site (indy only)\n-  ConstantPoolCacheEntry* invokedynamic_cp_cache_entry() const {\n-    assert(is_method_call(), \"\");\n-    return _pool->invokedynamic_cp_cache_entry_at(_indy_index);\n-  }\n-\n","filename":"src\/hotspot\/share\/interpreter\/bootstrapInfo.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/resolvedIndyEntry.hpp\"\n@@ -162,1 +163,1 @@\n-  \/\/ at the same time it allocates per-call-site CP cache entries.\n+  \/\/ at the same time it allocates per-call-site resolved indy entries.\n@@ -171,1 +172,5 @@\n-  return cpcache_entry()->constant_pool_index();\n+  if (invoke_code() == Bytecodes::_invokedynamic) {\n+    return resolved_indy_entry()->constant_pool_index();\n+  } else {\n+    return cpcache_entry()->constant_pool_index();\n+  }\n@@ -176,0 +181,1 @@\n+  assert(invoke_code() != Bytecodes::_invokedynamic, \"should not call this\");\n@@ -179,0 +185,6 @@\n+ResolvedIndyEntry* Bytecode_member_ref::resolved_indy_entry() const {\n+  int index = this->index();\n+  assert(invoke_code() == Bytecodes::_invokedynamic, \"should not call this\");\n+  return cpcache()->resolved_indy_entry_at(ConstantPool::decode_invokedynamic_index(index));\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+  ResolvedIndyEntry* resolved_indy_entry() const;\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,7 @@\n-inline bool Bytecode_invoke::has_appendix() { return cpcache_entry()->has_appendix(); }\n+inline bool Bytecode_invoke::has_appendix() {\n+  if (invoke_code() == Bytecodes::_invokedynamic) {\n+    return resolved_indy_entry()->has_appendix();\n+  } else {\n+    return cpcache_entry()->has_appendix();\n+  }\n+}\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.inline.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -428,3 +428,4 @@\n-    int indy_index = orig_i;\n-    int cpc_index = constants->invokedynamic_cp_cache_index(indy_index);\n-    print_cpcache_entry(cpc_index, st);\n+    int indy_index = constants->decode_invokedynamic_index(orig_i);\n+    ResolvedIndyEntry* indy_entry = constants->resolved_indy_entry_at(indy_index);\n+    st->print(\"  ResolvedIndyEntry: \");\n+    indy_entry->print_on(st);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -950,2 +950,1 @@\n-  ConstantPoolCacheEntry* cp_cache_entry = pool->invokedynamic_cp_cache_entry_at(index);\n-  cp_cache_entry->set_dynamic_call(pool, info);\n+  pool->cache()->set_dynamic_call(info, pool->decode_invokedynamic_index(index));\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1766,2 +1766,2 @@\n-  ConstantPoolCacheEntry* cpce = pool->invokedynamic_cp_cache_entry_at(indy_index);\n-  int pool_index = cpce->constant_pool_index();\n+  int index = pool->decode_invokedynamic_index(indy_index);\n+  int pool_index = pool->resolved_indy_entry_at(index)->constant_pool_index();\n@@ -1770,1 +1770,1 @@\n-  BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);\n+  BootstrapInfo bootstrap_specifier(pool, pool_index, index);\n@@ -1782,2 +1782,2 @@\n-  \/\/ method's CP index for the CONSTANT_MethodHandle_info.  So, there is no need to\n-  \/\/ set the indy_rf flag since any subsequent invokedynamic instruction which shares\n+  \/\/ method's CP index for the CONSTANT_MethodHandle_info.\n+  \/\/ Any subsequent invokedynamic instruction which shares\n@@ -1796,2 +1796,2 @@\n-  \/\/ the relevant CPCE::f1 field.  This is done by the caller\n-  \/\/ of this method, via CPCE::set_dynamic_call, which uses\n+  \/\/ the relevant ResolvedIndyEntry::method field.  This is done by the caller\n+  \/\/ of this method, via CPC::set_dynamic_call, which uses\n@@ -1799,1 +1799,1 @@\n-  \/\/ to CPCE state, including f1.\n+  \/\/ to ResolvedIndyEntry state, including method.\n@@ -1830,9 +1830,9 @@\n-     bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);\n-     if (!recorded_res_status) {\n-       \/\/ Another thread got here just before we did.  So, either use the method\n-       \/\/ that it resolved or throw the LinkageError exception that it threw.\n-       bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);\n-       if (is_done) return;\n-     }\n-     assert(bootstrap_specifier.invokedynamic_cp_cache_entry()->indy_resolution_failed(),\n-            \"Resolution failure flag wasn't set\");\n+    bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);\n+    if (!recorded_res_status) {\n+      \/\/ Another thread got here just before we did.  So, either use the method\n+      \/\/ that it resolved or throw the LinkageError exception that it threw.\n+      bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);\n+      if (is_done) return;\n+    }\n+    assert(bootstrap_specifier.pool()->resolved_indy_entry_at(bootstrap_specifier.indy_index())->resolution_failed(),\n+          \"Resolution should have failed\");\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"oops\/constantPool.hpp\"\n@@ -102,2 +101,1 @@\n-                                  _invokedynamic_cp_cache_map,\n-                                  _invokedynamic_references_map, CHECK);\n+                                  _invokedynamic_references_map, _initialized_indy_entries, CHECK);\n@@ -272,6 +270,5 @@\n-    int cache_index = add_invokedynamic_cp_cache_entry(cp_index);\n-    int resolved_index = add_invokedynamic_resolved_references_entry(cp_index, cache_index);\n-    \/\/ Replace the trailing four bytes with a CPC index for the dynamic\n-    \/\/ call site.  Unlike other CPC entries, there is one per bytecode,\n-    \/\/ not just one per distinct CP entry.  In other words, the\n-    \/\/ CPC-to-CP relation is many-to-one for invokedynamic entries.\n+    int resolved_index = add_invokedynamic_resolved_references_entry(cp_index, -1); \/\/ Indy no longer has a CPCE\n+    \/\/ Replace the trailing four bytes with an index to the array of\n+    \/\/ indy resolution information in the CPC. There is one entry for\n+    \/\/ each bytecode, even if they make the same call. In other words,\n+    \/\/ the CPC-to-CP relation is many-to-one for invokedynamic entries.\n@@ -283,5 +280,5 @@\n-    Bytes::put_native_u4(p, ConstantPool::encode_invokedynamic_index(cache_index));\n-    \/\/ add the bcp in case we need to patch this bytecode if we also find a\n-    \/\/ invokespecial\/InterfaceMethodref in the bytecode stream\n-    _patch_invokedynamic_bcps->push(p);\n-    _patch_invokedynamic_refs->push(resolved_index);\n+    Bytes::put_native_u4(p, ConstantPool::encode_invokedynamic_index(_invokedynamic_index));\n+    _invokedynamic_index++;\n+\n+    \/\/ Collect invokedynamic information before creating ResolvedInvokeDynamicInfo array\n+    _initialized_indy_entries.push(ResolvedIndyEntry((u2)resolved_index, (u2)cp_index));\n@@ -289,0 +286,1 @@\n+    \/\/ Should do nothing since we are not patching this bytecode\n@@ -294,2 +292,1 @@\n-    int adjustment = cp_cache_delta() + _first_iteration_cp_cache_limit;\n-    int cp_index = invokedynamic_cp_cache_entry_pool_index(cache_index - adjustment);\n+    int cp_index = _initialized_indy_entries.at(cache_index).constant_pool_index();\n@@ -303,26 +300,0 @@\n-void Rewriter::patch_invokedynamic_bytecodes() {\n-  \/\/ If the end of the cp_cache is the same as after initializing with the\n-  \/\/ cpool, nothing needs to be done.  Invokedynamic bytecodes are at the\n-  \/\/ correct offsets. ie. no invokespecials added\n-  int delta = cp_cache_delta();\n-  if (delta > 0) {\n-    int length = _patch_invokedynamic_bcps->length();\n-    assert(length == _patch_invokedynamic_refs->length(),\n-           \"lengths should match\");\n-    for (int i = 0; i < length; i++) {\n-      address p = _patch_invokedynamic_bcps->at(i);\n-      int cache_index = ConstantPool::decode_invokedynamic_index(\n-                          Bytes::get_native_u4(p));\n-      Bytes::put_native_u4(p, ConstantPool::encode_invokedynamic_index(cache_index + delta));\n-\n-      \/\/ invokedynamic resolved references map also points to cp cache and must\n-      \/\/ add delta to each.\n-      int resolved_index = _patch_invokedynamic_refs->at(i);\n-        assert(_invokedynamic_references_map.at(resolved_index) == cache_index,\n-             \"should be the same index\");\n-        _invokedynamic_references_map.at_put(resolved_index, cache_index + delta);\n-    }\n-  }\n-}\n-\n-\n@@ -572,4 +543,0 @@\n-\n-  \/\/ May have to fix invokedynamic bytecodes if invokestatic\/InterfaceMethodref\n-  \/\/ entries had to be added.\n-  patch_invokedynamic_bytecodes();\n@@ -600,1 +567,1 @@\n-    _invokedynamic_cp_cache_map(cpool->length() \/ 4)\n+    _invokedynamic_index(0)\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":14,"deletions":47,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include \"oops\/constantPool.hpp\"\n+#include \"oops\/resolvedIndyEntry.hpp\"\n@@ -47,0 +49,1 @@\n+  int                 _invokedynamic_index;\n@@ -48,10 +51,3 @@\n-  \/\/ For mapping invokedynamic bytecodes, which are discovered during method\n-  \/\/ scanning.  The invokedynamic entries are added at the end of the cpCache.\n-  \/\/ If there are any invokespecial\/InterfaceMethodref special case bytecodes,\n-  \/\/ these entries are added before invokedynamic entries so that the\n-  \/\/ invokespecial bytecode 16 bit index doesn't overflow.\n-  GrowableArray<int>      _invokedynamic_cp_cache_map;\n-\n-  \/\/ For patching.\n-  GrowableArray<address>* _patch_invokedynamic_bcps;\n-  GrowableArray<int>*     _patch_invokedynamic_refs;\n+  \/\/ For collecting information about invokedynamic bytecodes before resolution\n+  \/\/ With this, we can know how many indy calls there are and resolve them later\n+  GrowableArray<ResolvedIndyEntry> _initialized_indy_entries;\n@@ -73,5 +69,0 @@\n-\n-    \/\/ invokedynamic specific fields\n-    _invokedynamic_cp_cache_map.trunc_to(0);\n-    _patch_invokedynamic_bcps = new GrowableArray<address>(length \/ 4);\n-    _patch_invokedynamic_refs = new GrowableArray<int>(length \/ 4);\n@@ -114,16 +105,0 @@\n-  int add_invokedynamic_cp_cache_entry(int cp_index) {\n-    assert(_pool->tag_at(cp_index).value() == JVM_CONSTANT_InvokeDynamic, \"use non-indy version\");\n-    assert(_first_iteration_cp_cache_limit >= 0, \"add indy cache entries after first iteration\");\n-    \/\/ add to the invokedynamic index map.\n-    int cache_index = _invokedynamic_cp_cache_map.append(cp_index);\n-    \/\/ do not update _cp_map, since the mapping is one-to-many\n-    assert(invokedynamic_cp_cache_entry_pool_index(cache_index) == cp_index, \"\");\n-    \/\/ this index starts at one but in the bytecode it's appended to the end.\n-    return cache_index + _first_iteration_cp_cache_limit;\n-  }\n-\n-  int invokedynamic_cp_cache_entry_pool_index(int cache_index) {\n-    int cp_index = _invokedynamic_cp_cache_map.at(cache_index);\n-    return cp_index;\n-  }\n-\n@@ -167,1 +142,3 @@\n-    _invokedynamic_references_map.at_put_grow(ref_index, cache_index, -1);\n+    if (_pool->tag_at(cp_index).value() != JVM_CONSTANT_InvokeDynamic) {\n+      _invokedynamic_references_map.at_put_grow(ref_index, cache_index, -1);\n+    }\n@@ -195,2 +172,0 @@\n-  void patch_invokedynamic_bytecodes();\n-\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.hpp","additions":10,"deletions":35,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -269,0 +269,1 @@\n+  static void load_invokedynamic_entry(Register method);\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2250,8 +2250,3 @@\n-\n-        u4 index = Bytes::get_native_u4(pc+1);\n-        ConstantPoolCacheEntry* cache = cp->constant_pool()->invokedynamic_cp_cache_entry_at(index);\n-\n-        \/\/ We are resolved if the resolved_references array contains a non-null object (CallSite, etc.)\n-        \/\/ This kind of CP cache entry does not need to match the flags byte, because\n-        \/\/ there is a 1-1 relation between bytecode type and CP entry type.\n-        if (! cache->is_resolved((Bytecodes::Code) opcode)) {\n+        u4 index = cp->constant_pool()->decode_invokedynamic_index(Bytes::get_native_u4(pc+1)); \/\/ index is originally negative\n+        ResolvedIndyEntry* indy_info = cp->resolved_indy_entry_at(index);\n+        if (!indy_info->is_resolved()) {\n@@ -2260,1 +2255,1 @@\n-          cache = cp->constant_pool()->invokedynamic_cp_cache_entry_at(index);\n+          indy_info = cp->resolved_indy_entry_at(index); \/\/ get resolved entry\n@@ -2262,2 +2257,1 @@\n-\n-        Method* method = cache->f1_as_method();\n+        Method* method = indy_info->method();\n@@ -2266,1 +2260,1 @@\n-        if (cache->has_appendix()) {\n+        if (indy_info->has_appendix()) {\n@@ -2268,1 +2262,1 @@\n-          SET_STACK_OBJECT(cache->appendix_if_resolved(cp), 0);\n+          SET_STACK_OBJECT(cp->resolved_reference_from_indy(index), 0);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -655,0 +655,7 @@\n+  \/\/ Get the indy entry based on CP index\n+  int indy_index = -1;\n+  for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n+    if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n+      indy_index = i;\n+    }\n+  }\n@@ -656,1 +663,1 @@\n-  BootstrapInfo bootstrap_specifier(cp, index);\n+  BootstrapInfo bootstrap_specifier(cp, index, indy_index);\n@@ -1484,2 +1491,1 @@\n-  ConstantPoolCacheEntry* cp_cache_entry = cp->invokedynamic_cp_cache_entry_at(index);\n-  cp_cache_entry->set_dynamic_call(cp, callInfo);\n+  cp->cache()->set_dynamic_call(callInfo, index); \/\/ Index already decoded\n@@ -1534,2 +1540,4 @@\n-  if (cp_cache_entry->is_resolved(Bytecodes::_invokedynamic)) {\n-    return Bytecodes::_invokedynamic;\n+  if (cp->is_invokedynamic_index(index)) {\n+    if (cp->resolved_indy_entry_at(cp->decode_cpcache_index(index))->is_resolved()) {\n+      return Bytecodes::_invokedynamic;\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1877,7 +1877,3 @@\n-    ConstantPoolCacheEntry* cpce = cpool->invokedynamic_cp_cache_entry_at(index);\n-    bool is_resolved = !cpce->is_f1_null();\n-    if (is_resolved) {\n-      \/\/ Get the invoker Method* from the constant pool.\n-      \/\/ (The appendix argument, if any, will be noted in the method's signature.)\n-      Method* adapter = cpce->f1_as_method();\n-      return adapter;\n+    int indy_index = cpool->decode_invokedynamic_index(index);\n+    if (cpool->resolved_indy_entry_at(indy_index)->is_resolved()) {\n+      return cpool->resolved_indy_entry_at(indy_index)->method();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -639,3 +639,8 @@\n-  int cache_index = decode_cpcache_index(which, true);\n-  ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n-  return e->has_appendix();\n+  if (is_invokedynamic_index(which)) {\n+    int indy_index = decode_invokedynamic_index(which);\n+    return cpool->resolved_indy_entry_at(indy_index)->has_appendix();\n+  } else {\n+    int cache_index = decode_cpcache_index(which, true);\n+    ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n+    return e->has_appendix();\n+  }\n@@ -646,3 +651,8 @@\n-  int cache_index = decode_cpcache_index(which, true);\n-  ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n-  return e->appendix_if_resolved(cpool);\n+  if (is_invokedynamic_index(which)) {\n+    int indy_index = decode_invokedynamic_index(which);\n+    return cpool->resolved_reference_from_indy(indy_index);\n+  } else {\n+    int cache_index = decode_cpcache_index(which, true);\n+    ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n+    return e->appendix_if_resolved(cpool);\n+  }\n@@ -655,2 +665,6 @@\n-  ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n-  return e->has_local_signature();\n+  if (is_invokedynamic_index(which)) {\n+    return cpool->resolved_indy_entry_at(cache_index)->has_local_signature();\n+  } else {\n+    ConstantPoolCacheEntry* e = cpool->cache()->entry_at(cache_index);\n+    return e->has_local_signature();\n+  }\n@@ -674,1 +688,1 @@\n-      \/\/ Invokedynamic index is index into the constant pool cache\n+      \/\/ Invokedynamic index is index into the resolved indy array in the constant pool cache\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -259,14 +259,0 @@\n-\n-  \/\/ The invokedynamic points at a CP cache entry.  This entry points back\n-  \/\/ at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry\n-  \/\/ in the resolved_references array (which provides the appendix argument).\n-  int invokedynamic_cp_cache_index(int indy_index) const {\n-    assert(is_invokedynamic_index(indy_index), \"should be a invokedynamic index\");\n-    int cache_index = decode_invokedynamic_index(indy_index);\n-    return cache_index;\n-  }\n-  ConstantPoolCacheEntry* invokedynamic_cp_cache_entry_at(int indy_index) const {\n-    \/\/ decode index that invokedynamic points to.\n-    int cp_cache_index = invokedynamic_cp_cache_index(indy_index);\n-    return cache()->entry_at(cp_cache_index);\n-  }\n@@ -277,1 +263,1 @@\n-    return invokedynamic_cp_cache_entry_at(indy_index)->constant_pool_index();\n+    return cache()->resolved_indy_entry_at(decode_invokedynamic_index(indy_index))->constant_pool_index();\n@@ -930,0 +916,11 @@\n+\n+  \/\/ ResolvedIndyEntry getters\n+  ResolvedIndyEntry* resolved_indy_entry_at(int index) {\n+    return cache()->resolved_indy_entry_at(index);\n+  }\n+  int resolved_indy_entries_length() {\n+    return cache()->resolved_indy_entries_length();\n+  }\n+  oop resolved_reference_from_indy(int index) {\n+    return resolved_references()->obj_at(cache()->resolved_indy_entry_at(index)->resolved_references_index());\n+  }\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -346,4 +346,0 @@\n-void ConstantPoolCacheEntry::set_dynamic_call(const constantPoolHandle& cpool, const CallInfo &call_info) {\n-  set_method_handle_common(cpool, Bytecodes::_invokedynamic, call_info);\n-}\n-\n@@ -454,27 +450,0 @@\n-bool ConstantPoolCacheEntry::save_and_throw_indy_exc(\n-  const constantPoolHandle& cpool, int cpool_index, int index, constantTag tag, TRAPS) {\n-\n-  assert(HAS_PENDING_EXCEPTION, \"No exception got thrown!\");\n-  assert(PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass()),\n-         \"No LinkageError exception\");\n-\n-  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n-\n-  \/\/ if f1 is not null or the indy_resolution_failed flag is set then another\n-  \/\/ thread either succeeded in resolving the method or got a LinkageError\n-  \/\/ exception, before this thread was able to record its failure.  So, clear\n-  \/\/ this thread's exception and return false so caller can use the earlier\n-  \/\/ thread's result.\n-  if (!is_f1_null() || indy_resolution_failed()) {\n-    CLEAR_PENDING_EXCEPTION;\n-    return false;\n-  }\n-\n-  Symbol* error = PENDING_EXCEPTION->klass()->name();\n-  Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);\n-\n-  SystemDictionary::add_resolution_error(cpool, index, error, message);\n-  set_indy_resolution_failed();\n-  return true;\n-}\n-\n@@ -495,1 +464,0 @@\n-      case Bytecodes::_invokedynamic:\n@@ -498,0 +466,2 @@\n+      case Bytecodes::_invokedynamic:\n+        ShouldNotReachHere();\n@@ -647,2 +617,1 @@\n-    if (bytecode_1() == Bytecodes::_invokehandle ||\n-        bytecode_1() == Bytecodes::_invokedynamic) {\n+    if ((bytecode_1() == Bytecodes::_invokehandle)) {\n@@ -675,2 +644,3 @@\n-                                     const intStack& invokedynamic_index_map,\n-                                     const intStack& invokedynamic_map, TRAPS) {\n+                                     const intStack& invokedynamic_map,\n+                                     const GrowableArray<ResolvedIndyEntry> indy_entries,\n+                                     TRAPS) {\n@@ -678,1 +648,1 @@\n-  const int length = index_map.length() + invokedynamic_index_map.length();\n+  const int length = index_map.length();\n@@ -681,0 +651,11 @@\n+  \/\/ Initialize ResolvedIndyEntry array with available data\n+  Array<ResolvedIndyEntry>* resolved_indy_entries;\n+  if (indy_entries.length()) {\n+    resolved_indy_entries = MetadataFactory::new_array<ResolvedIndyEntry>(loader_data, indy_entries.length(), CHECK_NULL);\n+    for (int i = 0; i < indy_entries.length(); i++) {\n+      resolved_indy_entries->at_put(i, indy_entries.at(i));\n+    }\n+  } else {\n+    resolved_indy_entries = nullptr;\n+  }\n+\n@@ -682,1 +663,1 @@\n-    ConstantPoolCache(length, index_map, invokedynamic_index_map, invokedynamic_map);\n+              ConstantPoolCache(length, index_map, invokedynamic_map, resolved_indy_entries);\n@@ -686,1 +667,0 @@\n-                                   const intArray& invokedynamic_inverse_index_map,\n@@ -695,10 +675,0 @@\n-  \/\/ Append invokedynamic entries at the end\n-  int invokedynamic_offset = inverse_index_map.length();\n-  for (int i = 0; i < invokedynamic_inverse_index_map.length(); i++) {\n-    int offset = i + invokedynamic_offset;\n-    ConstantPoolCacheEntry* e = entry_at(offset);\n-    int original_index = invokedynamic_inverse_index_map.at(i);\n-    e->initialize_entry(original_index);\n-    assert(entry_at(offset) == e, \"sanity\");\n-  }\n-\n@@ -740,0 +710,6 @@\n+\n+  if (_resolved_indy_entries != nullptr) {\n+    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+      resolved_indy_entry_at(i)->remove_unshareable_info();\n+    }\n+  }\n@@ -753,0 +729,2 @@\n+    if (_resolved_indy_entries)\n+      MetadataFactory::free_array<ResolvedIndyEntry>(data, _resolved_indy_entries);\n@@ -784,0 +762,11 @@\n+  if (_resolved_indy_entries != nullptr) {\n+    for (int j = 0; j < _resolved_indy_entries->length(); j++) {\n+      Method* old_method = resolved_indy_entry_at(j)->method();\n+      if (old_method == nullptr || !old_method->is_old()) {\n+        continue;\n+      }\n+      Method* new_method = old_method->get_new_method();\n+      resolved_indy_entry_at(j)->adjust_method_entry(new_method);\n+      log_adjust(\"indy\", old_method, new_method, trace_name_printed);\n+    }\n+  }\n@@ -803,0 +792,12 @@\n+  if (_resolved_indy_entries) {\n+    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+      Method* m = resolved_indy_entry_at(i)->method();\n+      if (m != nullptr && !resolved_indy_entry_at(i)->check_no_old_or_obsolete_entry()) {\n+        log_trace(redefine, class, update, constantpool)\n+          (\"cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s\",\n+           constant_pool()->pool_holder()->external_name(), m->is_old(), m->is_obsolete(), m->external_name());\n+        return false;\n+      }\n+    }\n+  }\n+\n@@ -828,0 +829,89 @@\n+  if (_resolved_indy_entries != nullptr) {\n+    it->push(&_resolved_indy_entries, MetaspaceClosure::_writable);\n+  }\n+}\n+\n+bool ConstantPoolCache::save_and_throw_indy_exc(\n+  const constantPoolHandle& cpool, int cpool_index, int index, constantTag tag, TRAPS) {\n+\n+  assert(HAS_PENDING_EXCEPTION, \"No exception got thrown!\");\n+  assert(PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass()),\n+         \"No LinkageError exception\");\n+\n+  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n+\n+  \/\/ if the indy_info is resolved or the indy_resolution_failed flag is set then another\n+  \/\/ thread either succeeded in resolving the method or got a LinkageError\n+  \/\/ exception, before this thread was able to record its failure.  So, clear\n+  \/\/ this thread's exception and return false so caller can use the earlier\n+  \/\/ thread's result.\n+  if (resolved_indy_entry_at(index)->is_resolved() || resolved_indy_entry_at(index)->resolution_failed()) {\n+    CLEAR_PENDING_EXCEPTION;\n+    return false;\n+  }\n+\n+  Symbol* error = PENDING_EXCEPTION->klass()->name();\n+  Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);\n+\n+  int encoded_index = ResolutionErrorTable::encode_cpcache_index(\n+                          ConstantPool::encode_invokedynamic_index(index));\n+  SystemDictionary::add_resolution_error(cpool, encoded_index, error, message);\n+  resolved_indy_entry_at(index)->set_resolution_failed();\n+  return true;\n+}\n+\n+oop ConstantPoolCache::set_dynamic_call(const CallInfo &call_info, int index) {\n+  ResourceMark rm;\n+  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n+  assert(index >= 0, \"Indy index must be positive at this point\");\n+\n+  if (resolved_indy_entry_at(index)->method() != nullptr) {\n+    return constant_pool()->resolved_reference_from_indy(index);\n+  }\n+\n+  if (resolved_indy_entry_at(index)->resolution_failed()) {\n+    \/\/ Before we got here, another thread got a LinkageError exception during\n+    \/\/ resolution.  Ignore our success and throw their exception.\n+    guarantee(index >= 0, \"Invalid indy index\");\n+    int encoded_index = ResolutionErrorTable::encode_cpcache_index(\n+                          ConstantPool::encode_invokedynamic_index(index));\n+    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+    constantPoolHandle cp(THREAD, constant_pool());\n+    ConstantPool::throw_resolution_error(cp, encoded_index, THREAD);\n+    return nullptr;\n+  }\n+\n+  Method* adapter            = call_info.resolved_method();\n+  const Handle appendix      = call_info.resolved_appendix();\n+  const bool has_appendix    = appendix.not_null();\n+\n+  LogStream* log_stream = NULL;\n+  LogStreamHandle(Debug, methodhandles, indy) lsh_indy;\n+  if (lsh_indy.is_enabled()) {\n+    ResourceMark rm;\n+    log_stream = &lsh_indy;\n+    log_stream->print_cr(\"set_method_handle bc=%d appendix=\" PTR_FORMAT \"%s method=\" PTR_FORMAT \" (local signature) \",\n+                         0xba,\n+                         p2i(appendix()),\n+                         (has_appendix ? \"\" : \" (unused)\"),\n+                         p2i(adapter));\n+    adapter->print_on(log_stream);\n+    if (has_appendix)  appendix()->print_on(log_stream);\n+  }\n+\n+  if (has_appendix) {\n+    const int appendix_index = resolved_indy_entry_at(index)->resolved_references_index();\n+    objArrayOop resolved_references = constant_pool()->resolved_references();\n+    assert(appendix_index >= 0 && appendix_index < resolved_references->length(), \"oob\");\n+    assert(resolved_references->obj_at(appendix_index) == NULL, \"init just once\");\n+    resolved_references->obj_at_put(appendix_index, appendix());\n+  }\n+\n+  \/\/ Populate entry with resolved information\n+  assert(resolved_indy_entries() != nullptr, \"Invokedynamic array is empty, cannot fill with resolved information\");\n+  resolved_indy_entry_at(index)->fill_in(adapter, adapter->size_of_parameters(), as_TosState(adapter->result_type()), has_appendix);\n+\n+  if (log_stream != NULL) {\n+    resolved_indy_entry_at(index)->print_on(log_stream);\n+  }\n+  return appendix();\n@@ -836,0 +926,8 @@\n+  for (int i = 0; i < resolved_indy_entries_length(); i++) {\n+    ResolvedIndyEntry* indy_entry = resolved_indy_entry_at(i);\n+    indy_entry->print_on(st);\n+    if (indy_entry->has_appendix()) {\n+      st->print(\"  appendix: \");\n+      constant_pool()->resolved_reference_from_indy(i)->print_on(st);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":147,"deletions":49,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/resolvedIndyEntry.hpp\"\n@@ -259,5 +260,0 @@\n-  void set_dynamic_call(\n-    const constantPoolHandle& cpool,             \/\/ holding constant pool (required for locking)\n-    const CallInfo &call_info                    \/\/ Call link information\n-  );\n-\n@@ -285,7 +281,0 @@\n-  \/\/ Return TRUE if resolution failed and this thread got to record the failure\n-  \/\/ status.  Return FALSE if another thread succeeded or failed in resolving\n-  \/\/ the method and recorded the success or failure before this thread had a\n-  \/\/ chance to record its failure.\n-  bool save_and_throw_indy_exc(const constantPoolHandle& cpool, int cpool_index,\n-                               int index, constantTag tag, TRAPS);\n-\n@@ -420,0 +409,2 @@\n+  Array<ResolvedIndyEntry>* _resolved_indy_entries;\n+\n@@ -428,2 +419,2 @@\n-                    const intStack& invokedynamic_inverse_index_map,\n-                    const intStack& invokedynamic_references_map);\n+                    const intStack& invokedynamic_references_map,\n+                    Array<ResolvedIndyEntry>* indy_info);\n@@ -433,1 +424,0 @@\n-                  const intArray& invokedynamic_inverse_index_map,\n@@ -438,2 +428,3 @@\n-                                     const intStack& invokedynamic_cp_cache_map,\n-                                     const intStack& invokedynamic_references_map, TRAPS);\n+                                     const intStack& invokedynamic_references_map,\n+                                     const GrowableArray<ResolvedIndyEntry> indy_entries,\n+                                     TRAPS);\n@@ -454,0 +445,9 @@\n+  Array<ResolvedIndyEntry>* resolved_indy_entries()          { return _resolved_indy_entries; }\n+  ResolvedIndyEntry* resolved_indy_entry_at(int index) const { return _resolved_indy_entries->adr_at(index); }\n+  int resolved_indy_entries_length()                   const { return _resolved_indy_entries->length();      }\n+  void print_resolved_indy_entries(outputStream* st)   const {\n+    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+        _resolved_indy_entries->at(i).print_on(st);\n+    }\n+  }\n+\n@@ -456,0 +456,1 @@\n+  static ByteSize invokedynamic_entries_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries); }\n@@ -515,0 +516,7 @@\n+  \/\/ Return TRUE if resolution failed and this thread got to record the failure\n+  \/\/ status.  Return FALSE if another thread succeeded or failed in resolving\n+  \/\/ the method and recorded the success or failure before this thread had a\n+  \/\/ chance to record its failure.\n+  bool save_and_throw_indy_exc(const constantPoolHandle& cpool, int cpool_index, int index, constantTag tag, TRAPS);\n+  oop set_dynamic_call(const CallInfo &call_info, int index);\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-                                            const intStack& invokedynamic_inverse_index_map,\n-                                            const intStack& invokedynamic_references_map) :\n+                                            const intStack& invokedynamic_references_map,\n+                                            Array<ResolvedIndyEntry>* invokedynamic_info) :\n@@ -93,1 +93,2 @@\n-                                                  _gc_epoch(0) {\n+                                                  _gc_epoch(0),\n+                                                  _resolved_indy_entries(invokedynamic_info) {\n@@ -95,1 +96,1 @@\n-  initialize(inverse_index_map, invokedynamic_inverse_index_map,\n+  initialize(inverse_index_map,\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/compressedStream.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/resolvedIndyEntry.hpp\"\n+\n+bool ResolvedIndyEntry::check_no_old_or_obsolete_entry() {\n+  \/\/ return false if m refers to a non-deleted old or obsolete method\n+  if (_method != nullptr) {\n+      assert(_method->is_valid() && _method->is_method(), \"m is a valid method\");\n+      return !_method->is_old() && !_method->is_obsolete(); \/\/ old is always set for old and obsolete\n+  } else {\n+      return true;\n+  }\n+}\n+\n+void ResolvedIndyEntry::remove_unshareable_info() {\n+  u2 saved_resolved_references_index = _resolved_references_index;\n+  u2 saved_cpool_index = _cpool_index;\n+  memset(this, 0, sizeof(*this));\n+  _resolved_references_index = saved_resolved_references_index;\n+  _cpool_index = saved_cpool_index;\n+}\n+\n+void ResolvedIndyEntry::print_on(outputStream* st) const {\n+  st->print_cr(\"Resolved InvokeDynamic Info:\");\n+  if (_method != nullptr) {\n+      st->print_cr(\" - Method: \" INTPTR_FORMAT \" %s\", p2i(method()), method()->external_name());\n+  } else {\n+      st->print_cr(\" - Method: null\");\n+  }\n+  st->print_cr(\" - Resolved References Index: %d\", resolved_references_index());\n+  st->print_cr(\" - CP Index: %d\", constant_pool_index());\n+  st->print_cr(\" - Num Parameters: %d\", num_parameters());\n+  st->print_cr(\" - Return type: %s\", type2name(as_BasicType((TosState)return_type())));\n+  st->print_cr(\" - Has Appendix: %d\", has_appendix());\n+  st->print_cr(\" - Resolution Failed %d\", resolution_failed());\n+}\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_RESOLVEDINDYENTRY_HPP\n+#define SHARE_OOPS_RESOLVEDINDYENTRY_HPP\n+\n+\/\/ ResolvedIndyEntry contains the resolution information for invokedynamic bytecodes.\n+\/\/ A member of this class can be initialized with the resolved references index and\n+\/\/ constant pool index before any resolution is done, where \"resolution\" refers to finding the target\n+\/\/ method and its relevant information, like number of parameters and return type. These entries are contained\n+\/\/ within the ConstantPoolCache and are accessed with indices added to the invokedynamic bytecode after\n+\/\/ rewriting.\n+\n+\/\/ The invokedynamic bytecode starts with an Constant Pool index as its operand which is then rewritten\n+\/\/ to become an \"indy index\", an index into the array of ResolvedIndyEntry. The method here is an adapter method\n+\/\/ which will be something like linkToTargetMethod. When an indy call is resolved, we no longer need to invoke\n+\/\/ the bootstrap method (BSM) and we can get the target method (the method actually doing stuff, i.e. a string concat)\n+\/\/ from the CallSite. The CallSite is generated when the BSM is invoked and it simply contains a MethodHandle for\n+\/\/ the target method. The adapter will propagate information to and from the target method and the JVM.\n+\n+\n+class Method;\n+class ResolvedIndyEntry {\n+  friend class VMStructs;\n+\n+  Method* _method;               \/\/ Adapter method for indy call\n+  u2 _resolved_references_index; \/\/ Index of resolved references array that holds the appendix oop\n+  u2 _cpool_index;               \/\/ Constant pool index\n+  u2 _number_of_parameters;      \/\/ Number of arguments for adapter method\n+  u1 _return_type;               \/\/ Adapter method return type\n+  u1 _flags;                     \/\/ Flags: [0000|00|has_appendix|resolution_failed]\n+\n+public:\n+  ResolvedIndyEntry() :\n+    _method(nullptr),\n+    _resolved_references_index(0),\n+    _cpool_index(0),\n+    _number_of_parameters(0),\n+    _return_type(0),\n+    _flags(0) {}\n+  ResolvedIndyEntry(u2 resolved_references_index, u2 cpool_index) :\n+    _method(nullptr),\n+    _resolved_references_index(resolved_references_index),\n+    _cpool_index(cpool_index),\n+    _number_of_parameters(0),\n+    _return_type(0),\n+    _flags(0) {}\n+\n+  \/\/ Bit shift to get flags\n+  \/\/ Note: Only two flags exists at the moment but more could be added\n+  enum {\n+      has_appendix_shift        = 1,\n+  };\n+\n+  \/\/ Getters\n+  Method* method()               const { return Atomic::load_acquire(&_method); }\n+  u2 resolved_references_index() const { return _resolved_references_index;     }\n+  u2 constant_pool_index()       const { return _cpool_index;                   }\n+  u2 num_parameters()            const { return _number_of_parameters;          }\n+  u1 return_type()               const { return _return_type;                   }\n+  bool is_resolved()             const { return method() != nullptr;            }\n+  bool has_appendix()            const { return (_flags & (1 << has_appendix_shift)) != 0; }\n+  bool resolution_failed()       const { return (_flags & 1) != 0; }\n+  bool is_vfinal()               const { return false; }\n+  bool is_final()                const { return false; }\n+  bool has_local_signature()     const { return true;  }\n+\n+  \/\/ Printing\n+  void print_on(outputStream* st) const;\n+\n+  \/\/ Initialize with fields available before resolution\n+  void init(u2 resolved_references_index, u2 cpool_index) {\n+    _resolved_references_index = resolved_references_index;\n+    _cpool_index = cpool_index;\n+  }\n+\n+  void set_num_parameters(int value) {\n+    assert(_number_of_parameters == 0 || _number_of_parameters == value,\n+      \"size must not change: parameter_size=%d, value=%d\", _number_of_parameters, value);\n+    Atomic::store(&_number_of_parameters, (u2)value);\n+    guarantee(_number_of_parameters == value,\n+      \"size must not change: parameter_size=%d, value=%d\", _number_of_parameters, value);\n+  }\n+\n+  \/\/ Populate structure with resolution information\n+  void fill_in(Method* m, u2 num_params, u1 return_type, bool has_appendix) {\n+    set_num_parameters(num_params);\n+    _return_type = return_type;\n+    set_flags(has_appendix);\n+    \/\/ Set the method last since it is read lock free.\n+    \/\/ Resolution is indicated by whether or not the method is set.\n+    Atomic::release_store(&_method, m);\n+  }\n+\n+  \/\/ has_appendix is currently the only other flag besides resolution_failed\n+  void set_flags(bool has_appendix) {\n+    u1 new_flags = (has_appendix << has_appendix_shift);\n+    assert((new_flags & 1) == 0, \"New flags should not change resolution flag\");\n+    \/\/ Preserve the resolution_failed bit\n+    _flags = (_flags & 1) | new_flags;\n+  }\n+\n+  void set_resolution_failed() {\n+    _flags = _flags | 1;\n+  }\n+\n+  void adjust_method_entry(Method* new_method) { _method = new_method; }\n+  bool check_no_old_or_obsolete_entry();\n+\n+  \/\/ CDS\n+  void remove_unshareable_info();\n+\n+  \/\/ Offsets\n+  static ByteSize method_offset()                    { return byte_offset_of(ResolvedIndyEntry, _method);                    }\n+  static ByteSize resolved_references_index_offset() { return byte_offset_of(ResolvedIndyEntry, _resolved_references_index); }\n+  static ByteSize result_type_offset()               { return byte_offset_of(ResolvedIndyEntry, _return_type);               }\n+  static ByteSize num_parameters_offset()            { return byte_offset_of(ResolvedIndyEntry, _number_of_parameters);      }\n+  static ByteSize flags_offset()                     { return byte_offset_of(ResolvedIndyEntry, _flags);                     }\n+};\n+\n+#endif \/\/ SHARE_OOPS_RESOLVEDINDYENTRY_HPP\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.hpp","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -1041,0 +1041,1 @@\n+        int pool_index;\n@@ -1043,1 +1044,1 @@\n-          entry = mh->constants()->invokedynamic_cp_cache_entry_at(cpci);\n+          pool_index = mh->constants()->resolved_indy_entry_at(mh->constants()->decode_invokedynamic_index(cpci))->constant_pool_index();\n@@ -1047,0 +1048,1 @@\n+          pool_index = entry->constant_pool_index();\n@@ -1048,3 +1050,2 @@\n-        int i = entry->constant_pool_index();\n-        assert(i < mh->constants()->length(), \"sanity check\");\n-        Bytes::put_Java_u2((address)(p+1), (u2)i);     \/\/ java byte ordering\n+        assert(pool_index < mh->constants()->length(), \"sanity check\");\n+        Bytes::put_Java_u2((address)(p+1), (u2)pool_index);     \/\/ java byte ordering\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,2 +106,6 @@\n-    int cpci_old = s_old->get_index_u4();\n-    int cpci_new = s_new->get_index_u4();\n+    \/\/ Encoded indy index, should be negative\n+    int index_old = s_old->get_index_u4();\n+    int index_new = s_new->get_index_u4();\n+\n+    int indy_index_old = old_cp->decode_invokedynamic_index(index_old);\n+    int indy_index_new = new_cp->decode_invokedynamic_index(index_new);\n@@ -112,2 +116,3 @@\n-    if ((old_cp->name_ref_at(cpci_old) != new_cp->name_ref_at(cpci_new)) ||\n-        (old_cp->signature_ref_at(cpci_old) != new_cp->signature_ref_at(cpci_new)))\n+    \/\/ Currently needs encoded indy_index\n+    if ((old_cp->name_ref_at(index_old) != new_cp->name_ref_at(index_new)) ||\n+        (old_cp->signature_ref_at(index_old) != new_cp->signature_ref_at(index_new)))\n@@ -116,3 +121,5 @@\n-    \/\/ Translate object indexes to constant pool cache indexes.\n-    cpci_old = old_cp->invokedynamic_cp_cache_index(cpci_old);\n-    cpci_new = new_cp->invokedynamic_cp_cache_index(cpci_new);\n+    int cpi_old = old_cp->cache()->resolved_indy_entry_at(indy_index_old)->constant_pool_index();\n+    int cpi_new = new_cp->cache()->resolved_indy_entry_at(indy_index_new)->constant_pool_index();\n+    if ((old_cp->uncached_name_ref_at(cpi_old) != new_cp->uncached_name_ref_at(cpi_new)) ||\n+        (old_cp->uncached_signature_ref_at(cpi_old) != new_cp->uncached_signature_ref_at(cpi_new)))\n+      return false;\n@@ -120,2 +127,0 @@\n-    int cpi_old = old_cp->cache()->entry_at(cpci_old)->constant_pool_index();\n-    int cpi_new = new_cp->cache()->entry_at(cpci_new)->constant_pool_index();\n","filename":"src\/hotspot\/share\/prims\/methodComparator.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1874,0 +1874,18 @@\n+WB_ENTRY(jint, WB_getIndyInfoLength(JNIEnv* env, jobject wb, jclass klass))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == NULL) {\n+      return -1;\n+  }\n+  return cp->resolved_indy_entries_length();\n+WB_END\n+\n+WB_ENTRY(jint, WB_getIndyCPIndex(JNIEnv* env, jobject wb, jclass klass, jint index))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == NULL) {\n+      return -1;\n+  }\n+  return cp->resolved_indy_entry_at(index)->constant_pool_index();\n+WB_END\n+\n@@ -2713,0 +2731,2 @@\n+  {CC\"getIndyInfoLength0\", CC\"(Ljava\/lang\/Class;)I\",  (void*)&WB_getIndyInfoLength},\n+  {CC\"getIndyCPIndex0\",    CC\"(Ljava\/lang\/Class;I)I\", (void*)&WB_getIndyCPIndex},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -223,0 +223,2 @@\n+  nonstatic_field(ConstantPoolCache,           _resolved_indy_entries,                        Array<ResolvedIndyEntry>*)             \\\n+  nonstatic_field(ResolvedIndyEntry,           _cpool_index,                                  u2)                                    \\\n@@ -476,0 +478,2 @@\n+  nonstatic_field(Array<ResolvedIndyEntry>,    _length,                                       int)                                   \\\n+  nonstatic_field(Array<ResolvedIndyEntry>,    _data[0],                                      ResolvedIndyEntry)                     \\\n@@ -1022,6 +1026,7 @@\n-  nonstatic_field(Array<int>,                  _length,                                       int)                                   \\\n-  unchecked_nonstatic_field(Array<int>,        _data,                                         sizeof(int))                           \\\n-  unchecked_nonstatic_field(Array<u1>,         _data,                                         sizeof(u1))                            \\\n-  unchecked_nonstatic_field(Array<u2>,         _data,                                         sizeof(u2))                            \\\n-  unchecked_nonstatic_field(Array<Method*>,    _data,                                         sizeof(Method*))                       \\\n-  unchecked_nonstatic_field(Array<Klass*>,     _data,                                         sizeof(Klass*))                        \\\n+  nonstatic_field(Array<int>,                         _length,                                int)                                   \\\n+  unchecked_nonstatic_field(Array<int>,               _data,                                  sizeof(int))                           \\\n+  unchecked_nonstatic_field(Array<u1>,                _data,                                  sizeof(u1))                            \\\n+  unchecked_nonstatic_field(Array<u2>,                _data,                                  sizeof(u2))                            \\\n+  unchecked_nonstatic_field(Array<Method*>,           _data,                                  sizeof(Method*))                       \\\n+  unchecked_nonstatic_field(Array<Klass*>,            _data,                                  sizeof(Klass*))                        \\\n+  unchecked_nonstatic_field(Array<ResolvedIndyEntry>, _data,                                  sizeof(ResolvedIndyEntry))             \\\n@@ -1955,0 +1960,1 @@\n+            declare_type(Array<ResolvedIndyEntry>, MetaspaceObj)          \\\n@@ -1971,0 +1977,1 @@\n+  declare_toplevel_type(ResolvedIndyEntry)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+     } else if (code() == Bytecodes._invokedynamic) {\n+        return cpCache.getIndyEntryAt(cpCacheIndex).getConstantPoolIndex();\n@@ -58,1 +60,1 @@\n-      return cpCache.getEntryAt((int) (0xFFFF & cpCacheIndex)).getConstantPoolIndex();\n+        return cpCache.getEntryAt((int) (0xFFFF & cpCacheIndex)).getConstantPoolIndex();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeWithCPIndex.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,1 +315,1 @@\n-        int poolIndex = invokedynamicCPCacheEntryAt(which).getConstantPoolIndex();\n+        int poolIndex = getCache().getIndyEntryAt(which).getConstantPoolIndex();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    resolvedIndyArray = type.getAddressField(\"_resolved_indy_entries\");\n@@ -74,0 +75,1 @@\n+  private static AddressField  resolvedIndyArray;\n@@ -86,0 +88,6 @@\n+  public ResolvedIndyEntry getIndyEntryAt(int i) {\n+    Address addr = resolvedIndyArray.getValue(getAddress());\n+    ResolvedIndyArray array = new ResolvedIndyArray(addr);\n+    return array.getAt(i);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPoolCache.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.oops;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+import sun.jvm.hotspot.types.WrongTypeException;\n+import sun.jvm.hotspot.utilities.GenericArray;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class ResolvedIndyArray extends GenericArray {\n+    static {\n+        VM.registerVMInitializedObserver(new Observer() {\n+            public void update(Observable o, Object data) {\n+                initialize(VM.getVM().getTypeDataBase());\n+            }\n+        });\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+        elemType = db.lookupType(\"ResolvedIndyEntry\");\n+\n+        Type type = db.lookupType(\"Array<ResolvedIndyEntry>\");\n+        dataFieldOffset = type.getAddressField(\"_data\").getOffset();\n+    }\n+\n+    private static long dataFieldOffset;\n+    protected static Type elemType;\n+\n+    public ResolvedIndyArray(Address addr) {\n+        super(addr, dataFieldOffset);\n+    }\n+\n+    public ResolvedIndyEntry getAt(int index) {\n+        if (index < 0 || index >= length()) throw new ArrayIndexOutOfBoundsException(index + \" \" + length());\n+\n+        Type elemType = getElemType();\n+\n+        Address data = getAddress().addOffsetTo(dataFieldOffset);\n+        long elemSize = elemType.getSize();\n+\n+        return new ResolvedIndyEntry(data.addOffsetTo(index* elemSize));\n+    }\n+\n+    public Type getElemType() {\n+        return elemType;\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ResolvedIndyArray.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.oops;\n+\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class ResolvedIndyEntry extends VMObject {\n+    private static long          size;\n+    private static long          baseOffset;\n+    private static CIntegerField cpIndex;\n+\n+    static {\n+        VM.registerVMInitializedObserver(new Observer() {\n+            public void update(Observable o, Object data) {\n+                initialize(VM.getVM().getTypeDataBase());\n+            }\n+        });\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+        Type type = db.lookupType(\"ResolvedIndyEntry\");\n+        size = type.getSize();\n+\n+        cpIndex = type.getCIntegerField(\"_cpool_index\");\n+    }\n+\n+    ResolvedIndyEntry(Address addr) {\n+        super(addr);\n+    }\n+\n+    public int getConstantPoolIndex() {\n+        return this.getAddress().getJShortAt(cpIndex.getOffset());\n+    }\n+\n+    public void iterateFields(MetadataVisitor visitor) { }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ResolvedIndyEntry.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -847,1 +847,1 @@\n-            index = decodeInvokedynamicIndex(rawIndex) + config().constantPoolCpCacheIndexTag;\n+            return index = decodeInvokedynamicIndex(rawIndex);\n@@ -878,3 +878,5 @@\n-                \/\/ invokedynamic instructions point to a constant pool cache entry.\n-                index = decodeConstantPoolCacheIndex(cpi) + config().constantPoolCpCacheIndexTag;\n-                index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);\n+                \/\/ invokedynamic indices are different from constant pool cache indices\n+                index = decodeConstantPoolCacheIndex(cpi);\n+                if (isInvokedynamicIndex(cpi)) {\n+                    compilerToVM().resolveInvokeDynamicInPool(this, index);\n+                }\n@@ -931,3 +933,1 @@\n-                if (isInvokedynamicIndex(cpi)) {\n-                    compilerToVM().resolveInvokeDynamicInPool(this, cpi);\n-                }\n+                \/\/ nothing\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,7 @@\n+            if (constantPoolSS.getTagAt(cpi).equals(Tag.INVOKEDYNAMIC)) {\n+                for (int indy_index = 0; indy_index < WB.getIndyInfoLength(this.klass); indy_index++) {\n+                    if (WB.getIndyCPIndex(this.klass, indy_index) == cpi) {\n+                        return ~indy_index;\n+                    }\n+                }\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ConstantPoolTestsHelper.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -152,0 +152,12 @@\n+  }\n+\n+  private native int getIndyInfoLength0(Class<?> aClass);\n+  public         int getIndyInfoLength(Class<?> aClass) {\n+    Objects.requireNonNull(aClass);\n+    return getIndyInfoLength0(aClass);\n+  }\n+\n+  private native int getIndyCPIndex0(Class<?> aClass, int index);\n+  public         int getIndyCPIndex(Class<?> aClass, int index) {\n+    Objects.requireNonNull(aClass);\n+    return getIndyCPIndex0(aClass, index);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}