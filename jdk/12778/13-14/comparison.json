{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -349,0 +349,11 @@\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  get_cache_index_at_bcp(index, 1, sizeof(u4));\n+  \/\/ Get address of invokedynamic array\n+  get_constant_pool_cache(cache);\n+  z_lg(cache, Address(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  z_sllg(index, index, exact_log2(sizeof(ResolvedIndyEntry)));\n+  z_la(cache, Array<ResolvedIndyEntry>::base_offset_in_bytes(), index, cache);\n+}\n+\n@@ -744,0 +755,5 @@\n+void InterpreterMacroAssembler::get_constant_pool_cache(Register Rdst) {\n+  get_constant_pool(Rdst);\n+  mem2reg_opt(Rdst, Address(Rdst, ConstantPool::cache_offset_in_bytes()));\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -115,0 +115,1 @@\n+  void load_resolved_indy_entry(Register cache, Register index);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -63,1 +64,1 @@\n-  #define __ _masm->\n+  #define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -65,1 +66,1 @@\n-  #define __ _masm->\n+  #define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -652,8 +653,13 @@\n-  Register size   = Z_tmp_1;\n-  Register offset = Z_tmp_2;\n-  const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +\n-                                    ConstantPoolCacheEntry::flags_offset());\n-  __ get_cache_and_index_at_bcp(cache, offset, 1, index_size);\n-\n-  \/\/ #args is in rightmost byte of the _flags field.\n-  __ z_llgc(size, Address(cache, offset, flags_offset+(sizeof(size_t)-1)));\n+  Register size   = Z_tmp_2;\n+  Register index  = Z_tmp_2;\n+  if (index_size == sizeof(u4)) {\n+    __ load_resolved_indy_entry(cache, index);\n+    __ z_llgh(size, in_bytes(ResolvedIndyEntry::num_parameters_offset()), cache);\n+  } else {\n+    const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +\n+                                      ConstantPoolCacheEntry::flags_offset());\n+    __ get_cache_and_index_at_bcp(cache, index, 1, index_size);\n+\n+    \/\/ #args is in rightmost byte of the _flags field.\n+    __ z_llgc(size, Address(cache, index, flags_offset + (sizeof(size_t) - 1)));\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -54,1 +55,2 @@\n-#define __ (PRODUCT_ONLY(false&&)Verbose ? (_masm->block_comment(FILE_AND_LINE),_masm):_masm)->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n+\/\/ #define __ (PRODUCT_ONLY(false&&)Verbose ? (_masm->block_comment(FILE_AND_LINE),_masm):_masm)->\n@@ -2419,0 +2421,58 @@\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  const Register cache    = Z_tmp_1;\n+  const Register index    = Z_tmp_3;\n+  const Register appendix = Z_R1_scratch;\n+  assert_different_registers(cache, index, appendix, method);\n+\n+  Label resolved;\n+  __ load_resolved_indy_entry(cache, index);\n+  __ z_lg(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+\n+  \/\/ The invokedynamic is unresolved iff method is NULL\n+  __ z_clgij(method, 0, Assembler::bcondNotEqual, resolved); \/\/ method != 0, jump to resolved\n+  Bytecodes::Code code = bytecode();\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ load_const_optimized(Z_ARG2, (int)code);\n+  __ call_VM(noreg, entry, Z_ARG2);\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  __ z_lg(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+#ifdef ASSERT\n+  __ z_clgij(method, 0, Assembler::bcondNotEqual, resolved); \/\/ method != 0, jump to resolved\n+  __ stop(\"should be resolved by now\");\n+#endif \/\/ ASSERT\n+  __ bind(resolved);\n+\n+  Label L_no_push;\n+  __ z_llgc(index, Address(cache, in_bytes(ResolvedIndyEntry::flags_offset())));\n+  __ testbit(index, ResolvedIndyEntry::has_appendix_shift);\n+  __ z_bfalse(L_no_push);\n+  \/\/ get appendix\n+  __ z_llgh(index, Address(cache, in_bytes(ResolvedIndyEntry::resolved_references_index_offset())));\n+  \/\/ Push the appendix as a trailing parameter.\n+  \/\/ This must be done before we get the receiver,\n+  \/\/ since the parameter_size includes it.\n+  __ load_resolved_reference_at_index(appendix, index);\n+  __ verify_oop(appendix);\n+  __ push_ptr(appendix);  \/\/ Push appendix (MethodType, CallSite, etc.).\n+  __ bind(L_no_push);\n+\n+  \/\/ Compute return type.\n+  Register ret_type = index;\n+  __ z_llgc(ret_type, Address(cache, in_bytes(ResolvedIndyEntry::result_type_offset())));\n+\n+  const address table_addr = (address)Interpreter::invoke_return_entry_table_for(code);\n+  __ load_absolute_address(Z_R14, table_addr);\n+\n+  const int bit_shift = LogBytesPerWord;           \/\/ Size of each table entry.\n+  \/\/ const int r_bitpos  = 63 - bit_shift;\n+  \/\/ const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;\n+  \/\/ const int n_rotate  = bit_shift-ConstantPoolCacheEntry::tos_state_shift;\n+  \/\/ __ rotate_then_insert(ret_type, Z_R0_scratch, l_bitpos, r_bitpos, n_rotate, true);\n+  \/\/ Make sure we don't need to mask flags for tos_state after the above shift.\n+  __ z_sllg(ret_type, ret_type, bit_shift);\n+  ConstantPoolCacheEntry::verify_tos_state_shift();\n+  __ z_lg(Z_R14, Address(Z_R14, ret_type));\n+}\n+\n@@ -2425,1 +2485,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/* unused *\/) {\n@@ -2448,1 +2508,1 @@\n-    resolve_cache_and_index(byte_no, cache, cpe_offset, is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+    resolve_cache_and_index(byte_no, cache, cpe_offset, sizeof(u2));\n@@ -3385,1 +3445,1 @@\n-  const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;\n+  const bool is_invokedynamic    = false; \/\/ should not reach here with invokedynamic\n@@ -3402,1 +3462,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -3701,1 +3761,0 @@\n-  const Register Rcallsite = Z_tmp_1;\n@@ -3703,1 +3762,1 @@\n-  prepare_invoke(byte_no, Rmethod, Rcallsite);\n+  load_invokedynamic_entry(Rmethod);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":68,"deletions":9,"binary":false,"changes":77,"status":"modified"}]}