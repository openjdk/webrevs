{"files":[{"patch":"@@ -31,2 +31,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"utilities\/macros.hpp\"\n@@ -773,11 +771,13 @@\n-\/\/ As an optimization, choose optimum vector size for copy length known at compile time.\n-int ArrayCopyNode::get_partial_inline_vector_lane_count(BasicType type, int const_len) {\n-  int lane_count = ArrayOperationPartialInlineSize\/type2aelembytes(type);\n-  if (const_len > 0) {\n-    int size_in_bytes = const_len * type2aelembytes(type);\n-    if (size_in_bytes <= 16)\n-      lane_count = 16\/type2aelembytes(type);\n-    else if (size_in_bytes > 16 && size_in_bytes <= 32)\n-      lane_count = 32\/type2aelembytes(type);\n-  }\n-  return lane_count;\n+\/\/ As an optimization, choose the optimal vector size for bounded copy length\n+int ArrayCopyNode::get_partial_inline_vector_lane_count(BasicType type, jlong max_len) {\n+  assert(max_len > 0, JLONG_FORMAT, max_len);\n+  \/\/ We only care whether max_size_in_bytes is not larger than 32, we also want to avoid\n+  \/\/ multiplication overflow, so clamp max_len to [0, 64]\n+  int max_size_in_bytes = MIN2<jlong>(max_len, 64) * type2aelembytes(type);\n+  if (ArrayOperationPartialInlineSize > 16 && max_size_in_bytes <= 16) {\n+    return 16 \/ type2aelembytes(type);\n+  } else if (ArrayOperationPartialInlineSize > 32 && max_size_in_bytes <= 32) {\n+    return 32 \/ type2aelembytes(type);\n+  } else {\n+    return ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n+  }\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  static int get_partial_inline_vector_lane_count(BasicType type, int const_len);\n+  static int get_partial_inline_vector_lane_count(BasicType type, jlong max_len);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,3 +207,1 @@\n-  const TypePtr *src_adr_type = _igvn.type(src_start)->isa_ptr();\n-  Node* inline_block = nullptr;\n-  Node* stub_block = nullptr;\n+  int inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n@@ -211,10 +209,10 @@\n-  int const_len = -1;\n-  const TypeInt* lty = nullptr;\n-  uint shift  = exact_log2(type2aelembytes(type));\n-  if (length->Opcode() == Op_ConvI2L) {\n-    lty = _igvn.type(length->in(1))->isa_int();\n-  } else  {\n-    lty = _igvn.type(length)->isa_int();\n-  }\n-  if (lty && lty->is_con()) {\n-    const_len = lty->get_con() << shift;\n+  const TypeLong* length_type = _igvn.type(length)->isa_long();\n+  if (length_type == nullptr) {\n+    assert(_igvn.type(length) == Type::TOP, \"\");\n+    return;\n+  } else if (length_type->_hi <= 0) {\n+    \/\/ Nothing to copy\n+    return;\n+  } else if (length_type->_lo > inline_limit) {\n+    \/\/ Cannot inline\n+    return;\n@@ -223,5 +221,3 @@\n-  \/\/ Return if copy length is greater than partial inline size limit or\n-  \/\/ target does not supports masked load\/stores.\n-  int lane_count = ArrayCopyNode::get_partial_inline_vector_lane_count(type, const_len);\n-  if ( const_len > ArrayOperationPartialInlineSize ||\n-      !Matcher::match_rule_supported_vector(Op_LoadVectorMasked, lane_count, type)  ||\n+  \/\/ Return if the target does not supports masked load\/stores.\n+  int lane_count = ArrayCopyNode::get_partial_inline_vector_lane_count(type, length_type->_hi);\n+  if (!Matcher::match_rule_supported_vector(Op_LoadVectorMasked, lane_count, type)  ||\n@@ -233,7 +229,1 @@\n-  int inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n-  Node* casted_length = new CastLLNode(*ctrl, length, TypeLong::make(0, inline_limit, Type::WidenMin));\n-  transform_later(casted_length);\n-  Node* copy_bytes = new LShiftXNode(length, intcon(shift));\n-  transform_later(copy_bytes);\n-\n-  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayOperationPartialInlineSize));\n+  Node* cmp_le = new CmpULNode(length, longcon(inline_limit));\n@@ -243,2 +233,2 @@\n-  inline_block  = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n-  stub_block = *ctrl;\n+  Node* inline_block = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n+  Node* stub_block = *ctrl;\n@@ -246,0 +236,2 @@\n+  Node* casted_length = new CastLLNode(inline_block, length, TypeLong::make(0, inline_limit, Type::WidenMin), ConstraintCastNode::RegularDependency);\n+  transform_later(casted_length);\n@@ -249,1 +241,1 @@\n-  unsigned vec_size = lane_count *  type2aelembytes(type);\n+  unsigned vec_size = lane_count * type2aelembytes(type);\n@@ -254,0 +246,1 @@\n+  const TypePtr* src_adr_type = _igvn.type(src_start)->isa_ptr();\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-compiler\/c2\/TestVerifyConstraintCasts.java 8355574 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8251871 8285301\n+ * @bug 8251871 8285301 8355574\n@@ -41,0 +41,3 @@\n+ * @run main\/othervm\/timeout=600 -XX:-TieredCompilation -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+StressGCM -XX:VerifyConstraintCasts=2\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      compiler.arraycopy.TestArrayCopyConjoint\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyConjoint.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}