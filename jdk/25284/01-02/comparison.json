{"files":[{"patch":"@@ -771,11 +771,13 @@\n-\/\/ As an optimization, choose optimum vector size for copy length known at compile time.\n-int ArrayCopyNode::get_partial_inline_vector_lane_count(BasicType type, int const_len) {\n-  int lane_count = ArrayOperationPartialInlineSize\/type2aelembytes(type);\n-  if (const_len > 0) {\n-    int size_in_bytes = const_len * type2aelembytes(type);\n-    if (size_in_bytes <= 16)\n-      lane_count = 16\/type2aelembytes(type);\n-    else if (size_in_bytes > 16 && size_in_bytes <= 32)\n-      lane_count = 32\/type2aelembytes(type);\n-  }\n-  return lane_count;\n+\/\/ As an optimization, choose the optimal vector size for bounded copy length\n+int ArrayCopyNode::get_partial_inline_vector_lane_count(BasicType type, jlong max_len) {\n+  assert(max_len > 0, JLONG_FORMAT, max_len);\n+  \/\/ We only care if max_size_in_bytes is not larger than 32, we also want to avoid multiplication\n+  \/\/ overflow, so clamp max_len to [0, 64]\n+  int max_size_in_bytes = MIN2<jlong>(max_len, 64) * type2aelembytes(type);\n+  if (ArrayOperationPartialInlineSize > 16 && max_size_in_bytes <= 16) {\n+    return 16 \/ type2aelembytes(type);\n+  } else if (ArrayOperationPartialInlineSize > 32 && max_size_in_bytes <= 32) {\n+    return 32 \/ type2aelembytes(type);\n+  } else {\n+    return ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n+  }\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  static int get_partial_inline_vector_lane_count(BasicType type, int const_len);\n+  static int get_partial_inline_vector_lane_count(BasicType type, jlong max_len);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,3 +207,0 @@\n-  const TypePtr *src_adr_type = _igvn.type(src_start)->isa_ptr();\n-  Node* inline_block = nullptr;\n-  Node* stub_block = nullptr;\n@@ -212,9 +209,10 @@\n-  int const_len = -1;\n-  const TypeInt* lty = nullptr;\n-  if (length->Opcode() == Op_ConvI2L) {\n-    lty = _igvn.type(length->in(1))->isa_int();\n-  } else  {\n-    lty = _igvn.type(length)->isa_int();\n-  }\n-  if (lty && lty->is_con()) {\n-    const_len = lty->get_con();\n+  const TypeLong* length_type = _igvn.type(length)->isa_long();\n+  if (length_type == nullptr) {\n+    assert(_igvn.type(length) == Type::TOP, \"\");\n+    return;\n+  } else if (length_type->_hi <= 0) {\n+    \/\/ Nothing to copy\n+    return;\n+  } else if (length_type->_lo > inline_limit) {\n+    \/\/ Cannot inline\n+    return;\n@@ -225,3 +223,2 @@\n-  int lane_count = ArrayCopyNode::get_partial_inline_vector_lane_count(type, const_len);\n-  if (const_len > inline_limit ||\n-      !Matcher::match_rule_supported_vector(Op_LoadVectorMasked, lane_count, type)  ||\n+  int lane_count = ArrayCopyNode::get_partial_inline_vector_lane_count(type, length_type->_hi);\n+  if (!Matcher::match_rule_supported_vector(Op_LoadVectorMasked, lane_count, type)  ||\n@@ -237,2 +234,2 @@\n-  inline_block  = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n-  stub_block = *ctrl;\n+  Node* inline_block = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n+  Node* stub_block = *ctrl;\n@@ -245,1 +242,1 @@\n-  unsigned vec_size = lane_count *  type2aelembytes(type);\n+  unsigned vec_size = lane_count * type2aelembytes(type);\n@@ -250,0 +247,1 @@\n+  const TypePtr* src_adr_type = _igvn.type(src_start)->isa_ptr();\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"}]}