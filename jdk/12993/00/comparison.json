{"files":[{"patch":"@@ -72,0 +72,1 @@\n+import sun.awt.SunHints;\n@@ -3950,4 +3951,6 @@\n-                if (gg instanceof Graphics2D) {\n-                    gg.setColor(getBackground());\n-                    ((Graphics2D)gg).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));\n-                    gg.fillRect(0, 0, getWidth(), getHeight());\n+                if (gg instanceof Graphics2D gg2d) {\n+                    if (!SunHints.VALUE_PAINT_WINDOW_BACKGROUND_OFF.equals(gg2d.getRenderingHint(SunHints.KEY_PAINT_WINDOW_BACKGROUND_COLOR))) {\n+                        gg2d.setColor(getBackground());\n+                        gg2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));\n+                        gg2d.fillRect(0, 0, getWidth(), getHeight());\n+                    }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import sun.awt.SunHints;\n@@ -888,0 +889,6 @@\n+\n+                                if (g instanceof Graphics2D g2d) {\n+                                    \/\/ If Window#paint(Graphics) fills its background color we may see flickering\n+                                    g2d.setRenderingHint(SunHints.KEY_PAINT_WINDOW_BACKGROUND_COLOR, SunHints.VALUE_PAINT_WINDOW_BACKGROUND_OFF);\n+                                }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    private static final int NUM_KEYS = 10;\n+    private static final int NUM_KEYS = 11;\n@@ -264,0 +264,7 @@\n+    \/**\n+     * Paint window background color hint key and values\n+     *\/\n+    @Native public static final int INTKEY_PAINT_WINDOW_BACKGROUND_COLOR = 10;\n+    @Native public static final int INTVAL_PAINT_WINDOW_BACKGROUND_COLOR_ON = 0;\n+    @Native public static final int INTVAL_PAINT_WINDOW_BACKGROUND_COLOR_OFF = 1;\n+\n@@ -516,0 +523,15 @@\n+\n+    \/**\n+     * Paint window background color key and value objects\n+     *\/\n+    public static final Key KEY_PAINT_WINDOW_BACKGROUND_COLOR =\n+            new SunHints.Key(SunHints.INTKEY_PAINT_WINDOW_BACKGROUND_COLOR,\n+                    \"Paint window background color\");\n+    public static final Object VALUE_PAINT_WINDOW_BACKGROUND_ON =\n+            new SunHints.Value(KEY_PAINT_WINDOW_BACKGROUND_COLOR,\n+                    SunHints.INTVAL_PAINT_WINDOW_BACKGROUND_COLOR_ON,\n+                    \"Paint window background color\");\n+    public static final Object VALUE_PAINT_WINDOW_BACKGROUND_OFF =\n+            new SunHints.Value(KEY_PAINT_WINDOW_BACKGROUND_COLOR,\n+                    SunHints.INTVAL_PAINT_WINDOW_BACKGROUND_COLOR_OFF,\n+                    \"Do not paint window background color\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunHints.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.geom.RoundRectangle2D;\n+\n+import javax.swing.JComponent;\n+import javax.swing.SwingUtilities;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.plaf.PanelUI;\n+\n+\/* @test\n+ * @bug 8303950\n+ * @summary translucent windows flicker on repaint\n+ * @author Jeremy Wood\n+ *\/\n+public class bug8303950 {\n+\n+    \/\/ pick two random and distinct colors:\n+    static final Color FLICKER_OF_BACKGROUND_COLOR = new Color(91, 152, 214);\n+    static final Color CORRECT_FOREGROUND_COLOR = new Color(119, 33, 236);\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                FlickerTestWindow flickeringWindow = new FlickerTestWindow();\n+                flickeringWindow.pack();\n+                flickeringWindow.setLocationRelativeTo(null);\n+\n+                \/\/ put a solid sheet under our test window. If we see this window's background color\n+                \/\/ we know our test is failing because there's a flicker.\n+\n+                JDialog backgroundWindow = new JDialog();\n+                backgroundWindow.getContentPane().setBackground(FLICKER_OF_BACKGROUND_COLOR);\n+                backgroundWindow.setBounds(flickeringWindow.getBounds());\n+                backgroundWindow.setVisible(true);\n+\n+                \/\/ now show our test window on top:\n+                flickeringWindow.setVisible(true);\n+                flickeringWindow.toFront();\n+\n+                Thread watcherThread = new Thread() {\n+                    @Override\n+                    public void run() {\n+                        waitUntilReady();\n+\n+                        \/\/ now grab the center pixel for 3 seconds and see if it ever flickers to reveal\n+                        \/\/ the background window:\n+                        Robot robot;\n+                        try {\n+                            robot = new Robot();\n+\n+                            int flickerSamples = 0;\n+                            int noFlickerSamples = 0;\n+                            int notSetupSamples = 0;\n+\n+                            Point loc = new Point(flickeringWindow.label.getLocationOnScreen());\n+                            loc.x += 150;\n+                            loc.y += 150;\n+                            long t = System.currentTimeMillis();\n+                            while (true) {\n+                                long elapsed = System.currentTimeMillis() - t;\n+                                if (elapsed > 3_000) {\n+                                    System.out.println(\"flicker samples: \" + flickerSamples);\n+                                    System.out.println(\"successful samples: \" + noFlickerSamples);\n+                                    if (notSetupSamples > 0) {\n+                                        System.out.println(\"setup failed samples: \" + notSetupSamples);\n+                                        System.out.println(\"This means the windows weren't configured correctly, or the Robot was unable to capture pixels.\");\n+                                    }\n+                                    if (notSetupSamples + flickerSamples > 0) {\n+                                        System.err.println(\"This test failed.\");\n+                                        System.exit(1);\n+                                    } else {\n+                                        System.out.println(\"This test passed.\");\n+                                        return;\n+                                    }\n+                                }\n+                                Color c = robot.getPixelColor(loc.x, loc.y);\n+                                if (matches(CORRECT_FOREGROUND_COLOR, c)) {\n+                                    noFlickerSamples++;\n+                                } else if (matches(FLICKER_OF_BACKGROUND_COLOR, c)) {\n+                                    flickerSamples++;\n+                                } else {\n+                                    notSetupSamples++;\n+                                }\n+                            }\n+                        } catch (AWTException e) {\n+                            e.printStackTrace();\n+                            System.exit(1);\n+                        }\n+                    }\n+\n+                    private void waitUntilReady() {\n+                        try {\n+                            Thread.sleep(500);\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        while (true) {\n+                            if (flickeringWindow.isShowing() && backgroundWindow.isShowing()) {\n+                                break;\n+                            }\n+                            Thread.yield();\n+                        }\n+                    }\n+\n+                    \/**\n+                     * Return true if two colors are very similar.\n+                     * <p>\n+                     * This exists because I don't get an exact match on the static\n+                     * colors in this test, but the RGB values we get back are recognizable\n+                     * close to what we're aiming for.\n+                     * <\/p>\n+                     *\/\n+                    private boolean matches(Color c1, Color c2) {\n+                        return Math.abs(c1.getRed() - c2.getRed()) +\n+                                Math.abs(c1.getGreen() - c2.getGreen()) +\n+                                Math.abs(c1.getBlue() - c2.getBlue()) < 60;\n+                    }\n+                };\n+                watcherThread.start();\n+            }\n+        });\n+        Thread.currentThread().sleep(5000);\n+    }\n+\n+    static class FlickerTestWindow extends JWindow {\n+        JTextPane instructions = new JTextPane();\n+        JLabel label = new JLabel();\n+\n+        public FlickerTestWindow() {\n+            instructions.setText(\"Instructions:\\nCheck if the center of the animation (which is constantly repainting) ever flickers.\");\n+            instructions.setBorder(new EmptyBorder(10, 10, 10, 10));\n+            instructions.setOpaque(false);\n+            instructions.setEditable(false);\n+\n+            setBackground(new Color(0,0,0,0));\n+\n+            JPanel p = new JPanel();\n+            p.setOpaque(false);\n+            p.setBorder(new EmptyBorder(10,10,10,10));\n+            p.setUI(new PanelUI() {\n+                @Override\n+                public void paint(Graphics g, JComponent c) {\n+                    Graphics2D g2 = (Graphics2D) g;\n+                    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+                    g2.setColor(new Color(220, 180, 0, 200));\n+                    g2.fill(new RoundRectangle2D.Double(0,0,c.getWidth(),c.getHeight(),20,20));\n+                    c.repaint();\n+                }\n+            });\n+            p.setLayout(new BorderLayout());\n+            p.add(instructions, BorderLayout.NORTH);\n+            p.add(label, BorderLayout.CENTER);\n+\n+            Icon icon = new Icon() {\n+                @Override\n+                public void paintIcon(Component c, Graphics g, int x, int y) {\n+                    int startAngle = (int)( (System.currentTimeMillis() % 1000) * 360 \/ 1000 );\n+\n+                    g.setColor(CORRECT_FOREGROUND_COLOR);\n+                    g.fillRect(x, y, getIconWidth(), getIconHeight());\n+\n+                    g.setColor(new Color(0,0,0,100));\n+                    ((Graphics2D)g).setStroke(new BasicStroke(8));\n+                    g.drawArc(10, 10, 280, 280, startAngle, 200);\n+\n+                    c.repaint();\n+                }\n+\n+                @Override\n+                public int getIconWidth() {\n+                    return 300;\n+                }\n+\n+                @Override\n+                public int getIconHeight() {\n+                    return 300;\n+                }\n+            };\n+            label.setIcon(icon);\n+\n+            getContentPane().add(p);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303950\/bug8303950.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}