{"files":[{"patch":"@@ -72,0 +72,1 @@\n+import sun.awt.SunHints;\n@@ -3952,1 +3953,1 @@\n-                    ((Graphics2D)gg).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));\n+                    ((Graphics2D) gg).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1110,0 +1110,1 @@\n+                !repaintManager.isPaintManagerPainting() &&\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -888,0 +888,1 @@\n+\n@@ -889,1 +890,4 @@\n-                                    dirtyComponent.paint(g);\n+                                    AWTPaintManager<Component> pm = new AWTPaintManager<Component>();\n+                                    pm.repaintManager = RepaintManager.this;\n+                                    pm.paint(dirtyComponent, dirtyComponent, g,\n+                                            rect.x, rect.y, rect.width, rect.height);\n@@ -1518,0 +1522,1 @@\n+    ThreadLocal<AtomicInteger> paintManagerRecursionMonitor = new ThreadLocal<>();\n@@ -1520,3 +1525,3 @@\n-     * PaintManager is used to handle all double buffered painting for\n-     * Swing.  Subclasses should call back into the JComponent method\n-     * <code>paintToOffscreen<\/code> to handle the actual painting.\n+     * Returns true if this thread is currently repainting one or more Components with a AWTPaintManager.\n+     *\n+     * @return rue if this thread is currently repainting one or more Components with a AWTPaintManager.\n@@ -1524,1 +1529,5 @@\n-    static class PaintManager {\n+    public boolean isPaintManagerPainting() {\n+        return paintManagerRecursionMonitor.get() != null;\n+    }\n+\n+    static class AWTPaintManager<T extends Component> {\n@@ -1529,1 +1538,0 @@\n-        boolean isRepaintingRoot;\n@@ -1543,2 +1551,2 @@\n-        public boolean paint(JComponent paintingComponent,\n-                             JComponent bufferComponent, Graphics g,\n+        public boolean paint(T paintingComponent,\n+                             T bufferComponent, Graphics g,\n@@ -1546,22 +1554,34 @@\n-            \/\/ First attempt to use VolatileImage buffer for performance.\n-            \/\/ If this fails (which should rarely occur), fallback to a\n-            \/\/ standard Image buffer.\n-            boolean paintCompleted = false;\n-            Image offscreen;\n-            int sw = w + 1;\n-            int sh = h + 1;\n-\n-            if (repaintManager.useVolatileDoubleBuffer() &&\n-                (offscreen = getValidImage(repaintManager.\n-                getVolatileOffscreenBuffer(bufferComponent, sw, sh))) != null) {\n-                VolatileImage vImage = (java.awt.image.VolatileImage)offscreen;\n-                GraphicsConfiguration gc = bufferComponent.\n-                                            getGraphicsConfiguration();\n-                for (int i = 0; !paintCompleted &&\n-                         i < RepaintManager.VOLATILE_LOOP_MAX; i++) {\n-                    if (vImage.validate(gc) ==\n-                                   VolatileImage.IMAGE_INCOMPATIBLE) {\n-                        repaintManager.resetVolatileDoubleBuffer(gc);\n-                        offscreen = repaintManager.getVolatileOffscreenBuffer(\n-                            bufferComponent, sw, sh);\n-                        vImage = (java.awt.image.VolatileImage)offscreen;\n+            AtomicInteger recursionCtr = repaintManager.paintManagerRecursionMonitor.get();\n+            if (recursionCtr == null) {\n+                recursionCtr = new AtomicInteger(0);\n+                repaintManager.paintManagerRecursionMonitor.set(recursionCtr);\n+            }\n+            recursionCtr.incrementAndGet();\n+\n+            try {\n+                \/\/ First attempt to use VolatileImage buffer for performance.\n+                \/\/ If this fails (which should rarely occur), fallback to a\n+                \/\/ standard Image buffer.\n+                boolean paintCompleted = false;\n+                Image offscreen;\n+                int sw = w + 1;\n+                int sh = h + 1;\n+\n+                if (repaintManager.useVolatileDoubleBuffer() &&\n+                        (offscreen = getValidImage(repaintManager.\n+                                getVolatileOffscreenBuffer(bufferComponent, sw, sh))) != null) {\n+                    VolatileImage vImage = (java.awt.image.VolatileImage) offscreen;\n+                    GraphicsConfiguration gc = bufferComponent.\n+                            getGraphicsConfiguration();\n+                    for (int i = 0; !paintCompleted &&\n+                            i < RepaintManager.VOLATILE_LOOP_MAX; i++) {\n+                        if (vImage.validate(gc) ==\n+                                VolatileImage.IMAGE_INCOMPATIBLE) {\n+                            repaintManager.resetVolatileDoubleBuffer(gc);\n+                            offscreen = repaintManager.getVolatileOffscreenBuffer(\n+                                    bufferComponent, sw, sh);\n+                            vImage = (java.awt.image.VolatileImage) offscreen;\n+                        }\n+                        paintDoubleBuffered(paintingComponent, vImage, g, x, y,\n+                                w, h);\n+                        paintCompleted = !vImage.contentsLost();\n@@ -1569,3 +1589,14 @@\n-                    paintDoubleBuffered(paintingComponent, vImage, g, x, y,\n-                                        w, h);\n-                    paintCompleted = !vImage.contentsLost();\n+                }\n+                \/\/ VolatileImage painting loop failed, fallback to regular\n+                \/\/ offscreen buffer\n+                if (!paintCompleted && (offscreen = getValidImage(\n+                        repaintManager.getOffscreenBuffer(\n+                                bufferComponent, w, h))) != null) {\n+                    paintDoubleBuffered(paintingComponent, offscreen, g, x, y, w,\n+                            h);\n+                    paintCompleted = true;\n+                }\n+                return paintCompleted;\n+            } finally {\n+                if (recursionCtr.decrementAndGet() == 0) {\n+                    repaintManager.paintManagerRecursionMonitor.remove();\n@@ -1574,46 +1605,0 @@\n-            \/\/ VolatileImage painting loop failed, fallback to regular\n-            \/\/ offscreen buffer\n-            if (!paintCompleted && (offscreen = getValidImage(\n-                      repaintManager.getOffscreenBuffer(\n-                      bufferComponent, w, h))) != null) {\n-                paintDoubleBuffered(paintingComponent, offscreen, g, x, y, w,\n-                                    h);\n-                paintCompleted = true;\n-            }\n-            return paintCompleted;\n-        }\n-\n-        \/**\n-         * Does a copy area on the specified region.\n-         *\/\n-        public void copyArea(JComponent c, Graphics g, int x, int y, int w,\n-                             int h, int deltaX, int deltaY, boolean clip) {\n-            g.copyArea(x, y, w, h, deltaX, deltaY);\n-        }\n-\n-        \/**\n-         * Invoked prior to any calls to paint or copyArea.\n-         *\/\n-        public void beginPaint() {\n-        }\n-\n-        \/**\n-         * Invoked to indicate painting has been completed.\n-         *\/\n-        public void endPaint() {\n-        }\n-\n-        \/**\n-         * Shows a region of a previously rendered component.  This\n-         * will return true if successful, false otherwise.  The default\n-         * implementation returns false.\n-         *\/\n-        public boolean show(Container c, int x, int y, int w, int h) {\n-            return false;\n-        }\n-\n-        \/**\n-         * Invoked when the doubleBuffered or useTrueDoubleBuffering\n-         * properties of a JRootPane change.  This may come in on any thread.\n-         *\/\n-        public void doubleBufferingChanged(JRootPane rootPane) {\n@@ -1625,3 +1610,3 @@\n-        protected void paintDoubleBuffered(JComponent c, Image image,\n-                Graphics g, int clipX, int clipY,\n-                int clipW, int clipH) {\n+        protected void paintDoubleBuffered(T c, Image image,\n+                                           Graphics g, int clipX, int clipY,\n+                                           int clipW, int clipH) {\n@@ -1635,1 +1620,1 @@\n-        private void paintDoubleBufferedImpl(JComponent c, Image image,\n+        private void paintDoubleBufferedImpl(T c, Image image,\n@@ -1656,1 +1641,5 @@\n-                        c.paintToOffscreen(osg, x, y, bw, bh, maxx, maxy);\n+                        if (c instanceof JComponent jc) {\n+                            jc.paintToOffscreen(osg, x, y, bw, bh, maxx, maxy);\n+                        } else {\n+                            c.paint(osg);\n+                        }\n@@ -1676,1 +1665,1 @@\n-        private void paintDoubleBufferedFPScales(JComponent c, Image image,\n+        private void paintDoubleBufferedFPScales(Component c, Image image,\n@@ -1720,1 +1709,5 @@\n-                        c.paintToOffscreen(osg, x, y, bw, bh, maxx, maxy);\n+                        if (c instanceof JComponent jc) {\n+                            jc.paintToOffscreen(osg, x, y, bw, bh, maxx, maxy);\n+                        } else {\n+                            c.paint(osg);\n+                        }\n@@ -1752,1 +1745,1 @@\n-                                 image.getHeight(null) > 0) {\n+                    image.getHeight(null) > 0) {\n@@ -1758,0 +1751,70 @@\n+        private boolean isPixelsCopying(T c, Graphics g) {\n+\n+            AffineTransform tx = getTransform(g);\n+            GraphicsConfiguration gc = c.getGraphicsConfiguration();\n+\n+            if (tx == null || gc == null\n+                    || !SwingUtilities2.isFloatingPointScale(tx)) {\n+                return false;\n+            }\n+\n+            AffineTransform gcTx = gc.getDefaultTransform();\n+\n+            return gcTx.getScaleX() == tx.getScaleX()\n+                    && gcTx.getScaleY() == tx.getScaleY();\n+        }\n+\n+        private static AffineTransform getTransform(Graphics g) {\n+            if (g instanceof SunGraphics2D) {\n+                return ((SunGraphics2D) g).transform;\n+            } else if (g instanceof Graphics2D) {\n+                return ((Graphics2D) g).getTransform();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * PaintManager is used to handle all double buffered painting for\n+     * Swing.  Subclasses should call back into the JComponent method\n+     * <code>paintToOffscreen<\/code> to handle the actual painting.\n+     *\/\n+    static class PaintManager extends AWTPaintManager<JComponent> {\n+        boolean isRepaintingRoot;\n+\n+        \/**\n+         * Does a copy area on the specified region.\n+         *\/\n+        public void copyArea(JComponent c, Graphics g, int x, int y, int w,\n+                             int h, int deltaX, int deltaY, boolean clip) {\n+            g.copyArea(x, y, w, h, deltaX, deltaY);\n+        }\n+\n+        \/**\n+         * Invoked prior to any calls to paint or copyArea.\n+         *\/\n+        public void beginPaint() {\n+        }\n+\n+        \/**\n+         * Invoked to indicate painting has been completed.\n+         *\/\n+        public void endPaint() {\n+        }\n+\n+        \/**\n+         * Shows a region of a previously rendered component.  This\n+         * will return true if successful, false otherwise.  The default\n+         * implementation returns false.\n+         *\/\n+        public boolean show(Container c, int x, int y, int w, int h) {\n+            return false;\n+        }\n+\n+        \/**\n+         * Invoked when the doubleBuffered or useTrueDoubleBuffering\n+         * properties of a JRootPane change.  This may come in on any thread.\n+         *\/\n+        public void doubleBufferingChanged(JRootPane rootPane) {\n+        }\n+\n@@ -1788,25 +1851,0 @@\n-\n-        private boolean isPixelsCopying(JComponent c, Graphics g) {\n-\n-            AffineTransform tx = getTransform(g);\n-            GraphicsConfiguration gc = c.getGraphicsConfiguration();\n-\n-            if (tx == null || gc == null\n-                    || !SwingUtilities2.isFloatingPointScale(tx)) {\n-                return false;\n-            }\n-\n-            AffineTransform gcTx = gc.getDefaultTransform();\n-\n-            return gcTx.getScaleX() == tx.getScaleX()\n-                    && gcTx.getScaleY() == tx.getScaleY();\n-        }\n-\n-        private static AffineTransform getTransform(Graphics g) {\n-            if (g instanceof SunGraphics2D) {\n-                return ((SunGraphics2D) g).transform;\n-            } else if (g instanceof Graphics2D) {\n-                return ((Graphics2D) g).getTransform();\n-            }\n-            return null;\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":150,"deletions":112,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.geom.RoundRectangle2D;\n+\n+import javax.swing.JComponent;\n+import javax.swing.SwingUtilities;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.plaf.PanelUI;\n+\n+\/* @test\n+ * @bug 8303950\n+ * @summary translucent windows flicker on repaint\n+ * @author Jeremy Wood\n+ *\/\n+public class bug8303950 {\n+\n+    \/\/ pick two random and distinct colors:\n+    static final Color FLICKER_OF_BACKGROUND_COLOR = new Color(91, 152, 214);\n+    static final Color CORRECT_FOREGROUND_COLOR = new Color(119, 33, 236);\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                FlickerTestWindow flickeringWindow = new FlickerTestWindow();\n+                flickeringWindow.pack();\n+                flickeringWindow.setLocationRelativeTo(null);\n+\n+                \/\/ put a solid sheet under our test window. If we see this window's background color\n+                \/\/ we know our test is failing because there's a flicker.\n+\n+                JDialog backgroundWindow = new JDialog();\n+                backgroundWindow.getContentPane().setBackground(FLICKER_OF_BACKGROUND_COLOR);\n+                backgroundWindow.setBounds(flickeringWindow.getBounds());\n+                backgroundWindow.setVisible(true);\n+\n+                \/\/ now show our test window on top:\n+                flickeringWindow.setVisible(true);\n+                flickeringWindow.toFront();\n+\n+                Thread watcherThread = new Thread() {\n+                    @Override\n+                    public void run() {\n+                        waitUntilReady();\n+\n+                        \/\/ now grab the center pixel for 3 seconds and see if it ever flickers to reveal\n+                        \/\/ the background window:\n+                        Robot robot;\n+                        try {\n+                            robot = new Robot();\n+\n+                            int flickerSamples = 0;\n+                            int noFlickerSamples = 0;\n+                            int notSetupSamples = 0;\n+\n+                            Point loc = new Point(flickeringWindow.label.getLocationOnScreen());\n+                            loc.x += 150;\n+                            loc.y += 150;\n+                            long t = System.currentTimeMillis();\n+                            while (true) {\n+                                long elapsed = System.currentTimeMillis() - t;\n+                                if (elapsed > 3_000) {\n+                                    System.out.println(\"flicker samples: \" + flickerSamples);\n+                                    System.out.println(\"successful samples: \" + noFlickerSamples);\n+                                    if (notSetupSamples > 0) {\n+                                        System.out.println(\"setup failed samples: \" + notSetupSamples);\n+                                        System.out.println(\"This means the windows weren't configured correctly, or the Robot was unable to capture pixels.\");\n+                                    }\n+                                    if (notSetupSamples + flickerSamples > 0) {\n+                                        System.err.println(\"This test failed.\");\n+                                        System.exit(1);\n+                                    } else {\n+                                        System.out.println(\"This test passed.\");\n+                                        return;\n+                                    }\n+                                }\n+                                Color c = robot.getPixelColor(loc.x, loc.y);\n+                                if (matches(CORRECT_FOREGROUND_COLOR, c)) {\n+                                    noFlickerSamples++;\n+                                } else if (matches(FLICKER_OF_BACKGROUND_COLOR, c)) {\n+                                    flickerSamples++;\n+                                } else {\n+                                    notSetupSamples++;\n+                                }\n+                            }\n+                        } catch (AWTException e) {\n+                            e.printStackTrace();\n+                            System.exit(1);\n+                        }\n+                    }\n+\n+                    private void waitUntilReady() {\n+                        try {\n+                            Thread.sleep(500);\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        while (true) {\n+                            if (flickeringWindow.isShowing() && backgroundWindow.isShowing()) {\n+                                break;\n+                            }\n+                            Thread.yield();\n+                        }\n+                    }\n+\n+                    \/**\n+                     * Return true if two colors are very similar.\n+                     * <p>\n+                     * This exists because I don't get an exact match on the static\n+                     * colors in this test, but the RGB values we get back are recognizable\n+                     * close to what we're aiming for.\n+                     * <\/p>\n+                     *\/\n+                    private boolean matches(Color c1, Color c2) {\n+                        return Math.abs(c1.getRed() - c2.getRed()) +\n+                                Math.abs(c1.getGreen() - c2.getGreen()) +\n+                                Math.abs(c1.getBlue() - c2.getBlue()) < 60;\n+                    }\n+                };\n+                watcherThread.start();\n+            }\n+        });\n+        Thread.currentThread().sleep(5000);\n+    }\n+\n+    static class FlickerTestWindow extends JWindow {\n+        JTextPane instructions = new JTextPane();\n+        JLabel label = new JLabel();\n+\n+        public FlickerTestWindow() {\n+            instructions.setText(\"Instructions:\\nCheck if the center of the animation (which is constantly repainting) ever flickers.\");\n+            instructions.setBorder(new EmptyBorder(10, 10, 10, 10));\n+            instructions.setOpaque(false);\n+            instructions.setEditable(false);\n+\n+            setBackground(new Color(0,0,0,0));\n+\n+            JPanel p = new JPanel();\n+            p.setOpaque(false);\n+            p.setBorder(new EmptyBorder(10,10,10,10));\n+            p.setUI(new PanelUI() {\n+                @Override\n+                public void paint(Graphics g, JComponent c) {\n+                    Graphics2D g2 = (Graphics2D) g;\n+                    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+                    g2.setColor(new Color(220, 180, 0, 200));\n+                    g2.fill(new RoundRectangle2D.Double(0,0,c.getWidth(),c.getHeight(),20,20));\n+                    c.repaint();\n+                }\n+            });\n+            p.setLayout(new BorderLayout());\n+            p.add(instructions, BorderLayout.NORTH);\n+            p.add(label, BorderLayout.CENTER);\n+\n+            Icon icon = new Icon() {\n+                @Override\n+                public void paintIcon(Component c, Graphics g, int x, int y) {\n+                    int startAngle = (int)( (System.currentTimeMillis() % 1000) * 360 \/ 1000 );\n+\n+                    g.setColor(CORRECT_FOREGROUND_COLOR);\n+                    g.fillRect(x, y, getIconWidth(), getIconHeight());\n+\n+                    g.setColor(new Color(0,0,0,100));\n+                    ((Graphics2D)g).setStroke(new BasicStroke(8));\n+                    g.drawArc(10, 10, 280, 280, startAngle, 200);\n+\n+                    c.repaint();\n+                }\n+\n+                @Override\n+                public int getIconWidth() {\n+                    return 300;\n+                }\n+\n+                @Override\n+                public int getIconHeight() {\n+                    return 300;\n+                }\n+            };\n+            label.setIcon(icon);\n+\n+            getContentPane().add(p);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303950\/bug8303950.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}