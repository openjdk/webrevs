[{"commit":{"message":"8303950: adding unit test for legacy window behavior\n\nThis test passes in the current JDK. The test criteria don't really reflect a rational expected behavior; they just reflect the current status quo.\n\nThis currently fails in this JDK-8303950 branch (using the new proposed AWTPaintManager), which indicates we've changed behavior.\n\nIn this case it's \"window 4\" that's failing. We used to get a mostly blue background, and now we're getting a background that's mostly red with a little blue. This isn't necessarily a bad thing; this failure is just documenting a change."},"files":[{"filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303950\/bug8303950_legacyWindowPaintBehavior.java"}],"sha":"bd81761a1a5a6cf702cd3e8c6d1951a66730ca6f"},{"commit":{"message":"8303950: addressing artifacts observed in RepaintManagerFPUIScaleTest\n\nWhen I resized the window in the RepaintManagerFPUIScaleTest: I saw lots of random patches of misplaced pixels.\n\nI assume this is because the RepaintManager could now call AWTPaintManager#paint(..) recursively, which means each invocation could grab the cached VolatileImage returned by getVolatileOffscreenBuffer. As a test: I tried making getVolatileOffscreenBuffer always return a new image, and that resolved the artifacts.\n\nThis change avoids the recursion with a new helper method. This logic is similar to checking JComponent#getFlag(ANCESTOR_USING_BUFFER) , except that can't help identify recursion when the outermost call is coming from a Component like a Window.\n\nTo my knowledge this recursion can only ever happen when the outermost call is a non-Swing component and the innermost call is a Swing component. (And there should only ever be one layer of recursion.)"},"files":[{"filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java"},{"filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java"}],"sha":"960fd1761c765c8804acfe29e47f396e506dfe5c"},{"commit":{"message":"8303950: approaching using double-buffer approach instead\n\nThe PaintManager explicitly states that its for Swing components. This pulls some logic out of PaintManager that can be applied to generic awt.Components and introduces the AWTPaintManager super class.\n\nThe broad goal here is to take advantage of double-buffering AND avoid copying and pasting the hard work that the PaintManager already took care (regarding tiling, scaling, and looping attempts to use VolatileImages).\n\nThis is response to ongoing PR discussions; see https:\/\/github.com\/openjdk\/jdk\/pull\/12993#issuecomment-1470887449"},"files":[{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java"},{"filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java"}],"sha":"6a3a9b42bb705273e1ed9b1de0d04370e69c43ca"},{"commit":{"message":"8303950: fixing false negative\n\nApparently calling System.exit(0) was coming across as a failing condition. So instead I'll just let the app exit on its own.\n\nAlso small formatting\/typo tweaks."},"files":[{"filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303950\/bug8303950.java"}],"sha":"6594b54813e230557455eb3b28254f4b21224ff2"},{"commit":{"message":"8303950: avoid letting Window.paint(..) call g.fillRect(..)\n\nWhen Window.paint(..) calls g.fillRect(..): sometimes this results in flickering.\n\nThe problem appears to be that the monitor refreshes shortly after the call to fillRect(..) but *before* the RepaintManager has a chance to paint its replacement image with AlphaComposite.SRC.\n\nThis proposal uses a new RenderingHint to tell Window.paint(..) to skip its paint method. This feels hacky, but I don't see a simpler solution at this point. (I can think of at least two hackier approaches though, if we want to brainstorm alternatives.) If there is a simple way to safeguard the monitor from refreshing prematurely that might be a much better solution, but I'm not familiar that logic.\n\nSkipping g.fillRect(..) should be safe in RepaintManager's case, because the RepaintManager is already calling:\n```\ng2d.setBackground(c.getBackground());\ng2d.clearRect(x,y,bw,bh);\n```\n\nSo in this bug's test case: c will be a `JRootPane`. And JRootPane's `getBackground()` method will default to the Window's background color. So we're already flood filling RepaintManager's buffer with the correct background color (which is the window's background color).\n\nAnd (sigh) in the event the JRootPane and Window have *different* background colors: the JRootPane \"wins\", and the Window's background color is ignored. This is weird (and maybe bad), but this is the preexisting behavior. If you set up a window with a background of `new Color(255,0,0,200)` and a JRootPane with a background of `new Color(0,255,0,200)`, then (when there is no flickering): the JRootPane's background color always wins and there is no sign of the red. IMO this is a very low-priority bug of its own, where the expected behavior is the JRootPane's background renders on top of the Window's background."},"files":[{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java"},{"filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java"}],"sha":"1991fdac5dbf76ddaf73cc78a9f7c38370c9674c"},{"commit":{"message":"8303950: adding failing test to identify problem"},"files":[{"filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303950\/bug8303950.java"}],"sha":"55caec2e8f63fd935597bb35c53dcaf12319d3e7"},{"commit":{"message":"Merge pull request #4 from openjdk\/master\n\nUpdating mickleness\/jdk from openjdk\/jdk"},"files":[],"sha":"69481fc38f4021224ec4a8d1a75b275a89dfa832"},{"commit":{"message":"Merge pull request #3 from openjdk\/master\n\nMerge from openjdk\/jdk"},"files":[],"sha":"57346a421446d51192ceada277626ba1ae92d8d7"},{"commit":{"message":"Merge pull request #2 from openjdk\/master\n\nMerge openjdk\/jdk"},"files":[],"sha":"333c87c2107262532815db6978c5e8f59c5a967e"},{"commit":{"message":"Merge pull request #1 from openjdk\/master\n\nMerge openjdk\/jdk into mickleness\/jdk"},"files":[],"sha":"5dbf0a67ad41a53e03f02c41b1b6364fc3a633ee"}]