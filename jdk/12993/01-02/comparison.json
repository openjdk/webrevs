{"files":[{"patch":"@@ -1110,0 +1110,1 @@\n+                !repaintManager.isPaintManagerPainting() &&\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1522,0 +1522,11 @@\n+    ThreadLocal<AtomicInteger> paintManagerRecursionMonitor = new ThreadLocal<>();\n+\n+    \/**\n+     * Returns true if this thread is currently repainting one or more Components with a AWTPaintManager.\n+     *\n+     * @return rue if this thread is currently repainting one or more Components with a AWTPaintManager.\n+     *\/\n+    public boolean isPaintManagerPainting() {\n+        return paintManagerRecursionMonitor.get() != null;\n+    }\n+\n@@ -1543,22 +1554,34 @@\n-            \/\/ First attempt to use VolatileImage buffer for performance.\n-            \/\/ If this fails (which should rarely occur), fallback to a\n-            \/\/ standard Image buffer.\n-            boolean paintCompleted = false;\n-            Image offscreen;\n-            int sw = w + 1;\n-            int sh = h + 1;\n-\n-            if (repaintManager.useVolatileDoubleBuffer() &&\n-                    (offscreen = getValidImage(repaintManager.\n-                            getVolatileOffscreenBuffer(bufferComponent, sw, sh))) != null) {\n-                VolatileImage vImage = (java.awt.image.VolatileImage)offscreen;\n-                GraphicsConfiguration gc = bufferComponent.\n-                        getGraphicsConfiguration();\n-                for (int i = 0; !paintCompleted &&\n-                        i < RepaintManager.VOLATILE_LOOP_MAX; i++) {\n-                    if (vImage.validate(gc) ==\n-                            VolatileImage.IMAGE_INCOMPATIBLE) {\n-                        repaintManager.resetVolatileDoubleBuffer(gc);\n-                        offscreen = repaintManager.getVolatileOffscreenBuffer(\n-                                bufferComponent, sw, sh);\n-                        vImage = (java.awt.image.VolatileImage)offscreen;\n+            AtomicInteger recursionCtr = repaintManager.paintManagerRecursionMonitor.get();\n+            if (recursionCtr == null) {\n+                recursionCtr = new AtomicInteger(0);\n+                repaintManager.paintManagerRecursionMonitor.set(recursionCtr);\n+            }\n+            recursionCtr.incrementAndGet();\n+\n+            try {\n+                \/\/ First attempt to use VolatileImage buffer for performance.\n+                \/\/ If this fails (which should rarely occur), fallback to a\n+                \/\/ standard Image buffer.\n+                boolean paintCompleted = false;\n+                Image offscreen;\n+                int sw = w + 1;\n+                int sh = h + 1;\n+\n+                if (repaintManager.useVolatileDoubleBuffer() &&\n+                        (offscreen = getValidImage(repaintManager.\n+                                getVolatileOffscreenBuffer(bufferComponent, sw, sh))) != null) {\n+                    VolatileImage vImage = (java.awt.image.VolatileImage) offscreen;\n+                    GraphicsConfiguration gc = bufferComponent.\n+                            getGraphicsConfiguration();\n+                    for (int i = 0; !paintCompleted &&\n+                            i < RepaintManager.VOLATILE_LOOP_MAX; i++) {\n+                        if (vImage.validate(gc) ==\n+                                VolatileImage.IMAGE_INCOMPATIBLE) {\n+                            repaintManager.resetVolatileDoubleBuffer(gc);\n+                            offscreen = repaintManager.getVolatileOffscreenBuffer(\n+                                    bufferComponent, sw, sh);\n+                            vImage = (java.awt.image.VolatileImage) offscreen;\n+                        }\n+                        paintDoubleBuffered(paintingComponent, vImage, g, x, y,\n+                                w, h);\n+                        paintCompleted = !vImage.contentsLost();\n@@ -1566,3 +1589,14 @@\n-                    paintDoubleBuffered(paintingComponent, vImage, g, x, y,\n-                            w, h);\n-                    paintCompleted = !vImage.contentsLost();\n+                }\n+                \/\/ VolatileImage painting loop failed, fallback to regular\n+                \/\/ offscreen buffer\n+                if (!paintCompleted && (offscreen = getValidImage(\n+                        repaintManager.getOffscreenBuffer(\n+                                bufferComponent, w, h))) != null) {\n+                    paintDoubleBuffered(paintingComponent, offscreen, g, x, y, w,\n+                            h);\n+                    paintCompleted = true;\n+                }\n+                return paintCompleted;\n+            } finally {\n+                if (recursionCtr.decrementAndGet() == 0) {\n+                    repaintManager.paintManagerRecursionMonitor.remove();\n@@ -1571,10 +1605,0 @@\n-            \/\/ VolatileImage painting loop failed, fallback to regular\n-            \/\/ offscreen buffer\n-            if (!paintCompleted && (offscreen = getValidImage(\n-                    repaintManager.getOffscreenBuffer(\n-                            bufferComponent, w, h))) != null) {\n-                paintDoubleBuffered(paintingComponent, offscreen, g, x, y, w,\n-                        h);\n-                paintCompleted = true;\n-            }\n-            return paintCompleted;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":59,"deletions":35,"binary":false,"changes":94,"status":"modified"}]}