{"files":[{"patch":"@@ -217,1 +217,1 @@\n-  _attributes = NULL;\n+  _attributes = nullptr;\n@@ -267,1 +267,1 @@\n-  assert(inst_mark() != NULL, \"must be inside InstructionMark\");\n+  assert(inst_mark() != nullptr, \"must be inside InstructionMark\");\n@@ -687,1 +687,1 @@\n-      assert(inst_mark() != NULL, \"must be inside InstructionMark\");\n+      assert(inst_mark() != nullptr, \"must be inside InstructionMark\");\n@@ -1237,1 +1237,1 @@\n-  assert(inst != NULL && inst < pc(), \"must point to beginning of instruction\");\n+  assert(inst != nullptr && inst < pc(), \"must point to beginning of instruction\");\n@@ -1693,2 +1693,2 @@\n-  \/\/ Entry is NULL in case of a scratch emit.\n-  assert(entry == NULL || is_simm32(disp), \"disp=\" INTPTR_FORMAT \" must be 32bit offset (call2)\", disp);\n+  \/\/ Entry is null in case of a scratch emit.\n+  assert(entry == nullptr || is_simm32(disp), \"disp=\" INTPTR_FORMAT \" must be 32bit offset (call2)\", disp);\n@@ -2407,1 +2407,1 @@\n-    assert(dst != NULL, \"jcc most probably wrong\");\n+    assert(dst != nullptr, \"jcc most probably wrong\");\n@@ -2465,1 +2465,1 @@\n-    assert(entry != NULL, \"jmp most probably wrong\");\n+    assert(entry != nullptr, \"jmp most probably wrong\");\n@@ -2496,1 +2496,1 @@\n-  assert(dest != NULL, \"must have a target\");\n+  assert(dest != nullptr, \"must have a target\");\n@@ -2506,1 +2506,1 @@\n-    assert(entry != NULL, \"jmp most probably wrong\");\n+    assert(entry != nullptr, \"jmp most probably wrong\");\n@@ -6344,1 +6344,1 @@\n-    assert(entry != NULL, \"abort entry NULL\");\n+    assert(entry != nullptr, \"abort entry null\");\n@@ -12498,1 +12498,1 @@\n-  assert(inst_mark() != NULL, \"must be inside InstructionMark\");\n+  assert(inst_mark() != nullptr, \"must be inside InstructionMark\");\n@@ -13524,1 +13524,1 @@\n-static u_char* popa_code  = NULL;\n+static u_char* popa_code  = nullptr;\n@@ -13527,1 +13527,1 @@\n-static u_char* pusha_code = NULL;\n+static u_char* pusha_code = nullptr;\n@@ -13530,1 +13530,1 @@\n-static u_char* vzup_code  = NULL;\n+static u_char* vzup_code  = nullptr;\n@@ -13577,1 +13577,1 @@\n-  assert(src != NULL, \"code to copy must have been pre-computed\");\n+  assert(src != nullptr, \"code to copy must have been pre-computed\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-      _target(NULL)\n+      _target(nullptr)\n@@ -922,1 +922,1 @@\n-  void clear_attributes(void) { _attributes = NULL; }\n+  void clear_attributes(void) { _attributes = nullptr; }\n@@ -2887,1 +2887,1 @@\n-      _current_assembler(NULL) { }\n+      _current_assembler(nullptr) { }\n@@ -2890,1 +2890,1 @@\n-    if (_current_assembler != NULL) {\n+    if (_current_assembler != nullptr) {\n@@ -2893,1 +2893,1 @@\n-    _current_assembler = NULL;\n+    _current_assembler = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    assert(p != NULL, \"null pointer\");\n+    assert(p != nullptr, \"null pointer\");\n@@ -53,1 +53,1 @@\n-    assert(p != NULL, \"null pointer\");\n+    assert(p != nullptr, \"null pointer\");\n","filename":"src\/hotspot\/cpu\/x86\/bytes_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -321,1 +321,1 @@\n-    Metadata* o = NULL;\n+    Metadata* o = nullptr;\n@@ -336,1 +336,1 @@\n-    jobject o = NULL;\n+    jobject o = nullptr;\n@@ -407,1 +407,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -158,1 +158,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -324,1 +324,1 @@\n-        __ stop(\"locked object is NULL\");\n+        __ stop(\"locked object is null\");\n@@ -376,1 +376,1 @@\n-  jobject o = NULL;\n+  jobject o = nullptr;\n@@ -383,1 +383,1 @@\n-  Metadata* o = NULL;\n+  Metadata* o = nullptr;\n@@ -403,1 +403,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -453,1 +453,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -486,1 +486,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -497,1 +497,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -544,1 +544,1 @@\n-  guarantee(info != NULL, \"Shouldn't be NULL\");\n+  guarantee(info != nullptr, \"Shouldn't be null\");\n@@ -736,1 +736,1 @@\n-      if (c->as_jobject() == NULL) {\n+      if (c->as_jobject() == nullptr) {\n@@ -802,1 +802,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -950,1 +950,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1046,1 +1046,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1055,1 +1055,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1083,1 +1083,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1201,1 +1201,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1206,1 +1206,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1273,1 +1273,1 @@\n-        assert(info == NULL && patch == NULL, \"must be\");\n+        assert(info == nullptr && patch == nullptr, \"must be\");\n@@ -1281,1 +1281,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1290,1 +1290,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1342,1 +1342,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1404,3 +1404,3 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n@@ -1410,1 +1410,1 @@\n-    if (op->info() != NULL) add_debug_info_for_branch(op->info());\n+    if (op->info() != nullptr) add_debug_info_for_branch(op->info());\n@@ -1415,1 +1415,1 @@\n-      assert(op->ublock() != NULL, \"must have unordered successor\");\n+      assert(op->ublock() != nullptr, \"must have unordered successor\");\n@@ -1572,1 +1572,1 @@\n-      assert(op->stub() != NULL, \"stub required\");\n+      assert(op->stub() != nullptr, \"stub required\");\n@@ -1685,2 +1685,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -1690,1 +1690,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -1693,1 +1693,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -1695,1 +1695,1 @@\n-    assert(data != NULL,                \"need data for type check\");\n+    assert(data != nullptr,                \"need data for type check\");\n@@ -1801,1 +1801,1 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -1845,2 +1845,2 @@\n-    ciMethodData* md = NULL;\n-    ciProfileData* data = NULL;\n+    ciMethodData* md = nullptr;\n+    ciProfileData* data = nullptr;\n@@ -1850,1 +1850,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -1853,1 +1853,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -1855,1 +1855,1 @@\n-      assert(data != NULL,                \"need data for type check\");\n+      assert(data != nullptr,                \"need data for type check\");\n@@ -1885,1 +1885,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -2024,1 +2024,1 @@\n-    const2reg(opr1, result, lir_patch_none, NULL);\n+    const2reg(opr1, result, lir_patch_none, nullptr);\n@@ -2056,1 +2056,1 @@\n-      const2reg(opr2, result, lir_patch_none, NULL);\n+      const2reg(opr2, result, lir_patch_none, nullptr);\n@@ -2066,1 +2066,1 @@\n-  assert(info == NULL, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n+  assert(info == nullptr, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n@@ -2262,1 +2262,1 @@\n-        assert(const_addr != NULL, \"incorrect float\/double constant maintenance\");\n+        assert(const_addr != nullptr, \"incorrect float\/double constant maintenance\");\n@@ -2669,1 +2669,1 @@\n-        \/\/ All we need for now is a comparison with NULL for equality.\n+        \/\/ All we need for now is a comparison with null for equality.\n@@ -2672,1 +2672,1 @@\n-        if (m == NULL) {\n+        if (m == nullptr) {\n@@ -2680,1 +2680,1 @@\n-        if (o == NULL) {\n+        if (o == nullptr) {\n@@ -2690,1 +2690,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2740,1 +2740,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2761,1 +2761,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2784,1 +2784,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2890,1 +2890,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -2900,1 +2900,1 @@\n-  __ mov_metadata(rbx, (Metadata*)NULL);\n+  __ mov_metadata(rbx, (Metadata*)nullptr);\n@@ -3076,1 +3076,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -3080,1 +3080,1 @@\n-  if (default_type == NULL) {\n+  if (default_type == nullptr) {\n@@ -3099,1 +3099,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -3172,1 +3172,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n@@ -3202,1 +3202,1 @@\n-  \/\/ test for NULL\n+  \/\/ test for null\n@@ -3283,1 +3283,1 @@\n-      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, NULL);\n+      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, nullptr);\n@@ -3299,1 +3299,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -3504,1 +3504,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -3513,1 +3513,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -3531,1 +3531,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -3552,1 +3552,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -3554,1 +3554,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -3567,1 +3567,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -3592,1 +3592,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -3629,1 +3629,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -3664,1 +3664,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -3677,2 +3677,2 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n-        if (exact_klass != NULL) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n+        if (exact_klass != nullptr) {\n@@ -3706,1 +3706,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -3726,1 +3726,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -3757,1 +3757,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -3864,1 +3864,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -3873,1 +3873,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -3883,1 +3883,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -3893,1 +3893,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":78,"deletions":78,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  if (c && c->state_before() == NULL) {\n+  if (c && c->state_before() == nullptr) {\n@@ -146,1 +146,1 @@\n-  return c->type() != T_OBJECT || c->as_jobject() == NULL;\n+  return c->type() != T_OBJECT || c->as_jobject() == nullptr;\n@@ -315,1 +315,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -386,1 +386,1 @@\n-    assert(c != NULL, \"invalid constant\");\n+    assert(c != nullptr, \"invalid constant\");\n@@ -432,1 +432,1 @@\n-    address entry = NULL;\n+    address entry = nullptr;\n@@ -502,1 +502,1 @@\n-    address entry = NULL;\n+    address entry = nullptr;\n@@ -530,1 +530,1 @@\n-    arithmetic_op_long(x->op(), reg, left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), reg, left.result(), right.result(), nullptr);\n@@ -542,1 +542,1 @@\n-    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -586,1 +586,1 @@\n-      info = NULL;\n+      info = nullptr;\n@@ -653,1 +653,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -694,1 +694,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -870,1 +870,1 @@\n-  CallingConvention* cc = NULL;\n+  CallingConvention* cc = nullptr;\n@@ -895,1 +895,1 @@\n-      if (StubRoutines::dexp() != NULL) {\n+      if (StubRoutines::dexp() != nullptr) {\n@@ -902,1 +902,1 @@\n-      if (StubRoutines::dlog() != NULL) {\n+      if (StubRoutines::dlog() != nullptr) {\n@@ -909,1 +909,1 @@\n-      if (StubRoutines::dlog10() != NULL) {\n+      if (StubRoutines::dlog10() != nullptr) {\n@@ -916,1 +916,1 @@\n-      if (StubRoutines::dpow() != NULL) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -923,1 +923,1 @@\n-      if (VM_Version::supports_sse2() && StubRoutines::dsin() != NULL) {\n+      if (VM_Version::supports_sse2() && StubRoutines::dsin() != nullptr) {\n@@ -930,1 +930,1 @@\n-      if (VM_Version::supports_sse2() && StubRoutines::dcos() != NULL) {\n+      if (VM_Version::supports_sse2() && StubRoutines::dcos() != nullptr) {\n@@ -937,1 +937,1 @@\n-      if (StubRoutines::dtan() != NULL) {\n+      if (StubRoutines::dtan() != nullptr) {\n@@ -948,1 +948,1 @@\n-      if (StubRoutines::dexp() != NULL) {\n+      if (StubRoutines::dexp() != nullptr) {\n@@ -955,1 +955,1 @@\n-      if (StubRoutines::dlog() != NULL) {\n+      if (StubRoutines::dlog() != nullptr) {\n@@ -962,1 +962,1 @@\n-      if (StubRoutines::dlog10() != NULL) {\n+      if (StubRoutines::dlog10() != nullptr) {\n@@ -969,1 +969,1 @@\n-       if (StubRoutines::dpow() != NULL) {\n+       if (StubRoutines::dpow() != nullptr) {\n@@ -976,1 +976,1 @@\n-      if (StubRoutines::dsin() != NULL) {\n+      if (StubRoutines::dsin() != nullptr) {\n@@ -983,1 +983,1 @@\n-      if (StubRoutines::dcos() != NULL) {\n+      if (StubRoutines::dcos() != nullptr) {\n@@ -990,1 +990,1 @@\n-       if (StubRoutines::dtan() != NULL) {\n+       if (StubRoutines::dtan() != nullptr) {\n@@ -1262,1 +1262,1 @@\n-  ConversionStub* stub = NULL;\n+  ConversionStub* stub = nullptr;\n@@ -1338,1 +1338,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1371,1 +1371,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -1378,1 +1378,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1427,1 +1427,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1442,1 +1442,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1445,1 +1445,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1467,1 +1467,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    create_unhandled_lists(&intervals_in_register, &intervals_in_memory, is_in_fpu_register, NULL);\n+    create_unhandled_lists(&intervals_in_register, &intervals_in_memory, is_in_fpu_register, nullptr);\n@@ -112,1 +112,1 @@\n-  _fpu_stack_allocator = NULL;\n+  _fpu_stack_allocator = nullptr;\n@@ -119,1 +119,1 @@\n-  , _lir(NULL)\n+  , _lir(nullptr)\n@@ -139,2 +139,2 @@\n-    assert(fpu_stack_state != NULL ||\n-           block->end()->as_Base() != NULL ||\n+    assert(fpu_stack_state != nullptr ||\n+           block->end()->as_Base() != nullptr ||\n@@ -146,1 +146,1 @@\n-    if (fpu_stack_state != NULL) {\n+    if (fpu_stack_state != nullptr) {\n@@ -189,1 +189,1 @@\n-    if (branch != NULL && branch->block() != NULL) {\n+    if (branch != nullptr && branch->block() != nullptr) {\n@@ -198,1 +198,1 @@\n-    } else if (op1 != NULL) {\n+    } else if (op1 != nullptr) {\n@@ -200,1 +200,1 @@\n-    } else if (op2 != NULL) {\n+    } else if (op2 != nullptr) {\n@@ -202,1 +202,1 @@\n-    } else if (opCall != NULL) {\n+    } else if (opCall != nullptr) {\n@@ -259,1 +259,1 @@\n-    if (xhandler->entry_code() == NULL) {\n+    if (xhandler->entry_code() == nullptr) {\n@@ -283,1 +283,1 @@\n-          assert(op->as_Op1() != NULL, \"must be LIR_Op1\");\n+          assert(op->as_Op1() != nullptr, \"must be LIR_Op1\");\n@@ -1045,1 +1045,1 @@\n-    if (state != NULL) {\n+    if (state != nullptr) {\n@@ -1091,1 +1091,1 @@\n-      if (sux->fpu_stack_state() != NULL) {\n+      if (sux->fpu_stack_state() != nullptr) {\n@@ -1117,1 +1117,1 @@\n-    assert(sux_state != NULL, \"no fpu state\");\n+    assert(sux_state != nullptr, \"no fpu state\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  \/\/ location (NULL in the displaced hdr location indicates recursive locking)\n+  \/\/ location (null in the displaced hdr location indicates recursive locking)\n@@ -113,1 +113,1 @@\n-  \/\/ if the loaded hdr is NULL we had recursive locking\n+  \/\/ if the loaded hdr is null we had recursive locking\n@@ -282,1 +282,1 @@\n-  \/\/ explicit NULL check not needed since load from [klass_offset] causes a trap\n+  \/\/ explicit null check not needed since load from [klass_offset] causes a trap\n@@ -325,1 +325,1 @@\n-  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-  void null_check(Register r, Label *Lnull = NULL) { MacroAssembler::null_check(r); }\n+  void null_check(Register r, Label *Lnull = nullptr) { MacroAssembler::null_check(r); }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    set_last_Java_frame(thread, noreg, rbp, NULL, rscratch1);\n+    set_last_Java_frame(thread, noreg, rbp, nullptr, rscratch1);\n@@ -676,1 +676,1 @@\n-  OopMap* oop_map = NULL;\n+  OopMap* oop_map = nullptr;\n@@ -873,1 +873,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -889,1 +889,1 @@\n-  __ set_last_Java_frame(thread, noreg, rbp, NULL, rscratch1);\n+  __ set_last_Java_frame(thread, noreg, rbp, nullptr, rscratch1);\n@@ -1003,1 +1003,1 @@\n-  OopMapSet* oop_maps = NULL;\n+  OopMapSet* oop_maps = nullptr;\n@@ -1270,1 +1270,1 @@\n-        __ check_klass_subtype_slow_path(rsi, rax, rcx, rdi, NULL, &miss);\n+        __ check_klass_subtype_slow_path(rsi, rax, rcx, rdi, nullptr, &miss);\n@@ -1345,1 +1345,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -1495,1 +1495,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-    if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n+    if (BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {\n@@ -150,1 +150,1 @@\n-    bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+    bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n@@ -231,1 +231,1 @@\n-  if (method_data != NULL) {\n+  if (method_data != nullptr) {\n@@ -245,1 +245,1 @@\n-  if (method_data != NULL) {\n+  if (method_data != nullptr) {\n@@ -263,1 +263,1 @@\n-  assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+  assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -273,1 +273,1 @@\n-    assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -359,1 +359,1 @@\n-    assert(stack_rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(stack_rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -419,1 +419,1 @@\n-    assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -664,1 +664,1 @@\n-  \/\/ If we weren't able to swing _owner from NULL to the BasicLock\n+  \/\/ If we weren't able to swing _owner from null to the BasicLock\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  MachNode* last_m = NULL;\n+  MachNode* last_m = nullptr;\n@@ -89,1 +89,1 @@\n-        last_m = NULL;\n+        last_m = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/c2_intelJccErratum_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  if (mark == NULL) {\n+  if (mark == nullptr) {\n@@ -53,2 +53,2 @@\n-  if (base == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed.\n+  if (base == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed.\n@@ -85,1 +85,1 @@\n-  guarantee(stub != NULL, \"stub not found\");\n+  guarantee(stub != nullptr, \"stub not found\");\n@@ -111,1 +111,1 @@\n-  assert(stub != NULL, \"stub not found\");\n+  assert(stub != nullptr, \"stub not found\");\n@@ -131,1 +131,1 @@\n-  assert(cb != NULL, \"sanity\");\n+  assert(cb != nullptr, \"sanity\");\n@@ -136,1 +136,1 @@\n-  assert(stub != NULL, \"no stub found for static call\");\n+  assert(stub != nullptr, \"no stub found for static call\");\n","filename":"src\/hotspot\/cpu\/x86\/compiledIC_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  \/\/ at(frame::interpreter_frame_last_sp_offset) can be NULL at safepoint preempts\n+  \/\/ at(frame::interpreter_frame_last_sp_offset) can be null at safepoint preempts\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  static address decode_instruction0(address here, outputStream* st, address virtual_begin = NULL) {\n+  static address decode_instruction0(address here, outputStream* st, address virtual_begin = nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/disassembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-     _oop_maps(NULL) {\n+     _oop_maps(nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  if (_cb != NULL ) {\n+  if (_cb != nullptr ) {\n@@ -116,4 +116,4 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n+    intptr_t* sender_sp = nullptr;\n+    intptr_t* sender_unextended_sp = nullptr;\n+    address   sender_pc = nullptr;\n+    intptr_t* saved_fp =  nullptr;\n@@ -184,1 +184,1 @@\n-    if (sender_pc == NULL ||  sender_blob == NULL) {\n+    if (sender_pc == nullptr ||  sender_blob == nullptr) {\n@@ -217,1 +217,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -259,1 +259,1 @@\n-  if ( (address) this->fp()[return_addr_offset] == NULL) return false;\n+  if ( (address) this->fp()[return_addr_offset] == nullptr) return false;\n@@ -287,1 +287,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -359,1 +359,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -386,1 +386,1 @@\n-  return jfa->last_Java_sp() == NULL;\n+  return jfa->last_Java_sp() == nullptr;\n@@ -390,1 +390,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -435,1 +435,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -437,1 +437,1 @@\n-    if (sender_cm != NULL) {\n+    if (sender_cm != nullptr) {\n@@ -563,1 +563,1 @@\n-        obj = (obj_p == NULL) ? (oop)NULL : *obj_p;\n+        obj = (obj_p == nullptr) ? (oop)nullptr : *obj_p;\n@@ -662,1 +662,1 @@\n-  if (last_Java_sp() == NULL) return;\n+  if (last_Java_sp() == nullptr) return;\n@@ -665,1 +665,1 @@\n-  vmassert(last_Java_pc() == NULL, \"already walkable\");\n+  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -42,5 +42,5 @@\n-  _pc = NULL;\n-  _sp = NULL;\n-  _unextended_sp = NULL;\n-  _fp = NULL;\n-  _cb = NULL;\n+  _pc = nullptr;\n+  _sp = nullptr;\n+  _unextended_sp = nullptr;\n+  _fp = nullptr;\n+  _cb = nullptr;\n@@ -48,1 +48,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -58,1 +58,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -62,1 +62,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -71,1 +71,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -74,1 +74,1 @@\n-    assert(_cb == NULL || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n@@ -94,1 +94,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -96,2 +96,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n@@ -118,1 +118,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -135,1 +135,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -137,2 +137,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n@@ -163,1 +163,1 @@\n-  \/\/ assert(_pc != NULL, \"no pc?\");\n+  \/\/ assert(_pc != nullptr, \"no pc?\");\n@@ -169,1 +169,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -175,1 +175,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -190,1 +190,1 @@\n-\/\/ identity and younger\/older relationship. NULL represents an invalid (incomparable)\n+\/\/ identity and younger\/older relationship. null represents an invalid (incomparable)\n@@ -195,1 +195,1 @@\n-inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -202,1 +202,1 @@\n-  return os::is_readable_pointer(ptr) ? *ptr : NULL;\n+  return os::is_readable_pointer(ptr) ? *ptr : nullptr;\n@@ -211,1 +211,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -235,1 +235,1 @@\n-  assert(mask != NULL, \"\");\n+  assert(mask != nullptr, \"\");\n@@ -288,1 +288,1 @@\n-  if (last_sp == NULL) {\n+  if (last_sp == nullptr) {\n@@ -326,1 +326,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -332,1 +332,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -346,2 +346,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -349,1 +349,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -356,1 +356,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -386,1 +386,1 @@\n-  if (_cb != NULL) return sender_for_compiled_frame(map);\n+  if (_cb != nullptr) return sender_for_compiled_frame(map);\n@@ -394,1 +394,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -415,1 +415,1 @@\n-      if (oop_map() != NULL) {\n+      if (oop_map() != nullptr) {\n@@ -421,1 +421,1 @@\n-      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+      assert(oop_map() == nullptr || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-  \/\/ that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(ebp+frame::interpreter_frame_last_sp) == nullptr.\n@@ -294,1 +294,1 @@\n-  \/\/ crosses regions, storing NULL?\n+  \/\/ crosses regions, storing null?\n@@ -299,1 +299,1 @@\n-  \/\/ storing region crossing non-NULL, is card already dirty?\n+  \/\/ storing region crossing non-null, is card already dirty?\n@@ -319,1 +319,1 @@\n-  \/\/ storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ storing a region crossing, non-null oop, card is clean.\n@@ -522,1 +522,1 @@\n-  \/\/ At this point we know new_value is non-NULL and the new_value crosses regions.\n+  \/\/ At this point we know new_value is non-null and the new_value crosses regions.\n@@ -552,1 +552,1 @@\n-  \/\/ storing region crossing non-NULL, card is clean.\n+  \/\/ storing region crossing non-null, card is clean.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n@@ -399,1 +399,1 @@\n-  if (slow_path != NULL) {\n+  if (slow_path != nullptr) {\n@@ -412,1 +412,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n@@ -433,1 +433,1 @@\n-  if (bs == NULL) {\n+  if (bs == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-  \/\/ that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(ebp+frame::interpreter_frame_last_sp) == nullptr.\n@@ -706,1 +706,1 @@\n-  \/\/ Filter: when offending in-memory value is NULL, the failure is definitely legitimate\n+  \/\/ Filter: when offending in-memory value is null, the failure is definitely legitimate\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap NULLs passed to check cast\n+define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap nulls passed to check cast\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  \/\/ assert(cached_value == NULL || cached_oop->is_perm(), \"must be perm oop\");\n+  \/\/ assert(cached_value == nullptr || cached_oop->is_perm(), \"must be perm oop\");\n","filename":"src\/hotspot\/cpu\/x86\/icBuffer_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != null\");\n@@ -303,1 +303,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != nullptr\");\n@@ -402,1 +402,1 @@\n-    jcc(Assembler::zero, L); \/\/ if (thread->jvmti_thread_state() == NULL) exit;\n+    jcc(Assembler::zero, L); \/\/ if (thread->jvmti_thread_state() == nullptr) exit;\n@@ -1380,1 +1380,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1763,1 +1763,1 @@\n-  \/\/ observed the item[start_row] is NULL.\n+  \/\/ observed the item[start_row] is null.\n@@ -1779,1 +1779,1 @@\n-\/\/   if (row[0].rec != NULL) {\n+\/\/   if (row[0].rec != nullptr) {\n@@ -1782,1 +1782,1 @@\n-\/\/     if (row[1].rec != NULL) {\n+\/\/     if (row[1].rec != nullptr) {\n@@ -1785,1 +1785,1 @@\n-\/\/       if (row[2].rec != NULL) { count.incr(); goto done; } \/\/ overflow\n+\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n@@ -1991,1 +1991,1 @@\n-  if (where != NULL) {\n+  if (where != nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    \/\/ NULL last_sp until next java call\n+    \/\/ null last_sp until next java call\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    _last_Java_sp = NULL;\n+    _last_Java_sp = nullptr;\n@@ -44,2 +44,2 @@\n-    _last_Java_fp = NULL;\n-    _last_Java_pc = NULL;\n+    _last_Java_fp = nullptr;\n+    _last_Java_pc = nullptr;\n@@ -53,1 +53,1 @@\n-    \/\/ To act like previous version (pd_cache_state) don't NULL _last_Java_sp\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n@@ -57,1 +57,1 @@\n-      _last_Java_sp = NULL;\n+      _last_Java_sp = nullptr;\n@@ -65,1 +65,1 @@\n-  bool walkable(void)                            { return _last_Java_sp != NULL && _last_Java_pc != NULL; }\n+  bool walkable(void)                            { return _last_Java_sp != nullptr && _last_Java_pc != nullptr; }\n","filename":"src\/hotspot\/cpu\/x86\/javaFrameAnchor_x86.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  const char *name = NULL;\n+  const char *name = nullptr;\n@@ -131,1 +131,1 @@\n-  address slow_case_addr = NULL;\n+  address slow_case_addr = nullptr;\n@@ -267,1 +267,1 @@\n-  const char *name = NULL;\n+  const char *name = nullptr;\n@@ -346,1 +346,1 @@\n-  address slow_case_addr = NULL;\n+  address slow_case_addr = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_32.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  const char *name = NULL;\n+  const char *name = nullptr;\n@@ -110,1 +110,1 @@\n-  address slow_case_addr = NULL;\n+  address slow_case_addr = nullptr;\n@@ -153,1 +153,1 @@\n-  const char *name = NULL;\n+  const char *name = nullptr;\n@@ -202,1 +202,1 @@\n-  address slow_case_addr = NULL;\n+  address slow_case_addr = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-  NativeCall* call = NULL;\n+  NativeCall* call = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-  \/\/ See if oop is NULL if it is we need no handle\n+  \/\/ See if oop is null if it is we need no handle\n@@ -1052,1 +1052,1 @@\n-    \/\/ conditionally move a NULL\n+    \/\/ conditionally move a null\n@@ -1057,1 +1057,1 @@\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-null\n@@ -1080,1 +1080,1 @@\n-    \/\/ Store oop in handle area, may be NULL\n+    \/\/ Store oop in handle area, may be null\n@@ -1088,1 +1088,1 @@\n-    \/\/ conditionally move a NULL from the handle area where it was just stored\n+    \/\/ conditionally move a null from the handle area where it was just stored\n@@ -1347,1 +1347,1 @@\n-  mov_metadata(rbx, (Metadata*) NULL);  \/\/ Method is zapped till fixup time.\n+  mov_metadata(rbx, (Metadata*) nullptr);  \/\/ Method is zapped till fixup time.\n@@ -1565,1 +1565,1 @@\n-  set_last_Java_frame(java_thread, last_java_sp, rbp, NULL, rscratch1);\n+  set_last_Java_frame(java_thread, last_java_sp, rbp, nullptr, rscratch1);\n@@ -2857,1 +2857,1 @@\n-    \/\/ provoke OS NULL exception if reg = NULL by\n+    \/\/ provoke OS null exception if reg is null by\n@@ -2866,1 +2866,1 @@\n-    \/\/ will provoke OS NULL exception if reg = NULL\n+    \/\/ will provoke OS null exception if reg is null\n@@ -2877,1 +2877,1 @@\n-  const char* buf = NULL;\n+  const char* buf = nullptr;\n@@ -3108,1 +3108,1 @@\n-  if (last_java_pc != NULL) {\n+  if (last_java_pc != nullptr) {\n@@ -3890,1 +3890,1 @@\n-  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  jcc(Assembler::zero, done);           \/\/ Use null as-is.\n@@ -3924,1 +3924,1 @@\n-  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  jcc(Assembler::zero, done);           \/\/ Use null as-is.\n@@ -4265,1 +4265,1 @@\n-  \/\/ for (scan = klass->itable(); scan->interface() != NULL; scan += scan_step) {\n+  \/\/ for (scan = klass->itable(); scan->interface() != nullptr; scan += scan_step) {\n@@ -4323,2 +4323,2 @@\n-  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, NULL);\n-  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, NULL);\n+  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, nullptr);\n+  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, nullptr);\n@@ -4347,4 +4347,4 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -4446,3 +4446,3 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -4504,1 +4504,1 @@\n-    assert(!pushed_rdi, \"rdi must be left non-NULL\");\n+    assert(!pushed_rdi, \"rdi must be left non-null\");\n@@ -4525,1 +4525,1 @@\n-  assert(L_fast_path != NULL || L_slow_path != NULL, \"at least one is required\");\n+  assert(L_fast_path != nullptr || L_slow_path != nullptr, \"at least one is required\");\n@@ -4528,1 +4528,1 @@\n-  if (L_fast_path == NULL) {\n+  if (L_fast_path == nullptr) {\n@@ -4530,1 +4530,1 @@\n-  } else if (L_slow_path == NULL) {\n+  } else if (L_slow_path == nullptr) {\n@@ -4584,1 +4584,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -4654,1 +4654,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -4723,1 +4723,1 @@\n-        rc = NULL; \/\/ silence compiler warnings\n+        rc = nullptr; \/\/ silence compiler warnings\n@@ -4734,1 +4734,1 @@\n-        pc = NULL; \/\/ silence compiler warnings\n+        pc = nullptr; \/\/ silence compiler warnings\n@@ -4856,1 +4856,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5192,1 +5192,1 @@\n-\/\/ Used for storing NULLs.\n+\/\/ Used for storing nulls.\n@@ -5208,1 +5208,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -5233,1 +5233,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -5258,1 +5258,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -5282,1 +5282,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -5295,1 +5295,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -5313,1 +5313,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -5320,1 +5320,1 @@\n-    if (CompressedOops::base() != NULL) {\n+    if (CompressedOops::base() != nullptr) {\n@@ -5324,1 +5324,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -5331,1 +5331,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -5344,1 +5344,1 @@\n-      if (CompressedOops::base() != NULL) {\n+      if (CompressedOops::base() != nullptr) {\n@@ -5349,1 +5349,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -5358,1 +5358,1 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  if (CompressedKlassPointers::base() != nullptr) {\n@@ -5370,1 +5370,1 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  if (CompressedKlassPointers::base() != nullptr) {\n@@ -5393,1 +5393,1 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  if (CompressedKlassPointers::base() != nullptr) {\n@@ -5407,1 +5407,1 @@\n-  if (CompressedKlassPointers::base() == NULL &&\n+  if (CompressedKlassPointers::base() == nullptr &&\n@@ -5413,1 +5413,1 @@\n-    if (CompressedKlassPointers::base() != NULL) {\n+    if (CompressedKlassPointers::base() != nullptr) {\n@@ -5430,2 +5430,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5439,2 +5439,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5448,1 +5448,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5456,1 +5456,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5464,2 +5464,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5473,2 +5473,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5482,1 +5482,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5490,1 +5490,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5498,2 +5498,2 @@\n-    if (Universe::heap() != NULL) {\n-      if (CompressedOops::base() == NULL) {\n+    if (Universe::heap() != nullptr) {\n+      if (CompressedOops::base() == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  \/\/ Support for NULL-checks\n+  \/\/ Support for null-checks\n@@ -96,1 +96,1 @@\n-  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ Generates code that causes a null OS exception if the content of reg is null.\n@@ -122,1 +122,1 @@\n-                file == NULL ? \"<NULL>\" : file, line);\n+                file == nullptr ? \"<null>\" : file, line);\n@@ -380,1 +380,1 @@\n-  \/\/ Used for storing NULL. All other oop constants should be\n+  \/\/ Used for storing null. All other oop constants should be\n@@ -388,1 +388,1 @@\n-  \/\/ converting a zero (like NULL) into a Register by giving\n+  \/\/ converting a zero (like null) into a Register by giving\n@@ -613,1 +613,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n@@ -646,2 +646,2 @@\n-                      Label* L_fast_path = NULL,\n-                      Label* L_slow_path = NULL);\n+                      Label* L_fast_path = nullptr,\n+                      Label* L_slow_path = nullptr);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,1 +234,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -241,1 +241,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -524,2 +524,2 @@\n-  bool has_mh = (strstr(adaptername, \"\/static\") == NULL &&\n-                 strstr(adaptername, \"linkTo\") == NULL);    \/\/ static linkers don't have MH\n+  bool has_mh = (strstr(adaptername, \"\/static\") == nullptr &&\n+                 strstr(adaptername, \"linkTo\") == nullptr);    \/\/ static linkers don't have MH\n@@ -587,1 +587,1 @@\n-          assert(trace_calling_frame.cb() == NULL, \"not a C frame\");\n+          assert(trace_calling_frame.cb() == nullptr, \"not a C frame\");\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,1 +223,1 @@\n-  assert (instr_addr != NULL, \"illegal address for code patching\");\n+  assert (instr_addr != nullptr, \"illegal address for code patching\");\n@@ -619,1 +619,1 @@\n-   assert (instr_addr != NULL, \"illegal address for code patching (4)\");\n+   assert (instr_addr != nullptr, \"illegal address for code patching (4)\");\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -748,1 +748,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        return NULL; \/\/ ZMM16-31 are stored in full.\n+        return nullptr; \/\/ ZMM16-31 are stored in full.\n@@ -44,1 +44,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -58,1 +58,1 @@\n-    if (base_location != NULL) {\n+    if (base_location != nullptr) {\n@@ -62,1 +62,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-  if (orig_addr != NULL) {\n+  if (orig_addr != nullptr) {\n@@ -107,1 +107,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-  __ set_last_Java_frame(rcx, noreg, noreg, NULL, noreg);\n+  __ set_last_Java_frame(rcx, noreg, noreg, nullptr, noreg);\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -748,1 +748,1 @@\n-      (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {\n+      (Interpreter::code() != nullptr || StubRoutines::code1() != nullptr)) {\n@@ -755,1 +755,1 @@\n-    if (Interpreter::code() != NULL)\n+    if (Interpreter::code() != nullptr)\n@@ -759,1 +759,1 @@\n-    if (StubRoutines::code1() != NULL)\n+    if (StubRoutines::code1() != nullptr)\n@@ -763,1 +763,1 @@\n-    if (StubRoutines::code2() != NULL)\n+    if (StubRoutines::code2() != nullptr)\n@@ -979,1 +979,1 @@\n-  assert(regs2 == NULL, \"not needed on x86\");\n+  assert(regs2 == nullptr, \"not needed on x86\");\n@@ -1331,1 +1331,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       (OopMapSet*)nullptr);\n@@ -1334,1 +1334,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -1350,1 +1350,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -1365,1 +1365,1 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -1491,1 +1491,1 @@\n-  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  bs->nmethod_entry_barrier(masm, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n@@ -2077,1 +2077,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2206,1 +2206,1 @@\n-  __ set_last_Java_frame(rcx, noreg, noreg, NULL, noreg);\n+  __ set_last_Java_frame(rcx, noreg, noreg, nullptr, noreg);\n@@ -2354,1 +2354,1 @@\n-  __ set_last_Java_frame(rcx, noreg, rbp, NULL, noreg);\n+  __ set_last_Java_frame(rcx, noreg, rbp, nullptr, noreg);\n@@ -2451,1 +2451,1 @@\n-  __ set_last_Java_frame(rdx, noreg, noreg, NULL, noreg);\n+  __ set_last_Java_frame(rdx, noreg, noreg, nullptr, noreg);\n@@ -2563,1 +2563,1 @@\n-  __ set_last_Java_frame(rdi, noreg, rbp, NULL, noreg);\n+  __ set_last_Java_frame(rdi, noreg, rbp, nullptr, noreg);\n@@ -2603,1 +2603,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2616,1 +2616,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -2645,1 +2645,1 @@\n-  __ set_last_Java_frame(java_thread, noreg, noreg, NULL, noreg);\n+  __ set_last_Java_frame(java_thread, noreg, noreg, nullptr, noreg);\n@@ -2758,1 +2758,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2772,1 +2772,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2784,1 +2784,1 @@\n-  __ set_last_Java_frame(thread, noreg, rbp, NULL, noreg);\n+  __ set_last_Java_frame(thread, noreg, rbp, nullptr, noreg);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-      (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {\n+      (Interpreter::code() != nullptr || StubRoutines::code1() != nullptr)) {\n@@ -808,1 +808,1 @@\n-    if (Interpreter::code() != NULL)\n+    if (Interpreter::code() != nullptr)\n@@ -812,1 +812,1 @@\n-    if (StubRoutines::code1() != NULL)\n+    if (StubRoutines::code1() != nullptr)\n@@ -816,1 +816,1 @@\n-    if (StubRoutines::code2() != NULL)\n+    if (StubRoutines::code2() != nullptr)\n@@ -1017,1 +1017,1 @@\n-  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_no_clinit_check_entry = nullptr;\n@@ -1052,1 +1052,1 @@\n-  assert(regs2 == NULL, \"not needed on x86\");\n+  assert(regs2 == nullptr, \"not needed on x86\");\n@@ -1765,1 +1765,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       nullptr);\n@@ -1768,1 +1768,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -1785,1 +1785,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -1800,1 +1800,1 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -1930,1 +1930,1 @@\n-  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  bs->nmethod_entry_barrier(masm, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n@@ -2528,1 +2528,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2606,1 +2606,1 @@\n-    __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+    __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n@@ -2688,1 +2688,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n@@ -2721,1 +2721,1 @@\n-  \/\/ QQQ this is useless it was NULL above\n+  \/\/ QQQ this is useless it was null above\n@@ -2907,1 +2907,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n@@ -3065,1 +3065,1 @@\n-  assert(StubRoutines::forward_exception_entry() != NULL,\n+  assert(StubRoutines::forward_exception_entry() != nullptr,\n@@ -3077,1 +3077,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -3101,1 +3101,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);  \/\/ JavaFrameAnchor::capture_last_Java_pc() will get the pc from the return address, which we store next:\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);  \/\/ JavaFrameAnchor::capture_last_Java_pc() will get the pc from the return address, which we store next:\n@@ -3231,1 +3231,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -3242,1 +3242,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -3251,1 +3251,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-    assert(StubRoutines::_call_stub_return_address != NULL, \"_call_stub_return_address must have been generated before\");\n+    assert(StubRoutines::_call_stub_return_address != nullptr, \"_call_stub_return_address must have been generated before\");\n@@ -973,1 +973,1 @@\n-    __ jcc(Assembler::zero, exit);               \/\/ if obj is NULL it is ok\n+    __ jcc(Assembler::zero, exit);               \/\/ if obj is null it is ok\n@@ -986,1 +986,1 @@\n-    __ jcc(Assembler::zero, error);              \/\/ if klass is NULL it is broken\n+    __ jcc(Assembler::zero, error);              \/\/ if klass is null it is broken\n@@ -1112,1 +1112,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1289,1 +1289,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1547,1 +1547,1 @@\n-    if (label_ptr != NULL)  __ jcc(assembler_con, *(label_ptr));        \\\n+    if (label_ptr != nullptr)  __ jcc(assembler_con, *(label_ptr));        \\\n@@ -1553,1 +1553,1 @@\n-    \/\/                                  L_success, L_failure, NULL);\n+    \/\/                                  L_success, L_failure, null);\n@@ -1582,2 +1582,2 @@\n-    if (L_success == NULL) { BLOCK_COMMENT(\"L_success:\"); }\n-    if (L_failure == NULL) { BLOCK_COMMENT(\"L_failure:\"); }\n+    if (L_success == nullptr) { BLOCK_COMMENT(\"L_success:\"); }\n+    if (L_failure == nullptr) { BLOCK_COMMENT(\"L_failure:\"); }\n@@ -1637,1 +1637,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1705,1 +1705,1 @@\n-                        &L_store_element, NULL);\n+                        &L_store_element, nullptr);\n@@ -1912,1 +1912,1 @@\n-    \/\/ (5) src klass and dst klass should be the same and not NULL.\n+    \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -1924,1 +1924,1 @@\n-    \/\/  if (src == NULL) return -1;\n+    \/\/  if (src == null) return -1;\n@@ -1934,1 +1934,1 @@\n-    \/\/  if (dst == NULL) return -1;\n+    \/\/  if (dst == nullptr) return -1;\n@@ -1949,1 +1949,1 @@\n-    \/\/  if (src->klass() == NULL) return -1;\n+    \/\/  if (src->klass() == nullptr) return -1;\n@@ -1956,1 +1956,1 @@\n-    \/\/  assert(src->klass() != NULL);\n+    \/\/  assert(src->klass() != nullptr);\n@@ -1960,1 +1960,1 @@\n-      __ jccb(Assembler::notZero, L2);   \/\/ it is broken if klass is NULL\n+      __ jccb(Assembler::notZero, L2);   \/\/ it is broken if klass is null\n@@ -2133,1 +2133,1 @@\n-                          rdi_temp, NULL, &L_fail_array_check);\n+                          rdi_temp, nullptr, &L_fail_array_check);\n@@ -2197,1 +2197,1 @@\n-                               NULL, \"arrayof_jbyte_arraycopy\");\n+                               nullptr, \"arrayof_jbyte_arraycopy\");\n@@ -2210,1 +2210,1 @@\n-                               NULL, \"arrayof_jshort_arraycopy\");\n+                               nullptr, \"arrayof_jshort_arraycopy\");\n@@ -2239,1 +2239,1 @@\n-                               NULL, \"oop_arraycopy_uninit\",\n+                               nullptr, \"oop_arraycopy_uninit\",\n@@ -2268,1 +2268,1 @@\n-        generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL, \/*dest_uninitialized*\/true);\n+        generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr, \/*dest_uninitialized*\/true);\n@@ -3927,1 +3927,1 @@\n-    __ set_last_Java_frame(java_thread, rsp, rbp, NULL, noreg);\n+    __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n@@ -4234,1 +4234,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -4254,1 +4254,1 @@\n-  if (UnsafeCopyMemory::_table == NULL) {\n+  if (UnsafeCopyMemory::_table == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-  assert(StubRoutines::_call_stub_return_address != NULL,\n+  assert(StubRoutines::_call_stub_return_address != nullptr,\n@@ -1094,1 +1094,1 @@\n-  __ jcc(Assembler::zero, exit); \/\/ if obj is NULL it is OK\n+  __ jcc(Assembler::zero, exit); \/\/ if obj is null it is OK\n@@ -4088,1 +4088,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -4115,1 +4115,1 @@\n-  void *libjsvml = NULL;\n+  void *libjsvml = nullptr;\n@@ -4121,1 +4121,1 @@\n-  if (libjsvml != NULL) {\n+  if (libjsvml != nullptr) {\n@@ -4185,1 +4185,1 @@\n-  if (UnsafeCopyMemory::_table == NULL) {\n+  if (UnsafeCopyMemory::_table == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-    assert(no_overlap_target != NULL, \"must be generated\");\n-    array_overlap_test(no_overlap_target, NULL, sf);\n+    assert(no_overlap_target != nullptr, \"must be generated\");\n+    array_overlap_test(no_overlap_target, nullptr, sf);\n@@ -129,1 +129,1 @@\n-    array_overlap_test(NULL, &L_no_overlap, sf);\n+    array_overlap_test(nullptr, &L_no_overlap, sf);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-                                                                                   NULL, \"oop_arraycopy_uninit\",\n+                                                                                   nullptr, \"oop_arraycopy_uninit\",\n@@ -127,1 +127,1 @@\n-                                                                                    NULL, \"oop_arraycopy_uninit\",\n+                                                                                    nullptr, \"oop_arraycopy_uninit\",\n@@ -132,1 +132,1 @@\n-  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL,\n+  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n@@ -215,1 +215,1 @@\n-  if (NOLp == NULL) {\n+  if (NOLp == nullptr) {\n@@ -533,1 +533,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -755,1 +755,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1155,1 +1155,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1268,1 +1268,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1386,1 +1386,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1517,1 +1517,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1628,1 +1628,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1735,1 +1735,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1853,1 +1853,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1961,1 +1961,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -2043,1 +2043,1 @@\n-  __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, NULL,\n+  __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, nullptr,\n@@ -2045,1 +2045,1 @@\n-  __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, NULL);\n+  __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, nullptr);\n@@ -2122,1 +2122,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -2429,1 +2429,1 @@\n-  \/\/ (5) src klass and dst klass should be the same and not NULL.\n+  \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -2435,1 +2435,1 @@\n-  \/\/  if (src == NULL) return -1;\n+  \/\/  if (src == nullptr) return -1;\n@@ -2444,1 +2444,1 @@\n-  \/\/  if (dst == NULL) return -1;\n+  \/\/  if (dst == nullptr) return -1;\n@@ -2472,1 +2472,1 @@\n-  \/\/  assert(src->klass() != NULL);\n+  \/\/  assert(src->klass() != nullptr);\n@@ -2477,1 +2477,1 @@\n-    __ jcc(Assembler::notZero, L2);   \/\/ it is broken if klass is NULL\n+    __ jcc(Assembler::notZero, L2);   \/\/ it is broken if klass is null\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -36,28 +36,28 @@\n-address StubRoutines::x86::_verify_mxcsr_entry = NULL;\n-address StubRoutines::x86::_upper_word_mask_addr = NULL;\n-address StubRoutines::x86::_shuffle_byte_flip_mask_addr = NULL;\n-address StubRoutines::x86::_k256_adr = NULL;\n-address StubRoutines::x86::_vector_short_to_byte_mask = NULL;\n-address StubRoutines::x86::_vector_int_to_byte_mask = NULL;\n-address StubRoutines::x86::_vector_int_to_short_mask = NULL;\n-address StubRoutines::x86::_vector_all_bits_set = NULL;\n-address StubRoutines::x86::_vector_byte_shuffle_mask = NULL;\n-address StubRoutines::x86::_vector_int_mask_cmp_bits = NULL;\n-address StubRoutines::x86::_vector_short_shuffle_mask = NULL;\n-address StubRoutines::x86::_vector_int_shuffle_mask = NULL;\n-address StubRoutines::x86::_vector_long_shuffle_mask = NULL;\n-address StubRoutines::x86::_vector_float_sign_mask = NULL;\n-address StubRoutines::x86::_vector_float_sign_flip = NULL;\n-address StubRoutines::x86::_vector_double_sign_mask = NULL;\n-address StubRoutines::x86::_vector_double_sign_flip = NULL;\n-address StubRoutines::x86::_vector_byte_perm_mask = NULL;\n-address StubRoutines::x86::_vector_long_sign_mask = NULL;\n-address StubRoutines::x86::_vector_iota_indices = NULL;\n-address StubRoutines::x86::_vector_reverse_bit_lut = NULL;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_long = NULL;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_int = NULL;\n-address StubRoutines::x86::_vector_reverse_byte_perm_mask_short = NULL;\n-address StubRoutines::x86::_vector_popcount_lut = NULL;\n-address StubRoutines::x86::_vector_count_leading_zeros_lut = NULL;\n-address StubRoutines::x86::_vector_32_bit_mask = NULL;\n-address StubRoutines::x86::_vector_64_bit_mask = NULL;\n+address StubRoutines::x86::_verify_mxcsr_entry = nullptr;\n+address StubRoutines::x86::_upper_word_mask_addr = nullptr;\n+address StubRoutines::x86::_shuffle_byte_flip_mask_addr = nullptr;\n+address StubRoutines::x86::_k256_adr = nullptr;\n+address StubRoutines::x86::_vector_short_to_byte_mask = nullptr;\n+address StubRoutines::x86::_vector_int_to_byte_mask = nullptr;\n+address StubRoutines::x86::_vector_int_to_short_mask = nullptr;\n+address StubRoutines::x86::_vector_all_bits_set = nullptr;\n+address StubRoutines::x86::_vector_byte_shuffle_mask = nullptr;\n+address StubRoutines::x86::_vector_int_mask_cmp_bits = nullptr;\n+address StubRoutines::x86::_vector_short_shuffle_mask = nullptr;\n+address StubRoutines::x86::_vector_int_shuffle_mask = nullptr;\n+address StubRoutines::x86::_vector_long_shuffle_mask = nullptr;\n+address StubRoutines::x86::_vector_float_sign_mask = nullptr;\n+address StubRoutines::x86::_vector_float_sign_flip = nullptr;\n+address StubRoutines::x86::_vector_double_sign_mask = nullptr;\n+address StubRoutines::x86::_vector_double_sign_flip = nullptr;\n+address StubRoutines::x86::_vector_byte_perm_mask = nullptr;\n+address StubRoutines::x86::_vector_long_sign_mask = nullptr;\n+address StubRoutines::x86::_vector_iota_indices = nullptr;\n+address StubRoutines::x86::_vector_reverse_bit_lut = nullptr;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_long = nullptr;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_int = nullptr;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_short = nullptr;\n+address StubRoutines::x86::_vector_popcount_lut = nullptr;\n+address StubRoutines::x86::_vector_count_leading_zeros_lut = nullptr;\n+address StubRoutines::x86::_vector_32_bit_mask = nullptr;\n+address StubRoutines::x86::_vector_64_bit_mask = nullptr;\n@@ -65,3 +65,3 @@\n-address StubRoutines::x86::_k256_W_adr = NULL;\n-address StubRoutines::x86::_k512_W_addr = NULL;\n-address StubRoutines::x86::_pshuffle_byte_flip_mask_addr_sha512 = NULL;\n+address StubRoutines::x86::_k256_W_adr = nullptr;\n+address StubRoutines::x86::_k512_W_addr = nullptr;\n+address StubRoutines::x86::_pshuffle_byte_flip_mask_addr_sha512 = nullptr;\n@@ -69,16 +69,16 @@\n-address StubRoutines::x86::_encoding_table_base64 = NULL;\n-address StubRoutines::x86::_shuffle_base64 = NULL;\n-address StubRoutines::x86::_avx2_shuffle_base64 = NULL;\n-address StubRoutines::x86::_avx2_input_mask_base64 = NULL;\n-address StubRoutines::x86::_avx2_lut_base64 = NULL;\n-address StubRoutines::x86::_avx2_decode_tables_base64 = NULL;\n-address StubRoutines::x86::_avx2_decode_lut_tables_base64 = NULL;\n-address StubRoutines::x86::_lookup_lo_base64 = NULL;\n-address StubRoutines::x86::_lookup_hi_base64 = NULL;\n-address StubRoutines::x86::_lookup_lo_base64url = NULL;\n-address StubRoutines::x86::_lookup_hi_base64url = NULL;\n-address StubRoutines::x86::_pack_vec_base64 = NULL;\n-address StubRoutines::x86::_join_0_1_base64 = NULL;\n-address StubRoutines::x86::_join_1_2_base64 = NULL;\n-address StubRoutines::x86::_join_2_3_base64 = NULL;\n-address StubRoutines::x86::_decoding_table_base64 = NULL;\n+address StubRoutines::x86::_encoding_table_base64 = nullptr;\n+address StubRoutines::x86::_shuffle_base64 = nullptr;\n+address StubRoutines::x86::_avx2_shuffle_base64 = nullptr;\n+address StubRoutines::x86::_avx2_input_mask_base64 = nullptr;\n+address StubRoutines::x86::_avx2_lut_base64 = nullptr;\n+address StubRoutines::x86::_avx2_decode_tables_base64 = nullptr;\n+address StubRoutines::x86::_avx2_decode_lut_tables_base64 = nullptr;\n+address StubRoutines::x86::_lookup_lo_base64 = nullptr;\n+address StubRoutines::x86::_lookup_hi_base64 = nullptr;\n+address StubRoutines::x86::_lookup_lo_base64url = nullptr;\n+address StubRoutines::x86::_lookup_hi_base64url = nullptr;\n+address StubRoutines::x86::_pack_vec_base64 = nullptr;\n+address StubRoutines::x86::_join_0_1_base64 = nullptr;\n+address StubRoutines::x86::_join_1_2_base64 = nullptr;\n+address StubRoutines::x86::_join_2_3_base64 = nullptr;\n+address StubRoutines::x86::_decoding_table_base64 = nullptr;\n@@ -86,1 +86,1 @@\n-address StubRoutines::x86::_pshuffle_byte_flip_mask_addr = NULL;\n+address StubRoutines::x86::_pshuffle_byte_flip_mask_addr = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-address StubRoutines::x86::_verify_fpu_cntrl_wrd_entry = NULL;\n-address StubRoutines::x86::_method_entry_barrier = NULL;\n+address StubRoutines::x86::_verify_fpu_cntrl_wrd_entry = nullptr;\n+address StubRoutines::x86::_method_entry_barrier = nullptr;\n@@ -37,2 +37,2 @@\n-address StubRoutines::x86::_d2i_wrapper = NULL;\n-address StubRoutines::x86::_d2l_wrapper = NULL;\n+address StubRoutines::x86::_d2i_wrapper = nullptr;\n+address StubRoutines::x86::_d2l_wrapper = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_32.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-address StubRoutines::x86::_get_previous_sp_entry = NULL;\n+address StubRoutines::x86::_get_previous_sp_entry = nullptr;\n@@ -38,9 +38,9 @@\n-address StubRoutines::x86::_f2i_fixup = NULL;\n-address StubRoutines::x86::_f2l_fixup = NULL;\n-address StubRoutines::x86::_d2i_fixup = NULL;\n-address StubRoutines::x86::_d2l_fixup = NULL;\n-address StubRoutines::x86::_float_sign_mask = NULL;\n-address StubRoutines::x86::_float_sign_flip = NULL;\n-address StubRoutines::x86::_double_sign_mask = NULL;\n-address StubRoutines::x86::_double_sign_flip = NULL;\n-address StubRoutines::x86::_method_entry_barrier = NULL;\n+address StubRoutines::x86::_f2i_fixup = nullptr;\n+address StubRoutines::x86::_f2l_fixup = nullptr;\n+address StubRoutines::x86::_d2i_fixup = nullptr;\n+address StubRoutines::x86::_d2l_fixup = nullptr;\n+address StubRoutines::x86::_float_sign_mask = nullptr;\n+address StubRoutines::x86::_float_sign_flip = nullptr;\n+address StubRoutines::x86::_double_sign_mask = nullptr;\n+address StubRoutines::x86::_double_sign_flip = nullptr;\n+address StubRoutines::x86::_method_entry_barrier = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  assert(!pass_oop || message == NULL, \"either oop or message but not both\");\n+  assert(!pass_oop || message == nullptr, \"either oop or message but not both\");\n@@ -209,1 +209,1 @@\n-  \/\/ and NULL it as marker that esp is now tos until next java call\n+  \/\/ and null it as marker that esp is now tos until next java call\n@@ -257,1 +257,1 @@\n-  \/\/ NULL last_sp until next java call\n+  \/\/ null last_sp until next java call\n@@ -300,1 +300,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -437,2 +437,2 @@\n-  \/\/ (NULL bcp).  We pass zero for it.  The call returns the address\n-  \/\/ of the verified entry point for the method or NULL if the\n+  \/\/ (null bcp).  We pass zero for it.  The call returns the address\n+  \/\/ of the verified entry point for the method or null if the\n@@ -538,1 +538,1 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != NULL, \"stub not yet generated\");\n+  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n@@ -592,1 +592,1 @@\n-      __ stop(\"synchronization object is NULL\");\n+      __ stop(\"synchronization object is null\");\n@@ -690,1 +690,1 @@\n-  \/\/ Check if local 0 != NULL\n+  \/\/ Check if local 0 != null\n@@ -1305,1 +1305,1 @@\n-  \/\/  pop return address, reset last_sp to NULL\n+  \/\/  pop return address, reset last_sp to null\n@@ -1653,1 +1653,1 @@\n-    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.\n+    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or null.\n@@ -1842,1 +1842,1 @@\n-  assert(Interpreter::trace_code(t->tos_in()) != NULL,\n+  assert(Interpreter::trace_code(t->tos_in()) != nullptr,\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -161,1 +161,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -208,1 +208,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -234,1 +234,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -260,1 +260,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -287,1 +287,1 @@\n-   return NULL;\n+   return nullptr;\n@@ -314,1 +314,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -375,1 +375,1 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n+  if (!InlineIntrinsics) return nullptr; \/\/ Generate a vanilla entry\n@@ -396,1 +396,1 @@\n-      return NULL; \/\/ Generate a vanilla entry\n+      return nullptr; \/\/ Generate a vanilla entry\n@@ -409,1 +409,1 @@\n-      return NULL; \/\/ Generate a vanilla entry\n+      return nullptr; \/\/ Generate a vanilla entry\n@@ -427,1 +427,1 @@\n-        if (VM_Version::supports_sse2() && StubRoutines::dsin() != NULL) {\n+        if (VM_Version::supports_sse2() && StubRoutines::dsin() != nullptr) {\n@@ -437,1 +437,1 @@\n-        if (VM_Version::supports_sse2() && StubRoutines::dcos() != NULL) {\n+        if (VM_Version::supports_sse2() && StubRoutines::dcos() != nullptr) {\n@@ -447,1 +447,1 @@\n-        if (StubRoutines::dtan() != NULL) {\n+        if (StubRoutines::dtan() != nullptr) {\n@@ -463,1 +463,1 @@\n-        if (StubRoutines::dlog() != NULL) {\n+        if (StubRoutines::dlog() != nullptr) {\n@@ -473,1 +473,1 @@\n-        if (StubRoutines::dlog10() != NULL) {\n+        if (StubRoutines::dlog10() != nullptr) {\n@@ -485,1 +485,1 @@\n-      if (StubRoutines::dpow() != NULL) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -495,1 +495,1 @@\n-      if (StubRoutines::dexp() != NULL) {\n+      if (StubRoutines::dexp() != nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_32.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  \/\/        bcp (NULL)\n+  \/\/        bcp (null)\n@@ -141,1 +141,1 @@\n-  \/\/        bcp (NULL)\n+  \/\/        bcp (null)\n@@ -224,1 +224,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -281,1 +281,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -332,1 +332,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -399,1 +399,1 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n+  if (!InlineIntrinsics) return nullptr; \/\/ Generate a vanilla entry\n@@ -421,1 +421,1 @@\n-      return NULL; \/\/ Generate a vanilla entry\n+      return nullptr; \/\/ Generate a vanilla entry\n@@ -429,1 +429,1 @@\n-      return NULL; \/\/ Generate a vanilla entry\n+      return nullptr; \/\/ Generate a vanilla entry\n@@ -439,1 +439,1 @@\n-    if (StubRoutines::dexp() != NULL) {\n+    if (StubRoutines::dexp() != nullptr) {\n@@ -446,1 +446,1 @@\n-    if (StubRoutines::dlog() != NULL) {\n+    if (StubRoutines::dlog() != nullptr) {\n@@ -453,1 +453,1 @@\n-    if (StubRoutines::dlog10() != NULL) {\n+    if (StubRoutines::dlog10() != nullptr) {\n@@ -460,1 +460,1 @@\n-    if (StubRoutines::dsin() != NULL) {\n+    if (StubRoutines::dsin() != nullptr) {\n@@ -467,1 +467,1 @@\n-    if (StubRoutines::dcos() != NULL) {\n+    if (StubRoutines::dcos() != nullptr) {\n@@ -475,1 +475,1 @@\n-    if (StubRoutines::dpow() != NULL) {\n+    if (StubRoutines::dpow() != nullptr) {\n@@ -482,1 +482,1 @@\n-    if (StubRoutines::dtan() != NULL) {\n+    if (StubRoutines::dtan() != nullptr) {\n@@ -488,1 +488,1 @@\n-    assert(StubRoutines::x86::double_sign_mask() != NULL, \"not initialized\");\n+    assert(StubRoutines::x86::double_sign_mask() != nullptr, \"not initialized\");\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,2 +146,2 @@\n-\/\/ Store an oop (or NULL) at the address described by obj.\n-\/\/ If val == noreg this means store a NULL\n+\/\/ Store an oop (or null) at the address described by obj.\n+\/\/ If val == noreg this means store a null\n@@ -455,1 +455,1 @@\n-    __ xorptr(result, result);  \/\/ NULL object reference\n+    __ xorptr(result, result);  \/\/ null object reference\n@@ -1158,1 +1158,1 @@\n-  \/\/ Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]\n+  \/\/ Have a null in rax, rdx=array, ecx=index.  Store null at ary[idx]\n@@ -1162,1 +1162,1 @@\n-  \/\/ Store a NULL\n+  \/\/ Store a null\n@@ -2211,1 +2211,1 @@\n-          UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+          UseOnStackReplacement ? &backedge_counter_overflow : nullptr);\n@@ -2219,1 +2219,1 @@\n-        UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+        UseOnStackReplacement ? &backedge_counter_overflow : nullptr);\n@@ -2245,1 +2245,1 @@\n-      \/\/ rax: osr nmethod (osr ok) or NULL (osr not possible)\n+      \/\/ rax: osr nmethod (osr ok) or null (osr not possible)\n@@ -2690,1 +2690,1 @@\n-    __ clinit_barrier(klass, thread, NULL \/*L_fast_path*\/, &L_clinit_barrier_slow);\n+    __ clinit_barrier(klass, thread, nullptr \/*L_fast_path*\/, &L_clinit_barrier_slow);\n@@ -2777,1 +2777,1 @@\n-      __ xorptr(rax, rax);      \/\/ NULL object reference\n+      __ xorptr(rax, rax);      \/\/ null object reference\n@@ -2783,1 +2783,1 @@\n-    \/\/ rax,:   object pointer or NULL\n+    \/\/ rax,:   object pointer or null\n@@ -3034,1 +3034,1 @@\n-    \/\/ c_rarg1: object pointer set up above (NULL if static)\n+    \/\/ c_rarg1: object pointer set up above (null if static)\n@@ -4115,1 +4115,1 @@\n-  \/\/ Collect counts on whether this check-cast sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this check-cast sees nulls a lot or not.\n@@ -4178,1 +4178,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -4187,2 +4187,2 @@\n-  \/\/ rax = 0: obj == NULL or  obj is not an instanceof the specified klass\n-  \/\/ rax = 1: obj != NULL and obj is     an instanceof the specified klass\n+  \/\/ rax = 0: obj == nullptr or  obj is not an instanceof the specified klass\n+  \/\/ rax = 1: obj != nullptr and obj is     an instanceof the specified klass\n@@ -4250,1 +4250,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n@@ -4266,1 +4266,1 @@\n-  __ xorl(rmon, rmon); \/\/ points to free slot or NULL\n+  __ xorl(rmon, rmon); \/\/ points to free slot or null\n@@ -4347,1 +4347,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n-static get_cpu_info_stub_t get_cpu_info_stub = NULL;\n-static detect_virt_stub_t detect_virt_stub = NULL;\n+static get_cpu_info_stub_t get_cpu_info_stub = nullptr;\n+static detect_virt_stub_t detect_virt_stub = nullptr;\n@@ -404,1 +404,1 @@\n-    \/\/ Generate SEGV here (reference through NULL)\n+    \/\/ Generate SEGV here (reference through null)\n@@ -2113,1 +2113,1 @@\n-  if (stub_blob == NULL) {\n+  if (stub_blob == nullptr) {\n@@ -2187,1 +2187,1 @@\n-static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;\n+static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = nullptr;\n@@ -2197,1 +2197,1 @@\n-static char* _cpu_brand_string = NULL;\n+static char* _cpu_brand_string = nullptr;\n@@ -2322,1 +2322,1 @@\n-  NULL\n+  nullptr\n@@ -2337,1 +2337,1 @@\n-  NULL\n+  nullptr\n@@ -2485,1 +2485,1 @@\n-  if (cpuid_brand_string_stub_blob == NULL) {\n+  if (cpuid_brand_string_stub_blob == nullptr) {\n@@ -2497,1 +2497,1 @@\n-  const char* model = NULL;\n+  const char* model = nullptr;\n@@ -2502,1 +2502,1 @@\n-      if (model == NULL) {\n+      if (model == nullptr) {\n@@ -2511,1 +2511,1 @@\n-  if (_cpu_brand_string == NULL) {\n+  if (_cpu_brand_string == nullptr) {\n@@ -2513,2 +2513,2 @@\n-    if (NULL == _cpu_brand_string) {\n-      return NULL;\n+    if (nullptr == _cpu_brand_string) {\n+      return nullptr;\n@@ -2519,1 +2519,1 @@\n-      _cpu_brand_string = NULL;\n+      _cpu_brand_string = nullptr;\n@@ -2526,1 +2526,1 @@\n-  const char*  brand  = NULL;\n+  const char*  brand  = nullptr;\n@@ -2531,1 +2531,1 @@\n-    for (int i = 0; brand != NULL && i <= brand_num; i += 1) {\n+    for (int i = 0; brand != nullptr && i <= brand_num; i += 1) {\n@@ -2621,1 +2621,1 @@\n-  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf != nullptr, \"buffer is null!\");\n@@ -2624,2 +2624,2 @@\n-  const char* cpu_type = NULL;\n-  const char* x64 = NULL;\n+  const char* cpu_type = nullptr;\n+  const char* x64 = nullptr;\n@@ -2658,1 +2658,1 @@\n-  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf != nullptr, \"buffer is null!\");\n@@ -2660,1 +2660,1 @@\n-  assert(getCPUIDBrandString_stub != NULL, \"not initialized\");\n+  assert(getCPUIDBrandString_stub != nullptr, \"not initialized\");\n@@ -2683,1 +2683,1 @@\n-  guarantee(buf != NULL, \"buffer is NULL!\");\n+  guarantee(buf != nullptr, \"buffer is null!\");\n@@ -2744,1 +2744,1 @@\n-  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf != nullptr, \"buffer is null!\");\n@@ -2749,3 +2749,3 @@\n-  const char*        family = NULL;\n-  const char*        model = NULL;\n-  const char*        brand = NULL;\n+  const char*        family = nullptr;\n+  const char*        model = nullptr;\n+  const char*        brand = nullptr;\n@@ -2755,1 +2755,1 @@\n-  if (family == NULL) {\n+  if (family == nullptr) {\n@@ -2760,1 +2760,1 @@\n-  if (model == NULL) {\n+  if (model == nullptr) {\n@@ -2766,1 +2766,1 @@\n-  if (brand == NULL) {\n+  if (brand == nullptr) {\n@@ -2768,1 +2768,1 @@\n-    if (brand == NULL) {\n+    if (brand == nullptr) {\n@@ -2837,1 +2837,1 @@\n-  if (brand_string == NULL) {\n+  if (brand_string == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,3 +63,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -132,1 +132,1 @@\n-    __ stop(\"Vtable entry is NULL\");\n+    __ stop(\"Vtable entry is null\");\n@@ -155,3 +155,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_32.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,3 +52,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -123,1 +123,1 @@\n-    __ stop(\"Vtable entry is NULL\");\n+    __ stop(\"Vtable entry is null\");\n@@ -146,3 +146,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}