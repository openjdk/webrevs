{"files":[{"patch":"@@ -86,0 +86,16 @@\n+    private static class WhereClauses {\n+        private final Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses;\n+\n+        WhereClauses() {\n+            Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses = new EnumMap<>(WhereClauseKind.class);\n+            for (WhereClauseKind kind : WhereClauseKind.values()) {\n+                whereClauses.put(kind, new LinkedHashMap<>());\n+            }\n+            this.whereClauses = whereClauses;\n+        }\n+\n+        public Map<Type, JCDiagnostic> get(WhereClauseKind kind) {\n+            return whereClauses.get(kind);\n+        }\n+    }\n+\n@@ -87,1 +103,14 @@\n-    Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses;\n+    WhereClauses whereClauses;\n+\n+    private void enter() {\n+        if (nameSimplifier != null || whereClauses != null) {\n+            throw new IllegalStateException();\n+        }\n+        nameSimplifier = new ClassNameSimplifier();\n+        whereClauses = new WhereClauses();\n+    }\n+\n+    private void exit() {\n+        nameSimplifier = null;\n+        whereClauses = null;\n+    }\n@@ -105,1 +134,0 @@\n-        whereClauses = new EnumMap<>(WhereClauseKind.class);\n@@ -107,2 +135,0 @@\n-        for (WhereClauseKind kind : WhereClauseKind.values())\n-            whereClauses.put(kind, new LinkedHashMap<Type, JCDiagnostic>());\n@@ -113,14 +139,14 @@\n-        StringBuilder sb = new StringBuilder();\n-        nameSimplifier = new ClassNameSimplifier();\n-        for (WhereClauseKind kind : WhereClauseKind.values())\n-            whereClauses.get(kind).clear();\n-        preprocessDiagnostic(diag);\n-        sb.append(formatter.format(diag, l));\n-        if (getConfiguration().isEnabled(RichFormatterFeature.WHERE_CLAUSES)) {\n-            List<JCDiagnostic> clauses = getWhereClauses();\n-            String indent = formatter.isRaw() ? \"\" :\n-                formatter.indentString(DetailsInc);\n-            for (JCDiagnostic d : clauses) {\n-                String whereClause = formatter.format(d, l);\n-                if (whereClause.length() > 0) {\n-                    sb.append('\\n' + indent + whereClause);\n+        enter();\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            preprocessDiagnostic(diag);\n+            sb.append(formatter.format(diag, l));\n+            if (getConfiguration().isEnabled(RichFormatterFeature.WHERE_CLAUSES)) {\n+                List<JCDiagnostic> clauses = getWhereClauses();\n+                String indent = formatter.isRaw() ? \"\" :\n+                        formatter.indentString(DetailsInc);\n+                for (JCDiagnostic d : clauses) {\n+                    String whereClause = formatter.format(d, l);\n+                    if (whereClause.length() > 0) {\n+                        sb.append('\\n' + indent + whereClause);\n+                    }\n@@ -129,0 +155,3 @@\n+            return sb.toString();\n+        } finally {\n+            exit();\n@@ -130,1 +159,0 @@\n-        return sb.toString();\n@@ -135,3 +163,7 @@\n-        nameSimplifier = new ClassNameSimplifier();\n-        preprocessDiagnostic(diag);\n-        return super.formatMessage(diag, l);\n+        enter();\n+        try {\n+            preprocessDiagnostic(diag);\n+            return super.formatMessage(diag, l);\n+        } finally {\n+            exit();\n+        }\n@@ -559,1 +591,1 @@\n-            t = (TypeVar)t.stripMetadataIfNeeded();\n+            t = (TypeVar)t.stripMetadata();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":55,"deletions":23,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8355065\n+ * @summary ConcurrentModificationException in RichDiagnosticFormatter\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.main jdk.compiler\/com.sun.tools.javac.api\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RichFormatterWithTypeAnnotationsTest\n+ *\/\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class RichFormatterWithTypeAnnotationsTest extends TestRunner {\n+    ToolBox tb;\n+\n+    public RichFormatterWithTypeAnnotationsTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new RichFormatterWithTypeAnnotationsTest()\n+                .runTests(m -> new Object[] {Paths.get(m.getName())});\n+    }\n+\n+    @Test\n+    public void test(Path base) throws Exception {\n+        Path libClasses = base.resolve(\"libclasses\");\n+        Files.createDirectories(libClasses);\n+        new JavacTask(tb)\n+                .outdir(libClasses)\n+                .sources(\n+                        \"\"\"\n+                        package lib;\n+                        enum Bar {\n+                          BAZ\n+                        }\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        import java.lang.annotation.ElementType;\n+                        import java.lang.annotation.Retention;\n+                        import java.lang.annotation.RetentionPolicy;\n+                        import java.lang.annotation.Target;\n+\n+                        @Retention(RetentionPolicy.RUNTIME)\n+                        @interface Foo {\n+                          Bar value();\n+                        }\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        import java.lang.annotation.ElementType;\n+                        import java.lang.annotation.Retention;\n+                        import java.lang.annotation.RetentionPolicy;\n+                        import java.lang.annotation.Target;\n+\n+                        @Retention(RetentionPolicy.RUNTIME)\n+                        @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+                        @Foo(Bar.BAZ)\n+                        @interface A {}\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        public interface M<K, V> {\n+                          @A\n+                          V f(K k, V v);\n+                        }\n+                        \"\"\")\n+                .options()\n+                .run()\n+                .writeAll();\n+        Files.delete(libClasses.resolve(\"lib\").resolve(\"Bar.class\"));\n+        String code =\n+                \"\"\"\n+                import lib.M;\n+                class T {\n+                  protected M m;\n+\n+                  public void f() {\n+                    m.f(null, 0);\n+                  }\n+                }\n+                \"\"\";\n+        List<String> output =\n+                new JavacTask(tb)\n+                        .classpath(libClasses)\n+                        .sources(code)\n+                        .options(\"-Xlint:all\", \"-Werror\", \"-XDrawDiagnostics\")\n+                        .run(Task.Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+        List<String> expected =\n+                Arrays.asList(\n+                        \"T.java:3:13: compiler.warn.raw.class.use: lib.M, lib.M<K,V>\",\n+                        \"T.java:6:8: compiler.warn.unchecked.call.mbr.of.raw.type: f(K,V), lib.M\",\n+                        \"- compiler.err.warnings.and.werror\",\n+                        \"1 error\",\n+                        \"2 warnings\");\n+        tb.checkEqual(expected, output);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/RichFormatterWithTypeAnnotationsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}