{"files":[{"patch":"@@ -559,1 +559,1 @@\n-            t = (TypeVar)t.stripMetadataIfNeeded();\n+            t = (TypeVar)t.stripMetadata();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8355065\n+ * @summary ConcurrentModificationException in RichDiagnosticFormatter\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.main jdk.compiler\/com.sun.tools.javac.api\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RichFormatterWithTypeAnnotationsTest\n+ *\/\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class RichFormatterWithTypeAnnotationsTest extends TestRunner {\n+    ToolBox tb;\n+\n+    public RichFormatterWithTypeAnnotationsTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new RichFormatterWithTypeAnnotationsTest()\n+                .runTests(m -> new Object[] {Paths.get(m.getName())});\n+    }\n+\n+    @Test\n+    public void test(Path base) throws Exception {\n+        Path libClasses = base.resolve(\"libclasses\");\n+        Files.createDirectories(libClasses);\n+        new JavacTask(tb)\n+                .outdir(libClasses)\n+                .sources(\n+                        \"\"\"\n+                        package lib;\n+                        enum Bar {\n+                          BAZ\n+                        }\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        import java.lang.annotation.ElementType;\n+                        import java.lang.annotation.Retention;\n+                        import java.lang.annotation.RetentionPolicy;\n+                        import java.lang.annotation.Target;\n+\n+                        @Retention(RetentionPolicy.RUNTIME)\n+                        @interface Foo {\n+                          Bar value();\n+                        }\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        import java.lang.annotation.ElementType;\n+                        import java.lang.annotation.Retention;\n+                        import java.lang.annotation.RetentionPolicy;\n+                        import java.lang.annotation.Target;\n+\n+                        @Retention(RetentionPolicy.RUNTIME)\n+                        @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+                        @Foo(Bar.BAZ)\n+                        @interface A {}\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        public interface M<K, V> {\n+                          @A\n+                          V f(K k, V v);\n+                        }\n+                        \"\"\")\n+                .options()\n+                .run()\n+                .writeAll();\n+        Files.delete(libClasses.resolve(\"lib\").resolve(\"Bar.class\"));\n+        String code =\n+                \"\"\"\n+                import lib.M;\n+                class T {\n+                  protected M m;\n+\n+                  public void f() {\n+                    m.f(null, 0);\n+                  }\n+                }\n+                \"\"\";\n+        List<String> output =\n+                new JavacTask(tb)\n+                        .classpath(libClasses)\n+                        .sources(code)\n+                        .options(\"-Xlint:all\", \"-Werror\", \"-XDrawDiagnostics\")\n+                        .run(Task.Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+        List<String> expected =\n+                Arrays.asList(\n+                        \"T.java:3:13: compiler.warn.raw.class.use: lib.M, lib.M<K,V>\",\n+                        \"T.java:6:8: compiler.warn.unchecked.call.mbr.of.raw.type: f(K,V), lib.M\",\n+                        \"- compiler.err.warnings.and.werror\",\n+                        \"1 error\",\n+                        \"2 warnings\");\n+        tb.checkEqual(expected, output);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/RichFormatterWithTypeAnnotationsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}