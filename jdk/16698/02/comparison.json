{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    private final int blockSize;\n+    final int blockSize;\n@@ -140,0 +140,4 @@\n+    protected final void engineUpdate(byte[] buf) {\n+        engineUpdate(buf, 0, buf.length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DigestBase.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,4 @@\n+    \/\/ Number of bytes in the state buffer that has been used in squeezing.\n+    \/\/ Initialized as -1, becomes 0 when squeezing starts.\n+    private int squeezeOffset = -1;\n+\n@@ -100,0 +104,9 @@\n+    void finishAbsorb() {\n+        int numOfPadding =\n+                setPaddingBytes(suffix, buffer, (int)(bytesProcessed % buffer.length));\n+        if (numOfPadding < 1) {\n+            throw new ProviderException(\"Incorrect pad size: \" + numOfPadding);\n+        }\n+        implCompress(buffer, 0);\n+    }\n+\n@@ -105,4 +118,3 @@\n-        int numOfPadding =\n-            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % buffer.length));\n-        if (numOfPadding < 1) {\n-            throw new ProviderException(\"Incorrect pad size: \" + numOfPadding);\n+        if (engineGetDigestLength() == 0) {\n+            \/\/ this is an XOF, so the digest() call is illegal\n+            throw new ProviderException(\"Calling digest() is not allowed in an XOF\");\n@@ -110,2 +122,43 @@\n-        implCompress(buffer, 0);\n-        System.arraycopy(state, 0, out, ofs, engineGetDigestLength());\n+        finishAbsorb();\n+        int availableBytes = blockSize;\n+        int numBytes = engineGetDigestLength();\n+        while (numBytes > availableBytes) {\n+            System.arraycopy(state, 0, out, ofs, availableBytes);\n+            numBytes -= availableBytes;\n+            ofs += availableBytes;\n+            keccak();\n+        }\n+        System.arraycopy(state, 0, out, ofs, numBytes);\n+    }\n+\n+    void implSqueeze(byte[]output, int offset, int numBytes) {\n+        if (engineGetDigestLength() != 0) {\n+            \/\/ this is not an XOF, so the squeeze() call is illegal\n+            throw new ProviderException(\"Squeezing is only allowed in XOF mode\");\n+        }\n+\n+        if (squeezeOffset == -1) {\n+            finishAbsorb();\n+            squeezeOffset = 0;\n+        }\n+        int availableBytes = blockSize - squeezeOffset;\n+        while (numBytes > availableBytes) {\n+            System.arraycopy(state, squeezeOffset, output, offset, availableBytes);\n+            numBytes -= availableBytes;\n+            offset += availableBytes;\n+            squeezeOffset = 0;\n+            availableBytes = blockSize;\n+            keccak();\n+        }\n+        System.arraycopy(state, squeezeOffset, output, offset, numBytes);\n+        squeezeOffset += numBytes;\n+        if (squeezeOffset == blockSize) {\n+            squeezeOffset = 0;\n+            keccak();\n+        }\n+    }\n+\n+    byte[] implSqueeze(int numBytes) {\n+        byte[] result = new byte[numBytes];\n+        implSqueeze(result, 0, numBytes);\n+        return result;\n@@ -114,0 +167,2 @@\n+\n+\n@@ -120,0 +175,1 @@\n+        squeezeOffset = -1;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":63,"deletions":7,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.provider;\n+\n+\/*\n+ * The SHAKE256 extendable output function.\n+ *\/\n+public final class SHAKE128 extends SHA3 {\n+    \/\/ d is the required number of output bytes\n+    \/\/ If this constructor is used with d > 0, the squeezing methods will\n+    \/\/ throw a ProviderException.\n+    public SHAKE128(int d) {\n+        super(\"SHAKE128\", d, (byte) 0x1F, 32);\n+    }\n+\n+    \/\/ If this constructor is used to get an instance of the class, then, after\n+    \/\/ the last update, one can get the generated bytes using the squeezing\n+    \/\/ methods. Calling a digest method will throw a ProviderException.\n+    public SHAKE128() {\n+        super(\"SHAKE128\", 0, (byte) 0x1F, 32);\n+    }\n+\n+    public void update(byte in) {\n+        engineUpdate(in);\n+    }\n+    public void update(byte[] in, int off, int len) {\n+        engineUpdate(in, off, len);\n+    }\n+\n+    public void update(byte[] in) {\n+        engineUpdate(in);\n+    }\n+\n+    public byte[] digest() {\n+        return engineDigest();\n+    }\n+\n+    public void squeeze(byte[] output, int offset, int numBytes) {\n+        implSqueeze(output, offset, numBytes);\n+    }\n+    public byte[] squeeze(int numBytes) {\n+        return implSqueeze(numBytes);\n+    }\n+\n+    public void reset() {\n+        engineReset();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHAKE128.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+    \/\/ d is the required number of output bytes\n+    \/\/ If this constructor is used with d > 0, the squeezing methods will\n+    \/\/ throw a ProviderException.\n@@ -35,0 +38,7 @@\n+    \/\/ If this constructor is used to get an instance of the class, then, after\n+    \/\/ the last update, one can get the generated bytes using the squeezing\n+    \/\/ methods. Calling a digest method will throw a ProviderException.\n+    public SHAKE256() {\n+        super(\"SHAKE256\", 0, (byte) 0x1F, 64);\n+    }\n+\n@@ -42,0 +52,4 @@\n+    public void update(byte[] in) {\n+        engineUpdate(in);\n+    }\n+\n@@ -46,0 +60,7 @@\n+    public void squeeze(byte[] output, int offset, int numBytes) {\n+        implSqueeze(output, offset, numBytes);\n+    }\n+    public byte[] squeeze(int numBytes) {\n+        return implSqueeze(numBytes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHAKE256.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"}]}