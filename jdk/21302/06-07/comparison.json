{"files":[{"patch":"@@ -398,0 +398,1 @@\n+        _waiting_workers(_num_workers),\n@@ -411,1 +412,5 @@\n-  return MAX2(0, MIN2(MAX_WORKERS, os::active_processor_count() \/ CPUS_PER_WORKER) - 1);\n+  \/\/ The pool is used for short-lived bursty tasks. We do not want to spend\n+  \/\/ too much time creating and waking up threads unnecessarily. Plus, we do\n+  \/\/ not want to overwhelm large machines. This is why we want to be very\n+  \/\/ conservative about the number of workers actually needed.\n+  return MAX2(0, log2i_graceful(os::active_processor_count()));\n@@ -440,0 +445,13 @@\n+void ArchiveWorkers::signal_worker_if_needed() {\n+  while (true) {\n+    int cur = Atomic::load(&_waiting_workers);\n+    if (cur == 0) {\n+      return;\n+    }\n+    if (Atomic::cmpxchg(&_waiting_workers, cur, cur - 1, memory_order_relaxed) == cur) {\n+      break;\n+    }\n+  }\n+  _start_semaphore.signal(1);\n+}\n+\n@@ -463,1 +481,2 @@\n-  \/\/ Publish the task and signal workers to pick it up.\n+  \/\/ Set up the run and publish the task.\n+  Atomic::store(&_waiting_workers, _num_workers);\n@@ -466,1 +485,4 @@\n-  _start_semaphore.signal(_num_workers);\n+\n+  \/\/ Kick off pool wakeup by signaling a single worker, and proceed\n+  \/\/ immediately to executing the task locally.\n+  signal_worker_if_needed();\n@@ -477,0 +499,3 @@\n+\n+  assert(Atomic::load(&_waiting_workers) == 0, \"All workers were signaled\");\n+  assert(Atomic::load(&_running_workers) == 0, \"No workers are running\");\n@@ -502,0 +527,4 @@\n+  \/\/ Avalanche wakeups: each worker signals two others.\n+  signal_worker_if_needed();\n+  signal_worker_if_needed();\n+\n@@ -505,0 +534,3 @@\n+  \/\/ All work done in threads should be visible to caller.\n+  OrderAccess::fence();\n+\n@@ -531,3 +563,0 @@\n-\n-  \/\/ All work done in threads should be visible to caller.\n-  OrderAccess::fence();\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -346,9 +346,0 @@\n-  \/\/ The absolute limit on the number of archive workers. This should protect\n-  \/\/ from workers stumbling over each other on very large machines.\n-  static constexpr int MAX_WORKERS = 16;\n-\n-  \/\/ The reciprocal ratio for number of workers per CPU. We are targeting\n-  \/\/ to take 1\/2 CPUs to provide decent parallelism without letting workers\n-  \/\/ stumble over each other.\n-  static constexpr int CPUS_PER_WORKER = 2;\n-\n@@ -367,0 +358,1 @@\n+  int _waiting_workers;\n@@ -373,0 +365,1 @@\n+  void signal_worker_if_needed();\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  product(bool, ArchiveParallelRelocation, true, DIAGNOSTIC,                \\\n+  product(bool, AOTCacheParallelRelocation, true, DIAGNOSTIC,               \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2016,1 +2016,1 @@\n-    if (ArchiveParallelRelocation) {\n+    if (AOTCacheParallelRelocation) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}