{"files":[{"patch":"@@ -400,4 +400,1 @@\n-        _task(nullptr) {\n-  \/\/ Kick off pool startup by creating a single worker.\n-  start_worker_if_needed();\n-}\n+        _task(nullptr) {}\n@@ -430,2 +427,2 @@\n-  \/\/ If max chunks is not set, put our guess there.\n-  task->maybe_override_max_chunks(_num_workers * chunks_per_worker);\n+  \/\/ If the pool is idle, kick off its startup by creating a single worker.\n+  start_worker_if_needed();\n@@ -433,2 +430,2 @@\n-  \/\/ Publish the task.\n-  Atomic::release_store(&_task, task);\n+  \/\/ Configure the execution.\n+  task->maybe_override_max_chunks(_num_workers * chunks_per_worker);\n@@ -437,1 +434,2 @@\n-  \/\/ Signal workers to pick up work.\n+  \/\/ Publish the task and signal workers to pick it up.\n+  Atomic::release_store(&_task, task);\n@@ -440,1 +438,2 @@\n-  \/\/ Start executing the task ourselves, waiting for workers to catch up.\n+  \/\/ Execute the task ourselves, while workers are catching up.\n+  \/\/ This allows us to hide parts of task handoff latency.\n@@ -443,1 +442,2 @@\n-  \/\/ Done with our task, wait for workers to complete.\n+  \/\/ Done executing task locally, wait for any remaining workers to complete,\n+  \/\/ and then do the final housekeeping.\n@@ -445,2 +445,0 @@\n-\n-  \/\/ All done.\n@@ -448,2 +446,0 @@\n-\n-  \/\/ All work done in threads should be visible to caller.\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"}]}