{"files":[{"patch":"@@ -74,1 +74,1 @@\n-            Assertions.assertTrue(lookupString().equals(lookup.toString()));\n+            assertEquals(lookupString(), lookup.toString());\n@@ -101,1 +101,1 @@\n-                Assertions.assertTrue(cmp != 0);\n+                assertNotEquals(0, cmp);\n@@ -111,1 +111,1 @@\n-                Assertions.assertTrue(cmp != 0);\n+                assertNotEquals(0, cmp);\n@@ -256,1 +256,1 @@\n-                Assertions.assertTrue(changed == 0);       \/\/ [A11] (no deprivation if same class)\n+                assertEquals(0, changed);       \/\/ [A11] (no deprivation if same class)\n@@ -259,1 +259,1 @@\n-            if (accessible)  Assertions.assertTrue((changed & PUBLIC) == 0);\n+            if (accessible) assertEquals(0, changed & PUBLIC);\n@@ -264,2 +264,2 @@\n-            Assertions.assertTrue(l2.lookupClass() == c2);         \/\/ [A1]\n-            Assertions.assertTrue((modes1 | modes2) == modes1);    \/\/ [A1-a] (no elevation of access)\n+            assertSame(l2.lookupClass(), c2);         \/\/ [A1]\n+            assertEquals(modes1, modes1 | modes2);    \/\/ [A1-a] (no elevation of access)\n@@ -285,1 +285,1 @@\n-            Assertions.assertTrue((oldModes | newModes) == oldModes);    \/\/ [A2] (no elevation of access)\n+            assertEquals(oldModes, oldModes | newModes);    \/\/ [A2] (no elevation of access)\n@@ -336,1 +336,1 @@\n-            Assertions.assertTrue(m1 == m2 && prevLookupClass == null);\n+            assertNull(prevLookupClass);\n@@ -385,1 +385,1 @@\n-            Assertions.assertTrue(m1 == m2 && prevLookupClass == null);\n+            assertNull(prevLookupClass);\n@@ -414,1 +414,1 @@\n-        Assertions.assertTrue(c.getEnclosingClass() == null);\n+        assertNull(c.getEnclosingClass());\n@@ -448,1 +448,1 @@\n-            Assertions.assertTrue(l2.lookupClass() == c2); \/\/ [A1]\n+            assertSame(l2.lookupClass(), c2); \/\/ [A1]\n@@ -451,1 +451,1 @@\n-            Assertions.assertTrue((m1 | m2) == m1);        \/\/ [A2] (no elevation of access)\n+            assertEquals(m1, (m1 | m2));        \/\/ [A2] (no elevation of access)\n@@ -587,1 +587,1 @@\n-            Assertions.assertTrue(targetAccess == fixMods(haveMods));\n+            assertEquals(targetAccess, fixMods(haveMods));\n@@ -609,1 +609,1 @@\n-        Assertions.assertTrue(false);\n+        Assertions.fail();\n","filename":"test\/jdk\/java\/lang\/invoke\/AccessControlTest.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n-            VarHandle v = handle();\n+        VarHandle v = handle();\n@@ -63,1 +62,1 @@\n-            \/\/ Try a reflective invoke using a Method, with no arguments\n+        \/\/ Try a reflective invoke using a Method, with no arguments\n@@ -65,3 +64,2 @@\n-            Method vhm = VarHandle.class.getMethod(accessMode.methodName(), Object[].class);\n-            vhm.invoke(v, new Object[]{});\n-        });\n+        Method vhm = VarHandle.class.getMethod(accessMode.methodName(), Object[].class);\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> vhm.invoke(v, new Object[]{}));\n@@ -79,7 +77,4 @@\n-        try {\n-            vhm.invoke(v, arg);\n-        } catch (InvocationTargetException e) {\n-            if (!(e.getCause() instanceof UnsupportedOperationException)) {\n-                throw new RuntimeException(\"expected UnsupportedOperationException but got: \"\n-                                           + e.getCause().getClass().getName(), e);\n-            }\n+        var e = Assertions.assertThrows(InvocationTargetException.class, () -> vhm.invoke(v, arg));\n+        if (!(e.getCause() instanceof UnsupportedOperationException)) {\n+            throw new RuntimeException(\"expected UnsupportedOperationException but got: \"\n+                    + e.getCause().getClass().getName(), e);\n@@ -92,2 +87,1 @@\n-        Assertions.assertThrows(UnsupportedOperationException.class, () -> {\n-            VarHandle v = handle();\n+        VarHandle v = handle();\n@@ -95,1 +89,1 @@\n-            \/\/ Try a reflective invoke using a MethodHandle\n+        \/\/ Try a reflective invoke using a MethodHandle\n@@ -97,4 +91,5 @@\n-            MethodHandle mh = MethodHandles.lookup().unreflect(\n-                    VarHandle.class.getMethod(accessMode.methodName(), Object[].class));\n-            \/\/ Use invoke to avoid WrongMethodTypeException for\n-            \/\/ non-signature-polymorphic return types\n+        MethodHandle mh = MethodHandles.lookup().unreflect(\n+                VarHandle.class.getMethod(accessMode.methodName(), Object[].class));\n+        \/\/ Use invoke to avoid WrongMethodTypeException for\n+        \/\/ non-signature-polymorphic return types\n+        Assertions.assertThrows(UnsupportedOperationException.class, () -> {\n@@ -108,2 +103,1 @@\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n-            VarHandle v = handle();\n+        VarHandle v = handle();\n@@ -111,2 +105,2 @@\n-            \/\/ Try a reflective invoke using a Method obtained from cracking\n-            \/\/ a MethodHandle\n+        \/\/ Try a reflective invoke using a Method obtained from cracking\n+        \/\/ a MethodHandle\n@@ -114,4 +108,5 @@\n-            MethodHandle mh = MethodHandles.lookup().unreflect(\n-                    VarHandle.class.getMethod(accessMode.methodName(), Object[].class));\n-            MethodHandleInfo info = MethodHandles.lookup().revealDirect(mh);\n-            Method im = info.reflectAs(Method.class, MethodHandles.lookup());\n+        MethodHandle mh = MethodHandles.lookup().unreflect(\n+                VarHandle.class.getMethod(accessMode.methodName(), Object[].class));\n+        MethodHandleInfo info = MethodHandles.lookup().revealDirect(mh);\n+        Method im = info.reflectAs(Method.class, MethodHandles.lookup());\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n@@ -125,2 +120,1 @@\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n-            VarHandle v = handle();\n+        VarHandle v = handle();\n@@ -128,2 +122,2 @@\n-            MethodHandle mh = MethodHandles.varHandleInvoker(\n-                    accessMode, v.accessModeType(accessMode));\n+        MethodHandle mh = MethodHandles.varHandleInvoker(\n+                accessMode, v.accessModeType(accessMode));\n@@ -131,1 +125,1 @@\n-            MethodHandleInfo info = MethodHandles.lookup().revealDirect(mh);\n+        MethodHandleInfo info = MethodHandles.lookup().revealDirect(mh);\n@@ -133,2 +127,1 @@\n-            info.reflectAs(Method.class, MethodHandles.lookup());\n-        });\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> info.reflectAs(Method.class, MethodHandles.lookup()));\n@@ -140,2 +133,1 @@\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n-            VarHandle v = handle();\n+        VarHandle v = handle();\n@@ -143,2 +135,2 @@\n-            MethodHandle mh = MethodHandles.publicLookup().findVirtual(\n-                    VarHandle.class, accessMode.methodName(), v.accessModeType(accessMode));\n+        MethodHandle mh = MethodHandles.publicLookup().findVirtual(\n+                VarHandle.class, accessMode.methodName(), v.accessModeType(accessMode));\n@@ -146,1 +138,1 @@\n-            MethodHandleInfo info = MethodHandles.lookup().revealDirect(mh);\n+        MethodHandleInfo info = MethodHandles.lookup().revealDirect(mh);\n@@ -148,2 +140,1 @@\n-            info.reflectAs(Method.class, MethodHandles.lookup());\n-        });\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> info.reflectAs(Method.class, MethodHandles.lookup()));\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestReflection.java","additions":33,"deletions":42,"binary":false,"changes":75,"status":"modified"}]}