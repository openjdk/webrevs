{"files":[{"patch":"@@ -98,8 +98,1 @@\n-        \/\/ tests empty input stream\n-        assertThrows(NullPointerException.class, () -> inputStreamProvider.input().transferTo(null));\n-\n-        \/\/ tests single-byte input stream\n-        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1).transferTo(null));\n-\n-        \/\/ tests dual-byte input stream\n-        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1, (byte) 2).transferTo(null));\n+        assertNullPointerException(inputStreamProvider);\n@@ -115,24 +108,1 @@\n-        \/\/ tests empty input stream\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n-\n-        \/\/ tests input stream with a length between 1k and 4k\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n-\n-        \/\/ tests input stream with several data chunks, as 16k is more than a\n-        \/\/ single chunk can hold\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n-\n-        \/\/ tests randomly chosen starting positions within source and\n-        \/\/ target stream\n-        for (int i = 0; i < ITERATIONS; i++) {\n-            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n-            int posIn = RND.nextInt(inBytes.length);\n-            int posOut = RND.nextInt(MIN_SIZE);\n-            checkTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, posIn, posOut);\n-        }\n-\n-        \/\/ tests reading beyond source EOF (must not transfer any bytes)\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(4096, 0), 4096, 0);\n-\n-        \/\/ tests writing beyond target EOF (must extend output stream)\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(4096, 0), 0, 4096);\n+        assertStreamContents(inputStreamProvider, outputStreamProvider);\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":2,"deletions":32,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import static org.testng.Assert.assertThrows;\n-\n@@ -79,8 +77,1 @@\n-        \/\/ tests empty input stream\n-        assertThrows(NullPointerException.class, () -> inputStreamProvider.input().transferTo(null));\n-\n-        \/\/ tests single-byte input stream\n-        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1).transferTo(null));\n-\n-        \/\/ tests dual-byte input stream\n-        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1, (byte) 2).transferTo(null));\n+        assertNullPointerException(inputStreamProvider);\n@@ -96,24 +87,1 @@\n-        \/\/ tests empty input stream\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n-\n-        \/\/ tests input stream with a length between 1k and 4k\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n-\n-        \/\/ tests input stream with several data chunks, as 16k is more than a\n-        \/\/ single chunk can hold\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n-\n-        \/\/ tests randomly chosen starting positions within source and\n-        \/\/ target stream\n-        for (int i = 0; i < ITERATIONS; i++) {\n-            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n-            int posIn = RND.nextInt(inBytes.length);\n-            int posOut = RND.nextInt(MIN_SIZE);\n-            checkTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, posIn, posOut);\n-        }\n-\n-        \/\/ tests reading beyond source EOF (must not transfer any bytes)\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(4096, 0), 4096, 0);\n-\n-        \/\/ tests writing beyond target EOF (must extend output stream)\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(4096, 0), 0, 4096);\n+        assertStreamContents(inputStreamProvider, outputStreamProvider);\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo2.java","additions":2,"deletions":34,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import static org.testng.Assert.assertThrows;\n@@ -139,0 +140,47 @@\n+    \/*\n+     * Testing API compliance: input stream must throw NullPointerException\n+     * when parameter \"out\" is null.\n+     *\/\n+    static void assertNullPointerException(InputStreamProvider inputStreamProvider) {\n+        \/\/ tests empty input stream\n+        assertThrows(NullPointerException.class, () -> inputStreamProvider.input().transferTo(null));\n+\n+        \/\/ tests single-byte input stream\n+        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1).transferTo(null));\n+\n+        \/\/ tests dual-byte input stream\n+        assertThrows(NullPointerException.class, () -> inputStreamProvider.input((byte) 1, (byte) 2).transferTo(null));\n+    }\n+\n+    \/*\n+     * Testing API compliance: complete content of input stream must be\n+     * transferred to output stream.\n+     *\/\n+    static void assertStreamContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider) throws Exception {\n+        \/\/ tests empty input stream\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n+\n+        \/\/ tests input stream with a length between 1k and 4k\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n+\n+        \/\/ tests input stream with several data chunks, as 16k is more than a\n+        \/\/ single chunk can hold\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n+\n+        \/\/ tests randomly chosen starting positions within source and\n+        \/\/ target stream\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n+            int posIn = RND.nextInt(inBytes.length);\n+            int posOut = RND.nextInt(MIN_SIZE);\n+            checkTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, posIn, posOut);\n+        }\n+\n+        \/\/ tests reading beyond source EOF (must not transfer any bytes)\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(4096, 0), 4096, 0);\n+\n+        \/\/ tests writing beyond target EOF (must extend output stream)\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(4096, 0), 0, 4096);\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferToBase.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"}]}