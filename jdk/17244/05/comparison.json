{"files":[{"patch":"@@ -181,10 +181,36 @@\n-void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {\n-  size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;\n-  \/\/ Prepare error message\n-  const char* error = \"Invalid code heap sizes\";\n-  err_msg message(\"NonNMethodCodeHeapSize (\" SIZE_FORMAT \"K) + ProfiledCodeHeapSize (\" SIZE_FORMAT \"K)\"\n-                  \" + NonProfiledCodeHeapSize (\" SIZE_FORMAT \"K) = \" SIZE_FORMAT \"K\",\n-          non_nmethod_size\/K, profiled_size\/K, non_profiled_size\/K, total_size\/K);\n-\n-  if (total_size > cache_size) {\n-    \/\/ Some code heap sizes were explicitly set: total_size must be <= cache_size\n+static bool check_min_size(const char *codeheap, size_t size, size_t required_size) {\n+  if (size >= required_size) {\n+    return true;\n+  } else {\n+    log_debug(codecache)(\"Code heap (%s) size \" SIZE_FORMAT \" below required minimal size \" SIZE_FORMAT,\n+                         codeheap, size, required_size);\n+    err_msg title(\"Not enough space in %s to run VM\", codeheap);\n+    err_msg message(SIZE_FORMAT \"K < \" SIZE_FORMAT \"K\", size\/K, required_size\/K);\n+    vm_exit_during_initialization(title, message);\n+    return false;\n+  }\n+}\n+\n+struct CodeHeapInfo {\n+  size_t size;\n+  bool set;\n+  bool enabled;\n+};\n+\n+static void report_cache_size_error(const CodeHeapInfo& non_nmethod, const CodeHeapInfo& profiled,\n+                                    const CodeHeapInfo& non_profiled, size_t cache_size) {\n+  size_t total = non_nmethod.size;\n+\n+  err_msg message(\"NonNMethodCodeHeapSize (\" SIZE_FORMAT \"K)\", non_nmethod.size\/K);\n+  if (profiled.enabled) {\n+    total += profiled.size;\n+    message.append(\" + ProfiledCodeHeapSize (\" SIZE_FORMAT \"K)\", profiled.size\/K);\n+  }\n+\n+  if (non_profiled.enabled) {\n+    total += non_profiled.size;\n+    message.append(\" + NonProfiledCodeHeapSize (\" SIZE_FORMAT \"K)\", non_profiled.size\/K);\n+  }\n+  message.append(\" = \" SIZE_FORMAT \"K\", total\/K);\n+\n+  if (total > cache_size) {\n@@ -192,3 +218,2 @@\n-    vm_exit_during_initialization(error, message);\n-  } else if (all_set && total_size != cache_size) {\n-    \/\/ All code heap sizes were explicitly set: total_size must equal cache_size\n+  }\n+  else {\n@@ -196,1 +221,0 @@\n-    vm_exit_during_initialization(error, message);\n@@ -198,0 +222,7 @@\n+\n+  vm_exit_during_initialization(\"Invalid code heap sizes\", message);\n+}\n+\n+static void set_size_of_unset_code_heap(CodeHeapInfo* heap, size_t available_size, size_t known_segments_size, size_t min_size) {\n+  assert(!heap->set, \"sanity\");\n+  heap->size = (available_size > known_segments_size + min_size) ? (available_size - known_segments_size) : min_size;\n@@ -201,29 +232,0 @@\n-  bool non_nmethod_set      = FLAG_IS_CMDLINE(NonNMethodCodeHeapSize);\n-  bool profiled_set         = FLAG_IS_CMDLINE(ProfiledCodeHeapSize);\n-  bool non_profiled_set     = FLAG_IS_CMDLINE(NonProfiledCodeHeapSize);\n-  const size_t ps           = page_size(false, 8);\n-  const size_t min_size     = MAX2(os::vm_allocation_granularity(), ps);\n-  const size_t cache_size   = ReservedCodeCacheSize;\n-  size_t non_nmethod_size   = NonNMethodCodeHeapSize;\n-  size_t profiled_size      = ProfiledCodeHeapSize;\n-  size_t non_profiled_size  = NonProfiledCodeHeapSize;\n-  \/\/ Check if total size set via command line flags exceeds the reserved size\n-  check_heap_sizes((non_nmethod_set  ? non_nmethod_size  : min_size),\n-                   (profiled_set     ? profiled_size     : min_size),\n-                   (non_profiled_set ? non_profiled_size : min_size),\n-                   cache_size,\n-                   non_nmethod_set && profiled_set && non_profiled_set);\n-\n-  \/\/ Determine size of compiler buffers\n-  size_t code_buffers_size = 0;\n-#ifdef COMPILER1\n-  \/\/ C1 temporary code buffers (see Compiler::init_buffer_blob())\n-  const int c1_count = CompilationPolicy::c1_count();\n-  code_buffers_size += c1_count * Compiler::code_buffer_size();\n-#endif\n-#ifdef COMPILER2\n-  \/\/ C2 scratch buffers (see Compile::init_scratch_buffer_blob())\n-  const int c2_count = CompilationPolicy::c2_count();\n-  \/\/ Initial size of constant table (this may be increased if a compiled method needs more space)\n-  code_buffers_size += c2_count * C2Compiler::initial_code_buffer_size();\n-#endif\n@@ -231,61 +233,9 @@\n-  \/\/ Increase default non_nmethod_size to account for compiler buffers\n-  if (!non_nmethod_set) {\n-    non_nmethod_size += code_buffers_size;\n-  }\n-  \/\/ Calculate default CodeHeap sizes if not set by user\n-  if (!non_nmethod_set && !profiled_set && !non_profiled_set) {\n-    \/\/ Leave room for the other two parts of the code cache\n-    const size_t max_non_nmethod_size = cache_size - 2 * min_size;\n-    \/\/ Check if we have enough space for the non-nmethod code heap\n-    if (max_non_nmethod_size >= non_nmethod_size) {\n-      \/\/ Use the default value for non_nmethod_size and one half of the\n-      \/\/ remaining size for non-profiled and one half for profiled methods\n-      size_t remaining_size = cache_size - non_nmethod_size;\n-      profiled_size = remaining_size \/ 2;\n-      non_profiled_size = remaining_size - profiled_size;\n-    } else {\n-      \/\/ Use all space for the non-nmethod heap and set other heaps to minimal size\n-      non_nmethod_size = max_non_nmethod_size;\n-      profiled_size = min_size;\n-      non_profiled_size = min_size;\n-    }\n-  } else if (!non_nmethod_set || !profiled_set || !non_profiled_set) {\n-    \/\/ The user explicitly set some code heap sizes. Increase or decrease the (default)\n-    \/\/ sizes of the other code heaps accordingly. First adapt non-profiled and profiled\n-    \/\/ code heap sizes and then only change non-nmethod code heap size if still necessary.\n-    intx diff_size = cache_size - (non_nmethod_size + profiled_size + non_profiled_size);\n-    if (non_profiled_set) {\n-      if (!profiled_set) {\n-        \/\/ Adapt size of profiled code heap\n-        if (diff_size < 0 && ((intx)profiled_size + diff_size) <= 0) {\n-          \/\/ Not enough space available, set to minimum size\n-          diff_size += profiled_size - min_size;\n-          profiled_size = min_size;\n-        } else {\n-          profiled_size += diff_size;\n-          diff_size = 0;\n-        }\n-      }\n-    } else if (profiled_set) {\n-      \/\/ Adapt size of non-profiled code heap\n-      if (diff_size < 0 && ((intx)non_profiled_size + diff_size) <= 0) {\n-        \/\/ Not enough space available, set to minimum size\n-        diff_size += non_profiled_size - min_size;\n-        non_profiled_size = min_size;\n-      } else {\n-        non_profiled_size += diff_size;\n-        diff_size = 0;\n-      }\n-    } else if (non_nmethod_set) {\n-      \/\/ Distribute remaining size between profiled and non-profiled code heaps\n-      diff_size = cache_size - non_nmethod_size;\n-      profiled_size = diff_size \/ 2;\n-      non_profiled_size = diff_size - profiled_size;\n-      diff_size = 0;\n-    }\n-    if (diff_size != 0) {\n-      \/\/ Use non-nmethod code heap for remaining space requirements\n-      assert(!non_nmethod_set && ((intx)non_nmethod_size + diff_size) > 0, \"sanity\");\n-      non_nmethod_size += diff_size;\n-    }\n-  }\n+  CodeHeapInfo non_nmethod = {NonNMethodCodeHeapSize, FLAG_IS_CMDLINE(NonNMethodCodeHeapSize), true};\n+  CodeHeapInfo profiled = {ProfiledCodeHeapSize, FLAG_IS_CMDLINE(ProfiledCodeHeapSize), true};\n+  CodeHeapInfo non_profiled = {NonProfiledCodeHeapSize, FLAG_IS_CMDLINE(NonProfiledCodeHeapSize), true};\n+\n+  const bool cache_size_set   = FLAG_IS_CMDLINE(ReservedCodeCacheSize);\n+  const size_t ps             = page_size(false, 8);\n+  const size_t min_size       = MAX2(os::vm_allocation_granularity(), ps);\n+  const size_t min_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3); \/\/ Make sure we have enough space for VM internal code\n+  size_t cache_size           = ReservedCodeCacheSize;\n@@ -293,1 +243,1 @@\n-  \/\/ We do not need the profiled CodeHeap, use all space for the non-profiled CodeHeap\n+  \/\/ Prerequisites\n@@ -295,2 +245,7 @@\n-    non_profiled_size += profiled_size;\n-    profiled_size = 0;\n+    \/\/ For compatibility reasons, disabled tiered compilation overrides\n+    \/\/ segment size even if it is set explicitly.\n+    non_profiled.size += profiled.size;\n+    \/\/ Profiled code heap is not available, forcibly set size to 0\n+    profiled.size = 0;\n+    profiled.set = true;\n+    profiled.enabled = false;\n@@ -298,1 +253,1 @@\n-  \/\/ We do not need the non-profiled CodeHeap, use all space for the non-nmethod CodeHeap\n+\n@@ -300,2 +255,30 @@\n-    non_nmethod_size += non_profiled_size;\n-    non_profiled_size = 0;\n+    \/\/ MethodNonProfiled heap is always available for segmented code heap\n+    ShouldNotReachHere();\n+  }\n+\n+  size_t compiler_buffer_size = 0;\n+  COMPILER1_PRESENT(compiler_buffer_size += CompilationPolicy::c1_count() * Compiler::code_buffer_size());\n+  COMPILER2_PRESENT(compiler_buffer_size += CompilationPolicy::c2_count() * C2Compiler::initial_code_buffer_size());\n+\n+  if (!non_nmethod.set) {\n+    non_nmethod.size += compiler_buffer_size;\n+  }\n+\n+  if (!profiled.set && !non_profiled.set) {\n+    non_profiled.size = profiled.size = (cache_size > non_nmethod.size + 2 * min_size) ?\n+                                        (cache_size - non_nmethod.size) \/ 2 : min_size;\n+  }\n+\n+  if (profiled.set && !non_profiled.set) {\n+    set_size_of_unset_code_heap(&non_profiled, cache_size, non_nmethod.size + profiled.size, min_size);\n+  }\n+\n+  if (!profiled.set && non_profiled.set) {\n+    set_size_of_unset_code_heap(&profiled, cache_size, non_nmethod.size + non_profiled.size, min_size);\n+  }\n+\n+  \/\/ Compatibility.\n+  \/\/ Override Non-NMethod default size if two other segments are set explicitly\n+  size_t non_nmethod_min_size = min_cache_size + compiler_buffer_size;\n+  if (!non_nmethod.set && profiled.set && non_profiled.set) {\n+    set_size_of_unset_code_heap(&non_nmethod, cache_size, profiled.size + non_profiled.size, non_nmethod_min_size);\n@@ -303,6 +286,21 @@\n-  \/\/ Make sure we have enough space for VM internal code\n-  uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n-  if (non_nmethod_size < min_code_cache_size) {\n-    vm_exit_during_initialization(err_msg(\n-        \"Not enough space in non-nmethod code heap to run VM: \" SIZE_FORMAT \"K < \" SIZE_FORMAT \"K\",\n-        non_nmethod_size\/K, min_code_cache_size\/K));\n+\n+  size_t total = non_nmethod.size + profiled.size + non_profiled.size;\n+  if (total != cache_size && !cache_size_set) {\n+    log_info(codecache)(\"ReservedCodeCache size %lld changed to total segments size NonNMethod %lld NonProfiled %lld Profiled %lld = %lld\",\n+                        (long long) cache_size, (long long) non_nmethod.size, (long long) non_profiled.size,\n+                        (long long) profiled.size, (long long) total);\n+    \/\/ Adjust ReservedCodeCacheSize as necessary because it was not set explicitly\n+    cache_size = total;\n+  }\n+\n+  log_debug(codecache)(\"Initializing code heaps ReservedCodeCache %lld NonNMethod %lld NonProfiled %lld Profiled %lld\",\n+                       (long long) cache_size, (long long) non_nmethod.size,\n+                       (long long) non_profiled.size, (long long) profiled.size);\n+\n+  \/\/ Validation\n+  \/\/ Check minimal required sizes\n+  if (!check_min_size(\"non-nmethod code heap\", non_nmethod.size, non_nmethod_min_size) ||\n+     (profiled.enabled && !check_min_size(\"profiled code heap\", profiled.size, min_size)) ||\n+     (non_profiled.enabled && !check_min_size(\"non-profiled code heap\", non_profiled.size, min_size)) ||\n+     (cache_size_set && !check_min_size(\"reserved code cache\", cache_size, min_cache_size))) {\n+    return;\n@@ -311,5 +309,5 @@\n-  \/\/ Verify sizes and update flag values\n-  assert(non_profiled_size + profiled_size + non_nmethod_size == cache_size, \"Invalid code heap sizes\");\n-  FLAG_SET_ERGO(NonNMethodCodeHeapSize, non_nmethod_size);\n-  FLAG_SET_ERGO(ProfiledCodeHeapSize, profiled_size);\n-  FLAG_SET_ERGO(NonProfiledCodeHeapSize, non_profiled_size);\n+  \/\/ ReservedCodeCacheSize was set explicitly, so report error and abort if it doesn't match segment sizes.\n+  if (total != cache_size && cache_size_set) {\n+    report_cache_size_error(non_nmethod, profiled, non_profiled, cache_size);\n+    return;\n+  }\n@@ -317,1 +315,1 @@\n-  \/\/ Print warning if using large pages but not able to use the size given\n+  \/\/ Compatibility. Print warning if using large pages but not able to use the size given\n@@ -327,0 +325,4 @@\n+  \/\/ last adjustment: leftovers from page alignment go to non_nmethod segment\n+  non_nmethod.size += non_profiled.size & alignment_mask(min_size);\n+  non_nmethod.size += profiled.size & alignment_mask(min_size);\n+\n@@ -329,11 +331,9 @@\n-  non_nmethod_size = align_up(non_nmethod_size, min_size);\n-  profiled_size    = align_down(profiled_size, min_size);\n-  non_profiled_size = align_down(non_profiled_size, min_size);\n-\n-  \/\/ Reserve one continuous chunk of memory for CodeHeaps and split it into\n-  \/\/ parts for the individual heaps. The memory layout looks like this:\n-  \/\/ ---------- high -----------\n-  \/\/    Non-profiled nmethods\n-  \/\/         Non-nmethods\n-  \/\/      Profiled nmethods\n-  \/\/ ---------- low ------------\n+  non_nmethod.size = align_up(non_nmethod.size, min_size);\n+  non_profiled.size = align_down(non_profiled.size, min_size);\n+  profiled.size = align_down(profiled.size, min_size);\n+\n+  FLAG_SET_ERGO(NonNMethodCodeHeapSize, non_nmethod.size);\n+  FLAG_SET_ERGO(ProfiledCodeHeapSize, profiled.size);\n+  FLAG_SET_ERGO(NonProfiledCodeHeapSize, non_profiled.size);\n+  FLAG_SET_ERGO(ReservedCodeCacheSize, cache_size);\n+\n@@ -341,4 +341,0 @@\n-  ReservedSpace profiled_space      = rs.first_part(profiled_size);\n-  ReservedSpace rest                = rs.last_part(profiled_size);\n-  ReservedSpace non_method_space    = rest.first_part(non_nmethod_size);\n-  ReservedSpace non_profiled_space  = rest.last_part(non_nmethod_size);\n@@ -349,0 +345,10 @@\n+  size_t offset = 0;\n+  if (profiled.enabled) {\n+    ReservedSpace profiled_space = rs.partition(offset, profiled.size);\n+    offset += profiled.size;\n+    \/\/ Tier 2 and tier 3 (profiled) methods\n+    add_heap(profiled_space, \"CodeHeap 'profiled nmethods'\", CodeBlobType::MethodProfiled);\n+  }\n+\n+  ReservedSpace non_method_space = rs.partition(offset, non_nmethod.size);\n+  offset += non_nmethod.size;\n@@ -351,4 +357,6 @@\n-  \/\/ Tier 2 and tier 3 (profiled) methods\n-  add_heap(profiled_space, \"CodeHeap 'profiled nmethods'\", CodeBlobType::MethodProfiled);\n-  \/\/ Tier 1 and tier 4 (non-profiled) methods and native methods\n-  add_heap(non_profiled_space, \"CodeHeap 'non-profiled nmethods'\", CodeBlobType::MethodNonProfiled);\n+\n+  if (non_profiled.enabled) {\n+    ReservedSpace non_profiled_space  = rs.partition(offset, non_profiled.size);\n+    \/\/ Tier 1 and tier 4 (non-profiled) methods and native methods\n+    add_heap(non_profiled_space, \"CodeHeap 'non-profiled nmethods'\", CodeBlobType::MethodNonProfiled);\n+  }\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":149,"deletions":141,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -114,2 +114,1 @@\n-  \/\/ Check the code heap sizes set by the user via command line\n-  static void check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set);\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -317,3 +317,1 @@\n-\n-ReservedSpace\n-ReservedSpace::last_part(size_t partition_size, size_t alignment) {\n+ReservedSpace ReservedSpace::last_part(size_t partition_size, size_t alignment) {\n@@ -326,0 +324,5 @@\n+ReservedSpace ReservedSpace::partition(size_t offset, size_t partition_size, size_t alignment) {\n+  assert(offset + partition_size <= size(), \"partition failed\");\n+  ReservedSpace result(base()+offset, partition_size, alignment, page_size(), special(), executable());\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  ReservedSpace partition (size_t offset, size_t partition_size, size_t alignment);\n@@ -102,0 +103,1 @@\n+  inline ReservedSpace partition (size_t offset, size_t partition_size);\n@@ -116,2 +118,1 @@\n-ReservedSpace\n-ReservedSpace::first_part(size_t partition_size)\n+ReservedSpace ReservedSpace::first_part(size_t partition_size)\n@@ -127,0 +128,5 @@\n+ReservedSpace ReservedSpace::partition(size_t offset, size_t partition_size)\n+{\n+  return partition(offset, partition_size, alignment());\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,0 +85,30 @@\n+    private static void verifyCodeHeapSize(ProcessBuilder pb, String heapName, long heapSize) throws Exception {\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+\n+        long actualHeapSize = Long.parseLong(out.firstMatch(heapName + \"\\\\s+=\\\\s(\\\\d+)\", 1));\n+        if (heapSize != actualHeapSize) {\n+            throw new RuntimeException(\"Unexpected \" + heapName + \" size: \" + actualHeapSize + \" != \" + heapSize);\n+        }\n+\n+        \/\/ Sanity checks:\n+        \/\/ - segment sizes are aligned to at least 1KB\n+        \/\/ - sum of segment sizes equals ReservedCodeCacheSize\n+\n+        long nonNMethodCodeHeapSize = Long.parseLong(out.firstMatch(\"NonNMethodCodeHeapSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+        long nonProfiledCodeHeapSize = Long.parseLong(out.firstMatch(\"NonProfiledCodeHeapSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+        long profiledCodeHeapSize = Long.parseLong(out.firstMatch(\" ProfiledCodeHeapSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+        long reservedCodeCacheSize = Long.parseLong(out.firstMatch(\"ReservedCodeCacheSize\\\\s+=\\\\s(\\\\d+)\", 1));\n+\n+        if (reservedCodeCacheSize != nonNMethodCodeHeapSize + nonProfiledCodeHeapSize + profiledCodeHeapSize) {\n+            throw new RuntimeException(\"Unexpected segments size sum: \" + reservedCodeCacheSize + \" != \" +\n+                    nonNMethodCodeHeapSize + \"+\" + nonProfiledCodeHeapSize + \"+\" + profiledCodeHeapSize);\n+        }\n+\n+        if ((reservedCodeCacheSize % 1024 != 0) || (nonNMethodCodeHeapSize % 1024 != 0) ||\n+            (nonProfiledCodeHeapSize % 1024 != 0) || (profiledCodeHeapSize % 1024 != 0)) {\n+            throw new RuntimeException(\"Unexpected segments size alignment: \" + reservedCodeCacheSize + \", \" +\n+                    nonNMethodCodeHeapSize + \", \" + nonProfiledCodeHeapSize + \", \" + profiledCodeHeapSize);\n+        }\n+    }\n+\n@@ -163,0 +193,1 @@\n+                                                              \"-XX:NonNMethodCodeHeapSize=\" + minSize,\n@@ -167,0 +198,50 @@\n+\n+        \/\/ Try different combination of Segment Sizes\n+\n+        \/\/ Fails if there is not enough space for code cache.\n+        \/\/ All segments are set to minimum allowed value, but VM still fails\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=\" + minSize,\n+                                                              \"-XX:InitialCodeCacheSize=100K\",\n+                                                              \"-version\");\n+        failsWith(pb, \"Invalid code heap sizes\");\n+\n+\n+        \/\/ Reserved code cache is set but not equal to the sum of other segments\n+        \/\/ that are explicitly specified - fails\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=100M\",\n+                                                              \"-XX:NonNMethodCodeHeapSize=10M\",\n+                                                              \"-XX:ProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:NonProfiledCodeHeapSize=10M\",\n+                                                              \"-version\");\n+        failsWith(pb, \"Invalid code heap sizes\");\n+\n+        \/\/ Reserved code cache is not set - it's automatically adjusted to the sum of other segments\n+        \/\/ that are explicitly specified\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:NonNMethodCodeHeapSize=10M\",\n+                                                              \"-XX:ProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:NonProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:+PrintFlagsFinal\",\n+                                                              \"-version\");\n+        verifyCodeHeapSize(pb, \"ReservedCodeCacheSize\", 31457280);\n+\n+        \/\/ Reserved code cache is set, NonNmethod segment size is set, two other segments is automatically\n+        \/\/ adjusted to half of the remaining space\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=100M\",\n+                                                              \"-XX:NonNMethodCodeHeapSize=10M\",\n+                                                              \"-XX:+PrintFlagsFinal\",\n+                                                              \"-version\");\n+        verifyCodeHeapSize(pb, \" ProfiledCodeHeapSize\", 47185920);\n+\n+        \/\/ Reserved code cache is set but NonNmethodCodeHeapSize is not set.\n+        \/\/ It's calculated based on the number of compiler threads\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+SegmentedCodeCache\",\n+                                                              \"-XX:ReservedCodeCacheSize=100M\",\n+                                                              \"-XX:ProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:NonProfiledCodeHeapSize=10M\",\n+                                                              \"-XX:+PrintFlagsFinal\",\n+                                                              \"-version\");\n+        verifyCodeHeapSize(pb, \"NonNMethodCodeHeapSize\", 83886080);\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"}]}