{"files":[{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+@OperationsPerInvocation(100_000)\n+public class SegmentBulkRandomFill {\n+\n+    private static final int INSTANCES = 100_000;\n+\n+    private static final MemorySegment[] HEAP_SEGMENTS = new MemorySegment[INSTANCES];\n+    private static final MemorySegment[] NATIVE_SEGMENTS = new MemorySegment[INSTANCES];\n+    private static final MemorySegment[] UNALIGNED_SEGMENTS = new MemorySegment[INSTANCES];\n+\n+    @Setup\n+    public void setup() {\n+        var rnd = new Random(42);\n+        var arena = Arena.ofAuto();\n+        for (int i = 0; i < INSTANCES; i++) {\n+            var array = new byte[rnd.nextInt(1024)];\n+            HEAP_SEGMENTS[i] = MemorySegment.ofArray(array);\n+            NATIVE_SEGMENTS[i] = arena.allocate(array.length, 8);\n+            UNALIGNED_SEGMENTS[i] = arena.allocate(array.length + 1, 8).asSlice(1);\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Benchmark\n+    public void heapSegmentFillJava() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            HEAP_SEGMENTS[i].fill((byte) 0);\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+    @Benchmark\n+    public void heapSegmentFillUnsafe() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            HEAP_SEGMENTS[i].fill((byte) 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void heapSegmentFillLoop() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            final long end = HEAP_SEGMENTS[i].byteSize();\n+            for (long j = 0; j < end; j++) {\n+                HEAP_SEGMENTS[i].set(ValueLayout.JAVA_BYTE, j, (byte) 0);\n+            }\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Benchmark\n+    public void nativeSegmentFillJava() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            NATIVE_SEGMENTS[i].fill((byte) 0);\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+    @Benchmark\n+    public void nativeSegmentFillUnsafe() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            NATIVE_SEGMENTS[i].fill((byte) 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void nativeSegmentFillLoop() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            final long end = HEAP_SEGMENTS[i].byteSize();\n+            for (long j = 0; j < end; j++) {\n+                NATIVE_SEGMENTS[i].set(ValueLayout.JAVA_BYTE, j, (byte) 0);\n+            }\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Benchmark\n+    public void unalignedSegmentFillJava() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            UNALIGNED_SEGMENTS[i].fill((byte) 0);\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+    @Benchmark\n+    public void unalignedSegmentFillUnsafe() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            UNALIGNED_SEGMENTS[i].fill((byte) 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unalignedSegmentFillLoop() {\n+        for (int i = 0; i < INSTANCES; i++) {\n+            final long end = HEAP_SEGMENTS[i].byteSize();\n+            for (long j = 0; j < end; j++) {\n+                UNALIGNED_SEGMENTS[i].set(ValueLayout.JAVA_BYTE, j, (byte) 0);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkRandomFill.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"}]}