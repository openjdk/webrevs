{"files":[{"patch":"@@ -5834,0 +5834,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -5876,0 +5878,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -5887,0 +5892,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -5916,0 +5923,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -5925,0 +5935,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -5969,0 +5981,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -5977,0 +5992,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6018,0 +6035,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6026,0 +6046,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6067,0 +6089,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6075,0 +6100,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6116,0 +6143,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6124,0 +6154,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6175,0 +6207,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6185,0 +6220,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6234,0 +6271,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6242,0 +6282,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6288,0 +6330,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6296,0 +6341,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6342,0 +6389,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6350,0 +6400,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6396,0 +6448,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2249,0 +2249,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2250,2 +2259,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2254,1 +2261,1 @@\n-                                     current_thread, depth, slot);\n+                                     current_thread, depth, slot, self);\n@@ -2262,7 +2269,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, current_thread, depth, slot);\n+    VM_GetOrSetLocal op(java_thread, current_thread, depth, slot, self);\n@@ -2289,0 +2290,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2290,2 +2300,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2294,1 +2302,1 @@\n-                                   current_thread, depth);\n+                                   current_thread, depth, self);\n@@ -2302,7 +2310,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetReceiver op(java_thread, current_thread, depth);\n+    VM_GetReceiver op(java_thread, current_thread, depth, self);\n@@ -2330,0 +2332,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2331,2 +2342,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2335,1 +2344,1 @@\n-                                     depth, slot, T_INT);\n+                                     depth, slot, T_INT, self);\n@@ -2343,7 +2352,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, self);\n@@ -2371,0 +2374,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2372,2 +2384,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2376,1 +2386,1 @@\n-                                     depth, slot, T_LONG);\n+                                     depth, slot, T_LONG, self);\n@@ -2384,7 +2394,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, self);\n@@ -2412,0 +2416,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2413,2 +2426,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2417,1 +2428,1 @@\n-                                     depth, slot, T_FLOAT);\n+                                     depth, slot, T_FLOAT, self);\n@@ -2425,7 +2436,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, self);\n@@ -2453,0 +2458,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2454,2 +2468,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2458,1 +2470,1 @@\n-                                     depth, slot, T_DOUBLE);\n+                                     depth, slot, T_DOUBLE, self);\n@@ -2466,7 +2478,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, self);\n@@ -2493,0 +2499,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2496,2 +2511,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2500,1 +2513,1 @@\n-                                     depth, slot, T_OBJECT, val);\n+                                     depth, slot, T_OBJECT, val, self);\n@@ -2505,7 +2518,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_OBJECT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_OBJECT, val, self);\n@@ -2529,0 +2536,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2532,2 +2548,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2536,1 +2550,1 @@\n-                                     depth, slot, T_INT, val);\n+                                     depth, slot, T_INT, val, self);\n@@ -2541,7 +2555,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, val, self);\n@@ -2565,0 +2573,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2568,2 +2585,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2572,1 +2587,1 @@\n-                                     depth, slot, T_LONG, val);\n+                                     depth, slot, T_LONG, val, self);\n@@ -2577,7 +2592,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, val, self);\n@@ -2601,0 +2610,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2604,2 +2622,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2608,1 +2624,1 @@\n-                                     depth, slot, T_FLOAT, val);\n+                                     depth, slot, T_FLOAT, val, self);\n@@ -2613,7 +2629,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, val, self);\n@@ -2637,0 +2647,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2640,2 +2659,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2644,1 +2661,1 @@\n-                                     depth, slot, T_DOUBLE, val);\n+                                     depth, slot, T_DOUBLE, val, self);\n@@ -2649,7 +2666,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val, self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":121,"deletions":110,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -174,0 +174,11 @@\n+  static bool is_JavaThread_current(JavaThread* jt, oop thr_obj) {\n+    if (jt == NULL) {\n+      return false; \/\/ jt can be NULL in case of a virtual thread\n+    }\n+    JavaThread* current = JavaThread::current();\n+    oop cur_obj = current->jvmti_vthread();\n+    bool is_current = jt == current && (cur_obj == NULL || cur_obj == thr_obj);\n+\n+    return is_current;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-                                           jint index, BasicType type, jvalue value, bool set)\n+                                           jint index, BasicType type, jvalue value, bool set, bool self)\n@@ -443,0 +443,1 @@\n+  , _self(self)\n@@ -746,2 +747,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self),\n@@ -754,2 +755,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self),\n@@ -762,2 +763,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index)\n-  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index, bool self)\n+  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false, self),\n@@ -788,0 +789,4 @@\n+  if (!(_self || _thread->is_carrier_thread_suspended())) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return NULL;\n+  }\n@@ -802,2 +807,2 @@\n-    JavaThread* thread, JavaThread* caller_thread, jint depth)\n-    : VM_GetOrSetLocal(thread, caller_thread, depth, 0) {}\n+    JavaThread* thread, JavaThread* caller_thread, jint depth, bool self)\n+    : VM_GetOrSetLocal(thread, caller_thread, depth, 0, self) {}\n@@ -813,2 +818,2 @@\n-                                                             jint index, BasicType type)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false)\n+                                                             jint index, BasicType type, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self)\n@@ -822,2 +827,2 @@\n-                                                             jint index, BasicType type, jvalue value)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true)\n+                                                             jint index, BasicType type, jvalue value, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self)\n@@ -831,2 +836,2 @@\n-                                                             jint depth, int index)\n-  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false)\n+                                                             jint depth, int index, bool self)\n+  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false, self)\n@@ -847,0 +852,5 @@\n+  if (!(_self || JvmtiVTSuspender::is_vthread_suspended(_vthread_h()))) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return NULL;\n+  }\n+\n@@ -881,2 +891,2 @@\n-    JvmtiEnv* env, Handle vthread_h, JavaThread* caller_thread, jint depth)\n-    : VM_VirtualThreadGetOrSetLocal(env, vthread_h, caller_thread, depth, 0) {}\n+    JvmtiEnv* env, Handle vthread_h, JavaThread* caller_thread, jint depth, bool self)\n+    : VM_VirtualThreadGetOrSetLocal(env, vthread_h, caller_thread, depth, 0, self) {}\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -322,0 +322,1 @@\n+  bool        _self;\n@@ -337,1 +338,1 @@\n-                       BasicType type, jvalue value, bool set);\n+                       BasicType type, jvalue value, bool set, bool self);\n@@ -361,1 +362,1 @@\n-  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type);\n+  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, bool self);\n@@ -364,1 +365,1 @@\n-  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value);\n+  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value, bool self);\n@@ -367,2 +368,1 @@\n-  VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth,\n-                   int index);\n+  VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index, bool self);\n@@ -382,1 +382,1 @@\n-  VM_GetReceiver(JavaThread* thread, JavaThread* calling_thread, jint depth);\n+  VM_GetReceiver(JavaThread* thread, JavaThread* calling_thread, jint depth, bool self);\n@@ -396,1 +396,1 @@\n-  VM_VirtualThreadGetOrSetLocal(JvmtiEnv* env, Handle vthread_h, jint depth, jint index, BasicType type);\n+  VM_VirtualThreadGetOrSetLocal(JvmtiEnv* env, Handle vthread_h, jint depth, jint index, BasicType type, bool self);\n@@ -400,1 +400,1 @@\n-                                jint index, BasicType type, jvalue value);\n+                                jint index, BasicType type, jvalue value, bool self);\n@@ -404,1 +404,1 @@\n-                                jint depth, int index);\n+                                jint depth, int index, bool self);\n@@ -416,1 +416,1 @@\n-  VM_VirtualThreadGetReceiver(JvmtiEnv* env, Handle vthread_h, JavaThread* calling_thread, jint depth);\n+  VM_VirtualThreadGetReceiver(JvmtiEnv* env, Handle vthread_h, JavaThread* calling_thread, jint depth, bool self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8249293\n- *\n- * @summary Test if stack walk to get local variable in the JVMTI implementation is safe if the\n- *          target thread is not suspended.\n- *\n- * @comment The main\/target thread uses recursion to build a large stack, then\n- *          calls a native method to notify the JVMTI agent thread to get a\n- *          local variable deep in the stack. This prolongs the stack walk. The\n- *          target thread's stack is walkable while in native. After sending the\n- *          notification it waits a while to give the agent time to reach the\n- *          stack walk, then it returns from native. This is when its stack\n- *          becomes not walkable again.\n- *\n- * @library \/test\/lib\n- * @compile GetLocalWithoutSuspendTest.java\n- * @run main\/othervm\/native\n- *                  -agentlib:GetLocalWithoutSuspendTest\n- *                  -Xbatch\n- *                  GetLocalWithoutSuspendTest\n- *\/\n-\n-public class GetLocalWithoutSuspendTest {\n-\n-    public static final int M = 1 << 20;\n-\n-    public static final int TEST_ITERATIONS = 200;\n-\n-    \/**\n-     * Native method to notify the agent thread to call GetLocalObject() on this thread.\n-     *\n-     * @param depth Depth of target frame for GetLocalObject() call. Should be\n-     *        large value to prolong the unsafe stack walk.\n-     * @param waitTime Time to wait after notify with\n-     *        walkable stack before returning an becoming unsafe again.\n-     * @return Dummy value.\n-     *\/\n-    public static native void notifyAgentToGetLocal(int depth, int waitTime);\n-\n-    \/**\n-     * Notify agent thread that we are shutting down and wait for it to terminate.\n-     *\/\n-    public static native void shutDown();\n-\n-    \/**\n-     * Provide agent thread with reference to target thread.\n-     * @param target The target thread\n-     *\/\n-    public static native void setTargetThread(Thread target);\n-\n-    public static void main(String[] args) throws Exception {\n-        new GetLocalWithoutSuspendTest().runTest();\n-    }\n-\n-    \/**\n-     * Wait cycles in native, i.e. with walkable stack, after notifying agent\n-     * thread to do GetLocalObject() call.\n-     *\/\n-    public int waitCycles = 1;\n-\n-    public void runTest() throws Exception {\n-        log(\"Set target thread for get local variable calls by agent.\");\n-        setTargetThread(Thread.currentThread());\n-\n-        log(\"Test how many frames fit on the stack by performing recursive calls until\");\n-        log(\"StackOverflowError is thrown\");\n-        int targetDepth = recursiveMethod(0, M);\n-        log(\"Testing with target depth: \" + targetDepth);\n-\n-        log(\"Begin Test.\");\n-        long start = System.currentTimeMillis();\n-        for (int iterations = 0; iterations < TEST_ITERATIONS; iterations++) {\n-            long now = System.currentTimeMillis();\n-            log((now - start) + \" ms  Iteration : \" + iterations +\n-                \"  waitTime : \" + waitCycles);\n-            int newTargetDepth = recursiveMethod(0, targetDepth);\n-            if (newTargetDepth < targetDepth) {\n-                \/\/ A StackOverflowError can occur due to (re-)compilation. We\n-                \/\/ don't reach the native method notifyAgentToGetLocal() then\n-                \/\/ which is a prerequisite to trigger the problematic race\n-                \/\/ condition. So we reduce the targetDepth to avoid stack\n-                \/\/ overflow.\n-                log(\"StackOverflowError during test.\");\n-                log(\"Old target depth: \" + targetDepth);\n-                log(\"Retry with new target depth: \" + newTargetDepth);\n-                targetDepth = newTargetDepth;\n-            }\n-            iterations++;\n-            \/\/ Double wait time, but limit to roughly 10^6 cycles.\n-            waitCycles = (waitCycles << 1) & (M - 1);\n-            waitCycles = waitCycles == 0 ? 1 : waitCycles;\n-        }\n-\n-        \/\/ Notify agent thread that we are shutting down and wait for it to terminate.\n-        shutDown();\n-\n-        log(\"Successfully finished test\");\n-    }\n-\n-    \/**\n-     * Perform recursive calls until the target stack depth is reached or the stack overflows.\n-     * Call {@link #notifyAgentToGetLocal(int, int)} if the target depth is reached.\n-     *\n-     * @param depth Current recursion depth\n-     * @param targetStackDepth Target recursion depth\n-     * @return Depth at which the recursion was ended\n-     *\/\n-    public int recursiveMethod(int depth, int targetStackDepth) {\n-        int maxDepth = depth;\n-        try {\n-            if (depth == targetStackDepth) {\n-                notifyAgentToGetLocal(depth - 100, waitCycles);\n-            } else {\n-                maxDepth = recursiveMethod(depth + 1, targetStackDepth);\n-            }\n-        } catch (StackOverflowError e) {\n-            \/\/ Don't print message here, because this would likely trigger a new StackOverflowError\n-        }\n-        return maxDepth;\n-    }\n-\n-    public static void log(String m) {\n-        System.out.println(\"### Java-Test: \" + m);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/GetLocalWithoutSuspendTest.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies JVMTI GetLocalXXX\/SetLocalXXX return errors for unsuspended vthreads\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @compile --enable-preview -source ${jdk.version} GetSetLocalUnsuspended.java\n+ * @run main\/othervm\/native --enable-preview -agentlib:GetSetLocalUnsuspended GetSetLocalUnsuspended\n+ *\/\n+\n+\n+public class GetSetLocalUnsuspended {\n+    private static final String agentLib = \"GetSetLocalUnsuspended\";\n+\n+    static native void testUnsuspendedThread(Thread thread);\n+\n+    static private volatile boolean doStop;\n+\n+    static private void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interruption in Thread.sleep: \\n\\t\" + e);\n+        }\n+    }\n+\n+    static final Runnable SLEEPING_THREAD = () -> {\n+        while (!doStop) {\n+            sleep(1);\n+        }\n+    };\n+\n+    public static void testPlatformThread() throws Exception {\n+        doStop = false;\n+        Thread thread = Thread.ofPlatform().name(\"SleepingPlatformThread\").start(SLEEPING_THREAD);\n+        testUnsuspendedThread(thread);\n+        doStop = true;\n+        thread.join();\n+    }\n+\n+    public static void testVirtualThread() throws Exception {\n+        doStop = false;\n+        Thread thread = Thread.ofVirtual().name(\"SleepingVirtualThread\").start(SLEEPING_THREAD);\n+        testUnsuspendedThread(thread);\n+        doStop = true;\n+        thread.join();\n+    }\n+\n+    void runTest() throws Exception {\n+        testPlatformThread();\n+        testVirtualThread();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            System.loadLibrary(agentLib);\n+        } catch (UnsatisfiedLinkError ex) {\n+            System.err.println(\"Failed to load \" + agentLib + \" lib\");\n+            System.err.println(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ex;\n+        }\n+\n+        GetSetLocalUnsuspended obj = new GetSetLocalUnsuspended();\n+        obj.runTest();\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/GetSetLocalUnsuspended.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -1,449 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"jni.h\"\n-\n-\n-\/\/\n-\/\/ Please also read the @comment in GetLocalWithoutSuspendTest.java\n-\/\/\n-\n-extern \"C\" {\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BEGIN: Shared Variables\n-\/\/ The following variables are shared between agent and target thread\n-\n-\/\/ glws_monitor is used to synchronize access to shared variables.\n-static jrawMonitorID glws_monitor;\n-\n-\/\/ Target thread for agent operations.\n-static jthread target_thread = NULL;\n-\n-\/\/ Depth of the frame for GetLocalObject() call by the agent thread. It is set by the target thread.\n-\/\/ -1 is the signal to shut down.\n-static int depth_for_get_local = 0;\n-\n-enum TestState {\n-  Initial,\n-\n-  TargetInNative,            \/\/ The agent waits for the target thread to reach\n-                             \/\/ the native method notifyAgentToGetLocal. Then it\n-                             \/\/ reads depth_for_get_local and changes the state\n-                             \/\/ to AgentInGetLocal. After that it\n-                             \/\/ calls GetLocalObject().\n-\n-  AgentInGetLocal,           \/\/ The target thread waits for the agent to call\n-                             \/\/ GetLocalObject(). When this state is reached it\n-                             \/\/ resets the state to Initial and returns from\n-                             \/\/ native after a short spin wait racing the agent\n-                             \/\/ thread doing the unsafe stack walk.\n-\n-  ShutDown,\n-\n-  Terminated\n-};\n-\n-\/\/ Current test state. It is used to synchronize agent and target thread execution.\n-static TestState test_state;\n-\n-\/\/ END: Shared Variables\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-\/\/ Dummy counter used in spin wait. It is declared volatile to prevent the compiler\n-\/\/ from eliminating the whole spin loop.\n-static volatile int dummy_counter   = 0;\n-\n-\/\/ Makes a string of the argument (which is not macro-expanded)\n-#define STR(a)  #a\n-\n-\/\/ Makes a string of the macro expansion of a\n-#define XSTR(a) STR(a)\n-\n-#define AT_LINE \" ERROR at line \" XSTR(__LINE__)\n-\n-static jvmtiEnv* jvmti = NULL;\n-\n-static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n-\n-static char* GetErrorMessage(jvmtiEnv *jvmti, jvmtiError errCode) {\n-  char *errMsg;\n-  jvmtiError result = jvmti->GetErrorName(errCode, &errMsg);\n-  return result == JVMTI_ERROR_NONE ? errMsg : NULL;\n-}\n-\n-static void ShowErrorMessage(jvmtiEnv *jvmti, jvmtiError errCode, const char *message) {\n-  char* errMsg = GetErrorMessage(jvmti, errCode);\n-\n-  if (errMsg != NULL) {\n-    fprintf(stderr, \"AGENT: %s: %s (%d)\\n\", message, errMsg, errCode);\n-    jvmti->Deallocate((unsigned char *)errMsg);\n-  } else {\n-    fprintf(stderr, \"AGENT: %s (%d)\\n\", message, errCode);\n-  }\n-}\n-\n-static void monitor_enter(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorEnter(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_exit(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorExit(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_wait(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorWait(glws_monitor, 0);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_notify(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorNotify(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_destroy(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->DestroyRawMonitor(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-\/\/ Perform GetLocalObject() at the requested depth while target thread is running.\n-\/\/ Note that the JVMTI spec does not require to suspend the target thread.\n-void test_GetLocalObject(jvmtiEnv* jvmti, JNIEnv* env, int depth) {\n-  jvmtiError err;\n-  jobject obj;\n-  char* errMsg;\n-\n-  printf(\"AGENT: calling GetLocalObject() with depth %d\\n\", depth);\n-  err = jvmti->GetLocalObject(target_thread, depth, 0, &obj);\n-  errMsg = GetErrorMessage(jvmti, err);\n-  printf(\"AGENT: GetLocalObject() result code %s (%d)\\n\", errMsg != NULL ? errMsg : \"N\/A\", err);\n-  if (errMsg != NULL) {\n-    jvmti->Deallocate((unsigned char *)errMsg);\n-  }\n-  fflush(stdout);\n-\n-  \/\/ If the target thread wins the race we can get errors because we\n-  \/\/ don't find a frame at the given depth or we find a non-java frame\n-  \/\/ there (e.g. native frame). This is expected.\n-  \/\/ JVMTI_ERROR_INVALID_SLOT can occur also because the target thread is\n-  \/\/ running and the GetLocalObject() call might coincidentally refer to the\n-  \/\/ frame of a static method without parameters.\n-  if (err != JVMTI_ERROR_NONE &&\n-      err != JVMTI_ERROR_NO_MORE_FRAMES &&\n-      err != JVMTI_ERROR_OPAQUE_FRAME &&\n-      err != JVMTI_ERROR_INVALID_SLOT) {\n-    ShowErrorMessage(jvmti, err, \"AgentThreadLoop: error in JVMTI GetLocalObject\");\n-    env->FatalError(\"AgentThreadLoop: error in JVMTI GetLocalObject\\n\");\n-  }\n-}\n-\n-\/\/ Function holding the main loop for the test agent thread.\n-\/\/\n-\/\/ The agent does the following in each loop iteration:\n-\/\/\n-\/\/ - Wait for the target thread either to start a new test iteration or to\n-\/\/   signal shutdown.\n-\/\/\n-\/\/     Shutdown is signalled by setting test_state to ShutDown. The agent reacts\n-\/\/     to it by changing test_state to Terminated and then exits.\n-\/\/\n-\/\/     In the case of a new test iteration the target thread builds a deep call\n-\/\/     stack and then calls the native method notifyAgentToGetLocal(). While in\n-\/\/     native code its stack is walkable. It sets the shared variable test_state\n-\/\/     to TargetInNative and then uses the glws_monitor to send the\n-\/\/     notification to the agent thread.\n-\/\/\n-\/\/ - Read the shared variable depth_for_get_local which was set by the target\n-\/\/   thread before sending the notification.\n-\/\/\n-\/\/ - Set test_state to AgentInGetLocal and notify the target thread.\n-\/\/\n-\/\/ - Perform the JVMTI GetLocal call at depth_for_get_local racing the target\n-\/\/   thread returning from the native call making its stack not walkable. The VM\n-\/\/   will crash if this happens while the stack is walked to find the frame for\n-\/\/   the GetLocal operation. The deeper the frame the more likely the crash\n-\/\/   because the stack walk takes longer.\n-\/\/\n-JNIEXPORT void JNICALL\n-AgentThreadLoop(jvmtiEnv * jvmti, JNIEnv* env, void * arg) {\n-  jvmtiError err;\n-  jvmtiThreadInfo thread_info;\n-\n-  \/\/ Wait until target_thread is set by target thread.\n-  monitor_enter(jvmti, env, AT_LINE);\n-  while (target_thread == NULL) {\n-    monitor_wait(jvmti, env, AT_LINE);\n-  }\n-  monitor_exit(jvmti, env, AT_LINE);\n-\n-  err = jvmti->GetThreadInfo(target_thread, &thread_info);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"AgentThreadLoop: error in JVMTI GetThreadInfo\");\n-    env->FatalError(\"AgentThreadLoop: error in JVMTI GetThreadInfo\\n\");\n-  }\n-\n-  printf(\"AGENT: AgentThreadLoop thread started. Polling thread '%s' for local variables\\n\",\n-         thread_info.name);\n-  jvmti->Deallocate((unsigned char *) thread_info.name);\n-\n-  do {\n-    int depth;\n-\n-    monitor_enter(jvmti, env, AT_LINE);\n-\n-    \/\/ Wait for java part to build large stack and then become stack walk\n-    \/\/ save by calling the native method notifyAgentToGetLocal or to signal\n-    \/\/ shutdown.\n-    while (test_state != TargetInNative) {\n-      if (test_state == ShutDown) {\n-        test_state = Terminated;\n-        monitor_notify(jvmti, env, AT_LINE);\n-        monitor_exit(jvmti, env, AT_LINE);\n-        return;\n-      }\n-      monitor_wait(jvmti, env, AT_LINE);\n-    }\n-    depth = depth_for_get_local;\n-\n-    \/\/ Notify target thread that this thread is about to query the local value.\n-    test_state = AgentInGetLocal;\n-    monitor_notify(jvmti, env, AT_LINE);\n-\n-    monitor_exit(jvmti, env, AT_LINE);\n-\n-    \/\/ Now get the local object from the target thread's stack.\n-    test_GetLocalObject(jvmti, env, depth);\n-  } while (true);\n-\n-  printf(\"AGENT: AgentThreadLoop thread: exiting\\n\");\n-}\n-\n-\/\/ Called by target thread after building a large stack.\n-\/\/ By calling this native method, the thread's stack becomes walkable.\n-\/\/ It notifies the agent to do the GetLocalObject() call and then races\n-\/\/ it to make its stack not walkable by returning from the native call.\n-JNIEXPORT void JNICALL\n-Java_GetLocalWithoutSuspendTest_notifyAgentToGetLocal(JNIEnv *env, jclass cls, jint depth, jint waitCycles) {\n-  monitor_enter(jvmti, env, AT_LINE);\n-\n-  \/\/ Set depth_for_get_local and notify agent that the target thread is ready for the GetLocalObject() call\n-  depth_for_get_local = depth;\n-  test_state = TargetInNative;\n-\n-  monitor_notify(jvmti, env, AT_LINE);\n-\n-  \/\/ Wait for agent thread to read depth_for_get_local and do the GetLocalObject() call\n-  while (test_state != AgentInGetLocal) {\n-    monitor_wait(jvmti, env, AT_LINE);\n-  }\n-\n-  \/\/ Reset state to Initial\n-  test_state = Initial;\n-\n-  monitor_exit(jvmti, env, AT_LINE);\n-\n-  \/\/ Wait a little until agent thread is in unsafe stack walk.\n-  \/\/ This needs to be a spin wait or sleep because we cannot get a notification\n-  \/\/ from there.\n-  while (--waitCycles > 0) {\n-    dummy_counter++;\n-  }\n-}\n-\n-\/\/ Called by target thread to signal shutdown. The target thread waits for the\n-\/\/ agent's acknowledge by changing test_state to Terminated.\n-JNIEXPORT void JNICALL\n-Java_GetLocalWithoutSuspendTest_shutDown(JNIEnv *env, jclass cls) {\n-  monitor_enter(jvmti, env, AT_LINE);\n-\n-  \/\/ Notify agent thread to shut down\n-  test_state = ShutDown;\n-  monitor_notify(jvmti, env, AT_LINE);\n-\n-  \/\/ Wait for agent to terminate\n-  while (test_state != Terminated) {\n-    monitor_wait(jvmti, env, AT_LINE);\n-  }\n-\n-  monitor_exit(jvmti, env, AT_LINE);\n-\n-  \/\/ Destroy glws_monitor\n-  monitor_destroy(jvmti, env, AT_LINE);\n-}\n-\n-\/\/ Called by target thread to provide agent with its thread object\n-JNIEXPORT void JNICALL\n-Java_GetLocalWithoutSuspendTest_setTargetThread(JNIEnv *env, jclass cls, jthread target) {\n-  monitor_enter(jvmti, env, AT_LINE);\n-\n-  target_thread = env->NewGlobalRef(target);\n-\n-  monitor_notify(jvmti, env, AT_LINE);\n-\n-  monitor_exit(jvmti, env, AT_LINE);\n-}\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti, JNIEnv *env, jthread thr) {\n-  jvmtiError err;\n-  jobject agent_thread_name;\n-  jclass thread_clas;\n-  jmethodID thread_ctor;\n-  jthread agent_thread;\n-\n-  printf(\"AGENT: VM init event\\n\");\n-  printf(\"AGENT: Start new thread that performs GetLocalObject calls on a running target thread\\n\");\n-\n-  agent_thread_name = env->NewStringUTF(\"GetLocalWithoutSuspendTest Agent Thread\");\n-  if (agent_thread_name == NULL) {\n-    env->FatalError(\"VMInit: NewStringUTF failed\\n\");\n-  }\n-\n-  thread_clas = env->FindClass(\"java\/lang\/Thread\");\n-  if (thread_clas == NULL) {\n-    env->FatalError(\"VMInit: java.lang.Thread class not found\\n\");\n-  }\n-\n-  thread_ctor = env->GetMethodID(thread_clas, \"<init>\", \"(Ljava\/lang\/String;)V\");\n-  if (thread_ctor == NULL) {\n-    env->FatalError(\"VMInit: failed to get ID for the Thread ctor\\n\");\n-  }\n-\n-  agent_thread = (jthread) env->NewObject(thread_clas, thread_ctor, agent_thread_name);\n-  if (agent_thread == NULL) {\n-    env->FatalError(\"VMInit: Failed to allocate thread object\\n\");\n-  }\n-\n-  err = jvmti->RunAgentThread(agent_thread, &AgentThreadLoop, NULL,\n-                              JVMTI_THREAD_NORM_PRIORITY);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"VMInit: failed to start GetLocalWithoutSuspendTest thread\");\n-    return;\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  printf(\"AGENT: Agent_OnLoad started.\\n\");\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  printf(\"AGENT: Agent_OnAttach started.\");\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL\n-JNI_OnLoad(JavaVM *jvm, void *reserved) {\n-  jint res;\n-  JNIEnv *env;\n-\n-  printf(\"AGENT: JNI_OnLoad started.\");\n-  res = jvm->GetEnv((void **) &env, JNI_VERSION_9);\n-  if (res != JNI_OK || env == NULL) {\n-    fprintf(stderr, \"Error: GetEnv call failed(%d)!\\n\", res);\n-    return JNI_ERR;\n-  }\n-\n-  return JNI_VERSION_9;\n-}\n-\n-static\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jint res;\n-  jvmtiError err;\n-  jvmtiCapabilities caps;\n-  jvmtiEventCallbacks callbacks;\n-\n-  printf(\"AGENT: Agent_Initialize started\\n\");\n-\n-  memset(&caps, 0, sizeof(caps));\n-  memset(&callbacks, 0, sizeof(callbacks));\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    fprintf(stderr, \"Error: GetEnv(JVMTI_VERSION_9) call failed(%d)!\\n\", res);\n-    return JNI_ERR;\n-  }\n-\n-  caps.can_access_local_variables = 1;\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI AddCapabilities\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI GetCapabilities\");\n-    return JNI_ERR;\n-  }\n-\n-  if (!caps.can_access_local_variables) {\n-    fprintf(stderr, \"Warning: Access to local variables is not implemented\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  callbacks.VMInit = &VMInit;\n-  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI SetEventCallbacks\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI SetEventNotificationMode\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->CreateRawMonitor(\"GetLocalWithoutSuspend Test Monitor\", &glws_monitor);\n-\n-  printf(\"AGENT: Agent_Initialize finished\\n\");\n-  return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/libGetLocalWithoutSuspendTest.cpp","additions":0,"deletions":449,"binary":false,"changes":449,"status":"deleted"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define MAX_FRAME_COUNT 30\n+\n+enum Slots {\n+  SlotInvalid0 = -1,\n+  SlotString = 0,\n+  SlotThread = 1,\n+  SlotInt = 2,\n+  SlotLong = 3,\n+  SlotUnaligned = 4,\n+  SlotFloat = 5,\n+  SlotDouble = 6,\n+};\n+\n+static jvmtiEnv *jvmti = NULL;\n+\n+static void\n+check_jvmti_error_not_suspended(JNIEnv* jni, const char* func_name, jvmtiError err) {\n+  if (err != JVMTI_ERROR_THREAD_NOT_SUSPENDED) {\n+    LOG(\"%s failed: expected JVMTI_ERROR_THREAD_NOT_SUSPENDED instead of: %d\\n\", func_name, err);\n+    fatal(jni, func_name);\n+  }\n+}\n+\n+static void\n+test_GetLocal(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err;\n+  const int depth = 0;\n+\n+  jobject msg = NULL;\n+  jint ii = 0;\n+  jlong ll = 0L;\n+  jfloat ff = 0.0;\n+  jdouble dd = 0.0;\n+\n+  LOG(\"\\ntest_GetLocal started\\n\");\n+\n+  \/\/ #0: Test JVMTI GetLocalInstance function\n+  err = jvmti->GetLocalInstance(thread, depth, &msg);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalInstance\", err);\n+  LOG(\"check for JVMTI GetLocalInstance succeeded\\n\");\n+\n+  \/\/ #1: Test JVMTI GetLocalObject function\n+  err = jvmti->GetLocalObject(thread, depth, SlotString, &msg);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalObject\", err);\n+  LOG(\"check for JVMTI GetLocalObject succeeded\\n\");\n+\n+  \/\/ #2: Test JVMTI GetLocalInt function\n+  err = jvmti->GetLocalInt(thread, depth, SlotInt, &ii);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalInt\", err);\n+  LOG(\"check for JVMTI GetLocalInt succeeded\\n\");\n+\n+  \/\/ #3: Test JVMTI GetLocalLong function\n+  err = jvmti->GetLocalLong(thread, depth, SlotLong, &ll);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalLong\", err);\n+  LOG(\"check for JVMTI GetLocalLong succeeded\\n\");\n+\n+  \/\/ #4: Test JVMTI GetLocalFloat function\n+  err = jvmti->GetLocalFloat(thread, depth, SlotFloat, &ff);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalFloat\", err);\n+  LOG(\"check for JVMTI GetLocalFloat succeeded\\n\");\n+\n+  \/\/ #5: Test JVMTI GetLocalDouble function\n+  err = jvmti->GetLocalDouble(thread, depth, SlotDouble, &dd);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalDouble\", err);\n+  LOG(\"check for JVMTI GetLocalDouble succeeded\\n\");\n+\n+  LOG(\"test_GetLocal finished\\n\");\n+}\n+\n+static void\n+test_SetLocal(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err;\n+  const int depth = 0;\n+\n+  const jobject msg = NULL;\n+  const jint ii = 0;\n+  const jlong ll = 0L;\n+  const jfloat ff = 0.0;\n+  const jdouble dd = 0.0;\n+\n+  LOG(\"\\ntest_SetLocal started\\n\");\n+\n+  \/\/ #1: Test JVMTI SetLocalObject function\n+  err = jvmti->SetLocalObject(thread, depth, SlotString, msg);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalObject\", err);\n+  LOG(\"check for JVMTI SetLocalObject succeeded\\n\");\n+\n+  \/\/ #2: Test JVMTI SetLocalInt function\n+  err = jvmti->SetLocalInt(thread, depth, SlotInt, ii);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalInt\", err);\n+  LOG(\"check for JVMTI SetLocalInt succeeded\\n\");\n+\n+  \/\/ #3: Test JVMTI SetLocalLong function\n+  err = jvmti->SetLocalLong(thread, depth, SlotLong, ll);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalLong\", err);\n+  LOG(\"check for JVMTI SetLocalLong succeeded\\n\");\n+\n+  \/\/ #4: Test JVMTI SetLocalFloat function\n+  err = jvmti->SetLocalFloat(thread, depth, SlotFloat, ff);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalFloat\", err);\n+  LOG(\"check for JVMTI SetLocalFloat succeeded\\n\");\n+\n+  \/\/ #5: Test JVMTI SetLocalDouble function\n+  err = jvmti->SetLocalDouble(thread, depth, SlotDouble, dd);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalDouble\", err);\n+  LOG(\"check for JVMTI SetLocalDouble succeeded\\n\");\n+\n+  LOG(\"test_SetLocal finished\\n\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_support_virtual_threads = 1;\n+  caps.can_access_local_variables = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"error in JVMTI AddCapabilities: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetSetLocalUnsuspended_testUnsuspendedThread(JNIEnv *jni, jclass klass, jthread thread) {\n+  char* tname = get_thread_name(jvmti, jni, thread);\n+  jmethodID method = NULL;\n+  jlocation location = 0;\n+\n+  LOG(\"\\ntestUnsuspendedThread: started for thread: %s\\n\", tname);\n+\n+  test_GetLocal(jvmti, jni, thread);\n+  test_SetLocal(jvmti, jni, thread);\n+\n+  LOG(\"\\ntestUnsuspendedThread: finished for thread: %s\\n\", tname);\n+  deallocate(jvmti, jni, (void*)tname);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/libGetSetLocalUnsuspended.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -130,0 +130,2 @@\n+    suspend_thread(jvmti, jni, cthread);\n+\n@@ -133,0 +135,2 @@\n+\n+    resume_thread(jvmti, jni, cthread);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetSetLocalTest\/libGetSetLocalTest.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -381,2 +381,2 @@\n-  err = jvmti->GetLocalInstance(cthread, 3, &obj);\n-  check_jvmti_status(jni, err, \"event handler: error in JVMTI GetLocalInstance for carrier thread top frame Continuation.run\");\n+  {\n+    suspend_thread(jvmti, jni, cthread);\n@@ -384,1 +384,6 @@\n-  LOG(\"JVMTI GetLocalInstance succeed for carrier thread top frame Continuation.run()\\n\");\n+    err = jvmti->GetLocalInstance(cthread, 3, &obj);\n+    check_jvmti_status(jni, err, \"event handler: error in JVMTI GetLocalInstance for carrier thread top frame Continuation.run\");\n+    LOG(\"JVMTI GetLocalInstance succeed for carrier thread top frame Continuation.run()\\n\");\n+\n+    resume_thread(jvmti, jni, cthread);\n+  }\n@@ -592,0 +597,1 @@\n+  caps.can_suspend = 1;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadTest\/libVThreadTest.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -319,2 +319,0 @@\n-\n-\/* DEBUG -- while thread should be suspended\n@@ -322,1 +320,0 @@\n-*\/\n@@ -328,1 +325,0 @@\n-\/* DEBUG -- while thread should be suspended\n@@ -335,1 +331,0 @@\n-*\/\n@@ -391,1 +386,0 @@\n-\/* DEBUG -- while thread should be suspended\n@@ -396,1 +390,0 @@\n-*\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t011\/cm01t011.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}