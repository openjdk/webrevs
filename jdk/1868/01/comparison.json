{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -118,2 +119,3 @@\n-\/\/ A helper class for EnumRange and EnumIterator, computing some\n-\/\/ additional information based on T and EnumeratorRange<T>.\n+\/\/ An internal helper class for EnumRange and EnumIterator, computing some\n+\/\/ additional information based on T and EnumeratorRange<T>, and performing\n+\/\/ or supporting various validity checks.\n@@ -134,6 +136,0 @@\n-  \/\/ The first enumerator of T.\n-  static constexpr T _first = static_cast<T>(_start);\n-\n-  \/\/ The last enumerator of T.\n-  static constexpr T _last = static_cast<T>(_end - 1);\n-\n@@ -142,0 +138,21 @@\n+\n+  \/\/ Verify value is in [start, end].\n+  \/\/ The values for start and end default to _start and _end, respectively.\n+  \/\/ The (deduced) type V is expected to be either T or Underlying.\n+  template<typename V>\n+  static constexpr void assert_in_range(V value,\n+                                        V start = PrimitiveConversions::cast<V>(_start),\n+                                        V end = PrimitiveConversions::cast<V>(_end)) {\n+    assert(start <= value, \"out of range\");\n+    assert(value <= end, \"out of range\");\n+  }\n+\n+  \/\/ Convert an enumerator value to the corresponding underlying type.\n+  static constexpr Underlying underlying_value(T value) {\n+    return static_cast<Underlying>(value);\n+  }\n+\n+  \/\/ Convert a value to the corresponding enumerator.\n+  static constexpr T enumerator(Underlying value) {\n+    return static_cast<T>(value);\n+  }\n@@ -163,1 +180,1 @@\n-    _value(static_cast<Underlying>(value))\n+    _value(Traits::underlying_value(value))\n@@ -165,2 +182,1 @@\n-    assert(_value >= Traits::_start, \"out of range\");\n-    assert(_value <= Traits::_end, \"out of range\");\n+    Traits::assert_in_range(value);\n@@ -183,1 +199,1 @@\n-    return static_cast<T>(_value);\n+    return Traits::enumerator(_value);\n@@ -212,0 +228,4 @@\n+  constexpr void assert_not_empty() const {\n+    assert(size() > 0, \"empty range\");\n+  }\n+\n@@ -218,1 +238,1 @@\n-    EnumRange(Traits::_first) {}\n+    EnumRange(Traits::enumerator(Traits::_start)) {}\n@@ -222,1 +242,1 @@\n-    EnumRange(start, static_cast<T>(Traits::_end)) {}\n+    EnumRange(start, Traits::enumerator(Traits::_end)) {}\n@@ -227,2 +247,2 @@\n-    _start(static_cast<Underlying>(start)),\n-    _end(static_cast<Underlying>(end))\n+    _start(Traits::underlying_value(start)),\n+    _end(Traits::underlying_value(end))\n@@ -230,3 +250,3 @@\n-    assert(Traits::_start <= _start, \"out of range\");\n-    assert(_end <= Traits::_end, \"out of range\");\n-    assert(_start <= _end, \"invalid range\");\n+    Traits::assert_in_range(start);\n+    Traits::assert_in_range(end);\n+    assert(start <= end, \"invalid range\");\n@@ -237,1 +257,1 @@\n-    return Iterator(static_cast<T>(_start));\n+    return Iterator(Traits::enumerator(_start));\n@@ -242,1 +262,1 @@\n-    return Iterator(static_cast<T>(_end));\n+    return Iterator(Traits::enumerator(_end));\n@@ -245,0 +265,1 @@\n+  \/\/ Return the number of enumerator values in the range.\n@@ -249,2 +270,13 @@\n-  constexpr T first() const { return static_cast<T>(_start); }\n-  constexpr T last() const { return static_cast<T>(_end - 1); }\n+  \/\/ Return the first enumerator in the range.\n+  \/\/ precondition: size() > 0\n+  constexpr T first() const {\n+    assert_not_empty();\n+    return Traits::enumerator(_start);\n+  }\n+\n+  \/\/ Return the last enumerator in the range.\n+  \/\/ precondition: size() > 0\n+  constexpr T last() const {\n+    assert_not_empty();\n+    return Traits::enumerator(_end - 1);\n+  }\n@@ -255,3 +287,2 @@\n-    assert(first() <= value, \"out of bounds\");\n-    assert(value <= last(), \"out of bounds\");\n-    return static_cast<size_t>(static_cast<Underlying>(value) - _start);\n+    Traits::assert_in_range(value, first(), last());\n+    return static_cast<size_t>(Traits::underlying_value(value) - _start);\n","filename":"src\/hotspot\/share\/utilities\/enumIterator.hpp","additions":57,"deletions":26,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -181,0 +181,39 @@\n+\n+#ifdef ASSERT\n+\n+static volatile ExplicitTest empty_range_value = ExplicitTest::value1;\n+static volatile size_t empty_range_index =\n+  EnumRange<ExplicitTest>().index(empty_range_value);\n+\n+TEST_VM_ASSERT(TestEnumIterator, empty_range_first) {\n+  constexpr ExplicitTest start = ExplicitTest::value2;\n+  EXPECT_FALSE(empty_range_value == EnumRange<ExplicitTest>(start, start).first());\n+}\n+\n+TEST_VM_ASSERT(TestEnumIterator, empty_range_last) {\n+  constexpr ExplicitTest start = ExplicitTest::value2;\n+  EXPECT_FALSE(empty_range_value == EnumRange<ExplicitTest>(start, start).last());\n+}\n+\n+TEST_VM_ASSERT(TestEnumIterator, empty_range_index) {\n+  constexpr ExplicitTest start = ExplicitTest::value2;\n+  EXPECT_FALSE(empty_range_index == EnumRange<ExplicitTest>(start, start).index(start));\n+}\n+\n+TEST_VM_ASSERT(TestEnumIterator, end_iterator_dereference) {\n+  EXPECT_FALSE(empty_range_value == *(EnumRange<ExplicitTest>().end()));\n+}\n+\n+const int invalid_implicit_int = implicit_start - 1;\n+static volatile ImplicitTest invalid_implicit_value =\n+  static_cast<ImplicitTest>(invalid_implicit_int);\n+\n+TEST_VM_ASSERT(TestEnumIterator, invalid_range) {\n+  EXPECT_TRUE(invalid_implicit_value == EnumRange<ImplicitTest>(invalid_implicit_value).first());\n+}\n+\n+TEST_VM_ASSERT(TestEnumIterator, invalid_iterator) {\n+  EXPECT_TRUE(invalid_implicit_value == *EnumIterator<ImplicitTest>(invalid_implicit_value));\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/utilities\/test_enumIterator.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"}]}