[{"commit":{"message":"Adjust object sampler span handling\n\nThe span stored in each sample is not the calculated span, it's just the\nobject's byte size (`allocated`). That means as soon as any object falls\nout of the queue, the spans in the queue no longer sum to cover the\nallocation timeline. This causes all future samples to be added to be\nunduly prioritized for adding to the queue, because they are given an\nartificially high span. In effect, future samples are weighted as if they\ncover both the interval between themselves and the older neighbor sample,\nplus all \"missing spans\" from nodes that have been discarded since the\nprogram started.\n\nChanged object samples to store the calculated span rather than the bytes\nallocated for the sampled object.\n\nWhen a sample is removed from the queue because a sample with a larger\nspan is being added, the span of the removed node is not handed to the\nyounger neighbor, this only happens when a sample is removed due to GC.\nThis means that the span will be given to the next sample added to the\nqueue. When the sample being removed is the youngest sample, this is fine,\nbut when it's a sample that has a younger neighbor, the span should\nprobably be given to that neighbor rather than the newcomer. Handing it to\nthe newcomer gives the new sample a high weight it doesn't deserve. It ends\nup covering not just the span to the older neighbor, but also the span of\nthe removed node, which is not what we want.\n\nWhen replacing a sample in the queue, give the span of the removed sample\nto the younger neighbor. If there is no such neighbor, because the youngest\nsample is being replaced, give the span to the node being added instead,\nas that will become the new youngest sample."},"files":[{"filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp"},{"filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.hpp"}],"sha":"376f04756e42cd08aaab42d9bfd2e0e3d9c2b660"}]