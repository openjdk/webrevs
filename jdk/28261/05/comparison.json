{"files":[{"patch":"@@ -1750,0 +1750,3 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) {\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1584,0 +1584,3 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) {\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2998,0 +2998,4 @@\n+void os::numa_set_thread_affinity(Thread* thread, int node) {\n+  Linux::numa_set_thread_affinity(thread->osthread()->thread_id(), node);\n+}\n+\n@@ -3180,0 +3184,2 @@\n+      set_numa_bitmask_clearbit(CAST_TO_FN_PTR(numa_bitmask_clearbit_func_t,\n+                                               libnuma_dlsym(handle, \"numa_bitmask_clearbit\")));\n@@ -3194,0 +3200,4 @@\n+      set_numa_sched_setaffinity(CAST_TO_FN_PTR(numa_sched_setaffinity_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_sched_setaffinity\")));\n+      set_numa_allocate_cpumask(CAST_TO_FN_PTR(numa_allocate_cpumask_func_t,\n+                                               libnuma_v2_dlsym(handle, \"numa_allocate_cpumask\")));\n@@ -3199,0 +3209,1 @@\n+        set_numa_all_cpus_ptr((struct bitmask **)libnuma_dlsym(handle, \"numa_all_cpus_ptr\"));\n@@ -3202,0 +3213,1 @@\n+\n@@ -3205,0 +3217,1 @@\n+\n@@ -3208,0 +3221,5 @@\n+\n+        \/\/ Create a node -> CPUs mapping\n+        _numa_affinity_masks = new (mtInternal) GrowableArray<struct bitmask*>(0, mtInternal);\n+        build_numa_affinity_masks();\n+\n@@ -3243,0 +3261,36 @@\n+void os::Linux::build_numa_affinity_masks() {\n+  \/\/ We only build the affinity masks if running libnuma v2 (_numa_node_to_cpus_v2\n+  \/\/ is available) and we have the affinity mask of the process when it started.\n+  if (_numa_node_to_cpus_v2 == nullptr || _numa_all_cpus_ptr == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ It's important that we respect any user configuration by removing the\n+  \/\/ CPUs we're not allowed to run on from the affinity mask. For example,\n+  \/\/ if the user runs the JVM with \"numactl -C 0-1,4-5\" on a machine with\n+  \/\/ the following NUMA setup:\n+  \/\/ NUMA 0: CPUs 0-3, NUMA 1: CPUs 4-7\n+  \/\/ We expect to get the following affinity masks:\n+  \/\/ Affinity masks: idx 0 = (0, 1), idx 1 = (4, 5)\n+\n+  const int num_nodes = get_existing_num_nodes();\n+  const unsigned num_cpus = (unsigned)os::processor_count();\n+\n+  for (int i = 0; i < num_nodes; i++) {\n+    struct bitmask* affinity_mask = _numa_allocate_cpumask();\n+\n+    \/\/ Fill the affinity mask with all CPUs belonging to NUMA node i\n+    _numa_node_to_cpus_v2(i, affinity_mask);\n+\n+    \/\/ Clear the bits of all CPUs that the process is not allowed to\n+    \/\/ execute tasks on\n+    for (unsigned j = 0; j < num_cpus; j++) {\n+      if (!_numa_bitmask_isbitset(_numa_all_cpus_ptr, j)) {\n+        _numa_bitmask_clearbit(affinity_mask, j);\n+      }\n+    }\n+\n+    _numa_affinity_masks->push(affinity_mask);\n+  }\n+}\n+\n@@ -3358,0 +3412,19 @@\n+void os::Linux::numa_set_thread_affinity(pid_t tid, int node) {\n+  \/\/ We only set affinity if running libnuma v2 (_numa_sched_setaffinity\n+  \/\/ is available) and we have all affinity mask\n+  if (_numa_sched_setaffinity == nullptr ||\n+      _numa_all_cpus_ptr == nullptr ||\n+      _numa_affinity_masks->is_empty()) {\n+    return;\n+  }\n+\n+  if (node == -1) {\n+    \/\/ If the node is -1, the affinity is reverted to the original affinity\n+    \/\/ of the thread when the VM was started\n+    _numa_sched_setaffinity(tid, _numa_all_cpus_ptr);\n+  } else {\n+    \/\/ Normal case, set the affinity to the corresponding affinity mask\n+    _numa_sched_setaffinity(tid, _numa_affinity_masks->at(node));\n+  }\n+}\n+\n@@ -3367,0 +3440,1 @@\n+GrowableArray<struct bitmask*>* os::Linux::_numa_affinity_masks;\n@@ -3378,0 +3452,1 @@\n+os::Linux::numa_bitmask_clearbit_func_t os::Linux::_numa_bitmask_clearbit;\n@@ -3383,0 +3458,2 @@\n+os::Linux::numa_sched_setaffinity_func_t os::Linux::_numa_sched_setaffinity;\n+os::Linux::numa_allocate_cpumask_func_t os::Linux::_numa_allocate_cpumask;\n@@ -3389,0 +3466,1 @@\n+struct bitmask* os::Linux::_numa_all_cpus_ptr;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+  static GrowableArray<struct bitmask*>* _numa_affinity_masks;\n+\n+  static void build_numa_affinity_masks();\n+\n@@ -233,0 +237,1 @@\n+  typedef int (*numa_bitmask_clearbit_func_t)(struct bitmask *bmp, unsigned int n);\n@@ -235,0 +240,2 @@\n+  typedef int (*numa_sched_setaffinity_func_t)(pid_t pid, struct bitmask* mask);\n+  typedef struct bitmask* (*numa_allocate_cpumask_func_t)(void);\n@@ -247,0 +254,1 @@\n+  static numa_bitmask_clearbit_func_t _numa_bitmask_clearbit;\n@@ -254,0 +262,2 @@\n+  static numa_sched_setaffinity_func_t _numa_sched_setaffinity;\n+  static numa_allocate_cpumask_func_t _numa_allocate_cpumask;\n@@ -257,0 +267,1 @@\n+  static struct bitmask* _numa_all_cpus_ptr;\n@@ -272,0 +283,1 @@\n+  static void set_numa_bitmask_clearbit(numa_bitmask_clearbit_func_t func) { _numa_bitmask_clearbit = func; }\n@@ -282,0 +294,1 @@\n+  static void set_numa_all_cpus_ptr(struct bitmask **ptr) { _numa_all_cpus_ptr = (ptr == nullptr ? nullptr : *ptr); }\n@@ -285,0 +298,2 @@\n+  static void set_numa_sched_setaffinity(numa_sched_setaffinity_func_t func) { _numa_sched_setaffinity = func; }\n+  static void set_numa_allocate_cpumask(numa_allocate_cpumask_func_t func) { _numa_allocate_cpumask = func; }\n@@ -295,0 +310,2 @@\n+  static void numa_set_thread_affinity(pid_t tid, int node);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3755,0 +3755,1 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) { }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+  static void   numa_set_thread_affinity(Thread* thread, int node);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}