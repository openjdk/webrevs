{"files":[{"patch":"@@ -1750,0 +1750,3 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) {\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1584,0 +1584,3 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) {\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2967,0 +2967,4 @@\n+void os::numa_set_thread_affinity(Thread* thread, int node) {\n+  Linux::numa_set_thread_affinity(thread->osthread()->thread_id(), node);\n+}\n+\n@@ -3149,0 +3153,2 @@\n+      set_numa_bitmask_clearbit(CAST_TO_FN_PTR(numa_bitmask_clearbit_func_t,\n+                                               libnuma_dlsym(handle, \"numa_bitmask_clearbit\")));\n@@ -3163,0 +3169,4 @@\n+      set_numa_sched_setaffinity(CAST_TO_FN_PTR(numa_sched_setaffinity_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_sched_setaffinity\")));\n+      set_numa_allocate_cpumask(CAST_TO_FN_PTR(numa_allocate_cpumask_func_t,\n+                                               libnuma_v2_dlsym(handle, \"numa_allocate_cpumask\")));\n@@ -3168,0 +3178,1 @@\n+        set_numa_all_cpus_ptr((struct bitmask **)libnuma_dlsym(handle, \"numa_all_cpus_ptr\"));\n@@ -3171,0 +3182,1 @@\n+\n@@ -3174,0 +3186,1 @@\n+\n@@ -3177,0 +3190,5 @@\n+\n+        \/\/ Create a node -> CPUs mapping\n+        _numa_affinity_masks = new (mtInternal) GrowableArray<struct bitmask*>(0, mtInternal);\n+        build_numa_affinity_masks();\n+\n@@ -3212,0 +3230,31 @@\n+void os::Linux::build_numa_affinity_masks() {\n+  \/\/ We only build the affinity masks if running libnuma v2 (_numa_node_to_cpus_v2\n+  \/\/ is available) and we have the affinity mask of the process when it started.\n+  if (_numa_node_to_cpus_v2 == nullptr || _numa_all_cpus_ptr == nullptr) {\n+    return;\n+  }\n+\n+  const int num_nodes = get_existing_num_nodes();\n+  const unsigned num_cpus = (unsigned)os::processor_count();\n+\n+  for (int i = 0; i < num_nodes; i++) {\n+    struct bitmask* affinity_mask = _numa_allocate_cpumask();\n+    _numa_node_to_cpus_v2(i, affinity_mask);\n+\n+    \/\/ Make sure that the affinity mask are consistent with the original\n+    \/\/ affinity mask that the process was started with. For example, if the user\n+    \/\/ runs the JVM with \"numactl -C 0,1,2,3,4\" on a machine with the following\n+    \/\/ NUMA setup, we expect to get the following affinity masks:\n+    \/\/ NUMA 0: CPUs 0-3, NUMA 1: CPUs 4-7\n+    \/\/ Affinity masks: idx 0 = (0, 1), idx 1 = (4, 5)\n+    for (unsigned j = 0; j < num_cpus; j++) {\n+      if (_numa_bitmask_isbitset(affinity_mask, j) &&\n+          !_numa_bitmask_isbitset(_numa_all_cpus_ptr, j)) {\n+        _numa_bitmask_clearbit(affinity_mask, j);\n+      }\n+    }\n+\n+    _numa_affinity_masks->push(affinity_mask);\n+  }\n+}\n+\n@@ -3327,0 +3376,19 @@\n+void os::Linux::numa_set_thread_affinity(pid_t tid, int node) {\n+  \/\/ We only set affinity if running libnuma v2 (_numa_sched_setaffinity\n+  \/\/ is available) and we have all affinity mask\n+  if (_numa_sched_setaffinity == nullptr ||\n+      _numa_all_cpus_ptr == nullptr ||\n+      _numa_affinity_masks->is_empty()) {\n+    return;\n+  }\n+\n+  if (node == -1) {\n+    \/\/ If the node is -1, the affinity is reverted to the original affinity\n+    \/\/ of the thread when the VM was started\n+    _numa_sched_setaffinity(tid, _numa_all_cpus_ptr);\n+  } else {\n+    \/\/ Normal case, set the affinity to the corresponding affinity mask\n+    _numa_sched_setaffinity(tid, _numa_affinity_masks->at(node));\n+  }\n+}\n+\n@@ -3336,0 +3404,1 @@\n+GrowableArray<struct bitmask*>* os::Linux::_numa_affinity_masks;\n@@ -3347,0 +3416,1 @@\n+os::Linux::numa_bitmask_clearbit_func_t os::Linux::_numa_bitmask_clearbit;\n@@ -3352,0 +3422,2 @@\n+os::Linux::numa_sched_setaffinity_func_t os::Linux::_numa_sched_setaffinity;\n+os::Linux::numa_allocate_cpumask_func_t os::Linux::_numa_allocate_cpumask;\n@@ -3358,0 +3430,1 @@\n+struct bitmask* os::Linux::_numa_all_cpus_ptr;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+  static GrowableArray<struct bitmask*>* _numa_affinity_masks;\n+\n+  static void build_numa_affinity_masks();\n+\n@@ -235,0 +239,1 @@\n+  typedef int (*numa_bitmask_clearbit_func_t)(struct bitmask *bmp, unsigned int n);\n@@ -237,0 +242,2 @@\n+  typedef int (*numa_sched_setaffinity_func_t)(pid_t pid, struct bitmask* mask);\n+  typedef struct bitmask* (*numa_allocate_cpumask_func_t)(void);\n@@ -249,0 +256,1 @@\n+  static numa_bitmask_clearbit_func_t _numa_bitmask_clearbit;\n@@ -256,0 +264,2 @@\n+  static numa_sched_setaffinity_func_t _numa_sched_setaffinity;\n+  static numa_allocate_cpumask_func_t _numa_allocate_cpumask;\n@@ -259,0 +269,1 @@\n+  static struct bitmask* _numa_all_cpus_ptr;\n@@ -274,0 +285,1 @@\n+  static void set_numa_bitmask_clearbit(numa_bitmask_clearbit_func_t func) { _numa_bitmask_clearbit = func; }\n@@ -284,0 +296,1 @@\n+  static void set_numa_all_cpus_ptr(struct bitmask **ptr) { _numa_all_cpus_ptr = (ptr == nullptr ? nullptr : *ptr); }\n@@ -287,0 +300,2 @@\n+  static void set_numa_sched_setaffinity(numa_sched_setaffinity_func_t func) { _numa_sched_setaffinity = func; }\n+  static void set_numa_allocate_cpumask(numa_allocate_cpumask_func_t func) { _numa_allocate_cpumask = func; }\n@@ -297,0 +312,2 @@\n+  static void numa_set_thread_affinity(pid_t tid, int node);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3755,0 +3755,1 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) { }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+  static void   numa_set_thread_affinity(Thread* thread, int node);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}