{"files":[{"patch":"@@ -1174,0 +1174,19 @@\n+\n+  <Event name=\"JavaAgent\" category=\"Java Virtual Machine, Diagnostics\" label=\"Java Agent\" description=\"A Java programming language agent making use of the java.lang.instrument package for instrumenting programs running on the JVM\"\n+    thread=\"false\" startTime=\"false\" period=\"endChunk\" stackTrace=\"false\">\n+    <Field type=\"string\" name=\"name\" label=\"Name\" \/>\n+    <Field type=\"string\" name=\"options\" label=\"Options\" \/>\n+    <Field type=\"Ticks\" name=\"initialization\" label=\"Initialization\" description=\"The time the initialization method exported by the agent was invoked by the JVM\" \/>\n+    <Field type=\"Tickspan\" name=\"initializationTime\" label=\"Initialization Time\" description=\"The duration of executing the initialization method exported by the agent\" \/>\n+    <Field type=\"string\" name=\"initializationMethod\" label=\"Initialization Method\" description=\"The initialization method exported by the agent and invoked by the JVM\" \/>\n+  <\/Event>\n+\n+  <Event name=\"NativeAgent\" category=\"Java Virtual Machine, Diagnostics\" label=\"Native Agent\" description=\"A native programming language agent making use of the JVMTI or JVMPI interfaces used by development and monitoring tools\"\n+    thread=\"false\" startTime=\"false\" period=\"endChunk\" stackTrace=\"false\">\n+    <Field type=\"string\" name=\"name\" label=\"Name\" \/>\n+    <Field type=\"string\" name=\"options\" label=\"Options\" \/>\n+    <Field type=\"string\" name=\"path\" label=\"Path\" description=\"The path of the library\" \/>\n+    <Field type=\"boolean\" name=\"dynamic\" label=\"Dynamic\" description=\"If the library attached to the JVM dynamically during runtime, i.e. not at startup\" \/>\n+    <Field type=\"Ticks\" name=\"initialization\" label=\"Initialization\" description=\"The time the JVM initialized the agent\" \/>\n+    <Field type=\"Tickspan\" name=\"initializationTime\" label=\"Initialization Time\" description=\"The duration of executing the initialization function exported by the agent\" \/>\n+  <\/Event>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -272,0 +273,38 @@\n+template <typename AgentEvent>\n+static void send_agent_event(AgentEvent& event, const Agent* agent) {\n+  event.set_name(agent->name());\n+  event.set_options(agent->options());\n+  event.set_initialization(agent->initialization());\n+  event.set_initializationTime(agent->initialization_time());\n+  event.commit();\n+}\n+\n+TRACE_REQUEST_FUNC(JavaAgent) {\n+  const AgentList::Iterator it = AgentList::java_agents();\n+  while (it.has_next()) {\n+    const Agent* agent = it.next();\n+    assert(agent->is_jplis(), \"invariant\");\n+    EventJavaAgent event;\n+    event.set_initializationMethod(agent->is_dynamic() ? \"agentmain\" : \"premain\");\n+    send_agent_event(event, agent);\n+  }\n+}\n+\n+static void send_native_agent_events(const AgentList::Iterator& it) {\n+  while (it.has_next()) {\n+    const Agent* agent = it.next();\n+    assert(!agent->is_jplis(), \"invariant\");\n+    EventNativeAgent event;\n+    event.set_dynamic(agent->is_dynamic());\n+    event.set_path(agent->os_lib_path());\n+    send_agent_event(event, agent);\n+  }\n+}\n+\n+TRACE_REQUEST_FUNC(NativeAgent) {\n+  const AgentList::Iterator native_agents_it = AgentList::native_agents();\n+  send_native_agent_events(native_agents_it);\n+  const AgentList::Iterator xrun_agents_it = AgentList::xrun_agents();\n+  send_native_agent_events(xrun_agents_it);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/agent.hpp\"\n+\n+#include \"jvm_io.h\"\n+#include \"runtime\/os.inline.hpp\"\n+\n+\/*\n+  * The implementation builds a mapping bewteen JVMTI envs and JPLIS agents,\n+  * using internal JDK implementation knowledge about the way JPLIS agents\n+  * store data in their JvmtiEnv local storage.\n+  *\n+  * Please see JPLISAgent.c in module java.instrument:\n+  *\n+  * jvmtierror = (*jvmtienv)->SetEnvironmentLocalStorage( jvmtienv, &(agent->mNormalEnvironment));\n+  *\n+  * It is the pointer to the field agent->mNormalEnvironment that is stored in the jvmtiEnv local storage.\n+  *\n+  * These are some types used in the JDK, java.instrument, see JPLISAgent.h and JPLISAgent.c\n+  *\n+  * struct _JPLISEnvironment {\n+  *   jvmtiEnv*   mJVMTIEnv;              \/\/ the JVM TI environment\n+  *   JPLISAgent* mAgent;                 \/\/ corresponding agent\n+  *   jboolean    mIsRetransformer;       \/\/ indicates if special environment\n+  * };\n+  *\n+  * struct _JPLISAgent {\n+  *   JavaVM*                 mJVM;                   \/\/ handle to the JVM\n+  *   JPLISEnvironment        mNormalEnvironment;     \/\/ for every thing but retransform stuff\n+  *   JPLISEnvironment        mRetransformEnvironment;\/\/ for retransform stuff only\n+  *   jobject                 mInstrumentationImpl;   \/\/ handle to the Instrumentation instance\n+  *   jmethodID               mPremainCaller;         \/\/ method on the InstrumentationImpl that does the premain stuff (cached to save lots of lookups)\n+  *   jmethodID               mAgentmainCaller;       \/\/ method on the InstrumentationImpl for agents loaded via attach mechanism\n+  *   jmethodID               mTransform;             \/\/ method on the InstrumentationImpl that does the class file transform\n+  *   jboolean                mRedefineAvailable;     \/\/ cached answer to \"does this agent support redefine\"\n+  *   jboolean                mRedefineAdded;         \/\/ indicates if can_redefine_classes capability has been added\n+  *   jboolean                mNativeMethodPrefixAvailable; \/\/ cached answer to \"does this agent support prefixing\"\n+  *   jboolean                mNativeMethodPrefixAdded;     \/\/\/ indicates if can_set_native_method_prefix capability has been added\n+  *   char const* mAgentClassName; \/\/ agent class name\n+  *   char const* mOptionsString;  \/\/ -javaagent options string\n+  *   const char* mJarfile;        \/\/ agent jar file name\n+  * };\n+  *\n+  * To read the JPLISAgent specfic data stored in the JvmtiEnv local storage, we model two mirror structs:\n+  *\n+  * struct JPLISEnvirommentMirror {\n+  *   jvmtiEnv* mJVMTIEnv;         \/\/ the JVM TI environment\n+  *   JPLISAgentMirror* mAgent;   \/\/ corresponding agent\n+  *   jboolean  mIsRetransformer;  \/\/ indicates if special environment\n+  * };\n+  *\n+  * Declared in agent.hpp. JPLISAgentMirror is declared here, in agent.cpp.\n+  *\n+  *\/\n+struct JPLISAgentMirror {\n+  JavaVM* mJVM;                   \/\/ handle to the JVM\n+  JPLISEnvironmentMirror mNormalEnvironment;     \/\/ for every thing but retransform stuff\n+  JPLISEnvironmentMirror mRetransformEnvironment;\/\/ for retransform stuff only\n+  jobject mInstrumentationImpl;   \/\/ handle to the Instrumentation instance\n+  jmethodID mPremainCaller;         \/\/ method on the InstrumentationImpl that does the premain stuff (cached to save lots of lookups)\n+  jmethodID mAgentmainCaller;       \/\/ method on the InstrumentationImpl for agents loaded via attach mechanism\n+  jmethodID mTransform;             \/\/ method on the InstrumentationImpl that does the class file transform\n+  jboolean  mRedefineAvailable;     \/\/ cached answer to \"does this agent support redefine\"\n+  jboolean  mRedefineAdded;         \/\/ indicates if can_redefine_classes capability has been added\n+  jboolean  mNativeMethodPrefixAvailable; \/\/ cached answer to \"does this agent support prefixing\"\n+  jboolean mNativeMethodPrefixAdded;     \/\/\/ indicates if can_set_native_method_prefix capability has been added\n+  char const* mAgentClassName; \/\/ agent class name\n+  char const* mOptionsString;  \/\/ -javaagent options string\n+  const char* mJarfile;        \/\/ agent jar file name\n+};\n+\n+static void free_string(const char* str) {\n+  assert(str != nullptr, \"invariant\");\n+  FreeHeap(const_cast<char*>(str));\n+}\n+\n+static const char* allocate_copy(const char* str) {\n+  if (str == nullptr) {\n+    return nullptr;\n+  }\n+  const size_t length = strlen(str);\n+  char* copy = AllocateHeap(length + 1, mtInternal);\n+  strncpy(copy, str, length + 1);\n+  assert(strncmp(copy, str, length + 1) == 0, \"invariant\");\n+  return copy;\n+}\n+\n+\/\/ returns the lhs before '=', parsed_options output param gets the rhs.\n+static const char* split_options_and_allocate_copy(const char* options, const char** parsed_options) {\n+  assert(options != nullptr, \"invariant\");\n+  assert(parsed_options != nullptr, \"invariant\");\n+  const char* const equal_sign = strchr(options, '=');\n+  const size_t length = strlen(options);\n+  size_t name_length = length;\n+  if (equal_sign != nullptr) {\n+    name_length = equal_sign - options;\n+    const size_t options_length = length - name_length - 1;\n+    *parsed_options = allocate_copy(equal_sign + 1);\n+  } else {\n+    *parsed_options = nullptr;\n+    name_length = length;\n+  }\n+  char* const name = AllocateHeap(name_length + 1, mtInternal);\n+  jio_snprintf(name, name_length + 1, \"%s\", options);\n+  assert(strncmp(name, options, name_length) == 0, \"invariant\");\n+  return name;\n+}\n+\n+Agent::Agent(const char* name, const char* options, bool is_absolute_path) :\n+  _init(),\n+  _init_time(),\n+  _next(nullptr),\n+  _name(allocate_copy(name)),\n+  _options(allocate_copy(options)),\n+  _os_lib(nullptr),\n+  _os_lib_path(nullptr),\n+  _jplis(nullptr),\n+  _valid(false),\n+  _is_absolute_path(is_absolute_path),\n+  _is_static_lib(false),\n+  _is_dynamic(false),\n+  _is_instrument_lib(strcmp(name, \"instrument\") == 0),\n+  _is_xrun(false) {}\n+\n+Agent* Agent::next() const {\n+  return _next;\n+}\n+\n+const char* Agent::name() const {\n+  return _name;\n+}\n+\n+const char* Agent::options() const {\n+  return _options;\n+}\n+\n+bool Agent::is_absolute_path() const {\n+  return _is_absolute_path;\n+}\n+\n+void* Agent::os_lib() const {\n+  return _os_lib;\n+}\n+\n+void Agent::set_os_lib(void* os_lib) {\n+  _os_lib = os_lib;\n+}\n+\n+void Agent::set_os_lib_path(const char* path) {\n+  assert(path != nullptr, \"invariant\");\n+  assert(_os_lib_path == nullptr, \"invariant\");\n+  _os_lib_path = allocate_copy(path);\n+}\n+\n+const char* Agent::os_lib_path() const {\n+  return _os_lib_path;\n+}\n+\n+bool Agent::is_static_lib() const {\n+  return _is_static_lib;\n+}\n+\n+void Agent::set_static_lib() {\n+  _is_static_lib = true;\n+}\n+\n+bool Agent::is_dynamic() const {\n+  return _is_dynamic;\n+}\n+\n+bool Agent:: is_instrument_lib() const {\n+  return _is_instrument_lib;\n+}\n+\n+bool Agent::is_valid() const {\n+  return _valid;\n+}\n+\n+void Agent::set_valid() {\n+  _valid = true;\n+}\n+\n+const Ticks& Agent::initialization() const {\n+  return _init;\n+}\n+\n+const Tickspan& Agent::initialization_time() const {\n+  return _init_time;\n+}\n+\n+void Agent::set_jplis(const JPLISAgentMirror* jplis) {\n+  assert(jplis != nullptr, \"invaiant\");\n+  assert(is_instrument_lib(), \"invariant\");\n+  assert(_jplis == nullptr, \"invariant\");\n+  if (_options != nullptr) {\n+    \/\/ For JPLIS agents, update with the java name and options.\n+    free_string(_name);\n+    const char* options = _options;\n+    _name = split_options_and_allocate_copy(options, &_options);\n+    free_string(options);\n+  }\n+  _jplis = jplis;\n+}\n+\n+bool Agent::is_jplis() const {\n+  return _jplis != nullptr;\n+}\n+\n+bool Agent::is_jplis(const JPLISAgentMirror* jplis) const {\n+  assert(jplis != nullptr, \"invariant\");\n+  assert(is_instrument_lib(), \"invariant\");\n+  return jplis == _jplis;\n+}\n+\n+bool Agent::is_timestamped() const {\n+  return _init.value() != 0;\n+}\n+\n+void Agent::timestamp() {\n+  assert(_init.value() == 0, \"invariant\");\n+  _init = Ticks::now();\n+}\n+\n+void Agent::initialization_begin() {\n+  timestamp();\n+}\n+\n+void Agent::initialization_end() {\n+  assert(is_timestamped(), \"invariant\");\n+  assert(_init_time.value() == 0, \"invariant\");\n+  _init_time = Ticks::now() - initialization();\n+}\n","filename":"src\/hotspot\/share\/prims\/agent.cpp","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_PRIMS_AGENT_HPP\n+#define SHARE_PRIMS_AGENT_HPP\n+\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+struct JPLISAgentMirror;\n+\n+struct JPLISEnvironmentMirror {\n+  jvmtiEnv* mJVMTIEnv;         \/\/ the JVMTI environment\n+  JPLISAgentMirror* mAgent;    \/\/ corresponding agent\n+  jboolean  mIsRetransformer;  \/\/ indicates if special environment\n+};\n+\n+\/\/ For use by -agentlib, -agentpath and -Xrun\n+\/\/ The terminology classifies -agentlib and -agentpath as \"JVMTI agents\".\n+\/\/ -Xrun are classified as \"xrun agents\" (JVMPI)\n+class Agent : public CHeapObj<mtServiceability> {\n+  friend class AgentList;\n+ private:\n+  Ticks _init;\n+  Tickspan _init_time;\n+  Agent* _next;\n+  const char* _name;\n+  const char* _options;\n+  void* _os_lib;\n+  const char* _os_lib_path;\n+  const JPLISAgentMirror* _jplis;\n+  bool _valid;\n+  bool _is_absolute_path;\n+  bool _is_static_lib;\n+  bool _is_dynamic;\n+  bool _is_instrument_lib;\n+  bool _is_xrun;\n+\n+  Agent* next() const;\n+  void set_jplis(const JPLISAgentMirror* jplis);\n+\n+ public:\n+  const char* name() const;\n+  const char* options() const;\n+  bool is_absolute_path() const;\n+  void* os_lib() const;\n+  void set_os_lib(void* os_lib);\n+  void set_os_lib_path(const char* path);\n+  const char* os_lib_path() const;\n+  bool is_static_lib() const;\n+  void set_static_lib();\n+  bool is_dynamic() const;\n+  bool is_instrument_lib() const;\n+  bool is_valid() const;\n+  void set_valid();\n+  const Ticks& initialization() const;\n+  const Tickspan& initialization_time() const;\n+  bool is_jplis() const;\n+  bool is_jplis(const JPLISAgentMirror* jplis) const;\n+  bool is_timestamped() const;\n+  void timestamp();\n+  void initialization_begin();\n+  void initialization_end();\n+  Agent(const char* name, const char* options, bool is_absolute_path);\n+};\n+\n+#endif \/\/ SHARE_PRIMS_AGENT_HPP\n","filename":"src\/hotspot\/share\/prims\/agent.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,619 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/agentList.hpp\"\n+\n+#include \"cds\/cds_globals.hpp\"\n+#include \"jni.h\"\n+#include \"prims\/jvmtiEnvBase.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+Agent* AgentList::_list = nullptr;\n+\n+static inline Agent* head(Agent** list) {\n+  assert(list != nullptr, \"invariant\");\n+  return Atomic::load_acquire(list);\n+}\n+\n+void AgentList::add(Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  Agent* next;\n+  do {\n+    next = head(&_list);\n+    agent->_next = next;\n+  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n+}\n+\n+void AgentList::add(const char* name, char* options, bool absolute_path) {\n+  add(new Agent(name, options, absolute_path));\n+}\n+\n+void AgentList::add_xrun(const char* name, char* options, bool absolute_path) {\n+  Agent* agent = new Agent(name, options, absolute_path);\n+  agent->_is_xrun = true;\n+  add(agent);\n+}\n+\n+Agent* AgentList::Iterator::filter(Agent* agent) const {\n+  while (agent != nullptr) {\n+    if (_type == JVMTI) {\n+      if (!agent->_is_xrun) {\n+        return agent;\n+      }\n+    }\n+    if (_type == JAVA) {\n+      assert(!agent->_is_xrun, \"invariant\");\n+      if (agent->is_jplis()) {\n+        return agent;\n+      }\n+    } else if (_type == NATIVE) {\n+        if (!agent->is_jplis() && !agent->_is_xrun) {\n+          return agent;\n+        }\n+    } else {\n+      assert(_type == XRUN, \"invariant\");\n+      if (agent->_is_xrun) {\n+        return agent;\n+      }\n+    }\n+    agent = agent->_next;\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ The storage list is a single cas-linked-list, to allow for concurrent iterations. Especially during initial loading of agents,\n+\/\/ there exist an order requirement to iterate oldest -> newest. Our concurrent storage linked-list is newest -> oldest.\n+\/\/ The correct order is preserved by the iterator, by storing a filtered set of entries in a stack.\n+AgentList::Iterator::Iterator(Agent** list, Type type) : _stack(new GrowableArrayCHeap<Agent*, mtServiceability>(16)), _type(type) {\n+  Agent* next = head(list);\n+  while (next != nullptr) {\n+    next = filter(next);\n+    if (next != nullptr) {\n+      _stack->push(next);\n+      next = next->_next;\n+    }\n+  }\n+}\n+\n+AgentList::Iterator::~Iterator() {\n+  delete _stack;\n+}\n+\n+bool AgentList::Iterator::has_next() const {\n+  assert(_stack != nullptr, \"invariant\");\n+  return _stack->is_nonempty();\n+}\n+\n+const Agent* AgentList::Iterator::next() const {\n+  assert(has_next(), \"invariant\");\n+  return _stack->pop();\n+}\n+\n+Agent* AgentList::Iterator::next() {\n+  return const_cast<Agent*>(const_cast<const Iterator*>(this)->next());\n+}\n+\n+AgentList::Iterator AgentList::agents() {\n+  return Iterator(&_list, Iterator::JVMTI);\n+}\n+\n+AgentList::Iterator AgentList::java_agents() {\n+  return Iterator(&_list, Iterator::JAVA);\n+}\n+\n+AgentList::Iterator AgentList::native_agents() {\n+  return Iterator(&_list, Iterator::NATIVE);\n+}\n+\n+AgentList::Iterator AgentList::xrun_agents() {\n+  return Iterator(&_list, Iterator::XRUN);\n+}\n+\n+static inline void timestamp_agents(AgentList::Iterator& it) {\n+  while (it.has_next()) {\n+    Agent* agent = it.next();\n+    if (!agent->is_timestamped()) {\n+      agent->timestamp();\n+    }\n+  }\n+}\n+\n+void AgentList::timestamp() {\n+  Iterator xrun_it = xrun_agents();\n+  timestamp_agents(xrun_it);\n+  \/\/ In case a JVMTI agent did not enable the VMInit callback, it gets a timestamp here.\n+  Iterator agent_it = agents();\n+  timestamp_agents(agent_it);\n+}\n+\n+static const char* not_found_error_msg = \"Could not find agent library \";\n+static const char* missing_module_error_msg = \"\\nModule java.instrument may be missing from runtime image.\";\n+static char ebuf[1024];\n+static char buffer[JVM_MAXPATHLEN];\n+\n+static void vm_exit(const Agent* agent, const char* sub_msg1, const char* sub_msg2) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(sub_msg1 != nullptr, \"invariant\");\n+  assert(!agent->is_instrument_lib() || sub_msg2 != nullptr, \"invariant\");\n+  const size_t len = strlen(not_found_error_msg) + strlen(agent->name()) + strlen(sub_msg1) + strlen(&ebuf[0]) + 1 + (agent->is_instrument_lib() ? strlen(sub_msg2) : 0);\n+  char* buf = NEW_C_HEAP_ARRAY(char, len, mtInternal);\n+  if (agent->is_instrument_lib()) {\n+    jio_snprintf(buf, len, \"%s%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0], sub_msg2);\n+  } else {\n+    jio_snprintf(buf, len, \"%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0]);\n+  }\n+  vm_exit_during_initialization(buf, nullptr);\n+  FREE_C_HEAP_ARRAY(char, buf);\n+}\n+\n+static void* load_agent_from_executable(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_valid(), \"invariant\");\n+  assert(on_load_symbols != nullptr, \"invariant\");\n+  return os::find_builtin_agent(agent, &on_load_symbols[0], num_symbol_entries) ? agent->os_lib() : nullptr;\n+}\n+\n+static void* load_agent_from_absolute_path(Agent* agent, bool vm_exit_on_error) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_valid(), \"invariant\");\n+  assert(agent->is_absolute_path(), \"invariant\");\n+  assert(!agent->is_instrument_lib(), \"invariant\");\n+  void* const library = os::dll_load(agent->name(), &ebuf[0], sizeof ebuf);\n+  if (library == nullptr && vm_exit_on_error) {\n+    vm_exit(agent, \" in absolute path, with error: \", nullptr);\n+  }\n+  return library;\n+}\n+\n+static void* load_agent_from_relative_path(Agent* agent, bool vm_exit_on_error) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_valid(), \"invariant\");\n+  assert(!agent->is_absolute_path(), \"invariant\");\n+  const char* const name = agent->name();\n+  void* library = nullptr;\n+  \/\/ Try to load the agent from the standard dll directory\n+  if (os::dll_locate_lib(&buffer[0], sizeof buffer, Arguments::get_dll_dir(), name)) {\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+  }\n+  if (library == nullptr && os::dll_build_name(&buffer[0], sizeof buffer, name)) {\n+    \/\/ Try the library path directory.\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+    if (library != nullptr) {\n+      return library;\n+    }\n+    if (vm_exit_on_error) {\n+      vm_exit(agent, \" on the library path, with error: \", missing_module_error_msg);\n+    }\n+  }\n+  return library;\n+}\n+\n+\/\/ The newest jvmtiEnvs are appended to the list, JvmtiEnvIterator order is from oldest to newest.\n+static JvmtiEnv* get_last_jplis_jvmtienv() {\n+  JvmtiEnvIterator it;\n+  JvmtiEnv* env = it.first();\n+  assert(env != nullptr, \"invariant\");\n+  JvmtiEnv* next = it.next(env);\n+  while (next != nullptr) {\n+    assert(env != nullptr, \"invariant\");\n+    \/\/ get_env_local_storage() lets us find which JVMTI env map to which JPLIS agent.\n+    if (next->get_env_local_storage() == nullptr) {\n+      JvmtiEnv* temp = it.next(next);\n+      if (temp != nullptr) {\n+        next = temp;\n+        continue;\n+      }\n+      break;\n+    }\n+    env = next;\n+    next = it.next(env);\n+  }\n+  assert(env != nullptr, \"invariant\");\n+  assert(env->get_env_local_storage() != nullptr, \"invariant\");\n+  return env;\n+}\n+\n+\/\/ Link the last, or most recent jvmtiEnv. that is a JPLIS agent, with the current agent.\n+void AgentList::link_jplis(Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_instrument_lib(), \"invariant\");\n+  JvmtiEnv* const env = get_last_jplis_jvmtienv();\n+  assert(env != nullptr, \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = reinterpret_cast<const JPLISEnvironmentMirror*>(env->get_env_local_storage());\n+  assert(jplis_env != nullptr, \"invaiant\");\n+  assert(reinterpret_cast<JvmtiEnv*>(jplis_env->mJVMTIEnv) == env, \"invariant\");\n+  agent->set_jplis(jplis_env->mAgent);\n+}\n+\n+\/\/ CDS dumping does not support native JVMTI agent.\n+\/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n+static void check_cds_dump(Agent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(Arguments::is_dumping_archive(), \"invariant\");\n+  if (!agent->is_instrument_lib()) {\n+    vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n+  }\n+  if (!AllowArchivingWithJavaAgent) {\n+    vm_exit_during_cds_dumping(\n+      \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n+  }\n+}\n+\n+\/\/ type for the Agent_OnLoad and JVM_OnLoad entry points\n+extern \"C\" {\n+  typedef jint(JNICALL* OnLoadEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Find the OnLoad entry point for -agentlib:  -agentpath:   -Xrun agents.\n+\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n+static OnLoadEntry_t lookup_On_Load_entry_point(Agent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  assert(agent != nullptr, \"invariant\");\n+  if (!agent->is_valid()) {\n+    \/\/ First check to see if agent is statically linked into executable.\n+    void* library = load_agent_from_executable(agent, on_load_symbols, num_symbol_entries);\n+    if (library == nullptr) {\n+      library = agent->is_absolute_path() ? load_agent_from_absolute_path(agent, true) : load_agent_from_relative_path(agent, true);\n+    }\n+    assert(library != nullptr, \"invariant\");\n+    agent->set_os_lib(library);\n+    agent->set_valid();\n+  }\n+  assert(agent->is_valid(), \"invariant\");\n+  assert(agent->os_lib() != nullptr, \"invariant\");\n+\n+  \/\/ Find the OnLoad function.\n+  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbols, num_symbol_entries));\n+}\n+\n+static OnLoadEntry_t lookup_JVM_OnLoad_entry_point(Agent* lib) {\n+  const char* on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(lib, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+static OnLoadEntry_t lookup_Agent_OnLoad_entry_point(Agent* agent) {\n+  const char* on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+\/\/ For backwards compatibility with -Xrun, convert Xrun agents with no JVM_OnLoad,\n+\/\/ but which have an Agent_OnLoad, to be treated like -agentpath (JVMTI agents)\n+void AgentList::promote_xrun_to_jvmti() {\n+  Iterator it = xrun_agents();\n+  while (it.has_next()) {\n+    Agent* const agent = it.next();\n+    assert(agent->_is_xrun, \"invariant\");\n+    OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n+    \/\/ If there is an JVM_OnLoad function it will get called later,\n+    \/\/ otherwise see if there is an Agent_OnLoad.\n+    if (on_load_entry == nullptr) {\n+      vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", agent->name());\n+    }\n+    agent->_is_xrun = false; \/\/ promoted\n+  }\n+}\n+\n+\/\/ Invokes Agent_OnLoad for -agentlib:.. -agentpath:  and converted \/ promoted -Xrun agents.\n+\/\/ Called very early -- before JavaThreads exist\n+void AgentList::load_agents() {\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  extern struct JavaVM_ main_vm;\n+\n+  \/\/ Promote -Xrun to -agentlib: if there is no JVM_OnLoad\n+  promote_xrun_to_jvmti();\n+\n+  JvmtiExport::enter_onload_phase();\n+\n+  Iterator it = agents();\n+  while (it.has_next()) {\n+    Agent* agent = it.next();\n+    if (Arguments::is_dumping_archive()) {\n+      check_cds_dump(agent);\n+    }\n+\n+    OnLoadEntry_t on_load_entry = lookup_Agent_OnLoad_entry_point(agent);\n+\n+    if (on_load_entry == nullptr) {\n+      vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n+    }\n+    \/\/ Invoke the Agent_OnLoad function\n+    if ((*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr) != JNI_OK) {\n+      vm_exit_during_initialization(\"agent library failed Agent_OnLoad\", agent->name());\n+    }\n+\n+    \/\/ Resolve the instrument libs to the actual JPLIS \/ javaagent it represents.\n+    if (agent->is_instrument_lib()) {\n+      link_jplis(agent);\n+    }\n+  }\n+\n+  JvmtiExport::enter_primordial_phase();\n+}\n+\n+extern \"C\" {\n+  typedef void (JNICALL* Agent_OnUnload_t)(JavaVM*);\n+}\n+\n+\/\/ Called after the VM is initialized for -Xrun agents which have not been converted to JVMTI agents\n+void AgentList::invoke_JVM_OnLoad() {\n+  extern struct JavaVM_ main_vm;\n+  Iterator it = xrun_agents();\n+  while (it.has_next()) {\n+    Agent* agent = it.next();\n+    assert(agent->_is_xrun, \"invariant\");\n+    OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n+    if (on_load_entry == nullptr) {\n+      vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n+    }\n+    \/\/ Invoke the JVM_OnLoad function\n+    JavaThread* thread = JavaThread::current();\n+    ThreadToNativeFromVM ttn(thread);\n+    HandleMark hm(thread);\n+    const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), NULL);\n+    if (err != JNI_OK) {\n+      vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n+    }\n+  }\n+}\n+\n+\/\/ Launch -Xrun agents eagerly at startup.\n+void AgentList::load_xrun_agents_at_startup() {\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  assert(EagerXrunInit, \"invariant\");\n+  invoke_JVM_OnLoad();\n+}\n+\n+\/\/ Launch -Xrun agents\n+void AgentList::load_xrun_agents() {\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  assert(!EagerXrunInit, \"invariant\");\n+  invoke_JVM_OnLoad();\n+}\n+\n+\/\/ Use this for JavaThreads and state is  _thread_in_vm.\n+class AgentJavaThreadEventTransition : StackObj {\n+ private:\n+  ResourceMark _rm;\n+  ThreadToNativeFromVM _transition;\n+  HandleMark _hm;\n+ public:\n+  AgentJavaThreadEventTransition(JavaThread* thread) : _rm(), _transition(thread), _hm(thread) {};\n+};\n+\n+class AgentEventMark : public StackObj {\n+ private:\n+  JavaThread* _thread;\n+  JNIEnv* _jni_env;\n+  JvmtiThreadState::ExceptionState _saved_exception_state;\n+\n+ public:\n+  AgentEventMark(JavaThread* thread) : _thread(thread),\n+    _jni_env(thread->jni_environment()),\n+    _saved_exception_state(JvmtiThreadState::ES_CLEARED) {\n+    JvmtiThreadState* state = thread->jvmti_thread_state();\n+    \/\/ we are before an event.\n+    \/\/ Save current jvmti thread exception state.\n+    if (state != NULL) {\n+      _saved_exception_state = state->get_exception_state();\n+    }\n+    thread->push_jni_handle_block();\n+    assert(thread == JavaThread::current(), \"thread must be current!\");\n+    thread->frame_anchor()->make_walkable();\n+  }\n+\n+  ~AgentEventMark() {\n+    _thread->pop_jni_handle_block();\n+    JvmtiThreadState* state = _thread->jvmti_thread_state();\n+    \/\/ we are continuing after an event.\n+    if (state != NULL) {\n+      \/\/ Restore the jvmti thread exception state.\n+      state->restore_exception_state(_saved_exception_state);\n+    }\n+  }\n+};\n+\n+class AgentThreadEventMark : public AgentEventMark {\n+ private:\n+  jobject _jthread;\n+ public:\n+  AgentThreadEventMark(JavaThread* thread) : AgentEventMark(thread) {\n+    _jthread = JNIHandles::make_local(thread, thread->threadObj());\n+  };\n+  jthread jni_thread() { return (jthread)_jthread; }\n+};\n+\n+static void unload_and_delete(Agent* agent, void* library) {\n+  assert(agent != nullptr, \"invariant\");\n+  if (!agent->is_static_lib()) {\n+    os::dll_unload(library);\n+  }\n+  delete agent;\n+}\n+\n+\/\/ type for the Agent_OnAttach entry point\n+extern \"C\" {\n+  typedef jint(JNICALL* OnAttachEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Implementation for loading an agent dynamically during runtime, by invoking Agent_OnAttach.\n+jint AgentList::load_agent(const char* agent_name, const char* absParam,\n+                                  const char* options, outputStream* st) {\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"not in live phase!\");\n+  const char* on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n+  const size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n+\n+  \/\/ The abs parameter should be \"true\" or \"false\"\n+  const bool is_absolute_path = (absParam != nullptr) && (strcmp(absParam, \"true\") == 0);\n+  \/\/ Initially marked as invalid. It will be set to valid if we can find the agent\n+  Agent* agent = new Agent(agent_name, options, is_absolute_path);\n+  agent->_is_dynamic = true;\n+\n+  \/\/ Check for statically linked in agent. If not found then if the path is\n+  \/\/ absolute we attempt to load the library. Otherwise we try to load it from the standard dll directory.\n+  void* library = load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries);\n+  if (library == nullptr) {\n+    library = agent->is_absolute_path() ? load_agent_from_absolute_path(agent, \/* vm exit on error *\/ false) :\n+                                          load_agent_from_relative_path(agent, \/* vm exit on error *\/ false);\n+  }\n+  if (library != nullptr) {\n+    agent->set_os_lib_path(&buffer[0]);\n+    agent->set_os_lib(library);\n+    agent->set_valid();\n+  } else {\n+    st->print_cr(\"%s was not loaded.\", agent_name);\n+    if (*ebuf != '\\0') {\n+      st->print_cr(\"%s\", ebuf);\n+    }\n+    return JNI_ERR;\n+  }\n+\n+  assert(library != nullptr, \"invariant\");\n+  assert(agent->is_valid(), \"invariant\");\n+\n+  \/\/ The library was loaded so we attempt to lookup and invoke the Agent_OnAttach function\n+  OnAttachEntry_t on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n+                                                   os::find_agent_function(agent, false, &on_attach_symbols[0], num_symbol_entries));\n+\n+  if (on_attach_entry == nullptr) {\n+    \/\/ Agent_OnAttach missing - unload library\n+    unload_and_delete(agent, library);\n+    st->print_cr(\"%s is not available in %s\", on_attach_symbols[0], agent->name());\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Invoke the Agent_OnAttach function\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+  jint result = JNI_ERR;\n+  {\n+    extern struct JavaVM_ main_vm;\n+    AgentThreadEventMark jem(THREAD);\n+    AgentJavaThreadEventTransition jet(THREAD);\n+\n+    agent->initialization_begin();\n+\n+    result = (*on_attach_entry)(&main_vm, (char*)options, NULL);\n+\n+    agent->initialization_end();\n+\n+    \/\/ Agent_OnAttach may have used JNI\n+    if (THREAD->is_pending_jni_exception_check()) {\n+      THREAD->clear_pending_jni_exception_check();\n+    }\n+  }\n+\n+  \/\/ Agent_OnAttach may have used JNI\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+  }\n+\n+  if (result == JNI_OK) {\n+    if (agent->is_instrument_lib()) {\n+      \/\/ If this is a JPLIS agent, link it to its JVMTI env.\n+      link_jplis(agent);\n+    }\n+    \/\/ If OnAttach returns JNI_OK then we add it to the list of\n+    \/\/ agents so that we can iterate over it and call Agent_OnUnload later.\n+    add(agent);\n+  } else {\n+    unload_and_delete(agent, library);\n+  }\n+  st->print_cr(\"return code: %d\", result);\n+  \/\/ Agent_OnAttach executed so completion status is JNI_OK\n+  return JNI_OK;\n+}\n+\n+\/\/ Send any Agent_OnUnload notifications\n+void AgentList::unload_agents() {\n+  extern struct JavaVM_ main_vm;\n+  const char* on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n+  size_t num_symbol_entries = ARRAY_SIZE(on_unload_symbols);\n+  Iterator it = agents();\n+  while (it.has_next()) {\n+    Agent* agent = it.next();\n+    \/\/ Find the Agent_OnUnload function.\n+    Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n+                                                   os::find_agent_function(agent,\n+                                                   false,\n+                                                   &on_unload_symbols[0],\n+                                                   num_symbol_entries));\n+    \/\/ Invoke the Agent_OnUnload function\n+    if (unload_entry != nullptr) {\n+      JavaThread* thread = JavaThread::current();\n+      ThreadToNativeFromVM ttn(thread);\n+      HandleMark hm(thread);\n+      (*unload_entry)(&main_vm);\n+    }\n+  }\n+}\n+\n+static bool is_env_jplis_agent(JvmtiEnv* env, const Agent* agent) {\n+  assert(env != nullptr, \"invariant\");\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_instrument_lib(), \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = reinterpret_cast<const JPLISEnvironmentMirror*>(env->get_env_local_storage());\n+  return jplis_env != nullptr ? agent->is_jplis(jplis_env->mAgent) : false;\n+}\n+\n+static bool match(JvmtiEnv* env, const Agent* agent, const void* os_module_address) {\n+  assert(env != nullptr, \"invariant\");\n+  assert(agent != nullptr, \"invariant\");\n+  if (agent->os_lib() != os_module_address) {\n+    return false;\n+  }\n+  return agent->is_instrument_lib() ? is_env_jplis_agent(env, agent) : true;\n+}\n+\n+\/\/ The function pointer is a JVMTI callback function.\n+\/\/ Find the os module (dll) that exports this function.\n+\/\/ Now we can map a JVMTI env to its corresponding agent.\n+\/\/ Some agents create multiple JVMTI envs, but we only maintain a single 1-1 mapping to an agent where we can.\n+Agent* AgentList::lookup(JvmtiEnv* env, void* f_ptr) {\n+  assert(env != nullptr, \"invariant\");\n+  assert(f_ptr != nullptr, \"invariant\");\n+  int offset;\n+  if (!os::dll_address_to_library_name(reinterpret_cast<address>(f_ptr), &buffer[0], JVM_MAXPATHLEN, &offset)) {\n+    return nullptr;\n+  }\n+  assert(buffer[0] != '\\0', \"invariant\");\n+  assert(offset >= 0, \"invariant\");\n+  const void* const os_module_address = reinterpret_cast<address>(f_ptr) - offset;\n+\n+  AgentList::Iterator it = AgentList::agents();\n+  while (it.has_next()) {\n+    Agent* const agent = it.next();\n+    if (match(env, agent, os_module_address)) {\n+      agent->set_os_lib_path(&buffer[0]);\n+      return agent;\n+    }\n+  }\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/share\/prims\/agentList.cpp","additions":619,"deletions":0,"binary":false,"changes":619,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_PRIMS_AGENTLIST_HPP\n+#define SHARE_PRIMS_AGENTLIST_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"prims\/agent.hpp\"\n+\n+class JvmtiEnv;\n+\n+template <typename, MEMFLAGS>\n+class GrowableArrayCHeap;\n+\n+\/\/ Maintains a single cas-linked-list for -agentlib, -agentpath and -Xrun agents.\n+class AgentList : AllStatic {\n+  friend class Iterator;\n+  friend class JvmtiExport;\n+ public:\n+  class Iterator {\n+    friend class AgentList;\n+   private:\n+    enum Type {\n+      JAVA,\n+      NATIVE,\n+      JVMTI, \/\/ union of JAVA and NATIVE\n+      XRUN\n+    };\n+    GrowableArrayCHeap<Agent*, mtServiceability>* _stack;\n+    const Type _type;\n+    Iterator(Agent** list, Type type);\n+    Agent* filter(Agent* agent) const;\n+   public:\n+    bool has_next() const;\n+    Agent* next();\n+    const Agent* next() const;\n+    ~Iterator();\n+  };\n+\n+ private:\n+  static Agent* _list;\n+\n+  static void timestamp();\n+  static void invoke_JVM_OnLoad();\n+  static void promote_xrun_to_jvmti();\n+  static void link_jplis(Agent* agent);\n+\n+ public:\n+  static void add(Agent* agent);\n+  static void add(const char* name, char* options, bool absolute_path);\n+  static void add_xrun(const char* name, char* options, bool absolute_path);\n+\n+  static void load_xrun_agents();\n+  static void load_xrun_agents_at_startup();\n+  static void load_agents();\n+  static jint load_agent(const char* agent, const char* absParam,\n+                         const char* options, outputStream* st);\n+  static void unload_agents();\n+\n+  static Agent* lookup(JvmtiEnv* env, void* f_ptr);\n+\n+  static Iterator agents();\n+  static Iterator java_agents();\n+  static Iterator native_agents();\n+  static Iterator xrun_agents();\n+};\n+\n+#endif \/\/ SHARE_PRIMS_AGENTLIST_HPP\n","filename":"src\/hotspot\/share\/prims\/agentList.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -131,1 +131,0 @@\n-  const void* get_env_local_storage()              { return _env_local_storage; }\n@@ -166,0 +165,2 @@\n+  const void* get_env_local_storage() { return _env_local_storage; }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -713,0 +714,4 @@\n+        Agent* const agent = AgentList::lookup(env, reinterpret_cast<void*>(callback));\n+        if (agent != nullptr) {\n+          agent->initialization_begin();\n+        }\n@@ -714,0 +719,3 @@\n+        if (agent != nullptr) {\n+          agent->initialization_end();\n+        }\n@@ -717,1 +725,0 @@\n-}\n@@ -719,0 +726,5 @@\n+  \/\/ OnLoad JVMTI agents are timestamped as part of posting the VMInit event above.\n+  \/\/ For -Xrun agents and JVMTI agents with no VMInit callback, we ensure they are also timestamped.\n+  \/\/ JVM_OnLoad and Agent_OnLoad callouts are performed too early for the proper timestamp logic.\n+  AgentList::timestamp();\n+}\n@@ -2925,112 +2937,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-#if INCLUDE_SERVICES\n-\/\/ Attach is disabled if SERVICES is not included\n-\n-\/\/ type for the Agent_OnAttach entry point\n-extern \"C\" {\n-  typedef jint (JNICALL *OnAttachEntry_t)(JavaVM*, char *, void *);\n-}\n-\n-jint JvmtiExport::load_agent_library(const char *agent, const char *absParam,\n-                                     const char *options, outputStream* st) {\n-  char ebuf[1024] = {0};\n-  char buffer[JVM_MAXPATHLEN];\n-  void* library = nullptr;\n-  jint result = JNI_ERR;\n-  const char *on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n-  size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n-\n-  \/\/ The abs parameter should be \"true\" or \"false\"\n-  bool is_absolute_path = (absParam != nullptr) && (strcmp(absParam,\"true\")==0);\n-\n-  \/\/ Initially marked as invalid. It will be set to valid if we can find the agent\n-  AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, nullptr);\n-\n-  \/\/ Check for statically linked in agent. If not found then if the path is\n-  \/\/ absolute we attempt to load the library. Otherwise we try to load it\n-  \/\/ from the standard dll directory.\n-\n-  if (!os::find_builtin_agent(agent_lib, on_attach_symbols, num_symbol_entries)) {\n-    if (is_absolute_path) {\n-      library = os::dll_load(agent, ebuf, sizeof ebuf);\n-    } else {\n-      \/\/ Try to load the agent from the standard dll directory\n-      if (os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),\n-                             agent)) {\n-        library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-      }\n-      if (library == nullptr) {\n-        \/\/ not found - try OS default library path\n-        if (os::dll_build_name(buffer, sizeof(buffer), agent)) {\n-          library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-        }\n-      }\n-    }\n-    if (library != nullptr) {\n-      agent_lib->set_os_lib(library);\n-      agent_lib->set_valid();\n-    }\n-  }\n-  \/\/ If the library was loaded then we attempt to invoke the Agent_OnAttach\n-  \/\/ function\n-  if (agent_lib->valid()) {\n-    \/\/ Lookup the Agent_OnAttach function\n-    OnAttachEntry_t on_attach_entry = nullptr;\n-    on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n-       os::find_agent_function(agent_lib, false, on_attach_symbols, num_symbol_entries));\n-    if (on_attach_entry == nullptr) {\n-      \/\/ Agent_OnAttach missing - unload library\n-      if (!agent_lib->is_static_lib()) {\n-        os::dll_unload(library);\n-      }\n-      st->print_cr(\"%s is not available in %s\",\n-                   on_attach_symbols[0], agent_lib->name());\n-      delete agent_lib;\n-    } else {\n-      \/\/ Invoke the Agent_OnAttach function\n-      JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-      {\n-        extern struct JavaVM_ main_vm;\n-        JvmtiThreadEventMark jem(THREAD);\n-        JvmtiJavaThreadEventTransition jet(THREAD);\n-\n-        result = (*on_attach_entry)(&main_vm, (char*)options, nullptr);\n-\n-        \/\/ Agent_OnAttach may have used JNI\n-        if (THREAD->is_pending_jni_exception_check()) {\n-          THREAD->clear_pending_jni_exception_check();\n-        }\n-      }\n-\n-      \/\/ Agent_OnAttach may have used JNI\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n-\n-      \/\/ If OnAttach returns JNI_OK then we add it to the list of\n-      \/\/ agent libraries so that we can call Agent_OnUnload later.\n-      if (result == JNI_OK) {\n-        Arguments::add_loaded_agent(agent_lib);\n-      } else {\n-        if (!agent_lib->is_static_lib()) {\n-          os::dll_unload(library);\n-        }\n-        delete agent_lib;\n-      }\n-\n-      \/\/ Agent_OnAttach executed so completion status is JNI_OK\n-      st->print_cr(\"return code: %d\", result);\n-      result = JNI_OK;\n-    }\n-  } else {\n-    st->print_cr(\"%s was not loaded.\", agent);\n-    if (*ebuf != '\\0') {\n-      st->print_cr(\"%s\", ebuf);\n-    }\n-  }\n-  return result;\n-}\n-\n-#endif \/\/ INCLUDE_SERVICES\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":13,"deletions":113,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -288,3 +289,3 @@\n-    AgentLibrary* agent;\n-    for (agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n-      entry = (address) os::dll_lookup(agent->os_lib(), jni_name);\n+    AgentList::Iterator it = AgentList::agents();\n+    while (it.has_next()) {\n+      entry = (address)os::dll_lookup(it.next()->os_lib(), jni_name);\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -104,3 +105,0 @@\n-AgentLibraryList Arguments::_libraryList;\n-AgentLibraryList Arguments::_agentList;\n-\n@@ -216,19 +214,0 @@\n-AgentLibrary::AgentLibrary(const char* name, const char* options,\n-               bool is_absolute_path, void* os_lib,\n-               bool instrument_lib) {\n-  _name = AllocateHeap(strlen(name)+1, mtArguments);\n-  strcpy(_name, name);\n-  if (options == nullptr) {\n-    _options = nullptr;\n-  } else {\n-    _options = AllocateHeap(strlen(options)+1, mtArguments);\n-    strcpy(_options, options);\n-  }\n-  _is_absolute_path = is_absolute_path;\n-  _os_lib = os_lib;\n-  _next = nullptr;\n-  _state = agent_invalid;\n-  _is_static_lib = false;\n-  _is_instrument_lib = instrument_lib;\n-}\n-\n@@ -325,16 +304,0 @@\n-void Arguments::add_init_library(const char* name, char* options) {\n-  _libraryList.add(new AgentLibrary(name, options, false, nullptr));\n-}\n-\n-void Arguments::add_init_agent(const char* name, char* options, bool absolute_path) {\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr));\n-}\n-\n-void Arguments::add_instrument_agent(const char* name, char* options, bool absolute_path) {\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, true));\n-}\n-\n-\/\/ Late-binding agents not started via arguments\n-void Arguments::add_loaded_agent(AgentLibrary *agentLib) {\n-  _agentList.add(agentLib);\n-}\n@@ -2369,1 +2332,1 @@\n-        add_init_library(name, options);\n+        AgentList::add_xrun(name, options, false);\n@@ -2439,1 +2402,1 @@\n-        add_init_agent(name, options, is_absolute_path);\n+        AgentList::add(name, options, is_absolute_path);\n@@ -2452,1 +2415,1 @@\n-        add_instrument_agent(\"instrument\", options, false);\n+        AgentList::add(\"instrument\", options, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":41,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -141,92 +141,0 @@\n-\n-\/\/ For use by -agentlib, -agentpath and -Xrun\n-class AgentLibrary : public CHeapObj<mtArguments> {\n-  friend class AgentLibraryList;\n-public:\n-  \/\/ Is this library valid or not. Don't rely on os_lib == nullptr as statically\n-  \/\/ linked lib could have handle of RTLD_DEFAULT which == 0 on some platforms\n-  enum AgentState {\n-    agent_invalid = 0,\n-    agent_valid   = 1\n-  };\n-\n- private:\n-  char*           _name;\n-  char*           _options;\n-  void*           _os_lib;\n-  bool            _is_absolute_path;\n-  bool            _is_static_lib;\n-  bool            _is_instrument_lib;\n-  AgentState      _state;\n-  AgentLibrary*   _next;\n-\n- public:\n-  \/\/ Accessors\n-  const char* name() const                  { return _name; }\n-  char* options() const                     { return _options; }\n-  bool is_absolute_path() const             { return _is_absolute_path; }\n-  void* os_lib() const                      { return _os_lib; }\n-  void set_os_lib(void* os_lib)             { _os_lib = os_lib; }\n-  AgentLibrary* next() const                { return _next; }\n-  bool is_static_lib() const                { return _is_static_lib; }\n-  bool is_instrument_lib() const            { return _is_instrument_lib; }\n-  void set_static_lib(bool is_static_lib)   { _is_static_lib = is_static_lib; }\n-  bool valid()                              { return (_state == agent_valid); }\n-  void set_valid()                          { _state = agent_valid; }\n-\n-  \/\/ Constructor\n-  AgentLibrary(const char* name, const char* options, bool is_absolute_path,\n-               void* os_lib, bool instrument_lib=false);\n-};\n-\n-\/\/ maintain an order of entry list of AgentLibrary\n-class AgentLibraryList {\n- private:\n-  AgentLibrary*   _first;\n-  AgentLibrary*   _last;\n- public:\n-  bool is_empty() const                     { return _first == nullptr; }\n-  AgentLibrary* first() const               { return _first; }\n-\n-  \/\/ add to the end of the list\n-  void add(AgentLibrary* lib) {\n-    if (is_empty()) {\n-      _first = _last = lib;\n-    } else {\n-      _last->_next = lib;\n-      _last = lib;\n-    }\n-    lib->_next = nullptr;\n-  }\n-\n-  \/\/ search for and remove a library known to be in the list\n-  void remove(AgentLibrary* lib) {\n-    AgentLibrary* curr;\n-    AgentLibrary* prev = nullptr;\n-    for (curr = first(); curr != nullptr; prev = curr, curr = curr->next()) {\n-      if (curr == lib) {\n-        break;\n-      }\n-    }\n-    assert(curr != nullptr, \"always should be found\");\n-\n-    if (curr != nullptr) {\n-      \/\/ it was found, by-pass this library\n-      if (prev == nullptr) {\n-        _first = curr->_next;\n-      } else {\n-        prev->_next = curr->_next;\n-      }\n-      if (curr == _last) {\n-        _last = prev;\n-      }\n-      curr->_next = nullptr;\n-    }\n-  }\n-\n-  AgentLibraryList() {\n-    _first = nullptr;\n-    _last = nullptr;\n-  }\n-};\n-\n@@ -334,12 +242,0 @@\n-  \/\/ -Xrun arguments\n-  static AgentLibraryList _libraryList;\n-  static void add_init_library(const char* name, char* options);\n-\n-  \/\/ -agentlib and -agentpath arguments\n-  static AgentLibraryList _agentList;\n-  static void add_init_agent(const char* name, char* options, bool absolute_path);\n-  static void add_instrument_agent(const char* name, char* options, bool absolute_path);\n-\n-  \/\/ Late-binding agents not started via arguments\n-  static void add_loaded_agent(AgentLibrary *agentLib);\n-\n@@ -544,11 +440,0 @@\n-  \/\/ -Xrun\n-  static AgentLibrary* libraries()          { return _libraryList.first(); }\n-  static bool init_libraries_at_startup()   { return !_libraryList.is_empty(); }\n-  static void convert_library_to_agent(AgentLibrary* lib)\n-                                            { _libraryList.remove(lib);\n-                                              _agentList.add(lib); }\n-\n-  \/\/ -agentlib -agentpath\n-  static AgentLibrary* agents()             { return _agentList.first(); }\n-  static bool init_agents_at_startup()      { return !_agentList.is_empty(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":115,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -511,1 +512,1 @@\n-  Threads::shutdown_vm_agents();\n+  AgentList::unload_agents();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"prims\/agent.hpp\"\n@@ -537,1 +538,1 @@\n-void* os::find_agent_function(AgentLibrary *agent_lib, bool check_lib,\n+void* os::find_agent_function(Agent *agent_lib, bool check_lib,\n@@ -564,1 +565,1 @@\n-bool os::find_builtin_agent(AgentLibrary *agent_lib, const char *syms[],\n+bool os::find_builtin_agent(Agent *agent_lib, const char *syms[],\n@@ -583,1 +584,1 @@\n-    agent_lib->set_static_lib(true);\n+    agent_lib->set_static_lib();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-class AgentLibrary;\n+class Agent;\n@@ -735,1 +735,1 @@\n-  static bool find_builtin_agent(AgentLibrary *agent_lib, const char *syms[],\n+  static bool find_builtin_agent(Agent *agent_lib, const char *syms[],\n@@ -739,1 +739,1 @@\n-  static void *find_agent_function(AgentLibrary *agent_lib, bool check_lib,\n+  static void *find_agent_function(Agent *agent_lib, bool check_lib,\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -336,4 +337,0 @@\n-  if (EagerXrunInit && Arguments::init_libraries_at_startup()) {\n-    create_vm_init_libraries();\n-  }\n-\n@@ -503,6 +500,0 @@\n-  \/\/ Convert -Xrun to -agentlib: if there is no JVM_OnLoad\n-  \/\/ Must be before create_vm_init_agents()\n-  if (Arguments::init_libraries_at_startup()) {\n-    convert_vm_init_libraries_to_agents();\n-  }\n-\n@@ -510,3 +501,1 @@\n-  if (Arguments::init_agents_at_startup()) {\n-    create_vm_init_agents();\n-  }\n+  AgentList::load_agents();\n@@ -635,0 +624,5 @@\n+  \/\/ Launch -Xrun agents early if EagerXrunInit is set\n+  if (EagerXrunInit) {\n+    AgentList::load_xrun_agents_at_startup();\n+  }\n+\n@@ -668,5 +662,3 @@\n-  \/\/ Launch -Xrun agents\n-  \/\/ Must be done in the JVMTI live phase so that for backward compatibility the JDWP\n-  \/\/ back-end can launch with -Xdebug -Xrunjdwp.\n-  if (!EagerXrunInit && Arguments::init_libraries_at_startup()) {\n-    create_vm_init_libraries();\n+  \/\/ Launch -Xrun agents if EagerXrunInit is not set.\n+  if (!EagerXrunInit) {\n+    AgentList::load_xrun_agents();\n@@ -814,202 +806,0 @@\n-\/\/ type for the Agent_OnLoad and JVM_OnLoad entry points\n-extern \"C\" {\n-  typedef jint (JNICALL *OnLoadEntry_t)(JavaVM *, char *, void *);\n-}\n-\/\/ Find a command line agent library and return its entry point for\n-\/\/         -agentlib:  -agentpath:   -Xrun\n-\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n-static OnLoadEntry_t lookup_on_load(AgentLibrary* agent,\n-                                    const char *on_load_symbols[],\n-                                    size_t num_symbol_entries) {\n-  OnLoadEntry_t on_load_entry = nullptr;\n-  void *library = nullptr;\n-\n-  if (!agent->valid()) {\n-    char buffer[JVM_MAXPATHLEN];\n-    char ebuf[1024] = \"\";\n-    const char *name = agent->name();\n-    const char *msg = \"Could not find agent library \";\n-\n-    \/\/ First check to see if agent is statically linked into executable\n-    if (os::find_builtin_agent(agent, on_load_symbols, num_symbol_entries)) {\n-      library = agent->os_lib();\n-    } else if (agent->is_absolute_path()) {\n-      library = os::dll_load(name, ebuf, sizeof ebuf);\n-      if (library == nullptr) {\n-        const char *sub_msg = \" in absolute path, with error: \";\n-        size_t len = strlen(msg) + strlen(name) + strlen(sub_msg) + strlen(ebuf) + 1;\n-        char *buf = NEW_C_HEAP_ARRAY(char, len, mtThread);\n-        jio_snprintf(buf, len, \"%s%s%s%s\", msg, name, sub_msg, ebuf);\n-        \/\/ If we can't find the agent, exit.\n-        vm_exit_during_initialization(buf, nullptr);\n-        FREE_C_HEAP_ARRAY(char, buf);\n-      }\n-    } else {\n-      \/\/ Try to load the agent from the standard dll directory\n-      if (os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),\n-                             name)) {\n-        library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-      }\n-      if (library == nullptr) { \/\/ Try the library path directory.\n-        if (os::dll_build_name(buffer, sizeof(buffer), name)) {\n-          library = os::dll_load(buffer, ebuf, sizeof ebuf);\n-        }\n-        if (library == nullptr) {\n-          const char *sub_msg = \" on the library path, with error: \";\n-          const char *sub_msg2 = \"\\nModule java.instrument may be missing from runtime image.\";\n-\n-          size_t len = strlen(msg) + strlen(name) + strlen(sub_msg) +\n-                       strlen(ebuf) + strlen(sub_msg2) + 1;\n-          char *buf = NEW_C_HEAP_ARRAY(char, len, mtThread);\n-          if (!agent->is_instrument_lib()) {\n-            jio_snprintf(buf, len, \"%s%s%s%s\", msg, name, sub_msg, ebuf);\n-          } else {\n-            jio_snprintf(buf, len, \"%s%s%s%s%s\", msg, name, sub_msg, ebuf, sub_msg2);\n-          }\n-          \/\/ If we can't find the agent, exit.\n-          vm_exit_during_initialization(buf, nullptr);\n-          FREE_C_HEAP_ARRAY(char, buf);\n-        }\n-      }\n-    }\n-    agent->set_os_lib(library);\n-    agent->set_valid();\n-  }\n-\n-  \/\/ Find the OnLoad function.\n-  on_load_entry =\n-    CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent,\n-                                                          false,\n-                                                          on_load_symbols,\n-                                                          num_symbol_entries));\n-  return on_load_entry;\n-}\n-\n-\/\/ Find the JVM_OnLoad entry point\n-static OnLoadEntry_t lookup_jvm_on_load(AgentLibrary* agent) {\n-  const char *on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n-  return lookup_on_load(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n-\n-\/\/ Find the Agent_OnLoad entry point\n-static OnLoadEntry_t lookup_agent_on_load(AgentLibrary* agent) {\n-  const char *on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n-  return lookup_on_load(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n-}\n-\n-\/\/ For backwards compatibility with -Xrun\n-\/\/ Convert libraries with no JVM_OnLoad, but which have Agent_OnLoad to be\n-\/\/ treated like -agentpath:\n-\/\/ Must be called before agent libraries are created\n-void Threads::convert_vm_init_libraries_to_agents() {\n-  AgentLibrary* agent;\n-  AgentLibrary* next;\n-\n-  for (agent = Arguments::libraries(); agent != nullptr; agent = next) {\n-    next = agent->next();  \/\/ cache the next agent now as this agent may get moved off this list\n-    OnLoadEntry_t on_load_entry = lookup_jvm_on_load(agent);\n-\n-    \/\/ If there is an JVM_OnLoad function it will get called later,\n-    \/\/ otherwise see if there is an Agent_OnLoad\n-    if (on_load_entry == nullptr) {\n-      on_load_entry = lookup_agent_on_load(agent);\n-      if (on_load_entry != nullptr) {\n-        \/\/ switch it to the agent list -- so that Agent_OnLoad will be called,\n-        \/\/ JVM_OnLoad won't be attempted and Agent_OnUnload will\n-        Arguments::convert_library_to_agent(agent);\n-      } else {\n-        vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", agent->name());\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Create agents for -agentlib:  -agentpath:  and converted -Xrun\n-\/\/ Invokes Agent_OnLoad\n-\/\/ Called very early -- before JavaThreads exist\n-void Threads::create_vm_init_agents() {\n-  extern struct JavaVM_ main_vm;\n-  AgentLibrary* agent;\n-\n-  JvmtiExport::enter_onload_phase();\n-\n-  for (agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n-    \/\/ CDS dumping does not support native JVMTI agent.\n-    \/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n-    if (Arguments::is_dumping_archive()) {\n-      if(!agent->is_instrument_lib()) {\n-        vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n-      } else if (!AllowArchivingWithJavaAgent) {\n-        vm_exit_during_cds_dumping(\n-          \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n-      }\n-    }\n-\n-    OnLoadEntry_t  on_load_entry = lookup_agent_on_load(agent);\n-\n-    if (on_load_entry != nullptr) {\n-      \/\/ Invoke the Agent_OnLoad function\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), nullptr);\n-      if (err != JNI_OK) {\n-        vm_exit_during_initialization(\"agent library failed to init\", agent->name());\n-      }\n-    } else {\n-      vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n-    }\n-  }\n-\n-  JvmtiExport::enter_primordial_phase();\n-}\n-\n-extern \"C\" {\n-  typedef void (JNICALL *Agent_OnUnload_t)(JavaVM *);\n-}\n-\n-void Threads::shutdown_vm_agents() {\n-  \/\/ Send any Agent_OnUnload notifications\n-  const char *on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n-  size_t num_symbol_entries = ARRAY_SIZE(on_unload_symbols);\n-  extern struct JavaVM_ main_vm;\n-  for (AgentLibrary* agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n-\n-    \/\/ Find the Agent_OnUnload function.\n-    Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n-                                                   os::find_agent_function(agent,\n-                                                   false,\n-                                                   on_unload_symbols,\n-                                                   num_symbol_entries));\n-\n-    \/\/ Invoke the Agent_OnUnload function\n-    if (unload_entry != nullptr) {\n-      JavaThread* thread = JavaThread::current();\n-      ThreadToNativeFromVM ttn(thread);\n-      HandleMark hm(thread);\n-      (*unload_entry)(&main_vm);\n-    }\n-  }\n-}\n-\n-\/\/ Called for after the VM is initialized for -Xrun libraries which have not been converted to agent libraries\n-\/\/ Invokes JVM_OnLoad\n-void Threads::create_vm_init_libraries() {\n-  extern struct JavaVM_ main_vm;\n-  AgentLibrary* agent;\n-\n-  for (agent = Arguments::libraries(); agent != nullptr; agent = agent->next()) {\n-    OnLoadEntry_t on_load_entry = lookup_jvm_on_load(agent);\n-\n-    if (on_load_entry != nullptr) {\n-      \/\/ Invoke the JVM_OnLoad function\n-      JavaThread* thread = JavaThread::current();\n-      ThreadToNativeFromVM ttn(thread);\n-      HandleMark hm(thread);\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), nullptr);\n-      if (err != JNI_OK) {\n-        vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n-      }\n-    } else {\n-      vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":10,"deletions":220,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -137,1 +138,1 @@\n-  return JvmtiExport::load_agent_library(agent, absParam, options, out);\n+  return AgentList::load_agent(agent, absParam, options, out);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"prims\/agentList.hpp\"\n@@ -314,2 +315,1 @@\n-      JvmtiExport::load_agent_library(\"instrument\", \"false\",\n-                                      _libpath.value(), output());\n+      AgentList::load_agent(\"instrument\", \"false\", _libpath.value(), output());\n@@ -332,1 +332,1 @@\n-      JvmtiExport::load_agent_library(\"instrument\", \"false\", opt, output());\n+      AgentList::load_agent(\"instrument\", \"false\", opt, output());\n@@ -337,2 +337,1 @@\n-    JvmtiExport::load_agent_library(_libpath.value(), \"true\",\n-                                    _option.value(), output());\n+    AgentList::load_agent(_libpath.value(), \"true\", _option.value(), output());\n@@ -1048,1 +1047,3 @@\n-    for (AgentLibrary* agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n+    AgentList::Iterator it = AgentList::agents();\n+    while (it.has_next()) {\n+      Agent* agent = it.next();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -861,0 +861,10 @@\n+    <event name=\"jdk.JavaAgent\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.NativeAgent\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -861,0 +861,4 @@\n+    <event name=\"jdk.JavaAgent\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n@@ -862,0 +866,4 @@\n+    <event name=\"jdk.NativeAgent\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.lang.instrument.Instrumentation;\n+\n+public class JavaAgent {\n+\n+    public static void agentmain(String agentArgs, Instrumentation inst) throws Exception {\n+        System.out.println(\"agentmain: \" + agentArgs);\n+    }\n+\n+    public static void premain(String agentArgs, Instrumentation inst) throws Exception {\n+        System.out.println(\"premain: \" + agentArgs);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/JavaAgent.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.lang.reflect.Method;\n+import java.security.Timestamp;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedClassLoader;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.Event;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.TestClassLoader;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Tests Agent Loaded event by starting native and Java agents\n+ * @requires vm.hasJFR\n+ *\n+ * @library \/test\/lib\n+ * @modules java.instrument\n+ *\n+ * @build jdk.jfr.event.runtime.JavaAgent\n+ *\n+ * @run driver jdk.test.lib.util.JavaAgentBuilder\n+ *      jdk.jfr.event.runtime.JavaAgent\n+ *      JavaAgent.jar\n+ *\n+ * @run main\/othervm -javaagent:JavaAgent.jar=foo=bar\n+ *      jdk.jfr.event.runtime.TestAgentEvent\n+ *      testJavaStatic\n+ *\n+ * @run main\/othervm -Djdk.attach.allowAttachSelf=true\n+ *      jdk.jfr.event.runtime.TestAgentEvent\n+ *      testJavaDynamic\n+ *\n+ * @run main\/othervm -agentlib:jdwp=transport=dt_socket,server=y,address=any,onjcmd=y\n+ *      jdk.jfr.event.runtime.TestAgentEvent\n+ *      testNativeStatic\n+ *\/\n+public final class TestAgentEvent {\n+    private static final String JAVA_AGENT_JAR = \"JavaAgent.jar\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        String testMethod = args[0];\n+        Method m = TestAgentEvent.class.getDeclaredMethod(testMethod, new Class[0]);\n+        if (m == null) {\n+            throw new Exception(\"Unknown test method: \" + testMethod);\n+        }\n+        m.invoke(null, new Object[0]);\n+    }\n+\n+    private static void testJavaStatic() throws Throwable {\n+        try (Recording r = new Recording()) {\n+            r.enable(EventNames.JavaAgent);\n+            r.start();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            RecordedEvent e = events.get(0);\n+            System.out.println(e);\n+            Events.assertField(e, \"name\").equal(JAVA_AGENT_JAR);\n+            Events.assertField(e, \"options\").equal(\"foo=bar\");\n+            Instant initialization = e.getInstant(\"initialization\");\n+            if (initialization.isAfter(r.getStartTime())) {\n+                throw new Exception(\"Expected a static JavaAgent to be initialized before recording start\");\n+            }\n+            Events.assertField(e, \"initializationTime\").atLeast(0L);\n+            Events.assertField(e, \"initializationMethod\").equal(\"premain\");\n+        }\n+    }\n+\n+    private static void testNativeStatic() throws Throwable {\n+        try (Recording r = new Recording()) {\n+            r.enable(EventNames.NativeAgent);\n+            r.start();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            RecordedEvent e = events.get(0);\n+            System.out.println(e);\n+            Events.assertField(e, \"name\").equal(\"jdwp\");\n+            Events.assertField(e, \"options\").equal(\"transport=dt_socket,server=y,address=any,onjcmd=y\");\n+            Events.assertField(e, \"dynamic\").equal(false);\n+        }\n+    }\n+\n+    private static void testJavaDynamic() throws Throwable {\n+        try (Recording r = new Recording()) {\n+            r.enable(EventNames.JavaAgent);\n+            r.start();\n+            long pid = ProcessHandle.current().pid();\n+            VirtualMachine vm = VirtualMachine.attach(Long.toString(pid));\n+            vm.loadAgent(JAVA_AGENT_JAR, \"bar=baz\");\n+            vm.detach();\n+            vm = VirtualMachine.attach(Long.toString(pid));\n+            vm.loadAgent(JAVA_AGENT_JAR); \/\/ options = null\n+            vm.detach();\n+            vm = VirtualMachine.attach(Long.toString(pid));\n+            vm.loadAgent(JAVA_AGENT_JAR, \"\");\n+            vm.loadAgent(JAVA_AGENT_JAR, \"=\");\n+            vm.detach();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (RecordedEvent e : events) {\n+                System.out.println(e);\n+                Instant initialization = e.getInstant(\"initialization\");\n+                if (initialization.isBefore(r.getStartTime())) {\n+                    throw new Exception(\"Expected a dynamic JavaAgent to be initialized after recording start\");\n+                }\n+                if (initialization.isAfter(r.getStopTime())) {\n+                    throw new Exception(\"Expected a dynamic JavaAgent to be initialized before recording stop\");\n+                }\n+                Duration initializationTime = e.getDuration(\"initializationTime\");\n+                if (initializationTime.isNegative()) {\n+                    throw new Exception(\"Expected initalizationTime to be positive value\");\n+                }\n+                if (initializationTime.toSeconds() > 3600) {\n+                    throw new Exception(\"Expected initializationTime to be less than 1 hour\");\n+                }\n+                Events.assertField(e, \"initializationMethod\").equal(\"agentmain\");\n+                Events.assertField(e, \"name\").equal(JAVA_AGENT_JAR);\n+            }\n+            \/\/ The periodic task writing events uses an iterator over agents in the order from newest to oldest.\n+            Events.assertField(events.get(0), \"options\").equal(\"bar=baz\");\n+            Events.assertField(events.get(1), \"options\").equal(null);\n+            Events.assertField(events.get(2), \"options\").equal(\"\");\n+            Events.assertField(events.get(3), \"options\").equal(\"=\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestAgentEvent.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,2 @@\n+    public static final String JavaAgent = PREFIX + \"JavaAgent\";\n+    public static final String NativeAgent = PREFIX + \"NativeAgent\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}