{"files":[{"patch":"@@ -90,0 +90,1 @@\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n@@ -116,2 +117,2 @@\n-    public Object getProxyKey() {\n-        return this;\n+    public SurfaceManager.ProxyCache getSurfaceDataProxyCache() {\n+        return surfaceDataProxyCache;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-        setBlitProxyKey(gc.getProxyKey());\n+        setBlitProxyCache(gc.getSurfaceDataProxyCache());\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLSurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import sun.awt.image.SurfaceManager;\n@@ -77,0 +78,1 @@\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n@@ -109,2 +111,2 @@\n-    public Object getProxyKey() {\n-        return this;\n+    public SurfaceManager.ProxyCache getSurfaceDataProxyCache() {\n+        return surfaceDataProxyCache;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/opengl\/CGLGraphicsConfig.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.ref.WeakReference;\n+import java.util.Collections;\n@@ -35,1 +37,2 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n@@ -92,26 +95,0 @@\n-    private volatile ConcurrentHashMap<Object,Object> cacheMap;\n-\n-    \/**\n-     * Return an arbitrary cached object for an arbitrary cache key.\n-     * Other objects can use this mechanism to store cached data about\n-     * the source image that will let them save time when using or\n-     * manipulating the image in the future.\n-     * <p>\n-     * Note that the cache is maintained as a simple Map with no\n-     * attempts to keep it up to date or invalidate it so any data\n-     * stored here must either not be dependent on the state of the\n-     * image or it must be individually tracked to see if it is\n-     * outdated or obsolete.\n-     * <p>\n-     * The SurfaceData object of the primary (destination) surface\n-     * has a StateTracker mechanism which can help track the validity\n-     * and \"currentness\" of any data stored here.\n-     * For convenience and expediency an object stored as cached\n-     * data may implement the FlushableCacheData interface specified\n-     * below so that it may be notified immediately if the flush()\n-     * method is ever called.\n-     *\/\n-    public Object getCacheData(Object key) {\n-        return (cacheMap == null) ? null : cacheMap.get(key);\n-    }\n-\n@@ -119,3 +96,5 @@\n-     * Store an arbitrary cached object for an arbitrary cache key.\n-     * See the getCacheData() method for notes on tracking the\n-     * validity of data stored using this mechanism.\n+     * This map holds references to SurfaceDataProxy per given ProxyCache.\n+     * Unlike ProxyCache, which contains SurfaceDataProxy objects per given SurfaceManager,\n+     * this map does not prevent contained proxies from being garbage collected.\n+     * Therefore, ProxyCache can be considered an \"owning\" container for the SurfaceDataProxy objects,\n+     * and this map is just a weak mapping for the bookkeeping purposes.\n@@ -123,10 +102,1 @@\n-    public void setCacheData(Object key, Object value) {\n-        if (cacheMap == null) {\n-            synchronized (this) {\n-                if (cacheMap == null) {\n-                    cacheMap = new ConcurrentHashMap<>(2);\n-                }\n-            }\n-        }\n-        cacheMap.put(key, value);\n-    }\n+    private final Map<ProxyCache, WeakReference<SurfaceDataProxy>> weakCache = new WeakHashMap<>(2);\n@@ -205,6 +175,4 @@\n-            if (tmpGc instanceof ProxiedGraphicsConfig) {\n-                Object proxyKey =\n-                    ((ProxiedGraphicsConfig) tmpGc).getProxyKey();\n-                if (proxyKey != null) {\n-                    SurfaceDataProxy sdp =\n-                        (SurfaceDataProxy) getCacheData(proxyKey);\n+            if (tmpGc instanceof ProxiedGraphicsConfig pgc) {\n+                ProxyCache cache = pgc.getSurfaceDataProxyCache();\n+                if (cache != null) {\n+                    SurfaceDataProxy sdp = cache.get(SurfaceManager.this);\n@@ -225,1 +193,2 @@\n-    public static interface ProxiedGraphicsConfig {\n+    public interface ProxiedGraphicsConfig {\n+\n@@ -227,1 +196,1 @@\n-         * Return the key that destination surfaces created on the\n+         * Return the cache that destination surfaces created on the\n@@ -231,1 +200,38 @@\n-        public Object getProxyKey();\n+        ProxyCache getSurfaceDataProxyCache();\n+    }\n+\n+    public static class ProxyCache {\n+        private final Map<SurfaceManager, SurfaceDataProxy> map = Collections.synchronizedMap(new WeakHashMap<>());\n+\n+        \/**\n+         * Return a cached SurfaceDataProxy object for a given SurfaceManager.\n+         * <p>\n+         * Note that the cache is maintained as a simple Map with no\n+         * attempts to keep it up to date or invalidate it so any data\n+         * stored here must either not be dependent on the state of the\n+         * image or it must be individually tracked to see if it is\n+         * outdated or obsolete.\n+         * <p>\n+         * The SurfaceData object of the primary (destination) surface\n+         * has a StateTracker mechanism which can help track the validity\n+         * and \"currentness\" of any data stored here.\n+         * For convenience and expediency an object stored as cached\n+         * data may implement the FlushableCacheData interface specified\n+         * below so that it may be notified immediately if the flush()\n+         * method is ever called.\n+         *\/\n+        public SurfaceDataProxy get(SurfaceManager manager) {\n+            return map.get(manager);\n+        }\n+\n+        \/**\n+         * Store a cached SurfaceDataProxy object for a given SurfaceManager.\n+         * See the get() method for notes on tracking the\n+         * validity of data stored using this mechanism.\n+         *\/\n+        public void put(SurfaceManager manager, SurfaceDataProxy proxy) {\n+            synchronized (manager.weakCache) { \/\/ Synchronize on weakCache first!\n+                manager.weakCache.put(this, new WeakReference<>(proxy));\n+                map.put(manager, proxy);\n+            }\n+        }\n@@ -247,3 +253,3 @@\n-    synchronized void flush(boolean deaccelerate) {\n-        if (cacheMap != null) {\n-            Iterator<Object> i = cacheMap.values().iterator();\n+    void flush(boolean deaccelerate) {\n+        synchronized (weakCache) {\n+            Iterator<WeakReference<SurfaceDataProxy>> i = weakCache.values().iterator();\n@@ -251,5 +257,3 @@\n-                Object o = i.next();\n-                if (o instanceof FlushableCacheData) {\n-                    if (((FlushableCacheData) o).flush(deaccelerate)) {\n-                        i.remove();\n-                    }\n+                SurfaceDataProxy sdp = i.next().get();\n+                if (sdp == null || sdp.flush(deaccelerate)) {\n+                    i.remove();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/SurfaceManager.java","additions":61,"deletions":57,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    private Object blitProxyKey;\n+    private SurfaceManager.ProxyCache blitProxyCache;\n@@ -146,2 +146,2 @@\n-     * Subclasses can set a \"blit proxy key\" which will be used\n-     * along with the SurfaceManager.getCacheData() mechanism to\n+     * Subclasses can set a \"blit proxy cache\" which will be used\n+     * along with the SurfaceManager to\n@@ -149,4 +149,2 @@\n-     * This key is a \"tag\" used to identify which cached copies\n-     * are compatible with this destination SurfaceData.\n-     * The getSourceSurfaceData() method uses this key to manage\n-     * cached copies of a source image as described below.\n+     * The getSourceSurfaceData() method uses this cache to manage\n+     * copies of a source image as described below.\n@@ -154,1 +152,1 @@\n-     * The Object used as this key should be as unique as it needs\n+     * The cache used should be as unique as it needs\n@@ -156,1 +154,1 @@\n-     * each store their cached copies separately under different keys\n+     * each store their cached copies separately into different caches\n@@ -160,3 +158,3 @@\n-     * Many acceleratable SurfaceData objects can use their own\n-     * GraphicsConfiguration as their proxy key as the GC object will\n-     * typically be unique to a given screen and pixel format, but\n+     * Many GraphicsConfiguration implementations have their own\n+     * cache as the GC object is\n+     * typically unique to a given screen and pixel format, but\n@@ -171,1 +169,1 @@\n-     * implementations could use a single heavily shared key Object.\n+     * implementations could use a single heavily shared cache object.\n@@ -173,2 +171,2 @@\n-    protected void setBlitProxyKey(Object key) {\n-        \/\/ Caching is effectively disabled if we never have a proxy key\n+    protected void setBlitProxyCache(SurfaceManager.ProxyCache cache) {\n+        \/\/ Caching is effectively disabled if we never have a proxy cache\n@@ -176,1 +174,1 @@\n-        \/\/ if the key is not null.\n+        \/\/ if the cache is not null.\n@@ -178,1 +176,1 @@\n-            this.blitProxyKey = key;\n+            this.blitProxyCache = cache;\n@@ -195,1 +193,1 @@\n-     * If a blitProxyKey was supplied by the subclass then it is\n+     * If a blitProxyCache was supplied by the subclass then it is\n@@ -204,2 +202,2 @@\n-     * <li> destSD uses its \"blit proxy key\" (if set) to look for\n-     *      some cached data stored in the source SurfaceManager\n+     * <li> destSD uses its \"blit proxy cache\" (if set) to look for\n+     *      some cached data corresponding to the the source SurfaceManager\n@@ -222,5 +220,2 @@\n-        if (img.getAccelerationPriority() > 0.0f &&\n-            blitProxyKey != null)\n-        {\n-            SurfaceDataProxy sdp =\n-                (SurfaceDataProxy) srcMgr.getCacheData(blitProxyKey);\n+        if (img.getAccelerationPriority() > 0.0f && blitProxyCache != null) {\n+            SurfaceDataProxy sdp = blitProxyCache.get(srcMgr);\n@@ -233,1 +228,1 @@\n-                srcMgr.setCacheData(blitProxyKey, sdp);\n+                blitProxyCache.put(srcMgr, sdp);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SurfaceData.java","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-        setBlitProxyKey(gc.getProxyKey());\n+        setBlitProxyCache(gc.getSurfaceDataProxyCache());\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/opengl\/OGLSurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,2 +183,2 @@\n-    public Object getProxyKey() {\n-        return device.getProxyKeyFor(getSurfaceType());\n+    public SurfaceManager.ProxyCache getSurfaceDataProxyCache() {\n+        return device.getProxyCacheFor(getSurfaceType());\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,4 +38,1 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Objects;\n+import java.util.*;\n@@ -43,0 +40,1 @@\n+import sun.awt.image.SurfaceManager;\n@@ -65,1 +63,1 @@\n-    HashMap<SurfaceType, Object> x11ProxyKeyMap = new HashMap<>();\n+    Map<SurfaceType, SurfaceManager.ProxyCache> x11ProxyCacheMap = Collections.synchronizedMap(new HashMap<>());\n@@ -89,9 +87,2 @@\n-    public Object getProxyKeyFor(SurfaceType st) {\n-        synchronized (x11ProxyKeyMap) {\n-            Object o = x11ProxyKeyMap.get(st);\n-            if (o == null) {\n-                o = new Object();\n-                x11ProxyKeyMap.put(st, o);\n-            }\n-            return o;\n-        }\n+    public SurfaceManager.ProxyCache getProxyCacheFor(SurfaceType st) {\n+        return x11ProxyCacheMap.computeIfAbsent(st, unused -> new SurfaceManager.ProxyCache());\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsDevice.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n@@ -92,2 +93,2 @@\n-    public Object getProxyKey() {\n-        return this;\n+    public SurfaceManager.ProxyCache getSurfaceDataProxyCache() {\n+        return surfaceDataProxyCache;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/opengl\/GLXGraphicsConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-            setBlitProxyKey(gc.getProxyKey());\n+            setBlitProxyCache(gc.getSurfaceDataProxyCache());\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/x11\/X11SurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n+\n@@ -56,2 +58,3 @@\n-    public Object getProxyKey() {\n-        return this;\n+    @Override\n+    public SurfaceManager.ProxyCache getSurfaceDataProxyCache() {\n+        return surfaceDataProxyCache;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRGraphicsConfig.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -294,2 +294,1 @@\n-\n-        setBlitProxyKey(gc.getProxyKey());\n+        setBlitProxyCache(gc.getSurfaceDataProxyCache());\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRSurfaceData.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,2 +116,2 @@\n-    public Object getProxyKey() {\n-        return device;\n+    public SurfaceManager.ProxyCache getSurfaceDataProxyCache() {\n+        return device.surfaceDataProxyCache;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import sun.awt.image.SurfaceManager;\n@@ -93,0 +94,2 @@\n+    final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsDevice.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-        setBlitProxyKey(gc.getProxyKey());\n+        setBlitProxyCache(gc.getSurfaceDataProxyCache());\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/d3d\/D3DSurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n@@ -102,2 +103,2 @@\n-    public Object getProxyKey() {\n-        return this;\n+    public SurfaceManager.ProxyCache getSurfaceDataProxyCache() {\n+        return surfaceDataProxyCache;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/opengl\/WGLGraphicsConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-        setBlitProxyKey(graphicsConfig.getProxyKey());\n+        setBlitProxyCache(graphicsConfig.getSurfaceDataProxyCache());\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/windows\/GDIWindowSurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}