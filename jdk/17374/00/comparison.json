{"files":[{"patch":"@@ -418,22 +418,3 @@\n-    struct addrinfo hints;\n-    struct addrinfo *addrInfo = NULL;\n-    jdwpTransportError err;\n-\n-    \/*\n-     * To parse both IPv4 and IPv6 need to specify AF_UNSPEC family\n-     * (with AF_INET6 IPv4 addresses are not parsed even with AI_V4MAPPED and AI_ALL flags).\n-     *\/\n-    memset (&hints, 0, sizeof(hints));\n-    hints.ai_family = AF_UNSPEC;            \/\/ IPv6 or mapped IPv4\n-    hints.ai_socktype = SOCK_STREAM;\n-    hints.ai_protocol = IPPROTO_TCP;\n-    hints.ai_flags = AI_NUMERICHOST;        \/\/ only numeric addresses, no resolution\n-\n-    err = getAddrInfo(buffer, strlen(buffer), NULL, &hints, &addrInfo);\n-\n-    if (err != JDWPTRANSPORT_ERROR_NONE) {\n-        return err;\n-    }\n-\n-    if (addrInfo->ai_family == AF_INET6) {\n-        memcpy(result, &(((struct sockaddr_in6 *)(addrInfo->ai_addr))->sin6_addr), sizeof(*result));\n+    struct in_addr addr;\n+    struct in6_addr addr6;\n+    if (inet_pton (AF_INET6, buffer, &addr6) == 1) {\n@@ -441,4 +422,5 @@\n-    } else {    \/\/ IPv4 address - convert to mapped IPv6\n-        struct in6_addr addr6;\n-        convertIPv4ToIPv6(addrInfo->ai_addr, &addr6);\n-        memcpy(result, &addr6, sizeof(*result));\n+    } else if (inet_pton (AF_INET, buffer, &addr) == 1) {\n+        \/\/ IPv4 address - convert to mapped IPv6\n+        struct sockaddr sa;\n+        memcpy(&(((struct sockaddr_in*)&sa)->sin_addr), &addr, 4);\n+        convertIPv4ToIPv6(&sa, &addr6);\n@@ -446,1 +428,2 @@\n-    }\n+    } else\n+         return JDWPTRANSPORT_ERROR_IO_ERROR;\n@@ -448,1 +431,1 @@\n-    dbgsysFreeAddrInfo(addrInfo);\n+    memcpy(result, &addr6, sizeof(*result));\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libdt_socket\/socketTransport.c","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"}]}