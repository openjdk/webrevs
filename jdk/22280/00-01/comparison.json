{"files":[{"patch":"@@ -416,1 +416,0 @@\n-    jint modifiers;\n@@ -420,11 +419,0 @@\n-    error = fieldModifiers(clazz, field, &modifiers);\n-    if (error != JVMTI_ERROR_NONE) {\n-        outStream_setError(out, map2jdwpError(error));\n-        return;\n-    }\n-\n-    if (!(modifiers & JVM_ACC_STATIC)) {\n-        outStream_setError(out, JDWP_ERROR(INVALID_FIELDID));\n-        return;\n-    }\n-\n@@ -504,0 +492,2 @@\n+    jfieldID *fieldIDs = NULL;\n+    int i;\n@@ -519,1 +509,5 @@\n-    WITH_LOCAL_REFS(env, length + 1) { \/* +1 for class with instance fields *\/\n+    fieldIDs = jvmtiAllocate(length * (jint)sizeof(*fieldIDs));\n+    if (fieldIDs == NULL && length > 0) {\n+        outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));\n+        return;\n+    }\n@@ -521,1 +515,26 @@\n-        int i;\n+    if (!isStatic) {\n+        clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);\n+    }\n+\n+    \/\/ check field access for all requested fields. This must be done before\n+    \/\/ any writes to prevent extra data from being written.\n+    for (i = 0; i < length; i++) {\n+        fieldIDs[i] = inStream_readFieldID(in);\n+        jint modifiers;\n+        jvmtiError error;\n+\n+        error = fieldModifiers(clazz, fieldIDs[i], &modifiers);\n+        if (error != JVMTI_ERROR_NONE) {\n+            outStream_setError(out, map2jdwpError(error));\n+            jvmtiDeallocate(fieldIDs);\n+            return;\n+        }\n+\n+        if (((modifiers & JVM_ACC_STATIC) != 0) != isStatic) {\n+            outStream_setError(out, JDWP_ERROR(INVALID_FIELDID));\n+            jvmtiDeallocate(fieldIDs);\n+            return;\n+        }\n+    }\n+\n+    WITH_LOCAL_REFS(env, length + 1) { \/* +1 for class with instance fields *\/\n@@ -525,1 +544,1 @@\n-            jfieldID field = inStream_readFieldID(in);\n+            jfieldID field = fieldIDs[i];\n@@ -535,0 +554,2 @@\n+\n+    jvmtiDeallocate(fieldIDs);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,372 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdwp.ObjectReference.GetValues;\n+\n+import java.io.*;\n+\n+import nsk.share.*;\n+import nsk.share.jpda.*;\n+import nsk.share.jdwp.*;\n+\n+\/**\n+ * Test for JDWP command: ObjectReference.GetValues.\n+ *\n+ * See getvalues002.README for description of test execution.\n+ *\n+ * Test is executed by invoking method runIt().\n+ * JDWP command is tested in method testCommand().\n+ *\n+ * @see #runIt()\n+ * @see #testCommand()\n+ *\/\n+public class getvalues002 {\n+\n+    \/\/ exit status constants\n+    static final int JCK_STATUS_BASE = 95;\n+    static final int PASSED = 0;\n+    static final int FAILED = 2;\n+\n+    \/\/ communication signals constants\n+    static final String READY = \"ready\";\n+    static final String QUIT = \"quit\";\n+\n+    \/\/ package and classes names constants\n+    static final String PACKAGE_NAME = \"nsk.jdwp.ObjectReference.GetValues\";\n+    static final String TEST_CLASS_NAME = PACKAGE_NAME + \".\" + \"getvalues002\";\n+    static final String DEBUGEE_CLASS_NAME = TEST_CLASS_NAME + \"a\";\n+\n+    \/\/ tested JDWP command constants\n+    static final String JDWP_COMMAND_NAME = \"ObjectReference.GetValues\";\n+    static final int JDWP_COMMAND_ID = JDWP.Command.ObjectReference.GetValues;\n+\n+    \/\/ tested class name and signature constants\n+    static final String TESTED_CLASS_NAME = DEBUGEE_CLASS_NAME + \"$\" + \"TestedClass\";\n+    static final String TESTED_CLASS_SIGNATURE = \"L\" + TESTED_CLASS_NAME.replace('.', '\/') + \";\";\n+\n+    \/\/ name of the static field in the tested class with the tested object value\n+    static final String OBJECT_FIELD_NAME = getvalues002a.OBJECT_FIELD_NAME;\n+\n+    \/\/ error constants\n+    static final int INVALID_FIELDID = 25;\n+\n+    \/\/ names of static fields\n+    static final Object fields [] = {\n+                    \"booleanValue\",\n+                    \"byteValue\",\n+                    \"charValue\",\n+                    \"intValue\",\n+                    \"shortValue\",\n+                    \"longValue\",\n+                    \"floatValue\",\n+                    \"doubleValue\",\n+                    \"objectValue\",\n+                };\n+    static final int FIELDS_COUNT = fields.length;\n+\n+    \/\/ usual scaffold objects\n+    ArgumentHandler argumentHandler = null;\n+    Log log = null;\n+    Binder binder = null;\n+    Debugee debugee = null;\n+    Transport transport = null;\n+    IOPipe pipe = null;\n+\n+    \/\/ test passed or not\n+    boolean success = true;\n+\n+    \/\/ -------------------------------------------------------------------\n+\n+    \/**\n+     * Start test from command line.\n+     *\/\n+    public static void main (String argv[]) {\n+        int result = run(argv, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    \/**\n+     * Start JCK-compilant test.\n+     *\/\n+    public static int run(String argv[], PrintStream out) {\n+        return new getvalues002().runIt(argv, out);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------\n+\n+    \/**\n+     * Perform test execution.\n+     *\/\n+    public int runIt(String argv[], PrintStream out) {\n+\n+        \/\/ make log for debugger messages\n+        argumentHandler = new ArgumentHandler(argv);\n+        log = new Log(out, argumentHandler);\n+\n+        \/\/ execute test and display results\n+        try {\n+            log.display(\"\\n>>> Preparing debugee for testing \\n\");\n+\n+            \/\/ launch debugee\n+            binder = new Binder(argumentHandler, log);\n+            log.display(\"Launching debugee\");\n+            debugee = binder.bindToDebugee(DEBUGEE_CLASS_NAME);\n+            transport = debugee.getTransport();\n+            pipe = debugee.createIOPipe();\n+\n+            \/\/ make debuggee ready for testing\n+            prepareDebugee();\n+\n+            \/\/ work with prepared debugee\n+            try {\n+                log.display(\"\\n>>> Obtaining requred data from debugee \\n\");\n+\n+                \/\/ query debugee for TypeID of tested class\n+                log.display(\"Getting ReferenceTypeID by signature:\\n\"\n+                            + \"  \" + TESTED_CLASS_SIGNATURE);\n+                long classID = debugee.getReferenceTypeID(TESTED_CLASS_SIGNATURE);\n+                log.display(\"  got classID: \" + classID);\n+\n+                \/\/ query debuggee for objectID value from static field\n+                log.display(\"Getting objectID value from static field: \"\n+                            + OBJECT_FIELD_NAME);\n+                long objectID = queryObjectID(classID,\n+                            OBJECT_FIELD_NAME, JDWP.Tag.OBJECT);\n+                log.display(\"  got objectID: \" + objectID);\n+\n+                \/\/ query debugee for fieldIDs of tested class static fields\n+                log.display(\"Getting fieldIDs the tested class with the tested values\");\n+                long fieldIDs[] = queryClassFieldIDs(classID);\n+\n+                \/\/ perform testing JDWP command\n+                log.display(\"\\n>>> Testing JDWP command \\n\");\n+                for (int i = 0; i < FIELDS_COUNT; i++) {\n+                    testCommand(objectID, fieldIDs[i]);\n+                }\n+            } finally {\n+                \/\/ quit debugee\n+                log.display(\"\\n>>> Finishing test \\n\");\n+                quitDebugee();\n+            }\n+\n+        } catch (Failure e) {\n+            log.complain(\"TEST FAILED: \" + e.getMessage());\n+            e.printStackTrace(out);\n+            success = false;\n+        } catch (Exception e) {\n+            log.complain(\"Caught unexpected exception:\\n\" + e);\n+            e.printStackTrace(out);\n+            success = false;\n+        }\n+\n+        if (!success) {\n+            log.complain(\"TEST FAILED\");\n+            return FAILED;\n+        }\n+\n+        out.println(\"TEST PASSED\");\n+        return PASSED;\n+\n+    }\n+\n+    \/**\n+     * Prepare debugee for testing and waiting for ready signal.\n+     *\/\n+    void prepareDebugee() {\n+        \/\/ wait for VM_INIT event from debugee\n+        log.display(\"Waiting for VM_INIT event\");\n+        debugee.waitForVMInit();\n+\n+        \/\/ query debugee for VM-dependent ID sizes\n+        log.display(\"Querying for IDSizes\");\n+        debugee.queryForIDSizes();\n+\n+        \/\/ resume initially suspended debugee\n+        log.display(\"Resuming debugee VM\");\n+        debugee.resume();\n+\n+        \/\/ wait for READY signal from debugee\n+        log.display(\"Waiting for signal from debugee: \" + READY);\n+        String signal = pipe.readln();\n+        log.display(\"Received signal from debugee: \" + signal);\n+        if (! signal.equals(READY)) {\n+            throw new TestBug(\"Unexpected signal received form debugee: \" + signal\n+                            + \" (expected: \" + READY + \")\");\n+        }\n+    }\n+\n+    \/**\n+     * Sending debugee signal to quit and waiting for it exits.\n+     *\/\n+    void quitDebugee() {\n+        \/\/ send debugee signal to quit\n+        log.display(\"Sending signal to debugee: \" + QUIT);\n+        pipe.println(QUIT);\n+\n+        \/\/ wait for debugee exits\n+        log.display(\"Waiting for debugee exits\");\n+        int code = debugee.waitFor();\n+\n+        \/\/ analize debugee exit status code\n+        if (code == JCK_STATUS_BASE + PASSED) {\n+            log.display(\"Debugee PASSED with exit code: \" + code);\n+        } else {\n+            log.complain(\"Debugee FAILED with exit code: \" + code);\n+            success = false;\n+        }\n+    }\n+\n+    \/**\n+     * Query debuggee for objectID value of static class field.\n+     *\/\n+    long queryObjectID(long classID, String fieldName, byte tag) {\n+        \/\/ get fieledID for static field (declared in the class)\n+        long fieldID = debugee.getClassFieldID(classID, fieldName, true);\n+        \/\/ get value of the field\n+        JDWP.Value value = debugee.getStaticFieldValue(classID, fieldID);\n+\n+        \/\/ check that value has THREAD tag\n+        if (value.getTag() != tag) {\n+            throw new Failure(\"Wrong objectID tag received from field \\\"\" + fieldName\n+                            + \"\\\": \" + value.getTag() + \" (expected: \" + tag + \")\");\n+        }\n+\n+        \/\/ extract threadID from the value\n+        long objectID = ((Long)value.getValue()).longValue();\n+        return objectID;\n+    }\n+\n+    \/**\n+     * Query debugee for fieldIDs and them into nested_classesIDs array.\n+     *\/\n+    long[] queryClassFieldIDs(long typeID) {\n+        \/\/ create array for expected filedIDs\n+        long fieldIDs[] = new long[FIELDS_COUNT];\n+        for (int i = 0; i < FIELDS_COUNT; i++) {\n+            fieldIDs[i] = 0;\n+        }\n+\n+        \/\/ obtain requested fieldIDs form debuggee\n+        int count = 0;\n+        try {\n+            CommandPacket command = new CommandPacket(JDWP.Command.ReferenceType.Fields);\n+            command.addReferenceTypeID(typeID);\n+            command.setLength();\n+\n+            ReplyPacket reply = debugee.receiveReplyFor(command);\n+            reply.resetPosition();\n+\n+            long declared = reply.getInt();\n+            if (declared < FIELDS_COUNT) {\n+                throw new Failure(\"Too few fields of the tested class returned: \" + declared\n+                                    + \" (expected: at least \" + FIELDS_COUNT + \")\");\n+            }\n+\n+            for (int i = 0; i < declared; i++ ) {\n+                long fieldID = reply.getFieldID();\n+                String name = reply.getString();\n+                String signature = reply.getString();\n+                int modBits = reply.getInt();\n+\n+                for (int j = 0; j < FIELDS_COUNT; j++) {\n+                    if (fields[j].equals(name)) {\n+                        fieldIDs[j] = fieldID;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (!reply.isParsed()) {\n+                throw new Failure(\"Extra trailing bytes found in the reply packet at: \"\n+                                    + reply.currentPosition());\n+            }\n+\n+        } catch (BoundException e) {\n+            throw new Failure(\"Unable to extract field IDs from the reply packet:\\n\"\n+                            + e.getMessage());\n+        }\n+\n+        return fieldIDs;\n+    }\n+\n+    \/**\n+     * Perform testing JDWP command for specified objectID.\n+     *\/\n+    void testCommand(long objectID, long fieldID) {\n+        \/\/ create command packet\n+        log.display(\"Create command packet:\");\n+        log.display(\"Command: \" + JDWP_COMMAND_NAME);\n+        CommandPacket command = new CommandPacket(JDWP_COMMAND_ID);\n+\n+        \/\/ add out data to the command packet\n+        log.display(\"  objectID: \" + objectID);\n+        command.addObjectID(objectID);\n+        command.addInt(1);\n+        log.display(\"  fieldID: \" + fieldID);\n+        command.addFieldID(fieldID);\n+        command.setLength();\n+\n+        \/\/ send command packet to debugee\n+        try {\n+            log.display(\"Sending command packet:\\n\" + command);\n+            transport.write(command);\n+        } catch (IOException e) {\n+            log.complain(\"Unable to send command packet:\\n\" + e);\n+            success = false;\n+            return;\n+        }\n+\n+        ReplyPacket reply = new ReplyPacket();\n+\n+        \/\/ receive reply packet from debugee\n+        try {\n+            log.display(\"Waiting for reply packet\");\n+            transport.read(reply);\n+            log.display(\"Reply packet received:\\n\" + reply);\n+        } catch (IOException e) {\n+            log.complain(\"Unable to read reply packet:\\n\" + e);\n+            success = false;\n+            return;\n+        }\n+\n+        \/\/ check reply packet header\n+        try{\n+            log.display(\"Checking reply packet header\");\n+            reply.checkHeader(command.getPacketID(), INVALID_FIELDID);\n+        } catch (BoundException e) {\n+            log.complain(\"Bad header of reply packet: \" + e.getMessage());\n+            success = false;\n+        }\n+\n+        \/\/ check for extra data in reply packet\n+        reply.resetPosition();\n+        if (! reply.isParsed()) {\n+            log.complain(\"Extra trailing bytes found in reply packet at: \"\n+                        + \"0x\" + reply.toHexString(reply.currentDataPosition(), 4));\n+            success = false;\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ObjectReference\/GetValues\/getvalues002.java","additions":372,"deletions":0,"binary":false,"changes":372,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jdwp\/ObjectReference\/GetValues\/getvalues002.\n+ * VM Testbase keywords: [quick, jpda, jdwp]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test performs checking for\n+ *         command set: ObjectReference\n+ *         command: GetValues\n+ *     Test checks that debugee accept the command packet and\n+ *     replies with correct reply packet. Also test checks that\n+ *     the returned values of requested fields are equal to\n+ *     the expected ones.\n+ *     Test consists of two compoments:\n+ *         debugger: getvalues002\n+ *         debuggee: getvalues002a\n+ *     First, debugger uses nsk.share support classes to launch debuggee\n+ *     and obtain Transport object, that represents JDWP transport channel.\n+ *     Also communication channel (IOPipe) is established between\n+ *     debugger and debuggee to exchange with synchronization messages.\n+ *     Next, debugger obtains from debuggee classID for the tested class and\n+ *     objectID as the value of the class static field. Also debugger obtains\n+ *     fieldIDs for all tested fields of the class.\n+ *     Then, debugger creates command packet for GetValues command with the\n+ *     found objectID and a static fieldID as an argument, writes packet\n+ *     to the transport channel, and waits for a reply packet.\n+ *     When reply packet is received, debugger parses the packet structure\n+ *     and checks that the expected error is present. This test is repeated\n+ *     for all fields on the class.\n+ *     Finally, debugger sends debuggee signal to quit, waits for it exits\n+ *     and exits too with the proper exit code.\n+ *\n+ * @library \/vmTestbase \/test\/hotspot\/jtreg\/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.jdwp.ObjectReference.GetValues.getvalues002a\n+ * @run driver\n+ *      nsk.jdwp.ObjectReference.GetValues.getvalues002\n+ *      -arch=${os.family}-${os.simpleArch}\n+ *      -verbose\n+ *      -waittime=5\n+ *      -debugee.vmkind=java\n+ *      -transport.address=dynamic\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ObjectReference\/GetValues\/getvalues002\/TestDescription.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdwp.ObjectReference.GetValues;\n+\n+import nsk.share.*;\n+import nsk.share.jpda.*;\n+import nsk.share.jdwp.*;\n+\n+import java.io.*;\n+\n+public class getvalues002a {\n+\n+    public static final String OBJECT_FIELD_NAME = \"object\";\n+\n+    public static void main(String args[]) {\n+        getvalues002a _getvalues002a = new getvalues002a();\n+        System.exit(getvalues002.JCK_STATUS_BASE + _getvalues002a.runIt(args, System.err));\n+    }\n+\n+    public int runIt(String args[], PrintStream out) {\n+        \/\/ make log for debugee messages\n+        ArgumentHandler argumentHandler = new ArgumentHandler(args);\n+        Log log = new Log(out, argumentHandler);\n+\n+        \/\/ make communication pipe to debugger\n+        log.display(\"Creating pipe\");\n+        IOPipe pipe = argumentHandler.createDebugeeIOPipe(log);\n+\n+        \/\/ ensure tested class loaded\n+        log.display(\"Creating object of tested class\");\n+        TestedClass.object = new TestedClass();\n+\n+        \/\/ send debugger signal READY\n+        log.display(\"Sending signal to debugger: \" + getvalues002.READY);\n+        pipe.println(getvalues002.READY);\n+\n+        \/\/ wait for signal QUIT from debugeer\n+        log.display(\"Waiting for signal from debugger: \" + getvalues002.QUIT);\n+        String signal = pipe.readln();\n+        log.display(\"Received signal from debugger: \" + signal);\n+\n+        \/\/ check received signal\n+        if (! signal.equals(getvalues002.QUIT)) {\n+            log.complain(\"Unexpected communication signal from debugee: \" + signal\n+                        + \" (expected: \" + getvalues002.QUIT + \")\");\n+            log.display(\"Debugee FAILED\");\n+            return getvalues002.FAILED;\n+        }\n+\n+        \/\/ exit debugee\n+        log.display(\"Debugee PASSED\");\n+        return getvalues002.PASSED;\n+    }\n+\n+    \/\/ tested class with own static fields values\n+    public static class TestedClass {\n+\n+        \/\/ static field with tested object\n+        public static TestedClass object = null;\n+\n+        \/\/ fields with tested values\n+        private   static boolean       booleanValue = true;\n+        private   static final byte    byteValue    = (byte)0x0F;\n+        protected static char          charValue    = 'Z';\n+        protected static final int     intValue     = 100;\n+        public    static short         shortValue   = (short)10;\n+        public    static final long    longValue    = (long)1000000;\n+                  static float         floatValue   = (float)3.14;\n+                  static final double  doubleValue  = (double)2.8e-12;\n+                  static TestedClass   objectValue  = null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ObjectReference\/GetValues\/getvalues002a.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdwp.ReferenceType.GetValues;\n+\n+import java.io.*;\n+\n+import nsk.share.*;\n+import nsk.share.jpda.*;\n+import nsk.share.jdwp.*;\n+\n+\/**\n+ * Test for JDWP command: ReferenceType.GetValues.\n+ *\n+ * See getvalues002.README for description of test execution.\n+ *\n+ * Test is executed by invoking method runIt().\n+ * JDWP command is tested in method testCommand().\n+ *\n+ * @see #runIt()\n+ * @see #testCommand()\n+ *\/\n+public class getvalues002 {\n+\n+    \/\/ exit status constants\n+    static final int JCK_STATUS_BASE = 95;\n+    static final int PASSED = 0;\n+    static final int FAILED = 2;\n+\n+    \/\/ communication signals constants\n+    static final String READY = \"ready\";\n+    static final String QUIT = \"quit\";\n+\n+    \/\/ package and classes names constants\n+    static final String PACKAGE_NAME = \"nsk.jdwp.ReferenceType.GetValues\";\n+    static final String TEST_CLASS_NAME = PACKAGE_NAME + \".\" + \"getvalues002\";\n+    static final String DEBUGEE_CLASS_NAME = TEST_CLASS_NAME + \"a\";\n+\n+    \/\/ tested JDWP command constants\n+    static final String JDWP_COMMAND_NAME = \"ReferenceType.GetValues\";\n+    static final int JDWP_COMMAND_ID = JDWP.Command.ReferenceType.GetValues;\n+\n+    \/\/ tested class name and signature constants\n+    static final String TESTED_CLASS_NAME = DEBUGEE_CLASS_NAME + \"$\" + \"TestedClass\";\n+    static final String TESTED_CLASS_SIGNATURE = \"L\" + TESTED_CLASS_NAME.replace('.', '\/') + \";\";\n+\n+    \/\/ error constants\n+    static final int INVALID_FIELDID = 25;\n+\n+    \/\/ names of instance fields\n+    static final Object fields [] = {\n+            \"booleanValue\",\n+            \"byteValue\",\n+            \"charValue\",\n+            \"intValue\",\n+            \"shortValue\",\n+            \"longValue\",\n+            \"floatValue\",\n+            \"doubleValue\",\n+            \"objectValue\",\n+    };\n+    static final int FIELDS_COUNT = fields.length;\n+\n+    \/\/ field ID's for tested class static fields\n+    static final long[] fieldIDs = new long[FIELDS_COUNT];\n+\n+    \/\/ usual scaffold objects\n+    ArgumentHandler argumentHandler = null;\n+    Log log = null;\n+    Binder binder = null;\n+    Debugee debugee = null;\n+    Transport transport = null;\n+    IOPipe pipe = null;\n+\n+    \/\/ test passed or not\n+    boolean success = true;\n+\n+    \/\/ -------------------------------------------------------------------\n+\n+    \/**\n+     * Start test from command line.\n+     *\/\n+    public static void main (String argv[]) {\n+        int result = run(argv, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    \/**\n+     * Start JCK-compilant test.\n+     *\/\n+    public static int run(String argv[], PrintStream out) {\n+        return new getvalues002().runIt(argv, out);\n+    }\n+\n+    \/\/ -------------------------------------------------------------------\n+\n+    \/**\n+     * Perform test execution.\n+     *\/\n+    public int runIt(String argv[], PrintStream out) {\n+\n+        \/\/ make log for debugger messages\n+        argumentHandler = new ArgumentHandler(argv);\n+        log = new Log(out, argumentHandler);\n+\n+        \/\/ execute test and display results\n+        try {\n+            log.display(\"\\n>>> Preparing debugee for testing \\n\");\n+\n+            \/\/ launch debugee\n+            binder = new Binder(argumentHandler, log);\n+            log.display(\"Launching debugee\");\n+            debugee = binder.bindToDebugee(DEBUGEE_CLASS_NAME);\n+            transport = debugee.getTransport();\n+            pipe = debugee.createIOPipe();\n+\n+            \/\/ make debuggee ready for testing\n+            prepareDebugee();\n+\n+            \/\/ work with prepared debugee\n+            try {\n+                log.display(\"\\n>>> Obtaining requred data from debugee \\n\");\n+\n+                \/\/ query debugee for TypeID of tested class\n+                log.display(\"Getting ReferenceTypeID by signature:\\n\"\n+                            + \"  \" + TESTED_CLASS_SIGNATURE);\n+                long typeID = debugee.getReferenceTypeID(TESTED_CLASS_SIGNATURE);\n+                log.display(\"  got TypeID: \" + typeID);\n+\n+                \/\/ query debugee for fieldIDs of tested class static fields\n+                log.display(\"Getting fieldIDs for static fields of the tested class\");\n+                queryClassFieldIDs(typeID);\n+\n+                \/\/ perform testing JDWP command\n+                log.display(\"\\n>>> Testing JDWP command \\n\");\n+                for (int i = 0; i < FIELDS_COUNT; i++) {\n+                    testCommand(typeID, fieldIDs[i]);\n+                }\n+\n+            } finally {\n+                \/\/ quit debugee\n+                log.display(\"\\n>>> Finishing test \\n\");\n+                quitDebugee();\n+            }\n+\n+        } catch (Failure e) {\n+            log.complain(\"TEST FAILED: \" + e.getMessage());\n+            e.printStackTrace(out);\n+            success = false;\n+        } catch (Exception e) {\n+            log.complain(\"Caught unexpected exception:\\n\" + e);\n+            e.printStackTrace(out);\n+            success = false;\n+        }\n+\n+        if (!success) {\n+            log.complain(\"TEST FAILED\");\n+            return FAILED;\n+        }\n+\n+        out.println(\"TEST PASSED\");\n+        return PASSED;\n+\n+    }\n+\n+    \/**\n+     * Prepare debugee for testing and waiting for ready signal.\n+     *\/\n+    void prepareDebugee() {\n+        \/\/ wait for VM_INIT event from debugee\n+        log.display(\"Waiting for VM_INIT event\");\n+        debugee.waitForVMInit();\n+\n+        \/\/ query debugee for VM-dependent ID sizes\n+        log.display(\"Querying for IDSizes\");\n+        debugee.queryForIDSizes();\n+\n+        \/\/ resume initially suspended debugee\n+        log.display(\"Resuming debugee VM\");\n+        debugee.resume();\n+\n+        \/\/ wait for READY signal from debugee\n+        log.display(\"Waiting for signal from debugee: \" + READY);\n+        String signal = pipe.readln();\n+        log.display(\"Received signal from debugee: \" + signal);\n+        if (! signal.equals(READY)) {\n+            throw new TestBug(\"Unexpected signal received form debugee: \" + signal\n+                            + \" (expected: \" + READY + \")\");\n+        }\n+    }\n+\n+    \/**\n+     * Sending debugee signal to quit and waiting for it exits.\n+     *\/\n+    void quitDebugee() {\n+        \/\/ send debugee signal to quit\n+        log.display(\"Sending signal to debugee: \" + QUIT);\n+        pipe.println(QUIT);\n+\n+        \/\/ wait for debugee exits\n+        log.display(\"Waiting for debugee exits\");\n+        int code = debugee.waitFor();\n+\n+        \/\/ analize debugee exit status code\n+        if (code == JCK_STATUS_BASE + PASSED) {\n+            log.display(\"Debugee PASSED with exit code: \" + code);\n+        } else {\n+            log.complain(\"Debugee FAILED with exit code: \" + code);\n+            success = false;\n+        }\n+    }\n+\n+    \/**\n+     * Query debugee for TypeIDs for nested classes from nested_classes array\n+     * and put them into nested_classesIDs array.\n+     *\/\n+    void queryClassFieldIDs(long typeID) {\n+        for (int i = 0; i < FIELDS_COUNT; i++) {\n+            fieldIDs[i] = 0;\n+        }\n+\n+        int count = 0;\n+        try {\n+            CommandPacket command = new CommandPacket(JDWP.Command.ReferenceType.Fields);\n+            command.addReferenceTypeID(typeID);\n+            command.setLength();\n+\n+            ReplyPacket reply = debugee.receiveReplyFor(command);\n+            reply.resetPosition();\n+\n+            long declared = reply.getInt();\n+            log.display(\"  declared: \" + declared);\n+\n+            for (int i = 0; i < declared; i++ ) {\n+                long fieldID = reply.getFieldID();\n+                String name = reply.getString();\n+                String signature = reply.getString();\n+                int modBits = reply.getInt();\n+\n+                boolean found = false;\n+                for (int j = 0; j < FIELDS_COUNT; j++) {\n+                    if (fields[j].equals(name)) {\n+                        if (fieldIDs[j] != 0) {\n+                            throw new Failure(\"Duplicated field name of the tested class returned: \" + name);\n+                        }\n+                        fieldIDs[j] = fieldID;\n+                        found = true;\n+                        break;\n+                    }\n+                }\n+                if (!found) {\n+                    throw new Failure(\"Unexpected field of the tested class returned: \" + name);\n+                }\n+            }\n+\n+            if (declared < FIELDS_COUNT) {\n+                throw new Failure(\"Too few fields of the tested class returned: \" + declared\n+                                    + \" (expected: \" + FIELDS_COUNT + \")\");\n+            }\n+\n+            if (declared > FIELDS_COUNT) {\n+                throw new Failure(\"Too many fields of the tested class returned: \" + declared\n+                                    + \" (expected: \" + FIELDS_COUNT + \")\");\n+            }\n+\n+            if (!reply.isParsed()) {\n+                throw new Failure(\"Extra trailing bytes found in the reply packet at: \"\n+                                    + reply.currentPosition());\n+            }\n+\n+        } catch (BoundException e) {\n+            throw new Failure(\"Unable to extract field IDs from the reply packet:\\n\"\n+                            + e.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * Perform testing JDWP command for specified TypeID.\n+     *\/\n+    void testCommand(long typeID, long fieldID) {\n+        \/\/ create command packet\n+        log.display(\"Create command packet:\");\n+        log.display(\"Command: \" + JDWP_COMMAND_NAME);\n+        CommandPacket command = new CommandPacket(JDWP_COMMAND_ID);\n+\n+        \/\/ add out data to the command packet\n+        log.display(\"  refType: \" + typeID);\n+        command.addReferenceTypeID(typeID);\n+        command.addInt(1);\n+        log.display(\"  fieldID: \" + fieldID);\n+        command.addFieldID(fieldID);\n+        command.setLength();\n+\n+        \/\/ send command packet to debugee\n+        try {\n+            log.display(\"Sending command packet:\\n\" + command);\n+            transport.write(command);\n+        } catch (IOException e) {\n+            log.complain(\"Unable to send command packet:\\n\" + e);\n+            success = false;\n+            return;\n+        }\n+\n+        ReplyPacket reply = new ReplyPacket();\n+\n+        \/\/ receive reply packet from debugee\n+        try {\n+            log.display(\"Waiting for reply packet\");\n+            transport.read(reply);\n+            log.display(\"Reply packet received:\\n\" + reply);\n+        } catch (IOException e) {\n+            log.complain(\"Unable to read reply packet:\\n\" + e);\n+            success = false;\n+            return;\n+        }\n+\n+        \/\/ check reply packet header\n+        try{\n+            log.display(\"Checking reply packet header\");\n+            reply.checkHeader(command.getPacketID(), INVALID_FIELDID);\n+        } catch (BoundException e) {\n+            log.complain(\"Bad header of reply packet: \" + e.getMessage());\n+            success = false;\n+        }\n+\n+        \/\/ check for extra data in reply packet\n+        reply.resetPosition();\n+        if (! reply.isParsed()) {\n+            log.complain(\"Extra trailing bytes found in reply packet at: \"\n+                    + \"0x\" + reply.toHexString(reply.currentDataPosition(), 4));\n+            success = false;\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ReferenceType\/GetValues\/getvalues002.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jdwp\/ReferenceType\/GetValues\/getvalues002.\n+ * VM Testbase keywords: [quick, jpda, jdwp]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test performs checking for\n+ *         command set: ReferenceType\n+ *         command: GetValues\n+ *     Test checks that debugee accept the command packet and\n+ *     replies with correct reply packet. Also test checks that\n+ *     the returned values of requested fields are equal to\n+ *     the expected ones.\n+ *     Test consists of two compoments:\n+ *         debugger: getvalues002\n+ *         debuggee: getvalues002a\n+ *     First, debugger uses nsk.share support classes to launch debuggee\n+ *     and obtain Transport object, that represents JDWP transport channel.\n+ *     Also communication channel (IOPipe) is established between\n+ *     debugger and debuggee to exchange with synchronization messages.\n+ *     Next, debugger obtains ReferenceTypeIDs for the tested class from\n+ *     debugee, and obtains also fieldIDs for all tested fields of this class.\n+ *     Then, debugger creates command packet for GetValues command with the\n+ *     found referenceTypeID and list of fieldIDs as arguments, writes packet\n+ *     to the transport channel, and waits for a reply packet.\n+ *     When reply packet is received, debugger parses the packet structure\n+ *     and checks that the expected error is present. This test is repeated\n+ *     for all fields on the class.\n+ *     Finally, debugger sends debuggee signal to quit, waits for it exits\n+ *     and exits too with the proper exit code.\n+ *\n+ * @library \/vmTestbase \/test\/hotspot\/jtreg\/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.jdwp.ReferenceType.GetValues.getvalues002a\n+ * @run driver\n+ *      nsk.jdwp.ReferenceType.GetValues.getvalues002\n+ *      -arch=${os.family}-${os.simpleArch}\n+ *      -verbose\n+ *      -waittime=5\n+ *      -debugee.vmkind=java\n+ *      -transport.address=dynamic\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ReferenceType\/GetValues\/getvalues002\/TestDescription.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdwp.ReferenceType.GetValues;\n+\n+import nsk.share.*;\n+import nsk.share.jpda.*;\n+import nsk.share.jdwp.*;\n+\n+import java.io.*;\n+\n+public class getvalues002a {\n+\n+    public static void main(String args[]) {\n+        getvalues002a _getvalues002a = new getvalues002a();\n+        System.exit(getvalues002.JCK_STATUS_BASE + _getvalues002a.runIt(args, System.err));\n+    }\n+\n+    public int runIt(String args[], PrintStream out) {\n+        \/\/make log for debugee messages\n+        ArgumentHandler argumentHandler = new ArgumentHandler(args);\n+        Log log = new Log(out, argumentHandler);\n+\n+        \/\/ meke communication pipe to debugger\n+        log.display(\"Creating pipe\");\n+        IOPipe pipe = argumentHandler.createDebugeeIOPipe(log);\n+\n+        \/\/ ensure tested class loaded\n+        log.display(\"Creating object of tested class\");\n+        TestedClass foo = new TestedClass();\n+\n+        \/\/ send debugger signal READY\n+        log.display(\"Sending signal to debugger: \" + getvalues002.READY);\n+        pipe.println(getvalues002.READY);\n+\n+        \/\/ wait for signal QUIT from debugeer\n+        log.display(\"Waiting for signal from debugger: \" + getvalues002.QUIT);\n+        String signal = pipe.readln();\n+        log.display(\"Received signal from debugger: \" + signal);\n+\n+        \/\/ check received signal\n+        if (! signal.equals(getvalues002.QUIT)) {\n+            log.complain(\"Unexpected communication signal from debugee: \" + signal\n+                        + \" (expected: \" + getvalues002.QUIT + \")\");\n+            log.display(\"Debugee FAILED\");\n+            return getvalues002.FAILED;\n+        }\n+\n+        \/\/ exit debugee\n+        log.display(\"Debugee PASSED\");\n+        return getvalues002.PASSED;\n+    }\n+\n+    \/\/ tested class with own static fields values\n+    public static class TestedClass {\n+        private   boolean       booleanValue = true;\n+        private   final byte    byteValue    = (byte)0x0F;\n+        protected char          charValue    = 'Z';\n+        protected final int     intValue     = 100;\n+        public    short         shortValue   = (short)10;\n+        public    final long    longValue    = (long)1000000;\n+                  float         floatValue   = (float)3.14;\n+                  final double  doubleValue  = (double)2.8e-12;\n+                  TestedClass   objectValue  = null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ReferenceType\/GetValues\/getvalues002a.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,17 @@\n+    \/**\n+     * Check reply packet header for specified reply ID and error code.\n+     *\n+     * @throws PacketFormatException if packet header fields have invalid values\n+     *\/\n+    public void checkHeader(int id, int error) throws PacketFormatException {\n+        if (getPacketID() != id) {\n+            throw new PacketFormatException(\"Unexpected ID in reply packet header: \"\n+                    + getPacketID());\n+        }\n+\n+        if (getErrorCode() != error) {\n+            throw new PacketFormatException(\"Unexpected error code in reply packet header: \"\n+                    + getErrorCode());\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdwp\/ReplyPacket.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}