{"files":[{"patch":"@@ -15046,2 +15046,1 @@\n-      __ fcvtsh($tmp$$FloatRegister, $src$$FloatRegister);\n-      __ smov($dst$$Register, $tmp$$FloatRegister, __ H, 0);\n+      __ flt_to_flt16($dst$$Register, $src$$FloatRegister, $tmp$$FloatRegister);\n@@ -15059,2 +15058,1 @@\n-      __ mov($tmp$$FloatRegister, __ H, 0, $src$$Register);\n-      __ fcvths($dst$$FloatRegister, $tmp$$FloatRegister);\n+      __ flt16_to_flt($dst$$FloatRegister, $src$$Register, $tmp$$FloatRegister);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1817,1 +1817,1 @@\n-void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {\n+void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {\n@@ -1821,0 +1821,2 @@\n+  case lir_f2hf: __ flt_to_flt16(dest->as_register(), value->as_float_reg(), tmp->as_float_reg()); break;\n+  case lir_hf2f: __ flt16_to_flt(dest->as_float_reg(), value->as_register(), tmp->as_float_reg()); break;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -755,1 +755,3 @@\n-    case vmIntrinsics::_dsqrt_strict: {\n+    case vmIntrinsics::_dsqrt_strict:\n+    case vmIntrinsics::_floatToFloat16:\n+    case vmIntrinsics::_float16ToFloat: {\n@@ -759,0 +761,1 @@\n+      LIR_Opr src = value.result();\n@@ -764,1 +767,1 @@\n-          __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n+          __ sqrt(src, dst, LIR_OprFact::illegalOpr);\n@@ -768,1 +771,13 @@\n-          __ abs(value.result(), dst, LIR_OprFact::illegalOpr);\n+          __ abs(src, dst, LIR_OprFact::illegalOpr);\n+          break;\n+        }\n+        case vmIntrinsics::_floatToFloat16: {\n+          LIR_Opr tmp = new_register(T_FLOAT);\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+          __ f2hf(src, dst, tmp);\n+          break;\n+        }\n+        case vmIntrinsics::_float16ToFloat: {\n+          LIR_Opr tmp = new_register(T_FLOAT);\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+          __ hf2f(src, dst, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -516,0 +516,4 @@\n+  void flt_to_flt16(Register dst, FloatRegister src, FloatRegister tmp) {\n+    fcvtsh(tmp, src);\n+    smov(dst, tmp, H, 0);\n+  }\n@@ -517,1 +521,4 @@\n-public:\n+  void flt16_to_flt(FloatRegister dst, Register src, FloatRegister tmp) {\n+    mov(tmp, H, 0, src);\n+    fcvths(dst, tmp);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -303,0 +303,44 @@\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n+    return nullptr;\n+  }\n+  \/\/ r19_sender_sp: sender sp\n+  \/\/ stack:\n+  \/\/        [ arg ] <-- esp\n+  \/\/        [ arg ]\n+  \/\/ retaddr in lr\n+  \/\/ result in v0\n+\n+  address entry_point = __ pc();\n+  __ ldrw(c_rarg0, Address(esp));\n+  __ flt16_to_flt(v0, c_rarg0, v1);\n+  __ mov(sp, r19_sender_sp); \/\/ Restore caller's SP\n+  __ br(lr);\n+  return entry_point;\n+}\n+\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n+    return nullptr;\n+  }\n+  \/\/ r19_sender_sp: sender sp\n+  \/\/ stack:\n+  \/\/        [ arg ] <-- esp\n+  \/\/        [ arg ]\n+  \/\/ retaddr in lr\n+  \/\/ result in c_rarg0\n+\n+  address entry_point = __ pc();\n+  __ ldrs(v0, Address(esp));\n+  __ flt_to_flt16(c_rarg0, v0, v1);\n+  __ mov(sp, r19_sender_sp); \/\/ Restore caller's SP\n+  __ br(lr);\n+  return entry_point;\n+}\n+\n@@ -1701,0 +1745,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+  static bool supports_float16() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -786,0 +786,2 @@\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1936,0 +1936,4 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1282,1 +1282,1 @@\n-void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {\n+void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {\n@@ -1286,0 +1286,2 @@\n+    case lir_f2hf: __ flt_to_flt16(dest->as_register(), value->as_float_reg(), tmp->as_float_reg()); break;\n+    case lir_hf2f: __ flt16_to_flt(dest->as_float_reg(), value->as_register(), tmp->as_float_reg()); break;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -645,1 +645,3 @@\n-    case vmIntrinsics::_dsqrt_strict: {\n+    case vmIntrinsics::_dsqrt_strict:\n+    case vmIntrinsics::_floatToFloat16:\n+    case vmIntrinsics::_float16ToFloat: {\n@@ -649,0 +651,1 @@\n+      LIR_Opr src = value.result();\n@@ -654,1 +657,1 @@\n-          __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n+          __ sqrt(src, dst, LIR_OprFact::illegalOpr);\n@@ -658,1 +661,13 @@\n-          __ abs(value.result(), dst, LIR_OprFact::illegalOpr);\n+          __ abs(src, dst, LIR_OprFact::illegalOpr);\n+          break;\n+        }\n+        case vmIntrinsics::_floatToFloat16: {\n+          LIR_Opr tmp = new_register(T_FLOAT);\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+          __ f2hf(src, dst, tmp);\n+          break;\n+        }\n+        case vmIntrinsics::_float16ToFloat: {\n+          LIR_Opr tmp = new_register(T_FLOAT);\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+          __ hf2f(src, dst, tmp);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1223,0 +1223,9 @@\n+  void flt_to_flt16(Register dst, FloatRegister src, FloatRegister tmp) {\n+    fcvt_h_s(tmp, src);\n+    fmv_x_h(dst, tmp);\n+  }\n+  void flt16_to_flt(FloatRegister dst, Register src, FloatRegister tmp) {\n+    fmv_h_x(tmp, src);\n+    fcvt_s_h(dst, tmp);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -8196,2 +8196,1 @@\n-    __ fmv_h_x($tmp$$FloatRegister, $src$$Register);\n-    __ fcvt_s_h($dst$$FloatRegister, $tmp$$FloatRegister);\n+    __ flt16_to_flt($dst$$FloatRegister, $src$$Register, $tmp$$FloatRegister);\n@@ -8214,2 +8213,1 @@\n-    __ fcvt_h_s($tmp$$FloatRegister, $src$$FloatRegister);\n-    __ fmv_x_h($dst$$Register, $tmp$$FloatRegister);\n+    __ flt_to_flt16($dst$$Register, $src$$FloatRegister, $tmp$$FloatRegister);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -304,0 +304,44 @@\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n+    return nullptr;\n+  }\n+  \/\/ x19_sender_sp: sender sp\n+  \/\/ stack:\n+  \/\/        [ arg ] <-- esp\n+  \/\/        [ arg ]\n+  \/\/ retaddr in ra\n+  \/\/ result in f10\n+\n+  address entry_point = __ pc();\n+  __ lw(c_rarg0, Address(esp));\n+  __ flt16_to_flt(f10, c_rarg0, f11);\n+  __ mv(sp, x19_sender_sp); \/\/ Restore caller's SP\n+  __ jr(ra);\n+  return entry_point;\n+}\n+\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n+    return nullptr;\n+  }\n+  \/\/ x19_sender_sp: sender sp\n+  \/\/ stack:\n+  \/\/        [ arg ] <-- esp\n+  \/\/        [ arg ]\n+  \/\/ retaddr in ra\n+  \/\/ result in c_rarg0\n+\n+  address entry_point = __ pc();\n+  __ flw(f10, Address(esp));\n+  __ flt_to_flt16(c_rarg0, f10, f11);\n+  __ mv(sp, x19_sender_sp); \/\/ Restore caller's SP\n+  __ jr(ra);\n+  return entry_point;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,2 @@\n+  static bool supports_float16() { return UseZfhmin; }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2006,0 +2006,4 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2457,0 +2457,4 @@\n+  } else if (code == lir_f2hf) {\n+    __ flt_to_flt16(dest->as_register(), value->as_xmm_float_reg(), tmp->as_xmm_float_reg());\n+  } else if (code == lir_hf2f) {\n+    __ flt16_to_flt(dest->as_xmm_float_reg(), value->as_register());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -835,0 +835,4 @@\n+  if (x->id() == vmIntrinsics::_floatToFloat16) {\n+    tmp = new_register(T_FLOAT);\n+    __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+  }\n@@ -844,0 +848,6 @@\n+    case vmIntrinsics::_floatToFloat16:\n+      __ f2hf(calc_input, calc_result, tmp);\n+      break;\n+    case vmIntrinsics::_float16ToFloat:\n+      __ hf2f(calc_input, calc_result, LIR_OprFact::illegalOpr);\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -165,0 +165,5 @@\n+  void incrementl(AddressLiteral dst, Register rscratch = noreg);\n+  void incrementl(ArrayAddress   dst, Register rscratch);\n+\n+  void incrementq(AddressLiteral dst, Register rscratch = noreg);\n+\n@@ -192,2 +197,7 @@\n-  void incrementl(AddressLiteral dst, Register rscratch = noreg);\n-  void incrementl(ArrayAddress   dst, Register rscratch);\n+  void flt_to_flt16(Register dst, XMMRegister src, XMMRegister tmp) {\n+    \/\/ Use separate tmp XMM register because caller may\n+    \/\/ requires src XMM register to be unchanged (as in x86.ad).\n+    vcvtps2ph(tmp, src, 0x04, Assembler::AVX_128bit);\n+    movdl(dst, tmp);\n+    movswl(dst, dst);\n+  }\n@@ -195,1 +205,4 @@\n-  void incrementq(AddressLiteral dst, Register rscratch = noreg);\n+  void flt16_to_flt(XMMRegister dst, Register src) {\n+    movdl(dst, src);\n+    vcvtph2ps(dst, dst, Assembler::AVX_128bit);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3512,0 +3512,51 @@\n+\/**\n+*  Arguments:\n+*\n+*  Input:\n+*    c_rarg0   - float16  jshort\n+*\n+*  Output:\n+*       xmm0   - float\n+*\/\n+address StubGenerator::generate_float16ToFloat() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+\n+  address start = __ pc();\n+\n+  BLOCK_COMMENT(\"Entry:\");\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ Load value into xmm0 and convert\n+  __ flt16_to_flt(xmm0, c_rarg0);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/**\n+*  Arguments:\n+*\n+*  Input:\n+*       xmm0   - float\n+*\n+*  Output:\n+*        rax   - float16  jshort\n+*\/\n+address StubGenerator::generate_floatToFloat16() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+\n+  address start = __ pc();\n+\n+  BLOCK_COMMENT(\"Entry:\");\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ Convert and put result into rax\n+  __ flt_to_flt16(rax, xmm0, xmm1);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n@@ -3877,0 +3928,10 @@\n+  if (VM_Version::supports_float16()) {\n+    \/\/ For results consistency both intrinsics should be enabled.\n+    \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToFloat) &&\n+        vmIntrinsics::is_intrinsic_available(vmIntrinsics::_floatToFloat16)) {\n+      StubRoutines::_hf2f = generate_float16ToFloat();\n+      StubRoutines::_f2hf = generate_floatToFloat16();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -473,0 +473,2 @@\n+  address generate_float16ToFloat();\n+  address generate_floatToFloat16();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,0 +317,52 @@\n+\/**\n+ * Method entry for static method:\n+ *    java.lang.Float.float16ToFloat(short floatBinary16)\n+ *\/\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n+    return nullptr; \/\/ Generate a vanilla entry\n+  }\n+  address entry = __ pc();\n+\n+  \/\/ rsi: the sender's SP\n+\n+  \/\/ Load value into xmm0 and convert\n+  __ movswl(rax, Address(rsp, wordSize));\n+  __ flt16_to_flt(xmm0, rax);\n+\n+  \/\/ Return\n+  __ pop(rdi); \/\/ get return address\n+  __ mov(rsp, rsi); \/\/ set rsp to the sender's SP\n+  __ jmp(rdi);\n+  return entry;\n+}\n+\n+\/**\n+ * Method entry for static method:\n+ *    java.lang.Float.floatToFloat16(float value)\n+ *\/\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat)) {\n+    return nullptr; \/\/ Generate a vanilla entry\n+  }\n+  address entry = __ pc();\n+\n+  \/\/ rsi: the sender's SP\n+\n+  \/\/ Load value into xmm0, convert and put result into rax\n+  __ movflt(xmm0, Address(rsp, wordSize));\n+  __ flt_to_flt16(rax, xmm0, xmm1);\n+\n+  \/\/ Return\n+  __ pop(rdi); \/\/ get return address\n+  __ mov(rsp, rsi); \/\/ set rsp to the sender's SP\n+  __ jmp(rdi);\n+  return entry;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_32.cpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -335,0 +335,54 @@\n+\/**\n+ * Method entry for static method:\n+ *    java.lang.Float.float16ToFloat(short floatBinary16)\n+ *\/\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n+    return nullptr; \/\/ Generate a vanilla entry\n+  }\n+  address entry = __ pc();\n+\n+  \/\/ r13: the sender's SP\n+\n+  \/\/ Load value into xmm0 and convert\n+  __ movswl(rax, Address(rsp, wordSize));\n+  __ flt16_to_flt(xmm0, rax);\n+\n+  \/\/ Return result in xmm0\n+  __ pop(rdi);      \/\/ get return address\n+  __ mov(rsp, r13); \/\/ set rsp to sender's SP\n+  __ jmp(rdi);\n+\n+  return entry;\n+}\n+\n+\/**\n+ * Method entry for static method:\n+ *    java.lang.Float.floatToFloat16(float value)\n+ *\/\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n+  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+  if (!VM_Version::supports_float16() ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16) ||\n+      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat)) {\n+    return nullptr; \/\/ Generate a vanilla entry\n+  }\n+  address entry = __ pc();\n+\n+  \/\/ r13: the sender's SP\n+\n+  \/\/ Load value into xmm0, convert and put result into rax\n+  __ movflt(xmm0, Address(rsp, wordSize));\n+  __ flt_to_flt16(rax, xmm0, xmm1);\n+\n+  \/\/ Return result in rax\n+  __ pop(rdi);      \/\/ get return address\n+  __ mov(rsp, r13); \/\/ set rsp to sender's SP\n+  __ jmp(rdi);\n+\n+  return entry;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -762,0 +762,5 @@\n+  \/\/ For AVX CPUs only. f16c support is disabled if UseAVX == 0.\n+  static bool supports_float16() {\n+    return supports_f16c() || supports_avx512vl();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1686,1 +1686,1 @@\n-      if (!VM_Version::supports_f16c() && !VM_Version::supports_avx512vl()) {\n+      if (!VM_Version::supports_float16()) {\n@@ -3668,3 +3668,1 @@\n-    __ vcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n-    __ movdl($dst$$Register, $tmp$$XMMRegister);\n-    __ movswl($dst$$Register, $dst$$Register);\n+    __ flt_to_flt16($dst$$Register, $src$$XMMRegister, $tmp$$XMMRegister);\n@@ -3712,2 +3710,1 @@\n-    __ movdl($dst$$XMMRegister, $src$$Register);\n-    __ vcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+    __ flt16_to_flt($dst$$XMMRegister, $src$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,4 @@\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!VM_Version::supports_float16()) return false;\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -566,0 +566,2 @@\n+    case lir_f2hf:\n+    case lir_hf2f:\n@@ -1734,0 +1736,2 @@\n+     case lir_f2hf:                  s = \"f2hf\";          break;\n+     case lir_hf2f:                  s = \"hf2f\";          break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -961,0 +961,2 @@\n+      , lir_f2hf\n+      , lir_hf2f\n@@ -2275,0 +2277,2 @@\n+  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_f2hf, from, tmp, to)); }\n+  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_hf2f, from, tmp, to)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -729,0 +729,2 @@\n+    case lir_f2hf:\n+    case lir_hf2f:\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2968,0 +2968,4 @@\n+  \/\/ Use java.lang.Math intrinsics code since it works for these intrinsics too.\n+  case vmIntrinsics::_floatToFloat16: \/\/ fall through\n+  case vmIntrinsics::_float16ToFloat: do_MathIntrinsic(x); break;\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -6730,0 +6730,2 @@\n+        case lir_f2hf:\n+        case lir_hf2f:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,0 +312,4 @@\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!InlineIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  virtual bool is_intrinsic_available(const methodHandle& method, DirectiveSet* directive) {\n+  bool is_intrinsic_available(const methodHandle& method, DirectiveSet* directive) {\n","filename":"src\/hotspot\/share\/compiler\/abstractCompiler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,2 @@\n+      case vmIntrinsics::_float16ToFloat:    return java_lang_Float_float16ToFloat;\n+      case vmIntrinsics::_floatToFloat16:    return java_lang_Float_floatToFloat16;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+    java_lang_Float_float16ToFloat,                             \/\/ implementation of java.lang.Float.float16ToFloat()\n+    java_lang_Float_floatToFloat16,                             \/\/ implementation of java.lang.Float.floatToFloat16()\n@@ -160,0 +162,2 @@\n+      case vmIntrinsics::_floatToFloat16       : \/\/ fall thru\n+      case vmIntrinsics::_float16ToFloat       : \/\/ fall thru\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -226,0 +226,3 @@\n+  method_entry(java_lang_Float_float16ToFloat);\n+  method_entry(java_lang_Float_floatToFloat16);\n+\n@@ -440,1 +443,4 @@\n-\n+  case Interpreter::java_lang_Float_float16ToFloat\n+                                           : entry_point = generate_Float_float16ToFloat_entry(); break;\n+  case Interpreter::java_lang_Float_floatToFloat16\n+                                           : entry_point = generate_Float_floatToFloat16_entry(); break;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -106,0 +106,3 @@\n+  address generate_Float_float16ToFloat_entry();\n+  address generate_Float_floatToFloat16_entry();\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -168,2 +169,4 @@\n-  if( t == Type::TOP ) return Type::TOP;\n-  if( t == Type::FLOAT ) return TypeInt::SHORT;\n+  if (t == Type::TOP) return Type::TOP;\n+  if (t == Type::FLOAT) return TypeInt::SHORT;\n+  if (StubRoutines::f2hf() == nullptr) return bottom_type();\n+\n@@ -174,5 +177,0 @@\n-\/\/------------------------------Identity---------------------------------------\n-Node* ConvF2HFNode::Identity(PhaseGVN* phase) {\n-  return (in(1)->Opcode() == Op_ConvHF2F) ? in(1)->in(1) : this;\n-}\n-\n@@ -241,4 +239,3 @@\n-  if( t == Type::TOP ) return Type::TOP;\n-  if( t == TypeInt::SHORT ) return Type::FLOAT;\n-  const TypeInt *ti = t->is_int();\n-  if ( ti->is_con() ) return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+  if (t == Type::TOP) return Type::TOP;\n+  if (t == TypeInt::SHORT) return Type::FLOAT;\n+  if (StubRoutines::hf2f() == nullptr) return bottom_type();\n@@ -246,0 +243,4 @@\n+  const TypeInt *ti = t->is_int();\n+  if (ti->is_con()) {\n+    return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+  }\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -181,0 +181,2 @@\n+  \/\/ Does platform support float16 instructions?\n+  static bool supports_float16() { return false; }\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -448,1 +448,0 @@\n-\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:floatToFloat16\n@@ -450,47 +449,3 @@\n-  union {jfloat f; jint i;} bits;\n-  bits.f = x;\n-  jint doppel = bits.i;\n-  jshort sign_bit = (jshort) ((doppel & 0x80000000) >> 16);\n-  if (g_isnan(x))\n-    return (jshort)(sign_bit | 0x7c00 | (doppel & 0x007fe000) >> 13 | (doppel & 0x00001ff0) >> 4 | (doppel & 0x0000000f));\n-\n-  jfloat abs_f = (x >= 0.0f) ? x : (x * -1.0f);\n-\n-  \/\/ Overflow threshold is halffloat max value + 1\/2 ulp\n-  if (abs_f >= (65504.0f + 16.0f)) {\n-    return (jshort)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n-  }\n-\n-  \/\/ Smallest magnitude of Halffloat is 0x1.0p-24, half-way or smaller rounds to zero\n-  if (abs_f <= (pow(2, -24) * 0.5f)) { \/\/ Covers float zeros and subnormals.\n-    return sign_bit; \/\/ Positive or negative zero\n-  }\n-\n-  jint exp = ((0x7f800000 & doppel) >> (24 - 1)) - 127;\n-\n-  \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n-  \/\/ the difference exp_delta = E_min - exp.  This is the excess\n-  \/\/ shift value, in addition to 13, to be used in the\n-  \/\/ computations below. Further the (hidden) msb with value 1\n-  \/\/ in f must be involved as well\n-  jint exp_delta = 0;\n-  jint msb = 0x00000000;\n-  if (exp < -14) {\n-    exp_delta = -14 - exp;\n-    exp = -15;\n-    msb = 0x00800000;\n-  }\n-  jint f_signif_bits = ((doppel & 0x007fffff) | msb);\n-\n-  \/\/ Significand bits as if using rounding to zero\n-  jshort signif_bits = (jshort)(f_signif_bits >> (13 + exp_delta));\n-\n-  jint lsb = f_signif_bits & (1 << (13 + exp_delta));\n-  jint round  = f_signif_bits & (1 << (12 + exp_delta));\n-  jint sticky = f_signif_bits & ((1 << (12 + exp_delta)) - 1);\n-\n-  if (round != 0 && ((lsb | sticky) != 0 )) {\n-    signif_bits++;\n-  }\n-\n-  return (jshort)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+  assert(StubRoutines::f2hf() != nullptr, \"floatToFloat16 intrinsic is not supported on this platform\");\n+  typedef jshort (*f2hf_stub_t)(jfloat x);\n+  return ((f2hf_stub_t)StubRoutines::f2hf())(x);\n@@ -499,1 +454,0 @@\n-\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:float16ToFloat\n@@ -501,37 +455,3 @@\n-  \/\/ Halffloat format has 1 signbit, 5 exponent bits and\n-  \/\/ 10 significand bits\n-  union {jfloat f; jint i;} bits;\n-  jint hf_arg = (jint)x;\n-  jint hf_sign_bit = 0x8000 & hf_arg;\n-  jint hf_exp_bits = 0x7c00 & hf_arg;\n-  jint hf_significand_bits = 0x03ff & hf_arg;\n-\n-  jint significand_shift = 13; \/\/difference between float and halffloat precision\n-\n-  jfloat sign = (hf_sign_bit != 0) ? -1.0f : 1.0f;\n-\n-  \/\/ Extract halffloat exponent, remove its bias\n-  jint hf_exp = (hf_exp_bits >> 10) - 15;\n-\n-  if (hf_exp == -15) {\n-    \/\/ For subnormal values, return 2^-24 * significand bits\n-    return (sign * (pow(2,-24)) * hf_significand_bits);\n-  } else if (hf_exp == 16) {\n-    if (hf_significand_bits == 0) {\n-      bits.i = 0x7f800000;\n-      return sign * bits.f;\n-    } else {\n-      bits.i = (hf_sign_bit << 16) | 0x7f800000 |\n-               (hf_significand_bits << significand_shift);\n-      return bits.f;\n-    }\n-  }\n-\n-  \/\/ Add the bias of float exponent and shift\n-  jint float_exp_bits = (hf_exp + 127) << (24 - 1);\n-\n-  \/\/ Combine sign, exponent and significand bits\n-  bits.i = (hf_sign_bit << 16) | float_exp_bits |\n-           (hf_significand_bits << significand_shift);\n-\n-  return bits.f;\n+  assert(StubRoutines::hf2f() != nullptr, \"float16ToFloat intrinsic is not supported on this platform\");\n+  typedef jfloat (*hf2f_stub_t)(jshort x);\n+  return ((hf2f_stub_t)StubRoutines::hf2f())(x);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":86,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -131,2 +131,0 @@\n-  static jfloat  hf2f(jshort  x);\n-  static jshort  f2hf(jfloat  x);\n@@ -140,0 +138,6 @@\n+  \/\/ These are versions of the java.lang.Float methods which perform\n+  \/\/ the same operations as the intrinsic version.  They are used for\n+  \/\/ constant folding in the compiler to ensure equivalence.\n+  static jfloat  hf2f(jshort  x);\n+  static jshort  f2hf(jfloat  x);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+address StubRoutines::_f2hf = nullptr;\n+address StubRoutines::_hf2f = nullptr;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -252,0 +252,3 @@\n+  static address _f2hf;\n+  static address _hf2f;\n+\n@@ -427,0 +430,3 @@\n+  static address f2hf()                { return _f2hf; }\n+  static address hf2f()                { return _hf2f; }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,436 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289551 8302976\n+ * @summary Verify conversion between float and the binary16 format\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @comment default run\n+ * @run main Binary16Conversion\n+ * @comment C1 JIT compilation only:\n+ * @run main\/othervm -Xcomp -XX:TieredStopAtLevel=1 -XX:CompileCommand=compileonly,Binary16Conversion::test* Binary16Conversion\n+ * @comment C2 JIT compilation only:\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,Binary16Conversion::test* Binary16Conversion\n+ *\/\n+\n+public class Binary16Conversion {\n+\n+    public static final int FLOAT_SIGNIFICAND_WIDTH   = 24;\n+\n+    public static void main(String... argv) {\n+        System.out.println(\"Start ...\");\n+        short s = Float.floatToFloat16(0.0f); \/\/ Load Float class\n+\n+        int errors = 0;\n+        errors += testBinary16RoundTrip();\n+        \/\/ Note that helper methods do sign-symmetric testing\n+        errors += testBinary16CardinalValues();\n+        errors += testRoundFloatToBinary16();\n+        errors += testRoundFloatToBinary16HalfWayCases();\n+        errors += testRoundFloatToBinary16FullBinade();\n+        errors += testAlternativeImplementation();\n+\n+        if (errors > 0)\n+            throw new RuntimeException(errors + \" errors\");\n+    }\n+\n+    \/*\n+     * Put all 16-bit values through a conversion loop and make sure\n+     * the values are preserved (NaN bit patterns notwithstanding).\n+     *\/\n+    private static int testBinary16RoundTrip() {\n+        int errors = 0;\n+        for (int i = Short.MIN_VALUE; i < Short.MAX_VALUE; i++) {\n+            short s = (short)i;\n+            float f =  Float.float16ToFloat(s);\n+            short s2 = Float.floatToFloat16(f);\n+\n+            if (!Binary16.equivalent(s, s2)) {\n+                errors++;\n+                System.out.println(\"Roundtrip failure on \" +\n+                                   Integer.toHexString(0xFFFF & (int)s) +\n+                                   \"\\t got back \" + Integer.toHexString(0xFFFF & (int)s2));\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    private static int testBinary16CardinalValues() {\n+        int errors = 0;\n+        \/\/ Encode short value for different binary16 cardinal values as an\n+        \/\/ integer-valued float.\n+        float[][] testCases = {\n+            {Binary16.POSITIVE_ZERO,         +0.0f},\n+            {Binary16.MIN_VALUE,              0x1.0p-24f},\n+            {Binary16.MAX_SUBNORMAL,          0x1.ff8p-15f},\n+            {Binary16.MIN_NORMAL,             0x1.0p-14f},\n+            {Binary16.ONE,                    1.0f},\n+            {Binary16.MAX_VALUE,              65504.0f},\n+            {Binary16.POSITIVE_INFINITY,      Float.POSITIVE_INFINITY},\n+        };\n+\n+        \/\/ Check conversions in both directions\n+\n+        \/\/ short -> float\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError((short)testCase[0],\n+                                            testCase[1]);\n+        }\n+\n+        \/\/ float -> short\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[1],\n+                                            (short)testCase[0]);\n+        }\n+\n+        return errors;\n+    }\n+\n+    private static int testRoundFloatToBinary16() {\n+        int errors = 0;\n+\n+        float[][] testCases = {\n+            \/\/ Test all combinations of LSB, round, and sticky bit\n+\n+            \/\/ LSB = 0, test combination of round and sticky\n+            {0x1.ff8000p-1f,       (short)0x3bfe},              \/\/ round = 0, sticky = 0\n+            {0x1.ff8010p-1f,       (short)0x3bfe},              \/\/ round = 0, sticky = 1\n+            {0x1.ffa000p-1f,       (short)0x3bfe},              \/\/ round = 1, sticky = 0\n+            {0x1.ffa010p-1f,       (short)0x3bff},              \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ LSB = 1, test combination of round and sticky\n+            {0x1.ffc000p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 0\n+            {0x1.ffc010p-1f,       Binary16.ONE-1},             \/\/ round = 0, sticky = 1\n+            {0x1.ffe000p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe010p-1f,       Binary16.ONE},               \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test subnormal rounding\n+            \/\/ Largest subnormal binary16 0x03ff => 0x1.ff8p-15f; LSB = 1\n+            {0x1.ff8000p-15f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 0\n+            {0x1.ff8010p-15f,      Binary16.MAX_SUBNORMAL},     \/\/ round = 0, sticky = 1\n+            {0x1.ffc000p-15f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffc010p-15f,      Binary16.MIN_NORMAL},        \/\/ round = 1, sticky = 1 => ++\n+\n+            \/\/ Test rounding near binary16 MIN_VALUE\n+            \/\/ Smallest in magnitude subnormal binary16 value 0x0001 => 0x1.0p-24f\n+            \/\/ Half-way case,0x1.0p-25f, and smaller should round down to zero\n+            {0x1.fffffep-26f,      Binary16.POSITIVE_ZERO},     \/\/ nextDown in float\n+            {0x1.000000p-25f,      Binary16.POSITIVE_ZERO},\n+            {0x1.000002p-25f,      Binary16.MIN_VALUE},         \/\/ nextUp in float\n+            {0x1.100000p-25f,      Binary16.MIN_VALUE},\n+\n+            \/\/ Test rounding near overflow threshold\n+            \/\/ Largest normal binary16 number 0x7bff => 0x1.ffcp15f; LSB = 1\n+            {0x1.ffc000p15f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 0\n+            {0x1.ffc010p15f,       Binary16.MAX_VALUE},         \/\/ round = 0, sticky = 1\n+            {0x1.ffe000p15f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 0 => ++\n+            {0x1.ffe010p15f,       Binary16.POSITIVE_INFINITY}, \/\/ round = 1, sticky = 1 => ++\n+        };\n+\n+        for (var testCase : testCases) {\n+            errors += compareAndReportError(testCase[0],\n+                                            (short)testCase[1]);\n+        }\n+        return errors;\n+    }\n+\n+    private static int testRoundFloatToBinary16HalfWayCases() {\n+        int errors = 0;\n+\n+        \/\/ Test rounding of exact half-way cases between each pair of\n+        \/\/ finite exactly-representable binary16 numbers. Also test\n+        \/\/ rounding of half-way +\/- ulp of the *float* value.\n+        \/\/ Additionally, test +\/- float ulp of the endpoints. (Other\n+        \/\/ tests in this file make sure all short values round-trip so\n+        \/\/ that doesn't need to be tested here.)\n+\n+        for (int i = Binary16.POSITIVE_ZERO; \/\/ 0x0000\n+             i    <= Binary16.MAX_VALUE;     \/\/ 0x7bff\n+             i += 2) {     \/\/ Check every even\/odd pair once\n+            short lower = (short) i;\n+            short upper = (short)(i+1);\n+\n+            float lowerFloat = Float.float16ToFloat(lower);\n+            float upperFloat = Float.float16ToFloat(upper);\n+            assert lowerFloat < upperFloat;\n+\n+            float midway = (lowerFloat + upperFloat) * 0.5f; \/\/ Exact midpoint\n+\n+            errors += compareAndReportError(Math.nextUp(lowerFloat),   lower);\n+            errors += compareAndReportError(Math.nextDown(midway),     lower);\n+\n+            \/\/ Under round to nearest even, the midway point will\n+            \/\/ round *down* to the (even) lower endpoint.\n+            errors += compareAndReportError(              midway,      lower);\n+\n+            errors += compareAndReportError(Math.nextUp(  midway),     upper);\n+            errors += compareAndReportError(Math.nextDown(upperFloat), upper);\n+        }\n+\n+        \/\/ More testing around the overflow threshold\n+        \/\/ Binary16.ulp(Binary16.MAX_VALUE) == 32.0f; test around Binary16.MAX_VALUE + 1\/2 ulp\n+        float binary16_MAX_VALUE = Float.float16ToFloat(Binary16.MAX_VALUE);\n+        float binary16_MAX_VALUE_halfUlp = binary16_MAX_VALUE + 16.0f;\n+\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE,  Binary16.MAX_VALUE);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE), Binary16.MAX_VALUE);\n+\n+        \/\/ Binary16.MAX_VALUE is an \"odd\" value since its LSB = 1 so\n+        \/\/ the half-way value greater than Binary16.MAX_VALUE should\n+        \/\/ round up to the next even value, in this case Binary16.POSITIVE_INFINITY.\n+        errors += compareAndReportError(Math.nextDown(binary16_MAX_VALUE_halfUlp), Binary16.MAX_VALUE);\n+        errors += compareAndReportError(              binary16_MAX_VALUE_halfUlp,  Binary16.POSITIVE_INFINITY);\n+        errors += compareAndReportError(Math.nextUp(  binary16_MAX_VALUE_halfUlp), Binary16.POSITIVE_INFINITY);\n+\n+        return errors;\n+    }\n+\n+    private static int compareAndReportError(float input,\n+                                             short expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0( input,                 expected) +\n+               compareAndReportError0(-input, Binary16.negate(expected));\n+    }\n+\n+    private static int compareAndReportError0(float input,\n+                                              short expected) {\n+        short actual = Float.floatToFloat16(input);\n+        if (!Binary16.equivalent(actual, expected)) {\n+            System.out.println(\"Unexpected result of converting \" +\n+                               Float.toHexString(input) +\n+                               \" to short. Expected 0x\" + Integer.toHexString(0xFFFF & expected) +\n+                               \" got 0x\" + Integer.toHexString(0xFFFF & actual));\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError0(short input,\n+                                              float expected) {\n+        float actual = Float.float16ToFloat(input);\n+        if (Float.compare(actual, expected) != 0) {\n+            System.out.println(\"Unexpected result of converting \" +\n+                               Integer.toHexString(input & 0xFFFF) +\n+                               \" to float. Expected \" + Float.toHexString(expected) +\n+                               \" got \" + Float.toHexString(actual));\n+            return 1;\n+            }\n+        return 0;\n+    }\n+\n+    private static int compareAndReportError(short input,\n+                                             float expected) {\n+        \/\/ Round to nearest even is sign symmetric\n+        return compareAndReportError0(                input,   expected) +\n+               compareAndReportError0(Binary16.negate(input), -expected);\n+    }\n+\n+    private static int testRoundFloatToBinary16FullBinade() {\n+        int errors = 0;\n+\n+        \/\/ For each float value between 1.0 and less than 2.0\n+        \/\/ (i.e. set of float values with an exponent of 0), convert\n+        \/\/ each value to binary16 and then convert that binary16 value\n+        \/\/ back to float.\n+        \/\/\n+        \/\/ Any exponent could be used; the maximum exponent for normal\n+        \/\/ values would not exercise the full set of code paths since\n+        \/\/ there is an up-front check on values that would overflow,\n+        \/\/ which correspond to a ripple-carry of the significand that\n+        \/\/ bumps the exponent.\n+        short previous = (short)0;\n+        for (int i = Float.floatToIntBits(1.0f);\n+             i <= Float.floatToIntBits(Math.nextDown(2.0f));\n+             i++) {\n+            \/\/ (Could also express the loop control directly in terms\n+            \/\/ of floating-point operations, incrementing by ulp(1.0),\n+            \/\/ etc.)\n+\n+            float f = Float.intBitsToFloat(i);\n+            short f_as_bin16 = Float.floatToFloat16(f);\n+            short f_as_bin16_down = (short)(f_as_bin16 - 1);\n+            short f_as_bin16_up   = (short)(f_as_bin16 + 1);\n+\n+            \/\/ Across successive float values to convert to binary16,\n+            \/\/ the binary16 results should be semi-monotonic,\n+            \/\/ non-decreasing in this case.\n+\n+            \/\/ Only positive binary16 values so can compare using integer operations\n+            if (f_as_bin16 < previous) {\n+                errors++;\n+                System.out.println(\"Semi-monotonicity violation observed on loat: \" + Float.toHexString(f) + \"\/\" + Integer.toHexString(i) + \" \" +\n+                                   Integer.toHexString(0xffff & f_as_bin16) + \" previous: \" + Integer.toHexString(0xffff & previous) + \" f_as_bin16: \" + Integer.toHexString(0xffff & f_as_bin16));\n+            }\n+            \/\/ previous = f_as_bin16;\n+\n+            \/\/ If round-to-nearest was correctly done, when exactly\n+            \/\/ mapped back to float, f_as_bin16 should be at least as\n+            \/\/ close as either of its neighbors to the original value\n+            \/\/ of f.\n+\n+            float f_prime_down = Float.float16ToFloat(f_as_bin16_down);\n+            float f_prime      = Float.float16ToFloat(f_as_bin16);\n+            float f_prime_up   = Float.float16ToFloat(f_as_bin16_up);\n+\n+            previous = f_as_bin16;\n+\n+            float f_prime_diff = Math.abs(f - f_prime);\n+            if (f_prime_diff == 0.0) {\n+                continue;\n+            }\n+            float f_prime_down_diff = Math.abs(f - f_prime_down);\n+            float f_prime_up_diff   = Math.abs(f - f_prime_up);\n+\n+            if (f_prime_diff > f_prime_down_diff ||\n+                f_prime_diff > f_prime_up_diff) {\n+                errors++;\n+                System.out.println(\"Round-to-nearest violation on converting \" +\n+                                   Float.toHexString(f) + \"\/\" + Integer.toHexString(i) + \" to binary16 and back: \" + Integer.toHexString(0xffff & f_as_bin16) + \" f_prime: \" + Float.toHexString(f_prime));\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    private static int testAlternativeImplementation() {\n+        int errors = 0;\n+\n+        \/\/ For exhaustive test of all float values use\n+        \/\/ for (long ell = Integer.MIN_VALUE; ell <= Integer.MAX_VALUE; ell++) {\n+\n+        for (long ell   = Float.floatToIntBits(2.0f);\n+             ell       <= Float.floatToIntBits(4.0f);\n+             ell++) {\n+            float f = Float.intBitsToFloat((int)ell);\n+            short s1 = Float.floatToFloat16(f);\n+            short s2 =    testAltFloatToFloat16(f);\n+\n+            if (s1 != s2) {\n+                errors++;\n+                System.out.println(\"Different conversion of float value \" + Float.toHexString(f));\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    \/*\n+     * Rely on float operations to do rounding in both normal and\n+     * subnormal binary16 cases.\n+     *\/\n+    public static short testAltFloatToFloat16(float f) {\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel & 0x8000_0000) >> 16);\n+\n+        if (Float.isNaN(f)) {\n+            \/\/ Preserve sign and attempt to preserve significand bits\n+            return (short)(sign_bit\n+                    | 0x7c00 \/\/ max exponent + 1\n+                    \/\/ Preserve high order bit of float NaN in the\n+                    \/\/ binary16 result NaN (tenth bit); OR in remaining\n+                    \/\/ bits into lower 9 bits of binary 16 significand.\n+                    | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+                    | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+                    | (doppel & 0x0000_000f));     \/\/  4 bits\n+        }\n+\n+        float abs_f = Math.abs(f);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_f >= (65504.0f + 16.0f) ) {\n+            return (short)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+        } else {\n+            \/\/ Smallest magnitude nonzero representable binary16 value\n+            \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+            if (abs_f <= 0x1.0p-25f) { \/\/ Covers float zeros and subnormals.\n+                return sign_bit; \/\/ Positive or negative zero\n+            }\n+\n+            \/\/ Dealing with finite values in exponent range of\n+            \/\/ binary16 (when rounding is done, could still round up)\n+            int exp = Math.getExponent(f);\n+            assert -25 <= exp && exp <= 15;\n+            short signif_bits;\n+\n+            if (exp <= -15) { \/\/ scale down to float subnormal range to do rounding\n+                \/\/ Use a float multiply to compute the correct\n+                \/\/ trailing significand bits for a binary16 subnormal.\n+                \/\/\n+                \/\/ The exponent range of normalized binary16 subnormal\n+                \/\/ values is [-24, -15]. The exponent range of float\n+                \/\/ subnormals is [-149, -140]. Multiply abs_f down by\n+                \/\/ 2^(-125) -- since (-125 = -149 - (-24)) -- so that\n+                \/\/ the trailing bits of a subnormal float represent\n+                \/\/ the correct trailing bits of a binary16 subnormal.\n+                exp = -15; \/\/ Subnormal encoding using -E_max.\n+                float f_adjust = abs_f * 0x1.0p-125f;\n+\n+                \/\/ In case the significand rounds up and has a carry\n+                \/\/ propagate all the way up, take the bottom 11 bits\n+                \/\/ rather than bottom 10 bits. Adding this value,\n+                \/\/ rather than OR'ing htis value, will cause the right\n+                \/\/ exponent adjustment.\n+                signif_bits = (short)(Float.floatToRawIntBits(f_adjust) & 0x07ff);\n+                return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+            } else {\n+                \/\/ Scale down to subnormal range to round off excess bits\n+                int scalingExp = -139 - exp;\n+                float scaled = Math.scalb(Math.scalb(f, scalingExp),\n+                                                       -scalingExp);\n+                exp = Math.getExponent(scaled);\n+                doppel = Float.floatToRawIntBits(scaled);\n+\n+                signif_bits = (short)((doppel & 0x007f_e000) >>\n+                                      (FLOAT_SIGNIFICAND_WIDTH - 11));\n+                return (short)(sign_bit | ( ((exp + 15) << 10) | signif_bits ) );\n+            }\n+        }\n+    }\n+\n+    public static class Binary16 {\n+        public static final short POSITIVE_INFINITY = (short)0x7c00;\n+        public static final short MAX_VALUE         = 0x7bff;\n+        public static final short ONE               = 0x3c00;\n+        public static final short MIN_NORMAL        = 0x0400;\n+        public static final short MAX_SUBNORMAL     = 0x03ff;\n+        public static final short MIN_VALUE         = 0x0001;\n+        public static final short POSITIVE_ZERO     = 0x0000;\n+\n+        public static boolean isNaN(short binary16) {\n+            return ((binary16 & 0x7c00) == 0x7c00) \/\/ Max exponent and...\n+                && ((binary16 & 0x03ff) != 0 );    \/\/ significand nonzero.\n+        }\n+\n+        public static short negate(short binary16) {\n+            return (short)(binary16 ^ 0x8000 ); \/\/ Flip only sign bit.\n+        }\n+\n+        public static boolean equivalent(short bin16_1, short bin16_2) {\n+            return (bin16_1 == bin16_2) ||\n+                isNaN(bin16_1) && isNaN(bin16_2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16Conversion.java","additions":436,"deletions":0,"binary":false,"changes":436,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289551 8302976\n+ * @summary Verify NaN sign and significand bits are preserved across conversions\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xmixed -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileThresholdScaling=1000.0 Binary16ConversionNaN\n+ *\/\n+\n+\/*\n+ * The behavior tested below is an implementation property not\n+ * required by the specification. It would be acceptable for this\n+ * information to not be preserved (as long as a NaN is returned) if,\n+ * say, a intrinsified version using native hardware instructions\n+ * behaved differently.\n+ *\n+ * If that is the case, this test should be modified to disable\n+ * intrinsics or to otherwise not run on platforms with an differently\n+ * behaving intrinsic.\n+ *\/\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Method;\n+\n+public class Binary16ConversionNaN {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/*\n+     * Put all 16-bit NaN values through a conversion loop and make\n+     * sure the significand, sign, and exponent are all preserved.\n+     *\/\n+    public static void main(String... argv) throws NoSuchMethodException {\n+        int errors = 0;\n+        final int NAN_EXPONENT = 0x7c00;\n+        final int SIGN_BIT     = 0x8000;\n+\n+        \/\/ First, run with Interpreter only to  collect \"gold\" data.\n+        \/\/ Glags -Xmixed -XX:CompileThresholdScaling=1000.0 are used\n+        \/\/ to prevent compilation during this phase.\n+        short[] pVal = new short[1024];\n+        short[] pRes = new short[1024];\n+        short[] nVal = new short[1024];\n+        short[] nRes = new short[1024];\n+\n+        \/\/ A NaN has a nonzero significand\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            short binary16NaN = (short)(NAN_EXPONENT | i);\n+            assert isNaN(binary16NaN);\n+            short s1 = testRoundTrip(binary16NaN);\n+            errors  += verify(binary16NaN, s1);\n+            pVal[i] = binary16NaN;\n+            pRes[i] = s1;\n+\n+            short binary16NegNaN = (short)(SIGN_BIT | binary16NaN);\n+            short s2 = testRoundTrip(binary16NegNaN);\n+            errors  += verify(binary16NegNaN, s2);\n+            nVal[i] = binary16NegNaN;\n+            nRes[i] = s2;\n+        }\n+        if (errors > 0) { \/\/ Exit if Interpreter failed\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+\n+        Method test_method = Binary16ConversionNaN.class.getDeclaredMethod(\"testRoundTrip\", short.class);\n+\n+        \/\/ Compile with C1 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C1\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            short s1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], s1, \"C1\");\n+            short s2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], s2, \"C1\");\n+        }\n+\n+        WHITE_BOX.deoptimizeMethod(test_method);\n+\n+        \/\/ Compile with C2 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C2\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            short s1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], s1, \"C2\");\n+            short s2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], s2, \"C2\");\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+    }\n+\n+    private static boolean isNaN(short binary16) {\n+        return ((binary16 & 0x7c00) == 0x7c00) \/\/ Max exponent and...\n+            && ((binary16 & 0x03ff) != 0 );    \/\/ significand nonzero.\n+    }\n+\n+    private static short testRoundTrip(short i) {\n+        float f =  Float.float16ToFloat(i);\n+        return Float.floatToFloat16(f);\n+    }\n+\n+    private static int verify(short s, short s2) {\n+        int errors = 0;\n+        if ((s & ~0x0200) != (s2 & ~0x0200)) { \/\/ ignore QNaN bit\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(0xFFFF & (int)s) +\n+                               \"\\t got back \" + Integer.toHexString(0xFFFF & (int)s2));\n+        }\n+        return errors;\n+    }\n+\n+    private static int verifyCompiler(short s, short s2, String name) {\n+        int errors = 0;\n+        if (s != s2) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(0xFFFF & (int)s) +\n+                               \"\\t got back \" + Integer.toHexString(0xFFFF & (int)s2) +\n+                               \"\\t from \" + name + \" code\");\n+        }\n+        return errors;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302976\n+ * @summary Verify conversion between float and the binary16 format\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @comment default run:\n+ * @run main TestAllFloat16ToFloat\n+ * @comment disable intrinsics:\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 TestAllFloat16ToFloat\n+ * @comment eager JIT compilation:\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestAllFloat16ToFloat::test* -Xbatch TestAllFloat16ToFloat\n+ * @comment C2 JIT compilation only:\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestAllFloat16ToFloat::test* -Xbatch -XX:-TieredCompilation TestAllFloat16ToFloat\n+ * @comment C1 JIT compilation only:\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestAllFloat16ToFloat::test* -Xbatch -XX:TieredStopAtLevel=1 TestAllFloat16ToFloat\n+ *\/\n+\n+public class TestAllFloat16ToFloat {\n+    public static short testFloatToFloat16(float f) {\n+        return Float.floatToFloat16(f);\n+    }\n+\n+    public static float testFloat16ToFloat(short s) {\n+        return Float.float16ToFloat(s);\n+    }\n+\n+    public static short testRoundTrip(short s) {\n+        return Float.floatToFloat16(Float.float16ToFloat(s));\n+    }\n+\n+    public static void verify(short sVal, float fVal, short sRes) {\n+        if (sRes != sVal) {\n+            if (!Float.isNaN(fVal) || ((sRes & ~0x0200) != (sVal & ~0x0200)) ) {\n+                String fVal_hex = Integer.toHexString(Float.floatToRawIntBits(fVal));\n+                String sRes_hex = Integer.toHexString(sRes & 0xffff);\n+                String sVal_hex = Integer.toHexString(sVal & 0xffff);\n+              throw new RuntimeException(\"Inconsistent result for Float.floatToFloat16(\" + fVal + \"\/\" + fVal_hex + \"): \" + sRes_hex + \" != \" + sVal_hex);\n+           }\n+        }\n+    }\n+\n+    public static void run() {\n+        \/\/ Testing all float16 values.\n+        for (short sVal = Short.MIN_VALUE; sVal < Short.MAX_VALUE; ++sVal) {\n+            float fVal = Float.float16ToFloat(sVal);\n+            short sRes = testFloatToFloat16(fVal);\n+            verify(sVal, fVal, sRes);\n+            float fRes = testFloat16ToFloat(sVal);\n+            if (!Float.isNaN(fRes) && fRes != fVal) {\n+                String sVal_hex = Integer.toHexString(sVal & 0xffff);\n+                String fRes_hex = Integer.toHexString(Float.floatToRawIntBits(fRes));\n+                String fVal_hex = Integer.toHexString(Float.floatToRawIntBits(fVal));\n+                throw new RuntimeException(\"Inconsistent result for Float.float16ToFloat(\" + sVal_hex + \"): \" + fRes + \"\/\" + fRes_hex + \" != \" + fVal + \"\/\" + fVal_hex);\n+            }\n+            sRes = testRoundTrip(sVal);\n+            verify(sVal, fVal, sRes);\n+            if (Float.floatToFloat16(fRes) != Float.floatToFloat16(fVal)) {\n+                String sVal_hex = Integer.toHexString(sVal & 0xffff);\n+                String sfRes_hex = Integer.toHexString(Float.floatToFloat16(fRes) & 0xffff);\n+                String sfVal_hex = Integer.toHexString(Float.floatToFloat16(fVal)& 0xffff);\n+                throw new RuntimeException(\"Inconsistent result for Float.float16ToFloat(\" + sVal_hex + \"): \" + sfRes_hex + \" != \" + sfVal_hex);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Run twice to trigger compilation\n+        for (int i = 0; i < 2; i++) {\n+            run();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestAllFloat16ToFloat.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302976\n+ * @summary Verify conversion cons between float and the binary16 format\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @comment default run:\n+ * @run main TestConstFloat16ToFloat\n+ * @comment C1 JIT compilation only:\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,TestConstFloat16ToFloat::test* -XX:TieredStopAtLevel=1 TestConstFloat16ToFloat\n+ * @comment C2 JIT compilation only:\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,TestConstFloat16ToFloat::test* -XX:-TieredCompilation TestConstFloat16ToFloat\n+ *\/\n+\n+public class TestConstFloat16ToFloat {\n+\n+    public static class Binary16 {\n+        public static final short POSITIVE_INFINITY = (short)0x7c00;\n+        public static final short MAX_VALUE         = 0x7bff;\n+        public static final short ONE               = 0x3c00;\n+        public static final short MIN_NORMAL        = 0x0400;\n+        public static final short MAX_SUBNORMAL     = 0x03ff;\n+        public static final short MIN_VALUE         = 0x0001;\n+        public static final short POSITIVE_ZERO     = 0x0000;\n+    }\n+\n+    static final short[] sCon = {\n+        Short.MIN_VALUE,\n+        Short.MIN_VALUE + 1,\n+        -1,\n+        0,\n+        +1,\n+        Short.MAX_VALUE - 1,\n+        Short.MAX_VALUE,\n+        Binary16.MIN_VALUE,\n+        Binary16.MIN_NORMAL,\n+        Binary16.POSITIVE_ZERO,\n+        Binary16.ONE,\n+        Binary16.MAX_VALUE,\n+        Binary16.MAX_SUBNORMAL,\n+        Binary16.POSITIVE_INFINITY\n+    };\n+\n+    public final static class BinaryF16 {\n+        public static final float POSITIVE_INFINITY = Float.POSITIVE_INFINITY;\n+        public static final float MAX_VALUE         = 65504.0f;\n+        public static final float ONE               = 1.0f;\n+        public static final float MIN_NORMAL        = 0x1.0p-14f;\n+        public static final float MAX_SUBNORMAL     = 0x1.ff8p-15f;\n+        public static final float MIN_VALUE         = 0x1.0p-24f;\n+        public static final float POSITIVE_ZERO     = +0x0f;\n+    }\n+\n+    static float[] fCon = {\n+        0.0f - BinaryF16.POSITIVE_INFINITY,\n+        0.0f - BinaryF16.MAX_VALUE,\n+        0.0f - BinaryF16.MAX_SUBNORMAL,\n+        0.0f - BinaryF16.MIN_VALUE,\n+        0.0f - BinaryF16.MIN_NORMAL,\n+        -1.0f,\n+        -0.0f,\n+        BinaryF16.MIN_VALUE,\n+        BinaryF16.MIN_NORMAL,\n+        BinaryF16.POSITIVE_ZERO,\n+        BinaryF16.ONE,\n+        BinaryF16.MAX_VALUE,\n+        BinaryF16.MAX_SUBNORMAL,\n+        BinaryF16.POSITIVE_INFINITY\n+    };\n+\n+    \/\/ Testing some constant values (optimized by C2).\n+    public static void testFloat16Const(float[] fRes) {\n+        fRes[ 0] = Float.float16ToFloat(Short.MIN_VALUE);\n+        fRes[ 1] = Float.float16ToFloat((short)(Short.MIN_VALUE + 1));\n+        fRes[ 2] = Float.float16ToFloat((short)-1);\n+        fRes[ 3] = Float.float16ToFloat((short)0);\n+        fRes[ 4] = Float.float16ToFloat((short)+1);\n+        fRes[ 5] = Float.float16ToFloat((short)(Short.MAX_VALUE - 1));\n+        fRes[ 6] = Float.float16ToFloat(Short.MAX_VALUE);\n+        fRes[ 7] = Float.float16ToFloat(Binary16.MIN_VALUE);\n+        fRes[ 8] = Float.float16ToFloat(Binary16.MIN_NORMAL);\n+        fRes[ 9] = Float.float16ToFloat(Binary16.POSITIVE_ZERO);\n+        fRes[10] = Float.float16ToFloat(Binary16.ONE);\n+        fRes[11] = Float.float16ToFloat(Binary16.MAX_VALUE);\n+        fRes[12] = Float.float16ToFloat(Binary16.MAX_SUBNORMAL);\n+        fRes[13] = Float.float16ToFloat(Binary16.POSITIVE_INFINITY);\n+    }\n+\n+    public static void testFloatConst(short[] sRes) {\n+        sRes[ 0] = Float.floatToFloat16(0.0f - BinaryF16.POSITIVE_INFINITY);\n+        sRes[ 1] = Float.floatToFloat16(0.0f - BinaryF16.MAX_VALUE);\n+        sRes[ 2] = Float.floatToFloat16(0.0f - BinaryF16.MAX_SUBNORMAL);\n+        sRes[ 3] = Float.floatToFloat16(0.0f - BinaryF16.MIN_VALUE);\n+        sRes[ 4] = Float.floatToFloat16(0.0f - BinaryF16.MIN_NORMAL);\n+        sRes[ 5] = Float.floatToFloat16(-1.0f);\n+        sRes[ 6] = Float.floatToFloat16(-0.0f);\n+        sRes[ 7] = Float.floatToFloat16(BinaryF16.MIN_VALUE);\n+        sRes[ 8] = Float.floatToFloat16(BinaryF16.MIN_NORMAL);\n+        sRes[ 9] = Float.floatToFloat16(BinaryF16.POSITIVE_ZERO);\n+        sRes[10] = Float.floatToFloat16(BinaryF16.ONE);\n+        sRes[11] = Float.floatToFloat16(BinaryF16.MAX_VALUE);\n+        sRes[12] = Float.floatToFloat16(BinaryF16.MAX_SUBNORMAL);\n+        sRes[13] = Float.floatToFloat16(BinaryF16.POSITIVE_INFINITY);\n+    }\n+\n+    public static void run() {\n+        short s = Float.floatToFloat16(0.0f); \/\/ Load Float class\n+        \/\/ Testing constant float16 values.\n+        float[] fRes = new float[sCon.length];\n+        testFloat16Const(fRes);\n+        for (int i = 0; i < sCon.length; i++) {\n+            float fVal = Float.float16ToFloat(sCon[i]);\n+            if (Float.floatToRawIntBits(fRes[i]) != Float.floatToRawIntBits(fVal)) {\n+                String cVal_hex = Integer.toHexString(sCon[i] & 0xffff);\n+                String fRes_hex = Integer.toHexString(Float.floatToRawIntBits(fRes[i]));\n+                String fVal_hex = Integer.toHexString(Float.floatToRawIntBits(fVal));\n+                throw new RuntimeException(\"Inconsistent result for Float.float16ToFloat(\" + cVal_hex + \"): \" + fRes[i] + \"\/\" + fRes_hex + \" != \" + fVal + \"\/\" + fVal_hex);\n+            }\n+        }\n+\n+        \/\/ Testing constant float values.\n+        short[] sRes = new short[fCon.length];\n+        testFloatConst(sRes);\n+        for (int i = 0; i < fCon.length; i++) {\n+            short sVal = Float.floatToFloat16(fCon[i]);\n+            if (sRes[i] != sVal) {\n+                String cVal_hex = Integer.toHexString(Float.floatToRawIntBits(fCon[i]));\n+                String sRes_hex = Integer.toHexString(sRes[i] & 0xffff);\n+                String sVal_hex = Integer.toHexString(sVal & 0xffff);\n+                throw new RuntimeException(\"Inconsistent result for Float.floatToFloat16(\" + fCon[i] + \"\/\" + cVal_hex + \"): \" + sRes_hex + \" != \" + sVal_hex);\n+            }\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Run twice to trigger compilation\n+        for (int i = 0; i < 2; i++) {\n+            run();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.1 Binary16ConversionNaN\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}