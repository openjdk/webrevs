{"files":[{"patch":"@@ -801,2 +801,0 @@\n-  INSN(fcvt_s_h, 0b1010011, 0b00010, 0b0100000);\n-  INSN(fcvt_h_s, 0b1010011, 0b00000, 0b0100010);\n@@ -1059,1 +1057,0 @@\n-  INSN(fmv_h_x,  0b1010011, 0b000, 0b00000, 0b1111010);\n@@ -1080,1 +1077,0 @@\n-  INSN(fmv_x_h,  0b1010011, 0b000, 0b00000, 0b1110010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1282,1 +1282,1 @@\n-void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {\n+void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {\n@@ -1286,2 +1286,0 @@\n-    case lir_f2hf: __ flt_to_flt16(dest->as_register(), value->as_float_reg(), tmp->as_float_reg()); break;\n-    case lir_hf2f: __ flt16_to_flt(dest->as_float_reg(), value->as_register(), tmp->as_float_reg()); break;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -645,3 +645,1 @@\n-    case vmIntrinsics::_dsqrt_strict:\n-    case vmIntrinsics::_floatToFloat16:\n-    case vmIntrinsics::_float16ToFloat: {\n+    case vmIntrinsics::_dsqrt_strict: {\n@@ -651,1 +649,0 @@\n-      LIR_Opr src = value.result();\n@@ -657,1 +654,1 @@\n-          __ sqrt(src, dst, LIR_OprFact::illegalOpr);\n+          __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n@@ -661,13 +658,1 @@\n-          __ abs(src, dst, LIR_OprFact::illegalOpr);\n-          break;\n-        }\n-        case vmIntrinsics::_floatToFloat16: {\n-          LIR_Opr tmp = new_register(T_FLOAT);\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n-          __ f2hf(src, dst, tmp);\n-          break;\n-        }\n-        case vmIntrinsics::_float16ToFloat: {\n-          LIR_Opr tmp = new_register(T_FLOAT);\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n-          __ hf2f(src, dst, tmp);\n+          __ abs(value.result(), dst, LIR_OprFact::illegalOpr);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-  product(bool, UseZfhmin, false, EXPERIMENTAL, \"Use Zfhmin instructions\")       \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1223,9 +1223,0 @@\n-  void flt_to_flt16(Register dst, FloatRegister src, FloatRegister tmp) {\n-    fcvt_h_s(tmp, src);\n-    fmv_x_h(dst, tmp);\n-  }\n-  void flt16_to_flt(FloatRegister dst, Register src, FloatRegister tmp) {\n-    fmv_h_x(tmp, src);\n-    fcvt_s_h(dst, tmp);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1848,4 +1848,0 @@\n-\n-    case Op_ConvF2HF:\n-    case Op_ConvHF2F:\n-      return UseZfhmin;\n@@ -8183,36 +8179,0 @@\n-\/\/ float <-> half float\n-\n-instruct convHF2F_reg_reg(fRegF dst, iRegINoSp src, fRegF tmp) %{\n-  predicate(UseZfhmin);\n-  match(Set dst (ConvHF2F src));\n-  effect(TEMP tmp);\n-\n-  ins_cost(XFER_COST);\n-  format %{ \"fmv.h.x $tmp, $src\\t#@convHF2F_reg_reg\\n\\t\"\n-            \"fcvt.s.h $dst, $tmp\\t#@convHF2F_reg_reg\"\n-  %}\n-\n-  ins_encode %{\n-    __ flt16_to_flt($dst$$FloatRegister, $src$$Register, $tmp$$FloatRegister);\n-  %}\n-\n-  ins_pipe(fp_i2f);\n-%}\n-\n-instruct convF2HF_reg_reg(iRegINoSp dst, fRegF src, fRegF tmp) %{\n-  predicate(UseZfhmin);\n-  match(Set dst (ConvF2HF src));\n-  effect(TEMP tmp);\n-\n-  ins_cost(XFER_COST);\n-  format %{ \"fcvt.h.s $tmp, $src\\t#@convF2HF_reg_reg\\n\\t\"\n-            \"fmv.x.h $dst, $tmp\\t#@convF2HF_reg_reg\"\n-  %}\n-\n-  ins_encode %{\n-    __ flt_to_flt16($dst$$Register, $src$$FloatRegister, $tmp$$FloatRegister);\n-  %}\n-\n-  ins_pipe(fp_f2i);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -304,43 +304,3 @@\n-address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr;\n-  }\n-  \/\/ x19_sender_sp: sender sp\n-  \/\/ stack:\n-  \/\/        [ arg ] <-- esp\n-  \/\/        [ arg ]\n-  \/\/ retaddr in ra\n-  \/\/ result in f10\n-\n-  address entry_point = __ pc();\n-  __ lw(c_rarg0, Address(esp));\n-  __ flt16_to_flt(f10, c_rarg0, f11);\n-  __ mv(sp, x19_sender_sp); \/\/ Restore caller's SP\n-  __ jr(ra);\n-  return entry_point;\n-}\n-\n-address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr;\n-  }\n-  \/\/ x19_sender_sp: sender sp\n-  \/\/ stack:\n-  \/\/        [ arg ] <-- esp\n-  \/\/        [ arg ]\n-  \/\/ retaddr in ra\n-  \/\/ result in c_rarg0\n-\n-  address entry_point = __ pc();\n-  __ flw(f10, Address(esp));\n-  __ flt_to_flt16(c_rarg0, f10, f11);\n-  __ mv(sp, x19_sender_sp); \/\/ Restore caller's SP\n-  __ jr(ra);\n-  return entry_point;\n-}\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -79,3 +79,0 @@\n-    if (FLAG_IS_DEFAULT(UseZfhmin)) {\n-      FLAG_SET_DEFAULT(UseZfhmin, true);\n-    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,2 +66,0 @@\n-  static bool supports_float16() { return UseZfhmin; }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16Conversion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch == \"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestAllFloat16ToFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\" | (os.arch == \"riscv64\" & vm.opt.UseZfhmin == true)\n+ * @requires (vm.cpu.features ~= \".*avx512vl.*\" | vm.cpu.features ~= \".*f16c.*\") | os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}