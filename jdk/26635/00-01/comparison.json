{"files":[{"patch":"@@ -27,2 +27,0 @@\n-import sun.nio.cs.DoubleByte;\n-import sun.nio.cs.SingleByte;\n@@ -39,1 +37,0 @@\n-import java.util.function.Predicate;\n@@ -42,1 +39,0 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -44,1 +40,0 @@\n-import static sun.nio.cs.CharsetMapping.UNMAPPABLE_ENCODING;\n@@ -104,3 +99,0 @@\n-\n-        \/\/ Try to find a single-byte unmappable\n-        Predicate<char[]> isUnmappable1 = createUnmappableSingleCharPredicate(encoder);\n@@ -108,3 +100,3 @@\n-        for (int i = 0; i < 0xFF; i++) {\n-            unmappable1[0] = (char) i;\n-            boolean unmappable = isUnmappable1.test(unmappable1);\n+        for (char c = 0; c < 0xFF; c++) {\n+            unmappable1[0] = c;\n+            boolean unmappable = !encoder.canEncode(c);\n@@ -115,1 +107,0 @@\n-\n@@ -118,21 +109,0 @@\n-\n-    }\n-\n-    static Predicate<char[]> createUnmappableSingleCharPredicate(CharsetEncoder encoder) {\n-        return switch (encoder) {\n-            case SingleByte.Encoder sbEncoder -> c -> sbEncoder.encode(c[0]) == UNMAPPABLE_ENCODING;\n-            case DoubleByte.Encoder dbEncoder -> c -> dbEncoder.encodeChar(c[0]) == UNMAPPABLE_ENCODING;\n-            default -> createUnmappableDoubleCharPredicate(encoder);\n-        };\n-    }\n-\n-    static Predicate<char[]> createUnmappableDoubleCharPredicate(CharsetEncoder encoder) {\n-        assertEquals(encoder.unmappableCharacterAction(), CodingErrorAction.REPORT);\n-        CharBuffer charBuffer = CharBuffer.allocate(2);\n-        ByteBuffer byteBuffer = ByteBuffer.allocate(4);\n-        return unmappable -> {\n-            charBuffer.clear().put(unmappable).flip();\n-            byteBuffer.clear();\n-            CoderResult coderResult = encoder.encode(charBuffer, byteBuffer, true);\n-            return coderResult.isUnmappable();\n-        };\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceLatin1.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.function.Predicate;\n@@ -149,5 +148,8 @@\n-        Predicate<char[]> isUnmappable1 = TestEncoderReplaceLatin1.createUnmappableSingleCharPredicate(encoder);\n-        char[] unmappable1 = {0};\n-        for (int i = 0xFF; i < 0xFFFF; i++) {\n-            unmappable1[0] = (char) i;\n-            boolean unmappable = isUnmappable1.test(unmappable1);\n+        for (int i = 0xFF; i <= 0xFFFF; i++) {\n+            char c = (char) i;\n+            \/\/ Skip the surrogate, as a single dangling surrogate `char` should\n+            \/\/ trigger a \"malformed\" error, instead of \"unmappable\"\n+            if (Character.isSurrogate(c)) {\n+                continue;\n+            }\n+            boolean unmappable = !encoder.canEncode(c);\n@@ -155,1 +157,1 @@\n-                return unmappable1;\n+                return new char[]{c};\n@@ -159,12 +161,6 @@\n-        \/\/ Try to find a double-`char` unmappable\n-        Predicate<char[]> isUnmappable2 = TestEncoderReplaceLatin1.createUnmappableDoubleCharPredicate(encoder);\n-        char[] unmappable2 = {0, 0};\n-        for (int i = 0xFF; i < 0xFFFF; i++) {\n-            unmappable2[0] = (char) i;\n-            for (int j = 0xFF; j < 0xFFFF; j++) {\n-                unmappable2[1] = (char) j;\n-                boolean unmappable = isUnmappable2.test(unmappable2);\n-                if (unmappable) {\n-                    return unmappable2;\n-                }\n-            }\n+        \/\/ Try to find a double-`char` (i.e., surrogate pair) unmappable\n+        int[] nonBmpRange = {0x10000, 0x10FFFF};\n+        for (int i = nonBmpRange[0]; i < nonBmpRange[1]; i++) {\n+            char[] cs = Character.toChars(i);\n+            if (!encoder.canEncode(new String(cs)))\n+                return cs;\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceUTF16.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"}]}