{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import java.nio.charset.CharsetDecoder;\n-import java.nio.charset.CharsetEncoder;\n@@ -35,2 +33,1 @@\n-import sun.nio.cs.DoubleByte;\n-import sun.nio.cs.Surrogate;\n+\n@@ -358,6 +355,0 @@\n-        @SuppressWarnings(\"this-escape\")\n-        private byte[] repl = replacement();\n-        protected void implReplaceWith(byte[] newReplacement) {\n-            repl = newReplacement;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/HKSCS.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import sun.nio.cs.ArrayEncoder;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8364365\n+ * @summary Verifies `CodingErrorAction.REPLACE` behaviour of all available\n+ *          character set encoders while encoding a Latin-1 character\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/sun.nio.cs\n+ * @run junit TestEncoderReplaceLatin1\n+ *\/\n+\n+class TestEncoderReplaceLatin1 {\n+\n+    static Collection<Charset> charsets() {\n+        return Charset.availableCharsets().values();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charsets\")\n+    void testEncoderReplace(Charset charset) {\n+\n+        \/\/ Create an encoder\n+        CharsetEncoder encoder = createEncoder(charset);\n+        if (encoder == null) {\n+            return;\n+        }\n+\n+        \/\/ Find an unmappable character to test the `REPLACE` action.\n+        char[] unmappable = findUnmappable(encoder);\n+        if (unmappable == null) {\n+            return;\n+        }\n+\n+        \/\/ Configure the `REPLACE` action\n+        byte[] replacement = findCustomReplacement(encoder, new byte[]{(byte) unmappable[0]});\n+        if (replacement == null) {\n+            return;\n+        }\n+        encoder.onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(replacement);\n+\n+        \/\/ Verify the replacement\n+        System.err.println(\"Verifying replacement... \" + Map.of(\n+                \"unmappable\", TestEncoderReplaceLatin1.prettyPrintChars(unmappable),\n+                \"replacement\", TestEncoderReplaceLatin1.prettyPrintBytes(replacement)));\n+        testCharsetEncoderReplace(encoder, unmappable, replacement);\n+        testArrayEncoderLatin1Replace(encoder, unmappable[0], replacement);\n+\n+    }\n+\n+    private static CharsetEncoder createEncoder(Charset charset) {\n+        try {\n+            return charset.newEncoder();\n+        } catch (UnsupportedOperationException _) {\n+            System.err.println(\"Could not create the character encoder!\");\n+        }\n+        return null;\n+    }\n+\n+    private static char[] findUnmappable(CharsetEncoder encoder) {\n+        char[] unmappable1 = {0};\n+        for (char c = 0; c < 0xFF; c++) {\n+            unmappable1[0] = c;\n+            boolean unmappable = !encoder.canEncode(c);\n+            if (unmappable) {\n+                return unmappable1;\n+            }\n+        }\n+        System.err.println(\"Could not find an unmappable character!\");\n+        return null;\n+    }\n+\n+    \/**\n+     * Finds a {@linkplain CharsetEncoder#replacement() replacement} which is\n+     * different from the given unmappable and the default one.\n+     *\/\n+    static byte[] findCustomReplacement(CharsetEncoder encoder, byte[] unmappable) {\n+\n+        \/\/ Obtain the default replacement\n+        byte[] replacementD = encoder.replacement();\n+\n+        \/\/ Try to find a single-byte replacement\n+        byte[] replacement1 = {0};\n+        for (int i = 0; i < 0xFF; i++) {\n+            \/\/ Skip if the replacement is equal to the unmappable.\n+            \/\/ They need to be distinct to be able to determine whether the replacement has occurred.\n+            if (unmappable[0] == i) {\n+                continue;\n+            }\n+            replacement1[0] = (byte) i;\n+            \/\/ Skip the default value, since we're verifying if a custom one works\n+            if (replacement1[0] == replacementD[0]) {\n+                continue;\n+            }\n+            if (encoder.isLegalReplacement(replacement1)) {\n+                return replacement1;\n+            }\n+        }\n+\n+        \/\/ Try to find a double-byte replacement\n+        byte[] replacement2 = {0, 0};\n+        for (int i = 0; i < 0xFF; i++) {\n+            \/\/ Skip if the replacement is equal to the unmappable.\n+            \/\/ They need to be distinct to be able to determine whether the replacement has occurred.\n+            if (unmappable[0] == i) {\n+                continue;\n+            }\n+            replacement2[0] = (byte) i;\n+            for (int j = 0; j < 0xFF; j++) {\n+                \/\/ Skip if the replacement is equal to the unmappable.\n+                \/\/ They need to be distinct to be able to determine whether the replacement has occurred.\n+                if (unmappable.length > 1 && unmappable[1] == j) {\n+                    continue;\n+                }\n+                replacement2[1] = (byte) j;\n+                \/\/ Skip the default value, since we're verifying if a custom one works\n+                if (replacementD.length > 1 && replacement2[1] == replacementD[1]) {\n+                    continue;\n+                }\n+                if (encoder.isLegalReplacement(replacement2)) {\n+                    return replacement2;\n+                }\n+            }\n+        }\n+\n+        System.err.println(\"Could not find a replacement!\");\n+        return null;\n+\n+    }\n+\n+    \/**\n+     * Verifies {@linkplain CoderResult#isUnmappable() unmappable} character\n+     * {@linkplain CodingErrorAction#REPLACE replacement} using {@link\n+     * CharsetEncoder#encode(CharBuffer, ByteBuffer, boolean)\n+     * CharsetEncoder::encode}.\n+     *\/\n+    static void testCharsetEncoderReplace(CharsetEncoder encoder, char[] unmappable, byte[] replacement) {\n+        CharBuffer charBuffer = CharBuffer.wrap(unmappable);\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(replacement.length);\n+        CoderResult coderResult = encoder.encode(charBuffer, byteBuffer, true);\n+        assertArrayEquals(replacement, byteBuffer.array(), () -> {\n+            Object context = Map.of(\n+                    \"coderResult\", coderResult,\n+                    \"byteBuffer.position()\", byteBuffer.position(),\n+                    \"byteBuffer.array()\", prettyPrintBytes(byteBuffer.array()),\n+                    \"unmappable\", prettyPrintChars(unmappable),\n+                    \"replacement\", prettyPrintBytes(replacement));\n+            return \"Unexpected `CharsetEncoder::encode` output! \" + context;\n+        });\n+    }\n+\n+    \/**\n+     * Verifies {@linkplain CoderResult#isUnmappable() unmappable} character\n+     * {@linkplain CodingErrorAction#REPLACE replacement} using {@link\n+     * ArrayEncoder#encodeFromLatin1(byte[], int, int, byte[])\n+     * ArrayEncoder::encodeFromLatin1}.\n+     *\/\n+    private static void testArrayEncoderLatin1Replace(CharsetEncoder encoder, char unmappable, byte[] replacement) {\n+        if (!(encoder instanceof ArrayEncoder arrayEncoder)) {\n+            System.err.println(\"Encoder is not of type `ArrayEncoder`, skipping the `ArrayEncoder::encodeFromLatin1` test.\");\n+            return;\n+        }\n+        byte[] sa = {(byte) unmappable};\n+        byte[] da = new byte[replacement.length];\n+        int dp = arrayEncoder.encodeFromLatin1(sa, 0, 1, da);\n+        assertTrue(dp == replacement.length && Arrays.equals(da, replacement), () -> {\n+            Object context = Map.of(\n+                    \"dp\", dp,\n+                    \"da\", prettyPrintBytes(da),\n+                    \"sa\", prettyPrintBytes(sa),\n+                    \"unmappable\", prettyPrintChars(new char[]{unmappable}),\n+                    \"replacement\", prettyPrintBytes(replacement));\n+            return \"Unexpected `ArrayEncoder::encodeFromLatin1` output! \" + context;\n+        });\n+    }\n+\n+    static String prettyPrintChars(char[] cs) {\n+        StringBuilder sb = new StringBuilder(\"[\");\n+        for (int i = 0; i < cs.length; i++) {\n+            char c = cs[i];\n+            sb.append(\"%sU+%04X\".formatted(i > 0 ? \", \" : \"\", (int) c));\n+        }\n+        return sb.append(']').toString();\n+    }\n+\n+    static String prettyPrintBytes(byte[] bs) {\n+        StringBuilder sb = new StringBuilder(\"[\");\n+        for (int i = 0; i < bs.length; i++) {\n+            byte b = bs[i];\n+            sb.append(\"%s0x%02X\".formatted(i > 0 ? \", \" : \"\", b & 0xFF));\n+        }\n+        return sb.append(']').toString();\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceLatin1.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import sun.nio.cs.ArrayEncoder;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8364365\n+ * @summary Verifies `CodingErrorAction.REPLACE` behaviour of all available\n+ *          character set encoders while encoding a UTF-16 character\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/sun.nio.cs\n+ * @build TestEncoderReplaceLatin1\n+ * @run junit\/timeout=10 TestEncoderReplaceUTF16\n+ * @run junit\/timeout=10\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n+ *\/\n+\n+class TestEncoderReplaceUTF16 {\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/**\n+     * Character sets known to be absent of non-Latin-1 {@linkplain CoderResult#isUnmappable() unmappable} characters.\n+     *\/\n+    private static final Set<String> CHARSETS_WITHOUT_UNMAPPABLE = Set.of(\n+            \"CESU-8\",\n+            \"EUC-JP\",\n+            \"GB18030\",\n+            \"ISO-2022-JP\",\n+            \"ISO-2022-JP-2\",\n+            \"ISO-2022-KR\",\n+            \"ISO-8859-1\",\n+            \"US-ASCII\",\n+            \"UTF-16\",\n+            \"UTF-16BE\",\n+            \"UTF-16LE\",\n+            \"UTF-32\",\n+            \"UTF-32BE\",\n+            \"UTF-32LE\",\n+            \"UTF-8\",\n+            \"x-euc-jp-linux\",\n+            \"x-EUC-TW\",\n+            \"x-eucJP-Open\",\n+            \"x-IBM29626C\",\n+            \"x-IBM33722\",\n+            \"x-IBM964\",\n+            \"x-ISCII91\",\n+            \"x-ISO-2022-CN-CNS\",\n+            \"x-ISO-2022-CN-GB\",\n+            \"x-MS932_0213\",\n+            \"x-SJIS_0213\",\n+            \"x-UTF-16LE-BOM\",\n+            \"X-UTF-32BE-BOM\",\n+            \"X-UTF-32LE-BOM\",\n+            \"x-windows-50220\",\n+            \"x-windows-50221\",\n+            \"x-windows-iso2022jp\");\n+\n+    @ParameterizedTest\n+    @MethodSource(\"TestEncoderReplaceLatin1#charsets\")\n+    void testEncoderReplace(Charset charset) {\n+\n+        \/\/ Create an encoder\n+        CharsetEncoder encoder = createEncoder(charset);\n+        if (encoder == null) {\n+            return;\n+        }\n+\n+        \/\/ Find an unmappable character to test the `REPLACE` action.\n+        char[] unmappable = findUnmappableNonLatin1(encoder);\n+        if (unmappable == null) {\n+            return;\n+        }\n+\n+        \/\/ Configure the `REPLACE` action\n+        byte[] unmappableUTF16Bytes = utf16Bytes(unmappable);\n+        byte[] replacement = TestEncoderReplaceLatin1.findCustomReplacement(encoder, unmappableUTF16Bytes);\n+        if (replacement == null) {\n+            return;\n+        }\n+        encoder.onUnmappableCharacter(CodingErrorAction.REPLACE).replaceWith(replacement);\n+\n+        \/\/ Verify the replacement\n+        System.err.println(\"Verifying replacement... \" + Map.of(\n+                \"unmappable\", TestEncoderReplaceLatin1.prettyPrintChars(unmappable),\n+                \"unmappableUTF16Bytes\", TestEncoderReplaceLatin1.prettyPrintBytes(unmappableUTF16Bytes),\n+                \"replacement\", TestEncoderReplaceLatin1.prettyPrintBytes(replacement)));\n+        TestEncoderReplaceLatin1.testCharsetEncoderReplace(encoder, unmappable, replacement);\n+        testArrayEncoderUTF16Replace(encoder, unmappableUTF16Bytes, replacement);\n+\n+    }\n+\n+    private static CharsetEncoder createEncoder(Charset charset) {\n+        try {\n+            return charset.newEncoder();\n+        } catch (UnsupportedOperationException _) {\n+            System.err.println(\"Could not create the character encoder!\");\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Finds an {@linkplain CoderResult#isUnmappable() unmappable} non-Latin-1 {@code char[]} for the given encoder.\n+     *\/\n+    private static char[] findUnmappableNonLatin1(CharsetEncoder encoder) {\n+\n+        \/\/ Fast-path for characters sets known to be absent of unmappable non-Latin-1 characters\n+        if (CHARSETS_WITHOUT_UNMAPPABLE.contains(encoder.charset().name())) {\n+            System.err.println(\"Character set is known to be absent of unmappable non-Latin-1 characters!\");\n+            return null;\n+        }\n+\n+        \/\/ Try to find a single-`char` unmappable\n+        for (int i = 0xFF; i <= 0xFFFF; i++) {\n+            char c = (char) i;\n+            \/\/ Skip the surrogate, as a single dangling surrogate `char` should\n+            \/\/ trigger a \"malformed\" error, instead of \"unmappable\"\n+            if (Character.isSurrogate(c)) {\n+                continue;\n+            }\n+            boolean unmappable = !encoder.canEncode(c);\n+            if (unmappable) {\n+                return new char[]{c};\n+            }\n+        }\n+\n+        \/\/ Try to find a double-`char` (i.e., surrogate pair) unmappable\n+        int[] nonBmpRange = {0x10000, 0x10FFFF};\n+        for (int i = nonBmpRange[0]; i < nonBmpRange[1]; i++) {\n+            char[] cs = Character.toChars(i);\n+            if (!encoder.canEncode(new String(cs)))\n+                return cs;\n+        }\n+\n+        System.err.println(\"Could not find an unmappable character!\");\n+        return null;\n+    }\n+\n+    private static byte[] utf16Bytes(char[] cs) {\n+        int sl = cs.length;\n+        byte[] sa = new byte[sl << 1];\n+        for (int i = 0; i < sl; i++) {\n+            JLA.uncheckedPutCharUTF16(sa, i, cs[i]);\n+        }\n+        return sa;\n+    }\n+\n+    \/**\n+     * Verifies {@linkplain CoderResult#isUnmappable() unmappable} character\n+     * {@linkplain CodingErrorAction#REPLACE replacement} using {@link\n+     * ArrayEncoder#encodeFromUTF16(byte[], int, int, byte[])\n+     * ArrayEncoder::encodeFromUTF16}.\n+     *\/\n+    private static void testArrayEncoderUTF16Replace(CharsetEncoder encoder, byte[] unmappableUTF16Bytes, byte[] replacement) {\n+        if (!(encoder instanceof ArrayEncoder arrayEncoder)) {\n+            System.err.println(\"Encoder is not of type `ArrayEncoder`, skipping the `ArrayEncoder::encodeFromUTF16` test.\");\n+            return;\n+        }\n+        byte[] da = new byte[replacement.length];\n+        int dp = arrayEncoder.encodeFromUTF16(unmappableUTF16Bytes, 0, unmappableUTF16Bytes.length >>> 1, da);\n+        assertTrue(dp == replacement.length && Arrays.equals(da, replacement), () -> {\n+            Object context = Map.of(\n+                    \"dp\", dp,\n+                    \"da\", TestEncoderReplaceLatin1.prettyPrintBytes(da),\n+                    \"unmappableUTF16Bytes\", TestEncoderReplaceLatin1.prettyPrintBytes(unmappableUTF16Bytes),\n+                    \"replacement\", TestEncoderReplaceLatin1.prettyPrintBytes(replacement));\n+            return \"Unexpected `ArrayEncoder::encodeFromUTF16` output! \" + context;\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceUTF16.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}