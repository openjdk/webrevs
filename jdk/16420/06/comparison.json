{"files":[{"patch":"@@ -88,1 +88,1 @@\n-    private final AbstractPipeline previousStage;\n+    protected final AbstractPipeline previousStage;\n@@ -191,0 +191,2 @@\n+     * The previous stage must be unlinked and unconsumed.\n+     *\n@@ -194,0 +196,2 @@\n+     * @throws IllegalStateException if previousStage is already linked or\n+     * consumed\n@@ -208,0 +212,35 @@\n+    \/**\n+     * Constructor for replacing an intermediate operation stage onto an\n+     * existing pipeline.\n+     *\n+     * @param previousPreviousStage the upstream pipeline stage of the upstream pipeline stage\n+     * @param previousStage the upstream pipeline stage\n+     * @param opFlags the operation flags for the new stage, described in\n+     * {@link StreamOpFlag}\n+     * @throws IllegalStateException if previousStage is already linked or\n+     * consumed\n+     *\/\n+    protected AbstractPipeline(AbstractPipeline<?, E_IN, ?> previousPreviousStage, AbstractPipeline<?, E_IN, ?> previousStage, int opFlags) {\n+        if (previousStage.linkedOrConsumed || !previousPreviousStage.linkedOrConsumed || previousPreviousStage.nextStage != previousStage || previousStage.previousStage != previousPreviousStage)\n+            throw new IllegalStateException(MSG_STREAM_LINKED);\n+\n+        previousStage.linkedOrConsumed = true;\n+\n+        previousPreviousStage.nextStage = this;\n+\n+        this.previousStage = previousPreviousStage;\n+        this.sourceOrOpFlags = opFlags & StreamOpFlag.OP_MASK;\n+        this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousPreviousStage.combinedFlags);\n+        this.sourceStage = previousPreviousStage.sourceStage;\n+        this.depth = previousPreviousStage.depth + 1;\n+    }\n+\n+    \/**\n+     * Checks that the current stage has not been already linked or consumed,\n+     * and then sets this stage as being linked or consumed.\n+     *\/\n+    protected void linkOrConsume() {\n+        if (linkedOrConsumed)\n+            throw new IllegalStateException(MSG_STREAM_LINKED);\n+        linkedOrConsumed = true;\n+    }\n@@ -405,1 +444,1 @@\n-    private Spliterator<?> sourceSpliterator(int terminalFlags) {\n+    protected Spliterator<?> sourceSpliterator(int terminalFlags) {\n@@ -743,1 +782,1 @@\n-        return opEvaluateParallel(helper, spliterator, i -> (E_OUT[]) new Object[i]).spliterator();\n+        return opEvaluateParallel(helper, spliterator, Nodes.castingArray()).spliterator();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.stream;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Supplier;\n+\n+\n+\/**\n+ * An intermediate operation that transforms a stream of input elements into a\n+ * stream of output elements, optionally applying a final action when the end of\n+ * the upstream is reached. The transformation may be stateless or stateful,\n+ * and may buffer input before producing any output.\n+ *\n+ * <p>Gatherer operations can be performed either sequentially,\n+ * or be parallelized -- if a combiner function is supplied.\n+ *\n+ * <p>There are many examples of gathering operations, including but not\n+ * limited to:\n+ * grouping elements into batches (windowing functions);\n+ * de-duplicating consecutively similar elements; incremental accumulation\n+ * functions (prefix scan); incremental reordering functions, etc.  The class\n+ * {@link java.util.stream.Gatherers} provides implementations of common\n+ * gathering operations.\n+ *\n+ * @apiNote\n+ * <p>A {@code Gatherer} is specified by four functions that work together to\n+ * process input elements, optionally using intermediate state, and optionally\n+ * perform a final action at the end of input.  They are: <ul>\n+ *     <li>creating a new, potentially mutable, state ({@link #initializer()})<\/li>\n+ *     <li>integrating a new input element ({@link #integrator()})<\/li>\n+ *     <li>combining two states into one ({@link #combiner()})<\/li>\n+ *     <li>performing an optional final action ({@link #finisher()})<\/li>\n+ * <\/ul>\n+ *\n+ * <p>Each invocation of {@link #initializer()}, {@link #integrator()},\n+ * {@link #combiner()}, and {@link #finisher()} must return a semantically\n+ * identical result.\n+ *\n+ * <p>Implementations of Gatherer must not capture, retain, or expose to\n+ * other threads, the references to the state instance, or the downstream\n+ * {@link Downstream} for longer than the invocation duration of the method\n+ * which they are passed to.\n+ *\n+ * <p>Performing a gathering operation with a {@code Gatherer} should produce a\n+ * result equivalent to:\n+ *\n+ * {@snippet lang = java:\n+ * Gatherer.Downstream<? super R> downstream = ...;\n+ * A state = gatherer.initializer().get();\n+ * for (T t : data) {\n+ *     gatherer.integrator().integrate(state, t, downstream);\n+ * }\n+ * gatherer.finisher().accept(state, downstream);\n+ * }\n+ *\n+ * <p>However, the library is free to partition the input, perform the\n+ * integrations on the partitions, and then use the combiner function to\n+ * combine the partial results to achieve a gathering operation.  (Depending\n+ * on the specific gathering operation, this may perform better or worse,\n+ * depending on the relative cost of the integrator and combiner functions.)\n+ *\n+ * <p>In addition to the predefined implementations in {@link Gatherers}, the\n+ * static factory methods {@code of(...)} and {@code ofSequential(...)}\n+ * can be used to construct gatherers.  For example, you could create a gatherer\n+ * that implements the equivalent of\n+ * {@link java.util.stream.Stream#map(java.util.function.Function)} with:\n+ *\n+ * {@snippet lang = java:\n+ * public static <T, R> Gatherer<T, ?, R> map(Function<? super T, ? extends R> mapper) {\n+ *     return Gatherer.of(\n+ *         (unused, element, downstream) -> \/\/ integrator\n+ *             downstream.push(mapper.apply(element))\n+ *     );\n+ * }\n+ * }\n+ *\n+ * <p>Gatherers are designed to be <em>composed<\/em>; two or more Gatherers can\n+ * be composed into a single Gatherer using the {@link #andThen(Gatherer)}\n+ * method.\n+ *\n+ * {@snippet lang = java:\n+ * \/\/ using the implementation of `map` as seen above\n+ * Gatherer<Integer, ?, Integer> increment = map(i -> i + 1);\n+ *\n+ * Gatherer<Object, ?, String> toString = map(i -> i.toString());\n+ *\n+ * Gatherer<Integer, ?, String> incrementThenToString = increment.andThen(toString);\n+ * }\n+ *\n+ * <p>As an example, a Gatherer implementing a sequential Prefix Scan \n+ * could be done the following way:\n+ *\n+ * {@snippet lang = java:\n+ * public static <T, R> Gatherer<T, ?, R> scan(\n+ *     Supplier<R> initial,\n+ *     BiFunction<? super R, ? super T, ? extends R> scanner) {\n+ *\n+ *     class State {\n+ *         R current = initial.get();\n+ *     }\n+ *\n+ *     return Gatherer.<T, State, R>ofSequential(\n+ *          State::new,\n+ *          Gatherer.Integrator.ofGreedy((state, element, downstream) -> {\n+ *              state.current = scanner.apply(state.current, element);\n+ *              return downstream.push(state.current);\n+ *          })\n+ *     );\n+ * }\n+ * }\n+ *\n+ * <p>Example of usage:\n+ *\n+ * {@snippet lang = java:\n+ * \/\/ will contain: [\"1\", \"12\", \"123\", \"1234\", \"12345\", \"123456\", \"1234567\", \"12345678\", \"123456789\"]\n+ * List<String> numberStrings =\n+ *     Stream.of(1,2,3,4,5,6,7,8,9)\n+ *           .gather(\n+ *               scan(() -> \"\", (string, number) -> string + number)\n+ *            )\n+ *           .toList();\n+ * }\n+ *\n+ * @implSpec Libraries that implement transformations based on {@code Gatherer},\n+ * such as {@link Stream#gather(Gatherer)}, must adhere to the following\n+ * constraints:\n+ * <ul>\n+ *     <li>Gatherers whose initializer is {@link #defaultInitializer()} are\n+ *     considered to be stateless, and invoking their initializer is optional.\n+ *     <\/li>\n+ *     <li>Gatherers whose integrator is an instance of {@link Integrator.Greedy}\n+ *     can be assumed not to short-circuit, and the return value of invoking\n+ *     {@link Integrator#integrate(Object, Object, Downstream)} does not need to\n+ *     be inspected.<\/li>\n+ *     <li>The first argument passed to the integration function, both\n+ *     arguments passed to the combiner function, and the argument passed to the\n+ *     finisher function must be the result of a previous invocation of the\n+ *     initializer or combiner functions.<\/li>\n+ *     <li>The implementation should not do anything with the result of any of\n+ *     the initializer or combiner functions other than to\n+ *     pass them again to the integrator, combiner, or finisher functions.<\/li>\n+ *     <li>Once a state object is passed to the combiner or finisher function,\n+ *     it is never passed to the integrator function again.<\/li>\n+ *     <li>When the integrator function returns {@code false},\n+ *     it shall be interpreted just as if there were no more elements to pass\n+ *     it.<\/li>\n+ *     <li>For parallel evaluation, the gathering implementation must manage\n+ *     that the input is properly partitioned, that partitions are processed\n+ *     in isolation, and combining happens only after integration is complete\n+ *     for both partitions.<\/li>\n+ *     <li>Gatherers whose combiner is {@link #defaultCombiner()} may only be\n+ *     evaluated sequentially. All other combiners allow the operation to be\n+ *     parallelized by initializing each partition in separation, invoking\n+ *     the integrator until it returns {@code false}, and then joining each\n+ *     partitions state using the combiner, and then invoking the finisher on\n+ *     the joined state. Outputs and state later in the input sequence will\n+ *     be discarded if processing an earlier partition short-circuits.<\/li>\n+ *     <li>Gatherers whose finisher is {@link #defaultFinisher()} are considered\n+ *     to not have an end-of-stream hook and invoking their finisher is\n+ *     optional.<\/li>\n+ * <\/ul>\n+ *\n+ * @see Stream#gather(Gatherer)\n+ * @see Gatherers\n+ *\n+ * @param <T> the type of input elements to the gatherer operation\n+ * @param <A> the potentially mutable state type of the gatherer operation\n+ *            (often hidden as an implementation detail)\n+ * @param <R> the type of output elements from the gatherer operation\n+ * @since 22\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STREAM_GATHERERS)\n+public interface Gatherer<T, A, R> {\n+    \/**\n+     * A function that produces an instance of the intermediate state used for\n+     * this gathering operation.\n+     *\n+     * @implSpec The implementation in this interface returns\n+     *           {@link #defaultInitializer()}.\n+     *\n+     * @return A function that produces an instance of the intermediate state\n+     * used for this gathering operation\n+     *\/\n+    default Supplier<A> initializer() {\n+        return defaultInitializer();\n+    };\n+\n+    \/**\n+     * A function which integrates provided elements, potentially using\n+     * the provided intermediate state, optionally producing output to the\n+     * provided {@link Downstream}.\n+     *\n+     * @return a function which integrates provided elements, potentially using\n+     *         the provided state, optionally producing output to the provided\n+     *         Downstream\n+     *\/\n+    Integrator<A, T, R> integrator();\n+\n+    \/**\n+     * A function which accepts two intermediate states and combines them into\n+     * one.\n+     *\n+     * @implSpec The implementation in this interface returns\n+     *           {@link #defaultCombiner()}.\n+     *\n+     * @return a function which accepts two intermediate states and combines\n+     *         them into one\n+     *\/\n+    default BinaryOperator<A> combiner() {\n+        return defaultCombiner();\n+    }\n+\n+    \/**\n+     * A function which accepts the final intermediate state\n+     * and a {@link Downstream} object, allowing to perform a final action at\n+     * the end of input elements.\n+     *\n+     * @implSpec The implementation in this interface returns\n+     *           {@link #defaultFinisher()}.\n+     *\n+     * @return a function which transforms the intermediate result to the final\n+     *         result(s) which are then passed on to the provided Downstream\n+     *\/\n+    default BiConsumer<A, Downstream<? super R>> finisher() {\n+        return defaultFinisher();\n+    }\n+\n+    \/**\n+     * Returns a composed Gatherer which connects the output of this Gatherer\n+     * to the input of that Gatherer.\n+     *\n+     * @param that the other gatherer\n+     * @param <RR> The type of output of that Gatherer\n+     * @throws NullPointerException if the argument is {@code null}\n+     * @return returns a composed Gatherer which connects the output of this\n+     *         Gatherer as input that Gatherer\n+     *\/\n+    default <RR> Gatherer<T, ?, RR> andThen(Gatherer<? super R, ?, ? extends RR> that) {\n+        Objects.requireNonNull(that);\n+        return Gatherers.Composite.of(this, that);\n+    }\n+\n+    \/**\n+     * Returns an initializer which is the default initializer of a Gatherer.\n+     * The returned initializer identifies that the owner Gatherer is stateless.\n+     *\n+     * @implSpec This method always returns the same instance.\n+     *\n+     * @see Gatherer#initializer()\n+     * @return the instance of the default initializer\n+     * @param <A> the type of the state of the returned initializer\n+     *\/\n+    static <A> Supplier<A> defaultInitializer() {\n+        return Gatherers.Value.DEFAULT.initializer();\n+    }\n+\n+    \/**\n+     * Returns a combiner which is the default combiner of a Gatherer.\n+     * The returned combiner identifies that the owning Gatherer must only\n+     * be evaluated sequentially.\n+     *\n+     * @implSpec This method always returns the same instance.\n+     *\n+     * @see Gatherer#finisher()\n+     * @return the instance of the default combiner\n+     * @param <A> the type of the state of the returned combiner\n+     *\/\n+    static <A> BinaryOperator<A> defaultCombiner() {\n+        return Gatherers.Value.DEFAULT.combiner();\n+    }\n+\n+    \/**\n+     * Returns a {@code finisher} which is the default finisher of\n+     * a {@code Gatherer}.\n+     * The returned finisher identifies that the owning Gatherer performs\n+     * no additional actions at the end of input.\n+     *\n+     * @implSpec This method always returns the same instance.\n+     *\n+     * @see Gatherer#finisher()\n+     * @return the instance of the default finisher\n+     * @param <A> the type of the state of the returned finisher\n+     * @param <R> the type of the Downstream of the returned finisher\n+     *\/\n+    static <A,R> BiConsumer<A, Downstream<? super R>> defaultFinisher() {\n+        return Gatherers.Value.DEFAULT.finisher();\n+    }\n+\n+    \/**\n+     * Returns a new, sequential, and stateless {@code Gatherer} described by\n+     * the given {@code integrator}.\n+     *\n+     * @param integrator the integrator function for the new gatherer\n+     * @param <T> the type of input elements for the new gatherer\n+     * @param <R> the type of results for the new gatherer\n+     * @throws NullPointerException if the argument is {@code null}\n+     * @return the new {@code Gatherer}\n+     *\/\n+    static <T, R> Gatherer<T, Void, R> ofSequential(\n+            Integrator<Void, T, R> integrator) {\n+        return of(\n+                defaultInitializer(),\n+                integrator,\n+                defaultCombiner(),\n+                defaultFinisher()\n+        );\n+    }\n+\n+    \/**\n+     * Returns a new, sequential, and stateless {@code Gatherer} described by\n+     * the given {@code integrator} and {@code finisher}.\n+     *\n+     * @param integrator the integrator function for the new gatherer\n+     * @param finisher the finisher function for the new gatherer\n+     * @param <T> the type of input elements for the new gatherer\n+     * @param <R> the type of results for the new gatherer\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @return the new {@code Gatherer}\n+     *\/\n+    static <T, R> Gatherer<T, Void, R> ofSequential(\n+            Integrator<Void, T, R> integrator,\n+            BiConsumer<Void, Downstream<? super R>> finisher) {\n+        return of(\n+                defaultInitializer(),\n+                integrator,\n+                defaultCombiner(),\n+                finisher\n+        );\n+    }\n+\n+    \/**\n+     * Returns a new, sequential, {@code Gatherer} described by the given\n+     * {@code initializer} and {@code integrator}.\n+     *\n+     * @param initializer the supplier function for the new gatherer\n+     * @param integrator the integrator function for the new gatherer\n+     * @param <T> the type of input elements for the new gatherer\n+     * @param <A> the type of initializer for the new gatherer\n+     * @param <R> the type of results for the new gatherer\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @return the new {@code Gatherer}\n+     *\/\n+    static <T, A, R> Gatherer<T, A, R> ofSequential(\n+            Supplier<A> initializer,\n+            Integrator<A, T, R> integrator) {\n+        return of(\n+                initializer,\n+                integrator,\n+                defaultCombiner(),\n+                defaultFinisher()\n+        );\n+    }\n+\n+    \/**\n+     * Returns a new, sequential, {@code Gatherer} described by the given\n+     * {@code initializer}, {@code integrator}, and {@code finisher}.\n+     *\n+     * @param initializer the supplier function for the new gatherer\n+     * @param integrator the integrator function for the new gatherer\n+     * @param finisher the finisher function for the new gatherer\n+     * @param <T> the type of input elements for the new gatherer\n+     * @param <A> the type of initializer for the new gatherer\n+     * @param <R> the type of results for the new gatherer\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @return the new {@code Gatherer}\n+     *\/\n+    static <T, A, R> Gatherer<T, A, R> ofSequential(\n+            Supplier<A> initializer,\n+            Integrator<A, T, R> integrator,\n+            BiConsumer<A, Downstream<? super R>> finisher) {\n+        return of(\n+                initializer,\n+                integrator,\n+                defaultCombiner(),\n+                finisher\n+        );\n+    }\n+\n+    \/**\n+     * Returns a new, parallelizable, and stateless {@code Gatherer} described\n+     * by the given {@code integrator}.\n+     *\n+     * @param integrator the integrator function for the new gatherer\n+     * @param <T> the type of input elements for the new gatherer\n+     * @param <R> the type of results for the new gatherer\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @return the new {@code Gatherer}\n+     *\/\n+    static <T, R> Gatherer<T, Void, R> of(Integrator<Void, T, R> integrator) {\n+        return of(\n+                defaultInitializer(),\n+                integrator,\n+                Gatherers.Value.DEFAULT.statelessCombiner,\n+                defaultFinisher()\n+        );\n+    }\n+\n+    \/**\n+     * Returns a new, parallelizable, and stateless {@code Gatherer} described\n+     * by the given {@code integrator} and {@code finisher}.\n+     *\n+     * @param integrator the integrator function for the new gatherer\n+     * @param finisher the finisher function for the new gatherer\n+     * @param <T> the type of input elements for the new gatherer\n+     * @param <R> the type of results for the new gatherer\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @return the new {@code Gatherer}\n+     *\/\n+    static <T, R> Gatherer<T, Void, R> of(\n+            Integrator<Void, T, R> integrator,\n+            BiConsumer<Void, Downstream<? super R>> finisher) {\n+        return of(\n+                defaultInitializer(),\n+                integrator,\n+                Gatherers.Value.DEFAULT.statelessCombiner,\n+                finisher\n+        );\n+    }\n+\n+    \/**\n+     * Returns a new, parallelizable, {@code Gatherer} described by the given\n+     * {@code initializer}, {@code integrator}, {@code combiner} and\n+     * {@code finisher}.\n+     *\n+     * @param initializer the supplier function for the new gatherer\n+     * @param integrator the integrator function for the new gatherer\n+     * @param combiner the combiner function for the new gatherer\n+     * @param finisher the finisher function for the new gatherer\n+     * @param <T> the type of input elements for the new gatherer\n+     * @param <A> the type of initializer for the new gatherer\n+     * @param <R> the type of results for the new gatherer\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @return the new {@code Gatherer}\n+     *\/\n+    static <T, A, R> Gatherer<T, A, R> of(\n+            Supplier<A> initializer,\n+            Integrator<A, T, R> integrator,\n+            BinaryOperator<A> combiner,\n+            BiConsumer<A, Downstream<? super R>> finisher) {\n+        return new Gatherers.GathererImpl<>(\n+                Objects.requireNonNull(initializer),\n+                Objects.requireNonNull(integrator),\n+                Objects.requireNonNull(combiner),\n+                Objects.requireNonNull(finisher)\n+        );\n+    }\n+\n+    \/**\n+     * A Downstream object is the next stage in a pipeline of operations,\n+     * to which elements can be sent.\n+     * @param <T> the type of elements this downstream accepts\n+     * @since 22\n+     *\/\n+    @FunctionalInterface\n+    @PreviewFeature(feature = PreviewFeature.Feature.STREAM_GATHERERS)\n+    interface Downstream<T> {\n+\n+        \/**\n+         * Pushes, if possible, the provided element downstream -- to the next\n+         * stage in the pipeline.\n+         *\n+         * @implSpec If this method returns {@code false} then no further\n+         * elements will be accepted and subsequent invocations of this method\n+         * will return {@code false}.\n+         *\n+         * @param element the element to push downstream\n+         * @return {@code true} if more elements can be sent,\n+         *         and {@code false} if not.\n+         *\/\n+        boolean push(T element);\n+\n+        \/**\n+         * Checks whether the next stage is known to not want\n+         * any more elements sent to it.\n+         *\n+         * @apiNote This is best-effort only, once this returns {@code true} it\n+         * should never return {@code false} again for the same instance.\n+         *\n+         * @implSpec By default this method returns {@code false}.\n+         *\n+         * @return {@code true} if this Downstream is known not to want any\n+         *         more elements sent to it, {@code false} if otherwise\n+         *\/\n+        default boolean isRejecting() { return false; }\n+    }\n+\n+    \/**\n+     * An Integrator receives elements and processes them,\n+     * optionally using the supplied state, and optionally sends incremental\n+     * results downstream.\n+     *\n+     * @param <A> the type of state used by this integrator\n+     * @param <T> the type of elements this integrator consumes\n+     * @param <R> the type of results this integrator can produce\n+     * @since 22\n+     *\/\n+    @FunctionalInterface\n+    @PreviewFeature(feature = PreviewFeature.Feature.STREAM_GATHERERS)\n+    interface Integrator<A, T, R> {\n+        \/**\n+         * Performs an action given: the current state, the next element, and\n+         * a downstream object; potentially inspecting and\/or updating\n+         * the state, optionally sending any number of elements downstream\n+         * -- and then returns whether more elements are to be consumed or not.\n+         *\n+         * @param state The state to integrate into\n+         * @param element The element to integrate\n+         * @param downstream The downstream object of this integration\n+         * @return {@code true} if subsequent integration is desired,\n+         *         {@code false} if not\n+         *\/\n+        boolean integrate(A state, T element, Downstream<? super R> downstream);\n+\n+        \/**\n+         * Factory method for turning Integrator-shaped lambdas into\n+         * Integrators.\n+         *\n+         * @param integrator a lambda to create as Integrator\n+         * @return the given lambda as an Integrator\n+         * @param <A> the type of elements this integrator receives\n+         * @param <T> the type of initializer this integrator consumes\n+         * @param <R> the type of results this integrator can produce\n+         *\/\n+        @ForceInline\n+        static <A, T, R> Integrator<A, T, R> of(Integrator<A, T, R> integrator) {\n+            return integrator;\n+        }\n+\n+        \/**\n+         * Factory method for turning Integrator-shaped lambdas into\n+         * {@link Greedy} Integrators.\n+         *\n+         * @param greedy a lambda to create as Integrator.Greedy\n+         * @return the given lambda as a Greedy Integrator\n+         * @param <A> the type of elements this integrator receives\n+         * @param <T> the type of initializer this integrator consumes\n+         * @param <R> the type of results this integrator can produce\n+         *\/\n+        @ForceInline\n+        static <A, T, R> Greedy<A, T, R> ofGreedy(Greedy<A, T, R> greedy) {\n+            return greedy;\n+        }\n+\n+        \/**\n+         * Greedy Integrators consume all their input, and may only relay that\n+         * the downstream does not want more elements.\n+         *\n+         * @implSpec This interface is used to communicate that no\n+         * short-circuiting will be <i>initiated<\/i> by this Integrator, and that\n+         * information can then be used to optimize evaluation.\n+         *\n+         * @param <A> the type of elements this greedy integrator receives\n+         * @param <T> the type of initializer this greedy integrator consumes\n+         * @param <R> the type of results this greedy integrator can produce\n+         * @since 22\n+         *\/\n+        @FunctionalInterface\n+        @PreviewFeature(feature = PreviewFeature.Feature.STREAM_GATHERERS)\n+        interface Greedy<A, T, R> extends Integrator<A, T, R> { }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherer.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"},{"patch":"@@ -0,0 +1,755 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.stream;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.concurrent.CountedCompleter;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Gatherer.Integrator;\n+\n+\/**\n+ * Runtime machinery for evaluating Gatherers under different modes.\n+ * The performance-critical code below contains some more complicated encodings:\n+ * therefore, make sure to run benchmarks to verify changes to prevent regressions.\n+ *\n+ * @since 22\n+ *\/\n+final class GathererOp<T, A, R> extends ReferencePipeline<T, R> {\n+    @SuppressWarnings(\"unchecked\")\n+    static <P_IN, P_OUT extends T, T, A, R> Stream<R> of(\n+            ReferencePipeline<P_IN, P_OUT> upstream,\n+            Gatherer<T, A, R> gatherer) {\n+        \/\/ When attaching a gather-operation onto another gather-operation,\n+        \/\/ we can fuse them into one\n+        if (upstream.getClass() == GathererOp.class) {\n+            return new GathererOp<>(\n+                    ((GathererOp<P_IN, Object, P_OUT>) upstream).gatherer.andThen(gatherer),\n+                    (GathererOp<?, ?, P_IN>) upstream);\n+        } else {\n+            return new GathererOp<>(\n+                    (ReferencePipeline<?, T>) upstream,\n+                    gatherer);\n+        }\n+    }\n+\n+    \/*\n+     * GathererOp.NodeBuilder is a lazy accumulator of elements with O(1)\n+     * `append`, and O(8) `join` (concat).\n+     *\n+     * First `append` inflates a growable Builder, the O(8) for `join` is\n+     * because we prefer to delegate to `append` for small concatenations to\n+     * avoid excessive indirections (unbalanced Concat-trees) when joining many\n+     * NodeBuilders together.\n+     *\/\n+    static final class NodeBuilder<X> implements Consumer<X> {\n+        private static final int LINEAR_APPEND_MAX = 8; \/\/ TODO revisit\n+        static final class Builder<X> extends SpinedBuffer<X> implements Node<X> {\n+            Builder() {\n+            }\n+        }\n+\n+        NodeBuilder() {\n+        }\n+\n+        private Builder<X> rightMost;\n+        private Node<X> leftMost;\n+\n+        private boolean isEmpty() {\n+            return rightMost == null && leftMost == null;\n+        }\n+\n+        @Override\n+        public void accept(X x) {\n+            final var b = rightMost;\n+            (b == null ? (rightMost = new NodeBuilder.Builder<>()) : b).accept(x);\n+        }\n+\n+        public NodeBuilder<X> join(NodeBuilder<X> that) {\n+            if (isEmpty())\n+                return that;\n+\n+            if (!that.isEmpty()) {\n+                final var tb = that.build();\n+                if (rightMost != null && tb instanceof NodeBuilder.Builder<X>\n+                && tb.count() < LINEAR_APPEND_MAX)\n+                    tb.forEach(this); \/\/ Avoid conc for small nodes\n+                else\n+                    leftMost = Nodes.conc(StreamShape.REFERENCE, this.build(), tb);\n+            }\n+\n+            return this;\n+        }\n+\n+        public Node<X> build() {\n+            if (isEmpty())\n+                return Nodes.emptyNode(StreamShape.REFERENCE);\n+\n+            final var rm = rightMost;\n+\n+            if (rm != null) {\n+                rightMost = null; \/\/ Make sure builder isn't reused\n+                final var lm = leftMost;\n+                leftMost = (lm == null) ? rm : Nodes.conc(StreamShape.REFERENCE, lm, rm);\n+            }\n+\n+            return leftMost;\n+        }\n+    }\n+\n+    static final class GatherSink<T, A, R> implements Sink<T>, Gatherer.Downstream<R> {\n+        private final Sink<R> sink;\n+        private final Gatherer<T, A, R> gatherer;\n+        private final Integrator<A, T, R> integrator; \/\/ Optimization: reuse\n+        private A state;\n+        private boolean proceed = true;\n+\n+        GatherSink(Gatherer<T, A, R> gatherer, Sink<R> sink) {\n+            this.gatherer = gatherer;\n+            this.sink = sink;\n+            this.integrator = gatherer.integrator();\n+        }\n+\n+        \/\/ java.util.stream.Sink contract below:\n+\n+        @Override\n+        public void begin(long size) {\n+            final var initializer = gatherer.initializer();\n+            if (initializer != Gatherer.defaultInitializer()) \/\/ Optimization\n+                state = initializer.get();\n+            sink.begin(size);\n+        }\n+\n+        @Override\n+        public void accept(T t) {\n+            \/* Benchmarks have indicated that doing an unconditional write to\n+             * `proceed` is more efficient than branching.\n+             * We use `&=` here to prevent flips from `false` -> `true`.\n+             *\n+             * As of writing this, taking `greedy` or `stateless` into\n+             * consideration at this point doesn't yield any performance gains.\n+             *\/\n+            proceed &= integrator.integrate(state, t, this);\n+        }\n+\n+        @Override\n+        public boolean cancellationRequested() {\n+            return cancellationRequested(proceed);\n+        }\n+\n+        private boolean cancellationRequested(boolean knownProceed) {\n+            \/\/ Highly performance sensitive\n+            return !(knownProceed && (!sink.cancellationRequested() || (proceed = false)));\n+        }\n+\n+        @Override\n+        public void end() {\n+            final var finisher = gatherer.finisher();\n+            if (finisher != Gatherer.<A, R>defaultFinisher()) \/\/ Optimization\n+                finisher.accept(state, this);\n+            sink.end();\n+            state = null; \/\/ GC assistance\n+        }\n+\n+        \/\/ Gatherer.Sink contract below:\n+\n+        @Override\n+        public boolean isRejecting() {\n+            return !proceed;\n+        }\n+\n+        @Override\n+        public boolean push(R r) {\n+            var p = proceed;\n+            if (p)\n+                sink.accept(r);\n+            return !cancellationRequested(p);\n+        }\n+    }\n+\n+    private static int opFlagsFor(Integrator<?, ?, ?> integrator) {\n+        return integrator instanceof Integrator.Greedy<?, ?, ?>\n+                ? GREEDY_FLAGS : SHORT_CIRCUIT_FLAGS;\n+    }\n+\n+    private static final int DEFAULT_FLAGS =\n+            StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT |\n+                    StreamOpFlag.NOT_SIZED;\n+\n+    private static final int SHORT_CIRCUIT_FLAGS =\n+            DEFAULT_FLAGS | StreamOpFlag.IS_SHORT_CIRCUIT;\n+\n+    private static final int GREEDY_FLAGS =\n+            DEFAULT_FLAGS;\n+\n+    final Gatherer<T, A, R> gatherer;\n+\n+    \/*\n+     * This constructor is used for initial .gather() invocations\n+     *\/\n+    private GathererOp(ReferencePipeline<?, T> upstream, Gatherer<T, A, R> gatherer) {\n+        \/* TODO this is a prime spot for pre-super calls to make sure that\n+         * we only need to call `integrator()` once.\n+         *\/\n+        super(upstream, opFlagsFor(gatherer.integrator()));\n+        this.gatherer = gatherer;\n+    }\n+\n+    \/*\n+     * This constructor is used when fusing subsequent .gather() invocations\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private GathererOp(Gatherer<T, A, R> gatherer, GathererOp<?, ?, T> upstream) {\n+        super((AbstractPipeline<?, T, ?>) upstream.upstream(),\n+              upstream,\n+              opFlagsFor(gatherer.integrator()));\n+        this.gatherer = gatherer;\n+    }\n+\n+    \/* This allows internal access to the previous stage,\n+     * to be able to fuse `gather` followed by `collect`.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private AbstractPipeline<?, T, ?> upstream() {\n+        return (AbstractPipeline<?, T, ?>) super.previousStage;\n+    }\n+\n+    @Override\n+    boolean opIsStateful() {\n+        \/\/ TODO\n+        \/* Currently GathererOp is always stateful, but what could be tried is:\n+         * return gatherer.initializer() != Gatherer.defaultInitializer()\n+         *     || gatherer.combiner() == Gatherer.defaultCombiner()\n+         *     || gatherer.finisher() != Gatherer.defaultFinisher();\n+         *\/\n+        return true;\n+    }\n+\n+    @Override\n+    Sink<T> opWrapSink(int flags, Sink<R> downstream) {\n+        return new GatherSink<>(gatherer, downstream);\n+    }\n+\n+    \/*\n+     * This is used when evaluating .gather() operations interspersed with\n+     * other Stream operations (in parallel)\n+     *\/\n+    @Override\n+    <I> Node<R> opEvaluateParallel(PipelineHelper<R> unused1,\n+                                   Spliterator<I> spliterator,\n+                                   IntFunction<R[]> unused2) {\n+        return this.<NodeBuilder<R>, Node<R>>evaluate(\n+            upstream().wrapSpliterator(spliterator),\n+            true,\n+            gatherer,\n+            NodeBuilder::new,\n+            NodeBuilder::accept,\n+            NodeBuilder::join,\n+            NodeBuilder::build\n+        );\n+    }\n+\n+    @Override\n+    <P_IN> Spliterator<R> opEvaluateParallelLazy(PipelineHelper<R> helper,\n+                                                 Spliterator<P_IN> spliterator) {\n+        \/*\n+         * There's a very small subset of possible Gatherers which would be\n+         * expressible as Spliterators directly,\n+         * - the Gatherer's initializer is Gatherer.defaultInitiatizer(),\n+         * - the Gatherer's combiner is NOT Gatherer.defaultCombiner()\n+         * - the Gatherer's finisher is Gatherer.defaultFinisher()\n+         *\/\n+        return opEvaluateParallel(null, spliterator, null).spliterator();\n+    }\n+\n+    \/* gather-operations immediately followed by (terminal) collect-operations\n+     * are fused together to avoid having to first run the gathering to\n+     * completion and only after that be able to run the collection on top of\n+     * the output.  This is highly beneficial in the parallel case as stateful\n+     * operations cannot be pipelined in the ReferencePipeline implementation.\n+     * Overriding collect-operations overcomes this limitation.\n+     *\/\n+\n+    @Override\n+    public <CR, CA> CR collect(Collector<? super R, CA, CR> c) {\n+        linkOrConsume(); \/\/ Important for structural integrity\n+        final var parallel = isParallel();\n+        final var u = upstream();\n+        return evaluate(\n+            u.wrapSpliterator(u.sourceSpliterator(0)),\n+            parallel,\n+            gatherer,\n+            c.supplier(),\n+            c.accumulator(),\n+            parallel ? c.combiner() : null,\n+            c.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)\n+                    ? null\n+                    : c.finisher()\n+        );\n+    }\n+\n+    @Override\n+    public <RR> RR collect(Supplier<RR> supplier,\n+                           BiConsumer<RR, ? super R> accumulator,\n+                           BiConsumer<RR, RR> combiner) {\n+        linkOrConsume(); \/\/ Important for structural integrity\n+        final var parallel = isParallel();\n+        final var u = upstream();\n+        return evaluate(\n+            u.wrapSpliterator(u.sourceSpliterator(0)),\n+            parallel,\n+            gatherer,\n+            supplier,\n+            accumulator,\n+            parallel ? (l, r) -> {\n+                combiner.accept(l, r);\n+                return l;\n+            } : null,\n+            null\n+        );\n+    }\n+\n+    \/*\n+     * evaluate(...) is the primary execution mechanism besides opWrapSink()\n+     * and implements both sequential, hybrid parallel-sequential, and\n+     * parallel evaluation\n+     *\/\n+    private <CA, CR> CR evaluate(final Spliterator<T> spliterator,\n+                                 final boolean parallel,\n+                                 final Gatherer<T, A, R> gatherer,\n+                                 final Supplier<CA> collectorSupplier,\n+                                 final BiConsumer<CA, ? super R> collectorAccumulator,\n+                                 final BinaryOperator<CA> collectorCombiner,\n+                                 final Function<CA, CR> collectorFinisher) {\n+\n+        \/\/ There are two main sections here: sequential and parallel\n+\n+        final var initializer = gatherer.initializer();\n+        final var integrator = gatherer.integrator();\n+\n+        \/\/ Optimization\n+        final boolean greedy = integrator instanceof Integrator.Greedy<A, T, R>;\n+\n+        \/\/ Sequential evaluation section starts here.\n+\n+        \/\/ Sequential is the fusion of a Gatherer and a Collector which can\n+        \/\/ be evaluated sequentially.\n+        final class Sequential implements Consumer<T>, Gatherer.Downstream<R> {\n+            A state;\n+            CA collectorState;\n+            boolean proceed;\n+\n+            Sequential() {\n+                if (initializer != Gatherer.defaultInitializer())\n+                    state = initializer.get();\n+                collectorState = collectorSupplier.get();\n+                proceed = true;\n+            }\n+\n+            @ForceInline\n+            Sequential evaluateUsing(Spliterator<T> spliterator) {\n+                if (greedy)\n+                    spliterator.forEachRemaining(this);\n+                else\n+                    do {\n+                    } while (proceed && spliterator.tryAdvance(this));\n+\n+                return this;\n+            }\n+\n+            \/*\n+             * No need to override isKnownDone() as the default is `false`\n+             * and collectors can never short-circuit.\n+             *\/\n+            @Override\n+            public boolean push(R r) {\n+                collectorAccumulator.accept(collectorState, r);\n+                return true;\n+            }\n+\n+            @Override\n+            public void accept(T t) {\n+                \/*\n+                 * Benchmarking has shown that, in this case, conditional\n+                 * writing of `proceed` is desirable  and if that was not the\n+                 *  case, then the following line would've been clearer:\n+                 *\n+                 * proceed &= integrator.integrate(state, t, this);\n+                 *\/\n+\n+                var ignore = integrator.integrate(state, t, this)\n+                             || (!greedy && (proceed = false));\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            public CR get() {\n+                final var finisher = gatherer.finisher();\n+                if (finisher != Gatherer.<A, R>defaultFinisher())\n+                    finisher.accept(state, this);\n+                \/\/ IF collectorFinisher == null -> IDENTITY_FINISH\n+                return (collectorFinisher == null)\n+                           ? (CR) collectorState\n+                           : collectorFinisher.apply(collectorState);\n+            }\n+        }\n+\n+        \/*\n+         * It could be considered to also go to sequential mode if the\n+         * operation is non-greedy AND the combiner is Gatherer.defaultCombiner()\n+         * as those operations will not benefit from upstream parallel\n+         * preprocessing which is the main advantage of the Hybrid evaluation\n+         * strategy.\n+         *\/\n+        if (!parallel)\n+            return new Sequential().evaluateUsing(spliterator).get();\n+\n+        \/\/ Parallel section starts here:\n+\n+        final var combiner = gatherer.combiner();\n+\n+        \/*\n+         * The following implementation of hybrid parallel-sequential\n+         * Gatherer processing borrows heavily from ForeachOrderedTask,\n+         * and adds handling of short-circuiting.\n+         *\/\n+        @SuppressWarnings(\"serial\")\n+        final class Hybrid extends CountedCompleter<Sequential> {\n+            private final long targetSize;\n+            private final Hybrid leftPredecessor;\n+            private final AtomicBoolean cancelled;\n+            private final Sequential localResult;\n+\n+            private Spliterator<T> spliterator;\n+            private Hybrid next;\n+\n+            private static final VarHandle NEXT;\n+\n+            static {\n+                try {\n+                    MethodHandles.Lookup l = MethodHandles.lookup();\n+                    NEXT = l.findVarHandle(Hybrid.class, \"next\", Hybrid.class);\n+                } catch (Exception e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+\n+            protected Hybrid(Spliterator<T> spliterator) {\n+                super(null);\n+                this.spliterator = spliterator;\n+                this.targetSize =\n+                    AbstractTask.suggestTargetSize(spliterator.estimateSize());\n+                this.localResult = new Sequential();\n+                this.cancelled = greedy ? null : new AtomicBoolean(false);\n+                this.leftPredecessor = null;\n+            }\n+\n+            Hybrid(Hybrid parent, Spliterator<T> spliterator, Hybrid leftPredecessor) {\n+                super(parent);\n+                this.spliterator = spliterator;\n+                this.targetSize = parent.targetSize;\n+                this.localResult = parent.localResult;\n+                this.cancelled = parent.cancelled;\n+                this.leftPredecessor = leftPredecessor;\n+            }\n+\n+            @Override\n+            public Sequential getRawResult() {\n+                return localResult;\n+            }\n+\n+            @Override\n+            public void setRawResult(Sequential result) {\n+                if (result != null) throw new IllegalStateException();\n+            }\n+\n+            @Override\n+            public void compute() {\n+                var task = this;\n+                Spliterator<T> rightSplit = task.spliterator, leftSplit;\n+                long sizeThreshold = task.targetSize;\n+                boolean forkRight = false;\n+                while ((greedy || !cancelled.get())\n+                       && rightSplit.estimateSize() > sizeThreshold\n+                       && (leftSplit = rightSplit.trySplit()) != null) {\n+\n+                    var leftChild = new Hybrid(task, leftSplit, task.leftPredecessor);\n+                    var rightChild = new Hybrid(task, rightSplit, leftChild);\n+\n+                    \/* leftChild and rightChild were just created and not\n+                     * fork():ed yet so no need for a volatile write\n+                     *\/\n+                    leftChild.next = rightChild;\n+\n+                    \/\/ Fork the parent task\n+                    \/\/ Completion of the left and right children \"happens-before\"\n+                    \/\/ completion of the parent\n+                    task.addToPendingCount(1);\n+                    \/\/ Completion of the left child \"happens-before\" completion of\n+                    \/\/ the right child\n+                    rightChild.addToPendingCount(1);\n+\n+                    \/\/ If task is not on the left spine\n+                    if (task.leftPredecessor != null) {\n+                        \/*\n+                         * Completion of left-predecessor, or left subtree,\n+                         * \"happens-before\" completion of left-most leaf node of\n+                         * right subtree.\n+                         * The left child's pending count needs to be updated before\n+                         * it is associated in the completion map, otherwise the\n+                         * left child can complete prematurely and violate the\n+                         * \"happens-before\" constraint.\n+                         *\/\n+                        leftChild.addToPendingCount(1);\n+                        \/\/ Update association of left-predecessor to left-most\n+                        \/\/ leaf node of right subtree\n+                        if (NEXT.compareAndSet(task.leftPredecessor, task, leftChild)) {\n+                            \/\/ If replaced, adjust the pending count of the parent\n+                            \/\/ to complete when its children complete\n+                            task.addToPendingCount(-1);\n+                        } else {\n+                            \/\/ Left-predecessor has already completed, parent's\n+                            \/\/ pending count is adjusted by left-predecessor;\n+                            \/\/ left child is ready to complete\n+                            leftChild.addToPendingCount(-1);\n+                        }\n+                    }\n+\n+                    if (forkRight) {\n+                        rightSplit = leftSplit;\n+                        task = leftChild;\n+                        rightChild.fork();\n+                    } else {\n+                        task = rightChild;\n+                        leftChild.fork();\n+                    }\n+                    forkRight = !forkRight;\n+                }\n+\n+                \/*\n+                 * Task's pending count is either 0 or 1.  If 1 then the completion\n+                 * map will contain a value that is task, and two calls to\n+                 * tryComplete are required for completion, one below and one\n+                 * triggered by the completion of task's left-predecessor in\n+                 * onCompletion.  Therefore there is no data race within the if\n+                 * block.\n+                 *\n+                 * IMPORTANT: Currently we only perform the processing of this\n+                 * upstream data if we know the operation is greedy -- as we cannot\n+                 * safely speculate on the cost\/benefit ratio of parallelizing\n+                 * the pre-processing of upstream data under short-circuiting.\n+                 *\/\n+                if (greedy && task.getPendingCount() > 0) {\n+                    \/\/ Upstream elements are buffered\n+                    NodeBuilder<T> nb = new NodeBuilder<>();\n+                    rightSplit.forEachRemaining(nb); \/\/ Run the upstream\n+                    task.spliterator = nb.build().spliterator();\n+                }\n+                task.tryComplete();\n+            }\n+\n+            @Override\n+            public void onCompletion(CountedCompleter<?> caller) {\n+                var s = spliterator;\n+                spliterator = null; \/\/ GC assistance\n+\n+                \/* Performance sensitive since each leaf-task could have a\n+                 * spliterator of size 1 which means that all else is overhead\n+                 * which needs minimization.\n+                 *\/\n+                if (s != null\n+                    && (greedy || !cancelled.get())\n+                    && !localResult.evaluateUsing(s).proceed\n+                    && !greedy)\n+                    cancelled.set(true);\n+\n+                \/\/ The completion of this task *and* the dumping of elements\n+                \/\/ \"happens-before\" completion of the associated left-most leaf task\n+                \/\/ of right subtree (if any, which can be this task's right sibling)\n+                @SuppressWarnings(\"unchecked\")\n+                var leftDescendant = (Hybrid) NEXT.getAndSet(this, null);\n+                if (leftDescendant != null) {\n+                    leftDescendant.tryComplete();\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * The following implementation of parallel Gatherer processing\n+         * borrows heavily from AbstractShortCircuitTask\n+         *\/\n+        @SuppressWarnings(\"serial\")\n+        final class Parallel extends CountedCompleter<Sequential> {\n+            private Spliterator<T> spliterator;\n+            private Parallel leftChild; \/\/ Only non-null if rightChild is\n+            private Parallel rightChild; \/\/ Only non-null if leftChild is\n+            private Sequential localResult;\n+            private volatile boolean canceled;\n+            private long targetSize; \/\/ lazily initialized\n+\n+            private Parallel(Parallel parent, Spliterator<T> spliterator) {\n+                super(parent);\n+                this.targetSize = parent.targetSize;\n+                this.spliterator = spliterator;\n+            }\n+\n+            Parallel(Spliterator<T> spliterator) {\n+                super(null);\n+                this.targetSize = 0L;\n+                this.spliterator = spliterator;\n+            }\n+\n+            private long getTargetSize(long sizeEstimate) {\n+                long s;\n+                return ((s = targetSize) != 0\n+                        ? s\n+                        : (targetSize = AbstractTask.suggestTargetSize(sizeEstimate)));\n+            }\n+\n+            @Override\n+            public Sequential getRawResult() {\n+                return localResult;\n+            }\n+\n+            @Override\n+            public void setRawResult(Sequential result) {\n+                if (result != null) throw new IllegalStateException();\n+            }\n+\n+            private void doProcess() {\n+                if (!(localResult = new Sequential()).evaluateUsing(spliterator).proceed\n+                    && !greedy)\n+                    cancelLaterTasks();\n+            }\n+\n+            @Override\n+            public void compute() {\n+                Spliterator<T> rs = spliterator, ls;\n+                long sizeEstimate = rs.estimateSize();\n+                final long sizeThreshold = getTargetSize(sizeEstimate);\n+                Parallel task = this;\n+                boolean forkRight = false;\n+                boolean proceed;\n+                while ((proceed = (greedy || !task.isRequestedToCancel()))\n+                        && sizeEstimate > sizeThreshold\n+                        && (ls = rs.trySplit()) != null) {\n+                    final var leftChild = task.leftChild = new Parallel(task, ls);\n+                    final var rightChild = task.rightChild = new Parallel(task, rs);\n+                    task.setPendingCount(1);\n+                    if (forkRight) {\n+                        rs = ls;\n+                        task = leftChild;\n+                        rightChild.fork();\n+                    } else {\n+                        task = rightChild;\n+                        leftChild.fork();\n+                    }\n+                    forkRight = !forkRight;\n+                    sizeEstimate = rs.estimateSize();\n+                }\n+                if (proceed)\n+                    task.doProcess();\n+                task.tryComplete();\n+            }\n+\n+            Sequential merge(Sequential l, Sequential r) {\n+                \/*\n+                 * Only join the right if the left side didn't short-circuit,\n+                 * or when greedy\n+                 *\/\n+                if (greedy || (l != null && r != null && l.proceed)) {\n+                    l.state = combiner.apply(l.state, r.state);\n+                    l.collectorState =\n+                        collectorCombiner.apply(l.collectorState, r.collectorState);\n+                    l.proceed = r.proceed;\n+                    return l;\n+                }\n+\n+                return (l != null) ? l : r;\n+            }\n+\n+            @Override\n+            public void onCompletion(CountedCompleter<?> caller) {\n+                spliterator = null; \/\/ GC assistance\n+                if (leftChild != null) {\n+                    \/* Results can only be null in the case where there's\n+                     * short-circuiting or when Gatherers are stateful but\n+                     * uses `null` as their state value.\n+                     *\/\n+                    localResult = merge(leftChild.localResult, rightChild.localResult);\n+                    leftChild = rightChild = null; \/\/ GC assistance\n+                }\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            private Parallel getParent() {\n+                return (Parallel) getCompleter();\n+            }\n+\n+            private boolean isRequestedToCancel() {\n+                boolean cancel = canceled;\n+                if (!cancel) {\n+                    for (Parallel parent = getParent();\n+                         !cancel && parent != null;\n+                         parent = parent.getParent())\n+                        cancel = parent.canceled;\n+                }\n+                return cancel;\n+            }\n+\n+            private void cancelLaterTasks() {\n+                \/\/ Go up the tree, cancel right siblings of this node and all parents\n+                for (Parallel parent = getParent(), node = this;\n+                     parent != null;\n+                     node = parent, parent = parent.getParent()) {\n+                    \/\/ If node is a left child of parent, then has a right sibling\n+                    if (parent.leftChild == node)\n+                        parent.rightChild.canceled = true;\n+                }\n+            }\n+        }\n+\n+        if (combiner != Gatherer.defaultCombiner())\n+            return new Parallel(spliterator).invoke().get();\n+        else\n+            return new Hybrid(spliterator).invoke().get();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":755,"deletions":0,"binary":false,"changes":755,"status":"added"},{"patch":"@@ -0,0 +1,695 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.stream;\n+\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Gatherer.Integrator;\n+import java.util.stream.Gatherer.Downstream;\n+\n+\/**\n+ * Implementations of {@link Gatherer} that provide useful intermediate\n+ * operations, such as windowing functions, folding functions,\n+ * transforming elements concurrently, etc.\n+ *\n+ * @since 22\n+*\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STREAM_GATHERERS)\n+public final class Gatherers {\n+    private Gatherers() { } \/\/ This class is not intended to be instantiated\n+\n+    \/\/ Public built-in Gatherers and factory methods for them\n+\n+    \/**\n+     * Returns a Gatherer that gathers elements into windows\n+     * -- encounter-ordered groups of elements -- of a fixed size.\n+     * If the stream is empty then no window will be produced.\n+     * The last window may contain fewer elements than the supplied window size.\n+     *\n+     * <p>Example:\n+     * {@snippet lang = java:\n+     * \/\/ will contain: [[1, 2, 3], [4, 5, 6], [7, 8]]\n+     * List<List<Integer>> windows =\n+     *     Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList();\n+     * }\n+     *\n+     * @implSpec Each window produced is an unmodifiable List; calls to any\n+     * mutator method will always cause {@code UnsupportedOperationException}\n+     * to be thrown. There are no guarantees on the implementation type or\n+     * serializability of the produced Lists.\n+     *\n+     * @apiNote For efficiency reasons, windows may be allocated contiguously\n+     *          and eagerly. This means that choosing large window sizes for\n+     *          small streams may use excessive memory for the duration of\n+     *          evaluation of this operation.\n+     *\n+     * @param windowSize the size of the windows\n+     * @param <TR> the type of elements the returned gatherer consumes\n+     *             and the contents of the windows it produces\n+     * @return a new gatherer which groups elements into fixed-size windows\n+     * @throws IllegalArgumentException when {@code windowSize} is less than 1\n+     *\/\n+    public static <TR> Gatherer<TR, ?, List<TR>> windowFixed(int windowSize) {\n+        if (windowSize < 1)\n+            throw new IllegalArgumentException(\"'windowSize' must be greater than zero\");\n+\n+        class FixedWindow {\n+            Object[] window;\n+            int at;\n+\n+            FixedWindow() {\n+                at = 0;\n+                window = new Object[windowSize];\n+            }\n+\n+            boolean integrate(TR element, Downstream<? super List<TR>> downstream) {\n+                window[at++] = element;\n+                if (at < windowSize) {\n+                    return true;\n+                } else {\n+                    final var oldWindow = window;\n+                    window = new Object[windowSize];\n+                    at = 0;\n+                    return downstream.push(\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(oldWindow)\n+                    );\n+                }\n+            }\n+\n+            void finish(Downstream<? super List<TR>> downstream) {\n+                if (at > 0 && !downstream.isRejecting()) {\n+                    var lastWindow = new Object[at];\n+                    System.arraycopy(window, 0, lastWindow, 0, at);\n+                    window = null;\n+                    at = 0;\n+                    downstream.push(\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(lastWindow)\n+                    );\n+                }\n+            }\n+        }\n+        return Gatherer.<TR, FixedWindow, List<TR>>ofSequential(\n+                \/\/ Initializer\n+                FixedWindow::new,\n+\n+                \/\/ Integrator\n+                Integrator.<FixedWindow, TR, List<TR>>ofGreedy(FixedWindow::integrate),\n+\n+                \/\/ Finisher\n+                FixedWindow::finish\n+        );\n+    }\n+\n+    \/**\n+     * Returns a Gatherer that gathers elements into windows --\n+     * encounter-ordered groups of elements -- of a given size, where each\n+     * subsequent window includes all elements of the previous window except\n+     * for the least recent, and adds the next element in the stream.\n+     * If the stream is empty then no window will be produced. If the size of\n+     * the stream is smaller than the window size then only one window will\n+     * be produced, containing all elements in the stream.\n+     *\n+     * <p>Example:\n+     * {@snippet lang = java:\n+     * \/\/ will contain: [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8]]\n+     * List<List<Integer>> windows2 =\n+     *     Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowSliding(2)).toList();\n+     *\n+     * \/\/ will contain: [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8]]\n+     * List<List<Integer>> windows6 =\n+     *     Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowSliding(6)).toList();\n+     * }\n+     *\n+     * @implSpec Each window produced is an unmodifiable List; calls to any\n+     * mutator method will always cause {@code UnsupportedOperationException}\n+     * to be thrown. There are no guarantees on the implementation type or\n+     * serializability of the produced Lists.\n+     *\n+     * @apiNote For efficiency reasons, windows may be allocated contiguously\n+     *          and eagerly. This means that choosing large window sizes for\n+     *          small streams may use excessive memory for the duration of\n+     *          evaluation of this operation.\n+     *\n+     * @param windowSize the size of the windows\n+     * @param <TR> the type of elements the returned gatherer consumes\n+     *             and the contents of the windows it produces\n+     * @return a new gatherer which groups elements into sliding windows\n+     * @throws IllegalArgumentException when windowSize is less than 1\n+     *\/\n+    public static <TR> Gatherer<TR, ?, List<TR>> windowSliding(int windowSize) {\n+        if (windowSize < 1)\n+            throw new IllegalArgumentException(\"'windowSize' must be greater than zero\");\n+\n+        class SlidingWindow {\n+            Object[] window;\n+            int at;\n+            boolean firstWindow;\n+\n+            SlidingWindow() {\n+                firstWindow = true;\n+                at = 0;\n+                window = new Object[windowSize];\n+            }\n+\n+            boolean integrate(TR element, Downstream<? super List<TR>> downstream) {\n+                window[at++] = element;\n+                if (at < windowSize) {\n+                    return true;\n+                } else {\n+                    final var oldWindow = window;\n+                    final var newWindow = new Object[windowSize];\n+                    System.arraycopy(oldWindow,1, newWindow, 0, windowSize - 1);\n+                    window = newWindow;\n+                    at -= 1;\n+                    firstWindow = false;\n+                    return downstream.push(\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(oldWindow)\n+                    );\n+                }\n+            }\n+\n+            void finish(Downstream<? super List<TR>> downstream) {\n+                if (firstWindow && at > 0 && !downstream.isRejecting()) {\n+                    var lastWindow = new Object[at];\n+                    System.arraycopy(window, 0, lastWindow, 0, at);\n+                    window = null;\n+                    at = 0;\n+                    downstream.push(\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(lastWindow)\n+                    );\n+                }\n+            }\n+        }\n+        return Gatherer.<TR, SlidingWindow, List<TR>>ofSequential(\n+                \/\/ Initializer\n+                SlidingWindow::new,\n+\n+                \/\/ Integrator\n+                Integrator.<SlidingWindow, TR, List<TR>>ofGreedy(SlidingWindow::integrate),\n+\n+                \/\/ Finisher\n+                SlidingWindow::finish\n+        );\n+    }\n+\n+    \/**\n+     * Returns a Gatherer that performs an ordered, <i>reduction-like<\/i>,\n+     * transformation for scenarios where no combiner-function can be\n+     * implemented, or for reductions which are intrinsically\n+     * order-dependent.\n+     *\n+     * @implSpec If no exceptions are thrown during processing, then this\n+     * operation only ever produces a single element.\n+     *\n+     * <p>Example:\n+     * {@snippet lang = java:\n+     * \/\/ will contain: Optional[\"123456789\"]\n+     * Optional<String> numberString =\n+     *     Stream.of(1,2,3,4,5,6,7,8,9)\n+     *           .gather(\n+     *               Gatherers.fold(() -> \"\", (string, number) -> string + number)\n+     *            )\n+     *           .findFirst();\n+     * }\n+     *\n+     * @see java.util.stream.Stream#reduce(Object, BinaryOperator)\n+     *\n+     * @param initial the identity value for the fold operation\n+     * @param folder the folding function\n+     * @param <T> the type of elements the returned gatherer consumes\n+     * @param <R> the type of elements the returned gatherer produces\n+     * @return a new Gatherer\n+     * @throws NullPointerException if any of the parameters are {@code null}\n+     *\/\n+    public static <T, R> Gatherer<T, ?, R> fold(\n+            Supplier<R> initial,\n+            BiFunction<? super R, ? super T, ? extends R> folder) {\n+        Objects.requireNonNull(initial, \"'initial' must not be null\");\n+        Objects.requireNonNull(folder, \"'folder' must not be null\");\n+\n+        class State {\n+            R value = initial.get();\n+            State() {}\n+        }\n+\n+        return Gatherer.ofSequential(\n+                State::new,\n+                Integrator.ofGreedy((state, element, downstream) -> {\n+                    state.value = folder.apply(state.value, element);\n+                    return true;\n+                }),\n+                (state, downstream) -> downstream.push(state.value)\n+        );\n+    }\n+\n+    \/**\n+     * Returns a Gatherer that performs a Prefix Scan -- an incremental\n+     * accumulation -- using the provided functions.  Starting with an\n+     * initial value obtained from the {@code Supplier}, each subsequent\n+     * value is obtained by applying the {@code BiFunction} to the current\n+     * value and the next input element, after which the resulting value is\n+     * produced downstream.\n+     *\n+     * <p>Example:\n+     * {@snippet lang = java:\n+     * \/\/ will contain: [\"1\", \"12\", \"123\", \"1234\", \"12345\", \"123456\", \"1234567\", \"12345678\", \"123456789\"]\n+     * List<String> numberStrings =\n+     *     Stream.of(1,2,3,4,5,6,7,8,9)\n+     *           .gather(\n+     *               Gatherers.scan(() -> \"\", (string, number) -> string + number)\n+     *            )\n+     *           .toList();\n+     * }\n+     *\n+     * @param initial the supplier of the initial value for the scanner\n+     * @param scanner the function to apply for each element\n+     * @param <T> the type of element which this gatherer consumes\n+     * @param <R> the type of element which this gatherer produces\n+     * @return a new Gatherer which performs a prefix scan\n+     * @throws NullPointerException if any of the parameters are {@code null}\n+     *\/\n+    public static <T, R> Gatherer<T, ?, R> scan(\n+            Supplier<R> initial,\n+            BiFunction<? super R, ? super T, ? extends R> scanner) {\n+        Objects.requireNonNull(initial, \"'initial' must not be null\");\n+        Objects.requireNonNull(scanner, \"'scanner' must not be null\");\n+\n+        class State {\n+            R current = initial.get();\n+            boolean integrate(T element, Downstream<? super R> downstream) {\n+                return downstream.push(current = scanner.apply(current, element));\n+            }\n+        }\n+\n+        return Gatherer.ofSequential(State::new,\n+                Integrator.<State,T, R>ofGreedy(State::integrate));\n+    }\n+\n+    \/**\n+     * An operation which executes a function concurrently\n+     * with a configured level of max concurrency, using\n+     * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>.\n+     * This operation preserves the ordering of the stream.\n+     *\n+     * <p>In progress tasks will be attempted to be cancelled,\n+     * on a best-effort basis, in situations where the downstream no longer\n+     * wants to receive any more elements.\n+     *\n+     * <p>If a result of the function is to be pushed downstream but instead the function completed\n+     * exceptionally then the corresponding exception will instead be rethrown by this method as an \n+     * instance of {@link RuntimeException}. After which any remaining tasks are canceled. \n+     *\n+     * @param maxConcurrency the maximum concurrency desired\n+     * @param mapper a function to be executed concurrently\n+     * @param <T> the type of input\n+     * @param <R> the type of output\n+     * @return a new Gatherer\n+     * @throws IllegalArgumentException if {@code maxConcurrency} is less than 1\n+     * @throws NullPointerException if {@code mapper} is {@code null}\n+     *\/\n+    public static <T, R> Gatherer<T,?,R> mapConcurrent(\n+            final int maxConcurrency,\n+            final Function<? super T, ? extends R> mapper) {\n+        if (maxConcurrency < 1)\n+            throw new IllegalArgumentException(\n+                    \"'maxConcurrency' must be greater than 0\");\n+\n+        Objects.requireNonNull(mapper, \"'mapper' must not be null\");\n+\n+        class State {\n+            final ArrayDeque<Future<R>> window = new ArrayDeque<>(maxConcurrency);\n+            final Semaphore windowLock = new Semaphore(maxConcurrency);\n+\n+            final boolean integrate(T element,\n+                                    Downstream<? super R> downstream) {\n+                if (!downstream.isRejecting())\n+                    createTaskFor(element);\n+                return flush(0, downstream);\n+            }\n+\n+            final void createTaskFor(T element) {\n+                windowLock.acquireUninterruptibly();\n+\n+                var task = new FutureTask<R>(() -> {\n+                    try {\n+                        return mapper.apply(element);\n+                    } finally {\n+                        windowLock.release();\n+                    }\n+                });\n+\n+                var wasAddedToWindow = window.add(task);\n+                assert wasAddedToWindow;\n+\n+                Thread.startVirtualThread(task);\n+            }\n+\n+            final boolean flush(long atLeastN,\n+                                Downstream<? super R> downstream) {\n+                boolean proceed = !downstream.isRejecting();\n+                try {\n+                    Future<R> current;\n+                    while (proceed\n+                            && (current = window.peek()) != null\n+                                && (current.isDone() || atLeastN > 0)) {\n+                        proceed &= downstream.push(current.get());\n+                        atLeastN -= 1;\n+\n+                        var correctRemoval = window.pop() == current;\n+                        assert correctRemoval;\n+                    }\n+                } catch (Exception e) {\n+                    proceed = false; \/\/ Ensure cleanup\n+                    throw (e instanceof RuntimeException re)\n+                            ? re\n+                            : new RuntimeException(e);\n+                } finally {\n+                    \/\/ Clean up\n+                    if (!proceed) {\n+                        Future<R> next;\n+                        while ((next = window.pollFirst()) != null) {\n+                            next.cancel(true);\n+                        }\n+                    }\n+                }\n+\n+                return proceed;\n+            }\n+        }\n+\n+        return Gatherer.ofSequential(\n+                State::new,\n+                Integrator.<State, T, R>ofGreedy(State::integrate),\n+                (state, downstream) -> state.flush(Long.MAX_VALUE, downstream)\n+        );\n+    }\n+\n+    \/\/ Implementation details\n+\n+    \/*\n+     * This enum is used to provide the default functions for the\n+     * factory methods\n+     * and for the default methods for when implementing the Gatherer interface.\n+     *\n+     * This serves the following purposes:\n+     * 1. removes the need for using `null` for signalling absence of specified\n+     *    value and thereby hiding user bugs\n+     * 2. allows to check against these default values to avoid calling methods\n+     *    needlessly\n+     * 3. allows for more efficient composition and evaluation\n+     *\/\n+    @SuppressWarnings(\"rawtypes\")\n+    enum Value implements Supplier, BinaryOperator, BiConsumer {\n+        DEFAULT;\n+\n+        final BinaryOperator<Void> statelessCombiner = new BinaryOperator<>() {\n+            @Override public Void apply(Void left, Void right) { return null; }\n+        };\n+\n+        \/\/ BiConsumer\n+        @Override public void accept(Object state, Object downstream) {}\n+\n+        \/\/ BinaryOperator\n+        @Override public Object apply(Object left, Object right) {\n+            throw new UnsupportedOperationException(\"This combiner cannot be used!\");\n+        }\n+\n+        \/\/ Supplier\n+        @Override public Object get() { return null; }\n+\n+        @ForceInline\n+        @SuppressWarnings(\"unchecked\")\n+        <A> Supplier<A> initializer() { return (Supplier<A>)this; }\n+\n+        @ForceInline\n+        @SuppressWarnings(\"unchecked\")\n+        <T> BinaryOperator<T> combiner() { return (BinaryOperator<T>) this; }\n+\n+        @ForceInline\n+        @SuppressWarnings(\"unchecked\")\n+        <T, R> BiConsumer<T, Gatherer.Downstream<? super R>> finisher() {\n+            return (BiConsumer<T, Downstream<? super R>>) this;\n+        }\n+    }\n+\n+    record GathererImpl<T, A, R>(\n+            @Override Supplier<A> initializer,\n+            @Override Integrator<A, T, R> integrator,\n+            @Override BinaryOperator<A> combiner,\n+            @Override BiConsumer<A, Downstream<? super R>> finisher) implements Gatherer<T, A, R> {\n+\n+        static <T, A, R> GathererImpl<T, A, R> of(\n+                Supplier<A> initializer,\n+                Integrator<A, T, R> integrator,\n+                BinaryOperator<A> combiner,\n+                BiConsumer<A, Downstream<? super R>> finisher) {\n+            return new GathererImpl<>(\n+                    Objects.requireNonNull(initializer,\"initializer\"),\n+                    Objects.requireNonNull(integrator, \"integrator\"),\n+                    Objects.requireNonNull(combiner, \"combiner\"),\n+                    Objects.requireNonNull(finisher, \"finisher\")\n+            );\n+        }\n+    }\n+\n+    static final class Composite<T, A, R, AA, RR> implements Gatherer<T, Object, RR> {\n+        private final Gatherer<T, A, ? extends R> left;\n+        private final Gatherer<? super R, AA, ? extends RR> right;\n+        \/\/ FIXME change `impl` to a computed constant when available\n+        private GathererImpl<T, Object, RR> impl;\n+\n+        static <T, A, R, AA, RR> Composite<T, A, R, AA, RR> of(\n+                Gatherer<T, A, ? extends R> left,\n+                Gatherer<? super R, AA, ? extends RR> right) {\n+            return new Composite<>(left, right);\n+        }\n+\n+        private Composite(Gatherer<T, A, ? extends R> left,\n+                          Gatherer<? super R, AA, ? extends RR> right) {\n+            this.left = left;\n+            this.right = right;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private GathererImpl<T, Object, RR> impl() {\n+            \/\/ ATTENTION: this method currently relies on a \"benign\" data-race\n+            \/\/ as it should deterministically produce the same result even if\n+            \/\/ initialized concurrently on different threads.\n+            var i = impl;\n+            return i != null\n+                     ? i\n+                     : (impl = (GathererImpl<T, Object, RR>)impl(left, right));\n+        }\n+\n+        @Override public Supplier<Object> initializer() {\n+            return impl().initializer();\n+        }\n+\n+        @Override public Integrator<Object, T, RR> integrator() {\n+            return impl().integrator();\n+        }\n+\n+        @Override public BinaryOperator<Object> combiner() {\n+            return impl().combiner();\n+        }\n+\n+        @Override public BiConsumer<Object, Downstream<? super RR>> finisher() {\n+            return impl().finisher();\n+        }\n+\n+        @Override\n+        public <RRR> Gatherer<T, ?, RRR> andThen(\n+                Gatherer<? super RR, ?, ? extends RRR> that) {\n+            if (that.getClass() == Composite.class) {\n+                @SuppressWarnings(\"unchecked\")\n+                final var c =\n+                    (Composite<? super RR, ?, Object, ?, ? extends RRR>) that;\n+                return left.andThen(right.andThen(c.left).andThen(c.right));\n+            } else {\n+                return left.andThen(right.andThen(that));\n+            }\n+        }\n+\n+        static final <T, A, R, AA, RR> GathererImpl<T, ?, RR> impl(\n+                Gatherer<T, A, R> left, Gatherer<? super R, AA, RR> right) {\n+            final var leftInitializer = left.initializer();\n+            final var leftIntegrator = left.integrator();\n+            final var leftCombiner = left.combiner();\n+            final var leftFinisher = left.finisher();\n+\n+            final var rightInitializer = right.initializer();\n+            final var rightIntegrator = right.integrator();\n+            final var rightCombiner = right.combiner();\n+            final var rightFinisher = right.finisher();\n+\n+            final var leftStateless = leftInitializer == Gatherer.defaultInitializer();\n+            final var rightStateless = rightInitializer == Gatherer.defaultInitializer();\n+\n+            final var leftGreedy = leftIntegrator instanceof Integrator.Greedy;\n+            final var rightGreedy = rightIntegrator instanceof Integrator.Greedy;\n+\n+            \/*\n+             * For pairs of stateless and greedy Gatherers, we can optimize\n+             * evaluation as we do not need to track any state nor any\n+             * short-circuit signals. This can provide significant\n+             * performance improvements.\n+             *\/\n+            if (leftStateless && rightStateless && leftGreedy && rightGreedy) {\n+                return new GathererImpl<>(\n+                    Gatherer.defaultInitializer(),\n+                    Gatherer.Integrator.ofGreedy((unused, element, downstream) ->\n+                        leftIntegrator.integrate(\n+                                null,\n+                                element,\n+                                r -> rightIntegrator.integrate(null, r, downstream))\n+                    ),\n+                    (leftCombiner == Gatherer.defaultCombiner()\n+                    || rightCombiner == Gatherer.defaultCombiner())\n+                            ? Gatherer.defaultCombiner()\n+                            : Value.DEFAULT.statelessCombiner\n+                    ,\n+                    (leftFinisher == Gatherer.<A,R>defaultFinisher()\n+                    && rightFinisher == Gatherer.<AA,RR>defaultFinisher())\n+                            ? Gatherer.defaultFinisher()\n+                            : (unused, downstream) -> {\n+                        if (leftFinisher != Gatherer.<A,R>defaultFinisher())\n+                            leftFinisher.accept(\n+                                    null,\n+                                    r -> rightIntegrator.integrate(null, r, downstream));\n+                        if (rightFinisher != Gatherer.<AA,RR>defaultFinisher())\n+                            rightFinisher.accept(null, downstream);\n+                    }\n+                );\n+            } else {\n+                class State {\n+                    final A leftState;\n+                    final AA rightState;\n+                    boolean leftProceed;\n+                    boolean rightProceed;\n+\n+                    private State(A leftState, AA rightState,\n+                                  boolean leftProceed, boolean rightProceed) {\n+                        this.leftState = leftState;\n+                        this.rightState = rightState;\n+                        this.leftProceed = leftProceed;\n+                        this.rightProceed = rightProceed;\n+                    }\n+\n+                    State() {\n+                        this(leftStateless ? null : leftInitializer.get(),\n+                             rightStateless ? null : rightInitializer.get(),\n+                            true, true);\n+                    }\n+\n+                    State joinLeft(State right) {\n+                        return new State(\n+                                leftStateless ? null : leftCombiner.apply(this.leftState, right.leftState),\n+                                rightStateless ? null : rightCombiner.apply(this.rightState, right.rightState),\n+                                this.leftProceed && this.rightProceed,\n+                                right.leftProceed && right.rightProceed);\n+                    }\n+\n+                    boolean integrate(T t, Downstream<? super RR> c) {\n+                        \/*\n+                         * rightProceed must be checked after integration of\n+                         * left since that can cause right to short-circuit\n+                         * We always want to conditionally write leftProceed\n+                         * here, which means that we only do so if we are\n+                         * known to be not-greedy.\n+                         *\/\n+                        return (leftIntegrator.integrate(leftState, t, r -> rightIntegrate(r, c))\n+                                  || leftGreedy\n+                                  || (leftProceed = false))\n+                                && (rightGreedy || rightProceed);\n+                    }\n+\n+                    void finish(Downstream<? super RR> c) {\n+                        if (leftFinisher != Gatherer.<A, R>defaultFinisher())\n+                            leftFinisher.accept(leftState, r -> rightIntegrate(r, c));\n+                        if (rightFinisher != Gatherer.<AA, RR>defaultFinisher())\n+                            rightFinisher.accept(rightState, c);\n+                    }\n+\n+                    \/*\n+                     * Currently we use the following to ferry elements from\n+                     * the left Gatherer to the right Gatherer, but we create\n+                     * the Gatherer.Downstream as a lambda which means that\n+                     * the default implementation of `isKnownDone()` is used.\n+                     *\n+                     * If it is determined that we want to be able to support\n+                     * the full interface of Gatherer.Downstream then we have\n+                     *  the following options:\n+                     *    1. Have State implement Downstream<? super R>\n+                     *       and store the passed in Downstream<? super RR>\n+                     *       downstream as an instance field in integrate()\n+                     *       and read it in push(R r).\n+                     *    2. Allocate a new Gatherer.Downstream<? super R> for\n+                     *       each invocation of integrate() which might prove\n+                     *       costly.\n+                     *\/\n+                    public boolean rightIntegrate(R r, Downstream<? super RR> downstream) {\n+                        \/\/ The following logic is highly performance sensitive\n+                        return (rightGreedy || rightProceed)\n+                                && (rightIntegrator.integrate(rightState, r, downstream)\n+                                || rightGreedy\n+                                || (rightProceed = false));\n+                    }\n+                }\n+\n+                return new GathererImpl<T, State, RR>(\n+                        State::new,\n+                        (leftGreedy && rightGreedy)\n+                                ? Integrator.<State, T, RR>ofGreedy(State::integrate)\n+                                : Integrator.<State, T, RR>of(State::integrate),\n+                        (leftCombiner == Gatherer.defaultCombiner()\n+                        || rightCombiner == Gatherer.defaultCombiner())\n+                                ? Gatherer.defaultCombiner()\n+                                : State::joinLeft,\n+                        (leftFinisher == Gatherer.<A, R>defaultFinisher()\n+                        && rightFinisher == Gatherer.<AA, RR>defaultFinisher())\n+                                ? Gatherer.defaultFinisher()\n+                                : State::finish\n+                );\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherers.java","additions":695,"deletions":0,"binary":false,"changes":695,"status":"added"},{"patch":"@@ -93,1 +93,3 @@\n-     * @param upstream the upstream element source.\n+     * @param upstream the upstream element source\n+     * @param opFlags The operation flags for this operation, described in\n+     *        {@link StreamOpFlag}\n@@ -99,0 +101,13 @@\n+     \/**\n+      * Constructor for appending an intermediate operation onto an existing\n+      * pipeline.\n+      *\n+      * @param upupstream the upstream of the upstream element source\n+      * @param upstream the upstream element source\n+      * @param opFlags The operation flags for this operation, described in\n+      *        {@link StreamOpFlag}\n+      *\/\n+     protected ReferencePipeline(AbstractPipeline<?, P_IN, ?> upupstream, AbstractPipeline<?, P_IN, ?> upstream, int opFlags) {\n+         super(upupstream, upstream, opFlags);\n+     }\n+\n@@ -670,0 +685,5 @@\n+    @Override\n+    public final <R> Stream<R> gather(Gatherer<? super P_OUT, ?, R> gatherer) {\n+        return GathererOp.of(this, gatherer);\n+    }\n+\n@@ -672,1 +692,1 @@\n-    public final <R, A> R collect(Collector<? super P_OUT, A, R> collector) {\n+    public <R, A> R collect(Collector<? super P_OUT, A, R> collector) {\n@@ -690,1 +710,1 @@\n-    public final <R> R collect(Supplier<R> supplier,\n+    public <R> R collect(Supplier<R> supplier,\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReferencePipeline.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -1054,0 +1056,51 @@\n+    \/**\n+     * Returns a stream consisting of the results of applying the given\n+     * {@link Gatherer} to the elements of this stream.\n+     *\n+     * <p>This is an <a href=\"package-summary.html#Extensibility\">extension point<\/a>\n+     * for <a href=\"package-summary.html#StreamOps\">intermediate operations<\/a>.\n+     *\n+     * <p>Gatherers are highly flexible and can describe a vast array of\n+     * possibly stateful operations, with support for short-circuiting, and\n+     * parallelization.\n+     *\n+     * <p>When executed in parallel, multiple intermediate results may be\n+     * instantiated, populated, and merged so as to maintain isolation of\n+     * mutable data structures.  Therefore, even when executed in parallel\n+     * with non-thread-safe data structures (such as {@code ArrayList}), no\n+     * additional synchronization is needed for a parallel reduction.\n+     *\n+     * <p>Implementations are allowed, but not required, to detect consecutive\n+     * invocations and compose them into a single, fused, operation. This would\n+     * make the first expression below behave like the second:\n+     *\n+     * <pre>{@code\n+     *     var stream1 = Stream.of(...).gather(gatherer1).gather(gatherer2);\n+     *     var stream2 = Stream.of(...).gather(gatherer1.andThen(gatherer2));\n+     * }<\/pre>\n+     *\n+     * @implSpec\n+     * The default implementation obtains the {@link #spliterator() spliterator}\n+     * of this stream, wraps that spliterator so as to support the semantics\n+     * of this operation on traversal, and returns a new stream associated with\n+     * the wrapped spliterator.  The returned stream preserves the execution\n+     * characteristics of this stream (namely parallel or sequential execution\n+     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\n+     * not support splitting.  When the returned stream is closed, the close\n+     * handlers for both the returned and this stream are invoked.\n+     * Implementations of this interface should provide their own\n+     * implementation of this method.\n+     *\n+     * @see Gatherers\n+     * @param <R> The element type of the new stream\n+     * @param gatherer a gatherer\n+     * @return the new stream\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STREAM_GATHERERS)\n+    default <R> Stream<R> gather(Gatherer<? super T, ?, R> gatherer) {\n+        return StreamSupport.stream(spliterator(), isParallel())\n+                            .gather(gatherer)\n+                            .onClose(this::close);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Stream.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -623,0 +623,13 @@\n+ * <h3><a id=\"Extensibility\">Extensibility<\/a><\/h3>\n+ *\n+ * <p>Implementing {@link java.util.stream.Collector};\n+ * using the factory method {@code java.util.stream.Collector.of(...)}; or\n+ * using the predefined collectors in {@link java.util.stream.Collectors} allows\n+ * for user-defined, reusable, <em>terminal<\/em> operations.\n+ *\n+ * <p>Implementing {@link java.util.stream.Gatherer}; using the factory\n+ * methods {@code java.util.stream.Gatherer.of(...)} and\n+ * {@code java.util.stream.Gatherer.ofSequential(...)};\n+ * or using the predefined gatherers in {@link java.util.stream.Gatherers}\n+ * allows for user-defined, reusable, <em>intermediate<\/em> operations.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/package-info.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+        @JEP(number=461, title=\"Stream Gatherers\", status=\"Preview\")\n+        STREAM_GATHERERS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Supplier;\n+import java.util.stream.*;\n+import java.util.stream.Gatherer;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Testing public API of Gatherer\n+ * @enablePreview\n+ * @run junit GathererAPITest\n+ *\/\n+\n+public class GathererAPITest {\n+    final static Supplier<Void> initializer = () -> (Void)null;\n+    final static Gatherer.Integrator<Void, Integer, Integer> integrator = (v,e,d) -> d.push(e);\n+    final static BinaryOperator<Void> combiner = (l,r) -> l;\n+    final static BiConsumer<Void,Gatherer.Downstream<? super Integer>> finisher = (v,d) -> {};\n+\n+    final static Supplier<Void> nullInitializer = null;\n+    final static Gatherer.Integrator<Void, Integer, Integer> nullIntegrator = null;\n+    final static BinaryOperator<Void> nullCombiner = null;\n+    final static BiConsumer<Void,Gatherer.Downstream<? super Integer>> nullFinisher = null;\n+\n+    private final static <T> Gatherer<T,?,T> passthrough() {\n+        return Gatherer.of(\n+                () -> (Void)null,\n+                Gatherer.Integrator.<Void,T,T>ofGreedy((v,e,d) -> d.push(e)),\n+                (l,r) -> l,\n+                (v,d) -> {}\n+        );\n+    }\n+\n+    private final static void assertThrowsNPE(Supplier<? extends Object> supplier) {\n+        try {\n+            var discard = supplier.get();\n+        } catch (NullPointerException npe) {\n+            return;\n+        }\n+        fail(\"Expected NullPointerException but wasn't thrown!\");\n+    }\n+\n+    private final static <T> void assertThrowsUOE(Supplier<T> supplier) {\n+        try {\n+            var discard = supplier.get();\n+        } catch (UnsupportedOperationException uoe) {\n+            return;\n+        }\n+        fail(\"Expected NullPointerException but wasn't thrown!\");\n+    }\n+\n+    private final static <T,A,R> Gatherer<T,A,R> verifyGathererContract(Gatherer<T,A,R> gatherer) {\n+        \/\/ basics\n+        assertNotNull(gatherer);\n+\n+        \/\/ components\n+        assertNotNull(gatherer.initializer());\n+        assertNotNull(gatherer.integrator());\n+        assertNotNull(gatherer.combiner());\n+        assertNotNull(gatherer.finisher());\n+        assertNotNull(gatherer.andThen(passthrough()));\n+\n+        return gatherer;\n+    }\n+\n+    private final static <T,A,R> Gatherer<T,A,R> verifyGathererStructure(\n+            Gatherer<T,A,R> gatherer,\n+            Supplier<A> expectedSupplier,\n+            Gatherer.Integrator<A,T,R> expectedIntegrator,\n+            BinaryOperator<A> expectedCombiner,\n+            BiConsumer<A,Gatherer.Downstream<? super R>> expectedFinisher\n+    ) {\n+        \/\/ basics\n+        assertNotNull(gatherer);\n+\n+        \/\/ components\n+        assertSame(expectedSupplier, gatherer.initializer());\n+        assertSame(expectedIntegrator, gatherer.integrator());\n+        assertSame(expectedCombiner, gatherer.combiner());\n+        assertSame(expectedFinisher, gatherer.finisher());\n+\n+        return gatherer;\n+    }\n+\n+    @Test\n+    public void testGathererFactoriesNPE() {\n+        assertThrowsNPE(() -> Gatherer.of(nullInitializer, integrator, combiner, finisher));\n+        assertThrowsNPE(() -> Gatherer.of(initializer, nullIntegrator, combiner, finisher));\n+        assertThrowsNPE(() -> Gatherer.of(initializer, integrator, nullCombiner, finisher));\n+        assertThrowsNPE(() -> Gatherer.of(initializer, integrator, combiner, nullFinisher));\n+\n+        assertThrowsNPE(() -> Gatherer.of(nullIntegrator));\n+\n+        assertThrowsNPE(() -> Gatherer.of(nullIntegrator, finisher));\n+        assertThrowsNPE(() -> Gatherer.of(integrator, nullFinisher));\n+\n+        assertThrowsNPE(() -> Gatherer.ofSequential(nullInitializer, integrator));\n+        assertThrowsNPE(() -> Gatherer.ofSequential(initializer, nullIntegrator));\n+\n+        assertThrowsNPE(() -> Gatherer.ofSequential(nullIntegrator));\n+\n+        assertThrowsNPE(() -> Gatherer.ofSequential(nullIntegrator, finisher));\n+        assertThrowsNPE(() -> Gatherer.ofSequential(integrator, nullFinisher));\n+\n+        assertThrowsNPE(() -> Gatherer.ofSequential(nullInitializer, integrator, finisher));\n+        assertThrowsNPE(() -> Gatherer.ofSequential(initializer, nullIntegrator, finisher));\n+        assertThrowsNPE(() -> Gatherer.ofSequential(initializer, integrator, nullFinisher));\n+    }\n+\n+    @Test\n+    public void testGathererFactoriesAPI() {\n+        final var defaultInitializer = Gatherer.<Void>defaultInitializer();\n+        final var defaultCombiner = Gatherer.<Void>defaultCombiner();\n+        final var defaultFinisher = Gatherer.<Void,Integer>defaultFinisher();\n+\n+        var g1 = verifyGathererContract(passthrough()); \/\/ Quis custodiet ipsos custodes?\n+        verifyGathererContract(g1.andThen(g1));\n+\n+        var g2 = verifyGathererContract(Gatherer.of(integrator));\n+        verifyGathererContract(g2.andThen(g2));\n+        assertSame(defaultInitializer, g2.initializer());\n+        assertSame(integrator, g2.integrator());\n+        assertNotSame(defaultCombiner, g2.combiner());\n+        assertSame(defaultFinisher, g2.finisher());\n+\n+        var g3 = verifyGathererContract(Gatherer.of(integrator, finisher));\n+        verifyGathererContract(g3.andThen(g3));\n+        assertSame(integrator, g3.integrator());\n+        assertNotSame(defaultCombiner, g3.combiner());\n+        assertSame(finisher, g3.finisher());\n+\n+        var g4 = verifyGathererContract(Gatherer.ofSequential(integrator));\n+        verifyGathererContract(g4.andThen(g4));\n+        verifyGathererStructure(g4, defaultInitializer, integrator, defaultCombiner, defaultFinisher);\n+\n+        var g5 = verifyGathererContract(Gatherer.ofSequential(initializer, integrator));\n+        verifyGathererContract(g5.andThen(g5));\n+        verifyGathererStructure(g5, initializer, integrator, defaultCombiner, defaultFinisher);\n+\n+        var g6 = verifyGathererContract(Gatherer.ofSequential(integrator, finisher));\n+        verifyGathererContract(g6.andThen(g6));\n+        verifyGathererStructure(g6, defaultInitializer, integrator, defaultCombiner, finisher);\n+\n+        var g7 = verifyGathererContract(Gatherer.ofSequential(initializer, integrator, finisher));\n+        verifyGathererContract(g7.andThen(g7));\n+        verifyGathererStructure(g7, initializer, integrator, defaultCombiner, finisher);\n+\n+        var g8 = verifyGathererContract(Gatherer.of(initializer, integrator, combiner, finisher));\n+        verifyGathererContract(g8.andThen(g8));\n+        verifyGathererStructure(g8, initializer, integrator, combiner, finisher);\n+    }\n+\n+    @Test\n+    public void testGathererVariance() {\n+\n+        \/\/ Make sure that Gatherers can pass-through type\n+        Gatherer<Number,?,Number> nums = Gatherer.of((unused, element, downstream) -> downstream.push(element));\n+\n+        \/\/ Make sure that Gatherers can upcast the output type from the input type\n+        Gatherer<Number,?,Object> upcast = Gatherer.of((unused, element, downstream) -> downstream.push(element));\n+\n+        \/\/ Make sure that Gatherers can consume a supertype of the Stream output\n+        assertEquals(List.of(1,2,3,4,5), Stream.<Integer>of(1,2,3,4,5).gather(nums).toList());\n+\n+        Gatherer<Integer,?,Integer> ints = Gatherer.of((unused, element, downstream) -> downstream.push(element));\n+\n+        \/\/ Make sure that Gatherers can be composed where the output is a subtype of the input type of the next\n+        Gatherer<Integer,?,Number> composition = ints.andThen(nums);\n+\n+        \/\/ Make sure that composition works transitively, typing-wise\n+        Gatherer<Integer,?,Object> upcastComposition = ints.andThen(nums.andThen(upcast));\n+\n+        assertEquals(List.of(1,2,3,4,5), Stream.<Integer>of(1,2,3,4,5).gather(composition).toList());\n+        assertEquals(List.of(1,2,3,4,5), Stream.<Integer>of(1,2,3,4,5).gather(upcastComposition).toList());\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GathererAPITest.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,479 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.*;\n+import java.util.stream.Gatherer;\n+import static java.util.stream.DefaultMethodStreams.delegateTo;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Testing the Gatherer contract\n+ * @enablePreview\n+ * @library \/lib\/testlibrary\/bootlib\n+ * @build java.base\/java.util.stream.DefaultMethodStreams\n+ * @run junit GathererTest\n+ *\/\n+\n+public class GathererTest {\n+\n+    record Config(int streamSize, boolean parallel, boolean defaultImpl) {\n+\n+        Stream<Integer> countTo(int n) {\n+            return Stream.iterate(1, i -> i + 1).limit(n);\n+        }\n+\n+        Stream<Integer> stream() {\n+            return wrapStream(countTo(streamSize));\n+        }\n+\n+        <R> Stream<R> wrapStream(Stream<R> stream) {\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            stream = defaultImpl ? delegateTo(stream) : stream;\n+            return stream;\n+        }\n+\n+        List<Integer> list() {\n+            return stream().toList();\n+        }\n+    }\n+\n+    final static Stream<Config> configurations() {\n+        return Stream.of(0,1,10,33,99,9999)\n+                .flatMap(size ->\n+                        Stream.of(false, true)\n+                                .flatMap(parallel ->\n+                                        Stream.of(false, true).map( defaultImpl ->\n+                                                new Config(size, parallel,\n+                                                        defaultImpl)) )\n+                );\n+    }\n+\n+    final class TestException extends RuntimeException {\n+        TestException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    final static class InvocationTracker {\n+        int initialize;\n+        int integrate;\n+        int combine;\n+        int finish;\n+\n+        void copyFrom(InvocationTracker other) {\n+            initialize = other.initialize;\n+            integrate = other.integrate;\n+            combine = other.combine;\n+            finish = other.finish;\n+        }\n+\n+        void combine(InvocationTracker other) {\n+            if (other != this) {\n+                initialize += other.initialize;\n+                integrate += other.integrate;\n+                combine += other.combine + 1; \/\/ track this merge\n+                finish += other.finish;\n+            }\n+        }\n+    }\n+\n+    final Gatherer<Integer,Void,Integer> addOne = Gatherer.of(\n+            Gatherer.Integrator.<Void,Integer,Integer>ofGreedy((vöid, element, downstream) -> downstream.push(element + 1))\n+    );\n+\n+    final Gatherer<Integer,Void,Integer> timesTwo = Gatherer.of(\n+            Gatherer.Integrator.<Void,Integer,Integer>ofGreedy((vöid, element, downstream) -> downstream.push(element * 2))\n+    );\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testInvocationSemanticsGreedy(Config config) {\n+        var result = new InvocationTracker();\n+        var g = Gatherer.<Integer, InvocationTracker, Integer>of(\n+                () -> {\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n+                },\n+                Gatherer.Integrator.<InvocationTracker,Integer,Integer>ofGreedy((t, e, d) -> {\n+                    t.integrate++;\n+                    return d.push(e);\n+                }),\n+                (t1, t2) -> {\n+                    t1.combine(t2);\n+                    return t1;\n+                },\n+                (t, d) -> {\n+                    t.finish++;\n+                    result.copyFrom(t);\n+                });\n+        var res = config.stream().gather(g).toList();\n+        assertEquals(config.countTo(config.streamSize).toList(), res);\n+        if (config.parallel) {\n+            assertTrue(result.initialize > 0);\n+            assertEquals(config.streamSize, result.integrate);\n+            assertTrue(config.streamSize < 2 || result.combine > 0);\n+            assertEquals(1, result.finish);\n+        } else {\n+            assertEquals(1, result.initialize);\n+            assertEquals(config.streamSize, result.integrate);\n+            assertEquals(0, result.combine);\n+            assertEquals(1, result.finish);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testInvocationSemanticsShortCircuit(Config config) {\n+        final int CONSUME_UNTIL = Math.min(config.streamSize, 5);\n+        var result = new InvocationTracker();\n+        var g = Gatherer.<Integer, InvocationTracker, Integer>of(\n+                () -> {\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n+                },\n+                (t, e, d) -> {\n+                    ++t.integrate;\n+                    return e <= CONSUME_UNTIL && d.push(e) && e != CONSUME_UNTIL;\n+                },\n+                (t1, t2) -> {\n+                    t1.combine(t2);\n+                    return t1;\n+                },\n+                (t, d) -> {\n+                    t.finish++;\n+                    result.copyFrom(t);\n+                });\n+        var res = config.stream().gather(g).toList();\n+        assertEquals(config.countTo(CONSUME_UNTIL).toList(), res);\n+        if (config.parallel) {\n+            assertTrue(result.initialize > 0);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertTrue(result.combine >= 0); \/\/ We can't guarantee split sizes\n+            assertEquals(1, result.finish);\n+        } else {\n+            assertEquals(1, result.initialize);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertEquals(0, result.combine);\n+            assertEquals(1, result.finish);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testEmissionDuringFinisher(Config config) {\n+        var g = Gatherer.<Integer, InvocationTracker, InvocationTracker>of(\n+                () -> {\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n+                },\n+                (t, e, d) -> {\n+                    t.integrate++;\n+                    return true;\n+                },\n+                (t1, t2) -> {\n+                    t1.combine(t2);\n+                    return t1;\n+                },\n+                (t, d) -> {\n+                    t.finish++;\n+                    d.push(t);\n+                });\n+        var resultList = config.stream().gather(g).collect(Collectors.toList());\n+        assertEquals(resultList.size(), 1);\n+\n+        var t = resultList.get(0);\n+\n+        if (config.parallel) {\n+            assertTrue(t.initialize > 0);\n+            assertEquals(config.streamSize, t.integrate);\n+            assertTrue(config.streamSize < 2 || t.combine > 0);\n+            assertEquals(1, t.finish);\n+        } else {\n+            assertEquals(1, t.initialize);\n+            assertEquals(config.streamSize, t.integrate);\n+            assertEquals(0, t.combine);\n+            assertEquals(1, t.finish);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testInvocationSemanticsShortCircuitDuringCollect(Config config) {\n+        final int CONSUME_UNTIL = Math.min(config.streamSize, 5);\n+        var result = new InvocationTracker();\n+        var g = Gatherer.<Integer, InvocationTracker, Integer>of(\n+                () -> {\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n+                },\n+                (t, e, d) -> {\n+                    t.integrate++;\n+                    return e <= CONSUME_UNTIL && d.push(e) && e != CONSUME_UNTIL;\n+                },\n+                (t1, t2) -> {\n+                    t1.combine(t2);\n+                    return t1;\n+                },\n+                (t, d) -> {\n+                    t.finish++;\n+                    result.copyFrom(t);\n+                });\n+        var res = config.stream().gather(g).collect(Collectors.toList());\n+        assertEquals(config.countTo(CONSUME_UNTIL).toList(), res);\n+        if (config.parallel) {\n+            assertTrue(result.initialize > 0);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertTrue(result.combine >= 0); \/\/ We can't guarantee split sizes\n+            assertEquals(result.finish, 1);\n+        } else {\n+            assertEquals(result.initialize, 1);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertEquals(result.combine, 0);\n+            assertEquals(result.finish, 1);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testCompositionOfStatelessGatherers(Config config) {\n+        var range = config.stream().toList();\n+        var gRes = range.stream().gather(addOne.andThen(timesTwo)).toList();\n+        var rRes = range.stream().map(j -> j + 1).map(j -> j * 2).toList();\n+        assertEquals(config.streamSize, gRes.size());\n+        assertEquals(config.streamSize, rRes.size());\n+        assertEquals(gRes, rRes);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testCompositionOfStatefulGatherers(Config config) {\n+        var t1 = new InvocationTracker();\n+        var g1 = Gatherer.<Integer, InvocationTracker, Integer>of(\n+                () -> {\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n+                },\n+                (t, e, d) -> {\n+                    t.integrate++;\n+                    return d.push(e);\n+                },\n+                (l, r) -> {\n+                    l.combine(r);\n+                    return l;\n+                },\n+                (t, d) -> {\n+                    t.finish++;\n+                    t1.copyFrom(t);\n+                });\n+\n+        var t2 = new InvocationTracker();\n+        var g2 = Gatherer.<Integer, InvocationTracker, Integer>of(\n+                () -> {\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n+                },\n+                (t, e, d) -> {\n+                    t.integrate++;\n+                    return d.push(e);\n+                },\n+                (l, r) -> {\n+                    l.combine(r);\n+                    return l;\n+                },\n+                (t, d) -> {\n+                    t.finish++;\n+                    t2.copyFrom(t);\n+                });\n+\n+        var res = config.stream().gather(g1.andThen(g2)).toList();\n+        assertEquals(config.stream().toList(), res);\n+\n+        if (config.parallel) {\n+            assertTrue(t1.initialize > 0);\n+            assertEquals(config.streamSize, t1.integrate);\n+            assertTrue(config.streamSize < 2 || t1.combine > 0);\n+            assertEquals(1, t1.finish);\n+\n+            assertTrue(t2.initialize > 0);\n+            assertEquals(config.streamSize, t2.integrate);\n+            assertTrue(config.streamSize < 2 || t2.combine > 0);\n+            assertEquals(1, t2.finish);\n+        } else {\n+            assertEquals(1, t1.initialize);\n+            assertEquals(config.streamSize, t1.integrate);\n+            assertEquals(0, t1.combine);\n+            assertEquals(1, t1.finish);\n+\n+            assertEquals(1, t2.initialize);\n+            assertEquals(config.streamSize, t2.integrate);\n+            assertEquals(0, t2.combine);\n+            assertEquals(1, t2.finish);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testMassivelyComposedGatherers(Config config) {\n+        final int ITERATIONS = 1000; \/\/ Total number of compositions is 1 + (iterations*2)\n+        Gatherer<Integer,?,Integer> g = addOne;\n+        for(int i = 0;i < ITERATIONS;++i) {\n+            g = g.andThen(timesTwo).andThen(addOne);\n+        }\n+\n+        g = g.andThen(timesTwo);\n+\n+        var ref = config.stream().map(n -> n + 1);\n+        for(int c = 0; c < ITERATIONS; ++c) {\n+            ref = ref.map(n -> n * 2).map(n -> n + 1);\n+        }\n+        ref = ref.map(n -> n * 2);\n+\n+        var gatherered = config.stream().gather(g).toList();\n+        var reference = ref.toList();\n+        assertEquals(gatherered, reference);\n+    }\n+\n+    @Test\n+    public void testUnboundedEmissions() {\n+        Gatherer<Integer,?,Integer> g = Gatherer.of(\n+                    () -> (Void)null,\n+                    (v,e,d) -> { do {} while(d.push(e)); return false; },\n+                    (l,r) -> l,\n+                    (v,d) -> {}\n+                );\n+        assertEquals(Stream.of(1).gather(g).limit(1).toList(), List.of(1));\n+        assertEquals(Stream.of(1).gather(g.andThen(g)).limit(1).toList(), List.of(1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testCompositionSymmetry(Config config) {\n+            var consecutiveResult = config.stream().gather(addOne).gather(timesTwo).toList();\n+            var interspersedResult = config.stream().gather(addOne).map(id -> id).gather(timesTwo).toList();\n+            var composedResult = config.stream().gather(addOne.andThen(timesTwo)).toList();\n+\n+            var reference = config.stream().map(j -> j + 1).map(j -> j * 2).toList();\n+\n+            assertEquals(config.streamSize, consecutiveResult.size());\n+            assertEquals(config.streamSize, interspersedResult.size());\n+            assertEquals(config.streamSize, composedResult.size());\n+            assertEquals(config.streamSize, reference.size());\n+\n+            assertEquals(consecutiveResult, reference);\n+            assertEquals(interspersedResult, reference);\n+            assertEquals(composedResult, reference);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInInitializer(Config config) {\n+        final var expectedMessage = \"testExceptionInInitializer()\";\n+        assertThrowsTestException(() ->\n+            config.stream().gather(\n+                    Gatherer.<Integer,Integer,Integer>of(\n+                            () -> { throw new TestException(expectedMessage); },\n+                            (i, e, d) -> true,\n+                            (l,r) -> l,\n+                            (i,d) -> {}\n+                    )\n+            ).toList(), expectedMessage);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInIntegrator(Config config) {\n+        if (config.streamSize < 1) return; \/\/ No exceptions expected\n+\n+        final var expectedMessage = \"testExceptionInIntegrator()\";\n+        assertThrowsTestException(() ->\n+            config.stream().gather(\n+                    Gatherer.<Integer,Integer,Integer>of(\n+                            () -> 1,\n+                            (i, e, d) -> { throw new TestException(expectedMessage); },\n+                            (l,r) -> l,\n+                            (i,d) -> {}\n+                    )\n+            ).toList()\n+        , expectedMessage);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInCombiner(Config config) {\n+        if (config.streamSize < 2 || !config.parallel) return; \/\/ No exceptions expected\n+\n+        final var expectedMessage = \"testExceptionInCombiner()\";\n+        assertThrowsTestException(() ->\n+            config.stream().gather(\n+                    Gatherer.<Integer,Integer,Integer>of(\n+                            () -> 1,\n+                            (i, e, d) -> true,\n+                            (l,r) -> { throw new TestException(expectedMessage); },\n+                            (i,d) -> {}\n+                    )\n+            ).toList()\n+        , expectedMessage);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInFinisher(Config config) {\n+        final var expectedMessage = \"testExceptionInFinisher()\";\n+        assertThrowsTestException(() ->\n+            config.stream().gather(\n+                    Gatherer.<Integer,Integer,Integer>of(\n+                            () -> 1,\n+                            (i, e, d) -> true,\n+                            (l,r) -> l,\n+                            (v, d) -> { throw new TestException(expectedMessage); }\n+                    )\n+            ).toList()\n+        , expectedMessage);\n+    }\n+\n+    private final static void assertThrowsTestException(Supplier<?> supplier, String expectedMessage) {\n+        try {\n+            var discard = supplier.get();\n+        } catch (TestException e) {\n+            assertSame(TestException.class, e.getClass());\n+            assertEquals(expectedMessage, e.getMessage());\n+            return;\n+        }\n+        fail(\"Expected TestException but wasn't thrown!\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GathererTest.java","additions":479,"deletions":0,"binary":false,"changes":479,"status":"added"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.*;\n+import java.util.stream.Gatherer;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Testing the built-in Gatherer implementations and their contracts\n+ * @enablePreview\n+ * @run junit GatherersTest\n+ *\/\n+\n+public class GatherersTest {\n+\n+    record Config(int streamSize, boolean parallel) {\n+        Stream<Integer> stream() {\n+            return wrapStream(Stream.iterate(1, i -> i + 1).limit(streamSize));\n+        }\n+\n+        <R> Stream<R> wrapStream(Stream<R> stream) {\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n+        }\n+    }\n+\n+    final static Stream<Config> configurations() {\n+        return Stream.of(0,1,10,33,99,9999)\n+                     .flatMap(size ->\n+                             Stream.of(false, true)\n+                                   .map(parallel ->\n+                                               new Config(size, parallel))\n+                     );\n+    }\n+\n+    final class TestException extends RuntimeException {\n+        TestException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testFixedWindowAPIandContract(Config config) {\n+        \/\/ Groups must be greater than 0\n+        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowFixed(0));\n+\n+        final var streamSize = config.streamSize();\n+\n+        \/\/ We're already covering less-than-one scenarios above\n+        if (streamSize > 0) {\n+            \/\/Test creating a window of the same size as the stream\n+            {\n+                final var result = config.stream()\n+                        .gather(Gatherers.windowFixed(streamSize))\n+                        .toList();\n+                assertEquals(1, result.size());\n+                assertEquals(config.stream().toList(), result.get(0));\n+            }\n+\n+            \/\/Test nulls as elements\n+            {\n+                assertEquals(\n+                      config.stream()\n+                            .map(n -> Arrays.asList(null, null))\n+                            .toList(),\n+                      config.stream()\n+                            .flatMap(n -> Stream.of(null, null))\n+                            .gather(Gatherers.windowFixed(2))\n+                            .toList());\n+            }\n+\n+            \/\/ Test unmodifiability of windows\n+            {\n+                var window = config.stream()\n+                                   .gather(Gatherers.windowFixed(1))\n+                                   .findFirst()\n+                                   .get();\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> window.add(2));\n+            }\n+        }\n+\n+\n+        \/\/ Tests that the layout of the returned data is as expected\n+        for (var windowSize : List.of(1, 2, 3, 10)) {\n+            final var expectLastWindowSize = streamSize % windowSize == 0 ? windowSize : streamSize % windowSize;\n+            final var expectedSize = (streamSize \/ windowSize) + ((streamSize % windowSize == 0) ? 0 : 1);\n+\n+            final var expected = config.stream().toList().iterator();\n+\n+            final var result = config.stream()\n+                                     .gather(Gatherers.windowFixed(windowSize))\n+                                     .toList();\n+\n+            int currentWindow = 0;\n+            for (var window : result) {\n+                ++currentWindow;\n+                assertEquals(currentWindow < expectedSize ? windowSize : expectLastWindowSize, window.size());\n+                for (var element : window)\n+                    assertEquals(expected.next(), element);\n+            }\n+\n+            assertEquals(expectedSize, currentWindow);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testSlidingAPIandContract(Config config) {\n+        \/\/ Groups must be greater than 0\n+        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowSliding(0));\n+\n+        final var streamSize = config.streamSize();\n+\n+        \/\/ We're already covering less-than-one scenarios above\n+        if (streamSize > 0) {\n+            \/\/Test greating a window larger than the size of the stream\n+            {\n+                final var result = config.stream()\n+                                         .gather(Gatherers.windowSliding(streamSize + 1))\n+                                         .toList();\n+                assertEquals(1, result.size());\n+                assertEquals(config.stream().toList(), result.get(0));\n+            }\n+\n+            \/\/Test nulls as elements\n+            {\n+                assertEquals(\n+                        List.of(\n+                                Arrays.asList(null, null),\n+                                Arrays.asList(null, null)\n+                        ),\n+                        config.wrapStream(Stream.of(null, null, null))\n+                            .gather(Gatherers.windowSliding(2))\n+                            .toList());\n+            }\n+\n+            \/\/ Test unmodifiability of windows\n+            {\n+                var window = config.stream()\n+                        .gather(Gatherers.windowSliding(1))\n+                        .findFirst()\n+                        .get();\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> window.add(2));\n+            }\n+        }\n+\n+        \/\/ Tests that the layout of the returned data is as expected\n+        for (var windowSize : List.of(1, 2, 3, 10)) {\n+            final var expectLastWindowSize = streamSize < windowSize ? streamSize : windowSize;\n+            final var expectedNumberOfWindows = streamSize == 0 ? 0 : Math.max(1, 1 + streamSize - windowSize);\n+\n+            int expectedElement = 0;\n+            int currentWindow = 0;\n+\n+            final var result = config.stream()\n+                                     .gather(Gatherers.windowSliding(windowSize))\n+                                     .toList();\n+\n+            for (var window : result) {\n+                ++currentWindow;\n+                assertEquals(currentWindow < expectedNumberOfWindows ? windowSize : expectLastWindowSize, window.size());\n+                for (var element : window) {\n+                    assertEquals(++expectedElement, element.intValue());\n+                }\n+                \/\/ rewind for the sliding motion\n+                expectedElement -= (window.size() - 1);\n+            }\n+\n+            assertEquals(expectedNumberOfWindows, currentWindow);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testFoldAPIandContract(Config config) {\n+        \/\/ Verify prereqs\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(null, (state, next) -> state));\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(() -> \"\", null));\n+\n+        final var expectedResult = List.of(\n+                                       config.stream()\n+                                             .sequential()\n+                                             .reduce(\"\", (acc, next) -> acc + next, (l,r) -> { throw new IllegalStateException(); })\n+                                   );\n+\n+        final var result = config.stream()\n+                                 .gather(Gatherers.fold(() -> \"\", (acc, next) -> acc + next))\n+                                 .toList();\n+\n+        assertEquals(expectedResult, result);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testMapConcurrentAPIandContract(Config config) throws InterruptedException {\n+        \/\/ Verify prereqs\n+        assertThrows(IllegalArgumentException.class, () -> Gatherers.<String, String>mapConcurrent(0, s -> s));\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String, String>mapConcurrent(2, null));\n+\n+        \/\/ Test exception during processing\n+        {\n+            final var stream = config.parallel() ? Stream.of(1).parallel() : Stream.of(1);\n+\n+            assertThrows(RuntimeException.class,\n+                    () -> stream.gather(Gatherers.<Integer, Integer>mapConcurrent(2, x -> {\n+                        throw new RuntimeException();\n+                    })).toList());\n+        }\n+\n+        \/\/ Test cancellation after exception during processing\n+        if (config.streamSize > 2) { \/\/ We need streams of a minimum size to test this\n+            final var firstLatch = new CountDownLatch(1);\n+            final var secondLatch = new CountDownLatch(1);\n+            final var cancellationLatch = new CountDownLatch(config.streamSize - 2); \/\/ all but two will get cancelled\n+\n+            try {\n+                config.stream()\n+                      .gather(\n+                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n+                                switch (i) {\n+                                    case 1 -> {\n+                                        try {\n+                                            firstLatch.await(); \/\/ the first waits for the last element to start\n+                                        } catch (InterruptedException ie) {\n+                                            throw new IllegalStateException(ie);\n+                                        }\n+                                        throw new TestException(\"expected\");\n+                                    }\n+\n+                                    case Integer n when n == config.streamSize - 1 -> { \/\/ last element\n+                                        firstLatch.countDown(); \/\/ ensure that the first element can now proceed\n+                                    }\n+\n+                                    default -> {\n+                                        try {\n+                                            secondLatch.await(); \/\/ These should all get interrupted\n+                                        } catch (InterruptedException ie) {\n+                                            cancellationLatch.countDown(); \/\/ used to ensure that they all were interrupted\n+                                        }\n+                                    }\n+                                }\n+\n+                                return i;\n+                            })\n+                      )\n+                      .toList();\n+                fail(\"This should not be reached\");\n+            } catch (Throwable e) {\n+                while (e.getCause() != null)\n+                    e = e.getCause();\n+                assertSame(TestException.class, e.getClass());\n+                assertEquals(\"expected\", e.getMessage());\n+                cancellationLatch.await();\n+                return;\n+            }\n+\n+            fail(\"This should not be reached\");\n+        }\n+\n+        \/\/ Test cancellation during short-circuiting\n+        if (config.streamSize > 2) {\n+            final var firstLatch = new CountDownLatch(1);\n+            final var secondLatch = new CountDownLatch(1);\n+            final var cancellationLatch = new CountDownLatch(config.streamSize - 2); \/\/ all but two will get cancelled\n+\n+            final var result =\n+                config.stream()\n+                      .gather(\n+                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n+                                switch (i) {\n+                                    case 1 -> {\n+                                        try {\n+                                            firstLatch.await(); \/\/ the first waits for the last element to start\n+                                        } catch (InterruptedException ie) {\n+                                            throw new IllegalStateException(ie);\n+                                        }\n+                                    }\n+\n+                                    case Integer n when n == config.streamSize - 1 -> { \/\/ last element\n+                                        firstLatch.countDown(); \/\/ ensure that the first element can now proceed\n+                                    }\n+\n+                                    default -> {\n+                                        try {\n+                                            secondLatch.await(); \/\/ These should all get interrupted\n+                                        } catch (InterruptedException ie) {\n+                                            cancellationLatch.countDown(); \/\/ used to ensure that they all were interrupted\n+                                        }\n+                                    }\n+                                }\n+\n+                                return i;\n+                            })\n+                      )\n+                      .limit(2)\n+                      .toList();\n+            cancellationLatch.await(); \/\/ If this hangs, then we didn't cancel and interrupt the tasks\n+            assertEquals(List.of(1,2), result);\n+        }\n+\n+        for (var concurrency : List.of(1, 2, 3, 10, 1000)) {\n+            \/\/ Test normal operation\n+            {\n+                final var expectedResult = config.stream()\n+                                                 .map(x -> x * x)\n+                                                 .toList();\n+\n+                final var result = config.stream()\n+                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n+                                         .toList();\n+\n+                assertEquals(expectedResult, result);\n+            }\n+\n+            \/\/ Test short-circuiting\n+            {\n+                final var limitTo = Math.max(config.streamSize() \/ 2, 1);\n+\n+                final var expectedResult = config.stream()\n+                                                 .map(x -> x * x)\n+                                                 .limit(limitTo)\n+                                                 .toList();\n+\n+                final var result = config.stream()\n+                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n+                                         .limit(limitTo)\n+                                         .toList();\n+\n+                assertEquals(expectedResult, result);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersTest.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/lib\/testlibrary\/bootlib\/java.base\/java\/util\/stream\/DefaultMethodStreams.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+import java.util.stream.Gatherer;\n+import java.util.stream.Stream;\n+\n+\/\/ Utility Gatherer and Collector implementations used by Gatherer micro-benchmarks\n+public final class BenchmarkGathererImpls {\n+\n+    public static <TR> Gatherer<TR, ?, TR> filter(Predicate<? super TR> predicate) {\n+        return new FilteringGatherer<>(predicate);\n+    }\n+\n+    public final static <T,R> Gatherer<T, ?, R> map(Function<? super T, ? extends R> mapper) {\n+        return new MappingGatherer<>(Objects.requireNonNull(mapper));\n+    }\n+\n+    public static <TR> Gatherer<TR,?, TR> reduce(BinaryOperator<TR> reduce) {\n+        Objects.requireNonNull(reduce);\n+        return new ReducingGatherer<>(reduce);\n+    }\n+\n+    public final static <TR> Gatherer<TR, ?, TR> takeWhile(Predicate<? super TR> predicate) {\n+        return new TakeWhileGatherer<>(Objects.requireNonNull(predicate));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public final static <T> Collector<T,?,Optional<T>> findFirst() {\n+        return (Collector<T,?,Optional<T>>)FIND_FIRST;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public final static <T> Collector<T,?,Optional<T>> findLast() {\n+        return (Collector<T,?,Optional<T>>)FIND_LAST;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private final static Collector FIND_FIRST =\n+            Collector.<Object,Box<Object>,Optional<Object>>of(\n+                    () -> new Box<>(),\n+                    (b,e) -> {\n+                        if (!b.hasValue) {\n+                            b.value = e;\n+                            b.hasValue = true;\n+                        }\n+                    },\n+                    (l,r) -> l.hasValue ? l : r,\n+                    b -> b.hasValue ? Optional.of(b.value) : Optional.empty()\n+            );\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private final static Collector FIND_LAST =\n+            Collector.<Object,Box<Object>,Optional<Object>>of(\n+                         () -> new Box<>(),\n+                         (b,e) -> {\n+                            b.value = e;\n+                            if (!b.hasValue)\n+                                b.hasValue = true;\n+                         },\n+                         (l,r) -> r.hasValue ? r : l,\n+                         b -> b.hasValue ? Optional.of(b.value) : Optional.empty()\n+            );\n+\n+    public final static <T, R> Gatherer<T, ?, R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) {\n+        Objects.requireNonNull(mapper);\n+\n+        class FlatMappingGatherer implements Gatherer<T,Void,R>, Gatherer.Integrator<Void,T,R>, BinaryOperator<Void> {\n+            @Override public Integrator<Void, T, R> integrator() { return this; }\n+\n+            \/\/ Ideal encoding, but performance-wise suboptimal due to cost of allMatch--about factor-10 worse.\n+            \/*@Override public boolean integrate(Void state, T element, Gatherer.Downstream<? super R> downstream) {\n+                try(Stream<? extends R> s = mapper.apply(element)) {\n+                    return s != null ? s.sequential().allMatch(downstream::flush) : true;\n+                }\n+            }*\/\n+\n+            \/\/The version below performs better, but is not nice to maintain or explain.\n+\n+            private final static RuntimeException SHORT_CIRCUIT = new RuntimeException() {\n+                @Override public synchronized Throwable fillInStackTrace() { return this; }\n+            };\n+\n+            @Override public boolean integrate(Void state, T element, Gatherer.Downstream<? super R> downstream) {\n+                try (Stream<? extends R> s = mapper.apply(element)) {\n+                    if (s != null) {\n+                        s.sequential().spliterator().forEachRemaining(e -> {\n+                            if (!downstream.push(e)) throw SHORT_CIRCUIT;\n+                        });\n+                    }\n+                    return true;\n+                } catch (RuntimeException e) {\n+                    if (e == SHORT_CIRCUIT)\n+                        return false;\n+\n+                    throw e; \/\/ Rethrow anything else\n+                }\n+            }\n+\n+            @Override public BinaryOperator<Void> combiner() { return this; }\n+            @Override public Void apply(Void unused, Void unused2) { return unused; }\n+        }\n+\n+        return new FlatMappingGatherer();\n+    }\n+\n+    final static class MappingGatherer<T, R> implements Gatherer<T, Void, R>, Gatherer.Integrator.Greedy<Void, T, R>, BinaryOperator<Void> {\n+        final Function<? super T, ? extends R> mapper;\n+\n+        MappingGatherer(Function<? super T, ? extends R> mapper) { this.mapper = mapper; }\n+\n+        @Override public Integrator<Void, T, R> integrator() { return this; }\n+        @Override public BinaryOperator<Void> combiner() { return this; }\n+        @Override public Void apply(Void left, Void right) { return left; }\n+\n+        @Override\n+        public <RR> Gatherer<T, ?, RR> andThen(Gatherer<? super R, ?, ?\n+                extends RR> that) {\n+            if (that.getClass() == MappingGatherer.class) { \/\/ Implicit null-check of that\n+                @SuppressWarnings(\"unchecked\")\n+                var thatMapper = ((MappingGatherer<R,RR>)that).mapper;\n+                return new MappingGatherer<>(this.mapper.andThen(thatMapper));\n+            } else\n+                return Gatherer.super.andThen(that);\n+        }\n+\n+        @Override\n+        public boolean integrate(Void state, T element, Gatherer.Downstream<? super R> downstream) {\n+            return downstream.push(mapper.apply(element));\n+        }\n+    }\n+\n+\n+    final static class FilteringGatherer<TR> implements Gatherer<TR, Void, TR>, Gatherer.Integrator.Greedy<Void, TR, TR>, BinaryOperator<Void> {\n+        final Predicate<? super TR> predicate;\n+\n+        protected FilteringGatherer(Predicate<? super TR> predicate) { this.predicate = predicate; }\n+\n+        @Override public Integrator<Void, TR, TR> integrator() { return this; }\n+        @Override public BinaryOperator<Void> combiner() { return this; }\n+\n+        @Override public Void apply(Void left, Void right) { return left; }\n+\n+        @Override\n+        public boolean integrate(Void state, TR element, Gatherer.Downstream<? super TR> downstream) {\n+            return predicate.test(element) ? downstream.push(element) : true;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <RR> Gatherer<TR, ?, RR> andThen(Gatherer<? super TR, ?, ?\n+                extends RR> that) {\n+            if (that.getClass() == FilteringGatherer.class) {\n+                var first = predicate;\n+                var second = ((FilteringGatherer<TR>) that).predicate;\n+                return (Gatherer<TR, ?, RR>) new FilteringGatherer<TR>(e -> first.test(e) && second.test(e));\n+            } else if (that.getClass() == MappingGatherer.class) {\n+                final var thatMapper = (MappingGatherer<TR, RR>)that;\n+                return new FilteringMappingGatherer<>(predicate, thatMapper.mapper);\n+            } else if (that.getClass() == FilteringMappingGatherer.class) {\n+                var first = predicate;\n+                var thatFilterMapper = ((FilteringMappingGatherer<TR, RR>) that);\n+                var second = thatFilterMapper.predicate;\n+                return new FilteringMappingGatherer<>(e -> first.test(e) && second.test(e), thatFilterMapper.mapper);\n+            } else\n+                return Gatherer.super.andThen(that);\n+        }\n+    }\n+\n+    final static class FilteringMappingGatherer<T, R> implements Gatherer<T, Void, R>, Gatherer.Integrator.Greedy<Void, T, R>, BinaryOperator<Void> {\n+        final Predicate<? super T> predicate;\n+        final Function<? super T, ? extends R> mapper;\n+\n+        FilteringMappingGatherer(Predicate<? super T> predicate, Function<? super T, ? extends R> mapper) {\n+            this.predicate = predicate;\n+            this.mapper = mapper;\n+        }\n+\n+        @Override public Integrator<Void, T, R> integrator() { return this; }\n+        @Override public BinaryOperator<Void> combiner() { return this; }\n+        @Override public Void apply(Void left, Void right) { return left; }\n+\n+        @Override\n+        public <RR> Gatherer<T, ?, RR> andThen(Gatherer<? super R, ?, ?\n+                extends RR> that) {\n+            if (that.getClass() == MappingGatherer.class) { \/\/ Implicit null-check of that\n+                @SuppressWarnings(\"unchecked\")\n+                var thatMapper = ((MappingGatherer<R, RR>)that).mapper;\n+                return new FilteringMappingGatherer<>(this.predicate, this.mapper.andThen(thatMapper));\n+            } else\n+                return Gatherer.super.andThen(that);\n+        }\n+\n+        @Override\n+        public boolean integrate(Void state, T element, Gatherer.Downstream<? super R> downstream) {\n+            return !predicate.test(element) || downstream.push(mapper.apply(element));\n+        }\n+    }\n+\n+    final static class ReducingGatherer<TR> implements Gatherer<TR, Box<TR>, TR>,\n+            Supplier<Box<TR>>,\n+            Gatherer.Integrator.Greedy<Box<TR>, TR, TR>,\n+            BinaryOperator<Box<TR>>,\n+            BiConsumer<Box<TR>, Gatherer.Downstream<? super TR>> {\n+        private final BinaryOperator<TR> reduce;\n+        ReducingGatherer(BinaryOperator<TR> reduce) { this.reduce = reduce; }\n+\n+        @Override public Box<TR> get() { return new Box<>(); }\n+\n+        @Override\n+        public boolean integrate(Box<TR> state, TR m, Gatherer.Downstream<? super TR> downstream) {\n+            state.value = state.hasValue || !(state.hasValue = true) ? reduce.apply(state.value, m) : m;\n+            return true;\n+        }\n+\n+        @Override public Box<TR> apply(Box<TR> left, Box<TR> right) {\n+            if (right.hasValue)\n+                integrate(left, right.value, null);\n+            return left;\n+        }\n+\n+        @Override public void accept(Box<TR> box, Gatherer.Downstream<? super TR> downstream) {\n+            if (box.hasValue)\n+                downstream.push(box.value);\n+        }\n+\n+        @Override public Supplier<Box<TR>> initializer() { return this; }\n+        @Override public Integrator<Box<TR>, TR, TR> integrator() { return this; }\n+        @Override public BinaryOperator<Box<TR>> combiner() { return this; }\n+        @Override public BiConsumer<Box<TR>, Gatherer.Downstream<? super TR>> finisher() { return this; }\n+    }\n+\n+    final static class TakeWhileGatherer<TR> implements Gatherer<TR, Void, TR>, Gatherer.Integrator<Void, TR, TR>, BinaryOperator<Void> {\n+        final Predicate<? super TR> predicate;\n+        TakeWhileGatherer(Predicate<? super TR> predicate) { this.predicate = predicate; }\n+\n+        @Override public Integrator<Void, TR, TR> integrator() { return this; }\n+        @Override public BinaryOperator<Void> combiner() { return this; }\n+\n+        @Override public Void apply(Void left, Void right) { return left; }\n+\n+        @Override public boolean integrate(Void state, TR element, Gatherer.Downstream<? super TR> downstream) {\n+            return predicate.test(element) && downstream.push(element);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public final <RR> Gatherer<TR, ?, RR> andThen(Gatherer<? super TR, ?,\n+                ? extends RR> that) {\n+            if (that.getClass() == TakeWhileGatherer.class) {\n+                final var thisPredicate = predicate;\n+                final var thatPredicate = ((TakeWhileGatherer<TR>)that).predicate;\n+                return (Gatherer<TR, ?, RR>)new TakeWhileGatherer<TR>(e -> thisPredicate.test(e) && thatPredicate.test(e));\n+            }\n+            else\n+                return Gatherer.super.andThen(that);\n+        }\n+    }\n+\n+    final static class Box<T> {\n+        T value;\n+        boolean hasValue;\n+\n+        Box() {}\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/BenchmarkGathererImpls.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.Arrays;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.filter;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.map;\n+\n+\/**\n+ * Benchmark for filter+map+reduce operations implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherFMRPar {\n+\n+    @Param({\"10\",\"100\",\"1000000\"})\n+    private int size;\n+\n+    private Function<Long, Long> squared;\n+    private Predicate<Long> evens;\n+\n+    private Gatherer<Long, ?, Long> gathered;\n+    private Gatherer<Long, ?, Long> ga_map_squared;\n+    private Gatherer<Long, ?, Long> ga_filter_evens;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        squared = new Function<Long, Long>() { @Override public Long apply(Long l) { return l*l; } };\n+        evens = new Predicate<Long>() { @Override public boolean test(Long l) {\n+            return l % 2 == 0;\n+        } };\n+\n+        ga_map_squared = map(squared);\n+        ga_filter_evens = filter(evens);\n+\n+        gathered = ga_filter_evens.andThen(ga_map_squared);\n+    }\n+\n+    @Benchmark\n+    public long par_fmr_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .filter(evens)\n+                .map(squared)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_fmr_gather() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .gather(filter(evens))\n+                .gather(map(squared))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_fmr_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .gather(ga_filter_evens)\n+                .gather(ga_map_squared)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_fmr_gather_composed() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .gather(filter(evens).andThen(map(squared)))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_fmr_gather_composed_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .gather(filter(evens).andThen(map(squared)))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_fmr_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .gather(gathered)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherFMRPar.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.Arrays;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.filter;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.map;\n+\n+\/**\n+ * Benchmark for filter+map+reduce operations implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherFMRSeq {\n+\n+    @Param({\"10\",\"100\",\"1000000\"})\n+    private int size;\n+\n+    private Function<Long, Long> squared;\n+    private Predicate<Long> evens;\n+\n+    private Gatherer<Long, ?, Long> gathered;\n+    private Gatherer<Long, ?, Long> ga_map_squared;\n+    private Gatherer<Long, ?, Long> ga_filter_evens;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        squared = new Function<Long, Long>() { @Override public Long apply(Long l) { return l*l; } };\n+        evens = new Predicate<Long>() { @Override public boolean test(Long l) {\n+            return l % 2 == 0;\n+        } };\n+\n+        ga_map_squared = map(squared);\n+        ga_filter_evens = filter(evens);\n+\n+        gathered = ga_filter_evens.andThen(ga_map_squared);\n+    }\n+\n+    @Benchmark\n+    public long seq_fmr_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .filter(evens)\n+                .map(squared)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_fmr_gather() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(filter(evens))\n+                .gather(map(squared))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_fmr_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(ga_filter_evens)\n+                .gather(ga_map_squared)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_fmr_gather_composed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(filter(evens).andThen(map(squared)))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_fmr_gather_composed_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(filter(evens).andThen(map(squared)))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_fmr_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(gathered)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherFMRSeq.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.flatMap;\n+\n+\/**\n+ * Benchmark for map() operation implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherFlatMapInfinitySeq {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\", \"100\", \"1000\"})\n+    private int size;\n+\n+    private Function<Long, Stream<Long>> funInf;\n+\n+    private Long[] cachedInputArray;\n+\n+    private Gatherer<Long, ?, Long> gather_flatMap_inf;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        funInf = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+            return Stream.generate(() -> l);\n+        } };\n+\n+        gather_flatMap_inf = flatMap(funInf);\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .flatMap(funInf)\n+                .limit(size * 5)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(flatMap(funInf))\n+                .limit(size * 5)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(gather_flatMap_inf)\n+                .limit(size * 5)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherFlatMapInfinitySeq.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.flatMap;\n+\n+\/**\n+ * Benchmark for map() operation implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherFlatMapSeq {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\", \"100\", \"1000\"})\n+    private int size;\n+\n+    private Function<Long, Stream<Long>> fun;\n+\n+    private Gatherer<Long, ?, Long> gather_flatMap;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        fun = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+                return Arrays.stream(cachedInputArray);\n+            } };\n+\n+        gather_flatMap = flatMap(fun);\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .flatMap(fun)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(flatMap(fun))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(gather_flatMap)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherFlatMapSeq.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.map;\n+\n+\/**\n+ * Benchmark for map() operation implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherMapPar {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+    @Param({\"10\",\"100\",\"1000000\"})\n+    private int size;\n+\n+    private Function<Long, Long> m1, m2, m3;\n+\n+    private Gatherer<Long, ?, Long> gather_m1, gather_m2, gather_m3, gather_all, gather_m1_111;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+           cachedInputArray[i] = Long.valueOf(i);\n+\n+        m1 = new Function<Long, Long>() { @Override public Long apply(Long l) { return l*2; } };\n+        m2 = new Function<Long, Long>() { @Override public Long apply(Long l) { return l*2; } };\n+        m3 = new Function<Long, Long>() { @Override public Long apply(Long l) { return l*2; } };\n+        gather_m1 = map(m1);\n+        gather_m2 = map(m2);\n+        gather_m3 = map(m3);\n+        gather_all = gather_m1.andThen(gather_m2.andThen(gather_m3));\n+        gather_m1_111 = gather_m1.andThen(gather_m1.andThen(gather_m1));\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .map(m1)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_gather() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(map(m1))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(gather_m1)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_111_baseline() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .map(m1)\n+                .map(m1)\n+                .map(m1)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_111_gather_separate() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(map(m1))\n+                .gather(map(m1))\n+                .gather(map(m1))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_111_gather_composed() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(gather_m1.andThen(gather_m1).andThen(gather_m1))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_111_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(gather_m1_111)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_123_baseline() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .map(m1)\n+                .map(m2)\n+                .map(m3)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_123_gather_separate() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(map(m1))\n+                .gather(map(m2))\n+                .gather(map(m3))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_123_gather_composed() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(map(m1).andThen(map(m2).andThen(map(m3))))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_chain_123_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray).parallel()\n+                .gather(gather_all)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherMapPar.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.stream.Collector;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.map;\n+\n+\/**\n+ * Benchmark for map() operation implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherMapSeq {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\", \"100\", \"1000000\"})\n+    private int size;\n+\n+    private Function<Long, Long> m1, m2, m3;\n+\n+    private Gatherer<Long, ?, Long> gather_m1, gather_m2, gather_m3, gather_all, gather_m1_111;\n+\n+    private Long[] cachedInputArray;\n+\n+    private final static Collector<Long,LongAccumulator,Long> accumulate =\n+            Collector.of(LongAccumulator::new,\n+                         LongAccumulator::add,\n+                         (l,r) -> { l.merge(r); return l; },\n+                         LongAccumulator::get);\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+        m1 = new Function<Long, Long>() { @Override public Long apply(Long l) {\n+                return l*2;\n+            } };\n+        m2 = new Function<Long, Long>() { @Override public Long apply(Long l) {\n+                return l*2;\n+            } };\n+        m3 = new Function<Long, Long>() { @Override public Long apply(Long l) {\n+                return l*2;\n+            } };\n+        gather_m1 = map(m1);\n+        gather_m2 = map(m2);\n+        gather_m3 = map(m3);\n+        gather_all = gather_m1.andThen(gather_m2.andThen(gather_m3));\n+        gather_m1_111 = gather_m1.andThen(gather_m1.andThen(gather_m1));\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .map(m1)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(map(m1))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(gather_m1)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_111_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .map(m1)\n+                .map(m1)\n+                .map(m1)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_111_gather_separate() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(map(m1))\n+                .gather(map(m1))\n+                .gather(map(m1))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_111_gather_composed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(map(m1).andThen(map(m1)).andThen(map(m1)))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_111_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(gather_m1_111)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_123_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .map(m1)\n+                .map(m2)\n+                .map(m3)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_123_gather_separate() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(map(m1))\n+                .gather(map(m2))\n+                .gather(map(m3))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_123_gather_composed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(map(m1).andThen(map(m2)).andThen(map(m3)))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_chain_123_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(gather_all)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherMapSeq.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.Arrays;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.filter;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.map;\n+\n+\/**\n+ * Benchmark for misc operations implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherMiscPar {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\",\"100\",\"1000000\"})\n+    private int size;\n+\n+    private Function<Long, Long> timesTwo, halved;\n+    private Predicate<Long> evens, odds;\n+\n+    private Gatherer<Long, ?, Long> gathered;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        timesTwo = new Function<Long, Long>() { @Override public Long apply(Long l) {\n+                return l*2;\n+            } };\n+        halved = new Function<Long, Long>() { @Override public Long apply(Long l) { return l\/2; } };\n+\n+        evens = new Predicate<Long>() { @Override public boolean test(Long l) {\n+            return l % 2 == 0;\n+        } };\n+        odds = new Predicate<Long>() { @Override public boolean test(Long l) {\n+            return l % 2 != 0;\n+        } };\n+\n+        gathered = filter(odds)\n+                    .andThen(map(timesTwo))\n+                    .andThen(map(halved))\n+                    .andThen(filter(evens));\n+    }\n+\n+    @Benchmark\n+    public long par_misc_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .filter(odds)\n+                .map(timesTwo)\n+                .map(halved)\n+                .filter(evens)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_misc_gather() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .gather(filter(odds))\n+                .gather(map(timesTwo))\n+                .gather(map(halved))\n+                .gather(filter(evens))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_misc_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray)\n+                .parallel()\n+                .gather(gathered)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherMiscPar.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.filter;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.findLast;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.map;\n+\n+\/**\n+ * Benchmark for misc operations implemented as Gatherer, with the default map implementation of Stream as baseline.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherMiscSeq {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\",\"100\",\"1000000\"})\n+    private int size;\n+\n+    private Function<Long, Long> timesTwo, squared;\n+    private Predicate<Long> evens, odds;\n+\n+    private Gatherer<Long, ?, Long> gathered;\n+    private Gatherer<Long, ?, Long> ga_filter_odds;\n+    private Gatherer<Long, ?, Long> ga_map_timesTwo;\n+    private Gatherer<Long, ?, Long> ga_map_squared;\n+    private Gatherer<Long, ?, Long> ga_filter_evens;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        timesTwo = new Function<Long, Long>() { @Override public Long apply(Long l) {\n+                return l*2;\n+            } };\n+        squared = new Function<Long, Long>() { @Override public Long apply(Long l) { return l*l; } };\n+\n+        evens = new Predicate<Long>() { @Override public boolean test(Long l) {\n+            return l % 2 == 0;\n+        } };\n+        odds = new Predicate<Long>() { @Override public boolean test(Long l) {\n+            return l % 2 != 0;\n+        } };\n+\n+        ga_filter_odds = filter(odds);\n+        ga_map_timesTwo = map(timesTwo);\n+        ga_map_squared = map(squared);\n+        ga_filter_evens = filter(evens);\n+\n+        gathered = ga_filter_odds.andThen(ga_map_timesTwo).andThen(ga_map_squared).andThen(ga_filter_evens);\n+    }\n+\n+    @Benchmark\n+    public long seq_misc_baseline() {\n+        return Arrays.stream(cachedInputArray)\n+                .filter(odds)\n+                .map(timesTwo)\n+                .map(squared)\n+                .filter(evens)\n+                .collect(findLast()).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_misc_gather() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(filter(odds))\n+                .gather(map(timesTwo))\n+                .gather(map(squared))\n+                .gather(filter(evens))\n+                .collect(findLast()).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_misc_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(ga_filter_odds)\n+                .gather(ga_map_timesTwo)\n+                .gather(ga_map_squared)\n+                .gather(ga_filter_evens)\n+                .collect(findLast()).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_misc_gather_composed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(filter(odds)\n+                        .andThen(map(timesTwo))\n+                        .andThen(map(squared))\n+                        .andThen(filter(evens))\n+                )\n+                .collect(findLast()).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_misc_gather_composed_preallocated() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(ga_filter_odds\n+                        .andThen(ga_map_timesTwo)\n+                        .andThen(ga_map_squared)\n+                        .andThen(ga_filter_evens)\n+                )\n+                .collect(findLast()).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_misc_gather_precomposed() {\n+        return Arrays.stream(cachedInputArray)\n+                .gather(gathered)\n+                .collect(findLast()).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherMiscSeq.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BinaryOperator;\n+import java.util.Arrays;\n+import java.util.stream.Collector;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.findFirst;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.reduce;\n+\n+\/**\n+ * Benchmark for comparing the built-in reduce() operation with the Gatherer-based reduce-operation.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherReducePar {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *\/\n+\n+    @Param({\"100000\"})\n+    private int size;\n+\n+    private BinaryOperator<Long> op1;\n+\n+    private Gatherer<Long, ?, Long> gather_op1;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        op1 = new BinaryOperator<Long>() {\n+            @Override public Long apply(Long l, Long r) {\n+                return (l < r) ? r : l;\n+            }\n+        };\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray).parallel().reduce(op1).get();\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_gather() {\n+        return Arrays.stream(cachedInputArray).parallel().gather(reduce(op1)).collect(findFirst()).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherReducePar.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BinaryOperator;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Gatherer;\n+import java.util.stream.Collector;\n+import java.util.stream.Stream;\n+\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.findFirst;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.reduce;\n+\n+\/**\n+ * Benchmark for comparing the built-in reduce() operation with the Gatherer-based reduce-operation.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherReduceSeq {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *\/\n+\n+    @Param({\"100\", \"100000\"})\n+    private int size;\n+\n+    private BinaryOperator<Long> op1;\n+\n+    private Gatherer<Long, ?, Long> gather_op1;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        op1 = new BinaryOperator<Long>() {\n+            @Override\n+            public Long apply(Long l, Long r) {\n+                return (l < r) ? r : l;\n+            }\n+        };\n+\n+        gather_op1 = reduce(op1);\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray).reduce(op1).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather() {\n+        return Arrays.stream(cachedInputArray).gather(reduce(op1)).collect(findFirst()).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray).gather(gather_op1).collect(findFirst()).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherReduceSeq.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Predicate;\n+import java.util.Objects;\n+import java.util.Arrays;\n+import java.util.stream.Gatherer;\n+import static org.openjdk.bench.java.util.stream.ops.ref.BenchmarkGathererImpls.takeWhile;\n+\n+\/**\n+ * Benchmark for comparing the built-in takeWhile-operation with the Gatherer-based takeWhile-operation for ordered streams.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 7, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class GatherWhileOrdered {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *\/\n+\n+    @Param(\"100000\")\n+    private int size;\n+\n+    @Param({\"0\", \"49999\", \"99999\"})\n+    private int find;\n+\n+    private Predicate<Long> predicate;\n+\n+    private Gatherer<Long, ?, Long> gather_takeWhile;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        final int limit = find;\n+\n+        cachedInputArray = new Long[size];\n+        for(int i = 0;i < size;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        predicate = new Predicate<Long>() {\n+            @Override\n+            public boolean test(Long v) {\n+                return v < limit;\n+            }\n+        };\n+\n+        gather_takeWhile = takeWhile(predicate);\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray).takeWhile(predicate)\n+                         .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather() {\n+        return Arrays.stream(cachedInputArray).gather(takeWhile(predicate))\n+                         .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_invoke_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray).gather(gather_takeWhile)\n+                         .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_baseline() {\n+        return Arrays.stream(cachedInputArray).parallel().takeWhile(predicate)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_gather() {\n+        return Arrays.stream(cachedInputArray).parallel().gather(takeWhile(predicate))\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_invoke_gather_preallocated() {\n+        return Arrays.stream(cachedInputArray).parallel().gather(gather_takeWhile)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/GatherWhileOrdered.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}