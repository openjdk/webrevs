{"files":[{"patch":"@@ -45,1 +45,2 @@\n- * <p>Examples of gathering operations include, but is not limited to:\n+ * <p>There are many examples of gathering operations, including but not\n+ * limited to:\n@@ -115,1 +116,1 @@\n- * Gatherer<Integer, ?, String> incrementThenToString = plusOne.andThen(intToString);\n+ * Gatherer<Integer, ?, String> incrementThenToString = increment.andThen(intToString);\n@@ -118,1 +119,1 @@\n- * As an example, in order to create a gatherer to implement a sequential\n+ * <p>As an example, in order to create a gatherer to implement a sequential\n@@ -140,0 +141,12 @@\n+ * <p>Example of usage:\n+ *\n+ * {@snippet lang = java:\n+ * \/\/ will contain: [\"1\", \"12\", \"123\", \"1234\", \"12345\", \"123456\", \"1234567\", \"12345678\", \"123456789\"]\n+ * List<String> numberStrings =\n+ *     Stream.of(1,2,3,4,5,6,7,8,9)\n+ *           .gather(\n+ *               scan(() -> \"\", (string, number) -> string + number)\n+ *            )\n+ *           .toList();\n+ * }\n+ *\n@@ -250,1 +263,1 @@\n-     * @throws NullPointerException if the argument is null\n+     * @throws NullPointerException if the argument is {@code null}\n@@ -312,1 +325,1 @@\n-     * @throws NullPointerException if the argument is null\n+     * @throws NullPointerException if the argument is {@code null}\n@@ -333,1 +346,1 @@\n-     * @throws NullPointerException if any argument is null\n+     * @throws NullPointerException if any argument is {@code null}\n@@ -356,1 +369,1 @@\n-     * @throws NullPointerException if any argument is null\n+     * @throws NullPointerException if any argument is {@code null}\n@@ -380,1 +393,1 @@\n-     * @throws NullPointerException if any argument is null\n+     * @throws NullPointerException if any argument is {@code null}\n@@ -402,1 +415,1 @@\n-     * @throws NullPointerException if any argument is null\n+     * @throws NullPointerException if any argument is {@code null}\n@@ -422,1 +435,1 @@\n-     * @throws NullPointerException if any argument is null\n+     * @throws NullPointerException if any argument is {@code null}\n@@ -448,1 +461,1 @@\n-     * @throws NullPointerException if any argument is null\n+     * @throws NullPointerException if any argument is {@code null}\n@@ -475,2 +488,2 @@\n-         * Pushes, if possible, the provided element to the next stage in the\n-         * pipeline.\n+         * Pushes, if possible, the provided element downstream -- to the next\n+         * stage in the pipeline.\n@@ -478,2 +491,3 @@\n-         * <p>If this method returns {@code false} then the next stage does\n-         * not accept any more elements.\n+         * @implSpec If this method returns {@code false} then no further\n+         * elements will be accepted and subsequent invocations of this method\n+         * will return {@code false}.\n@@ -481,1 +495,1 @@\n-         * @param element the element to send\n+         * @param element the element to push downstream\n@@ -491,2 +505,2 @@\n-         * @apiNote This is best-effort only, once this returns true it should\n-         *          never return false again for the same instance.\n+         * @apiNote This is best-effort only, once this returns {@code true} it\n+         * should never return {@code false} again for the same instance.\n@@ -494,1 +508,1 @@\n-         * <p>By default this method returns {@code false}.\n+         * @implSpec By default this method returns {@code false}.\n@@ -523,2 +537,1 @@\n-         * @param downstream The downstream object of this integration,\n-         *                   returns false if doesn't want any more elements\n+         * @param downstream The downstream object of this integration\n@@ -577,1 +590,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherer.java","additions":35,"deletions":22,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+        private final static int LINEAR_APPEND_MAX = 8; \/\/ TODO revisit\n@@ -113,1 +114,1 @@\n-                && tb.count() < 8) \/\/ TODO revisit cutoff point\n+                && tb.count() < LINEAR_APPEND_MAX)\n@@ -179,0 +180,1 @@\n+            \/\/ Highly performance sensitive\n@@ -212,1 +214,0 @@\n-\n@@ -258,5 +259,4 @@\n-        \/* Currently GathererOp is always stateful,\n-         * but it would be possible to return `false` if:\n-         * - the Gatherer's initializer is Gatherer.defaultInitiatizer(),\n-         * - the Gatherer's combiner is NOT Gatherer.defaultCombiner()\n-         * - the Gatherer's finisher is Gatherer.defaultFinisher()\n+        \/* Currently GathererOp is always stateful, but what could be tried is:\n+         * return gatherer.initializer() != Gatherer.defaultInitializer()\n+         *     || gatherer.combiner() == Gatherer.defaultCombiner()\n+         *     || gatherer.finisher() != Gatherer.defaultFinisher();\n@@ -281,7 +281,7 @@\n-                upstream().wrapSpliterator(spliterator),\n-                true,\n-                gatherer,\n-                NodeBuilder::new,\n-                NodeBuilder::accept,\n-                NodeBuilder::join,\n-                NodeBuilder::build\n+            upstream().wrapSpliterator(spliterator),\n+            true,\n+            gatherer,\n+            NodeBuilder::new,\n+            NodeBuilder::accept,\n+            NodeBuilder::join,\n+            NodeBuilder::build\n@@ -316,0 +316,1 @@\n+        final var u = upstream();\n@@ -317,9 +318,9 @@\n-                upstream().wrapSpliterator(upstream().sourceSpliterator(0)),\n-                parallel,\n-                gatherer,\n-                c.supplier(),\n-                c.accumulator(),\n-                parallel ? c.combiner() : null,\n-                c.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)\n-                        ? null\n-                        : c.finisher()\n+            u.wrapSpliterator(u.sourceSpliterator(0)),\n+            parallel,\n+            gatherer,\n+            c.supplier(),\n+            c.accumulator(),\n+            parallel ? c.combiner() : null,\n+            c.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)\n+                    ? null\n+                    : c.finisher()\n@@ -335,0 +336,1 @@\n+        final var u = upstream();\n@@ -336,10 +338,10 @@\n-                upstream().wrapSpliterator(upstream().sourceSpliterator(0)),\n-                parallel,\n-                gatherer,\n-                supplier,\n-                accumulator,\n-                parallel ? (l, r) -> {\n-                    combiner.accept(l, r);\n-                    return l;\n-                } : null,\n-                null\n+            u.wrapSpliterator(u.sourceSpliterator(0)),\n+            parallel,\n+            gatherer,\n+            supplier,\n+            accumulator,\n+            parallel ? (l, r) -> {\n+                combiner.accept(l, r);\n+                return l;\n+            } : null,\n+            null\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":35,"deletions":33,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Collections;\n@@ -71,0 +72,5 @@\n+     * @implSpec Each window produced is an unmodifiable List; calls to any\n+     * mutator method will always cause {@code UnsupportedOperationException}\n+     * to be thrown. There are no guarantees on the implementation type or\n+     * serializability of the produced Lists.\n+     *\n@@ -80,1 +86,1 @@\n-     * @throws IllegalArgumentException when windowSize is less than 1\n+     * @throws IllegalArgumentException when {@code windowSize} is less than 1\n@@ -104,2 +110,2 @@\n-                            SharedSecrets.getJavaUtilCollectionAccess()\n-                                    .listFromTrustedArrayNullsAllowed(oldWindow)\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(oldWindow)\n@@ -117,2 +123,2 @@\n-                            SharedSecrets.getJavaUtilCollectionAccess()\n-                                    .listFromTrustedArrayNullsAllowed(lastWindow)\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(lastWindow)\n@@ -155,0 +161,5 @@\n+     * @implSpec Each window produced is an unmodifiable List; calls to any\n+     * mutator method will always cause {@code UnsupportedOperationException}\n+     * to be thrown. There are no guarantees on the implementation type or\n+     * serializability of the produced Lists.\n+     *\n@@ -193,2 +204,2 @@\n-                            SharedSecrets.getJavaUtilCollectionAccess()\n-                                    .listFromTrustedArrayNullsAllowed(oldWindow)\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(oldWindow)\n@@ -206,2 +217,2 @@\n-                            SharedSecrets.getJavaUtilCollectionAccess()\n-                                    .listFromTrustedArrayNullsAllowed(lastWindow)\n+                        SharedSecrets.getJavaUtilCollectionAccess()\n+                                     .listFromTrustedArrayNullsAllowed(lastWindow)\n@@ -235,1 +246,1 @@\n-     * \/\/ will contain: Optional[123456789]\n+     * \/\/ will contain: Optional[\"123456789\"]\n@@ -251,1 +262,1 @@\n-     * @throws NullPointerException if any of the parameters are null\n+     * @throws NullPointerException if any of the parameters are {@code null}\n@@ -284,1 +295,1 @@\n-     * \/\/ will contain: [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]\n+     * \/\/ will contain: [\"1\", \"12\", \"123\", \"1234\", \"12345\", \"123456\", \"1234567\", \"12345678\", \"123456789\"]\n@@ -298,1 +309,1 @@\n-     * @throws NullPointerException if any of the parameters are null\n+     * @throws NullPointerException if any of the parameters are {@code null}\n@@ -319,1 +330,1 @@\n-     * with a fixed window of max concurrency, using\n+     * with a configured level of max concurrency, using\n@@ -336,2 +347,2 @@\n-     * @throws IllegalArgumentException if maxConcurrency is less than 1\n-     * @throws NullPointerException if mapper is null\n+     * @throws IllegalArgumentException if {@code maxConcurrency} is less than 1\n+     * @throws NullPointerException if {@code mapper} is {@code null}\n@@ -342,1 +353,1 @@\n-        if (maxConcurrency <= 0)\n+        if (maxConcurrency < 1)\n@@ -344,1 +355,1 @@\n-                    \"'maxConcurrency' needs to be greater than 0\");\n+                    \"'maxConcurrency' must be greater than 0\");\n@@ -685,1 +696,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherers.java","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -106,0 +106,10 @@\n+\n+            \/\/ Test unmodifiability of windows\n+            {\n+                var window = config.stream()\n+                                   .gather(Gatherers.windowFixed(1))\n+                                   .findFirst()\n+                                   .get();\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> window.add(2));\n+            }\n@@ -162,0 +172,10 @@\n+\n+            \/\/ Test unmodifiability of windows\n+            {\n+                var window = config.stream()\n+                        .gather(Gatherers.windowSliding(1))\n+                        .findFirst()\n+                        .get();\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> window.add(2));\n+            }\n","filename":"test\/jdk\/java\/util\/stream\/GatherersTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}