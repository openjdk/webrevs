{"files":[{"patch":"@@ -263,0 +263,2 @@\n+     * @implSpec This method always returns the same instance.\n+     *\n@@ -276,0 +278,2 @@\n+     * @implSpec This method always returns the same instance.\n+     *\n@@ -290,0 +294,2 @@\n+     * @implSpec This method always returns the same instance.\n+     *\n@@ -509,3 +515,3 @@\n-        \/** Integrate is the method which given:\n-         * the current state, the next element, and a downstream object;\n-         * performs the main logic -- potentially inspecting and\/or updating\n+        \/**\n+         * Performs an action given: the current state, the next element, and\n+         * a downstream object; potentially inspecting and\/or updating\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherer.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n@@ -35,0 +38,1 @@\n+import java.util.function.BiFunction;\n@@ -39,0 +43,1 @@\n+import java.util.function.Predicate;\n@@ -40,0 +45,3 @@\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,268 +54,1 @@\n-    private Gatherers() { }\n-\n-    \/*\n-     * This enum is used to provide the default functions for the factory methods\n-     * and for the default methods for when implementing the Gatherer interface.\n-     *\n-     * This serves the following purposes:\n-     * 1. removes the need for using `null` for signalling absence of specified\n-     *    value and thereby hiding user bugs\n-     * 2. allows to check against these default values to avoid calling methods\n-     *    needlessly\n-     * 3. allows for more efficient composition and evaluation\n-     *\/\n-    @SuppressWarnings(\"rawtypes\")\n-    enum Value implements Supplier, BinaryOperator, BiConsumer {\n-        DEFAULT;\n-\n-        final BinaryOperator<Void> statelessCombiner = new BinaryOperator<>() {\n-            @Override public Void apply(Void left, Void right) { return null; }\n-        };\n-\n-        \/\/ BiConsumer\n-        @Override public void accept(Object state, Object downstream) {}\n-\n-        \/\/ BinaryOperator\n-        @Override public Object apply(Object left, Object right) {\n-            throw new UnsupportedOperationException(\"This combiner cannot be used!\");\n-        }\n-\n-        \/\/ Supplier\n-        @Override public Object get() { return null; }\n-\n-        @ForceInline\n-        @SuppressWarnings(\"unchecked\")\n-        <A> Supplier<A> initializer() { return (Supplier<A>)this; }\n-\n-        @ForceInline\n-        @SuppressWarnings(\"unchecked\")\n-        <T> BinaryOperator<T> combiner() { return (BinaryOperator<T>) this; }\n-\n-        @ForceInline\n-        @SuppressWarnings(\"unchecked\")\n-        <T, R> BiConsumer<T, Gatherer.Downstream<? super R>> finisher() {\n-            return (BiConsumer<T, Downstream<? super R>>) this;\n-        }\n-    }\n-\n-    record GathererImpl<T, A, R>(\n-            @Override Supplier<A> initializer,\n-            @Override Integrator<A, T, R> integrator,\n-            @Override BinaryOperator<A> combiner,\n-            @Override BiConsumer<A, Downstream<? super R>> finisher) implements Gatherer<T, A, R> {\n-\n-        static <T, A, R> GathererImpl<T, A, R> of(\n-                Supplier<A> initializer,\n-                Integrator<A, T, R> integrator,\n-                BinaryOperator<A> combiner,\n-                BiConsumer<A, Downstream<? super R>> finisher) {\n-            return new GathererImpl<>(\n-                    Objects.requireNonNull(initializer,\"initializer\"),\n-                    Objects.requireNonNull(integrator, \"integrator\"),\n-                    Objects.requireNonNull(combiner, \"combiner\"),\n-                    Objects.requireNonNull(finisher, \"finisher\")\n-            );\n-        }\n-    }\n-\n-    final static class Composite<T, A, R, AA, RR> implements Gatherer<T, Object, RR> {\n-        private final Gatherer<T, A, ? extends R> left;\n-        private final Gatherer<? super R, AA, ? extends RR> right;\n-        \/\/ FIXME change `impl` to a computed constant when available\n-        private GathererImpl<T, Object, RR> impl;\n-\n-        static <T, A, R, AA, RR> Composite<T, A, R, AA, RR> of(\n-                Gatherer<T, A, ? extends R> left,\n-                Gatherer<? super R, AA, ? extends RR> right) {\n-            return new Composite<>(left, right);\n-        }\n-\n-        private Composite(Gatherer<T, A, ? extends R> left,\n-                          Gatherer<? super R, AA, ? extends RR> right) {\n-            this.left = left;\n-            this.right = right;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        private GathererImpl<T, Object, RR> impl() {\n-            \/\/ ATTENTION: this method currently relies on a \"benign\" data-race\n-            \/\/ as it should deterministically produce the same result even if\n-            \/\/ initialized concurrently on different threads.\n-            var i = impl;\n-            return i != null\n-                     ? i\n-                     : (impl = (GathererImpl<T, Object, RR>)impl(left, right));\n-        }\n-\n-        @Override public Supplier<Object> initializer() {\n-            return impl().initializer();\n-        }\n-\n-        @Override public Integrator<Object, T, RR> integrator() {\n-            return impl().integrator();\n-        }\n-\n-        @Override public BinaryOperator<Object> combiner() {\n-            return impl().combiner();\n-        }\n-\n-        @Override public BiConsumer<Object, Downstream<? super RR>> finisher() {\n-            return impl().finisher();\n-        }\n-\n-        @Override\n-        public <RRR> Gatherer<T, ?, RRR> andThen(\n-                Gatherer<? super RR, ?, ? extends RRR> that) {\n-            if (that.getClass() == Composite.class) {\n-                @SuppressWarnings(\"unchecked\")\n-                final var c =\n-                    (Composite<? super RR, ?, Object, ?, ? extends RRR>) that;\n-                return left.andThen(right.andThen(c.left).andThen(c.right));\n-            } else {\n-                return left.andThen(right.andThen(that));\n-            }\n-        }\n-\n-        static final <T, A, R, AA, RR> GathererImpl<T, ?, RR> impl(\n-                Gatherer<T, A, R> left, Gatherer<? super R, AA, RR> right) {\n-            final var leftInitializer = left.initializer();\n-            final var leftIntegrator = left.integrator();\n-            final var leftCombiner = left.combiner();\n-            final var leftFinisher = left.finisher();\n-\n-            final var rightInitializer = right.initializer();\n-            final var rightIntegrator = right.integrator();\n-            final var rightCombiner = right.combiner();\n-            final var rightFinisher = right.finisher();\n-\n-            final var leftStateless = leftInitializer == Gatherer.defaultInitializer();\n-            final var rightStateless = rightInitializer == Gatherer.defaultInitializer();\n-\n-            final var leftGreedy = leftIntegrator instanceof Integrator.Greedy;\n-            final var rightGreedy = rightIntegrator instanceof Integrator.Greedy;\n-\n-            \/*\n-             * For pairs of stateless and greedy Gatherers, we can optimize\n-             * evaluation as we do not need to track any state nor any\n-             * short-circuit signals. This can provide significant\n-             * performance improvements.\n-             *\/\n-            if (leftStateless && rightStateless && leftGreedy && rightGreedy) {\n-                return new GathererImpl<>(\n-                    Gatherer.defaultInitializer(),\n-                    Gatherer.Integrator.ofGreedy((unused, element, downstream) ->\n-                        leftIntegrator.integrate(\n-                                null,\n-                                element,\n-                                r -> rightIntegrator.integrate(null, r, downstream))\n-                    ),\n-                    (leftCombiner == Gatherer.defaultCombiner()\n-                    || rightCombiner == Gatherer.defaultCombiner())\n-                            ? Gatherer.defaultCombiner()\n-                            : Value.DEFAULT.statelessCombiner\n-                    ,\n-                    (leftFinisher == Gatherer.<A,R>defaultFinisher()\n-                    && rightFinisher == Gatherer.<AA,RR>defaultFinisher())\n-                            ? Gatherer.defaultFinisher()\n-                            : (unused, downstream) -> {\n-                        if (leftFinisher != Gatherer.<A,R>defaultFinisher())\n-                            leftFinisher.accept(\n-                                    null,\n-                                    r -> rightIntegrator.integrate(null, r, downstream));\n-                        if (rightFinisher != Gatherer.<AA,RR>defaultFinisher())\n-                            rightFinisher.accept(null, downstream);\n-                    }\n-                );\n-            } else {\n-                class State {\n-                    final A leftState;\n-                    final AA rightState;\n-                    boolean leftProceed;\n-                    boolean rightProceed;\n-\n-                    private State(A leftState, AA rightState,\n-                                  boolean leftProceed, boolean rightProceed) {\n-                        this.leftState = leftState;\n-                        this.rightState = rightState;\n-                        this.leftProceed = leftProceed;\n-                        this.rightProceed = rightProceed;\n-                    }\n-\n-                    State() {\n-                        this(leftStateless ? null : leftInitializer.get(),\n-                             rightStateless ? null : rightInitializer.get(),\n-                            true, true);\n-                    }\n-\n-                    State joinLeft(State right) {\n-                        return new State(\n-                                leftStateless ? null : leftCombiner.apply(this.leftState, right.leftState),\n-                                rightStateless ? null : rightCombiner.apply(this.rightState, right.rightState),\n-                                this.leftProceed && this.rightProceed,\n-                                right.leftProceed && right.rightProceed);\n-                    }\n-\n-                    boolean integrate(T t, Downstream<? super RR> c) {\n-                        \/*\n-                         * rightProceed must be checked after integration of\n-                         * left since that can cause right to short-circuit\n-                         * We always want to conditionally write leftProceed\n-                         * here, which means that we only do so if we are\n-                         * known to be not-greedy.\n-                         *\/\n-                        return (leftIntegrator.integrate(leftState, t, r -> rightIntegrate(r, c))\n-                                  || leftGreedy\n-                                  || (leftProceed = false))\n-                                && (rightGreedy || rightProceed);\n-                    }\n-\n-                    void finish(Downstream<? super RR> c) {\n-                        if (leftFinisher != Gatherer.<A, R>defaultFinisher())\n-                            leftFinisher.accept(leftState, r -> rightIntegrate(r, c));\n-                        if (rightFinisher != Gatherer.<AA, RR>defaultFinisher())\n-                            rightFinisher.accept(rightState, c);\n-                    }\n-\n-                    \/*\n-                     * Currently we use the following to ferry elements from\n-                     * the left Gatherer to the right Gatherer, but we create\n-                     * the Gatherer.Downstream as a lambda which means that\n-                     * the default implementation of `isKnownDone()` is used.\n-                     *\n-                     * If it is determined that we want to be able to support\n-                     * the full interface of Gatherer.Downstream then we have\n-                     *  the following options:\n-                     *    1. Have State implement Downstream<? super R>\n-                     *       and store the passed in Downstream<? super RR>\n-                     *       downstream as an instance field in integrate()\n-                     *       and read it in push(R r).\n-                     *    2. Allocate a new Gatherer.Downstream<? super R> for\n-                     *       each invocation of integrate() which might prove\n-                     *       costly.\n-                     *\/\n-                    public boolean rightIntegrate(R r, Downstream<? super RR> downstream) {\n-                        \/\/ The following logic is highly performance sensitive\n-                        return (rightGreedy || rightProceed)\n-                                && (rightIntegrator.integrate(rightState, r, downstream)\n-                                || rightGreedy\n-                                || (rightProceed = false));\n-                    }\n-                }\n-\n-                return new GathererImpl<T, State, RR>(\n-                        State::new,\n-                        (leftGreedy && rightGreedy)\n-                                ? Integrator.<State, T, RR>ofGreedy(State::integrate)\n-                                : Integrator.<State, T, RR>of(State::integrate),\n-                        (leftCombiner == Gatherer.defaultCombiner()\n-                        || rightCombiner == Gatherer.defaultCombiner())\n-                                ? Gatherer.defaultCombiner()\n-                                : State::joinLeft,\n-                        (leftFinisher == Gatherer.<A, R>defaultFinisher()\n-                        && rightFinisher == Gatherer.<AA, RR>defaultFinisher())\n-                                ? Gatherer.defaultFinisher()\n-                                : State::finish\n-                );\n-            }\n-        }\n-    }\n+    private Gatherers() { } \/\/ This class is not intended to be instantiated\n@@ -326,2 +59,4 @@\n-     * Gathers elements into fixed-size windows. The last window may contain\n-     * fewer elements than the supplied window size.\n+     * Returns a Gatherer that gathers elements into windows\n+     * -- encounter-ordered groups of elements -- of a fixed size.\n+     * If the stream is empty then no window will be produced.\n+     * The last window may contain fewer elements than the supplied window size.\n@@ -369,2 +104,2 @@\n-                        SharedSecrets.getJavaUtilCollectionAccess()\n-                                     .listFromTrustedArrayNullsAllowed(oldWindow)\n+                            SharedSecrets.getJavaUtilCollectionAccess()\n+                                    .listFromTrustedArrayNullsAllowed(oldWindow)\n@@ -401,2 +136,4 @@\n-     * Gathers elements into sliding windows, sliding out the most previous\n-     * element and sliding in the next element for each subsequent window.\n+     * Returns a Gatherer that gathers elements into windows --\n+     * encounter-ordered groups of elements -- of a given size, where each\n+     * subsequent window includes all elements of the previous window except\n+     * for the least recent, and adds the next element in the stream.\n@@ -405,1 +142,1 @@\n-     * be emitted, containing all elements.\n+     * be produced, containing all elements in the stream.\n@@ -410,1 +147,1 @@\n-     * List<List<Integer>> windows =\n+     * List<List<Integer>> windows2 =\n@@ -412,0 +149,4 @@\n+     *\n+     * \/\/ will contain: [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8]]\n+     * List<List<Integer>> windows6 =\n+     *     Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowSliding(6)).toList();\n@@ -452,2 +193,2 @@\n-                        SharedSecrets.getJavaUtilCollectionAccess()\n-                                     .listFromTrustedArrayNullsAllowed(oldWindow)\n+                            SharedSecrets.getJavaUtilCollectionAccess()\n+                                    .listFromTrustedArrayNullsAllowed(oldWindow)\n@@ -465,2 +206,2 @@\n-                        SharedSecrets.getJavaUtilCollectionAccess()\n-                                     .listFromTrustedArrayNullsAllowed(lastWindow)\n+                            SharedSecrets.getJavaUtilCollectionAccess()\n+                                    .listFromTrustedArrayNullsAllowed(lastWindow)\n@@ -484,1 +225,1 @@\n-     * An operation which performs an ordered, <i>reduction-like<\/i>,\n+     * Returns a Gatherer that performs an ordered, <i>reduction-like<\/i>,\n@@ -489,1 +230,2 @@\n-     * <p>This operation always emits a single resulting element.\n+     * @implSpec If no exceptions are thrown during processing, then this\n+     * operation only ever produces a single element.\n@@ -517,3 +259,256 @@\n-        class State {\n-            R value = initial.get();\n-            State() {}\n+        class State {\n+            R value = initial.get();\n+            State() {}\n+        }\n+\n+        return Gatherer.ofSequential(\n+                State::new,\n+                Integrator.ofGreedy((state, element, downstream) -> {\n+                    state.value = folder.apply(state.value, element);\n+                    return true;\n+                }),\n+                (state, downstream) -> downstream.push(state.value)\n+        );\n+    }\n+\n+    \/**\n+     * Returns a Gatherer that performs a Prefix Scan -- an incremental\n+     * accumulation -- using the provided functions.  Starting with an\n+     * initial value obtained from the {@code Supplier}, each subsequent\n+     * value is obtained by applying the {@code BiFunction} to the current\n+     * value and the next input element, after which the resulting value is\n+     * produced downstream.\n+     *\n+     * <p>Example:\n+     * {@snippet lang = java:\n+     * \/\/ will contain: [1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789]\n+     * List<String> numberStrings =\n+     *     Stream.of(1,2,3,4,5,6,7,8,9)\n+     *           .gather(\n+     *               Gatherers.scan(() -> \"\", (string, number) -> string + number)\n+     *            )\n+     *           .toList();\n+     * }\n+     *\n+     * @param initial the supplier of the initial value for the scanner\n+     * @param scanner the function to apply for each element\n+     * @param <T> the type of element which this gatherer consumes\n+     * @param <R> the type of element which this gatherer produces\n+     * @return a new Gatherer which performs a prefix scan\n+     * @throws NullPointerException if any of the parameters are null\n+     *\/\n+    public static <T, R> Gatherer<T, ?, R> scan(\n+            Supplier<R> initial,\n+            BiFunction<? super R, ? super T, ? extends R> scanner) {\n+        Objects.requireNonNull(initial, \"'initial' must not be null\");\n+        Objects.requireNonNull(scanner, \"'scanner' must not be null\");\n+\n+        class State {\n+            R current = initial.get();\n+            boolean integrate(T element, Downstream<? super R> downstream) {\n+                return downstream.push(current = scanner.apply(current, element));\n+            }\n+        }\n+\n+        return Gatherer.ofSequential(State::new,\n+                Integrator.<State,T, R>ofGreedy(State::integrate));\n+    }\n+\n+    \/**\n+     * An operation which executes operations concurrently\n+     * with a fixed window of max concurrency, using\n+     * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>.\n+     * This operation preserves the ordering of the stream.\n+     *\n+     * <p>In progress tasks will be attempted to be cancelled,\n+     * on a best-effort basis, in situations where the downstream no longer\n+     * wants to receive any more elements.\n+     *\n+     * <p>If the mapper throws an exception during evaluation of this Gatherer,\n+     * and the result of that invocation is to be produced to the downstream,\n+     * then that exception will instead be rethrown as a {@link RuntimeException}.\n+     *\n+     * @param maxConcurrency the maximum concurrency desired\n+     * @param mapper a function to be executed concurrently\n+     * @param <T> the type of input\n+     * @param <R> the type of output\n+     * @return a new Gatherer\n+     * @throws IllegalArgumentException if maxConcurrency is less than 1\n+     * @throws NullPointerException if mapper is null\n+     *\/\n+    public static <T, R> Gatherer<T,?,R> mapConcurrent(\n+            final int maxConcurrency,\n+            final Function<? super T, ? extends R> mapper) {\n+        if (maxConcurrency <= 0)\n+            throw new IllegalArgumentException(\n+                    \"'maxConcurrency' needs to be greater than 0\");\n+\n+        Objects.requireNonNull(mapper, \"'mapper' must not be null\");\n+\n+        class State {\n+            final ArrayDeque<Future<R>> window = new ArrayDeque<>(maxConcurrency);\n+            final Semaphore windowLock = new Semaphore(maxConcurrency);\n+\n+            final boolean integrate(T element,\n+                                    Downstream<? super R> downstream) {\n+                if (!downstream.isRejecting())\n+                    createTaskFor(element);\n+                return flush(0, downstream);\n+            }\n+\n+            final void createTaskFor(T element) {\n+                windowLock.acquireUninterruptibly();\n+\n+                var task = new FutureTask<R>(() -> {\n+                    try {\n+                        return mapper.apply(element);\n+                    } finally {\n+                        windowLock.release();\n+                    }\n+                });\n+\n+                var wasAddedToWindow = window.add(task);\n+                assert wasAddedToWindow;\n+\n+                Thread.startVirtualThread(task);\n+            }\n+\n+            final boolean flush(long atLeastN,\n+                                Downstream<? super R> downstream) {\n+                boolean proceed = !downstream.isRejecting();\n+                try {\n+                    Future<R> current;\n+                    while(proceed\n+                            && (current = window.peek()) != null\n+                                && (current.isDone() || atLeastN > 0)) {\n+                        proceed &= downstream.push(current.get());\n+                        atLeastN -= 1;\n+\n+                        var correctRemoval = window.pop() == current;\n+                        assert correctRemoval;\n+                    }\n+                } catch (Exception e) {\n+                    proceed = false; \/\/ Ensure cleanup\n+                    throw (e instanceof RuntimeException re)\n+                            ? re\n+                            : new RuntimeException(e);\n+                } finally {\n+                    \/\/ Clean up\n+                    if (!proceed) {\n+                        Future<R> next;\n+                        while((next = window.pollFirst()) != null) {\n+                            next.cancel(true);\n+                        }\n+                    }\n+                }\n+\n+                return proceed;\n+            }\n+        }\n+\n+        return Gatherer.ofSequential(\n+                State::new,\n+                Integrator.<State, T, R>ofGreedy(State::integrate),\n+                (state, downstream) -> state.flush(Long.MAX_VALUE, downstream)\n+        );\n+    }\n+\n+    \/\/ Implementation details\n+\n+    \/*\n+     * This enum is used to provide the default functions for the\n+     * factory methods\n+     * and for the default methods for when implementing the Gatherer interface.\n+     *\n+     * This serves the following purposes:\n+     * 1. removes the need for using `null` for signalling absence of specified\n+     *    value and thereby hiding user bugs\n+     * 2. allows to check against these default values to avoid calling methods\n+     *    needlessly\n+     * 3. allows for more efficient composition and evaluation\n+     *\/\n+    @SuppressWarnings(\"rawtypes\")\n+    enum Value implements Supplier, BinaryOperator, BiConsumer {\n+        DEFAULT;\n+\n+        final BinaryOperator<Void> statelessCombiner = new BinaryOperator<>() {\n+            @Override public Void apply(Void left, Void right) { return null; }\n+        };\n+\n+        \/\/ BiConsumer\n+        @Override public void accept(Object state, Object downstream) {}\n+\n+        \/\/ BinaryOperator\n+        @Override public Object apply(Object left, Object right) {\n+            throw new UnsupportedOperationException(\"This combiner cannot be used!\");\n+        }\n+\n+        \/\/ Supplier\n+        @Override public Object get() { return null; }\n+\n+        @ForceInline\n+        @SuppressWarnings(\"unchecked\")\n+        <A> Supplier<A> initializer() { return (Supplier<A>)this; }\n+\n+        @ForceInline\n+        @SuppressWarnings(\"unchecked\")\n+        <T> BinaryOperator<T> combiner() { return (BinaryOperator<T>) this; }\n+\n+        @ForceInline\n+        @SuppressWarnings(\"unchecked\")\n+        <T, R> BiConsumer<T, Gatherer.Downstream<? super R>> finisher() {\n+            return (BiConsumer<T, Downstream<? super R>>) this;\n+        }\n+    }\n+\n+    record GathererImpl<T, A, R>(\n+            @Override Supplier<A> initializer,\n+            @Override Integrator<A, T, R> integrator,\n+            @Override BinaryOperator<A> combiner,\n+            @Override BiConsumer<A, Downstream<? super R>> finisher) implements Gatherer<T, A, R> {\n+\n+        static <T, A, R> GathererImpl<T, A, R> of(\n+                Supplier<A> initializer,\n+                Integrator<A, T, R> integrator,\n+                BinaryOperator<A> combiner,\n+                BiConsumer<A, Downstream<? super R>> finisher) {\n+            return new GathererImpl<>(\n+                    Objects.requireNonNull(initializer,\"initializer\"),\n+                    Objects.requireNonNull(integrator, \"integrator\"),\n+                    Objects.requireNonNull(combiner, \"combiner\"),\n+                    Objects.requireNonNull(finisher, \"finisher\")\n+            );\n+        }\n+    }\n+\n+    final static class Composite<T, A, R, AA, RR> implements Gatherer<T, Object, RR> {\n+        private final Gatherer<T, A, ? extends R> left;\n+        private final Gatherer<? super R, AA, ? extends RR> right;\n+        \/\/ FIXME change `impl` to a computed constant when available\n+        private GathererImpl<T, Object, RR> impl;\n+\n+        static <T, A, R, AA, RR> Composite<T, A, R, AA, RR> of(\n+                Gatherer<T, A, ? extends R> left,\n+                Gatherer<? super R, AA, ? extends RR> right) {\n+            return new Composite<>(left, right);\n+        }\n+\n+        private Composite(Gatherer<T, A, ? extends R> left,\n+                          Gatherer<? super R, AA, ? extends RR> right) {\n+            this.left = left;\n+            this.right = right;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private GathererImpl<T, Object, RR> impl() {\n+            \/\/ ATTENTION: this method currently relies on a \"benign\" data-race\n+            \/\/ as it should deterministically produce the same result even if\n+            \/\/ initialized concurrently on different threads.\n+            var i = impl;\n+            return i != null\n+                     ? i\n+                     : (impl = (GathererImpl<T, Object, RR>)impl(left, right));\n+        }\n+\n+        @Override public Supplier<Object> initializer() {\n+            return impl().initializer();\n@@ -522,9 +517,3 @@\n-        return Gatherer.ofSequential(\n-                State::new,\n-                Integrator.ofGreedy((state, element, downstream) -> {\n-                    state.value = folder.apply(state.value, element);\n-                    return true;\n-                }),\n-                (state, downstream) -> downstream.push(state.value)\n-        );\n-    }\n+        @Override public Integrator<Object, T, RR> integrator() {\n+            return impl().integrator();\n+        }\n@@ -532,16 +521,3 @@\n-    \/**\n-     * Performs a prefix scan -- an incremental accumulation, using the\n-     * provided functions.\n-     *\n-     * @param initial the supplier of the initial value for the scanner\n-     * @param scanner the function to apply for each element\n-     * @param <T> the type of element which this gatherer consumes\n-     * @param <R> the type of element which this gatherer produces\n-     * @return a new Gatherer which performs a prefix scan\n-     * @throws NullPointerException if any of the parameters are null\n-     *\/\n-    public static <T, R> Gatherer<T, ?, R> scan(\n-            Supplier<R> initial,\n-            BiFunction<? super R, ? super T, ? extends R> scanner) {\n-        Objects.requireNonNull(initial, \"'initial' must not be null\");\n-        Objects.requireNonNull(scanner, \"'scanner' must not be null\");\n+        @Override public BinaryOperator<Object> combiner() {\n+            return impl().combiner();\n+        }\n@@ -549,5 +525,2 @@\n-        class State {\n-            R current = initial.get();\n-            boolean integrate(T element, Downstream<? super R> downstream) {\n-                return downstream.push(current = scanner.apply(current, element));\n-            }\n+        @Override public BiConsumer<Object, Downstream<? super RR>> finisher() {\n+            return impl().finisher();\n@@ -556,3 +529,12 @@\n-        return Gatherer.ofSequential(State::new,\n-                                     Integrator.<State,T, R>ofGreedy(State::integrate));\n-    }\n+        @Override\n+        public <RRR> Gatherer<T, ?, RRR> andThen(\n+                Gatherer<? super RR, ?, ? extends RRR> that) {\n+            if (that.getClass() == Composite.class) {\n+                @SuppressWarnings(\"unchecked\")\n+                final var c =\n+                    (Composite<? super RR, ?, Object, ?, ? extends RRR>) that;\n+                return left.andThen(right.andThen(c.left).andThen(c.right));\n+            } else {\n+                return left.andThen(right.andThen(that));\n+            }\n+        }\n@@ -560,27 +542,6 @@\n-    \/**\n-     * An operation which executes operations concurrently\n-     * with a fixed window of max concurrency, using VirtualThreads.\n-     * This operation preserves the ordering of the stream.\n-     *\n-     * <p>In progress tasks will be attempted to be cancelled,\n-     * on a best-effort basis, in situations where the downstream no longer\n-     * wants to receive any more elements.\n-     *\n-     * <p>If the mapper throws an exception during evaluation of this Gatherer,\n-     * and the result of that invocation is to be produced to the downstream,\n-     * then that exception will instead be rethrown as a {@link RuntimeException}.\n-     *\n-     * @param maxConcurrency the maximum concurrency desired\n-     * @param mapper a function to be executed concurrently\n-     * @param <T> the type of input\n-     * @param <R> the type of output\n-     * @return a new Gatherer\n-     * @throws IllegalArgumentException if maxConcurrency is less than 1\n-     * @throws NullPointerException if mapper is null\n-     *\/\n-    public static <T, R> Gatherer<T,?,R> mapConcurrent(\n-            final int maxConcurrency,\n-            final Function<? super T, ? extends R> mapper) {\n-        if (maxConcurrency <= 0)\n-            throw new IllegalArgumentException(\n-                    \"'maxConcurrency' needs to be greater than 0\");\n+        static final <T, A, R, AA, RR> GathererImpl<T, ?, RR> impl(\n+                Gatherer<T, A, R> left, Gatherer<? super R, AA, RR> right) {\n+            final var leftInitializer = left.initializer();\n+            final var leftIntegrator = left.integrator();\n+            final var leftCombiner = left.combiner();\n+            final var leftFinisher = left.finisher();\n@@ -588,1 +549,4 @@\n-        Objects.requireNonNull(mapper, \"'mapper' must not be null\");\n+            final var rightInitializer = right.initializer();\n+            final var rightIntegrator = right.integrator();\n+            final var rightCombiner = right.combiner();\n+            final var rightFinisher = right.finisher();\n@@ -590,3 +554,2 @@\n-        class State {\n-            final ArrayDeque<Future<R>> window = new ArrayDeque<>(maxConcurrency);\n-            final Semaphore windowLock = new Semaphore(maxConcurrency);\n+            final var leftStateless = leftInitializer == Gatherer.defaultInitializer();\n+            final var rightStateless = rightInitializer == Gatherer.defaultInitializer();\n@@ -594,6 +557,2 @@\n-            final boolean integrate(T element,\n-                                    Downstream<? super R> downstream) {\n-                if (!downstream.isRejecting())\n-                    createTaskFor(element);\n-                return flush(0, downstream);\n-            }\n+            final var leftGreedy = leftIntegrator instanceof Integrator.Greedy;\n+            final var rightGreedy = rightIntegrator instanceof Integrator.Greedy;\n@@ -601,2 +560,38 @@\n-            final void createTaskFor(T element) {\n-                windowLock.acquireUninterruptibly();\n+            \/*\n+             * For pairs of stateless and greedy Gatherers, we can optimize\n+             * evaluation as we do not need to track any state nor any\n+             * short-circuit signals. This can provide significant\n+             * performance improvements.\n+             *\/\n+            if (leftStateless && rightStateless && leftGreedy && rightGreedy) {\n+                return new GathererImpl<>(\n+                    Gatherer.defaultInitializer(),\n+                    Gatherer.Integrator.ofGreedy((unused, element, downstream) ->\n+                        leftIntegrator.integrate(\n+                                null,\n+                                element,\n+                                r -> rightIntegrator.integrate(null, r, downstream))\n+                    ),\n+                    (leftCombiner == Gatherer.defaultCombiner()\n+                    || rightCombiner == Gatherer.defaultCombiner())\n+                            ? Gatherer.defaultCombiner()\n+                            : Value.DEFAULT.statelessCombiner\n+                    ,\n+                    (leftFinisher == Gatherer.<A,R>defaultFinisher()\n+                    && rightFinisher == Gatherer.<AA,RR>defaultFinisher())\n+                            ? Gatherer.defaultFinisher()\n+                            : (unused, downstream) -> {\n+                        if (leftFinisher != Gatherer.<A,R>defaultFinisher())\n+                            leftFinisher.accept(\n+                                    null,\n+                                    r -> rightIntegrator.integrate(null, r, downstream));\n+                        if (rightFinisher != Gatherer.<AA,RR>defaultFinisher())\n+                            rightFinisher.accept(null, downstream);\n+                    }\n+                );\n+            } else {\n+                class State {\n+                    final A leftState;\n+                    final AA rightState;\n+                    boolean leftProceed;\n+                    boolean rightProceed;\n@@ -604,5 +599,6 @@\n-                var task = new FutureTask<R>(() -> {\n-                    try {\n-                        return mapper.apply(element);\n-                    } finally {\n-                        windowLock.release();\n+                    private State(A leftState, AA rightState,\n+                                  boolean leftProceed, boolean rightProceed) {\n+                        this.leftState = leftState;\n+                        this.rightState = rightState;\n+                        this.leftProceed = leftProceed;\n+                        this.rightProceed = rightProceed;\n@@ -610,1 +606,0 @@\n-                });\n@@ -612,2 +607,5 @@\n-                var wasAddedToWindow = window.add(task);\n-                assert wasAddedToWindow;\n+                    State() {\n+                        this(leftStateless ? null : leftInitializer.get(),\n+                             rightStateless ? null : rightInitializer.get(),\n+                            true, true);\n+                    }\n@@ -615,2 +613,7 @@\n-                Thread.startVirtualThread(task);\n-            }\n+                    State joinLeft(State right) {\n+                        return new State(\n+                                leftStateless ? null : leftCombiner.apply(this.leftState, right.leftState),\n+                                rightStateless ? null : rightCombiner.apply(this.rightState, right.rightState),\n+                                this.leftProceed && this.rightProceed,\n+                                right.leftProceed && right.rightProceed);\n+                    }\n@@ -618,10 +621,13 @@\n-            final boolean flush(long atLeastN,\n-                                Downstream<? super R> downstream) {\n-                boolean proceed = !downstream.isRejecting();\n-                try {\n-                    Future<R> current;\n-                    while(proceed\n-                          && (current = window.peek()) != null\n-                          && (current.isDone() || atLeastN > 0)) {\n-                        proceed &= downstream.push(current.get());\n-                        atLeastN -= 1;\n+                    boolean integrate(T t, Downstream<? super RR> c) {\n+                        \/*\n+                         * rightProceed must be checked after integration of\n+                         * left since that can cause right to short-circuit\n+                         * We always want to conditionally write leftProceed\n+                         * here, which means that we only do so if we are\n+                         * known to be not-greedy.\n+                         *\/\n+                        return (leftIntegrator.integrate(leftState, t, r -> rightIntegrate(r, c))\n+                                  || leftGreedy\n+                                  || (leftProceed = false))\n+                                && (rightGreedy || rightProceed);\n+                    }\n@@ -629,2 +635,5 @@\n-                        var correctRemoval = window.pop() == current;\n-                        assert correctRemoval;\n+                    void finish(Downstream<? super RR> c) {\n+                        if (leftFinisher != Gatherer.<A, R>defaultFinisher())\n+                            leftFinisher.accept(leftState, r -> rightIntegrate(r, c));\n+                        if (rightFinisher != Gatherer.<AA, RR>defaultFinisher())\n+                            rightFinisher.accept(rightState, c);\n@@ -632,12 +641,24 @@\n-                } catch (Exception e) {\n-                    proceed = false; \/\/ Ensure cleanup\n-                    throw (e instanceof RuntimeException re)\n-                            ? re\n-                            : new RuntimeException(e);\n-                } finally {\n-                    \/\/ Clean up\n-                    if (!proceed) {\n-                        Future<R> next;\n-                        while((next = window.pollFirst()) != null) {\n-                            next.cancel(true);\n-                        }\n+\n+                    \/*\n+                     * Currently we use the following to ferry elements from\n+                     * the left Gatherer to the right Gatherer, but we create\n+                     * the Gatherer.Downstream as a lambda which means that\n+                     * the default implementation of `isKnownDone()` is used.\n+                     *\n+                     * If it is determined that we want to be able to support\n+                     * the full interface of Gatherer.Downstream then we have\n+                     *  the following options:\n+                     *    1. Have State implement Downstream<? super R>\n+                     *       and store the passed in Downstream<? super RR>\n+                     *       downstream as an instance field in integrate()\n+                     *       and read it in push(R r).\n+                     *    2. Allocate a new Gatherer.Downstream<? super R> for\n+                     *       each invocation of integrate() which might prove\n+                     *       costly.\n+                     *\/\n+                    public boolean rightIntegrate(R r, Downstream<? super RR> downstream) {\n+                        \/\/ The following logic is highly performance sensitive\n+                        return (rightGreedy || rightProceed)\n+                                && (rightIntegrator.integrate(rightState, r, downstream)\n+                                || rightGreedy\n+                                || (rightProceed = false));\n@@ -647,1 +668,14 @@\n-                return proceed;\n+                return new GathererImpl<T, State, RR>(\n+                        State::new,\n+                        (leftGreedy && rightGreedy)\n+                                ? Integrator.<State, T, RR>ofGreedy(State::integrate)\n+                                : Integrator.<State, T, RR>of(State::integrate),\n+                        (leftCombiner == Gatherer.defaultCombiner()\n+                        || rightCombiner == Gatherer.defaultCombiner())\n+                                ? Gatherer.defaultCombiner()\n+                                : State::joinLeft,\n+                        (leftFinisher == Gatherer.<A, R>defaultFinisher()\n+                        && rightFinisher == Gatherer.<AA, RR>defaultFinisher())\n+                                ? Gatherer.defaultFinisher()\n+                                : State::finish\n+                );\n@@ -650,6 +684,0 @@\n-\n-        return Gatherer.ofSequential(\n-                    State::new,\n-                    Integrator.<State, T, R>ofGreedy(State::integrate),\n-                    (state, downstream) -> state.flush(Long.MAX_VALUE, downstream)\n-        );\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherers.java","additions":426,"deletions":398,"binary":false,"changes":824,"status":"modified"},{"patch":"@@ -1091,2 +1091,1 @@\n-     *\n-     * @implNote Implementations of this interface should provide their own\n+     * Implementations of this interface should provide their own\n@@ -1095,1 +1094,0 @@\n-     * @see Gatherer\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Stream.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static java.util.stream.DefaultMethodStreams.delegateTo;\n@@ -40,0 +41,2 @@\n+ * @library \/lib\/testlibrary\/bootlib\n+ * @build java.base\/java.util.stream.DefaultMethodStreams\n@@ -45,2 +48,19 @@\n-    final static IntStream streamSizes() {\n-        return IntStream.of(0, 1, 10, 33, 99, 9999);\n+    record Config(int streamSize, boolean parallel, boolean defaultImpl) {\n+\n+        Stream<Integer> countTo(int n) {\n+            return Stream.iterate(1, i -> i + 1).limit(n);\n+        }\n+\n+        Stream<Integer> stream() {\n+            return wrapStream(countTo(streamSize));\n+        }\n+\n+        <R> Stream<R> wrapStream(Stream<R> stream) {\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            stream = defaultImpl ? delegateTo(stream) : stream;\n+            return stream;\n+        }\n+\n+        List<Integer> list() {\n+            return stream().toList();\n+        }\n@@ -49,2 +69,9 @@\n-    final static Stream<Integer> countTo(int to) {\n-        return Stream.iterate(1, i -> i + 1).limit(to);\n+    final static Stream<Config> configurations() {\n+        return Stream.of(0,1,10,33,99,9999)\n+                .flatMap(size ->\n+                        Stream.of(false, true)\n+                                .flatMap(parallel ->\n+                                        Stream.of(false, true).map( defaultImpl ->\n+                                                new Config(size, parallel,\n+                                                        defaultImpl)) )\n+                );\n@@ -64,0 +91,16 @@\n+\n+        void copyFrom(InvocationTracker other) {\n+            initialize = other.initialize;\n+            integrate = other.integrate;\n+            combine = other.combine;\n+            finish = other.finish;\n+        }\n+\n+        void combine(InvocationTracker other) {\n+            if (other != this) {\n+                initialize += other.initialize;\n+                integrate += other.integrate;\n+                combine += other.combine + 1; \/\/ track this merge\n+                finish += other.finish;\n+            }\n+        }\n@@ -75,3 +118,3 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testInvocationSemanticsGreedy(int streamSize) {\n-        var t = new InvocationTracker();\n+    @MethodSource(\"configurations\")\n+    public void testInvocationSemanticsGreedy(Config config) {\n+        var result = new InvocationTracker();\n@@ -80,0 +123,1 @@\n+                    var t = new InvocationTracker();\n@@ -83,2 +127,1 @@\n-                Gatherer.Integrator.<InvocationTracker,Integer,Integer>ofGreedy((state, e, d) -> {\n-                    assertSame(t, state);\n+                Gatherer.Integrator.<InvocationTracker,Integer,Integer>ofGreedy((t, e, d) -> {\n@@ -89,2 +132,1 @@\n-                    if (t1 != t2) t2.combine++;\n-                    t1.combine++;\n+                    t1.combine(t2);\n@@ -93,2 +135,1 @@\n-                (state, d) -> {\n-                    assertSame(t, state);\n+                (t, d) -> {\n@@ -96,0 +137,1 @@\n+                    result.copyFrom(t);\n@@ -97,6 +139,13 @@\n-        var res = countTo(streamSize).gather(g).toList();\n-        assertEquals(countTo(streamSize).toList(), res);\n-        assertEquals(1, t.initialize);\n-        assertEquals(streamSize, t.integrate);\n-        assertEquals(0, t.combine);\n-        assertEquals(1, t.finish);\n+        var res = config.stream().gather(g).toList();\n+        assertEquals(config.countTo(config.streamSize).toList(), res);\n+        if (config.parallel) {\n+            assertTrue(result.initialize > 0);\n+            assertEquals(config.streamSize, result.integrate);\n+            assertTrue(config.streamSize < 2 || result.combine > 0);\n+            assertEquals(1, result.finish);\n+        } else {\n+            assertEquals(1, result.initialize);\n+            assertEquals(config.streamSize, result.integrate);\n+            assertEquals(0, result.combine);\n+            assertEquals(1, result.finish);\n+        }\n@@ -106,4 +155,4 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testInvocationSemanticsShortCircuit(int streamSize) {\n-        final int CONSUME_AT_MOST = 5;\n-        var t = new InvocationTracker();\n+    @MethodSource(\"configurations\")\n+    public void testInvocationSemanticsShortCircuit(Config config) {\n+        final int CONSUME_UNTIL = Math.min(config.streamSize, 5);\n+        var result = new InvocationTracker();\n@@ -112,0 +161,1 @@\n+                    var t = new InvocationTracker();\n@@ -115,4 +165,3 @@\n-                (state, e, d) -> {\n-                    assertSame(t, state);\n-                    t.integrate++;\n-                    return d.push(e) && t.integrate < CONSUME_AT_MOST;\n+                (t, e, d) -> {\n+                    ++t.integrate;\n+                    return e <= CONSUME_UNTIL && d.push(e) && e != CONSUME_UNTIL;\n@@ -121,2 +170,1 @@\n-                    if (t1 != t2) t2.combine++;\n-                    t1.combine++;\n+                    t1.combine(t2);\n@@ -125,2 +173,1 @@\n-                (state, d) -> {\n-                    assertSame(t, state);\n+                (t, d) -> {\n@@ -128,0 +175,1 @@\n+                    result.copyFrom(t);\n@@ -129,6 +177,13 @@\n-        var res = countTo(streamSize).gather(g).toList();\n-        assertEquals(countTo(Math.min(streamSize, CONSUME_AT_MOST)).toList(), res);\n-        assertEquals(t.initialize, 1);\n-        assertEquals(t.integrate, Math.min(streamSize, CONSUME_AT_MOST));\n-        assertEquals(t.combine, 0);\n-        assertEquals(t.finish, 1);\n+        var res = config.stream().gather(g).toList();\n+        assertEquals(config.countTo(CONSUME_UNTIL).toList(), res);\n+        if (config.parallel) {\n+            assertTrue(result.initialize > 0);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertTrue(result.combine >= 0); \/\/ We can't guarantee split sizes\n+            assertEquals(1, result.finish);\n+        } else {\n+            assertEquals(1, result.initialize);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertEquals(0, result.combine);\n+            assertEquals(1, result.finish);\n+        }\n@@ -138,2 +193,2 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testEmissionDuringFinisher(int streamSize) {\n+    @MethodSource(\"configurations\")\n+    public void testEmissionDuringFinisher(Config config) {\n@@ -151,1 +206,1 @@\n-                    t1.combine++;\n+                    t1.combine(t2);\n@@ -158,1 +213,1 @@\n-        var resultList = countTo(streamSize).gather(g).collect(Collectors.toList());\n+        var resultList = config.stream().gather(g).collect(Collectors.toList());\n@@ -163,4 +218,11 @@\n-        assertEquals(t.initialize, 1);\n-        assertEquals(t.integrate, streamSize);\n-        assertEquals(t.combine, 0);\n-        assertEquals(t.finish, 1);\n+        if (config.parallel) {\n+            assertTrue(t.initialize > 0);\n+            assertEquals(config.streamSize, t.integrate);\n+            assertTrue(config.streamSize < 2 || t.combine > 0);\n+            assertEquals(1, t.finish);\n+        } else {\n+            assertEquals(1, t.initialize);\n+            assertEquals(config.streamSize, t.integrate);\n+            assertEquals(0, t.combine);\n+            assertEquals(1, t.finish);\n+        }\n@@ -170,5 +232,4 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testInvocationSemanticsShortCircuitParallel(int streamSize) {\n-        \/\/ short-circuit half-way into the sequence\n-        final Predicate<Integer> takeWhile = j -> j < (streamSize \/ 2);\n-\n+    @MethodSource(\"configurations\")\n+    public void testInvocationSemanticsShortCircuitDuringCollect(Config config) {\n+        final int CONSUME_UNTIL = Math.min(config.streamSize, 5);\n+        var result = new InvocationTracker();\n@@ -183,1 +244,1 @@\n-                    return takeWhile.test(e) && d.push(e);\n+                    return e <= CONSUME_UNTIL && d.push(e) && e != CONSUME_UNTIL;\n@@ -186,4 +247,1 @@\n-                    t1.initialize += t2.initialize;\n-                    t1.integrate += t2.integrate;\n-                    t1.combine += t2.combine + 1; \/\/ include this combination\n-                    t1.finish += t2.finish;\n+                    t1.combine(t2);\n@@ -193,32 +251,0 @@\n-                    assertTrue(t.initialize > 0);\n-                    assertTrue(t.integrate <= streamSize);\n-                    assertEquals(t.combine + 1,t.initialize);\n-                    assertEquals(++t.finish, 1);\n-                });\n-\n-        var res = countTo(streamSize).parallel().gather(g).toList();\n-        assertEquals(countTo(streamSize).takeWhile(takeWhile).toList(), res);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"streamSizes\")\n-    public void testInvocationSemanticsShortCircuitDuringCollect(int streamSize) {\n-        final int CONSUME_AT_MOST = 5;\n-        var t = new InvocationTracker();\n-        var g = Gatherer.<Integer, InvocationTracker, Integer>of(\n-                () -> {\n-                    t.initialize++;\n-                    return t;\n-                },\n-                (state, e, d) -> {\n-                    assertSame(t, state);\n-                    t.integrate++;\n-                    return d.push(e) && t.integrate < CONSUME_AT_MOST;\n-                },\n-                (t1, t2) -> {\n-                    if (t1 != t2) t2.combine++;\n-                    t1.combine++;\n-                    return t1;\n-                },\n-                (state, d) -> {\n-                    assertSame(t, state);\n@@ -226,0 +252,1 @@\n+                    result.copyFrom(t);\n@@ -227,6 +254,13 @@\n-        var res = countTo(streamSize).gather(g).collect(Collectors.toList());\n-        assertEquals(countTo(Math.min(streamSize, CONSUME_AT_MOST)).toList(), res);\n-        assertEquals(t.initialize, 1);\n-        assertEquals(t.integrate, Math.min(streamSize, CONSUME_AT_MOST));\n-        assertEquals(t.combine, 0);\n-        assertEquals(t.finish, 1);\n+        var res = config.stream().gather(g).collect(Collectors.toList());\n+        assertEquals(config.countTo(CONSUME_UNTIL).toList(), res);\n+        if (config.parallel) {\n+            assertTrue(result.initialize > 0);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertTrue(result.combine >= 0); \/\/ We can't guarantee split sizes\n+            assertEquals(result.finish, 1);\n+        } else {\n+            assertEquals(result.initialize, 1);\n+            assertEquals(CONSUME_UNTIL, result.integrate);\n+            assertEquals(result.combine, 0);\n+            assertEquals(result.finish, 1);\n+        }\n@@ -236,3 +270,3 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testCompositionOfStatelessGatherers(int streamSize) {\n-        var range = countTo(streamSize).toList();\n+    @MethodSource(\"configurations\")\n+    public void testCompositionOfStatelessGatherers(Config config) {\n+        var range = config.stream().toList();\n@@ -241,2 +275,2 @@\n-        assertEquals(gRes.size(), streamSize);\n-        assertEquals(rRes.size(), streamSize);\n+        assertEquals(config.streamSize, gRes.size());\n+        assertEquals(config.streamSize, rRes.size());\n@@ -247,2 +281,2 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testCompositionOfStatefulGatherers(int streamSize) {\n+    @MethodSource(\"configurations\")\n+    public void testCompositionOfStatefulGatherers(Config config) {\n@@ -252,2 +286,3 @@\n-                    t1.initialize++;\n-                    return t1;\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n@@ -255,3 +290,2 @@\n-                (state, e, d) -> {\n-                    assertSame(t1, state);\n-                    t1.integrate++;\n+                (t, e, d) -> {\n+                    t.integrate++;\n@@ -261,2 +295,1 @@\n-                    if (l != r) r.combine++;\n-                    l.combine++;\n+                    l.combine(r);\n@@ -265,3 +298,3 @@\n-                (state, d) -> {\n-                    assertSame(t1, state);\n-                    t1.finish++;\n+                (t, d) -> {\n+                    t.finish++;\n+                    t1.copyFrom(t);\n@@ -273,2 +306,3 @@\n-                    t2.initialize++;\n-                    return t2;\n+                    var t = new InvocationTracker();\n+                    t.initialize++;\n+                    return t;\n@@ -276,3 +310,2 @@\n-                (state, e, d) -> {\n-                    assertSame(t2, state);\n-                    t2.integrate++;\n+                (t, e, d) -> {\n+                    t.integrate++;\n@@ -282,2 +315,1 @@\n-                    if (l != r) r.combine++;\n-                    l.combine++;\n+                    l.combine(r);\n@@ -286,3 +318,3 @@\n-                (state, d) -> {\n-                    assertSame(t2, state);\n-                    t2.finish++;\n+                (t, d) -> {\n+                    t.finish++;\n+                    t2.copyFrom(t);\n@@ -291,12 +323,24 @@\n-        var res = countTo(streamSize).gather(g1.andThen(g2)).toList();\n-        assertEquals(countTo(streamSize).toList(), res);\n-\n-        assertEquals(t1.initialize, 1);\n-        assertEquals(t1.integrate, streamSize);\n-        assertEquals(t1.combine, 0);\n-        assertEquals(t1.finish, 1);\n-\n-        assertEquals(t2.initialize, 1);\n-        assertEquals(t2.integrate, streamSize);\n-        assertEquals(t2.combine, 0);\n-        assertEquals(t2.finish, 1);\n+        var res = config.stream().gather(g1.andThen(g2)).toList();\n+        assertEquals(config.stream().toList(), res);\n+\n+        if (config.parallel) {\n+            assertTrue(t1.initialize > 0);\n+            assertEquals(config.streamSize, t1.integrate);\n+            assertTrue(config.streamSize < 2 || t1.combine > 0);\n+            assertEquals(1, t1.finish);\n+\n+            assertTrue(t2.initialize > 0);\n+            assertEquals(config.streamSize, t2.integrate);\n+            assertTrue(config.streamSize < 2 || t2.combine > 0);\n+            assertEquals(1, t2.finish);\n+        } else {\n+            assertEquals(1, t1.initialize);\n+            assertEquals(config.streamSize, t1.integrate);\n+            assertEquals(0, t1.combine);\n+            assertEquals(1, t1.finish);\n+\n+            assertEquals(1, t2.initialize);\n+            assertEquals(config.streamSize, t2.integrate);\n+            assertEquals(0, t2.combine);\n+            assertEquals(1, t2.finish);\n+        }\n@@ -306,2 +350,2 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testMassivelyComposedGatherers(int streamSize) {\n+    @MethodSource(\"configurations\")\n+    public void testMassivelyComposedGatherers(Config config) {\n@@ -316,2 +360,2 @@\n-        var ref = countTo(streamSize).map(n -> n + 1);\n-        for(int c = 0;c < ITERATIONS;++c) {\n+        var ref = config.stream().map(n -> n + 1);\n+        for(int c = 0; c < ITERATIONS; ++c) {\n@@ -322,1 +366,1 @@\n-        var gatherered = countTo(streamSize).gather(g).toList();\n+        var gatherered = config.stream().gather(g).toList();\n@@ -340,6 +384,5 @@\n-    @MethodSource(\"streamSizes\")\n-    public void testCompositionSymmetry(int streamSize) {\n-            var range = countTo(streamSize).toList();\n-            var consecutiveResult = range.stream().gather(addOne).gather(timesTwo).toList();\n-            var interspersedResult = range.stream().gather(addOne).map(id -> id).gather(timesTwo).toList();\n-            var composedResult = range.stream().gather(addOne.andThen(timesTwo)).toList();\n+    @MethodSource(\"configurations\")\n+    public void testCompositionSymmetry(Config config) {\n+            var consecutiveResult = config.stream().gather(addOne).gather(timesTwo).toList();\n+            var interspersedResult = config.stream().gather(addOne).map(id -> id).gather(timesTwo).toList();\n+            var composedResult = config.stream().gather(addOne.andThen(timesTwo)).toList();\n@@ -347,1 +390,1 @@\n-            var reference = range.stream().map(j -> j + 1).map(j -> j * 2).toList();\n+            var reference = config.stream().map(j -> j + 1).map(j -> j * 2).toList();\n@@ -349,4 +392,4 @@\n-            assertEquals(consecutiveResult.size(), streamSize);\n-            assertEquals(interspersedResult.size(), streamSize);\n-            assertEquals(composedResult.size(), streamSize);\n-            assertEquals(reference.size(), streamSize);\n+            assertEquals(config.streamSize, consecutiveResult.size());\n+            assertEquals(config.streamSize, interspersedResult.size());\n+            assertEquals(config.streamSize, composedResult.size());\n+            assertEquals(config.streamSize, reference.size());\n@@ -359,2 +402,3 @@\n-    @Test\n-    public void testExceptionInInitializer() {\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInInitializer(Config config) {\n@@ -363,1 +407,1 @@\n-            Stream.of(1).gather(\n+            config.stream().gather(\n@@ -373,2 +417,5 @@\n-    @Test\n-    public void testExceptionInIntegrator() {\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInIntegrator(Config config) {\n+        if (config.streamSize < 1) return; \/\/ No exceptions expected\n+\n@@ -377,1 +424,1 @@\n-            Stream.of(1).gather(\n+            config.stream().gather(\n@@ -388,2 +435,5 @@\n-    @Test\n-    public void testExceptionInCombiner() {\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInCombiner(Config config) {\n+        if (config.streamSize < 2 || !config.parallel) return; \/\/ No exceptions expected\n+\n@@ -392,1 +442,1 @@\n-            Stream.of(1,2).parallel().gather(\n+            config.stream().gather(\n@@ -403,2 +453,3 @@\n-    @Test\n-    public void testExceptionInFinisher() {\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testExceptionInFinisher(Config config) {\n@@ -407,1 +458,1 @@\n-            Stream.of(1).gather(\n+            config.stream().gather(\n","filename":"test\/jdk\/java\/util\/stream\/GathererTest.java","additions":211,"deletions":160,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-            var stream = Stream.iterate(1, i -> i + 1).limit(streamSize);\n-            return parallel ? stream.parallel() : stream.sequential();\n+            return wrapStream(Stream.iterate(1, i -> i + 1).limit(streamSize));\n@@ -56,2 +55,3 @@\n-        List<Integer> list() {\n-            return stream().toList();\n+        <R> Stream<R> wrapStream(Stream<R> stream) {\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n@@ -65,1 +65,2 @@\n-                                   .map(parallel -> new Config(size, parallel))\n+                                   .map(parallel ->\n+                                               new Config(size, parallel))\n@@ -91,1 +92,1 @@\n-                assertEquals(result.get(0), config.list());\n+                assertEquals(config.stream().toList(), result.get(0));\n@@ -147,1 +148,1 @@\n-                assertEquals(config.list(), result.get(0));\n+                assertEquals(config.stream().toList(), result.get(0));\n@@ -157,1 +158,1 @@\n-                        Stream.of(null, null, null)\n+                        config.wrapStream(Stream.of(null, null, null))\n","filename":"test\/jdk\/java\/util\/stream\/GatherersTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"}]}