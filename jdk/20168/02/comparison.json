{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -254,0 +255,30 @@\n+    \/\/ Digit values for codePoints in the 0-255 range. Contents generated using:\n+    \/\/ for (char i = 0; i < 256; i++) {\n+    \/\/     int v = -1;\n+    \/\/     if (i >= '0' && i <= '9') { v = i - '0'; }\n+    \/\/     if (i % 20 == 0) System.out.println();\n+    \/\/     System.out.printf(\"%2d, \", v);\n+    \/\/ }\n+    \/\/\n+    \/\/ Analysis has shown that generating the whole array allows the JIT to generate\n+    \/\/ better code compared to a slimmed down array, such as one cutting off after '9'\n+    @Stable\n+    private static final byte[] DECIMAL_DIGITS = new byte[] {\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };\n+\n+    static int digit(byte ch) {\n+        return DECIMAL_DIGITS[ch & 0xFF];\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterDataLatin1.java.template","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -550,1 +550,1 @@\n-            throw new NumberFormatException(\"Cannot parse null string\");\n+            throw NumberFormatException.forNull();\n@@ -553,3 +553,2 @@\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        if (radix != 10 || !s.isLatin1()) {\n+            return parseInt(s, 0, s.length(), radix);\n@@ -558,6 +557,2 @@\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n-        }\n-\n-        int len = s.length();\n+        byte[] value = s.value();\n+        int len = value.length;\n@@ -569,1 +564,1 @@\n-        char firstChar = s.charAt(i++);\n+        byte firstChar = value[i++];\n@@ -571,1 +566,1 @@\n-            digit = digit(firstChar, radix);\n+            digit = CharacterDataLatin1.digit(firstChar);\n@@ -575,1 +570,1 @@\n-            int multmin = limit \/ radix;\n+            int multmin = -214748364; \/\/ actual limit \/ 10;\n@@ -579,1 +574,1 @@\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n+            while (i < len && (digit = CharacterDataLatin1.digit(value[i++])) >= 0\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -580,1 +580,1 @@\n-            throw new NumberFormatException(\"Cannot parse null string\");\n+            throw NumberFormatException.forNull();\n@@ -583,3 +583,2 @@\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        if (radix != 10 || !s.isLatin1()) {\n+            return parseLong(s, 0, s.length(), radix);\n@@ -588,6 +587,2 @@\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n-        }\n-\n-        int len = s.length();\n+        byte[] value = s.value();\n+        int len = value.length;\n@@ -599,1 +594,1 @@\n-        char firstChar = s.charAt(i++);\n+        byte firstChar = value[i++];\n@@ -601,1 +596,1 @@\n-            digit = digit(firstChar, radix);\n+            digit = CharacterDataLatin1.digit(firstChar);\n@@ -605,1 +600,1 @@\n-            long multmin = limit \/ radix;\n+            long multmin = -922337203685477580L; \/\/ actual limit \/ 10\n@@ -609,1 +604,1 @@\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n+            while (i < len && (digit = CharacterDataLatin1.digit(value[i++])) >= 0\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,4 @@\n+\n+    static NumberFormatException forNull() {\n+        return new NumberFormatException(\"Cannot parse null string\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/NumberFormatException.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,7 @@\n+    @Benchmark\n+    public void parseLong(Blackhole bh) {\n+        for (String s : strings) {\n+            bh.consume(Long.parseLong(s));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}