{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -254,0 +255,20 @@\n+    @Stable\n+    private static final byte[] DECIMAL_DIGITS = new byte[] {\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };\n+\n+    static int digit(byte ch) {\n+        return DECIMAL_DIGITS[ch & 0xFF];\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterDataLatin1.java.template","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -550,1 +550,1 @@\n-            throw new NumberFormatException(\"Cannot parse null string\");\n+            throw NumberFormatException.forNull();\n@@ -553,3 +553,2 @@\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        if (radix != 10 || !s.isLatin1()) {\n+            return parseInt(s, 0, s.length(), radix);\n@@ -558,25 +557,8 @@\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n-        }\n-\n-        int len = s.length();\n-        if (len == 0) {\n-            throw NumberFormatException.forInputString(\"\", radix);\n-        }\n-        int digit = ~0xFF;\n-        int i = 0;\n-        char firstChar = s.charAt(i++);\n-        if (firstChar != '-' && firstChar != '+') {\n-            digit = digit(firstChar, radix);\n-        }\n-        if (digit >= 0 || digit == ~0xFF && len > 1) {\n-            int limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n-            int multmin = limit \/ radix;\n-            int result = -(digit & 0xFF);\n-            boolean inRange = true;\n-            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n-                    && (inRange = result > multmin\n-                        || result == multmin && digit <= radix * multmin - limit)) {\n-                result = radix * result - digit;\n+        byte[] value = s.value();\n+        int len = value.length;\n+        if (len != 0) {\n+            int digit = ~0xFF;\n+            int i = 0;\n+            byte firstChar = value[i++];\n+            if (firstChar != '-' && firstChar != '+') {\n+                digit = CharacterDataLatin1.digit(firstChar);\n@@ -584,2 +566,14 @@\n-            if (inRange && i == len && digit >= 0) {\n-                return firstChar != '-' ? -result : result;\n+            if (digit >= 0 || digit == ~0xFF && len > 1) {\n+                int limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n+                int multmin = -214748364; \/\/ actual limit \/ 10;\n+                int result = -(digit & 0xFF);\n+                boolean inRange = true;\n+                \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+                while (i < len && (digit = CharacterDataLatin1.digit(value[i++])) >= 0\n+                        && (inRange = result > multmin\n+                            || result == multmin && digit <= 10 * multmin - limit)) {\n+                    result = 10 * result - digit;\n+                }\n+                if (inRange && i == len && digit >= 0) {\n+                    return firstChar != '-' ? -result : result;\n+                }\n@@ -588,1 +582,1 @@\n-        throw NumberFormatException.forInputString(s, radix);\n+        throw NumberFormatException.forInputString(s, 10);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":27,"deletions":33,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -580,1 +580,1 @@\n-            throw new NumberFormatException(\"Cannot parse null string\");\n+            throw NumberFormatException.forNull();\n@@ -583,3 +583,2 @@\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        if (radix != 10 || !s.isLatin1()) {\n+            return parseLong(s, 0, s.length(), radix);\n@@ -588,25 +587,8 @@\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n-        }\n-\n-        int len = s.length();\n-        if (len == 0) {\n-            throw NumberFormatException.forInputString(\"\", radix);\n-        }\n-        int digit = ~0xFF;\n-        int i = 0;\n-        char firstChar = s.charAt(i++);\n-        if (firstChar != '-' && firstChar != '+') {\n-            digit = digit(firstChar, radix);\n-        }\n-        if (digit >= 0 || digit == ~0xFF && len > 1) {\n-            long limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n-            long multmin = limit \/ radix;\n-            long result = -(digit & 0xFF);\n-            boolean inRange = true;\n-            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n-                    && (inRange = result > multmin\n-                        || result == multmin && digit <= (int) (radix * multmin - limit))) {\n-                result = radix * result - digit;\n+        byte[] value = s.value();\n+        int len = value.length;\n+        if (len != 0) {\n+            int digit = ~0xFF;\n+            int i = 0;\n+            byte firstChar = value[i++];\n+            if (firstChar != '-' && firstChar != '+') {\n+                digit = CharacterDataLatin1.digit(firstChar);\n@@ -614,2 +596,14 @@\n-            if (inRange && i == len && digit >= 0) {\n-                return firstChar != '-' ? -result : result;\n+            if (digit >= 0 || digit == ~0xFF && len > 1) {\n+                long limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n+                long multmin = -922337203685477580L; \/\/ actual limit \/ 10\n+                long result = -(digit & 0xFF);\n+                boolean inRange = true;\n+                \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+                while (i < len && (digit = CharacterDataLatin1.digit(value[i++])) >= 0\n+                        && (inRange = result > multmin\n+                            || result == multmin && digit <= (int) (10 * multmin - limit))) {\n+                    result = 10 * result - digit;\n+                }\n+                if (inRange && i == len && digit >= 0) {\n+                    return firstChar != '-' ? -result : result;\n+                }\n@@ -618,1 +612,1 @@\n-        throw NumberFormatException.forInputString(s, radix);\n+        throw NumberFormatException.forInputString(s, 10);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":27,"deletions":33,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,4 @@\n+\n+    static NumberFormatException forNull() {\n+        return new NumberFormatException(\"Cannot parse null string\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/NumberFormatException.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Integers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,7 @@\n+    @Benchmark\n+    public void parseLong(Blackhole bh) {\n+        for (String s : strings) {\n+            bh.consume(Long.parseLong(s));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}