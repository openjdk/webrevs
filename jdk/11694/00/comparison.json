{"files":[{"patch":"@@ -28,0 +28,2 @@\n+JAVAC_FLAGS += --enable-preview\n+DISABLED_WARNINGS_java += preview\n","filename":"make\/modules\/jdk.jartool\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+        jdk.jartool, \/\/ participates in preview features\n@@ -194,1 +195,0 @@\n-        jdk.jartool,\n@@ -382,0 +382,6 @@\n+    exports jdk.internal.classfile to\n+        jdk.jartool;\n+    exports jdk.internal.classfile.attribute to\n+        jdk.jartool;\n+    exports jdk.internal.classfile.constantpool to\n+        jdk.jartool;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import jdk.internal.javac.ParticipatesInPreview;\n+\n@@ -50,0 +52,1 @@\n+@ParticipatesInPreview\n","filename":"src\/jdk.jartool\/share\/classes\/module-info.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n-\n@@ -31,1 +29,1 @@\n-import java.io.InputStream;\n+import java.lang.reflect.AccessFlag;\n@@ -34,1 +32,0 @@\n-import java.util.HashMap;\n@@ -36,1 +33,0 @@\n-import java.util.Map;\n@@ -38,0 +34,10 @@\n+import java.util.function.Consumer;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n@@ -94,1 +100,1 @@\n-        return attrs.nestedClass;\n+        return attrs.maybeNestedClass && attrs.outerClassName != null;\n@@ -162,4 +168,8 @@\n-    private ClassAttributes getClassAttributes(byte[] bytes) {\n-        ClassReader rdr = new ClassReader(bytes);\n-        ClassAttributes attrs = new ClassAttributes();\n-        rdr.accept(attrs, 0);\n+    private static ClassAttributes getClassAttributes(byte[] bytes) {\n+        var cm = Classfile.parse(bytes);\n+        ClassAttributes attrs = new ClassAttributes(\n+                cm.flags(),\n+                cm.thisClass().asInternalName(),\n+                cm.superclass().map(ClassEntry::asInternalName).orElse(null),\n+                cm.majorVersion());\n+        cm.forEachElement(attrs);\n@@ -235,2 +245,2 @@\n-    private static final class ClassAttributes extends ClassVisitor {\n-        private String name;\n+    private static final class ClassAttributes implements Consumer<ClassElement> {\n+        private final String name;\n@@ -238,5 +248,5 @@\n-        private String superName;\n-        private int majorVersion;\n-        private int access;\n-        private boolean publicClass;\n-        private boolean nestedClass;\n+        private final String superName;\n+        private final int majorVersion;\n+        private final int access;\n+        private final boolean publicClass;\n+        private boolean maybeNestedClass;\n@@ -246,14 +256,3 @@\n-        public ClassAttributes() {\n-            super(Opcodes.ASM9);\n-        }\n-\n-        private boolean isPublic(int access) {\n-            return ((access & Opcodes.ACC_PUBLIC) == Opcodes.ACC_PUBLIC)\n-                    || ((access & Opcodes.ACC_PROTECTED) == Opcodes.ACC_PROTECTED);\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature,\n-                          String superName, String[] interfaces) {\n-            this.majorVersion = version & 0xFFFF; \/\/ JDK-8296329: extract major version only\n-            this.access = access;\n+        public ClassAttributes(AccessFlags access, String name, String superName, int majorVersion) {\n+            this.majorVersion = majorVersion; \/\/ JDK-8296329: extract major version only\n+            this.access = access.flagsMask();\n@@ -261,1 +260,1 @@\n-            this.nestedClass = name.contains(\"$\");\n+            this.maybeNestedClass = name.contains(\"$\");\n@@ -267,31 +266,9 @@\n-        public void visitOuterClass(String owner, String name, String desc) {\n-            if (!this.nestedClass) return;\n-            this.outerClassName = owner;\n-        }\n-\n-        @Override\n-        public void visitInnerClass(String name, String outerName, String innerName,\n-                                    int access) {\n-            if (!this.nestedClass) return;\n-            if (outerName == null) return;\n-            if (!this.name.equals(name)) return;\n-            if (this.outerClassName == null) this.outerClassName = outerName;\n-        }\n-\n-        @Override\n-        public FieldVisitor visitField(int access, String name, String desc,\n-                                       String signature, Object value) {\n-            if (isPublic(access)) {\n-                fields.add(new Field(access, name, desc));\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String desc,\n-                                         String signature, String[] exceptions) {\n-            if (isPublic(access)) {\n-                Set<String> exceptionSet = new HashSet<>();\n-                if (exceptions != null) {\n-                    for (String e : exceptions) {\n-                        exceptionSet.add(e);\n+        public void accept(ClassElement cle) {\n+            switch (cle) {\n+                case InnerClassesAttribute ica -> {\n+                    for (var icm : ica.classes()) {\n+                        if (this.maybeNestedClass && icm.outerClass().isPresent()\n+                                && this.name.equals(icm.innerClass().asInternalName())\n+                                && this.outerClassName == null) {\n+                            this.outerClassName = icm.outerClass().get().asInternalName();\n+                        }\n@@ -300,6 +277,23 @@\n-                \/\/ treat type descriptor as a proxy for signature because signature\n-                \/\/ is usually null, need to strip off the return type though\n-                int n;\n-                if (desc != null && (n = desc.lastIndexOf(')')) != -1) {\n-                    desc = desc.substring(0, n + 1);\n-                    methods.add(new Method(access, name, desc, exceptionSet));\n+                case FieldModel fm -> {\n+                    if (isPublic(fm.flags())) {\n+                        fields.add(new Field(fm.flags().flagsMask(),\n+                                             fm.fieldName().stringValue(),\n+                                             fm.fieldType().stringValue()));\n+                    }\n+                }\n+                case MethodModel mm -> {\n+                    if (isPublic(mm.flags())) {\n+                        Set<String> exceptionSet = new HashSet<>();\n+                        mm.findAttribute(Attributes.EXCEPTIONS).ifPresent(ea ->\n+                                ea.exceptions().forEach(e ->\n+                                        exceptionSet.add(e.asInternalName())));\n+                        \/\/ treat type descriptor as a proxy for signature because signature\n+                        \/\/ is usually null, need to strip off the return type though\n+                        int n;\n+                        var desc = mm.methodType().stringValue();\n+                        if (desc != null && (n = desc.lastIndexOf(')')) != -1) {\n+                            desc = desc.substring(0, n + 1);\n+                            methods.add(new Method(mm.flags().flagsMask(),\n+                                    mm.methodName().stringValue(), desc, exceptionSet));\n+                        }\n+                    }\n@@ -307,0 +301,6 @@\n+                case EnclosingMethodAttribute ema -> {\n+                    if (this.maybeNestedClass) {\n+                        this.outerClassName = ema.enclosingClass().asInternalName();\n+                    }\n+                }\n+                default -> {}\n@@ -308,1 +308,0 @@\n-            return null;\n@@ -311,3 +310,2 @@\n-        @Override\n-        public void visitEnd() {\n-            this.nestedClass = this.outerClassName != null;\n+        private static boolean isPublic(AccessFlags access) {\n+            return access.has(AccessFlag.PUBLIC) || access.has(AccessFlag.PROTECTED);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/FingerPrint.java","additions":71,"deletions":73,"binary":false,"changes":144,"status":"modified"}]}