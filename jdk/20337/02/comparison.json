{"files":[{"patch":"@@ -520,0 +520,23 @@\n+    \/**\n+     * Specialization of format. This method really calls\n+     * {@link #format(double, StringBuilder, FieldPosition)}.\n+     * Thus, the range of longs that are supported is only equal to\n+     * the range that can be stored by double. This will never be\n+     * a practical limitation.\n+     *\n+     * @param number number to be formatted and substituted.\n+     * @param toAppendTo where text is appended.\n+     * @param status ignore no useful status is returned.\n+     * @throws    ArrayIndexOutOfBoundsException if either the {@code limits}\n+     *            or {@code formats} of this ChoiceFormat are empty\n+     * @throws    NullPointerException if {@code toAppendTo}\n+     *            is {@code null}\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(long number,\n+                                StringBuilder toAppendTo,\n+                                FieldPosition status) {\n+        return format(number, StringBufFactory.of(toAppendTo), status).asStringBuilder();\n+    }\n+\n@@ -543,0 +566,19 @@\n+    \/**\n+     * Returns pattern with formatted double.\n+     *\n+     * @param number number to be formatted and substituted.\n+     * @param toAppendTo where text is appended.\n+     * @param status ignore no useful status is returned.\n+     * @throws    ArrayIndexOutOfBoundsException if either the {@code limits}\n+     *            or {@code formats} of this ChoiceFormat are empty\n+     * @throws    NullPointerException if {@code toAppendTo}\n+     *            is {@code null}\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(double number,\n+                                StringBuilder toAppendTo,\n+                                FieldPosition status) {\n+        return format(number, StringBufFactory.of(toAppendTo), status).asStringBuilder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -559,0 +559,35 @@\n+    \/**\n+     * Formats a number to produce a string representing its compact form.\n+     * The number can be of any subclass of {@link java.lang.Number}.\n+     * @param number     the number to format\n+     * @param toAppendTo the {@code StringBuilder} to which the formatted\n+     *                   text is to be appended\n+     * @param fieldPosition    keeps track on the position of the field within\n+     *                         the returned string. For example, for formatting\n+     *                         a number {@code 123456789} in the\n+     *                         {@link java.util.Locale#US US locale},\n+     *                         if the given {@code fieldPosition} is\n+     *                         {@link NumberFormat#INTEGER_FIELD}, the begin\n+     *                         index and end index of {@code fieldPosition}\n+     *                         will be set to 0 and 3, respectively for the\n+     *                         output string {@code 123M}. Similarly, positions\n+     *                         of the prefix and the suffix fields can be\n+     *                         obtained using {@link NumberFormat.Field#PREFIX}\n+     *                         and {@link NumberFormat.Field#SUFFIX} respectively.\n+     * @return           the {@code StringBuilder} passed in as {@code toAppendTo}\n+     * @throws           IllegalArgumentException if {@code number} is\n+     *                   {@code null} or not an instance of {@code Number}\n+     * @throws           NullPointerException if {@code toAppendTo} or\n+     *                   {@code fieldPosition} is {@code null}\n+     * @throws           ArithmeticException if rounding is needed with rounding\n+     *                   mode being set to {@code RoundingMode.UNNECESSARY}\n+     * @see              FieldPosition\n+     * @since 24\n+     *\/\n+    @Override\n+    public final StringBuilder format(Object number,\n+                                     StringBuilder toAppendTo,\n+                                     FieldPosition fieldPosition) {\n+        return format(number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuilder();\n+    }\n+\n@@ -612,0 +647,31 @@\n+    \/**\n+     * Formats a double to produce a string representing its compact form.\n+     * @param number    the double number to format\n+     * @param result    where the text is to be appended\n+     * @param fieldPosition    keeps track on the position of the field within\n+     *                         the returned string. For example, to format\n+     *                         a number {@code 1234567.89} in the\n+     *                         {@link java.util.Locale#US US locale}\n+     *                         if the given {@code fieldPosition} is\n+     *                         {@link NumberFormat#INTEGER_FIELD}, the begin\n+     *                         index and end index of {@code fieldPosition}\n+     *                         will be set to 0 and 1, respectively for the\n+     *                         output string {@code 1M}. Similarly, positions\n+     *                         of the prefix and the suffix fields can be\n+     *                         obtained using {@link NumberFormat.Field#PREFIX}\n+     *                         and {@link NumberFormat.Field#SUFFIX} respectively.\n+     * @return    the {@code StringBuilder} passed in as {@code result}\n+     * @throws NullPointerException if {@code result} or\n+     *            {@code fieldPosition} is {@code null}\n+     * @throws ArithmeticException if rounding is needed with rounding\n+     *            mode being set to {@code RoundingMode.UNNECESSARY}\n+     * @see FieldPosition\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(double number, StringBuilder result,\n+                               FieldPosition fieldPosition) {\n+\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuilder();\n+    }\n+\n@@ -711,0 +777,31 @@\n+    \/**\n+     * Formats a long to produce a string representing its compact form.\n+     * @param number    the long number to format\n+     * @param result    where the text is to be appended\n+     * @param fieldPosition    keeps track on the position of the field within\n+     *                         the returned string. For example, to format\n+     *                         a number {@code 123456789} in the\n+     *                         {@link java.util.Locale#US US locale},\n+     *                         if the given {@code fieldPosition} is\n+     *                         {@link NumberFormat#INTEGER_FIELD}, the begin\n+     *                         index and end index of {@code fieldPosition}\n+     *                         will be set to 0 and 3, respectively for the\n+     *                         output string {@code 123M}. Similarly, positions\n+     *                         of the prefix and the suffix fields can be\n+     *                         obtained using {@link NumberFormat.Field#PREFIX}\n+     *                         and {@link NumberFormat.Field#SUFFIX} respectively.\n+     * @return       the {@code StringBuilder} passed in as {@code result}\n+     * @throws       NullPointerException if {@code result} or\n+     *               {@code fieldPosition} is {@code null}\n+     * @throws       ArithmeticException if rounding is needed with rounding\n+     *               mode being set to {@code RoundingMode.UNNECESSARY}\n+     * @see FieldPosition\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(long number, StringBuilder result,\n+                               FieldPosition fieldPosition) {\n+\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuilder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -349,0 +349,46 @@\n+    \/**\n+     * Formats the given {@code Object} into a date-time string. The formatted\n+     * string is appended to the given {@code StringBuilder}.\n+     *\n+     * @apiNote Subclasses should override {@link #format(Date, StringBuilder, FieldPosition)}\n+     * to support this operation.\n+     * @implSpec This implementation calls {@link #format(Date, StringBuilder, FieldPosition)},\n+     * which by default throws always throws {@code UnsupportedOperationException}.\n+     * @param obj Must be a {@code Date} or a {@code Number} representing a\n+     * millisecond offset from the <a href=\"..\/util\/Calendar.html#Epoch\">Epoch<\/a>.\n+     * @param toAppendTo The string builder for the returning date-time string.\n+     * @param fieldPosition keeps track on the position of the field within\n+     * the returned string. For example, given a date-time text\n+     * {@code \"1996.07.10 AD at 15:08:56 PDT\"}, if the given {@code fieldPosition}\n+     * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of\n+     * {@code fieldPosition} will be set to 0 and 4, respectively.\n+     * Notice that if the same date-time field appears more than once in a\n+     * pattern, the {@code fieldPosition} will be set for the first occurrence\n+     * of that date-time field. For instance, formatting a {@code Date} to the\n+     * date-time string {@code \"1 PM PDT (Pacific Daylight Time)\"} using the\n+     * pattern {@code \"h a z (zzzz)\"} and the alignment field\n+     * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of\n+     * {@code fieldPosition} will be set to 5 and 8, respectively, for the\n+     * first occurrence of the timezone pattern character {@code 'z'}.\n+     * @return the string builder passed in as {@code toAppendTo},\n+     *         with formatted text appended.\n+     * @throws    IllegalArgumentException if the {@code Format} cannot format\n+     *            the given {@code obj}.\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n+     * @see java.text.Format\n+     * @since 24\n+     *\/\n+    @Override\n+    public final StringBuilder format(Object obj, StringBuilder toAppendTo,\n+                                     FieldPosition fieldPosition) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo, fieldPosition);\n+        } else if (obj instanceof Number) {\n+            return format(new Date(((Number) obj).longValue()),\n+                    toAppendTo, fieldPosition);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\n+        }\n+    }\n+\n@@ -387,0 +433,33 @@\n+    \/**\n+     * Formats a {@link Date} into a date-time string. The formatted\n+     * string is appended to the given {@code StringBuilder}.\n+     *\n+     * @apiNote Subclasses should override this method to support this operation.\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}.\n+     * @param date a Date to be formatted into a date-time string.\n+     * @param toAppendTo the string builder for the returning date-time string.\n+     * @param fieldPosition keeps track on the position of the field within\n+     * the returned string. For example, given a date-time text\n+     * {@code \"1996.07.10 AD at 15:08:56 PDT\"}, if the given {@code fieldPosition}\n+     * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of\n+     * {@code fieldPosition} will be set to 0 and 4, respectively.\n+     * Notice that if the same date-time field appears more than once in a\n+     * pattern, the {@code fieldPosition} will be set for the first occurrence\n+     * of that date-time field. For instance, formatting a {@code Date} to the\n+     * date-time string {@code \"1 PM PDT (Pacific Daylight Time)\"} using the\n+     * pattern {@code \"h a z (zzzz)\"} and the alignment field\n+     * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of\n+     * {@code fieldPosition} will be set to 5 and 8, respectively, for the\n+     * first occurrence of the timezone pattern character {@code 'z'}.\n+     * @return the string builder passed in as {@code toAppendTo}, with formatted\n+     * text appended.\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n+     * @since 24\n+     *\/\n+    public StringBuilder format(Date date, StringBuilder toAppendTo,\n+                                FieldPosition fieldPosition) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -563,0 +563,35 @@\n+    \/**\n+     * Formats a number and appends the resulting text to the given string\n+     * builder.\n+     * The number can be of any subclass of {@link java.lang.Number}.\n+     *\n+     * This implementation uses the maximum precision permitted.\n+     * @param number     the number to format\n+     * @param toAppendTo the {@code StringBuilder} to which the formatted\n+     *                   text is to be appended\n+     * @param pos        keeps track on the position of the field within the\n+     *                   returned string. For example, for formatting a number\n+     *                   {@code 1234567.89} in {@code Locale.US} locale,\n+     *                   if the given {@code fieldPosition} is\n+     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n+     *                   and end index of {@code fieldPosition} will be set\n+     *                   to 0 and 9, respectively for the output string\n+     *                   {@code 1,234,567.89}.\n+     * @return           the value passed in as {@code toAppendTo}\n+     * @throws           IllegalArgumentException if {@code number} is\n+     *                   null or not an instance of {@code Number}.\n+     * @throws           NullPointerException if {@code toAppendTo} or\n+     *                   {@code pos} is null\n+     * @throws           ArithmeticException if rounding is needed with rounding\n+     *                   mode being set to RoundingMode.UNNECESSARY\n+     * @see              java.text.FieldPosition\n+     * @since 24\n+     *\/\n+    @Override\n+    public final StringBuilder format(Object number,\n+                               StringBuilder toAppendTo,\n+                               FieldPosition pos) {\n+        return format(number, StringBufFactory.of(toAppendTo), pos).asStringBuilder();\n+    }\n+\n+\n@@ -607,0 +642,26 @@\n+    \/**\n+     * Formats a double to produce a string.\n+     * @param number    The double to format\n+     * @param result    where the text is to be appended\n+     * @param fieldPosition    keeps track on the position of the field within\n+     *                         the returned string. For example, for formatting\n+     *                         a number {@code 1234567.89} in {@code Locale.US}\n+     *                         locale, if the given {@code fieldPosition} is\n+     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index\n+     *                         and end index of {@code fieldPosition} will be set\n+     *                         to 0 and 9, respectively for the output string\n+     *                         {@code 1,234,567.89}.\n+     * @throws    NullPointerException if {@code result} or\n+     *            {@code fieldPosition} is {@code null}\n+     * @throws    ArithmeticException if rounding is needed with rounding\n+     *            mode being set to RoundingMode.UNNECESSARY\n+     * @return The formatted number string\n+     * @see java.text.FieldPosition\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(double number, StringBuilder result,\n+                               FieldPosition fieldPosition) {\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuilder();\n+    }\n+\n@@ -786,0 +847,26 @@\n+    \/**\n+     * Format a long to produce a string.\n+     * @param number    The long to format\n+     * @param result    where the text is to be appended\n+     * @param fieldPosition    keeps track on the position of the field within\n+     *                         the returned string. For example, for formatting\n+     *                         a number {@code 123456789} in {@code Locale.US}\n+     *                         locale, if the given {@code fieldPosition} is\n+     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index\n+     *                         and end index of {@code fieldPosition} will be set\n+     *                         to 0 and 11, respectively for the output string\n+     *                         {@code 123,456,789}.\n+     * @throws          NullPointerException if {@code result} or\n+     *                  {@code fieldPosition} is {@code null}\n+     * @throws          ArithmeticException if rounding is needed with rounding\n+     *                  mode being set to RoundingMode.UNNECESSARY\n+     * @return The formatted number string\n+     * @see java.text.FieldPosition\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(long number, StringBuilder result,\n+                               FieldPosition fieldPosition) {\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuilder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -193,0 +193,30 @@\n+    \/**\n+     * Formats an object and appends the resulting text to a given string\n+     * builder.\n+     * If the {@code pos} argument identifies a field used by the format,\n+     * then its indices are set to the beginning and end of the first such\n+     * field encountered.\n+     *\n+     * @apiNote Subclasses should override this method to support this operation.\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}.\n+     * @param obj    The object to format\n+     * @param toAppendTo    where the text is to be appended\n+     * @param pos    A {@code FieldPosition} identifying a field\n+     *               in the formatted text\n+     * @return       the string builder passed in as {@code toAppendTo},\n+     *               with formatted text appended\n+     * @throws    NullPointerException if {@code toAppendTo} or\n+     *            {@code pos} is null\n+     * @throws    IllegalArgumentException if the Format cannot format the given\n+     *            object\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n+     * @since 24\n+     *\/\n+    public StringBuilder format(Object obj,\n+                                StringBuilder toAppendTo,\n+                                FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -387,0 +387,22 @@\n+    \/**\n+     * Formats an object and appends the resulting text to a given string\n+     * builder. The object should either be a List or an array of Objects.\n+     *\n+     * @apiNote Formatting the string from an excessively long list or array\n+     *          may exceed memory or string sizes.\n+     * @param obj    The object to format. Must be a List or an array\n+     *               of Object.\n+     * @param toAppendTo    where the text is to be appended\n+     * @param pos    Ignored. Not used in ListFormat. May be null\n+     * @return       the string builder passed in as {@code toAppendTo},\n+     *               with formatted text appended\n+     * @throws    NullPointerException if {@code obj} or {@code toAppendTo} is null\n+     * @throws    IllegalArgumentException if {@code obj} is neither a {@code List}\n+     *               nor an array of {@code Object}s, or its length is zero.\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(Object obj, StringBuilder toAppendTo, FieldPosition pos) {\n+        return format(obj, StringBufFactory.of(toAppendTo), pos).asStringBuilder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-     * <table class=\"plain\">\n+     * <table class=\"plain\" id=\"text_derivation_table\">\n@@ -1032,0 +1032,39 @@\n+    \/**\n+     * Formats an array of objects and appends the {@code MessageFormat}'s\n+     * pattern, with format elements replaced by the formatted objects, to the\n+     * provided {@code StringBuilder}.\n+     * <p>\n+     * The text substituted for the individual format elements is derived from\n+     * the current subformat of the format element and the\n+     * {@code arguments} element at the format element's argument index\n+     * as indicated by the first matching line of the following table. An\n+     * argument is <i>unavailable<\/i> if {@code arguments} is\n+     * {@code null} or has fewer than argumentIndex+1 elements.\n+     * Refer to the following {@link ##text_derivation_table table} for a more\n+     * detailed view of this derivation.\n+     * <p>\n+     * If {@code pos} is non-null, and refers to\n+     * {@code Field.ARGUMENT}, the location of the first formatted\n+     * string will be returned.\n+     *\n+     * @param arguments an array of objects to be formatted and substituted.\n+     * @param result where text is appended.\n+     * @param pos keeps track on the position of the first replaced argument\n+     *            in the output string.\n+     * @return the string builder passed in as {@code result}, with formatted\n+     * text appended\n+     * @throws    IllegalArgumentException if an argument in the\n+     *            {@code arguments} array is not of the type\n+     *            expected by the format element(s) that use it.\n+     * @throws    NullPointerException if {@code result} is {@code null} or\n+     *            if the {@code MessageFormat} instance that calls this method\n+     *            has locale set to null, and the implementation\n+     *            uses a locale-dependent subformat.\n+     * @since 24\n+     *\/\n+    public final StringBuilder format(Object[] arguments, StringBuilder result,\n+                                     FieldPosition pos)\n+    {\n+        return subformat(arguments, StringBufFactory.of(result), pos, null).asStringBuilder();\n+    }\n+\n@@ -1082,0 +1121,29 @@\n+    \/**\n+     * Formats an array of objects and appends the {@code MessageFormat}'s\n+     * pattern, with format elements replaced by the formatted objects, to the\n+     * provided {@code StringBuilder}.\n+     * This is equivalent to\n+     * <blockquote>\n+     *     <code>{@link #format(java.lang.Object[], java.lang.StringBuilder, java.text.FieldPosition) format}((Object[]) arguments, result, pos)<\/code>\n+     * <\/blockquote>\n+     *\n+     * @param arguments an array of objects to be formatted and substituted.\n+     * @param result where text is appended.\n+     * @param pos keeps track on the position of the first replaced argument\n+     *            in the output string.\n+     * @throws    IllegalArgumentException if an argument in the\n+     *            {@code arguments} array is not of the type\n+     *            expected by the format element(s) that use it.\n+     * @throws    NullPointerException if {@code result} is {@code null} or\n+     *            if the {@code MessageFormat} instance that calls this method\n+     *            has locale set to null, and the implementation\n+     *            uses a locale-dependent subformat.\n+     * @since 24\n+     *\/\n+    @Override\n+    public final StringBuilder format(Object arguments, StringBuilder result,\n+                                     FieldPosition pos)\n+    {\n+        return subformat((Object[]) arguments, StringBufFactory.of(result), pos, null).asStringBuilder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -318,0 +318,62 @@\n+    \/**\n+     * Formats a number and appends the resulting text to the given string\n+     * builder.\n+     * The number can be of any subclass of {@link java.lang.Number}.\n+     *\n+     * @apiNote Subclasses should override {@link #format(long,\n+     * java.lang.StringBuilder, java.text.FieldPosition)} and {@link #format(double,\n+     * java.lang.StringBuilder, java.text.FieldPosition)} to support this operation.\n+     * @implSpec This implementation may call {@link #format(long,\n+     * java.lang.StringBuilder, java.text.FieldPosition)} or {@link #format(double,\n+     * java.lang.StringBuilder, java.text.FieldPosition)}, which by default always\n+     * throws {@code UnsupportedOperationException}.\n+     * Additionally, this implementation extracts the number's value using\n+     * {@link java.lang.Number#longValue()} for all integral type values that\n+     * can be converted to {@code long} without loss of information,\n+     * including {@code BigInteger} values with a\n+     * {@link java.math.BigInteger#bitLength() bit length} of less than 64,\n+     * and {@link java.lang.Number#doubleValue()} for all other types. It\n+     * then calls {@link #format(long,java.lang.StringBuilder,java.text.FieldPosition)}\n+     * or {@link #format(double,java.lang.StringBuilder,java.text.FieldPosition)}.\n+     * This may result in loss of magnitude information and precision for\n+     * {@code BigInteger} and {@code BigDecimal} values.\n+     * @param number     the number to format\n+     * @param toAppendTo the {@code StringBuilder} to which the formatted\n+     *                   text is to be appended\n+     * @param pos        keeps track on the position of the field within the\n+     *                   returned string. For example, for formatting a number\n+     *                   {@code 1234567.89} in {@code Locale.US} locale,\n+     *                   if the given {@code fieldPosition} is\n+     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n+     *                   and end index of {@code fieldPosition} will be set\n+     *                   to 0 and 9, respectively for the output string\n+     *                   {@code 1,234,567.89}.\n+     * @return           the value passed in as {@code toAppendTo}\n+     * @throws           IllegalArgumentException if {@code number} is\n+     *                   null or not an instance of {@code Number}.\n+     * @throws           NullPointerException if {@code toAppendTo} or\n+     *                   {@code pos} is null\n+     * @throws           ArithmeticException if rounding is needed with rounding\n+     *                   mode being set to RoundingMode.UNNECESSARY\n+     * @throws           UnsupportedOperationException if the implementation of this\n+     *                   method does not support this operation\n+     * @see              java.text.FieldPosition\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(Object number,\n+                               StringBuilder toAppendTo,\n+                               FieldPosition pos) {\n+        return switch (number) {\n+            case Long l -> format(l.longValue(), toAppendTo, pos);\n+            case Integer i -> format(i.longValue(), toAppendTo, pos);\n+            case Short s -> format(s.longValue(), toAppendTo, pos);\n+            case Byte b -> format(b.longValue(), toAppendTo, pos);\n+            case AtomicInteger ai -> format(ai.longValue(), toAppendTo, pos);\n+            case AtomicLong al -> format(al.longValue(), toAppendTo, pos);\n+            case BigInteger bi when bi.bitLength() < 64 -> format(bi.longValue(), toAppendTo, pos);\n+            case Number n -> format(n.doubleValue(), toAppendTo, pos);\n+            case null, default -> throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        };\n+    }\n+\n@@ -424,0 +486,31 @@\n+    \/**\n+     * Specialization of format.\n+     *\n+     * @apiNote Subclasses should override this method to support this operation.\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}.\n+     * @param number     the double number to format\n+     * @param toAppendTo the StringBuilder to which the formatted text is to be\n+     *                   appended\n+     * @param pos        keeps track on the position of the field within the\n+     *                   returned string. For example, for formatting a number\n+     *                   {@code 1234567.89} in {@code Locale.US} locale,\n+     *                   if the given {@code fieldPosition} is\n+     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n+     *                   and end index of {@code fieldPosition} will be set\n+     *                   to 0 and 9, respectively for the output string\n+     *                   {@code 1,234,567.89}.\n+     * @return           the formatted StringBuilder\n+     * @throws           ArithmeticException if rounding is needed with rounding\n+     *                   mode being set to RoundingMode.UNNECESSARY\n+     * @throws           UnsupportedOperationException if the implementation of this\n+     *                   method does not support this operation\n+     * @see java.text.Format#format\n+     * @since 24\n+     *\/\n+    public StringBuilder format(double number,\n+                                StringBuilder toAppendTo,\n+                                FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -453,0 +546,31 @@\n+    \/**\n+     * Specialization of format.\n+     *\n+     * @apiNote Subclasses should override this method to support this operation.\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}.\n+     * @param number     the long number to format\n+     * @param toAppendTo the StringBuilder to which the formatted text is to be\n+     *                   appended\n+     * @param pos        keeps track on the position of the field within the\n+     *                   returned string. For example, for formatting a number\n+     *                   {@code 123456789} in {@code Locale.US} locale,\n+     *                   if the given {@code fieldPosition} is\n+     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\n+     *                   and end index of {@code fieldPosition} will be set\n+     *                   to 0 and 11, respectively for the output string\n+     *                   {@code 123,456,789}.\n+     * @return           the formatted StringBuilder\n+     * @throws           ArithmeticException if rounding is needed with rounding\n+     *                   mode being set to RoundingMode.UNNECESSARY\n+     * @throws           UnsupportedOperationException if the implementation of this\n+     *                   method does not support this operation\n+     * @see java.text.Format#format\n+     * @since 24\n+     *\/\n+    public StringBuilder format(long number,\n+                                StringBuilder toAppendTo,\n+                                FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -974,0 +974,29 @@\n+    \/**\n+     * Formats the given {@code Date} into a date\/time string and appends\n+     * the result to the given {@code StringBuilder}.\n+     *\n+     * @param date the date-time value to be formatted into a date-time string.\n+     * @param toAppendTo where the new date-time text is to be appended.\n+     * @param pos keeps track on the position of the field within\n+     * the returned string. For example, given a date-time text\n+     * {@code \"1996.07.10 AD at 15:08:56 PDT\"}, if the given {@code fieldPosition}\n+     * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of\n+     * {@code fieldPosition} will be set to 0 and 4, respectively.\n+     * Notice that if the same date-time field appears more than once in a\n+     * pattern, the {@code fieldPosition} will be set for the first occurrence\n+     * of that date-time field. For instance, formatting a {@code Date} to the\n+     * date-time string {@code \"1 PM PDT (Pacific Daylight Time)\"} using the\n+     * pattern {@code \"h a z (zzzz)\"} and the alignment field\n+     * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of\n+     * {@code fieldPosition} will be set to 5 and 8, respectively, for the\n+     * first occurrence of the timezone pattern character {@code 'z'}.\n+     * @return the formatted date-time string.\n+     * @throws    NullPointerException if any of the parameters is {@code null}.\n+     * @since 24\n+     *\/\n+    @Override\n+    public StringBuilder format(Date date, StringBuilder toAppendTo,\n+                               FieldPosition pos) {\n+        return format(date, StringBufFactory.of(toAppendTo), pos).asStringBuilder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/SimpleDateFormat.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-                () -> f.format(new Object(), null, new FieldPosition(0)));\n+                () -> f.format(new Object(), (StringBuffer) null, new FieldPosition(0)));\n","filename":"test\/jdk\/java\/text\/Format\/ListFormat\/TestListFormat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8313205\n+ * @summary Ensure expected behavior of Format, NumberFormat, and DateFormat\n+ *          default and subclass behavior for the StringBuilder overloads.\n+ *          This test is not concerned with the correctness of the JDK implementing\n+ *          class behavior, see JDKImplementingStrBuilderOverloads.java.\n+ * @run junit AbstractStrBuilderOverloads\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.DateFormat;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Date;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class AbstractStrBuilderOverloads {\n+\n+    \/\/ Generic params to satisfy the StringBuilder method calls\n+    private static final double db = 1.1;\n+    private static final long l = 1;\n+    private static final Date date = new Date(1);\n+    private static final Object num_o = 1;\n+    private static final Object date_o = new Date(1);\n+    private static final StringBuilder bldr = new StringBuilder(\"foo\");\n+    private static final FieldPosition fp = new FieldPosition(1);\n+\n+    \/\/ Implementing subclass should support if overloading\n+    @Test\n+    public void implementingFmtClassTest() {\n+        var f = new implementingFormat();\n+        assertEquals(bldr, f.format(num_o, bldr, fp)); \/\/ Object\n+    }\n+\n+    \/\/ Default implementation should throw for all StringBuilder overloads\n+    @Test\n+    public void defaultFmtClassTest() {\n+        var f = new defaultFormat();\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> f.format(num_o, bldr, fp)); \/\/ Object\n+    }\n+\n+    \/\/ Implementing subclass should support if overloading\n+    @Test\n+    public void implementingNFmtClassTest() {\n+        var f = new implementingNumberFormat();\n+        assertEquals(bldr, f.format(db, bldr, fp)); \/\/ double\n+        assertEquals(bldr, f.format(l, bldr, fp)); \/\/ long\n+        assertEquals(bldr, f.format(num_o, bldr, fp)); \/\/ Object\n+    }\n+\n+    \/\/ Default implementation should throw for all StringBuilder overloads\n+    @Test\n+    public void defaultNFmtClassTest() {\n+        var f = new defaultNumberFormat();\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> f.format(db, bldr, fp)); \/\/ double\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> f.format(l, bldr, fp)); \/\/ long\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> f.format(num_o, bldr, fp)); \/\/ Object\n+    }\n+\n+    \/\/ Implementing subclass should support if overloading\n+    @Test\n+    public void implementingDFmtClassTest() {\n+        var f = new implementingDateFormat();\n+        assertEquals(bldr, f.format(date, bldr, fp)); \/\/ Date\n+        assertEquals(bldr, f.format(date_o, bldr, fp)); \/\/ Object\n+    }\n+\n+    \/\/ Default implementation should throw for all StringBuilder overloads\n+    @Test\n+    public void defaultDFmtClassTest() {\n+        var f = new defaultDateFormat();\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> f.format(date, bldr, fp)); \/\/ Date\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> f.format(date_o, bldr, fp)); \/\/ Object\n+    }\n+\n+    \/\/ Each defaultXxx extends the abstract base class and overrides the abstract methods\n+    \/\/ Each ImplementingXxx extends the defaultXxx and overrides the required StringBuilder overloads\n+    \/\/ We are not concerned with the actual implementation, but simply to check\n+    \/\/ that UOE is not thrown, hence the immediate return of the passed StringBuilder.\n+    static class implementingFormat extends defaultFormat {\n+\n+        @Override\n+        public StringBuilder format(Object obj, StringBuilder toAppendTo, FieldPosition pos) {\n+            return toAppendTo;\n+        }\n+    }\n+\n+    static class defaultFormat extends Format {\n+\n+        @Override\n+        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Object parseObject(String source, ParsePosition pos) {\n+            return null;\n+        }\n+    }\n+\n+    static class implementingNumberFormat extends defaultNumberFormat {\n+\n+        @Override\n+        public StringBuilder format(double number, StringBuilder toAppendTo, FieldPosition pos) {\n+            return toAppendTo;\n+        }\n+\n+        @Override\n+        public StringBuilder format(long number, StringBuilder toAppendTo, FieldPosition pos) {\n+            return toAppendTo;\n+        }\n+    }\n+\n+    static class defaultNumberFormat extends NumberFormat {\n+\n+        @Override\n+        public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Number parse(String source, ParsePosition parsePosition) {\n+            return null;\n+        }\n+    }\n+\n+    static class implementingDateFormat extends defaultDateFormat {\n+\n+        @Override\n+        public StringBuilder format(Date date, StringBuilder toAppendTo,\n+                                    FieldPosition pos) {\n+            return toAppendTo;\n+        }\n+    }\n+\n+    static class defaultDateFormat extends DateFormat {\n+\n+        @Override\n+        public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Date parse(String source, ParsePosition pos) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/common\/AbstractStrBuilderOverloads.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8313205\n+ * @summary Ensure correctness of StringBuilder overloads at the JDK implementing\n+ *          class level. See AbstractStrBuilderOverloads.java for behavior of\n+ *          default and non JDK implementing classes.\n+ * @run junit JDKImplementingStrBuilderOverloads\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.ChoiceFormat;\n+import java.text.DateFormat;\n+import java.text.FieldPosition;\n+import java.text.ListFormat;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.util.Date;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/\/ Basic sanity to check that resultant toStrings from buffer\/builder are equivalent\n+\/\/ and that resultant type is of StringBuilder\n+public class JDKImplementingStrBuilderOverloads {\n+\n+    \/\/ Generic params to satisfy the StringBuilder\/Buffer method calls\n+    private static final double db = 1.1;\n+    private static final long l = 1;\n+    private static final Date date = new Date(1);\n+    private static final Object num_o = 1;\n+    private static final Object date_o = new Date(1);\n+    private static final Object arr_o = new String[] {\"foo\", \"bar\", \"baz\"};\n+    private static final Object[] obj_arr = (Object[]) arr_o;\n+    private static final FieldPosition fp = new FieldPosition(1);\n+\n+    @Test\n+    public void decimalFormatTest() {\n+        \/\/ decimalFormat w\/ some formatting style\n+        var fmt = NumberFormat.getCurrencyInstance();\n+        StringBuilder bldr = fmt.format(db, new StringBuilder(), fp);\n+        assertEquals(fmt.format(db, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ double\n+        bldr = fmt.format(l, new StringBuilder(), fp);\n+        assertEquals(fmt.format(l, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ long\n+        bldr = fmt.format(num_o, new StringBuilder(), fp);\n+        assertEquals(fmt.format(num_o, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Object\n+    }\n+\n+    @Test\n+    public void compactNumberFormatTest() {\n+        \/\/ compactNumberFormat w\/ some formatting style\n+        var fmt = NumberFormat.getCompactNumberInstance();\n+        StringBuilder bldr = fmt.format(db, new StringBuilder(), fp);\n+        assertEquals(fmt.format(db, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ double\n+        bldr = fmt.format(l, new StringBuilder(), fp);\n+        assertEquals(fmt.format(l, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ long\n+        bldr = fmt.format(num_o, new StringBuilder(), fp);\n+        assertEquals(fmt.format(num_o, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Object\n+    }\n+\n+    @Test\n+    public void listFormatTest() {\n+        var fmt = ListFormat.getInstance();\n+        StringBuilder bldr = fmt.format(arr_o, new StringBuilder(), fp);\n+        assertEquals(fmt.format(arr_o, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Object\n+    }\n+\n+    @Test\n+    public void choiceFormatTest() {\n+        var fmt = new ChoiceFormat(\"0#foo1#bar\");\n+        StringBuilder bldr = fmt.format(db, new StringBuilder(), fp);\n+        assertEquals(fmt.format(db, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ double\n+        bldr = fmt.format(l, new StringBuilder(), fp);\n+        assertEquals(fmt.format(l, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ long\n+        bldr = fmt.format(num_o, new StringBuilder(), fp);\n+        assertEquals(fmt.format(num_o, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Object\n+    }\n+\n+    @Test\n+    public void simpleDateFormatTest() {\n+        \/\/ SimpleDateFormat w\/ some formatting style\n+        var fmt = DateFormat.getDateInstance();\n+        StringBuilder bldr = fmt.format(date, new StringBuilder(), fp);\n+        assertEquals(fmt.format(date, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Date\n+        bldr = fmt.format(date_o, new StringBuilder(), fp);\n+        assertEquals(fmt.format(date_o, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Object\n+    }\n+\n+    @Test\n+    public void messageFormatTest() {\n+        var fmt = new MessageFormat(\"First {0}, then {1}, lastly {2}.\");\n+        StringBuilder bldr = fmt.format(arr_o, new StringBuilder(), fp);\n+        assertEquals(fmt.format(arr_o, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Object\n+        bldr = fmt.format(obj_arr, new StringBuilder(), fp);\n+        assertEquals(fmt.format(obj_arr, new StringBuffer(), fp).toString(),\n+                bldr.toString()); \/\/ Object[]\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/common\/JDKImplementingStrBuilderOverloads.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}