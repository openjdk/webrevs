{"files":[{"patch":"@@ -538,1 +538,1 @@\n-    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -MP\"\n+    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:preprocessor -Zc:strictStrings -MP -GR-\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  NotificationThread(ThreadFunction entry_point) : JavaThread(entry_point) {};\n+  NotificationThread(ThreadFunction entry_point) : JavaThread(entry_point) {}\n@@ -45,0 +45,6 @@\n+  \/\/ Serviceability Agent relies on being able to identify types based on their vtable address. If\n+  \/\/ we do not override any virtual methods and RTTI is disabled, MSVC may emit a single vtable for\n+  \/\/ JavaThread and NotificationThread. This results in the vtable symbols for both classes pointing\n+  \/\/ to the same address and Serviceability Agent thinking all JavaThread are NotificationThread. So\n+  \/\/ while this method is not directly used anywhere, it must exist.\n+  bool is_Notification_thread() const override { return true; }\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+  virtual bool is_Notification_thread() const        { return false; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}