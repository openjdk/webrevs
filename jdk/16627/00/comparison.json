{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.Collections;\n@@ -51,0 +50,1 @@\n+import java.io.PrintStream;\n@@ -54,0 +54,1 @@\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter.TargetDescription;\n@@ -97,2 +98,1 @@\n-    static ExecutionControl create(ExecutionEnv env, String remoteAgent,\n-            boolean isLaunch, String host, int timeout) throws IOException {\n+    static ExecutionControl create(ExecutionEnv env, Map<String, String> parameters, String remoteAgent, int timeout, JdiStarter starter) throws IOException {\n@@ -110,0 +110,26 @@\n+            ExecutionEnv augmentedEnv = new ExecutionEnv() {\n+                @Override\n+                public InputStream userIn() {\n+                    return env.userIn();\n+                }\n+\n+                @Override\n+                public PrintStream userOut() {\n+                    return env.userOut();\n+                }\n+\n+                @Override\n+                public PrintStream userErr() {\n+                    return env.userErr();\n+                }\n+\n+                @Override\n+                public List<String> extraRemoteVMOptions() {\n+                    return augmentedremoteVMOptions;\n+                }\n+\n+                @Override\n+                public void closeDown() {\n+                    env.closeDown();\n+                }\n+            };\n@@ -112,5 +138,3 @@\n-            JdiInitiator jdii = new JdiInitiator(port,\n-                    augmentedremoteVMOptions, remoteAgent, isLaunch, host,\n-                    timeout, Collections.emptyMap());\n-            VirtualMachine vm = jdii.vm();\n-            Process process = jdii.process();\n+            TargetDescription target = starter.start(augmentedEnv, parameters, port);\n+            VirtualMachine vm = target.vm();\n+            Process process = target.process();\n@@ -297,0 +321,27 @@\n+    \/**\n+     * Start an external process where the user's snippets can be run.\n+     *\n+     * @since 22\n+     *\/\n+    public interface JdiStarter {\n+        \/**\n+         * Start the external process based on the given parameters. The external\n+         * process should connect to the given {@code port} to communicate with the\n+         * driving instance of JShell.\n+         *\n+         * @param env the execution context\n+         * @param parameters additional execution parameters\n+         * @param port the port to which the remote process should connect\n+         * @return a description of the started external process\n+         * @throws RuntimeException if the process cannot be started\n+         * @throws Error if the process cannot be started\n+         *\/\n+        public TargetDescription start(ExecutionEnv env, Map<String, String> parameters, int port);\n+\n+        \/**\n+         * The description of a started external process.\n+         * @param vm the JDI's {@code VirtualMachine}\n+         * @param process the external {@code Process}\n+         *\/\n+        public record TargetDescription(VirtualMachine vm, Process process) {}\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":60,"deletions":9,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Collections;\n@@ -32,0 +33,1 @@\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter;\n@@ -69,0 +71,2 @@\n+    private final JdiStarter starter;\n+\n@@ -76,0 +80,31 @@\n+        this(new JdiStarter() {\n+            @Override\n+            public TargetDescription start(ExecutionEnv env, Map<String, String> parameters, int port) {\n+                String remoteAgent = parameters.get(PARAM_REMOTE_AGENT);\n+                int timeout = Integer.parseUnsignedInt(\n+                    parameters.get(PARAM_TIMEOUT));\n+                String host = parameters.get(PARAM_HOST_NAME);\n+                String sIsLaunch = parameters.get(PARAM_LAUNCH)\n+                                             .toLowerCase(Locale.ROOT);\n+                boolean isLaunch = sIsLaunch.length() > 0\n+                    && (\"true\".startsWith(sIsLaunch) || \"yes\".startsWith(sIsLaunch));\n+\n+                JdiInitiator jdii = new JdiInitiator(port,\n+                    env.extraRemoteVMOptions(), remoteAgent, isLaunch, host,\n+                    timeout, Collections.emptyMap());\n+                return new TargetDescription(jdii.vm(), jdii.process());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create an instance.  An instance can be used to\n+     * {@linkplain  #generate generate} an {@link ExecutionControl} instance\n+     * that uses the Java Debug Interface as part of the control of a remote\n+     * process. The provided {@code start} will be used to start the remote process.\n+     *\n+     * @param starter starter that will create the remote process\n+     * @since 22\n+     *\/\n+    public JdiExecutionControlProvider(JdiStarter starter) {\n+        this.starter = starter;\n@@ -145,1 +180,2 @@\n-        String remoteAgent = parameters.getOrDefault(PARAM_REMOTE_AGENT, dp.get(PARAM_REMOTE_AGENT));\n+        parameters = new HashMap<>(parameters);\n+        String remoteAgent = parameters.computeIfAbsent(PARAM_REMOTE_AGENT, x -> dp.get(PARAM_REMOTE_AGENT));\n@@ -147,6 +183,5 @@\n-                parameters.getOrDefault(PARAM_TIMEOUT, dp.get(PARAM_TIMEOUT)));\n-        String host = parameters.getOrDefault(PARAM_HOST_NAME, dp.get(PARAM_HOST_NAME));\n-        String sIsLaunch = parameters.getOrDefault(PARAM_LAUNCH, dp.get(PARAM_LAUNCH)).toLowerCase(Locale.ROOT);\n-        boolean isLaunch = sIsLaunch.length() > 0\n-                && (\"true\".startsWith(sIsLaunch) || \"yes\".startsWith(sIsLaunch));\n-        return JdiDefaultExecutionControl.create(env, remoteAgent, isLaunch, host, timeout);\n+                parameters.computeIfAbsent(PARAM_TIMEOUT, x -> dp.get(PARAM_TIMEOUT)));\n+        parameters.putIfAbsent(PARAM_HOST_NAME, dp.get(PARAM_HOST_NAME));\n+        parameters.putIfAbsent(PARAM_LAUNCH, dp.get(PARAM_LAUNCH));\n+\n+        return JdiDefaultExecutionControl.create(env, parameters, remoteAgent, timeout, starter);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiExecutionControlProvider.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -156,0 +156,45 @@\n+        try {\n+            String addr;\n+\n+            try {\n+                \/\/ Start listening, get the JDI connection address\n+                addr = listener.startListening(connectorArgs);\n+                debug(\"Listening at address: \" + addr);\n+            } catch (Throwable t) {\n+                throw reportLaunchFail(t, \"listen\");\n+            }\n+\n+            runListenProcess(addr, port, remoteVMOptions, process -> {\n+                \/\/ Accept the connection from the remote agent\n+                vm = timedVirtualMachineCreation(() -> listener.accept(connectorArgs),\n+                        () -> process.waitFor());\n+                try {\n+                    listener.stopListening(connectorArgs);\n+                } catch (IOException | IllegalConnectorArgumentsException ex) {\n+                    \/\/ ignore\n+                }\n+            });\n+            return vm;\n+        } catch (Throwable ex) {\n+            try {\n+                listener.stopListening(connectorArgs);\n+            } catch (IOException | IllegalConnectorArgumentsException iex) {\n+                \/\/ ignore\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    \/**\n+     * Create a process that will attach to the given address.\n+     * @param jdiAddress address on which a JDI server is waiting for a connection\n+     * @param jshellControlPort the port which the remote agent should connect to\n+     * @param remoteVMOptions VM options for the remote agent VM\n+     * @param setupVM a callback that should be called then the remote agent process\n+     *                is created. The callback will setup the JDI's {@code VirtualMachine}.\n+     * @since 22\n+     *\/\n+    protected void runListenProcess(String jdiAddress,\n+                                    int jshellControlPort,\n+                                    List<String> remoteVMOptions,\n+                                    ProcessStarted setupVM) {\n@@ -160,4 +205,0 @@\n-            \/\/ Start listening, get the JDI connection address\n-            String addr = listener.startListening(connectorArgs);\n-            debug(\"Listening at address: \" + addr);\n-\n@@ -171,1 +212,1 @@\n-                    \",address=\" + addr);\n+                    \",address=\" + jdiAddress);\n@@ -174,1 +215,1 @@\n-            args.add(\"\" + port);\n+            args.add(\"\" + jshellControlPort);\n@@ -180,8 +221,2 @@\n-            \/\/ Accept the connection from the remote agent\n-            vm = timedVirtualMachineCreation(() -> listener.accept(connectorArgs),\n-                    () -> process.waitFor());\n-            try {\n-                listener.stopListening(connectorArgs);\n-            } catch (IOException | IllegalConnectorArgumentsException ex) {\n-                \/\/ ignore\n-            }\n+            setupVM.processStarted(process);\n+\n@@ -190,1 +225,0 @@\n-            return vm;\n@@ -195,5 +229,0 @@\n-            try {\n-                listener.stopListening(connectorArgs);\n-            } catch (IOException | IllegalConnectorArgumentsException iex) {\n-                \/\/ ignore\n-            }\n@@ -331,0 +360,15 @@\n+    \/**\n+     * Callback that should invoked when the remote process is invoked.\n+     *\n+     * @since 22\n+     *\/\n+    protected interface ProcessStarted {\n+        \/**\n+         * Notify the process has been started.\n+         *\n+         * @param p the {@code Process}\n+         * @throws Throwable thrown when anything goes wrong.\n+         *\/\n+        public void processStarted(Process p) throws Throwable;\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiInitiator.java","additions":64,"deletions":20,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319311\n+ * @summary Tests JdiStarter\n+ * @modules jdk.jshell\/jdk.jshell jdk.jshell\/jdk.jshell.spi jdk.jshell\/jdk.jshell.execution\n+ * @run testng JdiStarterTest\n+ *\/\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import org.testng.annotations.Test;\n+import jdk.jshell.JShell;\n+import jdk.jshell.SnippetEvent;\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter;\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter.TargetDescription;\n+import jdk.jshell.execution.JdiExecutionControlProvider;\n+import jdk.jshell.execution.JdiInitiator;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class JdiStarterTest {\n+\n+    public void jdiStarter() {\n+        \/\/ turn on logging of launch failures\n+        Logger.getLogger(\"jdk.jshell.execution\").setLevel(Level.ALL);\n+        JdiStarter starter = (env, parameters, port) -> {\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_HOST_NAME), \"\");\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_LAUNCH), \"false\");\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_REMOTE_AGENT), \"jdk.jshell.execution.RemoteExecutionControl\");\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_TIMEOUT), \"5000\");\n+            JdiInitiator jdii =\n+                    new JdiInitiator(port,\n+                                     env.extraRemoteVMOptions(),\n+                                     \"jdk.jshell.execution.RemoteExecutionControl\",\n+                                     false,\n+                                     null,\n+                                     5000,\n+                                     Collections.emptyMap());\n+            return new TargetDescription(jdii.vm(), jdii.process());\n+        };\n+        JShell jshell =\n+                JShell.builder()\n+                      .executionEngine(new JdiExecutionControlProvider(starter), Map.of())\n+                      .build();\n+        List<SnippetEvent> evts = jshell.eval(\"1 + 2\");\n+        assertEquals(1, evts.size());\n+        assertEquals(\"3\", evts.get(0).value());\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/JdiStarterTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}