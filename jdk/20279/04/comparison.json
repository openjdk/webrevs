{"files":[{"patch":"@@ -838,8 +838,6 @@\n-        \/\/ Call resolve_super so class circularity is checked\n-        interf = SystemDictionary::resolve_super_or_fail(\n-                                                  _class_name,\n-                                                  unresolved_klass,\n-                                                  Handle(THREAD, _loader_data->class_loader()),\n-                                                  _protection_domain,\n-                                                  false,\n-                                                  CHECK);\n+        \/\/ Call resolve on the interface class name with class circularity checking\n+        interf = SystemDictionary::resolve_super_or_fail(_class_name,\n+                                                         unresolved_klass,\n+                                                         Handle(THREAD, _loader_data->class_loader()),\n+                                                         _protection_domain,\n+                                                         false, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -98,2 +98,2 @@\n-    case PlaceholderTable::LOAD_SUPER:\n-       queuehead = _superThreadQ;\n+    case PlaceholderTable::DETECT_CIRCULARITY:\n+       queuehead = _circularityThreadQ;\n@@ -114,2 +114,2 @@\n-    case PlaceholderTable::LOAD_SUPER:\n-       _superThreadQ = seenthread;\n+    case PlaceholderTable::DETECT_CIRCULARITY:\n+       _circularityThreadQ = seenthread;\n@@ -191,1 +191,1 @@\n-void PlaceholderEntry::set_supername(Symbol* supername) {\n+void PlaceholderEntry::set_next_klass_name(Symbol* next_klass_name) {\n@@ -193,2 +193,2 @@\n-  assert(_supername == nullptr || _supername->refcount() > 1, \"must be referenced also by the loader\");\n-  _supername = supername;\n+  assert(_next_klass_name == nullptr || _next_klass_name->refcount() > 1, \"must be referenced also by the loader\");\n+  _next_klass_name = next_klass_name;\n@@ -202,1 +202,1 @@\n-                                   Symbol* supername){\n+                                   Symbol* next_klass_name){\n@@ -207,1 +207,1 @@\n-  entry.set_supername(supername);\n+  entry.set_next_klass_name(next_klass_name);\n@@ -233,1 +233,1 @@\n-  case PlaceholderTable::LOAD_SUPER:    return \"LOAD_SUPER\";\n+  case PlaceholderTable::DETECT_CIRCULARITY:    return \"DETECT_CIRCULARITY\";\n@@ -253,1 +253,1 @@\n-\/\/ If LOAD_SUPER, this is used for circularity detection for instanceklass loading.\n+\/\/ If DETECT_CIRCULARITY, this is used for circularity detection for instanceklass loading.\n@@ -257,1 +257,1 @@\n-                                                 Symbol* supername,\n+                                                 Symbol* next_klass_name,\n@@ -259,1 +259,2 @@\n-  assert(action != LOAD_SUPER || supername != nullptr, \"must have a super class name\");\n+  assert(action != DETECT_CIRCULARITY || next_klass_name != nullptr,\n+         \"must have a class name for the next step in the class resolution recursion\");\n@@ -263,1 +264,1 @@\n-    probe = add_entry(name, loader_data, supername);\n+    probe = add_entry(name, loader_data, next_klass_name);\n@@ -265,2 +266,2 @@\n-    if (action == LOAD_SUPER) {\n-      probe->set_supername(supername);\n+    if (action == DETECT_CIRCULARITY) {\n+      probe->set_next_klass_name(next_klass_name);\n@@ -298,2 +299,2 @@\n-  if (probe->superThreadQ() == nullptr) {\n-    probe->set_supername(nullptr);\n+  if (probe->circularityThreadQ() == nullptr) {\n+    probe->set_next_klass_name(nullptr);\n@@ -302,1 +303,1 @@\n-  if ((probe->superThreadQ() == nullptr) && (probe->loadInstanceThreadQ() == nullptr)\n+  if ((probe->circularityThreadQ() == nullptr) && (probe->loadInstanceThreadQ() == nullptr)\n@@ -315,3 +316,3 @@\n-  if (supername() != nullptr) {\n-    st->print(\", supername \");\n-    supername()->print_value_on(st);\n+  if (next_klass_name() != nullptr) {\n+    st->print(\", next_klass_name \");\n+    next_klass_name()->print_value_on(st);\n@@ -331,2 +332,2 @@\n-  st->print(\"superThreadQ threads:\");\n-  SeenThread::print_action_queue(superThreadQ(), st);\n+  st->print(\"circularityThreadQ threads:\");\n+  SeenThread::print_action_queue(circularityThreadQ(), st);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-  \/\/ multiple LOAD_SUPER threads can proceed in parallel\n-  \/\/ LOAD_SUPER needed to check for class circularity\n+  \/\/ multiple DETECT_CIRCULARITY threads can proceed in parallel\n+  \/\/ DETECT_CIRCULARITY needed to check for class circularity\n@@ -52,1 +52,1 @@\n-    LOAD_SUPER = 2,                \/\/ loading superclass for this class\n+    DETECT_CIRCULARITY = 2,        \/\/ loading while detecting class circularity\n@@ -84,7 +84,7 @@\n-  SymbolHandle      _supername;\n-  JavaThread*       _definer;       \/\/ owner of define token\n-  InstanceKlass*    _instanceKlass; \/\/ InstanceKlass from successful define\n-  SeenThread*       _superThreadQ;  \/\/ doubly-linked queue of Threads loading a superclass for this class\n-  SeenThread*       _loadInstanceThreadQ;  \/\/ loadInstance thread\n-                                    \/\/ This can't be multiple threads since class loading waits for\n-                                    \/\/ this token to be removed.\n+  SymbolHandle      _next_klass_name;     \/\/ next step in the recursive process of class loading\n+  JavaThread*       _definer;             \/\/ owner of define token\n+  InstanceKlass*    _instanceKlass;       \/\/ InstanceKlass from successful define\n+  SeenThread*       _circularityThreadQ;  \/\/ doubly-linked queue of Threads loading with circularity detection\n+  SeenThread*       _loadInstanceThreadQ; \/\/ loadInstance thread\n+                                          \/\/ This can't be multiple threads since class loading\n+                                          \/\/ waits for this token to be removed.\n@@ -102,2 +102,2 @@\n-  SeenThread*        superThreadQ()        const { return _superThreadQ; }\n-  void               set_superThreadQ(SeenThread* SeenThread) { _superThreadQ = SeenThread; }\n+  SeenThread*        circularityThreadQ()  const { return _circularityThreadQ; }\n+  void               set_circularityThreadQ(SeenThread* SeenThread) { _circularityThreadQ = SeenThread; }\n@@ -113,1 +113,1 @@\n-     _superThreadQ(nullptr), _loadInstanceThreadQ(nullptr), _defineThreadQ(nullptr) { }\n+     _circularityThreadQ(nullptr), _loadInstanceThreadQ(nullptr), _defineThreadQ(nullptr) { }\n@@ -115,2 +115,2 @@\n-  Symbol*            supername()           const { return _supername; }\n-  void               set_supername(Symbol* supername);\n+  Symbol*            next_klass_name()     const { return _next_klass_name; }\n+  void               set_next_klass_name(Symbol* next_klass_name);\n@@ -124,2 +124,2 @@\n-  bool super_load_in_progress() {\n-     return (_superThreadQ != nullptr);\n+  bool circularity_detection_in_progress() {\n+     return (_circularityThreadQ != nullptr);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -402,2 +402,2 @@\n-\/\/ resolve_super_or_fail adds a LOAD_SUPER placeholder to the placeholder table before calling\n-\/\/ resolve_instance_class_or_null. ClassCircularityError is detected when a LOAD_SUPER or LOAD_INSTANCE\n+\/\/ resolve_with_circularity_detection adds a DETECT_CIRCULARITY placeholder to the placeholder table before calling\n+\/\/ resolve_instance_class_or_null. ClassCircularityError is detected when a DETECT_CIRCULARITY or LOAD_INSTANCE\n@@ -407,9 +407,9 @@\n-InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* class_name,\n-                                                       Symbol* super_name,\n-                                                       Handle class_loader,\n-                                                       Handle protection_domain,\n-                                                       bool is_superclass,\n-                                                       TRAPS) {\n-\n-  assert(super_name != nullptr, \"null superclass for resolving\");\n-  assert(!Signature::is_array(super_name), \"invalid superclass name\");\n+InstanceKlass* SystemDictionary::resolve_with_circularity_detection(Symbol* class_name,\n+                                                                    Symbol* next_name,\n+                                                                    Handle class_loader,\n+                                                                    Handle protection_domain,\n+                                                                    bool is_superclass,\n+                                                                    TRAPS) {\n+\n+  assert(next_name != nullptr, \"null superclass for resolving\");\n+  assert(!Signature::is_array(next_name), \"invalid superclass name\");\n@@ -420,1 +420,1 @@\n-                           super_name, is_superclass);\n+                           next_name, is_superclass);\n@@ -427,1 +427,1 @@\n-  \/\/ If klass is already loaded, just return the superclass or superinterface.\n+  \/\/ If class_name is already loaded, just return the superclass or superinterface.\n@@ -442,2 +442,1 @@\n-    \/\/ if the super_name matches class->super()->name() and if the class loaders match.\n-    \/\/ Otherwise, a LinkageError will be thrown later.\n+    \/\/ if the next_name matches class->super()->name() and if the class loaders match.\n@@ -445,4 +444,4 @@\n-        ((quicksuperk = klassk->java_super()) != nullptr) &&\n-         ((quicksuperk->name() == super_name) &&\n-            (quicksuperk->class_loader() == class_loader()))) {\n-           return quicksuperk;\n+       ((quicksuperk = klassk->java_super()) != nullptr) &&\n+       ((quicksuperk->name() == next_name) &&\n+         (quicksuperk->class_loader() == class_loader()))) {\n+      return quicksuperk;\n@@ -452,1 +451,1 @@\n-      if (probe && probe->check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {\n+      if (probe && probe->check_seen_thread(THREAD, PlaceholderTable::DETECT_CIRCULARITY)) {\n@@ -459,1 +458,1 @@\n-      \/\/ Be careful not to exit resolve_super without removing this placeholder.\n+      \/\/ Be careful not to exit resolve_with_circularity_detection without removing this placeholder.\n@@ -462,2 +461,2 @@\n-                                                                  PlaceholderTable::LOAD_SUPER,\n-                                                                  super_name, THREAD);\n+                                                                  PlaceholderTable::DETECT_CIRCULARITY,\n+                                                                  next_name, THREAD);\n@@ -474,1 +473,1 @@\n-    SystemDictionary::resolve_instance_class_or_null(super_name,\n+    SystemDictionary::resolve_instance_class_or_null(next_name,\n@@ -482,1 +481,1 @@\n-    PlaceholderTable::find_and_remove(class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n+    PlaceholderTable::find_and_remove(class_name, loader_data, PlaceholderTable::DETECT_CIRCULARITY, THREAD);\n@@ -488,1 +487,1 @@\n-    handle_resolution_exception(super_name, true, CHECK_NULL);\n+    handle_resolution_exception(next_name, true, CHECK_NULL);\n@@ -505,7 +504,9 @@\n-  \/\/ superk is not used; resolve_super_or_fail is called for circularity check only.\n-  Klass* superk = SystemDictionary::resolve_super_or_fail(name,\n-                                                          superclassname,\n-                                                          class_loader,\n-                                                          protection_domain,\n-                                                          true,\n-                                                          CHECK);\n+  \/\/ The result superk is not used; resolve_with_circularity_detection is called for circularity check only.\n+  \/\/ This passes true to is_superclass even though it might not be the super class in order to perform the\n+  \/\/ optimization anyway.\n+  Klass* superk = SystemDictionary::resolve_with_circularity_detection(name,\n+                                                                       superclassname,\n+                                                                       class_loader,\n+                                                                       protection_domain,\n+                                                                       true,\n+                                                                       CHECK);\n@@ -539,1 +540,1 @@\n-             (oldprobe->instance_load_in_progress() || oldprobe->super_load_in_progress())) {\n+             (oldprobe->instance_load_in_progress() || oldprobe->circularity_detection_in_progress())) {\n@@ -578,0 +579,1 @@\n+  DEBUG_ONLY(ResourceMark rm(THREAD));\n@@ -579,1 +581,1 @@\n-         !Signature::has_envelope(name), \"invalid class name\");\n+         !Signature::has_envelope(name), \"invalid class name: %s\", name == nullptr ? \"nullptr\" : name->as_C_string());\n@@ -610,1 +612,1 @@\n-  bool super_load_in_progress  = false;\n+  bool circularity_detection_in_progress  = false;\n@@ -628,3 +630,3 @@\n-      if (placeholder != nullptr && placeholder->super_load_in_progress()) {\n-         super_load_in_progress = true;\n-         superclassname = placeholder->supername();\n+      if (placeholder != nullptr && placeholder->circularity_detection_in_progress()) {\n+         circularity_detection_in_progress = true;\n+         superclassname = placeholder->next_klass_name();\n@@ -638,1 +640,1 @@\n-  if (super_load_in_progress) {\n+  if (circularity_detection_in_progress) {\n@@ -1055,2 +1057,2 @@\n-  Klass *found = resolve_super_or_fail(klass->name(), super_type->name(),\n-                                       class_loader, protection_domain, is_superclass, CHECK_0);\n+  Klass *found = resolve_with_circularity_detection(klass->name(), super_type->name(),\n+                                                    class_loader, protection_domain, is_superclass, CHECK_0);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":44,"deletions":42,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,7 @@\n+  static InstanceKlass* resolve_with_circularity_detection(Symbol* class_name,\n+                                                           Symbol* next_name,\n+                                                           Handle class_loader,\n+                                                           Handle protection_domain,\n+                                                           bool is_superclass,\n+                                                           TRAPS);\n+\n@@ -108,2 +115,1 @@\n-  static InstanceKlass* resolve_super_or_fail(Symbol* class_name,\n-                                              Symbol* super_name,\n+  static InstanceKlass* resolve_super_or_fail(Symbol* class_name, Symbol* super_name,\n@@ -111,3 +117,5 @@\n-                                              Handle protection_domain,\n-                                              bool is_superclass,\n-                                              TRAPS);\n+                                              Handle protection_domain, bool is_superclass, TRAPS) {\n+    return resolve_with_circularity_detection(class_name, super_name, class_loader, protection_domain,\n+                                              is_superclass, THREAD);\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    PlaceholderTable::classloadAction super_action = PlaceholderTable::LOAD_SUPER;\n+    PlaceholderTable::classloadAction super_action = PlaceholderTable::DETECT_CIRCULARITY;\n@@ -74,1 +74,1 @@\n-    SymbolHandle supername = placeholder->supername();\n+    SymbolHandle supername = placeholder->next_klass_name();\n@@ -89,1 +89,1 @@\n-    supername = placeholder->supername();\n+    supername = placeholder->next_klass_name();\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}