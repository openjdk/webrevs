{"files":[{"patch":"@@ -264,1 +264,2 @@\n-     * information about modifiers and type parameters.\n+     * information about modifiers, {@link #isSealed() sealed}\/{@code\n+     * non-sealed} status, and type parameters.\n@@ -317,0 +318,5 @@\n+                \/\/ A class cannot be strictfp and sealed\/non-sealed so\n+                \/\/ it is sufficient to check for sealed-ness after all\n+                \/\/ modifiers are printed.\n+                addSealingInfo(modifiers, sb);\n+\n@@ -347,0 +353,46 @@\n+    private void addSealingInfo(int modifiers, StringBuilder sb) {\n+        \/\/ A class can be final XOR sealed XOR non-sealed.\n+        if (Modifier.isFinal(modifiers)) {\n+            return; \/\/ no-op\n+        } else {\n+            if (isSealed()) {\n+                sb.append(\"sealed \");\n+                return;\n+            } else {\n+                \/\/ Check for sealed ancestor, which implies this class\n+                \/\/ is non-sealed.\n+                if (hasSealedAncestor(this)) {\n+                    sb.append(\"non-sealed \");\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean hasSealedAncestor(Class<?> clazz) {\n+        \/\/ From JLS 8.1.1.2:\n+        \/\/ \"It is a compile-time error if a class has a sealed direct\n+        \/\/ superclass or a sealed direct superinterface, and is not\n+        \/\/ declared final, sealed, or non-sealed either explicitly or\n+        \/\/ implicitly.\n+        \/\/ Thus, an effect of the sealed keyword is to force all\n+        \/\/ direct subclasses to explicitly declare whether they are\n+        \/\/ final, sealed, or non-sealed. This avoids accidentally\n+        \/\/ exposing a sealed class hierarchy to unwanted subclassing.\n+        \/\/ [...]\n+        \/\/ Thus, a subclass of a non-sealed class cannot itself be\n+        \/\/ declared non-sealed.\"\n+\n+        \/\/ Therefore, will just check direct superclass and\n+        \/\/ superinterfaces.\n+        var superclass = clazz.getSuperclass();\n+        if (superclass != null && superclass.isSealed()) {\n+            return true;\n+        }\n+        for (var superinterface : clazz.getInterfaces()) {\n+            if (superinterface.isSealed()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6298888 6992705 8161500 6304578\n+ * @bug 6298888 6992705 8161500 6304578 8322878\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n@@ -40,0 +39,2 @@\n+    private static record PlatformTestCase(Class<?> clazz, String expected) {}\n+\n@@ -46,13 +47,27 @@\n-        Map<Class<?>, String> testCases =\n-            Map.of(int.class,                          \"int\",\n-                   void.class,                         \"void\",\n-                   args.getClass(),                    \"java.lang.String[]\",\n-                   nested.getClass(),                  \"java.lang.String[][]\",\n-                   intArray.getClass(),                \"int[][]\",\n-                   java.lang.Enum.class,               \"public abstract class java.lang.Enum<E extends java.lang.Enum<E>>\",\n-                   java.util.Map.class,                \"public abstract interface java.util.Map<K,V>\",\n-                   java.util.EnumMap.class,            \"public class java.util.EnumMap<K extends java.lang.Enum<K>,V>\",\n-                   java.util.EventListenerProxy.class, \"public abstract class java.util.EventListenerProxy<T extends java.util.EventListener>\");\n-\n-        for (Map.Entry<Class<?>, String> testCase : testCases.entrySet()) {\n-            failures += checkToGenericString(testCase.getKey(), testCase.getValue());\n+       List<PlatformTestCase> platformTestCases =\n+           List.of(new PlatformTestCase(int.class,           \"int\"),\n+                   new PlatformTestCase(void.class,          \"void\"),\n+                   new PlatformTestCase(args.getClass(),     \"java.lang.String[]\"),\n+                   new PlatformTestCase(nested.getClass(),   \"java.lang.String[][]\"),\n+                   new PlatformTestCase(intArray.getClass(), \"int[][]\"),\n+\n+                   new PlatformTestCase(java.lang.Enum.class,\n+                                        \"public abstract class java.lang.Enum<E extends java.lang.Enum<E>>\"),\n+                   new PlatformTestCase(java.util.Map.class,\n+                                        \"public abstract interface java.util.Map<K,V>\"),\n+                   new PlatformTestCase(java.util.EnumMap.class,\n+                                        \"public class java.util.EnumMap<K extends java.lang.Enum<K>,V>\"),\n+                   new PlatformTestCase(java.util.EventListenerProxy.class,\n+                                        \"public abstract class java.util.EventListenerProxy<T extends java.util.EventListener>\"),\n+\n+                   \/\/ Sealed class\n+                   new PlatformTestCase(java.lang.ref.Reference.class,\n+                                     \"public abstract sealed class java.lang.ref.Reference<T>\"),\n+                   \/\/ non-sealed class\n+                   new PlatformTestCase(java.lang.ref.WeakReference.class,\n+                                     \"public non-sealed class java.lang.ref.WeakReference<T>\")\n+                   );\n+\n+        for (PlatformTestCase platformTestCase : platformTestCases) {\n+            failures += checkToGenericString(platformTestCase.clazz,\n+                                             platformTestCase.expected);\n@@ -73,1 +88,27 @@\n-                                     AnotherEnum.class)) {\n+                                     AnotherEnum.class,\n+\n+                                     SealedRootClass.class,\n+                                     SealedRootClass.ChildA.class,\n+                                     SealedRootClass.ChildB.class,\n+                                     SealedRootClass.ChildB.GrandChildAB.class,\n+                                     SealedRootClass.ChildC.class,\n+                                     SealedRootClass.ChildC.GrandChildACA.class,\n+                                     SealedRootClass.ChildC.GrandChildACB.class,\n+                                     SealedRootClass.ChildC.GrandChildACC.class,\n+                                     SealedRootClass.ChildC.GrandChildACC.GreatGrandChildACCA.class,\n+                                     SealedRootClass.ChildC.GrandChildACC.GreatGrandChildACCB.class,\n+\n+                                     SealedRootIntf.class,\n+                                     SealedRootIntf.ChildA.class,\n+                                     SealedRootIntf.ChildB.class,\n+                                     SealedRootIntf.ChildB.GrandChildAB.class,\n+                                     SealedRootIntf.ChildC.class,\n+                                     SealedRootIntf.ChildC.GrandChildACA.class,\n+                                     SealedRootIntf.ChildC.GrandChildACB.class,\n+                                     SealedRootIntf.ChildC.GrandChildACC.class,\n+                                     SealedRootIntf.ChildC.GrandChildACC.GreatGrandChildACCA.class,\n+                                     SealedRootIntf.ChildC.GrandChildACC.GreatGrandChildACCB.class,\n+                                     SealedRootIntf.IntfA.class,\n+                                     SealedRootIntf.IntfA.IntfAImpl.class,\n+                                     SealedRootIntf.IntfB.class,\n+                                     SealedRootIntf.IntfB.IntfAImpl.class)) {\n@@ -110,1 +151,4 @@\n-@ExpectedGenericString(\"enum AnotherEnum\")\n+\/\/ If an enum class has a specialized enum constant, that is compiled\n+\/\/ by having the enum class as being sealed rather than final. See JLS\n+\/\/ 8.9 Enum Classes.\n+@ExpectedGenericString(\"sealed enum AnotherEnum\")\n@@ -114,0 +158,92 @@\n+\n+\/\/ Test cases for sealed\/non-sealed _class_ hierarchy.\n+@ExpectedGenericString(\"sealed class SealedRootClass\")\n+sealed class SealedRootClass\n+    permits\n+    SealedRootClass.ChildA,\n+    SealedRootClass.ChildB,\n+    SealedRootClass.ChildC {\n+\n+    @ExpectedGenericString(\"final class SealedRootClass$ChildA\")\n+    final class ChildA extends SealedRootClass {}\n+\n+    @ExpectedGenericString(\"sealed class SealedRootClass$ChildB\")\n+    sealed class ChildB extends SealedRootClass permits SealedRootClass.ChildB.GrandChildAB {\n+        @ExpectedGenericString(\"final class SealedRootClass$ChildB$GrandChildAB\")\n+        final class GrandChildAB extends ChildB {}\n+    }\n+\n+    @ExpectedGenericString(\"non-sealed class SealedRootClass$ChildC\")\n+    non-sealed class ChildC extends SealedRootClass {\n+        \/\/ The subclasses of ChildC do not themselves have to be\n+        \/\/ sealed, non-sealed, or final.\n+        @ExpectedGenericString(\"class SealedRootClass$ChildC$GrandChildACA\")\n+        class GrandChildACA extends ChildC {}\n+\n+        @ExpectedGenericString(\"final class SealedRootClass$ChildC$GrandChildACB\")\n+        final class GrandChildACB extends ChildC {}\n+\n+        @ExpectedGenericString(\"sealed class SealedRootClass$ChildC$GrandChildACC\")\n+        sealed class GrandChildACC extends ChildC {\n+            @ExpectedGenericString(\"final class SealedRootClass$ChildC$GrandChildACC$GreatGrandChildACCA\")\n+            final class GreatGrandChildACCA extends GrandChildACC {}\n+\n+            @ExpectedGenericString(\"non-sealed class SealedRootClass$ChildC$GrandChildACC$GreatGrandChildACCB\")\n+            non-sealed class GreatGrandChildACCB extends GrandChildACC {}\n+        }\n+    }\n+}\n+\n+\/\/ Test cases for sealed\/non-sealed _interface_ hierarchy.\n+@ExpectedGenericString(\"abstract sealed interface SealedRootIntf\")\n+sealed interface SealedRootIntf\n+    permits\n+    SealedRootIntf.ChildA,\n+    SealedRootIntf.ChildB,\n+    SealedRootIntf.ChildC,\n+\n+    SealedRootIntf.IntfA,\n+    SealedRootIntf.IntfB {\n+\n+    @ExpectedGenericString(\"public static final class SealedRootIntf$ChildA\")\n+    final class ChildA implements SealedRootIntf {}\n+\n+    @ExpectedGenericString(\"public static sealed class SealedRootIntf$ChildB\")\n+    sealed class ChildB implements SealedRootIntf permits SealedRootIntf.ChildB.GrandChildAB {\n+        @ExpectedGenericString(\"final class SealedRootIntf$ChildB$GrandChildAB\")\n+        final class GrandChildAB extends ChildB {}\n+    }\n+\n+    @ExpectedGenericString(\"public static non-sealed class SealedRootIntf$ChildC\")\n+    non-sealed class ChildC implements SealedRootIntf {\n+        \/\/ The subclasses of ChildC do not themselves have to be\n+        \/\/ sealed, non-sealed, or final.\n+        @ExpectedGenericString(\"class SealedRootIntf$ChildC$GrandChildACA\")\n+        class GrandChildACA extends ChildC {}\n+\n+        @ExpectedGenericString(\"final class SealedRootIntf$ChildC$GrandChildACB\")\n+        final class GrandChildACB extends ChildC {}\n+\n+        @ExpectedGenericString(\"sealed class SealedRootIntf$ChildC$GrandChildACC\")\n+        sealed class GrandChildACC extends ChildC {\n+            @ExpectedGenericString(\"final class SealedRootIntf$ChildC$GrandChildACC$GreatGrandChildACCA\")\n+            final class GreatGrandChildACCA extends GrandChildACC {}\n+\n+            @ExpectedGenericString(\"non-sealed class SealedRootIntf$ChildC$GrandChildACC$GreatGrandChildACCB\")\n+            non-sealed class GreatGrandChildACCB extends GrandChildACC {}\n+        }\n+    }\n+\n+    @ExpectedGenericString(\"public abstract static sealed interface SealedRootIntf$IntfA\")\n+    sealed interface IntfA extends  SealedRootIntf {\n+        @ExpectedGenericString(\"public static non-sealed class SealedRootIntf$IntfA$IntfAImpl\")\n+        non-sealed class IntfAImpl implements IntfA {}\n+    }\n+\n+    @ExpectedGenericString(\"public abstract static non-sealed interface SealedRootIntf$IntfB\")\n+    non-sealed interface IntfB extends  SealedRootIntf {\n+        \/\/ Check that non-sealing can be allowed with a second superinterface being sealed.\n+        @ExpectedGenericString(\"public static non-sealed class SealedRootIntf$IntfB$IntfAImpl\")\n+        non-sealed class IntfAImpl implements IntfB, IntfA  {}\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Class\/GenericStringTest.java","additions":154,"deletions":18,"binary":false,"changes":172,"status":"modified"}]}