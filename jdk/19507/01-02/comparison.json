{"files":[{"patch":"@@ -60,59 +60,1 @@\n- *\n- * {@snippet id=\"compdecomp\" lang=\"java\":\n- *    \/\/ Encode a String into bytes\n- *    String inputString = \"blahblahblah\\u20AC\\u20AC\";\n- *    byte[] input = inputString.getBytes(StandardCharsets.UTF_8);\n- *\n- *    \/\/ Compress the bytes\n- *    ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n- *    Deflater compressor = new Deflater();\n- *    try {\n- *        compressor.setInput(input);\n- *        \/\/ Let the compressor know that the complete input\n- *        \/\/ has been made available\n- *        compressor.finish();\n- *        \/\/ Keep compressing the input till the compressor\n- *        \/\/ is finished compressing\n- *        while (!compressor.finished()) {\n- *            \/\/ Use some reasonable size for the temporary buffer\n- *            \/\/ based on the data being compressed\n- *            byte[] tmpBuffer = new byte[100];\n- *            int numCompressed = compressor.deflate(tmpBuffer);\n- *            \/\/ Copy over the compressed bytes from the temporary\n- *            \/\/ buffer into the final byte array\n- *            compressedBaos.write(tmpBuffer, 0, numCompressed);\n- *        }\n- *    } finally {\n- *        \/\/ Release the resources held by the compressor\n- *        compressor.end();\n- *    }\n- *\n- *    \/\/ Decompress the bytes\n- *    Inflater decompressor = new Inflater();\n- *    ByteArrayOutputStream decompressedBaos = new ByteArrayOutputStream();\n- *    try {\n- *        byte[] compressed = compressedBaos.toByteArray();\n- *        decompressor.setInput(compressed, 0, compressed.length);\n- *        while (!decompressor.finished()) {\n- *            \/\/ Use some reasonable size for the temporary buffer\n- *            \/\/ based on the data being decompressed\n- *            byte[] tmpBuffer = new byte[100];\n- *            int numDecompressed = 0;\n- *            try {\n- *                numDecompressed = decompressor.inflate(tmpBuffer);\n- *            } catch (DataFormatException dfe) {\n- *                \/\/ Handle exception\n- *                ...\n- *            }\n- *            \/\/ Copy over the decompressed bytes from the temporary\n- *            \/\/ buffer into the final byte array\n- *            decompressedBaos.write(tmpBuffer, 0, numDecompressed);\n- *        }\n- *    } finally {\n- *        \/\/ Release the resources held by the decompressor\n- *        decompressor.end();\n- *    }\n- *    \/\/ Decode the bytes into a String\n- *    byte[] decompressed = decompressedBaos.toByteArray();\n- *    String outputString = new String(decompressed, 0, decompressed.length, StandardCharsets.UTF_8);\n- * }\n+ * {@snippet id=\"compdecomp\" lang=\"java\" class=\"Snippets\" region=\"DeflaterInflaterExample\"}\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":1,"deletions":59,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n- * The {@linkplain Deflater##compdecomp code fragment in Deflater} demonstrates\n- * a trivial compression and decompression of a string using {@code Deflater} and\n+ * The following code fragment demonstrates a trivial compression\n+ * and decompression of a string using {@code Deflater} and\n@@ -59,0 +59,1 @@\n+ * {@snippet id=\"compdecomp\" lang=\"java\" class=\"Snippets\" region=\"DeflaterInflaterExample\"}\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.zip;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+\n+class Snippets {\n+\n+    void deflaterInflaterExample() {\n+        \/\/ @start region=\"DeflaterInflaterExample\"\n+\n+        \/\/ Encode a String into bytes\n+        String inputString = \"blahblahblah\\u20AC\\u20AC\";\n+        byte[] input = inputString.getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ Compress the bytes\n+        ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n+        Deflater compressor = new Deflater();\n+        try {\n+            compressor.setInput(input);\n+            \/\/ Let the compressor know that the complete input\n+            \/\/ has been made available\n+            compressor.finish();\n+            \/\/ Keep compressing the input till the compressor\n+            \/\/ is finished compressing\n+            while (!compressor.finished()) {\n+                \/\/ Use some reasonable size for the temporary buffer\n+                \/\/ based on the data being compressed\n+                byte[] tmpBuffer = new byte[100];\n+                int numCompressed = compressor.deflate(tmpBuffer);\n+                \/\/ Copy over the compressed bytes from the temporary\n+                \/\/ buffer into the final byte array\n+                compressedBaos.write(tmpBuffer, 0, numCompressed);\n+            }\n+        } finally {\n+            \/\/ Release the resources held by the compressor\n+            compressor.end();\n+        }\n+\n+        \/\/ Decompress the bytes\n+        Inflater decompressor = new Inflater();\n+        ByteArrayOutputStream decompressedBaos = new ByteArrayOutputStream();\n+        try {\n+            byte[] compressed = compressedBaos.toByteArray();\n+            decompressor.setInput(compressed, 0, compressed.length);\n+            while (!decompressor.finished()) {\n+                \/\/ Use some reasonable size for the temporary buffer,\n+                \/\/ based on the data being decompressed; in this example,\n+                \/\/ we use a small buffer size\n+                byte[] tmpBuffer = new byte[100];\n+                int numDecompressed = 0;\n+                try {\n+                    numDecompressed = decompressor.inflate(tmpBuffer);\n+                } catch (DataFormatException dfe) {\n+                    \/\/ Handle the exception suitably, in this example\n+                    \/\/ we just rethrow it\n+                    throw new RuntimeException(dfe);\n+                }\n+                \/\/ Copy over the decompressed bytes from the temporary\n+                \/\/ buffer into the final byte array\n+                decompressedBaos.write(tmpBuffer, 0, numDecompressed);\n+            }\n+        } finally {\n+            \/\/ Release the resources held by the decompressor\n+            decompressor.end();\n+        }\n+        \/\/ Decode the bytes into a String\n+        String outputString = decompressedBaos.toString(StandardCharsets.UTF_8);\n+\n+        \/\/ @end\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/snippet-files\/Snippets.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}