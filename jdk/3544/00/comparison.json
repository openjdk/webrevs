{"files":[{"patch":"@@ -146,1 +146,9 @@\n-    \/\/ flag inidicating whether to omit the call to C_Initialize()\n+    \/\/ short ms value to indicate how often native cleaner thread is called\n+    private int resourceCleanerShortInterval = 2_000;\n+    \/\/ long ms value to indicate how often native cleaner thread is called\n+    private int resourceCleanerLongInterval = 60_000;\n+\n+    \/\/ should Token be destroyed after logout()\n+    private boolean destroyTokenAfterLogout;\n+\n+    \/\/ flag indicating whether to omit the call to C_Initialize()\n@@ -280,0 +288,12 @@\n+    boolean getDestroyTokenAfterLogout() {\n+        return destroyTokenAfterLogout;\n+    }\n+\n+    int getResourceCleanerShortInterval() {\n+        return resourceCleanerShortInterval;\n+    }\n+\n+    int getResourceCleanerLongInterval() {\n+        return resourceCleanerLongInterval;\n+    }\n+\n@@ -414,0 +434,12 @@\n+            } else if (word.endsWith(\"cleaner.shortInterval\")) {\n+                resourceCleanerShortInterval = parseIntegerEntry(word);\n+                if (resourceCleanerShortInterval < 1_000) {\n+                    throw excLine(word + \" must be at least 1000 ms\");\n+                }\n+            } else if (word.endsWith(\"cleaner.longInterval\")) {\n+                resourceCleanerLongInterval = parseIntegerEntry(word);\n+                if (resourceCleanerLongInterval < 1_000) {\n+                    throw excLine(word + \" must be at least 1000 ms\");\n+                }\n+            } else if (word.endsWith(\"destroyTokenAfterLogout\")) {\n+                destroyTokenAfterLogout = parseBooleanEntry(word);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,4 @@\n+    synchronized void clear() {\n+        strongCache.clear();\n+        cacheReference = null;\n+    }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/KeyCache.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import sun.security.util.Debug;\n@@ -144,2 +143,2 @@\n-        this.keyIDHolder = new NativeKeyHolder(this, keyID, session, extractKeyInfo,\n-            tokenObject);\n+        this.keyIDHolder = new NativeKeyHolder(this, keyID, session,\n+                extractKeyInfo, tokenObject);\n@@ -168,0 +167,13 @@\n+    static boolean drainRefQueue() {\n+        boolean found = false;\n+        while (true) {\n+            SessionKeyRef next = (SessionKeyRef) SessionKeyRef.refQueue.poll();\n+            if (next == null) {\n+                break;\n+            }\n+            found = true;\n+            next.dispose();\n+        }\n+        return found;\n+    }\n+\n@@ -884,1 +896,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -893,1 +905,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1131,1 +1143,0 @@\n-\n@@ -1256,0 +1267,1 @@\n+\n@@ -1329,1 +1341,1 @@\n-    private static ReferenceQueue<P11Key> refQueue =\n+    static ReferenceQueue<P11Key> refQueue =\n@@ -1334,14 +1346,0 @@\n-    static ReferenceQueue<P11Key> referenceQueue() {\n-        return refQueue;\n-    }\n-\n-    private static void drainRefQueueBounded() {\n-        while (true) {\n-            SessionKeyRef next = (SessionKeyRef) refQueue.poll();\n-            if (next == null) {\n-                break;\n-            }\n-            next.dispose();\n-        }\n-    }\n-\n@@ -1357,1 +1355,2 @@\n-            throw new ProviderException(\"key must be associated with a session\");\n+            throw new ProviderException\n+                    (\"key must be associated with a session\");\n@@ -1363,1 +1362,0 @@\n-        drainRefQueueBounded();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,4 +85,0 @@\n-    long idInternal() {\n-        return id;\n-    }\n-\n@@ -115,0 +111,2 @@\n+    \/\/ regular close which will not close sessions when there are objects(keys)\n+    \/\/ still associated with them\n@@ -116,1 +114,13 @@\n-        if (hasObjects()) {\n+        close(true);\n+    }\n+\n+    \/\/ forced close which will close sessions regardless if there are objects\n+    \/\/ associated with them. Note that closing the sessions this way may\n+    \/\/ lead to those associated objects(keys) un-usable. Thus should only be\n+    \/\/ used for scenarios such as the token is about to be removed, etc.\n+    void kill() {\n+        close(false);\n+    }\n+\n+    private void close(boolean checkObjCtr) {\n+        if (hasObjects() && checkObjCtr) {\n@@ -118,1 +128,1 @@\n-                \"Internal error: close session with active objects\");\n+                    \"Internal error: close session with active objects\");\n@@ -122,1 +132,0 @@\n-}\n@@ -124,0 +133,11 @@\n+    static boolean drainRefQueue() {\n+        boolean found = false;\n+        while (true) {\n+            SessionRef next = (SessionRef) SessionRef.refQueue.poll();\n+            if (next == null) break;\n+            found = true;\n+            next.dispose();\n+        }\n+        return found;\n+    }\n+}\n@@ -132,1 +152,1 @@\n-    private static ReferenceQueue<Session> refQueue =\n+    static ReferenceQueue<Session> refQueue =\n@@ -138,16 +158,0 @@\n-    static ReferenceQueue<Session> referenceQueue() {\n-        return refQueue;\n-    }\n-\n-    static int totalCount() {\n-        return refList.size();\n-    }\n-\n-    private static void drainRefQueueBounded() {\n-        while (true) {\n-            SessionRef next = (SessionRef) refQueue.poll();\n-            if (next == null) break;\n-            next.dispose();\n-        }\n-    }\n-\n@@ -163,2 +167,0 @@\n-        \/\/ TBD: run at some interval and not every time?\n-        drainRefQueueBounded();\n@@ -173,3 +175,1 @@\n-        } catch (PKCS11Exception e1) {\n-            \/\/ ignore\n-        } catch (ProviderException e2) {\n+        } catch (PKCS11Exception | ProviderException e1) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Session.java","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\n@@ -33,1 +32,0 @@\n-\n@@ -174,1 +172,3 @@\n-        closeSession(session);\n+\n+        session.kill();\n+        activeSessions.decrementAndGet();\n@@ -182,1 +182,0 @@\n-\n@@ -191,0 +190,5 @@\n+    void clearPools() {\n+        objSessions.closeAll();\n+        opSessions.closeAll();\n+    }\n+\n@@ -199,0 +203,1 @@\n+\n@@ -241,0 +246,2 @@\n+        \/\/ access is synchronized on 'this'\n+        private volatile boolean closed = false;\n@@ -263,1 +270,1 @@\n-            if (!pool.offer(session)) {\n+            if (closed || !pool.offer(session)) {\n@@ -271,0 +278,3 @@\n+            \/\/ quick return path\n+            if (pool.size() == 0) return;\n+\n@@ -294,0 +304,9 @@\n+        \/\/ empty out all sessions inside 'pool' and close them.\n+        \/\/ however the Pool can still accept sessions\n+        void closeAll() {\n+            closed = true;\n+            Session s;\n+            while ((s = pool.poll()) != null) {\n+                mgr.killSession(s);\n+            }\n+        }\n@@ -295,1 +314,0 @@\n-\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SessionManager.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import javax.security.auth.callback.ConfirmationCallback;\n@@ -43,1 +42,0 @@\n-import javax.security.auth.callback.TextOutputCallback;\n@@ -88,0 +86,2 @@\n+    static NativeResourceCleaner cleaner;\n+\n@@ -895,1 +895,1 @@\n-    private static class TokenPoller implements Runnable {\n+    private static class TokenPoller extends Thread {\n@@ -898,0 +898,1 @@\n+\n@@ -899,0 +900,4 @@\n+            super((ThreadGroup)null, \"Poller-\" + provider.getName());\n+            setContextClassLoader(null);\n+            setDaemon(true);\n+            setPriority(Thread.MIN_PRIORITY);\n@@ -902,0 +907,1 @@\n+        @Override\n@@ -930,7 +936,2 @@\n-        final TokenPoller poller = new TokenPoller(this);\n-        Thread t = new Thread(null, poller, \"Poller \" + getName(), 0, false);\n-        t.setContextClassLoader(null);\n-        t.setDaemon(true);\n-        t.setPriority(Thread.MIN_PRIORITY);\n-        t.start();\n-        this.poller = poller;\n+        poller = new TokenPoller(this);\n+        poller.start();\n@@ -959,0 +960,37 @@\n+    private class NativeResourceCleaner extends Thread {\n+        private long sleepMillis = config.getResourceCleanerShortInterval();\n+        private int count = 0;\n+        boolean p11RefFound, SessRefFound;\n+\n+        private NativeResourceCleaner() {\n+            super((ThreadGroup)null, \"Cleanup-SunPKCS11\");\n+            setContextClassLoader(null);\n+            setDaemon(true);\n+            setPriority(Thread.MIN_PRIORITY);\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (true) {\n+                try {\n+                    sleep(sleepMillis);\n+                } catch (InterruptedException ie) {\n+                    break;\n+                }\n+                p11RefFound = P11Key.drainRefQueue();\n+                SessRefFound = Session.drainRefQueue();\n+                if (!p11RefFound && !SessRefFound) {\n+                    count++;\n+                } else {\n+                    count = 0;\n+                    sleepMillis = config.getResourceCleanerShortInterval();\n+                }\n+                if (count > 100) {\n+                    \/\/ no reference freed for some time\n+                    \/\/ increase the sleep time\n+                    sleepMillis = config.getResourceCleanerLongInterval();\n+                }\n+            }\n+        }\n+    }\n+\n@@ -974,1 +1012,4 @@\n-        createPoller();\n+        \/\/ keep polling for token insertion unless configured not to\n+        if (removable && !config.getDestroyTokenAfterLogout()) {\n+            createPoller();\n+        }\n@@ -1121,0 +1162,4 @@\n+        if (cleaner == null) {\n+            cleaner = new NativeResourceCleaner();\n+            cleaner.start();\n+        }\n@@ -1332,1 +1377,1 @@\n-        if (hasValidToken() == false) {\n+        if (!hasValidToken()) {\n@@ -1334,0 +1379,1 @@\n+\n@@ -1337,1 +1383,0 @@\n-\n@@ -1449,1 +1494,0 @@\n-\n@@ -1475,1 +1519,1 @@\n-            if (token.isLoggedInNow(null) == false) {\n+            if (!token.isLoggedInNow(null)) {\n@@ -1479,0 +1523,3 @@\n+                if (config.getDestroyTokenAfterLogout()) {\n+                    token.destroy();\n+                }\n@@ -1486,1 +1533,0 @@\n-\n@@ -1507,0 +1553,3 @@\n+            if (config.getDestroyTokenAfterLogout()) {\n+                token.destroy();\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":65,"deletions":16,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,1 +294,4 @@\n-        valid = false;\n+        secretCache.clear();\n+        privateCache.clear();\n+\n+        sessionManager.clearPools();\n@@ -296,0 +299,1 @@\n+        valid = false;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    static Provider pkcs11;\n+    static Provider pkcs11 = newPKCS11Provider();\n@@ -112,3 +112,1 @@\n-    \/\/ Goes through ServiceLoader instead of Provider.getInstance() since it\n-    \/\/ works on all platforms\n-    static {\n+    protected static Provider newPKCS11Provider() {\n@@ -139,1 +137,1 @@\n-        pkcs11 = p;\n+        return p;\n@@ -142,1 +140,1 @@\n-    \/\/ Return a SunPKCS11 provider configured with the specified config file\n+    \/\/ Return the static test SunPKCS11 provider configured with the specified config file\n@@ -144,1 +142,6 @@\n-        if (pkcs11 == null) {\n+        return getSunPKCS11(config, pkcs11);\n+    }\n+\n+    \/\/ Return the Provider p configured with the specified config file\n+    static Provider getSunPKCS11(String config, Provider p) throws Exception {\n+        if (p == null) {\n@@ -147,1 +150,1 @@\n-        return pkcs11.configure(config);\n+        return p.configure(config);\n@@ -539,0 +542,1 @@\n+    \/\/ Run NSS testing on the static PKCS11 test Provider\n@@ -540,0 +544,15 @@\n+        testNSS(test, null);\n+    }\n+\n+    \/\/ Run NSS testing on a Provider p configured with test nss config\n+    public static void testNSS(PKCS11Test test, Provider p) throws Exception {\n+        String nssConfig = getNssConfig();\n+        if (nssConfig == null) {\n+            \/\/ issue loading libraries\n+            return;\n+        }\n+        p = getSunPKCS11(nssConfig);\n+        test.premain(p);\n+    }\n+\n+    protected static String getNssConfig() throws Exception {\n@@ -542,1 +561,1 @@\n-            return;\n+            return null;\n@@ -544,1 +563,0 @@\n-        String base = getBase();\n@@ -547,1 +565,1 @@\n-            return;\n+            return null;\n@@ -550,0 +568,2 @@\n+        String base = getBase();\n+\n@@ -554,2 +574,2 @@\n-                                customDBdir :\n-                                base + SEP + \"nss\" + SEP + \"db\";\n+                customDBdir :\n+                base + SEP + \"nss\" + SEP + \"db\";\n@@ -561,4 +581,0 @@\n-        String p11config = (customConfig != null) ?\n-                                customConfig :\n-                                base + SEP + \"nss\" + SEP + customConfigName;\n-\n@@ -567,2 +583,3 @@\n-        Provider p = getSunPKCS11(p11config);\n-        test.premain(p);\n+        return (customConfig != null) ?\n+                customConfig :\n+                base + SEP + \"nss\" + SEP + customConfigName;\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.util.*;\n+import java.lang.ref.WeakReference;\n@@ -31,0 +31,3 @@\n+import javax.security.auth.login.LoginException;\n+\n+import sun.security.pkcs11.SunPKCS11;\n@@ -36,0 +39,1 @@\n+    private static SunPKCS11 pkcs11Provider = null;\n@@ -39,0 +43,9 @@\n+\n+        pkcs11Provider.logout();\n+        WeakReference<SunPKCS11> weakRef = new WeakReference<>(pkcs11Provider);\n+        pkcs11Provider = null;\n+        for (int i = 0; i > 100; i++) {\n+            System.gc();\n+            Thread.sleep(100);\n+        }\n+        System.out.println(\"Finish: \"+ weakRef.refersTo(null));\n@@ -55,1 +68,1 @@\n-        AuthProvider ap = (AuthProvider)ks.getProvider();\n+        pkcs11Provider = (SunPKCS11)ks.getProvider();\n@@ -62,2 +75,2 @@\n-            ap.login(new Subject(), new PasswordCallbackHandler());\n-            ap.logout();\n+            pkcs11Provider.login(new Subject(), new PasswordCallbackHandler());\n+            pkcs11Provider.logout();\n@@ -77,2 +90,2 @@\n-            ap.login(new Subject(), null);\n-            ap.logout();\n+            pkcs11Provider.login(new Subject(), null);\n+            pkcs11Provider.logout();\n@@ -89,2 +102,2 @@\n-        ap.setCallbackHandler(new PasswordCallbackHandler());\n-        ap.login(new Subject(), null);\n+        pkcs11Provider.setCallbackHandler(new PasswordCallbackHandler());\n+        pkcs11Provider.login(new Subject(), null);\n@@ -94,2 +107,2 @@\n-        ap.setCallbackHandler(null);\n-        ap.login(new Subject(), null);\n+        pkcs11Provider.setCallbackHandler(null);\n+        pkcs11Provider.login(new Subject(), null);\n@@ -99,1 +112,1 @@\n-        ap.logout();\n+        pkcs11Provider.logout();\n@@ -102,2 +115,11 @@\n-        ap.setCallbackHandler(new PasswordCallbackHandler());\n-        ks.load(null, (char[])null);\n+        pkcs11Provider.setCallbackHandler(new PasswordCallbackHandler());\n+        try {\n+            ks.load(null, (char[]) null);\n+        } catch (IOException e) {\n+            if (e.getCause() instanceof LoginException &&\n+                    e.getCause().getMessage().contains(\"No token present\")) {\n+                \/\/ignore\n+            } else {\n+                throw new RuntimeException(\"Unexpected result\", e);\n+            }\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/Login.java","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+        --add-modules jdk.crypto.cryptoki \\\n+        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n@@ -120,0 +122,2 @@\n+        --add-modules jdk.crypto.cryptoki \\\n+        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/Login.sh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+name = NSS\n+\n+slot = 2\n+\n+#password = test12\n+\n+library = ${pkcs11test.nss.lib}\n+\n+nssArgs = \"configdir='${pkcs11test.nss.db}' certPrefix='' keyPrefix='' secmod='secmod.db' flags=readOnly\"\n+\n+destroyTokenAfterLogout = true\n+cleaner.longInterval = 10000\n+cleaner.shortInterval = 1000\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins-nss.txt","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import sun.security.pkcs11.SunPKCS11;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.auth.login.FailedLoginException;\n+import javax.security.auth.login.LoginException;\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.security.AuthProvider;\n+import java.security.KeyStore;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+public class MultipleLogins extends PKCS11Test {\n+\n+    private static final String KS_TYPE = \"PKCS11\";\n+    private static char[] password;\n+    private static final int NUM_PROVIDERS = 20;\n+    private static final SunPKCS11[] providers = new SunPKCS11[NUM_PROVIDERS];\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i =0; i < NUM_PROVIDERS; i++) {\n+            providers[i] = (SunPKCS11)PKCS11Test.newPKCS11Provider();\n+            String nssConfig = PKCS11Test.getNssConfig();\n+            if (nssConfig == null) {\n+                throw new RuntimeException(\"issue setting up config\");\n+            }\n+            providers[i] = (SunPKCS11)PKCS11Test.getSunPKCS11(nssConfig, providers[i]);\n+            Security.addProvider(providers[i]);\n+            test(providers[i]);\n+        }\n+\n+        WeakReference<SunPKCS11>[] weakRef = new WeakReference[NUM_PROVIDERS];\n+        for (int i =0; i < NUM_PROVIDERS; i++) {\n+            weakRef[i] = new WeakReference<>(providers[i]);\n+            providers[i].logout();\n+\n+            if (i == 0) {\n+                \/\/ one provider stays for use with clean up thread\n+                continue;\n+            }\n+\n+            try {\n+                providers[i].login(new Subject(), new PasswordCallbackHandler());\n+                throw new RuntimeException(\"Expected LoginException\");\n+            } catch (LoginException le) {\n+                \/\/ expected\n+            }\n+\n+            Security.removeProvider(providers[i].getName());\n+            providers[i] = null;\n+\n+            ForceGC gc = new ForceGC();\n+            int finalI = i;\n+            gc.await(() -> weakRef[finalI].get() == null);\n+            if (!weakRef[i].refersTo(null)) {\n+                throw new RuntimeException(\"Expected SunPKCS11 Provider to be GC'ed..\");\n+            }\n+        }\n+    }\n+\n+    public void main(Provider p) throws Exception {\n+    }\n+\n+    private static void test(SunPKCS11 p) throws Exception {\n+        KeyStore ks = KeyStore.getInstance(KS_TYPE, p);\n+\n+        p.setCallbackHandler(new PasswordCallbackHandler());\n+        try {\n+            ks.load(null, (char[]) null);\n+        } catch (IOException e) {\n+            if (!e.getMessage().contains(\"load failed\")) {\n+                \/\/ we expect the keystore load to fail\n+                throw new RuntimeException(\"unexpected exception\", e);\n+            }\n+        }\n+\n+        p.logout();\n+\n+        try {\n+            ks.load(null, (char[]) null);\n+        } catch (IOException e) {\n+            if (e.getCause() instanceof LoginException &&\n+                    e.getCause().getMessage().contains(\"No token present\")) {\n+                \/\/ expected\n+            } else {\n+                throw new RuntimeException(\"Token was present\", e);\n+            }\n+        }\n+    }\n+\n+    public static class PasswordCallbackHandler implements CallbackHandler {\n+        public void handle(Callback[] callbacks)\n+                throws IOException, UnsupportedCallbackException {\n+            if (!(callbacks[0] instanceof PasswordCallback)) {\n+                throw new UnsupportedCallbackException(callbacks[0]);\n+            }\n+            PasswordCallback pc = (PasswordCallback)callbacks[0];\n+            pc.setPassword(MultipleLogins.password);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 7777777\n+# @summary\n+# @library \/test\/lib\/\n+# @build jdk.test.lib.util.ForceGC\n+# @run shell MultipleLogins.sh\n+\n+# set a few environment variables so that the shell-script can run stand-alone\n+# in the source directory\n+\n+# if running by hand on windows, change TESTSRC and TESTCLASSES to \".\"\n+if [ \"${TESTSRC}\" = \"\" ] ; then\n+    TESTSRC=`pwd`\n+fi\n+if [ \"${TESTCLASSES}\" = \"\" ] ; then\n+    TESTCLASSES=`pwd`\n+fi\n+\n+if [ \"${TESTCLASSPATH}\" = \"\" ] ; then\n+    TESTCLASSPATH=`pwd`\n+fi\n+\n+if [ \"${COMPILEJAVA}\" = \"\" ]; then\n+    COMPILEJAVA=\"${TESTJAVA}\"\n+fi\n+echo TESTSRC=${TESTSRC}\n+echo TESTCLASSES=${TESTCLASSES}\n+echo TESTJAVA=${TESTJAVA}\n+echo COMPILEJAVA=${COMPILEJAVA}\n+echo \"\"\n+\n+# let java test exit if platform unsupported\n+\n+OS=`uname -s`\n+case \"$OS\" in\n+  Linux )\n+    FS=\"\/\"\n+    PS=\":\"\n+    CP=\"${FS}bin${FS}cp\"\n+    CHMOD=\"${FS}bin${FS}chmod\"\n+    ;;\n+  Darwin )\n+    FS=\"\/\"\n+    PS=\":\"\n+    CP=\"${FS}bin${FS}cp\"\n+    CHMOD=\"${FS}bin${FS}chmod\"\n+    ;;\n+  AIX )\n+    FS=\"\/\"\n+    PS=\":\"\n+    CP=\"${FS}bin${FS}cp\"\n+    CHMOD=\"${FS}bin${FS}chmod\"\n+    ;;\n+  Windows* )\n+    FS=\"\\\\\"\n+    PS=\";\"\n+    CP=\"cp\"\n+    CHMOD=\"chmod\"\n+    ;;\n+  CYGWIN* )\n+    FS=\"\/\"\n+    PS=\";\"\n+    CP=\"cp\"\n+    CHMOD=\"chmod\"\n+    #\n+    # javac does not like \/cygdrive produced by `pwd`\n+    #\n+    TESTSRC=`cygpath -d ${TESTSRC}`\n+    ;;\n+  * )\n+    echo \"Unrecognized system!\"\n+    exit 1;\n+    ;;\n+esac\n+\n+# first make cert\/key DBs writable\n+\n+${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}cert8.db ${TESTCLASSES}\n+${CHMOD} +w ${TESTCLASSES}${FS}cert8.db\n+\n+${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}key3.db ${TESTCLASSES}\n+${CHMOD} +w ${TESTCLASSES}${FS}key3.db\n+\n+# compile test\n+\n+${COMPILEJAVA}${FS}bin${FS}javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} \\\n+        -classpath ${TESTCLASSPATH} \\\n+        -d ${TESTCLASSES} \\\n+        --add-modules jdk.crypto.cryptoki \\\n+        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n+        ${TESTSRC}${FS}..${FS}..${FS}..${FS}..${FS}..${FS}lib${FS}jdk${FS}test${FS}lib${FS}artifacts${FS}*.java \\\n+        ${TESTSRC}${FS}MultipleLogins.java \\\n+        ${TESTSRC}${FS}..${FS}PKCS11Test.java\n+\n+# run test\n+\n+${TESTJAVA}${FS}bin${FS}java ${TESTVMOPTS} \\\n+        -classpath ${TESTCLASSPATH} \\\n+        --add-modules jdk.crypto.cryptoki \\\n+        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n+        -DCUSTOM_DB_DIR=${TESTCLASSES} \\\n+        -DCUSTOM_P11_CONFIG=${TESTSRC}${FS}MultipleLogins-nss.txt \\\n+        -DNO_DEFAULT=true \\\n+        -DNO_DEIMOS=true \\\n+        -Dtest.src=${TESTSRC} \\\n+        -Dtest.classes=${TESTCLASSES} \\\n+        -Djava.security.debug=${DEBUG} \\\n+        MultipleLogins sm Login.policy\n+\n+# save error status\n+status=$?\n+\n+# return\n+exit $status\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.sh","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}