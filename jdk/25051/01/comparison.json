{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -30,0 +31,1 @@\n+import java.util.List;\n@@ -36,1 +38,1 @@\n-public final class ApplicationLayout implements PathGroup.Facade<ApplicationLayout> {\n+public final class ApplicationLayout {\n@@ -87,1 +89,0 @@\n-    @Override\n@@ -92,1 +93,0 @@\n-    @Override\n@@ -97,0 +97,20 @@\n+    public List<Path> roots() {\n+        return data.roots();\n+    }\n+\n+    public long sizeInBytes() throws IOException {\n+        return data.sizeInBytes();\n+    }\n+\n+    public void copy(ApplicationLayout other) throws IOException {\n+        data.copy(other.data);\n+    }\n+\n+    public void move(ApplicationLayout other) throws IOException {\n+        data.move(other.data);\n+    }\n+\n+    public void transform(ApplicationLayout other, PathGroup.TransformHandler handler) throws IOException {\n+        data.transform(other.data, handler);\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayout.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+import static java.util.stream.Collectors.collectingAndThen;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+\n@@ -28,0 +33,3 @@\n+import java.io.UncheckedIOException;\n+import java.nio.file.CopyOption;\n+import java.nio.file.FileVisitOption;\n@@ -29,0 +37,1 @@\n+import java.nio.file.LinkOption;\n@@ -32,0 +41,1 @@\n+import java.util.Comparator;\n@@ -35,2 +45,2 @@\n-import java.util.function.BiFunction;\n-import java.util.stream.Collectors;\n+import java.util.Objects;\n+import java.util.Set;\n@@ -39,1 +49,0 @@\n-\n@@ -41,2 +50,1 @@\n- * Group of paths.\n- * Each path in the group is assigned a unique id.\n+ * Group of paths. Each path in the group is assigned a unique id.\n@@ -45,0 +53,6 @@\n+\n+    \/**\n+     * Creates path group with the initial paths.\n+     *\n+     * @param paths the initial paths\n+     *\/\n@@ -46,0 +60,2 @@\n+        paths.keySet().forEach(Objects::requireNonNull);\n+        paths.values().forEach(Objects::requireNonNull);\n@@ -49,0 +65,7 @@\n+    \/**\n+     * Returns a path associated with the given identifier in this path group.\n+     *\n+     * @param id the identifier\n+     * @return the path corresponding to the given identifier in this path group or\n+     *         <code>null<\/code> if there is no such path\n+     *\/\n@@ -50,3 +73,1 @@\n-        if (id == null) {\n-            throw new NullPointerException();\n-        }\n+        Objects.requireNonNull(id);\n@@ -56,0 +77,11 @@\n+    \/**\n+     * Assigns the specified path value to the given identifier in this path group.\n+     * If the given identifier doesn't exist in this path group, it is added,\n+     * otherwise, the current value associated with the identifier is replaced with\n+     * the given path value. If the path value is <code>null<\/code> the given\n+     * identifier is removed from this path group if it existed; otherwise, no\n+     * action is taken.\n+     *\n+     * @param id   the identifier\n+     * @param path the path to associate with the identifier or <code>null<\/code>\n+     *\/\n@@ -57,0 +89,1 @@\n+        Objects.requireNonNull(id);\n@@ -65,1 +98,27 @@\n-     * All configured entries.\n+     * Adds a path associated with the new unique identifier to this path group.\n+     *\n+     * @param path the path to associate the new unique identifier in this path\n+     *             group\n+     *\/\n+    public void ghostPath(Path path) {\n+        Objects.requireNonNull(path);\n+        setPath(new Object(), path);\n+    }\n+\n+    \/**\n+     * Gets all identifiers of this path group.\n+     * <p>\n+     * The order of identifiers in the returned list is undefined.\n+     *\n+     * @return all identifiers of this path group\n+     *\/\n+    public Set<Object> keys() {\n+        return entries.keySet();\n+    }\n+\n+    \/**\n+     * Gets paths associated with all identifiers in this path group.\n+     * <p>\n+     * The order of paths in the returned list is undefined.\n+     *\n+     * @return paths associated with all identifiers in this path group\n@@ -72,1 +131,9 @@\n-     * Root entries.\n+     * Gets root paths in this path group.\n+     * <p>\n+     * If multiple identifiers are associated with the same path value in the group,\n+     * the path value is added to the returned list only once. Paths that are\n+     * descendants of other paths in the group are not added to the returned list.\n+     * <p>\n+     * The order of paths in the returned list is undefined.\n+     *\n+     * @return unique root paths in this path group\n@@ -75,13 +142,33 @@\n-        \/\/ Sort by the number of path components in ascending order.\n-        List<Map.Entry<Path, Path>> sorted = normalizedPaths().stream().sorted(\n-                (a, b) -> a.getKey().getNameCount() - b.getKey().getNameCount()).toList();\n-\n-        \/\/ Returns `true` if `a` is a parent of `b`\n-        BiFunction<Map.Entry<Path, Path>, Map.Entry<Path, Path>, Boolean> isParentOrSelf = (a, b) -> {\n-            return a == b || b.getKey().startsWith(a.getKey());\n-        };\n-\n-        return sorted.stream().filter(\n-                v -> v == sorted.stream().sequential().filter(\n-                        v2 -> isParentOrSelf.apply(v2, v)).findFirst().get()).map(\n-                        v -> v.getValue()).toList();\n+        if (entries.isEmpty()) {\n+            return List.of();\n+        }\n+\n+        \/\/ Sort by the number of path components in descending order.\n+        final var sorted = entries.entrySet().stream().map(e -> {\n+            return Map.entry(e.getValue().normalize(), e.getValue());\n+        }).sorted(Comparator.comparingInt(e -> e.getValue().getNameCount() * -1)).distinct().toList();\n+\n+        final var shortestNormalizedPath = sorted.getLast().getKey();\n+        if (shortestNormalizedPath.getNameCount() == 1 && shortestNormalizedPath.getFileName().toString().isEmpty()) {\n+            return List.of(sorted.getLast().getValue());\n+        }\n+\n+        final List<Path> roots = new ArrayList<>();\n+\n+        for (int i = 0; i < sorted.size(); ++i) {\n+            final var path = sorted.get(i).getKey();\n+            boolean pathIsRoot = true;\n+            for (int j = i + 1; j < sorted.size(); ++j) {\n+                final var maybeParent = sorted.get(j).getKey();\n+                if (path.getNameCount() > maybeParent.getNameCount() && path.startsWith(maybeParent)) {\n+                    pathIsRoot = false;\n+                    break;\n+                }\n+            }\n+\n+            if (pathIsRoot) {\n+                roots.add(sorted.get(i).getValue());\n+            }\n+        }\n+\n+        return roots;\n@@ -90,0 +177,9 @@\n+    \/**\n+     * Gets the number of bytes in root paths of this path group. The method sums\n+     * the size of all root path entries in the group. If the path entry is a\n+     * directory it calculates the total size of the files in the directory. If the\n+     * path entry is a file, it takes its size.\n+     *\n+     * @return the total number of bytes in root paths of this path group\n+     * @throws IOException If an I\/O error occurs\n+     *\/\n@@ -92,5 +188,6 @@\n-        for (Path dir : roots().stream().filter(f -> Files.isDirectory(f)).collect(\n-                Collectors.toList())) {\n-            try (Stream<Path> stream = Files.walk(dir)) {\n-                reply += stream.filter(p -> Files.isRegularFile(p)).mapToLong(\n-                        f -> f.toFile().length()).sum();\n+        final var roots = roots();\n+        try {\n+            for (Path dir : roots.stream().filter(Files::isDirectory).toList()) {\n+                try (Stream<Path> stream = Files.walk(dir)) {\n+                    reply += stream.mapToLong(PathGroup::sizeInBytes).sum();\n+                }\n@@ -98,0 +195,3 @@\n+            reply += roots.stream().mapToLong(PathGroup::sizeInBytes).sum();\n+        } catch (UncheckedIOException ex) {\n+            throw ex.getCause();\n@@ -102,0 +202,21 @@\n+    private static long sizeInBytes(Path path) throws UncheckedIOException {\n+        if (Files.isRegularFile(path)) {\n+            try {\n+                return Files.size(path);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * Creates a copy of this path group with all paths resolved against the given\n+     * root. Taken action is equivalent to creating a copy of this path group and\n+     * calling <code>root.resolve()<\/code> on every path in the copy.\n+     *\n+     * @param root the root against which to resolve paths\n+     *\n+     * @return a new path group resolved against the given root path\n+     *\/\n@@ -103,3 +224,3 @@\n-        return new PathGroup(entries.entrySet().stream().collect(\n-                Collectors.toMap(e -> e.getKey(),\n-                        e -> root.resolve(e.getValue()))));\n+        Objects.requireNonNull(root);\n+        return new PathGroup(entries.entrySet().stream()\n+                .collect(toMap(Map.Entry::getKey, e -> root.resolve(e.getValue()))));\n@@ -108,2 +229,13 @@\n-    public void copy(PathGroup dst) throws IOException {\n-        copy(this, dst, null, false);\n+    \/**\n+     * Copies files\/directories from the locations in the path group into the\n+     * locations of the given path group. For every identifier found in this and the\n+     * given group, copy the associated file or directory from the location\n+     * specified by the path value associated with the identifier in this group into\n+     * the location associated with the identifier in the given group.\n+     *\n+     * @param dst the destination path group\n+     * @throws IOException If an I\/O error occurs\n+     *\/\n+    public void copy(PathGroup dst, CopyOption ...options) throws IOException {\n+        final var handler = new Copy(false, options);\n+        copy(this, dst, handler, handler.followSymlinks());\n@@ -112,2 +244,11 @@\n-    public void move(PathGroup dst) throws IOException {\n-        copy(this, dst, null, true);\n+    \/**\n+     * Similar to {@link #copy(PathGroup)} but moves files\/directories instead of\n+     * copying.\n+     *\n+     * @param dst the destination path group\n+     * @throws IOException If an I\/O error occurs\n+     *\/\n+    public void move(PathGroup dst, CopyOption ...options) throws IOException {\n+        final var handler = new Copy(true, options);\n+        copy(this, dst, handler, handler.followSymlinks());\n+        deleteEntries();\n@@ -116,0 +257,8 @@\n+    \/**\n+     * Similar to {@link #copy(PathGroup)} but uses the given handler to transform\n+     * paths instead of coping.\n+     *\n+     * @param dst the destination path group\n+     * @param handler the path transformation handler\n+     * @throws IOException If an I\/O error occurs\n+     *\/\n@@ -120,2 +269,18 @@\n-    public static interface Facade<T> {\n-        PathGroup pathGroup();\n+    \/**\n+     * Handler of file copying and directory creating.\n+     *\n+     * @see #transform\n+     *\/\n+    public static interface TransformHandler {\n+\n+        \/**\n+         * Request to copy a file from the given source location into the given\n+         * destination location.\n+         *\n+         * @implNote Default implementation takes no action\n+         *\n+         * @param src the source file location\n+         * @param dst the destination file location\n+         * @throws IOException If an I\/O error occurs\n+         *\/\n+        default void copyFile(Path src, Path dst) throws IOException {\n@@ -123,2 +288,0 @@\n-        default Collection<Path> paths() {\n-            return pathGroup().paths();\n@@ -127,2 +290,10 @@\n-        default List<Path> roots() {\n-            return pathGroup().roots();\n+        \/**\n+         * Request to create a directory at the given location.\n+         *\n+         * @implNote Default implementation takes no action\n+         *\n+         * @param dir the path where the directory is requested to be created\n+         * @throws IOException\n+         *\/\n+        default void createDirectory(Path dir) throws IOException {\n+\n@@ -131,2 +302,12 @@\n-        default long sizeInBytes() throws IOException {\n-            return pathGroup().sizeInBytes();\n+        \/**\n+         * Request to copy a symbolic link from the given source location into the given\n+         * destination location.\n+         *\n+         * @implNote Default implementation calls {@link #copyFile}.\n+         *\n+         * @param src the source symbolic link location\n+         * @param dst the destination symbolic link location\n+         * @throws IOException If an I\/O error occurs\n+         *\/\n+        default void copySymbolicLink(Path src, Path dst) throws IOException {\n+            copyFile(src, dst);\n@@ -134,0 +315,1 @@\n+    }\n@@ -135,1 +317,9 @@\n-        T resolveAt(Path root);\n+    private void deleteEntries() throws IOException {\n+        for (final var file : entries.values()) {\n+            if (Files.isDirectory(file)) {\n+                FileUtils.deleteRecursive(file);\n+            } else {\n+                Files.deleteIfExists(file);\n+            }\n+        }\n+    }\n@@ -137,2 +327,7 @@\n-        default void copy(Facade<T> dst) throws IOException {\n-            pathGroup().copy(dst.pathGroup());\n+    private record CopySpec(Path basepath, Path from, Path to) {\n+        CopySpec {\n+            Objects.requireNonNull(basepath);\n+            Objects.requireNonNull(to);\n+            if (!from.startsWith(basepath)) {\n+                throw new IllegalArgumentException();\n+            }\n@@ -141,2 +336,3 @@\n-        default void move(Facade<T> dst) throws IOException {\n-            pathGroup().move(dst.pathGroup());\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(from, to);\n@@ -145,3 +341,10 @@\n-        default void transform(Facade<T> dst, TransformHandler handler) throws\n-                IOException {\n-            pathGroup().transform(dst.pathGroup(), handler);\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if ((obj == null) || (getClass() != obj.getClass())) {\n+                return false;\n+            }\n+            CopySpec other = (CopySpec) obj;\n+            return Objects.equals(from, other.from) && Objects.equals(to, other.to);\n@@ -149,1 +352,0 @@\n-    }\n@@ -151,3 +353,11 @@\n-    public static interface TransformHandler {\n-        void copyFile(Path src, Path dst) throws IOException;\n-        void createDirectory(Path dir) throws IOException;\n+        Path fromNormalized() {\n+            return from().normalize();\n+        }\n+\n+        Path toNormalized() {\n+            return to().normalize();\n+        }\n+\n+        CopySpec(Path from, Path to) {\n+            this(from, from, to);\n+        }\n@@ -156,4 +366,3 @@\n-    private static void copy(PathGroup src, PathGroup dst,\n-            TransformHandler handler, boolean move) throws IOException {\n-        List<Map.Entry<Path, Path>> copyItems = new ArrayList<>();\n-        List<Path> excludeItems = new ArrayList<>();\n+    private static void copy(PathGroup src, PathGroup dst, TransformHandler handler, boolean followSymlinks) throws IOException {\n+        List<CopySpec> copySpecs = new ArrayList<>();\n+        List<Path> excludePaths = new ArrayList<>();\n@@ -161,4 +370,5 @@\n-        for (var id: src.entries.keySet()) {\n-            Path srcPath = src.entries.get(id);\n-            if (dst.entries.containsKey(id)) {\n-                copyItems.add(Map.entry(srcPath, dst.entries.get(id)));\n+        for (final var e : src.entries.entrySet()) {\n+            final var srcPath = e.getValue();\n+            final var dstPath = dst.entries.get(e.getKey());\n+            if (dstPath != null) {\n+                copySpecs.add(new CopySpec(srcPath, dstPath));\n@@ -166,1 +376,1 @@\n-                excludeItems.add(srcPath);\n+                excludePaths.add(srcPath.normalize());\n@@ -170,1 +380,1 @@\n-        copy(move, copyItems, excludeItems, handler);\n+        copy(copySpecs, excludePaths, handler, followSymlinks);\n@@ -173,15 +383,1 @@\n-    private static void copy(boolean move, List<Map.Entry<Path, Path>> entries,\n-            List<Path> excludePaths, TransformHandler handler) throws\n-            IOException {\n-\n-        if (handler == null) {\n-            handler = new TransformHandler() {\n-                @Override\n-                public void copyFile(Path src, Path dst) throws IOException {\n-                    Files.createDirectories(dst.getParent());\n-                    if (move) {\n-                        Files.move(src, dst);\n-                    } else {\n-                        Files.copy(src, dst);\n-                    }\n-                }\n+    private record Copy(boolean move, boolean followSymlinks, CopyOption ... options) implements TransformHandler {\n@@ -189,5 +385,2 @@\n-                @Override\n-                public void createDirectory(Path dir) throws IOException {\n-                    Files.createDirectories(dir);\n-                }\n-            };\n+        Copy(boolean move, CopyOption ... options) {\n+            this(move, !Set.of(options).contains(LinkOption.NOFOLLOW_LINKS), options);\n@@ -196,10 +389,5 @@\n-        \/\/ destination -> source file mapping\n-        Map<Path, Path> actions = new HashMap<>();\n-        for (var action: entries) {\n-            Path src = action.getKey();\n-            Path dst = action.getValue();\n-            if (Files.isDirectory(src)) {\n-               try (Stream<Path> stream = Files.walk(src)) {\n-                   stream.sequential().forEach(path -> actions.put(dst.resolve(\n-                            src.relativize(path)).normalize(), path));\n-               }\n+        @Override\n+        public void copyFile(Path src, Path dst) throws IOException {\n+            Files.createDirectories(dst.getParent());\n+            if (move) {\n+                Files.move(src, dst, options);\n@@ -207,1 +395,1 @@\n-                actions.put(dst.normalize(), src);\n+                Files.copy(src, dst, options);\n@@ -211,3 +399,5 @@\n-        for (var action : actions.entrySet()) {\n-            Path dst = action.getKey();\n-            Path src = action.getValue();\n+        @Override\n+        public void createDirectory(Path dir) throws IOException {\n+            Files.createDirectories(dir);\n+        }\n+    }\n@@ -215,3 +405,3 @@\n-            if (excludePaths.stream().anyMatch(src::startsWith)) {\n-                continue;\n-            }\n+    private static boolean match(Path what, List<Path> paths) {\n+        return paths.stream().anyMatch(what::startsWith);\n+    }\n@@ -219,3 +409,4 @@\n-            if (src.equals(dst) || !src.toFile().exists()) {\n-                continue;\n-            }\n+    private static void copy(List<CopySpec> copySpecs, List<Path> excludePaths,\n+            TransformHandler handler, boolean followSymlinks) throws IOException {\n+        Objects.requireNonNull(excludePaths);\n+        Objects.requireNonNull(handler);\n@@ -223,4 +414,6 @@\n-            if (Files.isDirectory(src)) {\n-                handler.createDirectory(dst);\n-            } else {\n-                handler.copyFile(src, dst);\n+\n+        final var filteredCopySpecs = copySpecs.stream().<CopySpec>mapMulti((copySpec, consumer) -> {\n+            final var src = copySpec.from();\n+\n+            if (!Files.exists(src) || match(src, excludePaths)) {\n+                return;\n@@ -228,1 +421,0 @@\n-        }\n@@ -230,6 +422,11 @@\n-        if (move) {\n-            \/\/ Delete source dirs.\n-            for (var entry: entries) {\n-                Path srcFile = entry.getKey();\n-                if (Files.isDirectory(srcFile)) {\n-                    FileUtils.deleteRecursive(srcFile);\n+            if (Files.isDirectory(copySpec.from())) {\n+                final var dst = copySpec.to;\n+                final var walkMode = followSymlinks ? new FileVisitOption[] { FileVisitOption.FOLLOW_LINKS } : new FileVisitOption[0];\n+                try (final var files = Files.walk(src, walkMode)) {\n+                    files.filter(file -> {\n+                        return !match(file, excludePaths);\n+                    }).map(file -> {\n+                        return new CopySpec(src, file, dst.resolve(src.relativize(file)));\n+                    }).toList().forEach(consumer::accept);\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n@@ -237,0 +434,2 @@\n+            } else {\n+                consumer.accept(copySpec);\n@@ -238,0 +437,33 @@\n+        }).collect(groupingBy(CopySpec::fromNormalized, collectingAndThen(toSet(), copySpecGroup -> {\n+            return copySpecGroup.stream().filter(copySpec -> {\n+                for (final var otherCopySpec : copySpecGroup) {\n+                    if (otherCopySpec != copySpec && !otherCopySpec.basepath().equals(copySpec.basepath())\n+                            && otherCopySpec.basepath().startsWith(copySpec.basepath())) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }).toList();\n+        }))).values().stream().flatMap(Collection::stream).toList();\n+\n+        filteredCopySpecs.stream().collect(toMap(CopySpec::toNormalized, x -> x, (x, y) -> {\n+            throw new IllegalStateException(String.format(\n+                    \"Duplicate source files [%s] and [%s] for [%s] destination file\", x.from(), y.from(), x.to()));\n+        }));\n+\n+        try {\n+            filteredCopySpecs.stream().forEach(copySpec -> {\n+                try {\n+                    if (Files.isSymbolicLink(copySpec.from())) {\n+                        handler.copySymbolicLink(copySpec.from(), copySpec.to());\n+                    } else if (Files.isDirectory(copySpec.from())) {\n+                        handler.createDirectory(copySpec.to());\n+                    } else {\n+                        handler.copyFile(copySpec.from(), copySpec.to());\n+                    }\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+        } catch (UncheckedIOException ex) {\n+            throw ex.getCause();\n@@ -241,16 +473,0 @@\n-    private static Map.Entry<Path, Path> normalizedPath(Path v) {\n-        final Path normalized;\n-        if (!v.isAbsolute()) {\n-            normalized = Path.of(\".\/\").resolve(v.normalize());\n-        } else {\n-            normalized = v.normalize();\n-        }\n-\n-        return Map.entry(normalized, v);\n-    }\n-\n-    private List<Map.Entry<Path, Path>> normalizedPaths() {\n-        return entries.values().stream().map(PathGroup::normalizedPath).collect(\n-                Collectors.toList());\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathGroup.java","additions":348,"deletions":132,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-        Path destktopIntegrationDirectory, Path contentDirectory) {\n+        Path desktopIntegrationDirectory, Path contentDirectory, Path libapplauncher) {\n@@ -41,2 +41,3 @@\n-                resolve(root, destktopIntegrationDirectory),\n-                resolve(root, contentDirectory));\n+                resolve(root, desktopIntegrationDirectory),\n+                resolve(root, contentDirectory),\n+                resolve(root, libapplauncher));\n@@ -53,1 +54,2 @@\n-                Path.of(\"lib\")\n+                Path.of(\"lib\"),\n+                Path.of(\"lib\/libapplauncher.so\")\n@@ -65,1 +67,2 @@\n-                Path.of(\"\")\n+                Path.of(\"\"),\n+                null\n@@ -77,1 +80,2 @@\n-                Path.of(\"Contents\")\n+                Path.of(\"Contents\"),\n+                null\n@@ -105,0 +109,1 @@\n+                null,\n@@ -119,1 +124,2 @@\n-                lib\n+                lib,\n+                lib.resolve(\"lib\/libapplauncher.so\")\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ApplicationLayout.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1011,1 +1011,1 @@\n-            assertFileInAppImage(lookupPath, null);\n+            assertFileNotInAppImage(lookupPath);\n@@ -1013,1 +1013,1 @@\n-            assertFileInAppImage(lookupPath, lookupPath);\n+            assertFileInAppImage(lookupPath);\n@@ -1038,1 +1038,1 @@\n-            assertFileInAppImage(lookupPath, null);\n+            assertFileNotInAppImage(lookupPath);\n@@ -1043,1 +1043,1 @@\n-                    assertFileInAppImage(lookupPath, null);\n+                    assertFileNotInAppImage(lookupPath);\n@@ -1045,1 +1045,1 @@\n-                    assertFileInAppImage(lookupPath, lookupPath);\n+                    assertFileInAppImage(lookupPath);\n@@ -1048,1 +1048,1 @@\n-                assertFileInAppImage(lookupPath, lookupPath);\n+                assertFileInAppImage(lookupPath);\n@@ -1053,0 +1053,8 @@\n+    public void assertFileInAppImage(Path expectedPath) {\n+        assertFileInAppImage(expectedPath.getFileName(), expectedPath);\n+    }\n+\n+    public void assertFileNotInAppImage(Path filename) {\n+        assertFileInAppImage(filename, null);\n+    }\n+\n@@ -1054,0 +1062,9 @@\n+        if (expectedPath != null) {\n+            if (expectedPath.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!expectedPath.getFileName().equals(filename.getFileName())) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        Path iconPath = cmd.appLayout().destktopIntegrationDirectory().resolve(\n+        Path iconPath = cmd.appLayout().desktopIntegrationDirectory().resolve(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-        return cmd.appLayout().destktopIntegrationDirectory().resolve(\n+        return cmd.appLayout().desktopIntegrationDirectory().resolve(\n@@ -396,1 +396,1 @@\n-            try (var files = Files.list(cmd.appLayout().destktopIntegrationDirectory())) {\n+            try (var files = Files.list(cmd.appLayout().desktopIntegrationDirectory())) {\n@@ -473,1 +473,1 @@\n-                Map.entry(Map.entry(\"Icon\", Optional.empty()), ApplicationLayout::destktopIntegrationDirectory))) {\n+                Map.entry(Map.entry(\"Icon\", Optional.empty()), ApplicationLayout::desktopIntegrationDirectory))) {\n@@ -540,1 +540,1 @@\n-                Path appDesktopFile = cmd.appLayout().destktopIntegrationDirectory().resolve(\n+                Path appDesktopFile = cmd.appLayout().desktopIntegrationDirectory().resolve(\n@@ -572,1 +572,1 @@\n-                Path mimeTypeIcon = cmd.appLayout().destktopIntegrationDirectory().resolve(\n+                Path mimeTypeIcon = cmd.appLayout().desktopIntegrationDirectory().resolve(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,11 @@\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n@@ -27,0 +38,1 @@\n+import java.io.UncheckedIOException;\n@@ -30,0 +42,1 @@\n+import java.util.Collection;\n@@ -31,0 +44,1 @@\n+import java.util.HashMap;\n@@ -33,0 +47,3 @@\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n@@ -34,0 +51,1 @@\n+import java.util.function.Function;\n@@ -35,0 +53,1 @@\n+import java.util.stream.IntStream;\n@@ -36,7 +55,0 @@\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotEquals;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -116,0 +128,63 @@\n+    public record TestRootsSpec(Collection<Path> paths, Set<Path> expectedRoots) {\n+        public TestRootsSpec {\n+            paths.forEach(Objects::requireNonNull);\n+            expectedRoots.forEach(Objects::requireNonNull);\n+        }\n+\n+        void test() {\n+            final var pg = new PathGroup(paths.stream().collect(toMap(x -> new Object(), x -> x)));\n+            final var actualRoots = pg.roots().stream().collect(toSet());\n+            assertEquals(expectedRoots, actualRoots);\n+        }\n+\n+        static TestRootsSpec create(Collection<String> paths, Set<String> expectedRoots) {\n+            return new TestRootsSpec(paths.stream().map(Path::of).toList(), expectedRoots.stream().map(Path::of).collect(toSet()));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testRootsValues\")\n+    public void testRoots(TestRootsSpec testSpec) {\n+        testSpec.test();\n+    }\n+\n+    private static Collection<TestRootsSpec> testRootsValues() {\n+        return List.of(\n+                TestRootsSpec.create(List.of(\"\"), Set.of(\"\")),\n+                TestRootsSpec.create(List.of(\"\/\", \"a\/b\/c\", \"a\/b\", \"a\/b\", \"a\/b\/\"), Set.of(\"a\/b\", \"\/\"))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSizeInBytes(List<Path> paths, @TempDir Path tempDir) throws IOException {\n+        final var files = Set.of(\"AA.txt\", \"a\/b\/c\/BB.txt\", \"a\/b\/c\/DD.txt\", \"d\/foo.txt\").stream().map(Path::of).toList();\n+\n+        int counter = 0;\n+        for (var file : files) {\n+            file = tempDir.resolve(file);\n+            Files.createDirectories(file.getParent());\n+            Files.writeString(file, \"x\".repeat(++counter * 100));\n+        }\n+\n+        final var expectedSize = Stream.of(walkFiles(tempDir))\n+                .map(tempDir::resolve)\n+                .filter(Files::isRegularFile)\n+                .map(toFunction(Files::size))\n+                .mapToLong(Long::longValue).sum();\n+\n+        final var pg = new PathGroup(paths.stream().collect(toMap(x -> new Object(), x -> x))).resolveAt(tempDir);\n+\n+        assertEquals(expectedSize, pg.sizeInBytes());\n+    }\n+\n+    private static Collection<List<Path>> testSizeInBytes() {\n+        return Stream.of(\n+                List.of(\"\"),\n+                List.of(\"AA.txt\", \"a\/b\", \"d\", \"non-existant\", \"non-existant\/foo\/bar\"),\n+                List.of(\"AA.txt\", \"a\/b\", \"d\", \"a\/b\/c\/BB.txt\", \"a\/b\/c\/BB.txt\")\n+        ).map(v -> {\n+            return v.stream().map(Path::of).toList();\n+        }).toList();\n+    }\n+\n@@ -143,1 +218,1 @@\n-    enum TransformType { COPY, MOVE, HANDLER };\n+    enum TransformType { COPY, MOVE, HANDLER }\n@@ -268,0 +343,247 @@\n+    private enum PathRole {\n+        DESKTOP,\n+        LINUX_APPLAUNCHER_LIB,\n+    }\n+\n+    private static PathGroup linuxAppImage() {\n+        return new PathGroup(Map.of(\n+                PathRole.DESKTOP, Path.of(\"lib\"),\n+                PathRole.LINUX_APPLAUNCHER_LIB, Path.of(\"lib\/libapplauncher.so\")\n+        ));\n+    }\n+\n+    private static PathGroup linuxUsrTreePackageImage(Path prefix, String packageName) {\n+        final Path lib = prefix.resolve(Path.of(\"lib\", packageName));\n+        return new PathGroup(Map.of(\n+                PathRole.DESKTOP, lib,\n+                PathRole.LINUX_APPLAUNCHER_LIB, lib.resolve(\"lib\/libapplauncher.so\")\n+        ));\n+    }\n+\n+    @Test\n+    public void testLinuxLibapplauncher(@TempDir Path tempDir) throws IOException {\n+        final Path srcDir = tempDir.resolve(\"src\");\n+        final Path dstDir = tempDir.resolve(\"dst\");\n+\n+        final Map<PathRole, List<Path>> files = Map.of(\n+                PathRole.LINUX_APPLAUNCHER_LIB, List.of(Path.of(\"\")),\n+                PathRole.DESKTOP, List.of(Path.of(\"UsrUsrTreeTest.png\"))\n+        );\n+\n+        final var srcAppLayout = linuxAppImage().resolveAt(srcDir);\n+        final var dstAppLayout = linuxUsrTreePackageImage(dstDir.resolve(\"usr\"), \"foo\");\n+\n+        for (final var e : files.entrySet()) {\n+            final var pathRole = e.getKey();\n+            final var basedir = srcAppLayout.getPath(pathRole);\n+            for (var file : e.getValue().stream().map(basedir::resolve).toList()) {\n+                Files.createDirectories(file.getParent());\n+                Files.writeString(file, \"foo\");\n+            }\n+        }\n+\n+        srcAppLayout.copy(dstAppLayout);\n+\n+        Stream.of(walkFiles(dstDir)).filter(p -> {\n+            return p.getFileName().equals(dstAppLayout.getPath(PathRole.LINUX_APPLAUNCHER_LIB).getFileName());\n+        }).reduce((x, y) -> {\n+            throw new AssertionError(String.format(\"Multiple libapplauncher: [%s], [%s]\", x, y));\n+        });\n+    }\n+\n+\n+    public enum TestFileContent {\n+        A,\n+        B,\n+        C;\n+\n+        void assertFileContent(Path path) {\n+            try {\n+                final var expected = name();\n+                final var actual = Files.readString(path);\n+                assertEquals(expected, actual);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        void createFile(Path path) {\n+            try {\n+                Files.createDirectories(path.getParent());\n+                Files.writeString(path, name());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+    public record PathGroupCopy(Path from, Path to) {\n+        public PathGroupCopy {\n+            Objects.requireNonNull(from);\n+        }\n+\n+        public PathGroupCopy(Path from) {\n+            this(from, null);\n+        }\n+    }\n+\n+    public record TestFile(Path path, TestFileContent content) {\n+        public TestFile {\n+            Objects.requireNonNull(content);\n+            if (path.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        void assertFileContent(Path basedir) {\n+            content.assertFileContent(basedir.resolve(path));\n+        }\n+\n+        void create(Path basedir) {\n+            content.createFile(basedir.resolve(path));\n+        }\n+    }\n+\n+    public record TestCopySpec(List<PathGroupCopy> pathGroupSpecs, Collection<TestFile> src, Collection<TestFile> dst) {\n+        public TestCopySpec {\n+            pathGroupSpecs.forEach(Objects::requireNonNull);\n+            src.forEach(Objects::requireNonNull);\n+            dst.forEach(Objects::requireNonNull);\n+        }\n+\n+        PathGroup from() {\n+            return createPathGroup(PathGroupCopy::from);\n+        }\n+\n+        PathGroup to() {\n+            return createPathGroup(PathGroupCopy::to);\n+        }\n+\n+        void test(Path tempDir) throws IOException {\n+            final Path srcDir = tempDir.resolve(\"src\");\n+            final Path dstDir = tempDir.resolve(\"dst\");\n+\n+            src.stream().forEach(testFile -> {\n+                testFile.create(srcDir);\n+            });\n+\n+            from().resolveAt(srcDir).copy(to().resolveAt(dstDir));\n+\n+            dst.stream().forEach(testFile -> {\n+                testFile.assertFileContent(dstDir);\n+            });\n+\n+            Files.createDirectories(dstDir);\n+            final var actualFiles = Stream.of(walkFiles(dstDir)).filter(path -> {\n+                return Files.isRegularFile(dstDir.resolve(path));\n+            }).collect(toSet());\n+            final var expectedFiles = dst.stream().map(TestFile::path).collect(toSet());\n+\n+            assertEquals(expectedFiles, actualFiles);\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static class Builder {\n+            Builder addPath(String from, String to) {\n+                pathGroupSpecs.add(new PathGroupCopy(Path.of(from), Optional.ofNullable(to).map(Path::of).orElse(null)));\n+                return this;\n+            }\n+\n+            Builder file(TestFileContent content, String srcPath, String ...dstPaths) {\n+                srcFiles.putAll(Map.of(Path.of(srcPath), content));\n+                dstFiles.putAll(Stream.of(dstPaths).collect(toMap(Path::of, x -> content)));\n+                return this;\n+            }\n+\n+            TestCopySpec create() {\n+                return new TestCopySpec(pathGroupSpecs, convert(srcFiles), convert(dstFiles));\n+            }\n+\n+            private static Collection<TestFile> convert(Map<Path, TestFileContent> map) {\n+                return map.entrySet().stream().map(e -> {\n+                    return new TestFile(e.getKey(), e.getValue());\n+                }).toList();\n+            }\n+\n+            private final List<PathGroupCopy> pathGroupSpecs = new ArrayList<>();\n+            private final Map<Path, TestFileContent> srcFiles = new HashMap<>();\n+            private final Map<Path, TestFileContent> dstFiles = new HashMap<>();\n+        }\n+\n+        private PathGroup createPathGroup(Function<PathGroupCopy, Path> keyFunc) {\n+            return new PathGroup(IntStream.range(0, pathGroupSpecs.size()).mapToObj(Integer::valueOf).map(i -> {\n+                return Optional.ofNullable(keyFunc.apply(pathGroupSpecs.get(i))).map(path -> {\n+                    return Map.entry(i, path);\n+                });\n+            }).filter(Optional::isPresent).map(Optional::orElseThrow).collect(toMap(Map.Entry::getKey, Map.Entry::getValue)));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testCopy(TestCopySpec testSpec, @TempDir Path tempDir) throws IOException {\n+        testSpec.test(tempDir);\n+    }\n+\n+    private static Collection<TestCopySpec> testCopy() {\n+        return List.of(\n+                TestCopySpec.build().create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\/c\", \"a\")\n+                        .file(TestFileContent.A, \"a\/b\/c\/j\/k\/foo\", \"a\/j\/k\/foo\")\n+                        .create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\/c\", \"a\")\n+                        .addPath(\"a\/b\/c\", \"d\")\n+                        .file(TestFileContent.A, \"a\/b\/c\/j\/k\/foo\", \"a\/j\/k\/foo\", \"d\/j\/k\/foo\")\n+                        .create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\/c\", \"\")\n+                        .addPath(\"a\/b\/c\", \"d\")\n+                        .file(TestFileContent.A, \"a\/b\/c\/j\/k\/foo\", \"j\/k\/foo\", \"d\/j\/k\/foo\")\n+                        .create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\/c\", \"cc\")\n+                        .addPath(\"a\/b\/c\", \"dd\")\n+                        .addPath(\"a\/b\/c\/foo\", null)\n+                        .file(TestFileContent.A, \"a\/b\/c\/foo\")\n+                        .create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\/c\", \"cc\")\n+                        .addPath(\"a\/b\/c\", \"dd\")\n+                        .addPath(\"a\/b\/c\/foo\", null)\n+                        .file(TestFileContent.A, \"a\/b\/c\/foo\")\n+                        .file(TestFileContent.B, \"a\/b\/c\/bar\", \"cc\/bar\", \"dd\/bar\")\n+                        .create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\/c\", \"cc\")\n+                        .addPath(\"a\/b\/c\", \"dd\")\n+                        .addPath(\"a\/b\/c\/bar\", \"dd\/buz\")\n+                        .addPath(\"a\/b\/c\/foo\", null)\n+                        .file(TestFileContent.A, \"a\/b\/c\/foo\")\n+                        .file(TestFileContent.B, \"a\/b\/c\/bar\", \"dd\/buz\")\n+                        .create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\/c\", \"cc\")\n+                        .addPath(\"a\/b\/c\", \"dd\")\n+                        .addPath(\"a\/b\/c\/bar\", \"dd\/buz\")\n+                        .addPath(\"a\/b\/c\/bar\", \"cc\/rab\")\n+                        .addPath(\"a\/b\/c\/foo\", null)\n+                        .file(TestFileContent.A, \"a\/b\/c\/foo\")\n+                        .file(TestFileContent.B, \"a\/b\/c\/bar\", \"cc\/rab\", \"dd\/buz\")\n+                        .create(),\n+                TestCopySpec.build()\n+                        .addPath(\"a\/b\", null)\n+                        .addPath(\"a\/b\/c\", \"cc\")\n+                        .addPath(\"a\/b\/c\", \"dd\")\n+                        .addPath(\"a\/b\/c\/bar\", \"dd\/buz\")\n+                        .addPath(\"a\/b\/c\/bar\", \"cc\/rab\")\n+                        .file(TestFileContent.A, \"a\/b\/c\/foo\")\n+                        .file(TestFileContent.B, \"a\/b\/c\/bar\")\n+                        .create()\n+        );\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PathGroupTest.java","additions":330,"deletions":8,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.test.ApplicationLayout.linuxAppImage;\n+\n@@ -27,2 +30,3 @@\n-import java.util.stream.Collectors;\n-import jdk.jpackage.test.TKit;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.LinuxHelper;\n@@ -31,2 +35,1 @@\n-import jdk.jpackage.test.LinuxHelper;\n-import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.TKit;\n@@ -93,14 +96,7 @@\n-\n-            List<Path> packageFiles = LinuxHelper.getPackageFiles(cmd).collect(\n-                    Collectors.toList());\n-\n-            Consumer<Path> packageFileVerifier = file -> {\n-                TKit.assertTrue(packageFiles.stream().filter(\n-                        path -> path.equals(file)).findFirst().orElse(\n-                                null) != null, String.format(\n-                                \"Check file [%s] is in [%s] package\", file,\n-                                packageName));\n-            };\n-\n-            packageFileVerifier.accept(launcherPath);\n-            packageFileVerifier.accept(launcherCfgPath);\n+        })\n+        .addInstallVerifier(cmd -> {\n+            Stream.of(\n+                    cmd.appLauncherPath(),\n+                    cmd.appLauncherCfgPath(null),\n+                    cmd.appLayout().libapplauncher()\n+            ).map(cmd::pathToPackageFile).map(cmd.appInstallationDirectory()::relativize).forEachOrdered(cmd::assertFileInAppImage);\n","filename":"test\/jdk\/tools\/jpackage\/linux\/UsrTreeTest.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"}]}