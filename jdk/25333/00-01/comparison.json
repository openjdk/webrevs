{"files":[{"patch":"@@ -63,0 +63,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -64,0 +65,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -96,1 +98,1 @@\n-    private volatile boolean finished = false;\n+    private final CountDownLatch finishedLatch = new CountDownLatch(1);\n@@ -182,1 +184,1 @@\n-        if (!bound || started || finished) {\n+        if (!bound || started || isFinishing()) {\n@@ -226,1 +228,1 @@\n-        return finished;\n+        return finishedLatch.getCount()==0;\n@@ -246,0 +248,2 @@\n+        terminating = true;\n+\n@@ -248,1 +252,0 @@\n-        terminating = true;\n@@ -251,5 +254,17 @@\n-        long latest = System.nanoTime() + delay * 1000000000L;\n-        while (System.nanoTime() < latest) {\n-            delay();\n-            if (finished) {\n-                break;\n+\n+        try {\n+            \/\/ waiting for the duration of the delay, unless released before\n+            finishedLatch.await(delay, TimeUnit.SECONDS);\n+\n+        } catch (InterruptedException e) {\n+            logger.log(Level.TRACE, \"Error in awaiting the delay\");\n+\n+        } finally {\n+\n+            logger.log(Level.TRACE, \"closing connections\");\n+            finishedLatch.countDown();\n+            selector.wakeup();\n+            synchronized (allConnections) {\n+                for (HttpConnection c : allConnections) {\n+                    c.close();\n+                }\n@@ -257,7 +272,6 @@\n-        }\n-        logger.log(Level.TRACE, \"closing connections\");\n-        finished = true;\n-        selector.wakeup();\n-        synchronized (allConnections) {\n-            for (HttpConnection c : allConnections) {\n-                c.close();\n+            allConnections.clear();\n+            idleConnections.clear();\n+            newlyAcceptedConnections.clear();\n+            timer.cancel();\n+            if (reqRspTimeoutEnabled) {\n+                timer1.cancel();\n@@ -265,9 +279,1 @@\n-        }\n-        allConnections.clear();\n-        idleConnections.clear();\n-        newlyAcceptedConnections.clear();\n-        timer.cancel();\n-        if (reqRspTimeoutEnabled) {\n-            timer1.cancel();\n-        }\n-        logger.log(Level.TRACE, \"connections closed\");\n+            logger.log(Level.TRACE, \"connections closed\");\n@@ -275,7 +281,8 @@\n-        if (dispatcherThread != null && dispatcherThread != Thread.currentThread()) {\n-            logger.log(Level.TRACE, \"waiting for dispatcher thread\");\n-            try {\n-                dispatcherThread.join();\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                logger.log (Level.TRACE, \"ServerImpl.stop: \", e);\n+            if (dispatcherThread != null && dispatcherThread != Thread.currentThread()) {\n+                logger.log(Level.TRACE, \"waiting for dispatcher thread\");\n+                try {\n+                    dispatcherThread.join();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    logger.log(Level.TRACE, \"ServerImpl.stop: \", e);\n+                }\n@@ -283,0 +290,1 @@\n+            logger.log(Level.TRACE, \"server stopped\");\n@@ -284,1 +292,0 @@\n-        logger.log(Level.TRACE, \"server stopped\");\n@@ -409,1 +416,5 @@\n-                logger.log(Level.TRACE, \"Stop event requested\");\n+                logger.log(Level.TRACE, \"Handling Stop Requested Event\");\n+\n+                \/\/ checking if terminating is set to true\n+                final boolean terminatingCopy = terminating;\n+                assert terminatingCopy;\n@@ -411,2 +422,4 @@\n-                if (terminating && getExchangeCount() == 0) {\n-                    finished = true;\n+                if (getExchangeCount() == 0 && reqConnections.isEmpty()) {\n+                    finishedLatch.countDown();\n+                } else {\n+                    logger.log(Level.TRACE, \"Some requests are still pending\");\n@@ -425,2 +438,2 @@\n-                    if (terminating && exchanges == 0) {\n-                        finished = true;\n+                    if (terminating && exchanges == 0 && reqConnections.isEmpty()) {\n+                        finishedLatch.countDown();\n@@ -476,1 +489,1 @@\n-            while (!finished) {\n+             while (!isFinishing()) {\n@@ -480,1 +493,1 @@\n-                        if (events.size() > 0) {\n+                        if (!events.isEmpty()) {\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":53,"deletions":40,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * Does not contain ay information about a connection.\n+ * The event applies to the whole server and is not tied to any particular exchange.\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/StopRequestedEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.test.lib.Utils;\n@@ -49,0 +50,1 @@\n+ * @library \/test\/lib\n@@ -90,1 +92,1 @@\n-            } catch (InterruptedException e) {\n+            } catch (final InterruptedException e) {\n@@ -128,1 +130,1 @@\n-        final Duration delayDuration = Duration.ofSeconds(2);\n+        final Duration delayDuration = Duration.ofSeconds(Utils.adjustTimeout(5));\n@@ -160,1 +162,1 @@\n-        final Duration exchangeDuration = Duration.ofSeconds(10);\n+        final Duration exchangeDuration = Duration.ofSeconds(Utils.adjustTimeout(5));\n@@ -183,0 +185,61 @@\n+    \/**\n+     * Verify that a stop operation with a 1-second delay and a 20-second executor\n+     * completes after the delay expires.\n+     *\n+     * @throws InterruptedException if an unexpected interruption occurs\n+     *\/\n+    @Test\n+    public void shouldCompeteAfterDelayCustomHandler() throws IOException, InterruptedException {\n+\n+        \/\/ Custom server setup to include the executor\n+        log(\"Changing the server to the server with a custom executor\");\n+        \/\/ Create an HttpServer binding\n+        final InetAddress loopbackAddress = InetAddress.getLoopbackAddress();\n+        server = HttpServer.create(new InetSocketAddress(loopbackAddress, 0),\n+                0,\n+                \"\/\", exchange -> {\n+                    exchange.sendResponseHeaders(200, 0);\n+                    exchange.close();\n+                });\n+        final Duration executorSleepTime = Duration.ofSeconds(Utils.adjustTimeout(20));\n+        server.setExecutor(command -> Thread.ofVirtual().start(() -> {\n+            try {\n+                \/\/ Let the test know the executor was triggered\n+                start.countDown();\n+                log(\"Custom executor started, sleeping\");\n+                \/\/ waiting in the executor stage before running the exchange\n+                Thread.sleep(executorSleepTime);\n+                log(\"Custom executor sleep complete\");\n+                command.run();\/\/ start the exchange\n+\n+            } catch (final InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }));\n+        \/\/ Start server and client\n+        server.start();\n+        log(\"Custom setup complete\");\n+\n+        \/\/ Initiate an exchange\n+        startExchange();\n+        \/\/ Wait for the server to start the executor\n+        start.await();\n+        log(\"Exchange (Executor) started\");\n+\n+        \/\/ Time the shutdown sequence\n+        final Duration delayDuration = Duration.ofSeconds(1);\n+        log(\"Shutdown triggered with the delay of \" + delayDuration.getSeconds());\n+        final long elapsed = timeShutdown(delayDuration);\n+        log(\"Shutdown complete\");\n+\n+        \/\/ The shutdown should not await the exchange to complete\n+        if (elapsed >= executorSleepTime.toNanos()) {\n+            fail(\"HttpServer.stop terminated too late\");\n+        }\n+\n+        \/\/ The shutdown delay should have expired\n+        if (elapsed < delayDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated before delay\");\n+        }\n+    }\n+\n@@ -190,1 +253,1 @@\n-        final Duration delayDuration = Duration.ofSeconds(1);\n+        final Duration delayDuration = Duration.ofSeconds(Utils.adjustTimeout(5));\n@@ -238,1 +301,1 @@\n-                    \/\/ is called withing the dispatcher thread since we haven't\n+                    \/\/ is called within the dispatcher thread since we haven't\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ServerStopTerminationTest.java","additions":68,"deletions":5,"binary":false,"changes":73,"status":"modified"}]}