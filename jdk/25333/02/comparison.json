{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -64,0 +65,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -96,1 +98,1 @@\n-    private volatile boolean finished = false;\n+    private final CountDownLatch finishedLatch = new CountDownLatch(1);\n@@ -182,1 +184,1 @@\n-        if (!bound || started || finished) {\n+        if (!bound || started || isFinishing()) {\n@@ -226,1 +228,1 @@\n-        return finished;\n+        return finishedLatch.getCount()==0;\n@@ -229,0 +231,9 @@\n+    \/**\n+     * This method stops the server by adding a stop request event and\n+     * waiting for the server until the event is triggered or until the maximum delay is triggered.\n+     * <p>\n+     * This ensures that the server is stopped immediately after all exchanges are complete,\n+     * but still stops as soon as maximum delay is reached.\n+     *\n+     * @param delay maximum delay in stopping the server\n+     *\/\n@@ -233,0 +244,4 @@\n+\n+        logger.log(Level.TRACE, \"stopping\");\n+        \/\/ posting a stop event, which will flip finished flag if it finishes\n+        \/\/ before the timeout in this method\n@@ -234,0 +249,3 @@\n+\n+        addEvent(new StopRequestedEvent());\n+\n@@ -236,5 +254,17 @@\n-        long latest = System.currentTimeMillis() + delay * 1000;\n-        while (System.currentTimeMillis() < latest) {\n-            delay();\n-            if (finished) {\n-                break;\n+\n+        try {\n+            \/\/ waiting for the duration of the delay, unless released before\n+            finishedLatch.await(delay, TimeUnit.SECONDS);\n+\n+        } catch (InterruptedException e) {\n+            logger.log(Level.TRACE, \"Error in awaiting the delay\");\n+\n+        } finally {\n+\n+            logger.log(Level.TRACE, \"closing connections\");\n+            finishedLatch.countDown();\n+            selector.wakeup();\n+            synchronized (allConnections) {\n+                for (HttpConnection c : allConnections) {\n+                    c.close();\n+                }\n@@ -242,6 +272,6 @@\n-        }\n-        finished = true;\n-        selector.wakeup();\n-        synchronized (allConnections) {\n-            for (HttpConnection c : allConnections) {\n-                c.close();\n+            allConnections.clear();\n+            idleConnections.clear();\n+            newlyAcceptedConnections.clear();\n+            timer.cancel();\n+            if (reqRspTimeoutEnabled) {\n+                timer1.cancel();\n@@ -249,14 +279,10 @@\n-        }\n-        allConnections.clear();\n-        idleConnections.clear();\n-        newlyAcceptedConnections.clear();\n-        timer.cancel();\n-        if (reqRspTimeoutEnabled) {\n-            timer1.cancel();\n-        }\n-        if (dispatcherThread != null && dispatcherThread != Thread.currentThread()) {\n-            try {\n-                dispatcherThread.join();\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                logger.log (Level.TRACE, \"ServerImpl.stop: \", e);\n+            logger.log(Level.TRACE, \"connections closed\");\n+\n+            if (dispatcherThread != null && dispatcherThread != Thread.currentThread()) {\n+                logger.log(Level.TRACE, \"waiting for dispatcher thread\");\n+                try {\n+                    dispatcherThread.join();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    logger.log(Level.TRACE, \"ServerImpl.stop: \", e);\n+                }\n@@ -264,0 +290,1 @@\n+            logger.log(Level.TRACE, \"server stopped\");\n@@ -385,0 +412,18 @@\n+\n+            \/\/ Stopping marking the state as finished if stop is requested,\n+            \/\/ termination is in progress and exchange count is 0\n+            if (r instanceof StopRequestedEvent) {\n+                logger.log(Level.TRACE, \"Handling Stop Requested Event\");\n+\n+                \/\/ checking if terminating is set to true\n+                final boolean terminatingCopy = terminating;\n+                assert terminatingCopy;\n+\n+                if (getExchangeCount() == 0 && reqConnections.isEmpty()) {\n+                    finishedLatch.countDown();\n+                } else {\n+                    logger.log(Level.TRACE, \"Some requests are still pending\");\n+                }\n+                return;\n+            }\n+\n@@ -387,0 +432,1 @@\n+\n@@ -392,2 +438,2 @@\n-                    if (terminating && exchanges == 0) {\n-                        finished = true;\n+                    if (terminating && exchanges == 0 && reqConnections.isEmpty()) {\n+                        finishedLatch.countDown();\n@@ -443,1 +489,1 @@\n-            while (!finished) {\n+             while (!isFinishing()) {\n@@ -447,1 +493,1 @@\n-                        if (events.size() > 0) {\n+                        if (!events.isEmpty()) {\n@@ -594,12 +640,12 @@\n-        case REQUEST:\n-            reqConnections.remove(conn);\n-            break;\n-        case RESPONSE:\n-            rspConnections.remove(conn);\n-            break;\n-        case IDLE:\n-            idleConnections.remove(conn);\n-            break;\n-        case NEWLY_ACCEPTED:\n-            newlyAcceptedConnections.remove(conn);\n-            break;\n+            case REQUEST:\n+                reqConnections.remove(conn);\n+                break;\n+            case RESPONSE:\n+                rspConnections.remove(conn);\n+                break;\n+            case IDLE:\n+                idleConnections.remove(conn);\n+                break;\n+            case NEWLY_ACCEPTED:\n+                newlyAcceptedConnections.remove(conn);\n+                break;\n@@ -928,7 +974,0 @@\n-    void delay () {\n-        Thread.yield();\n-        try {\n-            Thread.sleep (200);\n-        } catch (InterruptedException e) {}\n-    }\n-\n@@ -941,0 +980,4 @@\n+    synchronized int getExchangeCount() {\n+        return exchangeCount;\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":95,"deletions":52,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver;\n+\n+\/**\n+ * Stopping event for the http server.\n+ * The event applies to the whole server and is not tied to any particular exchange.\n+ *\/\n+class StopRequestedEvent extends Event {\n+    StopRequestedEvent() {\n+        super(null);\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/StopRequestedEvent.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8304065\n+ * @summary HttpServer.stop() should terminate immediately if no exchanges are in progress,\n+ *          else terminate after a timeout\n+ * @library \/test\/lib\n+ * @run junit\/othervm -Djdk.internal.httpclient.debug=err ServerStopTerminationTest\n+ *\/\n+\n+public class ServerStopTerminationTest {\n+\n+    \/\/ enabling logging for the http server\n+    private final static Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    static {\n+        logger.setLevel(Level.FINEST);\n+        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.FINEST);\n+    }\n+\n+    \/\/ The server instance used to test shutdown timing\n+    private HttpServer server;\n+    \/\/ Client for initiating exchanges\n+    private HttpClient client;\n+    \/\/ Allows test to await the start of the exchange\n+    private final CountDownLatch start = new CountDownLatch(1);\n+    \/\/ Allows test to signal when exchange should complete\n+    private final CountDownLatch complete = new CountDownLatch(1);\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+\n+        \/\/ Create an HttpServer binding to the loopback address with an ephemeral port\n+        server = HttpServer.create();\n+        final InetAddress loopbackAddress = InetAddress.getLoopbackAddress();\n+        server.bind(\n+                new InetSocketAddress(loopbackAddress, 0),\n+                0);\n+\n+        \/\/ A handler with completion timing controlled by tests\n+        server.createContext(\"\/\", exchange -> {\n+            \/\/ Let the test know the exchange is started\n+            start.countDown();\n+            try {\n+                \/\/ Wait for test to signal that we can complete the exchange\n+                complete.await();\n+                exchange.sendResponseHeaders(200, 0);\n+                exchange.close();\n+            } catch (final InterruptedException e) {\n+                throw new IOException(e);\n+            }\n+        });\n+\n+        \/\/ Start server and client\n+        server.start();\n+        client = HttpClient.newBuilder().build();\n+    }\n+\n+    \/**\n+     * Clean up resources used by this test\n+     *\/\n+    @AfterEach\n+    public void cleanup() {\n+        client.shutdown();\n+    }\n+\n+    \/**\n+     * Verify that a stop operation with a 1-second exchange and a 2-second delay\n+     * completes when the exchange completes.\n+     *\n+     * @throws InterruptedException if an unexpected interruption occurs\n+     *\/\n+    @Test\n+    public void shouldAwaitActiveExchange() throws InterruptedException {\n+        \/\/ Initiate an exchange\n+        startExchange();\n+        \/\/ Wait for the server to receive the exchange\n+        start.await();\n+        log(\"Exchange started\");\n+\n+        \/\/ Complete the exchange one second into the future\n+        final Duration exchangeDuration = Duration.ofSeconds(1);\n+        completeExchange(exchangeDuration);\n+        log(\"Complete Exchange triggered\");\n+\n+        \/\/ Time the shutdown sequence\n+        final Duration delayDuration = Duration.ofSeconds(Utils.adjustTimeout(5));\n+        log(\"Shutdown triggered with the delay of \" + delayDuration.getSeconds());\n+        final long elapsed = timeShutdown(delayDuration);\n+        log(\"Shutdown complete\");\n+\n+        \/\/ The shutdown should take at least as long as the exchange duration\n+        if (elapsed < exchangeDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated before exchange completed\");\n+        }\n+\n+        \/\/ The delay should not have expired\n+        if (elapsed >= delayDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated after delay expired\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a stop operation with a 1-second delay and a 10-second exchange\n+     * completes after the delay expires.\n+     *\n+     * @throws InterruptedException if an unexpected interruption occurs\n+     *\/\n+    @Test\n+    public void shouldCompeteAfterDelay() throws InterruptedException {\n+        \/\/ Initiate an exchange\n+        startExchange();\n+        \/\/ Wait for the server to receive the exchange\n+        start.await();\n+        log(\"Exchange started\");\n+\n+        \/\/ Complete the exchange 10 second into the future.\n+        \/\/ Runs in parallel, so won't block the server stop\n+        final Duration exchangeDuration = Duration.ofSeconds(Utils.adjustTimeout(5));\n+        completeExchange(exchangeDuration);\n+        log(\"Complete Exchange triggered\");\n+\n+\n+        \/\/ Time the shutdown sequence\n+        final Duration delayDuration = Duration.ofSeconds(1);\n+        log(\"Shutdown triggered with the delay of \" + delayDuration.getSeconds());\n+        final long elapsed = timeShutdown(delayDuration);\n+        log(\"Shutdown complete\");\n+\n+\n+        \/\/ The shutdown should not await the exchange to complete\n+        if (elapsed >= exchangeDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated too late\");\n+        }\n+\n+        \/\/ The shutdown delay should have expired\n+        if (elapsed < delayDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated before delay\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a stop operation with a 1-second delay and a 20-second executor\n+     * completes after the delay expires.\n+     *\n+     * @throws InterruptedException if an unexpected interruption occurs\n+     *\/\n+    @Test\n+    public void shouldCompeteAfterDelayCustomHandler() throws IOException, InterruptedException {\n+\n+        \/\/ Custom server setup to include the executor\n+        log(\"Changing the server to the server with a custom executor\");\n+        \/\/ Create an HttpServer binding\n+        final InetAddress loopbackAddress = InetAddress.getLoopbackAddress();\n+        server = HttpServer.create(new InetSocketAddress(loopbackAddress, 0),\n+                0,\n+                \"\/\", exchange -> {\n+                    exchange.sendResponseHeaders(200, 0);\n+                    exchange.close();\n+                });\n+        final Duration executorSleepTime = Duration.ofSeconds(Utils.adjustTimeout(20));\n+        server.setExecutor(command -> Thread.ofVirtual().start(() -> {\n+            try {\n+                \/\/ Let the test know the executor was triggered\n+                start.countDown();\n+                log(\"Custom executor started, sleeping\");\n+                \/\/ waiting in the executor stage before running the exchange\n+                Thread.sleep(executorSleepTime);\n+                log(\"Custom executor sleep complete\");\n+                command.run();\/\/ start the exchange\n+\n+            } catch (final InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }));\n+        \/\/ Start server and client\n+        server.start();\n+        log(\"Custom setup complete\");\n+\n+        \/\/ Initiate an exchange\n+        startExchange();\n+        \/\/ Wait for the server to start the executor\n+        start.await();\n+        log(\"Exchange (Executor) started\");\n+\n+        \/\/ Time the shutdown sequence\n+        final Duration delayDuration = Duration.ofSeconds(1);\n+        log(\"Shutdown triggered with the delay of \" + delayDuration.getSeconds());\n+        final long elapsed = timeShutdown(delayDuration);\n+        log(\"Shutdown complete\");\n+\n+        \/\/ The shutdown should not await the exchange to complete\n+        if (elapsed >= executorSleepTime.toNanos()) {\n+            fail(\"HttpServer.stop terminated too late\");\n+        }\n+\n+        \/\/ The shutdown delay should have expired\n+        if (elapsed < delayDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated before delay\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that an HttpServer with no active exchanges terminates\n+     * before the delay timeout occurs.\n+     *\/\n+    @Test\n+    public void noActiveExchanges() {\n+        \/\/ With no active exchanges, shutdown should complete immediately\n+        final Duration delayDuration = Duration.ofSeconds(Utils.adjustTimeout(5));\n+        final long elapsed = timeShutdown(delayDuration);\n+        log(\"Shutting down the server with no exchanges\");\n+        if (elapsed >= delayDuration.toNanos()) {\n+            fail(\"Expected HttpServer.stop to terminate immediately with no active exchanges\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that an already stopped HttpServer can be stopped\n+     *\/\n+    @Test\n+    public void shouldAllowRepeatedStop() {\n+        final Duration delayDuration = Duration.ofSeconds(1);\n+        log(\"Shutting down the server the first time\");\n+        timeShutdown(delayDuration);\n+        log(\"Shutting down the server the second time\");\n+        timeShutdown(delayDuration);\n+    }\n+\n+    \/**\n+     * Run HttpServer::stop with the given delay, returning the\n+     * elapsed time in nanoseconds for the shutdown to complete\n+     *\/\n+    private long timeShutdown(Duration delayDuration) {\n+        final long startTime = System.nanoTime();\n+\n+        server.stop((int) delayDuration.toSeconds());\n+        return System.nanoTime() - startTime;\n+    }\n+\n+    \/**\n+     * Initiate an exchange asynchronously\n+     *\/\n+    private void startExchange() {\n+        try {\n+            final HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URIBuilder.newBuilder()\n+                            .scheme(\"http\")\n+                            .loopback()\n+                            .port(server.getAddress().getPort())\n+                            .build())\n+                    \/\/ We need to use POST to prevent retries\n+                    .POST(HttpRequest.BodyPublishers.ofString(\"\"))\n+                    .build();\n+\n+            client.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n+                    .whenCompleteAsync((r, t) -> {\n+                        System.out.println(\"request completed (\" + r + \", \" + t + \")\");\n+                        \/\/ count the latch down to allow the handler to complete\n+                        \/\/ and the server's dispatcher thread to proceed; The handler\n+                        \/\/ is called within the dispatcher thread since we haven't\n+                        \/\/ set any executor on the server side\n+                        complete.countDown();\n+                    });\n+        } catch (final URISyntaxException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * At the specified time into the future, signal to the\n+     * handler that the exchange can complete.\n+     *\n+     * @param exchangeDuration the duration to wait before signaling completion\n+     *\/\n+    private void completeExchange(Duration exchangeDuration) {\n+        Thread.ofVirtual().start(() -> {\n+            try {\n+                Thread.sleep(exchangeDuration);\n+                complete.countDown();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * This logging method will log the name of the method which called the log\n+     * for easier debug\n+     *\n+     * @param message message to include in the log\n+     *\/\n+    private void log(final String message) {\n+\n+        String filename = \"\";\n+        try {\n+            filename = Thread.currentThread()\n+                    .getStackTrace()[2].getMethodName();\n+        } finally {\n+            System.out.printf(\"{%s}: %s%n\", filename, message);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ServerStopTerminationTest.java","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"}]}