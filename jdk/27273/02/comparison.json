{"files":[{"patch":"@@ -52,3 +52,0 @@\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n@@ -56,1 +53,0 @@\n-import java.nio.file.StandardCopyOption;\n@@ -65,0 +61,2 @@\n+import jdk.test.lib.os.linux.Smaps;\n+import jdk.test.lib.os.linux.Smaps.Range;\n@@ -103,1 +101,1 @@\n-            BigInteger heapStart = extractHeapStartFromLog();\n+            String heapStart = extractHeapStartFromLog();\n@@ -105,1 +103,2 @@\n-            Path smaps = makeSmapsCopy();\n+            Smaps.Parser smapsParser = new Smaps.Parser();\n+            smapsParser.parse();\n@@ -107,45 +106,3 @@\n-            final Pattern addressRangePattern = Pattern.compile(\"([0-9a-f]*?)-([0-9a-f]*?) .*\");\n-            final Pattern thpEligiblePattern = Pattern.compile(\"THPeligible:\\\\s+(\\\\d)\\\\s*\");\n-\n-            Scanner smapsFile = new Scanner(smaps);\n-            while (smapsFile.hasNextLine()) {\n-                Matcher addressRangeMatcher = addressRangePattern.matcher(smapsFile.nextLine());\n-                if (!addressRangeMatcher.matches()) {\n-                    continue;\n-                }\n-\n-                \/\/ Found an address range line in the smaps file\n-\n-                BigInteger addressStart = new BigInteger(addressRangeMatcher.group(1), 16);\n-                BigInteger addressEnd = new BigInteger(addressRangeMatcher.group(2), 16);\n-\n-                \/\/ Linux sometimes merges adjacent VMAs so we can't search for a range that\n-                \/\/ exactly matches the heap range. Instead we look for the first range that\n-                \/\/ contains the start of the heap and verify that that range is THP eligible.\n-\n-                if (addressStart.compareTo(heapStart) > 0 || heapStart.compareTo(addressEnd) >= 0) {\n-                    continue;\n-                }\n-\n-                \/\/ Found a range that contains the start of the heap, verify that it is THP eligible.\n-\n-                while (smapsFile.hasNextLine()) {\n-                    Matcher m = thpEligiblePattern.matcher(smapsFile.nextLine());\n-                    if (!m.matches()) {\n-                        continue;\n-                    }\n-\n-                    \/\/ Found the THPeligible line\n-\n-                    if (m.group(1).equals(\"1\")) {\n-                        \/\/ Success - THPeligible is 1, heap can be backed by huge pages\n-                        return;\n-                    }\n-\n-                    throw new RuntimeException(\"The address range 0x\" + addressStart.toString(16)\n-                                               + \"-0x\" + addressEnd.toString(16)\n-                                               + \" that contains the heap start\" + heapStart\n-                                               + \" is not THPeligible\");\n-                }\n-\n-                throw new RuntimeException(\"Couldn't find THPeligible in the smaps file\");\n+            Range range = smapsParser.getRange(heapStart);\n+            if (range == null) {\n+                throw new AssertionError(\"Could not find heap section in smaps file. No memory range found for heap start: \" + heapStart);\n@@ -154,1 +111,7 @@\n-            throw new RuntimeException(\"Could not find an address range containing the heap start \" + heapStart + \" in the smaps file\");\n+            if (!range.isTransparentHuge()) {\n+                \/\/ Failed to verify THP for heap\n+                throw new RuntimeException(\"The address range 0x\" + range.getStart().toString(16)\n+                        + \"-0x\" + range.getEnd().toString(16)\n+                        + \" that contains the heap start\" + heapStart\n+                        + \" is not THPeligible\");\n+            }\n@@ -157,1 +120,1 @@\n-        private static BigInteger extractHeapStartFromLog() throws Exception {\n+        private static String extractHeapStartFromLog() throws Exception {\n@@ -163,3 +126,1 @@\n-                String line = logFile.nextLine();\n-\n-                Matcher m = heapAddress.matcher(line);\n+                Matcher m = heapAddress.matcher(logFile.nextLine());\n@@ -167,1 +128,1 @@\n-                    return new BigInteger(m.group(1), 16);\n+                    return m.group(1);\n@@ -173,7 +134,0 @@\n-\n-        private static Path makeSmapsCopy() throws Exception {\n-            Path src = Paths.get(\"\/proc\/self\/smaps\");\n-            Path dest = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + \".txt\");\n-            Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);\n-            return dest;\n-        }\n","filename":"test\/hotspot\/jtreg\/gc\/TestTransparentHugePagesHeap.java","additions":18,"deletions":64,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,5 +107,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.util.LinkedList;\n@@ -116,0 +111,2 @@\n+import jdk.test.lib.os.linux.Smaps;\n+import jdk.test.lib.os.linux.Smaps.Range;\n@@ -122,2 +119,0 @@\n-    \/\/ Store address ranges with known page size.\n-    private static LinkedList<RangeWithPageSize> ranges = new LinkedList<>();\n@@ -127,109 +122,0 @@\n-    \/\/ Copy smaps locally\n-    \/\/ (To minimize chances of concurrent modification when parsing, as well as helping with error analysis)\n-    private static Path copySmaps() throws Exception {\n-        Path p1 = Paths.get(\"\/proc\/self\/smaps\");\n-        Path p2 = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + \"-\" + (run++) + \".txt\");\n-        Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING);\n-        debug(\"Copied \" + p1 + \" to \" + p2 + \"...\");\n-        return p2;\n-    }\n-\n-    \/\/ Parse \/proc\/self\/smaps.\n-    private static void parseSmaps() throws Exception {\n-        \/\/ We can override the smaps file to parse to pass in a pre-fetched one\n-        String smapsFileToParse = System.getProperty(\"smaps-file\");\n-        if (smapsFileToParse != null) {\n-            parseSmaps(Paths.get(smapsFileToParse));\n-        } else {\n-            Path smapsCopy = copySmaps();\n-            parseSmaps(smapsCopy);\n-        }\n-    }\n-\n-    static class SmapsParser {\n-        \/\/ This is a simple smaps parser; it will recognize smaps section start lines\n-        \/\/  (e.g. \"40fa00000-439b80000 rw-p 00000000 00:00 0 \") and look for keywords inside the section.\n-        \/\/ Section will be finished and written into a RangeWithPageSize when either the next section is found\n-        \/\/  or the end of file is encountered.\n-        static final Pattern SECTION_START_PATT = Pattern.compile(\"^([a-f0-9]+)-([a-f0-9]+) [\\\\-rwpsx]{4}.*\");\n-        static final Pattern KERNEL_PAGESIZE_PATT = Pattern.compile(\"^KernelPageSize:\\\\s*(\\\\d*) kB\");\n-        static final Pattern THP_ELIGIBLE_PATT = Pattern.compile(\"^THPeligible:\\\\s+(\\\\d*)\");\n-        static final Pattern VMFLAGS_PATT = Pattern.compile(\"^VmFlags: ([\\\\w\\\\? ]*)\");\n-        String start;\n-        String end;\n-        String ps;\n-        String thpEligible;\n-        String vmFlags;\n-        int lineno;\n-\n-        void reset() {\n-            start = null;\n-            end = null;\n-            ps = null;\n-            thpEligible = null;\n-            vmFlags = null;\n-        }\n-\n-        public void finish() {\n-            if (start != null) {\n-                RangeWithPageSize range = new RangeWithPageSize(start, end, ps, thpEligible, vmFlags);\n-                ranges.add(range);\n-                debug(\"Added range: \" + range);\n-                reset();\n-            }\n-        }\n-\n-        void eatNext(String line) {\n-            \/\/  For better debugging experience call finish here before the debug() call.\n-            Matcher matSectionStart = SECTION_START_PATT.matcher(line);\n-            if (matSectionStart.matches()) {\n-                finish();\n-            }\n-\n-            debug(\"\" + (lineno++) + \" \" + line);\n-\n-            if (matSectionStart.matches()) {\n-                start = matSectionStart.group(1);\n-                end = matSectionStart.group(2);\n-                ps = null;\n-                vmFlags = null;\n-                return;\n-            } else {\n-                Matcher matKernelPageSize = KERNEL_PAGESIZE_PATT.matcher(line);\n-                if (matKernelPageSize.matches()) {\n-                    ps = matKernelPageSize.group(1);\n-                    return;\n-                }\n-                Matcher matTHPEligible = THP_ELIGIBLE_PATT.matcher(line);\n-                if (matTHPEligible.matches()) {\n-                    thpEligible = matTHPEligible.group(1);\n-                    return;\n-                }\n-                Matcher matVmFlags = VMFLAGS_PATT.matcher(line);\n-                if (matVmFlags.matches()) {\n-                    vmFlags = matVmFlags.group(1);\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/ Parse \/proc\/self\/smaps\n-    private static void parseSmaps(Path smapsFileToParse) throws Exception {\n-        debug(\"Parsing: \" + smapsFileToParse.getFileName() + \"...\");\n-        SmapsParser parser = new SmapsParser();\n-        Files.lines(smapsFileToParse).forEach(parser::eatNext);\n-        parser.finish();\n-    }\n-\n-    \/\/ Search for a range including the given address.\n-    private static RangeWithPageSize getRange(String addr) {\n-        long laddr = Long.decode(addr);\n-        for (RangeWithPageSize range : ranges) {\n-            if (range.includes(laddr)) {\n-                return range;\n-            }\n-        }\n-        return null;\n-    }\n-\n@@ -275,1 +161,2 @@\n-        parseSmaps();\n+        Smaps.Parser smapsParser = new Smaps.Parser();\n+        smapsParser.parse(\"-\" + (run++));\n@@ -292,1 +179,1 @@\n-                RangeWithPageSize range = getRange(address);\n+                Range range = smapsParser.getRange(address);\n@@ -328,72 +215,0 @@\n-\n-\/\/ Class used to store information about memory ranges parsed\n-\/\/ from \/proc\/self\/smaps. The file contain a lot of information\n-\/\/ about the different mappings done by an application, but the\n-\/\/ lines we care about are:\n-\/\/ 700000000-73ea00000 rw-p 00000000 00:00 0\n-\/\/ ...\n-\/\/ KernelPageSize:        4 kB\n-\/\/ ...\n-\/\/ VmFlags: rd wr mr mw me ac sd\n-\/\/\n-\/\/ We use the VmFlags to know what kind of huge pages are used.\n-\/\/ For transparent huge pages the KernelPageSize field will not\n-\/\/ report the large page size.\n-class RangeWithPageSize {\n-    private long start;\n-    private long end;\n-    private long pageSize;\n-    private boolean thpEligible;\n-    private boolean vmFlagHG;\n-    private boolean vmFlagHT;\n-    private boolean isTHP;\n-\n-    public RangeWithPageSize(String start, String end, String pageSize, String thpEligible, String vmFlags) {\n-        \/\/ Note: since we insist on kernels >= 3.8, all the following information should be present\n-        \/\/  (none of the input strings be null).\n-        this.start = Long.parseUnsignedLong(start, 16);\n-        this.end = Long.parseUnsignedLong(end, 16);\n-        this.pageSize = Long.parseLong(pageSize);\n-        this.thpEligible = thpEligible == null ? false : (Integer.parseInt(thpEligible) == 1);\n-\n-        vmFlagHG = false;\n-        vmFlagHT = false;\n-        \/\/ Check if the vmFlags line include:\n-        \/\/ * ht - Meaning the range is mapped using explicit huge pages.\n-        \/\/ * hg - Meaning the range is madvised huge.\n-        for (String flag : vmFlags.split(\" \")) {\n-            if (flag.equals(\"ht\")) {\n-                vmFlagHT = true;\n-            } else if (flag.equals(\"hg\")) {\n-                vmFlagHG = true;\n-            }\n-        }\n-\n-        \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false,\n-        \/\/ therefore also check thpEligible. If this is still causing problems in the future,\n-        \/\/ we might have to check the AnonHugePages field.\n-\n-        isTHP = vmFlagHG || this.thpEligible;\n-    }\n-\n-    public long getPageSize() {\n-        return pageSize;\n-    }\n-\n-    public boolean isTransparentHuge() {\n-        return isTHP;\n-    }\n-\n-    public boolean isExplicitHuge() {\n-        return vmFlagHT;\n-    }\n-\n-    public boolean includes(long addr) {\n-        return start <= addr && addr < end;\n-    }\n-\n-    public String toString() {\n-        return \"[\" + Long.toHexString(start) + \", \" + Long.toHexString(end) + \") \" +\n-               \"pageSize=\" + pageSize + \"KB isTHP=\" + isTHP + \" isHUGETLB=\" + vmFlagHT;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":6,"deletions":191,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.os.linux;\n+\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class Smaps {\n+\n+    \/\/ This is a simple smaps parser; it will recognize smaps section start lines\n+    \/\/  (e.g. \"40fa00000-439b80000 rw-p 00000000 00:00 0 \") and look for keywords inside the section.\n+    \/\/ Section will be finished and written into a RangeWithPageSize when either the next section is found\n+    \/\/  or the end of file is encountered.\n+    public static class Parser {\n+        private static final List<Range> ranges = new LinkedList<>();\n+\n+        private static final Pattern SECTION_START_PATT = Pattern.compile(\"^([a-f0-9]+)-([a-f0-9]+) [\\\\-rwpsx]{4}.*\");\n+        private static final Pattern KERNEL_PAGESIZE_PATT = Pattern.compile(\"^KernelPageSize:\\\\s*(\\\\d*) kB\");\n+        private static final Pattern THP_ELIGIBLE_PATT = Pattern.compile(\"^THPeligible:\\\\s+(\\\\d*)\");\n+        private static final Pattern VMFLAGS_PATT = Pattern.compile(\"^VmFlags: ([\\\\w\\\\? ]*)\");\n+\n+        String start;\n+        String end;\n+        String ps;\n+        String thpEligible;\n+        String vmFlags;\n+\n+        void reset() {\n+            start = null;\n+            end = null;\n+            ps = null;\n+            thpEligible = null;\n+            vmFlags = null;\n+        }\n+\n+        public void finish() {\n+            if (start != null) {\n+                Range range = new Range(start, end, ps, thpEligible, vmFlags);\n+                ranges.add(range);\n+                reset();\n+            }\n+        }\n+\n+        public void eatNext(String line) {\n+            \/\/  For better debugging experience call finish here before the debug() call.\n+            Matcher matSectionStart = SECTION_START_PATT.matcher(line);\n+            if (matSectionStart.matches()) {\n+                finish();\n+            }\n+\n+            if (matSectionStart.matches()) {\n+                start = matSectionStart.group(1);\n+                end = matSectionStart.group(2);\n+                ps = null;\n+                vmFlags = null;\n+                return;\n+            } else {\n+                Matcher matKernelPageSize = KERNEL_PAGESIZE_PATT.matcher(line);\n+                if (matKernelPageSize.matches()) {\n+                    ps = matKernelPageSize.group(1);\n+                    return;\n+                }\n+                Matcher matTHPEligible = THP_ELIGIBLE_PATT.matcher(line);\n+                if (matTHPEligible.matches()) {\n+                    thpEligible = matTHPEligible.group(1);\n+                    return;\n+                }\n+                Matcher matVmFlags = VMFLAGS_PATT.matcher(line);\n+                if (matVmFlags.matches()) {\n+                    vmFlags = matVmFlags.group(1);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        \/\/ Copy smaps locally\n+        \/\/ (To minimize chances of concurrent modification when parsing, as well as helping with error analysis)\n+        private Path copySmaps(String postfix) throws Exception {\n+            Path p1 = Paths.get(\"\/proc\/self\/smaps\");\n+            Path p2 = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + postfix + \".txt\");\n+            Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING);\n+            return p2;\n+        }\n+\n+        \/\/ Parse \/proc\/self\/smaps.\n+        public void parse() throws Exception {\n+            parse(\"\");\n+        }\n+\n+        public void parse(String postfix) throws Exception {\n+            \/\/ We can override the smaps file to parse to pass in a pre-fetched one\n+            String smapsFileToParse = System.getProperty(\"smaps-file\");\n+            if (smapsFileToParse != null) {\n+                parse(Paths.get(smapsFileToParse));\n+            } else {\n+                Path smapsCopy = copySmaps(postfix);\n+                parse(smapsCopy);\n+            }\n+        }\n+\n+        \/\/ Parse \/proc\/self\/smaps\n+        public void parse(Path smapsFileToParse) throws Exception {\n+            Files.lines(smapsFileToParse).forEach(this::eatNext);\n+            this.finish();\n+        }\n+\n+        \/\/ Search for a range including the given address.\n+        public Range getRange(String addr) {\n+            BigInteger laddr = new BigInteger(addr.substring(2), 16);\n+            for (Range range : ranges) {\n+                if (range.includes(laddr)) {\n+                    return range;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Class used to store information about memory ranges parsed\n+    \/\/ from \/proc\/self\/smaps. The file contain a lot of information\n+    \/\/ about the different mappings done by an application, but the\n+    \/\/ lines we care about are:\n+    \/\/ 700000000-73ea00000 rw-p 00000000 00:00 0\n+    \/\/ ...\n+    \/\/ KernelPageSize:        4 kB\n+    \/\/ ...\n+    \/\/ VmFlags: rd wr mr mw me ac sd\n+    \/\/\n+    \/\/ We use the VmFlags to know what kind of huge pages are used.\n+    \/\/ For transparent huge pages the KernelPageSize field will not\n+    \/\/ report the large page size.\n+    public static class Range {\n+\n+        private BigInteger start;\n+        private BigInteger end;\n+        private long pageSize;\n+        private boolean thpEligible;\n+        private boolean vmFlagHG;\n+        private boolean vmFlagHT;\n+        private boolean isTHP;\n+\n+        public Range(String start, String end, String pageSize, String thpEligible, String vmFlags) {\n+            \/\/ Note: since we insist on kernels >= 3.8, all the following information should be present\n+            \/\/  (none of the input strings be null).\n+            this.start = new BigInteger(start, 16);\n+            this.end = new BigInteger(end, 16);\n+            this.pageSize = Long.parseLong(pageSize);\n+            this.thpEligible = thpEligible == null ? false : (Integer.parseInt(thpEligible) == 1);\n+\n+            vmFlagHG = false;\n+            vmFlagHT = false;\n+            \/\/ Check if the vmFlags line include:\n+            \/\/ * ht - Meaning the range is mapped using explicit huge pages.\n+            \/\/ * hg - Meaning the range is madvised huge.\n+            for (String flag : vmFlags.split(\" \")) {\n+                if (flag.equals(\"ht\")) {\n+                    vmFlagHT = true;\n+                } else if (flag.equals(\"hg\")) {\n+                    vmFlagHG = true;\n+                }\n+            }\n+\n+            \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false,\n+            \/\/ therefore also check thpEligible. If this is still causing problems in the future,\n+            \/\/ we might have to check the AnonHugePages field.\n+\n+            isTHP = vmFlagHG || this.thpEligible;\n+        }\n+\n+        public BigInteger getStart() {\n+            return start;\n+        }\n+\n+        public BigInteger getEnd() {\n+            return end;\n+        }\n+\n+        public long getPageSize() {\n+            return pageSize;\n+        }\n+\n+        public boolean isTransparentHuge() {\n+            return isTHP;\n+        }\n+\n+        public boolean isExplicitHuge() {\n+            return vmFlagHT;\n+        }\n+\n+        public boolean includes(BigInteger addr) {\n+            boolean isGreaterThanOrEqualStart = start.compareTo(addr) <= 0;\n+            boolean isLessThanEnd = addr.compareTo(end) < 0;\n+\n+            return isGreaterThanOrEqualStart && isLessThanEnd;\n+        }\n+\n+        public String toString() {\n+            return \"[\" + start.toString(16) + \", \" + end.toString(16) + \") \" +\n+                    \"pageSize=\" + pageSize + \"KB isTHP=\" + isTHP + \" isHUGETLB=\" + vmFlagHT;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/os\/linux\/Smaps.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"}]}