{"files":[{"patch":"@@ -61,1 +61,2 @@\n-import jdk.test.lib.SmapsParser;\n+import jdk.test.lib.os.linux.Smaps;\n+import jdk.test.lib.os.linux.Smaps.Range;\n@@ -102,1 +103,1 @@\n-            SmapsParser smapsParser = new SmapsParser();\n+            Smaps.Parser smapsParser = new Smaps.Parser();\n@@ -105,1 +106,1 @@\n-            SmapsParser.RangeWithPageSize range = smapsParser.getRange(heapStart);\n+            Range range = smapsParser.getRange(heapStart);\n","filename":"test\/hotspot\/jtreg\/gc\/TestTransparentHugePagesHeap.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,2 @@\n-import jdk.test.lib.SmapsParser;\n-import jdk.test.lib.SmapsParser.RangeWithPageSize;\n+import jdk.test.lib.os.linux.Smaps;\n+import jdk.test.lib.os.linux.Smaps.Range;\n@@ -161,1 +161,1 @@\n-        SmapsParser smapsParser = new SmapsParser();\n+        Smaps.Parser smapsParser = new Smaps.Parser();\n@@ -179,1 +179,1 @@\n-                RangeWithPageSize range = smapsParser.getRange(address);\n+                Range range = smapsParser.getRange(address);\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib;\n-\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-public class SmapsParser {\n-    private static List<RangeWithPageSize> ranges = new LinkedList<>();\n-\n-    \/\/ This is a simple smaps parser; it will recognize smaps section start lines\n-    \/\/  (e.g. \"40fa00000-439b80000 rw-p 00000000 00:00 0 \") and look for keywords inside the section.\n-    \/\/ Section will be finished and written into a RangeWithPageSize when either the next section is found\n-    \/\/  or the end of file is encountered.\n-    private static final Pattern SECTION_START_PATT = Pattern.compile(\"^([a-f0-9]+)-([a-f0-9]+) [\\\\-rwpsx]{4}.*\");\n-    private static final Pattern KERNEL_PAGESIZE_PATT = Pattern.compile(\"^KernelPageSize:\\\\s*(\\\\d*) kB\");\n-    private static final Pattern THP_ELIGIBLE_PATT = Pattern.compile(\"^THPeligible:\\\\s+(\\\\d*)\");\n-    private static final Pattern VMFLAGS_PATT = Pattern.compile(\"^VmFlags: ([\\\\w\\\\? ]*)\");\n-\n-    String start;\n-    String end;\n-    String ps;\n-    String thpEligible;\n-    String vmFlags;\n-\n-    void reset() {\n-        start = null;\n-        end = null;\n-        ps = null;\n-        thpEligible = null;\n-        vmFlags = null;\n-    }\n-\n-    public void finish() {\n-        if (start != null) {\n-            RangeWithPageSize range = new RangeWithPageSize(start, end, ps, thpEligible, vmFlags);\n-            ranges.add(range);\n-            reset();\n-        }\n-    }\n-\n-    public void eatNext(String line) {\n-        \/\/  For better debugging experience call finish here before the debug() call.\n-        Matcher matSectionStart = SECTION_START_PATT.matcher(line);\n-        if (matSectionStart.matches()) {\n-            finish();\n-        }\n-\n-        if (matSectionStart.matches()) {\n-            start = matSectionStart.group(1);\n-            end = matSectionStart.group(2);\n-            ps = null;\n-            vmFlags = null;\n-            return;\n-        } else {\n-            Matcher matKernelPageSize = KERNEL_PAGESIZE_PATT.matcher(line);\n-            if (matKernelPageSize.matches()) {\n-                ps = matKernelPageSize.group(1);\n-                return;\n-            }\n-            Matcher matTHPEligible = THP_ELIGIBLE_PATT.matcher(line);\n-            if (matTHPEligible.matches()) {\n-                thpEligible = matTHPEligible.group(1);\n-                return;\n-            }\n-            Matcher matVmFlags = VMFLAGS_PATT.matcher(line);\n-            if (matVmFlags.matches()) {\n-                vmFlags = matVmFlags.group(1);\n-                return;\n-            }\n-        }\n-    }\n-\n-    \/\/ Copy smaps locally\n-    \/\/ (To minimize chances of concurrent modification when parsing, as well as helping with error analysis)\n-    private Path copySmaps(String postfix) throws Exception {\n-        Path p1 = Paths.get(\"\/proc\/self\/smaps\");\n-        Path p2 = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + postfix + \".txt\");\n-        Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING);\n-        return p2;\n-    }\n-\n-    \/\/ Parse \/proc\/self\/smaps.\n-    public void parse() throws Exception {\n-        parse(\"\");\n-    }\n-\n-    public void parse(String postfix) throws Exception {\n-        \/\/ We can override the smaps file to parse to pass in a pre-fetched one\n-        String smapsFileToParse = System.getProperty(\"smaps-file\");\n-        if (smapsFileToParse != null) {\n-            parse(Paths.get(smapsFileToParse));\n-        } else {\n-            Path smapsCopy = copySmaps(postfix);\n-            parse(smapsCopy);\n-        }\n-    }\n-\n-    \/\/ Parse \/proc\/self\/smaps\n-    public void parse(Path smapsFileToParse) throws Exception {\n-        Files.lines(smapsFileToParse).forEach(this::eatNext);\n-        this.finish();\n-    }\n-\n-    \/\/ Search for a range including the given address.\n-    public RangeWithPageSize getRange(String addr) {\n-        BigInteger laddr = new BigInteger(addr.substring(2), 16);\n-        for (RangeWithPageSize range : ranges) {\n-            if (range.includes(laddr)) {\n-                return range;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/\/ Class used to store information about memory ranges parsed\n-    \/\/ from \/proc\/self\/smaps. The file contain a lot of information\n-    \/\/ about the different mappings done by an application, but the\n-    \/\/ lines we care about are:\n-    \/\/ 700000000-73ea00000 rw-p 00000000 00:00 0\n-    \/\/ ...\n-    \/\/ KernelPageSize:        4 kB\n-    \/\/ ...\n-    \/\/ VmFlags: rd wr mr mw me ac sd\n-    \/\/\n-    \/\/ We use the VmFlags to know what kind of huge pages are used.\n-    \/\/ For transparent huge pages the KernelPageSize field will not\n-    \/\/ report the large page size.\n-    public static class RangeWithPageSize {\n-        private BigInteger start;\n-        private BigInteger end;\n-        private long pageSize;\n-        private boolean thpEligible;\n-        private boolean vmFlagHG;\n-        private boolean vmFlagHT;\n-        private boolean isTHP;\n-\n-        public RangeWithPageSize(String start, String end, String pageSize, String thpEligible, String vmFlags) {\n-            \/\/ Note: since we insist on kernels >= 3.8, all the following information should be present\n-            \/\/  (none of the input strings be null).\n-            this.start = new BigInteger(start, 16);\n-            this.end = new BigInteger(end, 16);\n-            this.pageSize = Long.parseLong(pageSize);\n-            this.thpEligible = thpEligible == null ? false : (Integer.parseInt(thpEligible) == 1);\n-\n-            vmFlagHG = false;\n-            vmFlagHT = false;\n-            \/\/ Check if the vmFlags line include:\n-            \/\/ * ht - Meaning the range is mapped using explicit huge pages.\n-            \/\/ * hg - Meaning the range is madvised huge.\n-            for (String flag : vmFlags.split(\" \")) {\n-                if (flag.equals(\"ht\")) {\n-                    vmFlagHT = true;\n-                } else if (flag.equals(\"hg\")) {\n-                    vmFlagHG = true;\n-                }\n-            }\n-\n-            \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false,\n-            \/\/ therefore also check thpEligible. If this is still causing problems in the future,\n-            \/\/ we might have to check the AnonHugePages field.\n-\n-            isTHP = vmFlagHG || this.thpEligible;\n-        }\n-\n-        public BigInteger getStart() {\n-            return start;\n-        }\n-\n-        public BigInteger getEnd() {\n-            return end;\n-        }\n-\n-        public long getPageSize() {\n-            return pageSize;\n-        }\n-\n-        public boolean isTransparentHuge() {\n-            return isTHP;\n-        }\n-\n-        public boolean isExplicitHuge() {\n-            return vmFlagHT;\n-        }\n-\n-        public boolean includes(BigInteger addr) {\n-            boolean isGreaterThanOrEqualStart = start.compareTo(addr) <= 0;\n-            boolean isLessThanEnd = addr.compareTo(end) < 0;\n-\n-            return isGreaterThanOrEqualStart && isLessThanEnd;\n-        }\n-\n-        public String toString() {\n-            return \"[\" + start.toString(16) + \", \" + end.toString(16) + \") \" +\n-                    \"pageSize=\" + pageSize + \"KB isTHP=\" + isTHP + \" isHUGETLB=\" + vmFlagHT;\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/SmapsParser.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.os.linux;\n+\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class Smaps {\n+\n+    \/\/ This is a simple smaps parser; it will recognize smaps section start lines\n+    \/\/  (e.g. \"40fa00000-439b80000 rw-p 00000000 00:00 0 \") and look for keywords inside the section.\n+    \/\/ Section will be finished and written into a RangeWithPageSize when either the next section is found\n+    \/\/  or the end of file is encountered.\n+    public static class Parser {\n+        private static final List<Range> ranges = new LinkedList<>();\n+\n+        private static final Pattern SECTION_START_PATT = Pattern.compile(\"^([a-f0-9]+)-([a-f0-9]+) [\\\\-rwpsx]{4}.*\");\n+        private static final Pattern KERNEL_PAGESIZE_PATT = Pattern.compile(\"^KernelPageSize:\\\\s*(\\\\d*) kB\");\n+        private static final Pattern THP_ELIGIBLE_PATT = Pattern.compile(\"^THPeligible:\\\\s+(\\\\d*)\");\n+        private static final Pattern VMFLAGS_PATT = Pattern.compile(\"^VmFlags: ([\\\\w\\\\? ]*)\");\n+\n+        String start;\n+        String end;\n+        String ps;\n+        String thpEligible;\n+        String vmFlags;\n+\n+        void reset() {\n+            start = null;\n+            end = null;\n+            ps = null;\n+            thpEligible = null;\n+            vmFlags = null;\n+        }\n+\n+        public void finish() {\n+            if (start != null) {\n+                Range range = new Range(start, end, ps, thpEligible, vmFlags);\n+                ranges.add(range);\n+                reset();\n+            }\n+        }\n+\n+        public void eatNext(String line) {\n+            \/\/  For better debugging experience call finish here before the debug() call.\n+            Matcher matSectionStart = SECTION_START_PATT.matcher(line);\n+            if (matSectionStart.matches()) {\n+                finish();\n+            }\n+\n+            if (matSectionStart.matches()) {\n+                start = matSectionStart.group(1);\n+                end = matSectionStart.group(2);\n+                ps = null;\n+                vmFlags = null;\n+                return;\n+            } else {\n+                Matcher matKernelPageSize = KERNEL_PAGESIZE_PATT.matcher(line);\n+                if (matKernelPageSize.matches()) {\n+                    ps = matKernelPageSize.group(1);\n+                    return;\n+                }\n+                Matcher matTHPEligible = THP_ELIGIBLE_PATT.matcher(line);\n+                if (matTHPEligible.matches()) {\n+                    thpEligible = matTHPEligible.group(1);\n+                    return;\n+                }\n+                Matcher matVmFlags = VMFLAGS_PATT.matcher(line);\n+                if (matVmFlags.matches()) {\n+                    vmFlags = matVmFlags.group(1);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        \/\/ Copy smaps locally\n+        \/\/ (To minimize chances of concurrent modification when parsing, as well as helping with error analysis)\n+        private Path copySmaps(String postfix) throws Exception {\n+            Path p1 = Paths.get(\"\/proc\/self\/smaps\");\n+            Path p2 = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + postfix + \".txt\");\n+            Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING);\n+            return p2;\n+        }\n+\n+        \/\/ Parse \/proc\/self\/smaps.\n+        public void parse() throws Exception {\n+            parse(\"\");\n+        }\n+\n+        public void parse(String postfix) throws Exception {\n+            \/\/ We can override the smaps file to parse to pass in a pre-fetched one\n+            String smapsFileToParse = System.getProperty(\"smaps-file\");\n+            if (smapsFileToParse != null) {\n+                parse(Paths.get(smapsFileToParse));\n+            } else {\n+                Path smapsCopy = copySmaps(postfix);\n+                parse(smapsCopy);\n+            }\n+        }\n+\n+        \/\/ Parse \/proc\/self\/smaps\n+        public void parse(Path smapsFileToParse) throws Exception {\n+            Files.lines(smapsFileToParse).forEach(this::eatNext);\n+            this.finish();\n+        }\n+\n+        \/\/ Search for a range including the given address.\n+        public Range getRange(String addr) {\n+            BigInteger laddr = new BigInteger(addr.substring(2), 16);\n+            for (Range range : ranges) {\n+                if (range.includes(laddr)) {\n+                    return range;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Class used to store information about memory ranges parsed\n+    \/\/ from \/proc\/self\/smaps. The file contain a lot of information\n+    \/\/ about the different mappings done by an application, but the\n+    \/\/ lines we care about are:\n+    \/\/ 700000000-73ea00000 rw-p 00000000 00:00 0\n+    \/\/ ...\n+    \/\/ KernelPageSize:        4 kB\n+    \/\/ ...\n+    \/\/ VmFlags: rd wr mr mw me ac sd\n+    \/\/\n+    \/\/ We use the VmFlags to know what kind of huge pages are used.\n+    \/\/ For transparent huge pages the KernelPageSize field will not\n+    \/\/ report the large page size.\n+    public static class Range {\n+\n+        private BigInteger start;\n+        private BigInteger end;\n+        private long pageSize;\n+        private boolean thpEligible;\n+        private boolean vmFlagHG;\n+        private boolean vmFlagHT;\n+        private boolean isTHP;\n+\n+        public Range(String start, String end, String pageSize, String thpEligible, String vmFlags) {\n+            \/\/ Note: since we insist on kernels >= 3.8, all the following information should be present\n+            \/\/  (none of the input strings be null).\n+            this.start = new BigInteger(start, 16);\n+            this.end = new BigInteger(end, 16);\n+            this.pageSize = Long.parseLong(pageSize);\n+            this.thpEligible = thpEligible == null ? false : (Integer.parseInt(thpEligible) == 1);\n+\n+            vmFlagHG = false;\n+            vmFlagHT = false;\n+            \/\/ Check if the vmFlags line include:\n+            \/\/ * ht - Meaning the range is mapped using explicit huge pages.\n+            \/\/ * hg - Meaning the range is madvised huge.\n+            for (String flag : vmFlags.split(\" \")) {\n+                if (flag.equals(\"ht\")) {\n+                    vmFlagHT = true;\n+                } else if (flag.equals(\"hg\")) {\n+                    vmFlagHG = true;\n+                }\n+            }\n+\n+            \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false,\n+            \/\/ therefore also check thpEligible. If this is still causing problems in the future,\n+            \/\/ we might have to check the AnonHugePages field.\n+\n+            isTHP = vmFlagHG || this.thpEligible;\n+        }\n+\n+        public BigInteger getStart() {\n+            return start;\n+        }\n+\n+        public BigInteger getEnd() {\n+            return end;\n+        }\n+\n+        public long getPageSize() {\n+            return pageSize;\n+        }\n+\n+        public boolean isTransparentHuge() {\n+            return isTHP;\n+        }\n+\n+        public boolean isExplicitHuge() {\n+            return vmFlagHT;\n+        }\n+\n+        public boolean includes(BigInteger addr) {\n+            boolean isGreaterThanOrEqualStart = start.compareTo(addr) <= 0;\n+            boolean isLessThanEnd = addr.compareTo(end) < 0;\n+\n+            return isGreaterThanOrEqualStart && isLessThanEnd;\n+        }\n+\n+        public String toString() {\n+            return \"[\" + start.toString(16) + \", \" + end.toString(16) + \") \" +\n+                    \"pageSize=\" + pageSize + \"KB isTHP=\" + isTHP + \" isHUGETLB=\" + vmFlagHT;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/os\/linux\/Smaps.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"}]}