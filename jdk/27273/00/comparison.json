{"files":[{"patch":"@@ -52,1 +52,1 @@\n-import java.nio.file.Files;\n+import java.io.File;\n@@ -55,1 +55,0 @@\n-import java.nio.file.StandardCopyOption;\n@@ -64,0 +63,1 @@\n+import jdk.test.lib.SmapsParser;\n@@ -102,23 +102,7 @@\n-            Path smaps = makeSmapsCopy();\n-\n-            final Pattern heapSection = Pattern.compile(\"^\" + heapAddress + \".*\");\n-            final Pattern thpEligible = Pattern.compile(\"THPeligible:\\\\s+(\\\\d)\\\\s*\");\n-\n-            Scanner smapsFile = new Scanner(smaps);\n-            while (smapsFile.hasNextLine()) {\n-                Matcher heapMatcher = heapSection.matcher(smapsFile.nextLine());\n-\n-                if (heapMatcher.matches()) {\n-                    \/\/ Found the first heap section, verify that it is THP eligible\n-                    while (smapsFile.hasNextLine()) {\n-                        Matcher m = thpEligible.matcher(smapsFile.nextLine());\n-                        if (m.matches()) {\n-                            if (Integer.parseInt(m.group(1)) == 1) {\n-                                \/\/ THPeligible is 1, heap can be backed by huge pages\n-                                return;\n-                            }\n-\n-                            throw new RuntimeException(\"First heap section at 0x\" + heapAddress + \" is not THPeligible\");\n-                        }\n-                    }\n-                }\n+\n+            SmapsParser smapsParser = new SmapsParser();\n+            smapsParser.parse();\n+\n+            SmapsParser.RangeWithPageSize range = smapsParser.getRangeStartWith(heapAddress);\n+            if (range == null) {\n+                throw new AssertionError(\"Could not find heap section in smaps file. No memory range found for heapAddress: \" + heapAddress);\n@@ -127,2 +111,4 @@\n-            \/\/ Failed to verify THP for heap\n-            throw new RuntimeException(\"Could not find heap section in smaps file\");\n+            if (!range.isTransparentHuge()) {\n+                \/\/ Failed to verify THP for heap\n+                throw new RuntimeException(\"First heap section at \" + heapAddress + \" is not THPeligible\");\n+            }\n@@ -138,1 +124,1 @@\n-                    return Long.toHexString(Long.decode(m.group(1)));\n+                    return m.group(1);\n@@ -143,7 +129,0 @@\n-\n-        private static Path makeSmapsCopy() throws Exception {\n-            Path src = Paths.get(\"\/proc\/self\/smaps\");\n-            Path dest = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + \".txt\");\n-            Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);\n-            return dest;\n-        }\n","filename":"test\/hotspot\/jtreg\/gc\/TestTransparentHugePagesHeap.java","additions":14,"deletions":35,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -107,5 +107,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.util.LinkedList;\n@@ -116,0 +111,2 @@\n+import jdk.test.lib.SmapsParser;\n+import jdk.test.lib.SmapsParser.RangeWithPageSize;\n@@ -122,2 +119,0 @@\n-    \/\/ Store address ranges with known page size.\n-    private static LinkedList<RangeWithPageSize> ranges = new LinkedList<>();\n@@ -127,109 +122,0 @@\n-    \/\/ Copy smaps locally\n-    \/\/ (To minimize chances of concurrent modification when parsing, as well as helping with error analysis)\n-    private static Path copySmaps() throws Exception {\n-        Path p1 = Paths.get(\"\/proc\/self\/smaps\");\n-        Path p2 = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + \"-\" + (run++) + \".txt\");\n-        Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING);\n-        debug(\"Copied \" + p1 + \" to \" + p2 + \"...\");\n-        return p2;\n-    }\n-\n-    \/\/ Parse \/proc\/self\/smaps.\n-    private static void parseSmaps() throws Exception {\n-        \/\/ We can override the smaps file to parse to pass in a pre-fetched one\n-        String smapsFileToParse = System.getProperty(\"smaps-file\");\n-        if (smapsFileToParse != null) {\n-            parseSmaps(Paths.get(smapsFileToParse));\n-        } else {\n-            Path smapsCopy = copySmaps();\n-            parseSmaps(smapsCopy);\n-        }\n-    }\n-\n-    static class SmapsParser {\n-        \/\/ This is a simple smaps parser; it will recognize smaps section start lines\n-        \/\/  (e.g. \"40fa00000-439b80000 rw-p 00000000 00:00 0 \") and look for keywords inside the section.\n-        \/\/ Section will be finished and written into a RangeWithPageSize when either the next section is found\n-        \/\/  or the end of file is encountered.\n-        static final Pattern SECTION_START_PATT = Pattern.compile(\"^([a-f0-9]+)-([a-f0-9]+) [\\\\-rwpsx]{4}.*\");\n-        static final Pattern KERNEL_PAGESIZE_PATT = Pattern.compile(\"^KernelPageSize:\\\\s*(\\\\d*) kB\");\n-        static final Pattern THP_ELIGIBLE_PATT = Pattern.compile(\"^THPeligible:\\\\s+(\\\\d*)\");\n-        static final Pattern VMFLAGS_PATT = Pattern.compile(\"^VmFlags: ([\\\\w\\\\? ]*)\");\n-        String start;\n-        String end;\n-        String ps;\n-        String thpEligible;\n-        String vmFlags;\n-        int lineno;\n-\n-        void reset() {\n-            start = null;\n-            end = null;\n-            ps = null;\n-            thpEligible = null;\n-            vmFlags = null;\n-        }\n-\n-        public void finish() {\n-            if (start != null) {\n-                RangeWithPageSize range = new RangeWithPageSize(start, end, ps, thpEligible, vmFlags);\n-                ranges.add(range);\n-                debug(\"Added range: \" + range);\n-                reset();\n-            }\n-        }\n-\n-        void eatNext(String line) {\n-            \/\/  For better debugging experience call finish here before the debug() call.\n-            Matcher matSectionStart = SECTION_START_PATT.matcher(line);\n-            if (matSectionStart.matches()) {\n-                finish();\n-            }\n-\n-            debug(\"\" + (lineno++) + \" \" + line);\n-\n-            if (matSectionStart.matches()) {\n-                start = matSectionStart.group(1);\n-                end = matSectionStart.group(2);\n-                ps = null;\n-                vmFlags = null;\n-                return;\n-            } else {\n-                Matcher matKernelPageSize = KERNEL_PAGESIZE_PATT.matcher(line);\n-                if (matKernelPageSize.matches()) {\n-                    ps = matKernelPageSize.group(1);\n-                    return;\n-                }\n-                Matcher matTHPEligible = THP_ELIGIBLE_PATT.matcher(line);\n-                if (matTHPEligible.matches()) {\n-                    thpEligible = matTHPEligible.group(1);\n-                    return;\n-                }\n-                Matcher matVmFlags = VMFLAGS_PATT.matcher(line);\n-                if (matVmFlags.matches()) {\n-                    vmFlags = matVmFlags.group(1);\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/ Parse \/proc\/self\/smaps\n-    private static void parseSmaps(Path smapsFileToParse) throws Exception {\n-        debug(\"Parsing: \" + smapsFileToParse.getFileName() + \"...\");\n-        SmapsParser parser = new SmapsParser();\n-        Files.lines(smapsFileToParse).forEach(parser::eatNext);\n-        parser.finish();\n-    }\n-\n-    \/\/ Search for a range including the given address.\n-    private static RangeWithPageSize getRange(String addr) {\n-        long laddr = Long.decode(addr);\n-        for (RangeWithPageSize range : ranges) {\n-            if (range.includes(laddr)) {\n-                return range;\n-            }\n-        }\n-        return null;\n-    }\n-\n@@ -275,1 +161,2 @@\n-        parseSmaps();\n+        SmapsParser smapsParser = new SmapsParser();\n+        smapsParser.parse(\"-\" + (run++));\n@@ -292,1 +179,1 @@\n-                RangeWithPageSize range = getRange(address);\n+                RangeWithPageSize range = smapsParser.getRangeInclude(address);\n@@ -328,72 +215,0 @@\n-\n-\/\/ Class used to store information about memory ranges parsed\n-\/\/ from \/proc\/self\/smaps. The file contain a lot of information\n-\/\/ about the different mappings done by an application, but the\n-\/\/ lines we care about are:\n-\/\/ 700000000-73ea00000 rw-p 00000000 00:00 0\n-\/\/ ...\n-\/\/ KernelPageSize:        4 kB\n-\/\/ ...\n-\/\/ VmFlags: rd wr mr mw me ac sd\n-\/\/\n-\/\/ We use the VmFlags to know what kind of huge pages are used.\n-\/\/ For transparent huge pages the KernelPageSize field will not\n-\/\/ report the large page size.\n-class RangeWithPageSize {\n-    private long start;\n-    private long end;\n-    private long pageSize;\n-    private boolean thpEligible;\n-    private boolean vmFlagHG;\n-    private boolean vmFlagHT;\n-    private boolean isTHP;\n-\n-    public RangeWithPageSize(String start, String end, String pageSize, String thpEligible, String vmFlags) {\n-        \/\/ Note: since we insist on kernels >= 3.8, all the following information should be present\n-        \/\/  (none of the input strings be null).\n-        this.start = Long.parseUnsignedLong(start, 16);\n-        this.end = Long.parseUnsignedLong(end, 16);\n-        this.pageSize = Long.parseLong(pageSize);\n-        this.thpEligible = thpEligible == null ? false : (Integer.parseInt(thpEligible) == 1);\n-\n-        vmFlagHG = false;\n-        vmFlagHT = false;\n-        \/\/ Check if the vmFlags line include:\n-        \/\/ * ht - Meaning the range is mapped using explicit huge pages.\n-        \/\/ * hg - Meaning the range is madvised huge.\n-        for (String flag : vmFlags.split(\" \")) {\n-            if (flag.equals(\"ht\")) {\n-                vmFlagHT = true;\n-            } else if (flag.equals(\"hg\")) {\n-                vmFlagHG = true;\n-            }\n-        }\n-\n-        \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false,\n-        \/\/ therefore also check thpEligible. If this is still causing problems in the future,\n-        \/\/ we might have to check the AnonHugePages field.\n-\n-        isTHP = vmFlagHG || this.thpEligible;\n-    }\n-\n-    public long getPageSize() {\n-        return pageSize;\n-    }\n-\n-    public boolean isTransparentHuge() {\n-        return isTHP;\n-    }\n-\n-    public boolean isExplicitHuge() {\n-        return vmFlagHT;\n-    }\n-\n-    public boolean includes(long addr) {\n-        return start <= addr && addr < end;\n-    }\n-\n-    public String toString() {\n-        return \"[\" + Long.toHexString(start) + \", \" + Long.toHexString(end) + \") \" +\n-               \"pageSize=\" + pageSize + \"KB isTHP=\" + isTHP + \" isHUGETLB=\" + vmFlagHT;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":5,"deletions":190,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class SmapsParser {\n+    private static List<RangeWithPageSize> ranges = new LinkedList<>();\n+\n+    \/\/ This is a simple smaps parser; it will recognize smaps section start lines\n+    \/\/  (e.g. \"40fa00000-439b80000 rw-p 00000000 00:00 0 \") and look for keywords inside the section.\n+    \/\/ Section will be finished and written into a RangeWithPageSize when either the next section is found\n+    \/\/  or the end of file is encountered.\n+    private static final Pattern SECTION_START_PATT = Pattern.compile(\"^([a-f0-9]+)-([a-f0-9]+) [\\\\-rwpsx]{4}.*\");\n+    private static final Pattern KERNEL_PAGESIZE_PATT = Pattern.compile(\"^KernelPageSize:\\\\s*(\\\\d*) kB\");\n+    private static final Pattern THP_ELIGIBLE_PATT = Pattern.compile(\"^THPeligible:\\\\s+(\\\\d*)\");\n+    private static final Pattern VMFLAGS_PATT = Pattern.compile(\"^VmFlags: ([\\\\w\\\\? ]*)\");\n+\n+    String start;\n+    String end;\n+    String ps;\n+    String thpEligible;\n+    String vmFlags;\n+\n+    void reset() {\n+        start = null;\n+        end = null;\n+        ps = null;\n+        thpEligible = null;\n+        vmFlags = null;\n+    }\n+\n+    public void finish() {\n+        if (start != null) {\n+            RangeWithPageSize range = new RangeWithPageSize(start, end, ps, thpEligible, vmFlags);\n+            ranges.add(range);\n+            reset();\n+        }\n+    }\n+\n+    public void eatNext(String line) {\n+        \/\/  For better debugging experience call finish here before the debug() call.\n+        Matcher matSectionStart = SECTION_START_PATT.matcher(line);\n+        if (matSectionStart.matches()) {\n+            finish();\n+        }\n+\n+        if (matSectionStart.matches()) {\n+            start = matSectionStart.group(1);\n+            end = matSectionStart.group(2);\n+            ps = null;\n+            vmFlags = null;\n+            return;\n+        } else {\n+            Matcher matKernelPageSize = KERNEL_PAGESIZE_PATT.matcher(line);\n+            if (matKernelPageSize.matches()) {\n+                ps = matKernelPageSize.group(1);\n+                return;\n+            }\n+            Matcher matTHPEligible = THP_ELIGIBLE_PATT.matcher(line);\n+            if (matTHPEligible.matches()) {\n+                thpEligible = matTHPEligible.group(1);\n+                return;\n+            }\n+            Matcher matVmFlags = VMFLAGS_PATT.matcher(line);\n+            if (matVmFlags.matches()) {\n+                vmFlags = matVmFlags.group(1);\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ Copy smaps locally\n+    \/\/ (To minimize chances of concurrent modification when parsing, as well as helping with error analysis)\n+    private Path copySmaps(String postfix) throws Exception {\n+        Path p1 = Paths.get(\"\/proc\/self\/smaps\");\n+        Path p2 = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + postfix + \".txt\");\n+        Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING);\n+        return p2;\n+    }\n+\n+    \/\/ Parse \/proc\/self\/smaps.\n+    public void parse() throws Exception {\n+        parse(\"\");\n+    }\n+\n+    public void parse(String postfix) throws Exception {\n+        \/\/ We can override the smaps file to parse to pass in a pre-fetched one\n+        String smapsFileToParse = System.getProperty(\"smaps-file\");\n+        if (smapsFileToParse != null) {\n+            parse(Paths.get(smapsFileToParse));\n+        } else {\n+            Path smapsCopy = copySmaps(postfix);\n+            parse(smapsCopy);\n+        }\n+    }\n+\n+    \/\/ Parse \/proc\/self\/smaps\n+    public void parse(Path smapsFileToParse) throws Exception {\n+        Files.lines(smapsFileToParse).forEach(this::eatNext);\n+        this.finish();\n+    }\n+\n+    \/\/ Search for a range including the given address.\n+    public RangeWithPageSize getRangeInclude(String addr) {\n+        long laddr = Long.decode(addr);\n+        for (RangeWithPageSize range : ranges) {\n+            if (range.includes(laddr)) {\n+                return range;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public RangeWithPageSize getRangeStartWith(String addr) {\n+        long laddr = Long.decode(addr);\n+        for (RangeWithPageSize range : ranges) {\n+            if (range.startWith(laddr)) {\n+                return range;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Class used to store information about memory ranges parsed\n+    \/\/ from \/proc\/self\/smaps. The file contain a lot of information\n+    \/\/ about the different mappings done by an application, but the\n+    \/\/ lines we care about are:\n+    \/\/ 700000000-73ea00000 rw-p 00000000 00:00 0\n+    \/\/ ...\n+    \/\/ KernelPageSize:        4 kB\n+    \/\/ ...\n+    \/\/ VmFlags: rd wr mr mw me ac sd\n+    \/\/\n+    \/\/ We use the VmFlags to know what kind of huge pages are used.\n+    \/\/ For transparent huge pages the KernelPageSize field will not\n+    \/\/ report the large page size.\n+    public static class RangeWithPageSize {\n+        private long start;\n+        private long end;\n+        private long pageSize;\n+        private boolean thpEligible;\n+        private boolean vmFlagHG;\n+        private boolean vmFlagHT;\n+        private boolean isTHP;\n+\n+        public RangeWithPageSize(String start, String end, String pageSize, String thpEligible, String vmFlags) {\n+            \/\/ Note: since we insist on kernels >= 3.8, all the following information should be present\n+            \/\/  (none of the input strings be null).\n+            this.start = Long.parseUnsignedLong(start, 16);\n+            this.end = Long.parseUnsignedLong(end, 16);\n+            this.pageSize = Long.parseLong(pageSize);\n+            this.thpEligible = thpEligible == null ? false : (Integer.parseInt(thpEligible) == 1);\n+\n+            vmFlagHG = false;\n+            vmFlagHT = false;\n+            \/\/ Check if the vmFlags line include:\n+            \/\/ * ht - Meaning the range is mapped using explicit huge pages.\n+            \/\/ * hg - Meaning the range is madvised huge.\n+            for (String flag : vmFlags.split(\" \")) {\n+                if (flag.equals(\"ht\")) {\n+                    vmFlagHT = true;\n+                } else if (flag.equals(\"hg\")) {\n+                    vmFlagHG = true;\n+                }\n+            }\n+\n+            \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false,\n+            \/\/ therefore also check thpEligible. If this is still causing problems in the future,\n+            \/\/ we might have to check the AnonHugePages field.\n+\n+            isTHP = vmFlagHG || this.thpEligible;\n+        }\n+\n+        public long getPageSize() {\n+            return pageSize;\n+        }\n+\n+        public boolean isTransparentHuge() {\n+            return isTHP;\n+        }\n+\n+        public boolean isExplicitHuge() {\n+            return vmFlagHT;\n+        }\n+\n+        public boolean includes(long addr) {\n+            return start <= addr && addr < end;\n+        }\n+\n+        public boolean startWith(long addr) {\n+            return start == addr;\n+        }\n+\n+        public String toString() {\n+            return \"[\" + Long.toHexString(start) + \", \" + Long.toHexString(end) + \") \" +\n+                    \"pageSize=\" + pageSize + \"KB isTHP=\" + isTHP + \" isHUGETLB=\" + vmFlagHT;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/SmapsParser.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"}]}