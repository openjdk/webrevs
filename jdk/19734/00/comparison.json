{"files":[{"patch":"@@ -0,0 +1,870 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.nio.ByteOrder;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n+public class MergeStoreBench {\n+    private static final int HI_BYTE_SHIFT;\n+    private static final int LO_BYTE_SHIFT;\n+    static {\n+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {\n+            HI_BYTE_SHIFT = 8;\n+            LO_BYTE_SHIFT = 0;\n+        } else {\n+            HI_BYTE_SHIFT = 0;\n+            LO_BYTE_SHIFT = 8;\n+        }\n+    }\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    final static VarHandle INT_L = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.LITTLE_ENDIAN);\n+    final static VarHandle INT_B = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.BIG_ENDIAN);\n+\n+    final static VarHandle LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN);\n+    final static VarHandle LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN);\n+\n+    final static int NUMBERS = 8192;\n+    final byte[] bytes4 = new byte[NUMBERS * 4];\n+    final byte[] bytes8 = new byte[NUMBERS * 8];\n+    final int[] ints = new int[NUMBERS];\n+    final long[] longs = new long[NUMBERS];\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random();\n+        for (int i = 0; i < ints.length; i++) {\n+            ints[i] = r.nextInt();\n+            INT_L.set(bytes4, i * 4, i);\n+        }\n+\n+        for (int i = 0; i < longs.length; i++) {\n+            longs[i] = r.nextLong();\n+            LONG_L.set(bytes8, i * 8, i);\n+        }\n+    }\n+\n+    \/*\n+     * The names of these cases have the following `B\/L\/V\/U` suffixes, which are:\n+     * ```\n+     * B BigEndian\n+     * L LittleEndian\n+     * V VarHandle\n+     * U Unsafe\n+     * R ReverseBytes\n+     * ```\n+     *\/\n+\n+    @Benchmark\n+    public void getIntB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_B.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_L.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += Integer.reverseBytes(\n+                    UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntB(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntBU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntBV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            INT_B.set(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntL(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntLU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            INT_L.set(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRB(bytes4, i * 4, ints[i]);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRBU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRL(bytes4, i * 4, ints[i]);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            setIntRLU(bytes4, i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            v = Integer.reverseBytes(v);\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setIntU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            int v = ints[i];\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_B.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_L.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += Long.reverseBytes(\n+                    UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongB(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongBU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            LONG_B.set(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongL(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongLU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            LONG_L.set(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRB(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRBU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRL(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            setLongRLU(bytes8, i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            v = Long.reverseBytes(v);\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void setLongU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            long v = longs[i];\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n+            sum += v;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4(bytes8, i * 4, 'n', 'u', 'l', 'l');\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4UB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4UB(bytes8, i * 4, 'n', 'u', 'l', 'l');\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void putChars4UC(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            putChars4UC(bytes8, i * 4, 'n', 'u', 'l', 'l');\n+            sum += longs[i];\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    static int getIntB(byte[] array, int offset) {\n+        return ((array[offset    ] & 0xff) << 24)\n+             | ((array[offset + 1] & 0xff) << 16)\n+             | ((array[offset + 2] & 0xff) <<  8)\n+             | ((array[offset + 3] & 0xff)      );\n+    }\n+\n+    static int getIntBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff) << 24)\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff)      );\n+    }\n+\n+    static int getIntL(byte[] array, int offset) {\n+        return ((array[offset       ] & 0xff)      )\n+                | ((array[offset + 1] & 0xff) <<  8)\n+                | ((array[offset + 2] & 0xff) << 16)\n+                | ((array[offset + 3] & 0xff) << 24);\n+    }\n+\n+    static int getIntRB(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntB(array, offset));\n+    }\n+\n+    static int getIntRBU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntBU(array, offset));\n+    }\n+\n+    static int getIntRL(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntL(array, offset));\n+    }\n+\n+    static int getIntRLU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntLU(array, offset));\n+    }\n+\n+    static void setIntB(byte[] array, int offset, int value) {\n+        array[offset    ] = (byte) (value >> 24);\n+        array[offset + 1] = (byte) (value >> 16);\n+        array[offset + 2] = (byte) (value >>  8);\n+        array[offset + 3] = (byte) (value      );\n+    }\n+\n+    static void setIntBU(byte[] array, int offset, int value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte) (value >> 24));\n+        UNSAFE.putByte(array, address + 1, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 3, (byte) (value      ));\n+    }\n+\n+    public static void setIntL(byte[] array, int offset, int value) {\n+        array[offset    ] = (byte)  value;\n+        array[offset + 1] = (byte) (value >> 8);\n+        array[offset + 2] = (byte) (value >> 16);\n+        array[offset + 3] = (byte) (value >> 24);\n+    }\n+\n+    public static void setIntLU(byte[] array, int offset, int value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte)  value       );\n+        UNSAFE.putByte(array, address + 1, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 3, (byte) (value >> 24));\n+    }\n+\n+    public static void setIntRL(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntL(array, offset, value);\n+    }\n+\n+    public static void setIntRLU(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntLU(array, offset, value);\n+    }\n+\n+    public static void setIntRB(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntB(array, offset, value);\n+    }\n+\n+    public static void setIntRBU(byte[] array, int offset, int value) {\n+        value = Integer.reverseBytes(value);\n+        setIntBU(array, offset, value);\n+    }\n+\n+    static long getLongB(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff) << 56)\n+             | (((long) array[offset + 1] & 0xff) << 48)\n+             | (((long) array[offset + 2] & 0xff) << 40)\n+             | (((long) array[offset + 3] & 0xff) << 32)\n+             | (((long) array[offset + 4] & 0xff) << 24)\n+             | (((long) array[offset + 5] & 0xff) << 16)\n+             | (((long) array[offset + 6] & 0xff) << 8)\n+             | (((long) array[offset + 7] & 0xff)     );\n+    }\n+\n+    static long getLongBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address)     & 0xff)) << 56)\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff))      );\n+    }\n+\n+    public static long getLongL(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff)      )\n+             | (((long) array[offset + 1] & 0xff) <<  8)\n+             | (((long) array[offset + 2] & 0xff) << 16)\n+             | (((long) array[offset + 3] & 0xff) << 24)\n+             | (((long) array[offset + 4] & 0xff) << 32)\n+             | (((long) array[offset + 5] & 0xff) << 40)\n+             | (((long) array[offset + 6] & 0xff) << 48)\n+             | (((long) array[offset + 7] & 0xff) << 56);\n+    }\n+\n+    static long getLongLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address    ) & 0xff))      )\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff)) << 56);\n+    }\n+\n+    static long getLongRB(byte[] array, int offset) {\n+        return getLongB(array, offset);\n+    }\n+\n+    static long getLongRBU(byte[] array, int offset) {\n+        return getLongBU(array, offset);\n+    }\n+\n+    static long getLongRL(byte[] array, int offset) {\n+        return getLongL(array, offset);\n+    }\n+\n+    static long getLongRLU(byte[] array, int offset) {\n+        return getLongLU(array, offset);\n+    }\n+\n+    static void setLongB(byte[] array, int offset, long value) {\n+        array[offset]     = (byte) (value >> 56);\n+        array[offset + 1] = (byte) (value >> 48);\n+        array[offset + 2] = (byte) (value >> 40);\n+        array[offset + 3] = (byte) (value >> 32);\n+        array[offset + 4] = (byte) (value >> 24);\n+        array[offset + 5] = (byte) (value >> 16);\n+        array[offset + 6] = (byte) (value >>  8);\n+        array[offset + 7] = (byte) (value      );\n+    }\n+\n+    public static void setLongL(byte[] array, int offset, long value) {\n+        array[offset]     = (byte)  value       ;\n+        array[offset + 1] = (byte) (value >> 8 );\n+        array[offset + 2] = (byte) (value >> 16);\n+        array[offset + 3] = (byte) (value >> 24);\n+        array[offset + 4] = (byte) (value >> 32);\n+        array[offset + 5] = (byte) (value >> 40);\n+        array[offset + 6] = (byte) (value >> 48);\n+        array[offset + 7] = (byte) (value >> 56);\n+    }\n+\n+    public static void setLongRL(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongL(array, offset, value);\n+    }\n+\n+    public static void setLongRLU(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongLU(array, offset, value);\n+    }\n+\n+    public static void setLongRB(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongB(array, offset, value);\n+    }\n+\n+    public static void setLongRBU(byte[] array, int offset, long value) {\n+        value = Long.reverseBytes(value);\n+        setLongBU(array, offset, value);\n+    }\n+\n+    public static void setLongBU(byte[] array, int offset, long value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte) (value >> 56));\n+        UNSAFE.putByte(array, address + 1, (byte) (value >> 48));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >> 40));\n+        UNSAFE.putByte(array, address + 3, (byte) (value >> 32));\n+        UNSAFE.putByte(array, address + 4, (byte) (value >> 24));\n+        UNSAFE.putByte(array, address + 5, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 6, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 7, (byte)  value       );\n+    }\n+\n+    public static void setLongLU(byte[] array, int offset, long value) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(array, address    , (byte)  value       );\n+        UNSAFE.putByte(array, address + 1, (byte) (value >>  8));\n+        UNSAFE.putByte(array, address + 2, (byte) (value >> 16));\n+        UNSAFE.putByte(array, address + 3, (byte) (value >> 24));\n+        UNSAFE.putByte(array, address + 4, (byte) (value >> 32));\n+        UNSAFE.putByte(array, address + 5, (byte) (value >> 40));\n+        UNSAFE.putByte(array, address + 6, (byte) (value >> 48));\n+        UNSAFE.putByte(array, address + 7, (byte) (value >> 56));\n+    }\n+\n+    public static int getIntLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff)      )\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n+    }\n+\n+    public static void putChars4(byte[] array, int offset, char c0, char c1, char c2, char c3) {\n+        putChar(array, offset, c0);\n+        putChar(array, offset + 1, c1);\n+        putChar(array, offset + 2, c2);\n+        putChar(array, offset + 3, c3);\n+    }\n+\n+    public static void putChars4UC(byte[] array, int offset, char c0, char c1, char c2, char c3) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putChar(array, address, c0);\n+        UNSAFE.putChar(array, address + 2, c1);\n+        UNSAFE.putChar(array, address + 4, c2);\n+        UNSAFE.putChar(array, address + 6, c3);\n+    }\n+\n+    public static void putChars4UB(byte[] array, int offset, char c0, char c1, char c2, char c3) {\n+        putCharUB(array, offset, c0);\n+        putCharUB(array, offset + 1, c1);\n+        putCharUB(array, offset + 2, c2);\n+        putCharUB(array, offset + 3, c3);\n+    }\n+\n+    private static void putChar(byte[] val, int index, char c) {\n+        index <<= 1;\n+        val[index    ] = (byte)(c >> HI_BYTE_SHIFT);\n+        val[index + 1] = (byte)(c >> LO_BYTE_SHIFT);\n+    }\n+\n+    public static void putCharUB(byte[] array, int offset, char c) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        UNSAFE.putByte(array, address    , (byte) (c >>  8));\n+        UNSAFE.putByte(array, address + 1, (byte) (c      ));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MergeStoreBench.java","additions":870,"deletions":0,"binary":false,"changes":870,"status":"added"}]}