{"files":[{"patch":"@@ -1435,2 +1435,11 @@\n-void PSParallelCompact::fill_dense_prefix_end(SpaceId id)\n-{\n+void PSParallelCompact::fill_dense_prefix_end(SpaceId id) {\n+  \/\/ Since both markword and klass takes 1 heap word, the min-obj-size is 2\n+  \/\/ heap words.\n+  \/\/ If min-obj-size decreases to 1, this whole method becomes redundant.\n+  assert(CollectedHeap::min_fill_size() == 2, \"inv\");\n+#ifndef _LP64\n+  \/\/ In 32-bit system, min-obj-alignment is >= 8 bytes, so the gap (if any)\n+  \/\/ right before denses-prefix must be greater than min-fill-size; nothing to\n+  \/\/ do.\n+  return;\n+#endif\n@@ -1438,55 +1447,8 @@\n-  const RegionData* region = _summary_data.addr_to_region_ptr(dense_prefix_end);\n-  const idx_t dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);\n-  if (dead_space_crosses_boundary(region, dense_prefix_bit)) {\n-    \/\/ Only enough dead space is filled so that any remaining dead space to the\n-    \/\/ left is larger than the minimum filler object.  (The remainder is filled\n-    \/\/ during the copy\/update phase.)\n-    \/\/\n-    \/\/ The size of the dead space to the right of the boundary is not a\n-    \/\/ concern, since compaction will be able to use whatever space is\n-    \/\/ available.\n-    \/\/\n-    \/\/ Here '||' is the boundary, 'x' represents a don't care bit and a box\n-    \/\/ surrounds the space to be filled with an object.\n-    \/\/\n-    \/\/ In the 32-bit VM, each bit represents two 32-bit words:\n-    \/\/                              +---+\n-    \/\/ a) beg_bits:  ...  x   x   x | 0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  x   x   x | 0 | ||   0   x  x  ...\n-    \/\/                              +---+\n-    \/\/\n-    \/\/ In the 64-bit VM, each bit represents one 64-bit word:\n-    \/\/                              +------------+\n-    \/\/ b) beg_bits:  ...  x   x   x | 0   ||   0 | x  x  ...\n-    \/\/    end_bits:  ...  x   x   1 | 0   ||   0 | x  x  ...\n-    \/\/                              +------------+\n-    \/\/                          +-------+\n-    \/\/ c) beg_bits:  ...  x   x | 0   0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  x   1 | 0   0 | ||   0   x  x  ...\n-    \/\/                          +-------+\n-    \/\/                      +-----------+\n-    \/\/ d) beg_bits:  ...  x | 0   0   0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  1 | 0   0   0 | ||   0   x  x  ...\n-    \/\/                      +-----------+\n-    \/\/                          +-------+\n-    \/\/ e) beg_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...\n-    \/\/                          +-------+\n-\n-    \/\/ Initially assume case a, c or e will apply.\n-    size_t obj_len = CollectedHeap::min_fill_size();\n-    HeapWord* obj_beg = dense_prefix_end - obj_len;\n-\n-#ifdef  _LP64\n-    if (MinObjAlignment > 1) { \/\/ object alignment > heap word size\n-      \/\/ Cases a, c or e.\n-    } else if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {\n-      \/\/ Case b above.\n-      obj_beg = dense_prefix_end - 1;\n-    } else if (!_mark_bitmap.is_obj_end(dense_prefix_bit - 3) &&\n-               _mark_bitmap.is_obj_end(dense_prefix_bit - 4)) {\n-      \/\/ Case d above.\n-      obj_beg = dense_prefix_end - 3;\n-      obj_len = 3;\n-    }\n-#endif  \/\/ #ifdef _LP64\n+  RegionData* const region = _summary_data.addr_to_region_ptr(dense_prefix_end);\n+  idx_t const dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);\n+\n+  if (region->partial_obj_size() != 0 ||\n+      _mark_bitmap.is_obj_beg(dense_prefix_bit)) {\n+    \/\/ next region starts with live bytes\n+    return;\n+  }\n@@ -1494,0 +1456,5 @@\n+  if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {\n+    \/\/ Exactly one heap word gap right before dense prefix end; the filler obj\n+    \/\/ will extend to next region.\n+    const size_t obj_len = 2; \/\/ min-obj-size\n+    HeapWord* const obj_beg = dense_prefix_end - 1;\n@@ -1496,1 +1463,2 @@\n-    _summary_data.add_obj(obj_beg, obj_len);\n+    _summary_data.addr_to_region_ptr(obj_beg)->add_live_obj(1);\n+    region->set_partial_obj_size(1);\n@@ -2565,0 +2533,1 @@\n+  HeapWord* const space_bottom = space(space_id)->bottom();\n@@ -2566,1 +2535,2 @@\n-  if (beg_addr != space(space_id)->bottom()) {\n+  \/\/ Check if it's the first region in this space.\n+  if (beg_addr != space_bottom) {\n@@ -2578,2 +2548,5 @@\n-    } else if (dead_space_crosses_boundary(cp, mbm->addr_to_bit(beg_addr))) {\n-      beg_addr = mbm->find_obj_beg(beg_addr, end_addr);\n+    } else {\n+      idx_t beg_bit = mbm->addr_to_bit(beg_addr);\n+      if (!mbm->is_obj_beg(beg_bit) && !mbm->is_obj_end(beg_bit - 1)) {\n+        beg_addr = mbm->find_obj_beg(beg_addr, end_addr);\n+      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":34,"deletions":61,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -1024,8 +1024,2 @@\n-  \/\/ Return true if dead space crosses onto the specified Region; bit must be\n-  \/\/ the bit index corresponding to the first word of the Region.\n-  static inline bool dead_space_crosses_boundary(const RegionData* region,\n-                                                 idx_t bit);\n-\n-  \/\/ Summary phase utility routine to fill dead space (if any) at the dense\n-  \/\/ prefix boundary.  Should only be called if the dense prefix is\n-  \/\/ non-empty.\n+  \/\/ Create a filler obj (if needed) right before the dense-prefix-boundary to\n+  \/\/ make the heap parsable.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,14 +49,0 @@\n-inline bool PSParallelCompact::dead_space_crosses_boundary(const RegionData* region,\n-                                                           idx_t bit) {\n-  assert(bit > 0, \"cannot call this for the first bit\/region\");\n-  assert(_summary_data.region_to_addr(region) == _mark_bitmap.bit_to_addr(bit),\n-         \"sanity check\");\n-\n-  \/\/ Dead space crosses the boundary if (1) a partial object does not extend\n-  \/\/ onto the region, (2) an object does not start at the beginning of the\n-  \/\/ region, and (3) an object does not end at the end of the prior region.\n-  return region->partial_obj_size() == 0 &&\n-    !_mark_bitmap.is_obj_beg(bit) &&\n-    !_mark_bitmap.is_obj_end(bit - 1);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"}]}