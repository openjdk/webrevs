{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -32,0 +33,1 @@\n+import java.util.stream.Stream;\n@@ -33,1 +35,0 @@\n-import com.sun.tools.javac.code.Symbol.*;\n@@ -35,0 +36,2 @@\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.util.Assert;\n@@ -36,1 +39,1 @@\n-import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Names;\n@@ -38,1 +41,0 @@\n-import com.sun.tools.javac.util.Pair;\n@@ -48,2 +50,2 @@\n-public class Lint\n-{\n+public class Lint {\n+\n@@ -62,11 +64,9 @@\n-     * Returns the result of combining the values in this object with\n-     * the given annotation.\n-     *\/\n-    public Lint augment(Attribute.Compound attr) {\n-        return augmentor.augment(this, attr);\n-    }\n-\n-\n-    \/**\n-     * Returns the result of combining the values in this object with\n-     * the metadata on the given symbol.\n+     * Obtain an instance with additional warning supression applied from any\n+     * @SuppressWarnings and\/or @Deprecated annotations on the given symbol.\n+     *\n+     * <p>\n+     * The returned instance will be different from this instance if and only if\n+     * {@link #suppressionsFrom} returns a non-empty set.\n+     *\n+     * @param sym symbol\n+     * @return lint instance with new warning suppressions applied, or this instance if none\n@@ -75,6 +75,6 @@\n-        Lint l = augmentor.augment(this, sym.getDeclarationAttributes());\n-        if (sym.isDeprecated() && sym.isDeprecatableViaAnnotation()) {\n-            if (l == this)\n-                l = new Lint(this);\n-            l.values.remove(LintCategory.DEPRECATION);\n-            l.suppressedValues.add(LintCategory.DEPRECATION);\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(sym);\n+        if (!suppressions.isEmpty()) {\n+            Lint lint = new Lint(this);\n+            lint.values.removeAll(suppressions);\n+            lint.suppressedValues.addAll(suppressions);\n+            return lint;\n@@ -82,1 +82,1 @@\n-        return l;\n+        return this;\n@@ -96,1 +96,5 @@\n-    private final AugmentVisitor augmentor;\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily to avoid dependency loops\n+    private Symtab syms;\n+    private Names names;\n@@ -98,0 +102,1 @@\n+    \/\/ Invariant: it's never the case that a category is in both \"values\" and \"suppressedValues\"\n@@ -113,1 +118,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -116,1 +121,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -145,1 +150,1 @@\n-        suppressedValues = EnumSet.noneOf(LintCategory.class);\n+        suppressedValues = LintCategory.newEmptySet();\n@@ -147,0 +152,1 @@\n+        this.context = context;\n@@ -148,1 +154,0 @@\n-        augmentor = new AugmentVisitor(context);\n@@ -152,1 +157,3 @@\n-        this.augmentor = other.augmentor;\n+        this.context = other.context;\n+        this.syms = other.syms;\n+        this.names = other.names;\n@@ -159,1 +166,1 @@\n-        return \"Lint:[values\" + values + \" suppressedValues\" + suppressedValues + \"]\";\n+        return \"Lint:[enable\" + values + \",suppress\" + suppressedValues + \"]\";\n@@ -366,0 +373,5 @@\n+        public static EnumSet<LintCategory> newEmptySet() {\n+            return EnumSet.noneOf(LintCategory.class);\n+        }\n+\n+        \/** Get the string representing this category in @SuppressAnnotations and -Xlint options. *\/\n@@ -388,64 +400,16 @@\n-    protected static class AugmentVisitor implements Attribute.Visitor {\n-        private final Context context;\n-        private Symtab syms;\n-        private Lint parent;\n-        private Lint lint;\n-\n-        AugmentVisitor(Context context) {\n-            \/\/ to break an ugly sequence of initialization dependencies,\n-            \/\/ we defer the initialization of syms until it is needed\n-            this.context = context;\n-        }\n-\n-        Lint augment(Lint parent, Attribute.Compound attr) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            attr.accept(this);\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        Lint augment(Lint parent, List<Attribute.Compound> attrs) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            for (Attribute.Compound a: attrs) {\n-                a.accept(this);\n-            }\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        private void initSyms() {\n-            if (syms == null)\n-                syms = Symtab.instance(context);\n-        }\n-\n-        private void suppress(LintCategory lc) {\n-            if (lint == null)\n-                lint = new Lint(parent);\n-            lint.suppressedValues.add(lc);\n-            lint.values.remove(lc);\n-        }\n-\n-        public void visitConstant(Attribute.Constant value) {\n-            if (value.type.tsym == syms.stringType.tsym) {\n-                LintCategory lc = LintCategory.get((String) (value.value));\n-                if (lc != null)\n-                    suppress(lc);\n-            }\n-        }\n-\n-        public void visitClass(Attribute.Class clazz) {\n-        }\n-\n-        \/\/ If we find a @SuppressWarnings annotation, then we continue\n-        \/\/ walking the tree, in order to suppress the individual warnings\n-        \/\/ specified in the @SuppressWarnings annotation.\n-        public void visitCompound(Attribute.Compound compound) {\n-            if (compound.type.tsym == syms.suppressWarningsType.tsym) {\n-                for (List<Pair<MethodSymbol,Attribute>> v = compound.values;\n-                     v.nonEmpty(); v = v.tail) {\n-                    Pair<MethodSymbol,Attribute> value = v.head;\n-                    if (value.fst.name.toString().equals(\"value\"))\n-                        value.snd.accept(this);\n-                }\n+    \/**\n+     * Obtain the set of recognized lint warning categories suppressed at the given symbol's declaration.\n+     *\n+     * <p>\n+     * This set can be non-empty only if the symbol is annotated with either\n+     * @SuppressWarnings or @Deprecated.\n+     *\n+     * @param symbol symbol corresponding to a possibly-annotated declaration\n+     * @return new warning suppressions applied to sym\n+     *\/\n+    public EnumSet<LintCategory> suppressionsFrom(Symbol symbol) {\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(symbol.getDeclarationAttributes().stream());\n+        if (symbol.isDeprecated() && symbol.isDeprecatableViaAnnotation())\n+            suppressions.add(LintCategory.DEPRECATION);\n+        return suppressions;\n+    }\n@@ -453,2 +417,13 @@\n-            }\n-        }\n+    \/**\n+     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n+     *\n+     * @param annotation @SuppressWarnings annotation, or null\n+     * @return set of lint categories, possibly empty but never null\n+     *\/\n+    private EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n+        initializeIfNeeded();\n+        if (annotation == null)\n+            return LintCategory.newEmptySet();\n+        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n+        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n+    }\n@@ -456,4 +431,10 @@\n-        public void visitArray(Attribute.Array array) {\n-            for (Attribute value : array.values)\n-                value.accept(this);\n-        }\n+    \/\/ Find the @SuppressWarnings annotation in the given stream and extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Stream<Attribute.Compound> attributes) {\n+        initializeIfNeeded();\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        attributes\n+          .filter(attribute -> attribute.type.tsym == syms.suppressWarningsType.tsym)\n+          .map(this::suppressionsFrom)\n+          .forEach(result::addAll);\n+        return result;\n+    }\n@@ -461,1 +442,8 @@\n-        public void visitEnum(Attribute.Enum e) {\n+    \/\/ Given a @SuppressWarnings annotation, extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Attribute.Compound suppressWarnings) {\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        Attribute.Array values = (Attribute.Array)suppressWarnings.member(names.value);\n+        for (Attribute value : values.values) {\n+            Optional.of((String)((Attribute.Constant)value).value)\n+              .map(LintCategory::get)\n+              .ifPresent(result::add);\n@@ -463,0 +451,2 @@\n+        return result;\n+    }\n@@ -464,1 +454,4 @@\n-        public void visitError(Attribute.Error e) {\n+    private void initializeIfNeeded() {\n+        if (syms == null) {\n+            syms = Symtab.instance(context);\n+            names = Names.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":95,"deletions":102,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1365,1 +1365,1 @@\n-                log.warning(Warnings.IncubatingModules(incubatingModules));\n+                log.warning(LintCategory.INCUBATING, null, Warnings.IncubatingModules(incubatingModules));\n@@ -1754,1 +1754,1 @@\n-                    log.warning(Warnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n+                    log.warning(LintCategory.OPTIONS, null, Warnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,2 @@\n-        boolean warn = options.isLintSet(\"path\");\n+        boolean warn = options.isLintSet(LintCategory.PATH.option);\n+        boolean fileClashOption = options.isLintSet(LintCategory.OUTPUT_FILE_CLASH.option);\n@@ -99,0 +100,2 @@\n+\n+        \/\/ Only track file clashes if enabled\n@@ -100,1 +103,1 @@\n-            outputFilesWritten = options.isLintSet(\"output-file-clash\") ? new HashSet<>() : null;\n+            outputFilesWritten = fileClashOption ? new HashSet<>() : null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2076,1 +2076,1 @@\n-                        log.warning(Warnings.AnnotationMethodNotFound(container, name));\n+                        log.warning(LintCategory.CLASSFILE, null, Warnings.AnnotationMethodNotFound(container, name));\n@@ -2078,3 +2078,4 @@\n-                        log.warning(Warnings.AnnotationMethodNotFoundReason(container,\n-                                                                            name,\n-                                                                            failure.getDetailValue()));\/\/diagnostic, if present\n+                        log.warning(LintCategory.CLASSFILE, null,\n+                            Warnings.AnnotationMethodNotFoundReason(container,\n+                                                                    name,\n+                                                                    failure.getDetailValue()));\/\/diagnostic, if present\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -495,1 +495,1 @@\n-                    log.warning(Warnings.ProcSuspiciousClassName(name, extn));\n+                    log.warning(PROCESSING, null, Warnings.ProcSuspiciousClassName(name, extn));\n@@ -711,1 +711,1 @@\n-                log.warning(Warnings.ProcIllegalFileName(name));\n+                log.warning(PROCESSING, null, Warnings.ProcIllegalFileName(name));\n@@ -740,1 +740,1 @@\n-                log.warning(Warnings.ProcTypeRecreate(typename));\n+                log.warning(PROCESSING, null, Warnings.ProcTypeRecreate(typename));\n@@ -744,1 +744,1 @@\n-            log.warning(Warnings.ProcTypeAlreadyExists(typename));\n+            log.warning(PROCESSING, null, Warnings.ProcTypeAlreadyExists(typename));\n@@ -774,1 +774,1 @@\n-                log.warning(Warnings.ProcFileReopening(fileObject.getName()));\n+                log.warning(PROCESSING, null, Warnings.ProcFileReopening(fileObject.getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -717,1 +717,1 @@\n-                        log.warning(Warnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(PROCESSING, null, Warnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -731,1 +731,1 @@\n-                    log.warning(Warnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(PROCESSING, null, Warnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -739,2 +739,2 @@\n-                            log.warning(Warnings.ProcDuplicateOptionName(optionName,\n-                                                                         p.getClass().getName()));\n+                            log.warning(PROCESSING, null,\n+                                        Warnings.ProcDuplicateOptionName(optionName, p.getClass().getName()));\n@@ -960,1 +960,1 @@\n-                log.warning(Warnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));\n+                log.warning(PROCESSING, null, Warnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));\n@@ -1783,1 +1783,1 @@\n-            log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+            log.warning(PROCESSING, null, Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,2 @@\n-    private EnumSet<LintCategory> nonSilentLintSet = EnumSet.noneOf(LintCategory.class);\n-    private EnumSet<LintCategory> silentLintSet = EnumSet.noneOf(LintCategory.class);\n+    private EnumSet<LintCategory> nonSilentLintSet = LintCategory.newEmptySet();\n+    private EnumSet<LintCategory> silentLintSet = LintCategory.newEmptySet();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}