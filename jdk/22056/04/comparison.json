{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -32,0 +33,1 @@\n+import java.util.stream.Stream;\n@@ -33,1 +35,0 @@\n-import com.sun.tools.javac.code.Symbol.*;\n@@ -35,0 +36,2 @@\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.util.Assert;\n@@ -38,1 +41,0 @@\n-import com.sun.tools.javac.util.List;\n@@ -40,0 +42,1 @@\n+import com.sun.tools.javac.util.Names;\n@@ -41,1 +44,0 @@\n-import com.sun.tools.javac.util.Pair;\n@@ -51,2 +53,2 @@\n-public class Lint\n-{\n+public class Lint {\n+\n@@ -65,11 +67,9 @@\n-     * Returns the result of combining the values in this object with\n-     * the given annotation.\n-     *\/\n-    public Lint augment(Attribute.Compound attr) {\n-        return augmentor.augment(this, attr);\n-    }\n-\n-\n-    \/**\n-     * Returns the result of combining the values in this object with\n-     * the metadata on the given symbol.\n+     * Obtain an instance with additional warning supression applied from any\n+     * @SuppressWarnings and\/or @Deprecated annotations on the given symbol.\n+     *\n+     * <p>\n+     * The returned instance will be different from this instance if and only if\n+     * {@link #suppressionsFrom} returns a non-empty set.\n+     *\n+     * @param sym symbol\n+     * @return lint instance with new warning suppressions applied, or this instance if none\n@@ -78,6 +78,6 @@\n-        Lint l = augmentor.augment(this, sym.getDeclarationAttributes());\n-        if (sym.isDeprecated() && sym.isDeprecatableViaAnnotation()) {\n-            if (l == this)\n-                l = new Lint(this);\n-            l.values.remove(LintCategory.DEPRECATION);\n-            l.suppressedValues.add(LintCategory.DEPRECATION);\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(sym);\n+        if (!suppressions.isEmpty()) {\n+            Lint lint = new Lint(this);\n+            lint.values.removeAll(suppressions);\n+            lint.suppressedValues.addAll(suppressions);\n+            return lint;\n@@ -85,1 +85,1 @@\n-        return l;\n+        return this;\n@@ -99,1 +99,5 @@\n-    private final AugmentVisitor augmentor;\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily to avoid dependency loops\n+    private Symtab syms;\n+    private Names names;\n@@ -101,0 +105,1 @@\n+    \/\/ Invariant: it's never the case that a category is in both \"values\" and \"suppressedValues\"\n@@ -116,1 +121,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -119,1 +124,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -148,1 +153,1 @@\n-        suppressedValues = EnumSet.noneOf(LintCategory.class);\n+        suppressedValues = LintCategory.newEmptySet();\n@@ -150,0 +155,1 @@\n+        this.context = context;\n@@ -151,1 +157,0 @@\n-        augmentor = new AugmentVisitor(context);\n@@ -155,1 +160,3 @@\n-        this.augmentor = other.augmentor;\n+        this.context = other.context;\n+        this.syms = other.syms;\n+        this.names = other.names;\n@@ -162,1 +169,1 @@\n-        return \"Lint:[values\" + values + \" suppressedValues\" + suppressedValues + \"]\";\n+        return \"Lint:[enable\" + values + \",suppress\" + suppressedValues + \"]\";\n@@ -369,0 +376,5 @@\n+        public static EnumSet<LintCategory> newEmptySet() {\n+            return EnumSet.noneOf(LintCategory.class);\n+        }\n+\n+        \/** Get the string representing this category in @SuppressAnnotations and -Xlint options. *\/\n@@ -400,64 +412,16 @@\n-    protected static class AugmentVisitor implements Attribute.Visitor {\n-        private final Context context;\n-        private Symtab syms;\n-        private Lint parent;\n-        private Lint lint;\n-\n-        AugmentVisitor(Context context) {\n-            \/\/ to break an ugly sequence of initialization dependencies,\n-            \/\/ we defer the initialization of syms until it is needed\n-            this.context = context;\n-        }\n-\n-        Lint augment(Lint parent, Attribute.Compound attr) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            attr.accept(this);\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        Lint augment(Lint parent, List<Attribute.Compound> attrs) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            for (Attribute.Compound a: attrs) {\n-                a.accept(this);\n-            }\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        private void initSyms() {\n-            if (syms == null)\n-                syms = Symtab.instance(context);\n-        }\n-\n-        private void suppress(LintCategory lc) {\n-            if (lint == null)\n-                lint = new Lint(parent);\n-            lint.suppressedValues.add(lc);\n-            lint.values.remove(lc);\n-        }\n-\n-        public void visitConstant(Attribute.Constant value) {\n-            if (value.type.tsym == syms.stringType.tsym) {\n-                LintCategory lc = LintCategory.get((String) (value.value));\n-                if (lc != null)\n-                    suppress(lc);\n-            }\n-        }\n-\n-        public void visitClass(Attribute.Class clazz) {\n-        }\n-\n-        \/\/ If we find a @SuppressWarnings annotation, then we continue\n-        \/\/ walking the tree, in order to suppress the individual warnings\n-        \/\/ specified in the @SuppressWarnings annotation.\n-        public void visitCompound(Attribute.Compound compound) {\n-            if (compound.type.tsym == syms.suppressWarningsType.tsym) {\n-                for (List<Pair<MethodSymbol,Attribute>> v = compound.values;\n-                     v.nonEmpty(); v = v.tail) {\n-                    Pair<MethodSymbol,Attribute> value = v.head;\n-                    if (value.fst.name.toString().equals(\"value\"))\n-                        value.snd.accept(this);\n-                }\n+    \/**\n+     * Obtain the set of recognized lint warning categories suppressed at the given symbol's declaration.\n+     *\n+     * <p>\n+     * This set can be non-empty only if the symbol is annotated with either\n+     * @SuppressWarnings or @Deprecated.\n+     *\n+     * @param symbol symbol corresponding to a possibly-annotated declaration\n+     * @return new warning suppressions applied to sym\n+     *\/\n+    public EnumSet<LintCategory> suppressionsFrom(Symbol symbol) {\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(symbol.getDeclarationAttributes().stream());\n+        if (symbol.isDeprecated() && symbol.isDeprecatableViaAnnotation())\n+            suppressions.add(LintCategory.DEPRECATION);\n+        return suppressions;\n+    }\n@@ -465,2 +429,13 @@\n-            }\n-        }\n+    \/**\n+     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n+     *\n+     * @param annotation @SuppressWarnings annotation, or null\n+     * @return set of lint categories, possibly empty but never null\n+     *\/\n+    private EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n+        initializeIfNeeded();\n+        if (annotation == null)\n+            return LintCategory.newEmptySet();\n+        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n+        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n+    }\n@@ -468,4 +443,10 @@\n-        public void visitArray(Attribute.Array array) {\n-            for (Attribute value : array.values)\n-                value.accept(this);\n-        }\n+    \/\/ Find the @SuppressWarnings annotation in the given stream and extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Stream<Attribute.Compound> attributes) {\n+        initializeIfNeeded();\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        attributes\n+          .filter(attribute -> attribute.type.tsym == syms.suppressWarningsType.tsym)\n+          .map(this::suppressionsFrom)\n+          .forEach(result::addAll);\n+        return result;\n+    }\n@@ -473,1 +454,8 @@\n-        public void visitEnum(Attribute.Enum e) {\n+    \/\/ Given a @SuppressWarnings annotation, extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Attribute.Compound suppressWarnings) {\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        Attribute.Array values = (Attribute.Array)suppressWarnings.member(names.value);\n+        for (Attribute value : values.values) {\n+            Optional.of((String)((Attribute.Constant)value).value)\n+              .map(LintCategory::get)\n+              .ifPresent(result::add);\n@@ -475,0 +463,2 @@\n+        return result;\n+    }\n@@ -476,1 +466,4 @@\n-        public void visitError(Attribute.Error e) {\n+    private void initializeIfNeeded() {\n+        if (syms == null) {\n+            syms = Symtab.instance(context);\n+            names = Names.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":95,"deletions":102,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -93,1 +94,2 @@\n-        boolean warn = options.isLintSet(\"path\");\n+        boolean warn = options.isLintSet(LintCategory.PATH.option);\n+        boolean fileClashOption = options.isLintSet(LintCategory.OUTPUT_FILE_CLASH.option);\n@@ -95,0 +97,2 @@\n+\n+        \/\/ Only track file clashes if enabled\n@@ -96,1 +100,1 @@\n-            outputFilesWritten = options.isLintSet(\"output-file-clash\") ? new HashSet<>() : null;\n+            outputFilesWritten = fileClashOption ? new HashSet<>() : null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,2 @@\n-    private EnumSet<LintCategory> nonSilentLintSet = EnumSet.noneOf(LintCategory.class);\n-    private EnumSet<LintCategory> silentLintSet = EnumSet.noneOf(LintCategory.class);\n+    private EnumSet<LintCategory> nonSilentLintSet = LintCategory.newEmptySet();\n+    private EnumSet<LintCategory> silentLintSet = LintCategory.newEmptySet();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}