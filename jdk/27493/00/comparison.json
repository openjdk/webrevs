{"files":[{"patch":"@@ -240,1 +240,1 @@\n-            final var codesignDir = Codesign.build(signingCfgWithoutEntitlements::toCodesignArgs).force(true).create().asConsumer();\n+            final var codesignDir = Codesign.build(signingCfg::toCodesignArgs).force(true).create().asConsumer();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n@@ -29,0 +31,1 @@\n+import java.util.HashMap;\n@@ -30,0 +33,1 @@\n+import java.util.Map;\n@@ -33,0 +37,1 @@\n+import java.util.stream.Stream;\n@@ -34,0 +39,1 @@\n+import javax.xml.xpath.XPath;\n@@ -36,1 +42,1 @@\n-import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import org.w3c.dom.Element;\n@@ -40,0 +46,3 @@\n+\/**\n+ * Property list (plist) file reader.\n+ *\/\n@@ -42,0 +51,111 @@\n+    public record Raw(String value, Type type) {\n+\n+        public enum Type {\n+            STRING,\n+            BOOLEAN,\n+            REAL,\n+            INTEGER,\n+            DATE,\n+            DATA;\n+\n+            private static Optional<Type> fromElementName(String name) {\n+                switch (name) {\n+                    case \"string\" -> {\n+                        return Optional.of(STRING);\n+                    }\n+                    case \"true\" -> {\n+                        return Optional.of(BOOLEAN);\n+                    }\n+                    case \"false\" -> {\n+                        return Optional.of(BOOLEAN);\n+                    }\n+                    case \"real\" -> {\n+                        return Optional.of(REAL);\n+                    }\n+                    case \"integer\" -> {\n+                        return Optional.of(INTEGER);\n+                    }\n+                    case \"date\" -> {\n+                        return Optional.of(DATE);\n+                    }\n+                    case \"data\" -> {\n+                        return Optional.of(DATA);\n+                    }\n+                    default -> {\n+                        return Optional.empty();\n+                    }\n+                }\n+            }\n+        }\n+\n+        public Raw {\n+            Objects.requireNonNull(value);\n+            Objects.requireNonNull(type);\n+        }\n+\n+        private static Optional<Raw> tryCreate(Element e) {\n+            return Type.fromElementName(e.getNodeName()).map(type -> {\n+                if (type == Type.BOOLEAN) {\n+                    if (\"true\".equals(e.getNodeName())) {\n+                        return new Raw(Boolean.TRUE.toString(), type);\n+                    } else {\n+                        return new Raw(Boolean.FALSE.toString(), type);\n+                    }\n+                } else {\n+                    return new Raw(e.getTextContent(), type);\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Returns the contents of the the underlying \"dict\" element as a Map.\n+     * <p>\n+     * The keys in the returned map are names of the properties.\n+     * <p>\n+     * Values of nested \"dict\" properties are stored as {@code Map<String, Object>}\n+     * or {@code PListReader} objects depending on the value of the\n+     * {@code fetchDictionaries} parameter.\n+     * <p>\n+     * Values of \"array\" properties are stored as {@code List<Object>} objects.\n+     * <p>\n+     * Values of other properties are stored as {@code Raw} objects.\n+     *\n+     * @param fetchDictionaries controls the type of objects of nested \"dict\"\n+     *                          elements. If the value is {@code true},\n+     *                          {@code Map<String, Object>} type is used, and\n+     *                          {@code PListReader} type otherwise.\n+     * @return the contents of the the underlying \"dict\" element as a Map\n+     *\/\n+    public Map<String, Object> toMap(boolean fetchDictionaries) {\n+        Map<String, Object> reply = new HashMap<>();\n+        var nodes = root.getChildNodes();\n+        for (int i = 0; i != nodes.getLength(); i++) {\n+            if (nodes.item(i) instanceof Element e) {\n+                tryCreateValue(e, fetchDictionaries).ifPresent(value -> {\n+                    final var query = \"preceding-sibling::*[1]\";\n+                    Optional.ofNullable(toSupplier(() -> {\n+                        return (Node) XPathSingleton.INSTANCE.evaluate(query, e, XPathConstants.NODE);\n+                    }).get()).ifPresent(n -> {\n+                        if (\"key\".equals(n.getNodeName())) {\n+                            var keyName = n.getTextContent();\n+                            reply.putIfAbsent(keyName, value);\n+                        }\n+                    });\n+                });\n+            }\n+        }\n+\n+        return reply;\n+    }\n+\n+    \/**\n+     * Returns the value of the given string property in the underlying \"dict\"\n+     * element.\n+     *\n+     * @param keyName the name of a string property whose value to query\n+     * @return the value of the string property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no string property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n@@ -54,0 +174,32 @@\n+    \/**\n+     * Returns the value of the given \"dict\" property in the underlying \"dict\"\n+     * element.\n+     *\n+     * @param keyName the name of a \"dict\" property whose value to query\n+     * @return the value of the \"dict\" property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no \"dict\" property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n+    public PListReader queryDictValue(String keyName) {\n+        final var node = getNode(keyName);\n+        switch (node.getNodeName()) {\n+            case \"dict\" -> {\n+                return new PListReader(node);\n+            }\n+            default -> {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of the given boolean property in the underlying \"dict\"\n+     * element.\n+     *\n+     * @param keyName the name of a boolean property whose value to query\n+     * @return the value of the boolean property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no string property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n@@ -69,1 +221,48 @@\n-    public List<String> queryArrayValue(String keyName) {\n+    \/**\n+     * Returns the value of the given array property in the underlying \"dict\"\n+     * element as a list of strings.\n+     * <p>\n+     * Processes the result of calling {@link #queryArrayValue(String)} on the\n+     * specified property name by filtering {@link Raw} instances of type\n+     * {@link Raw.Type#STRING}.\n+     *\n+     * @param keyName the name of an array property whose value to query\n+     * @return the value of the array property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no array property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n+    public List<String> queryStringArrayValue(String keyName) {\n+        return queryArrayValue(keyName, false).map(v -> {\n+            if (v instanceof Raw r) {\n+                if (r.type() == Raw.Type.STRING) {\n+                    return r.value();\n+                }\n+            }\n+            return (String)null;\n+        }).filter(Objects::nonNull).toList();\n+    }\n+\n+    \/**\n+     * Returns the value of the given array property in the underlying \"dict\"\n+     * element as a stream of {@link Object}-s.\n+     * <p>\n+     * Values of \"dict\" array items are stored as {@code Map<String, Object>} or\n+     * {@code PListReader} objects depending on the value of the\n+     * {@code fetchDictionaries} parameter.\n+     * <p>\n+     * Values of \"array\" array items are stored as {@code List<Object>} objects.\n+     * <p>\n+     * Values of other types are stored as {@code Raw} objects.\n+     *\n+     * @param keyName           the name of an array property whose value to query\n+     * @param fetchDictionaries controls the type of objects of \"dict\" elements. If\n+     *                          the value is {@code true},\n+     *                          {@code Map<String, Object>} type is used, and\n+     *                          {@code PListReader} type otherwise.\n+     * @return the value of the array property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no array key with the given name\n+     *                                in the underlying \"dict\" element\n+     *\/\n+    public Stream<Object> queryArrayValue(String keyName, boolean fetchDictionaries) {\n@@ -73,3 +272,1 @@\n-                return XmlUtils.toStream(node.getChildNodes()).filter(n -> {\n-                    return n.getNodeName().equals(\"string\");\n-                }).map(Node::getTextContent).toList();\n+                return readArray(node, fetchDictionaries);\n@@ -83,2 +280,21 @@\n-    public PListReader(Node doc) {\n-        this.root = Objects.requireNonNull(doc);\n+    \/**\n+     * Creates plist reader from the given node.\n+     * <p>\n+     * If the specified node is an element with the name \"dict\", the reader is bound\n+     * to the specified node; otherwise, it is bound to the {@code \/plist\/dict}\n+     * element in the document.\n+     *\n+     * @param node the node\n+     * @throws NoSuchElementException if the specified node is not an element with\n+     *                                name \"dict\" and there is no\n+     *                                {@code \/plist\/dict} node in the document\n+     *\/\n+    public PListReader(Node node) {\n+        Objects.requireNonNull(node);\n+        if (node.getNodeName().equals(\"dict\")) {\n+            this.root = node;\n+        } else {\n+            this.root = Optional.ofNullable(toSupplier(() -> {\n+                return (Node) XPathSingleton.INSTANCE.evaluate(\"\/plist[1]\/dict[1]\", node, XPathConstants.NODE);\n+            }).get()).orElseThrow(NoSuchElementException::new);\n+        }\n@@ -91,0 +307,29 @@\n+    private Optional<?> tryCreateValue(Element e, boolean fetchDictionaries) {\n+        switch (e.getNodeName()) {\n+            case \"dict\" -> {\n+                var plistReader = new PListReader(e);\n+                if (fetchDictionaries) {\n+                    return Optional.of(plistReader.toMap(fetchDictionaries));\n+                } else {\n+                    return Optional.of(plistReader);\n+                }\n+            }\n+            case \"array\" -> {\n+                return Optional.of(readArray(e, fetchDictionaries).toList());\n+            }\n+            default -> {\n+                return Raw.tryCreate(e);\n+            }\n+        }\n+    }\n+\n+    private Stream<Object> readArray(Node node, boolean fetchDictionaries) {\n+        return XmlUtils.toStream(node.getChildNodes()).map(n -> {\n+            if (n instanceof Element e) {\n+                return tryCreateValue(e, fetchDictionaries);\n+            } else {\n+                return Optional.<Raw>empty();\n+            }\n+        }).filter(Optional::isPresent).map(Optional::get);\n+    }\n+\n@@ -92,4 +337,4 @@\n-        final var xPath = XPathFactory.newInstance().newXPath();\n-        final var query = String.format(\"\/\/*[preceding-sibling::key = \\\"%s\\\"][1]\", keyName);\n-        return Optional.ofNullable(ThrowingSupplier.toSupplier(() -> {\n-            return (Node) xPath.evaluate(query, root, XPathConstants.NODE);\n+        Objects.requireNonNull(keyName);\n+        final var query = String.format(\"*[preceding-sibling::key = \\\"%s\\\"][1]\", keyName);\n+        return Optional.ofNullable(toSupplier(() -> {\n+            return (Node) XPathSingleton.INSTANCE.evaluate(query, root, XPathConstants.NODE);\n@@ -99,0 +344,6 @@\n+\n+    private static final class XPathSingleton {\n+        private static final XPath INSTANCE = XPathFactory.newInstance().newXPath();\n+    }\n+\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PListReader.java","additions":262,"deletions":11,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+    jdk.jpackage\/jdk.jpackage.internal.resources \\\n","filename":"test\/jdk\/tools\/jpackage\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1088,1 +1088,3 @@\n-                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_INSTALLED);\n+                new LauncherVerifier(cmd).verify(cmd,\n+                        LauncherVerifier.Action.VERIFY_INSTALLED,\n+                        LauncherVerifier.Action.VERIFY_MAC_ENTITLEMENTS);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-        var args = servicePlist.queryArrayValue(\"ProgramArguments\");\n+        var args = servicePlist.queryStringArrayValue(\"ProgramArguments\");\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import javax.xml.parsers.ParserConfigurationException;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+import jdk.jpackage.internal.util.PListReader;\n@@ -41,0 +44,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -43,0 +47,1 @@\n+import org.xml.sax.SAXException;\n@@ -85,0 +90,5 @@\n+        VERIFY_MAC_ENTITLEMENTS((verifier, cmd) -> {\n+            if (TKit.isOSX() && MacHelper.appImageSigned(cmd)) {\n+                verifier.verifyMacEntitlements(cmd);\n+            }\n+        }),\n@@ -99,1 +109,1 @@\n-                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_APP_IMAGE_FILE\n+                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_APP_IMAGE_FILE, VERIFY_MAC_ENTITLEMENTS\n@@ -326,0 +336,18 @@\n+    private void verifyMacEntitlements(JPackageCommand cmd) throws ParserConfigurationException, SAXException, IOException {\n+        Path launcherPath = cmd.appLauncherPath(name);\n+        var entitlements = MacSignVerify.findEntitlements(launcherPath);\n+\n+        TKit.assertTrue(entitlements.isPresent(), String.format(\"Check [%s] launcher is signed with entitlements\", name));\n+\n+        Map<String, Object> expected;\n+        if (cmd.hasArgument(\"--mac-entitlements\")) {\n+            expected = new PListReader(Files.readAllBytes(Path.of(cmd.getArgumentValue(\"--mac-entitlements\")))).toMap(true);\n+        } else if (cmd.hasArgument(\"--mac-app-store\")) {\n+            expected = DefaultEntitlements.APP_STORE;\n+        } else {\n+            expected = DefaultEntitlements.STANDARD;\n+        }\n+\n+        TKit.assertEquals(expected, entitlements.orElseThrow().toMap(true), String.format(\"Check [%s] launcher is signed with expected entitlements\", name));\n+    }\n+\n@@ -365,0 +393,14 @@\n+\n+    private static final class DefaultEntitlements {\n+        private static Map<String, Object> loadFromResources(String resourceName) {\n+            return ThrowingSupplier.toSupplier(() -> {\n+                var bytes = ResourceLocator.class.getResourceAsStream(\"entitlements.plist\").readAllBytes();\n+                return new PListReader(bytes).toMap(true);\n+            }).get();\n+        }\n+\n+        static final Map<String, Object> STANDARD = loadFromResources(\"entitlements.plist\");\n+        static final Map<String, Object> APP_STORE = loadFromResources(\"sandbox.plist\");\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-            var plist = readPList(attachExecutor.getOutput());\n+            \/\/ The first \"dict\" item of \"system-entities\" array property contains \"mount-point\" string property.\n+            var plist = readPList(attachExecutor.getOutput()).queryArrayValue(\"system-entities\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,11 @@\n+    public static Optional<PListReader> findEntitlements(Path path) {\n+        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"-d\", \"--entitlements\", \"-\", \"--xml\", path.toString()).saveOutput().dumpOutput();\n+        final var result = exec.execute();\n+        var xml = result.stdout().getOutput();\n+        if (xml.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(MacHelper.readPList(xml));\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Map;\n@@ -39,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -40,0 +42,1 @@\n+import jdk.jpackage.internal.util.PListReader.Raw;\n@@ -43,0 +46,1 @@\n+import org.junit.jupiter.params.provider.EnumSource.Mode;\n@@ -54,1 +58,17 @@\n-        STRING_ARRAY(PListReader::queryArrayValue);\n+        DICT((plistReader, keyName) -> {\n+            return plistReader.queryDictValue(keyName).toMap(true);\n+        }),\n+        STRING_ARRAY(PListReader::queryStringArrayValue),\n+        RAW_ARRAY((plistReader, keyName) -> {\n+            return plistReader.queryArrayValue(keyName, false).toList();\n+        }),\n+        RAW_ARRAY_RECURSIVE((plistReader, keyName) -> {\n+            return plistReader.queryArrayValue(keyName, true).toList();\n+        }),\n+        TO_MAP((plistReader, _) -> {\n+            return plistReader.toMap(false);\n+        }),\n+        TO_MAP_RECURSIVE((plistReader, _) -> {\n+            return plistReader.toMap(true);\n+        }),\n+        ;\n@@ -68,1 +88,1 @@\n-    public record QueryValueTestSpec(QueryType queryType, String keyName, Optional<Object> expectedValue,\n+    public record TestSpec(QueryType queryType, Optional<String> keyName, Optional<Object> expectedValue,\n@@ -71,1 +91,1 @@\n-        public QueryValueTestSpec {\n+        public TestSpec {\n@@ -80,0 +100,8 @@\n+            if (keyName.isEmpty()) {\n+                switch (queryType) {\n+                    case TO_MAP, TO_MAP_RECURSIVE -> {}\n+                    default -> {\n+                        throw new IllegalArgumentException();\n+                    }\n+                }\n+            }\n@@ -94,1 +122,1 @@\n-            Builder expectedValue(Object v) {\n+            Builder expect(Object v) {\n@@ -102,0 +130,2 @@\n+                } else if (v instanceof Map<?, ?>) {\n+                    queryType(QueryType.DICT);\n@@ -106,1 +136,1 @@\n-            Builder expectedException(Class<? extends RuntimeException> v) {\n+            Builder expectException(Class<? extends RuntimeException> v) {\n@@ -116,2 +146,5 @@\n-            QueryValueTestSpec create() {\n-                return new QueryValueTestSpec(queryType, keyName, Optional.ofNullable(expectedValue),\n+            TestSpec create() {\n+                return new TestSpec(\n+                        queryType,\n+                        Optional.ofNullable(keyName),\n+                        Optional.ofNullable(expectedValue),\n@@ -140,1 +173,1 @@\n-                final var actualValue = queryType.queryValue(plistReader, keyName);\n+                final var actualValue = queryType.queryValue(plistReader, keyName.orElse(null));\n@@ -145,1 +178,1 @@\n-                assertThrows(v, () -> queryType.queryValue(plistReader, keyName));\n+                assertThrows(v, () -> queryType.queryValue(plistReader, keyName.orElse(null)));\n@@ -153,1 +186,3 @@\n-            sb.append(\"; key=\").append(keyName);\n+            if (keyName != null) {\n+                sb.append(\"; key=\").append(keyName);\n+            }\n@@ -169,1 +204,1 @@\n-    @EnumSource(QueryType.class)\n+    @EnumSource(mode = Mode.MATCH_NONE, names = {\"TO_MAP.*\"})\n@@ -175,1 +210,1 @@\n-    @EnumSource(QueryType.class)\n+    @EnumSource(mode = Mode.MATCH_NONE, names = {\"TO_MAP.*\"})\n@@ -185,1 +220,3 @@\n-                \"<array><string>b<\/string><\/array>\");\n+                \"<array><string>b<\/string><\/array>\",\n+                \"<key>dict-key<\/key>\",\n+                \"<dict><key>nested-dict-key<\/key><integer>345<\/integer><\/dict>\");\n@@ -187,1 +224,1 @@\n-        List<QueryValueTestSpec> testSpecs = new ArrayList<>();\n+        List<TestSpec> testSpecs = new ArrayList<>();\n@@ -194,0 +231,1 @@\n+                testSpecs.add(builder.keyName(\"dict-key\").create());\n@@ -198,0 +236,1 @@\n+                testSpecs.add(builder.keyName(\"dict-key\").create());\n@@ -199,1 +238,1 @@\n-            case STRING_ARRAY -> {\n+            case STRING_ARRAY, RAW_ARRAY, RAW_ARRAY_RECURSIVE -> {\n@@ -203,0 +242,10 @@\n+                testSpecs.add(builder.keyName(\"dict-key\").create());\n+            }\n+            case DICT -> {\n+                testSpecs.add(builder.keyName(\"string-key\").create());\n+                testSpecs.add(builder.keyName(\"boolean-true-key\").create());\n+                testSpecs.add(builder.keyName(\"boolean-false-key\").create());\n+                testSpecs.add(builder.keyName(\"array-key\").create());\n+            }\n+            case TO_MAP, TO_MAP_RECURSIVE -> {\n+                throw new UnsupportedOperationException();\n@@ -206,1 +255,10 @@\n-        testSpecs.forEach(QueryValueTestSpec::test);\n+        testSpecs.forEach(TestSpec::test);\n+\n+        builder.keyName(null).expect(Map.of(\n+                \"string-key\", new Raw(\"a\", Raw.Type.STRING),\n+                \"boolean-true-key\", new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN),\n+                \"boolean-false-key\", new Raw(Boolean.FALSE.toString(), Raw.Type.BOOLEAN),\n+                \"array-key\", List.of(new Raw(\"b\", Raw.Type.STRING)),\n+                \"dict-key\", Map.of(\"nested-dict-key\", new Raw(\"345\", Raw.Type.INTEGER))\n+        )).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+\n@@ -211,1 +269,1 @@\n-    public void testQueryValue(QueryValueTestSpec testSpec) {\n+    public void test(TestSpec testSpec) {\n@@ -222,14 +280,54 @@\n-    private static List<QueryValueTestSpec> testQueryValue() {\n-        return List.of(\n-                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string>\").create(),\n-                testSpec().expectedValue(\"\").xml(\"<key>foo<\/key><string\/>\").create(),\n-                testSpec().xml(\"<key>foo<\/key><String\/>\").create(),\n-                testSpec().expectedValue(Boolean.TRUE).xml(\"<key>foo<\/key><true\/>\").create(),\n-                testSpec().expectedValue(Boolean.FALSE).xml(\"<key>foo<\/key><false\/>\").create(),\n-                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><True\/>\").create(),\n-                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><False\/>\").create(),\n-                testSpec().expectedValue(List.of(\"foo\", \"bar\")).xml(\"<key>foo<\/key><array><string>foo<\/string><string>bar<\/string><\/array>\").create(),\n-                testSpec().expectedValue(List.of()).xml(\"<key>foo<\/key><array\/>\").create(),\n-                testSpec(QueryType.STRING_ARRAY).xml(\"<key>foo<\/key><Array\/>\").create(),\n-                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string><string>B<\/string>\").create(),\n-                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><string>B<\/string>\").create()\n+    @Test\n+    public void test_toMap() {\n+\n+        var builder = testSpec();\n+\n+        builder.xml(\n+                \"<key>AppName<\/key>\",\n+                \"<string>Hello<\/string>\",\n+                \"<!-- Application version -->\",\n+                \"<key>AppVersion<\/key>\",\n+                \"<real>1.0<\/real>\",\n+                \"<key>Release<\/key>\",\n+                \"<true\/>\",\n+                \"<key>Debug<\/key>\",\n+                \"<false\/>\",\n+                \"<key>ReleaseDate<\/key>\",\n+                \"<date>2025-09-24T09:23:00Z<\/date>\",\n+                \"<key>UserData<\/key>\",\n+                \"<!-- User data -->\",\n+                \"<dict>\",\n+                \"  <key>Foo<\/key>\",\n+                \"  <array>\",\n+                \"    <string>Str<\/string>\",\n+                \"    <array>\",\n+                \"      <string>Another Str<\/string>\",\n+                \"      <true\/>\",\n+                \"      <false\/>\",\n+                \"    <\/array>\",\n+                \"  <\/array>\",\n+                \"<\/dict>\",\n+                \"<key>Checksum<\/key>\",\n+                \"<data>7841ff0076cdde93bdca02cfd332748c40620ce4<\/data>\",\n+                \"<key>Plugins<\/key>\",\n+                \"<array>\",\n+                \"  <dict>\",\n+                \"    <key>PluginName<\/key>\",\n+                \"    <string>Foo<\/string>\",\n+                \"    <key>Priority<\/key>\",\n+                \"    <integer>13<\/integer>\",\n+                \"    <key>History<\/key>\",\n+                \"    <array>\",\n+                \"      <string>New File<\/string>\",\n+                \"      <string>Another New File<\/string>\",\n+                \"    <\/array>\",\n+                \"  <\/dict>\",\n+                \"  <dict>\",\n+                \"    <key>PluginName<\/key>\",\n+                \"    <string>Bar<\/string>\",\n+                \"    <key>Priority<\/key>\",\n+                \"    <real>23<\/real>\",\n+                \"    <key>History<\/key>\",\n+                \"    <array\/>\",\n+                \"  <\/dict>\",\n+                \"<\/array>\"\n@@ -237,0 +335,122 @@\n+\n+        var expected = Map.of(\n+                \"AppName\", new Raw(\"Hello\", Raw.Type.STRING),\n+                \"AppVersion\", new Raw(\"1.0\", Raw.Type.REAL),\n+                \"Release\", new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN),\n+                \"Debug\", new Raw(Boolean.FALSE.toString(), Raw.Type.BOOLEAN),\n+                \"ReleaseDate\", new Raw(\"2025-09-24T09:23:00Z\", Raw.Type.DATE),\n+                \"Checksum\", new Raw(\"7841ff0076cdde93bdca02cfd332748c40620ce4\", Raw.Type.DATA),\n+                \"UserData\", Map.of(\n+                        \"Foo\", List.of(\n+                                new Raw(\"Str\", Raw.Type.STRING),\n+                                List.of(\n+                                        new Raw(\"Another Str\", Raw.Type.STRING),\n+                                        new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN),\n+                                        new Raw(Boolean.FALSE.toString(), Raw.Type.BOOLEAN)\n+                                )\n+                        )\n+                ),\n+                \"Plugins\", List.of(\n+                        Map.of(\n+                                \"PluginName\", new Raw(\"Foo\", Raw.Type.STRING),\n+                                \"Priority\", new Raw(\"13\", Raw.Type.INTEGER),\n+                                \"History\", List.of(\n+                                        new Raw(\"New File\", Raw.Type.STRING),\n+                                        new Raw(\"Another New File\", Raw.Type.STRING)\n+                                )\n+                        ),\n+                        Map.of(\n+                                \"PluginName\", new Raw(\"Bar\", Raw.Type.STRING),\n+                                \"Priority\", new Raw(\"23\", Raw.Type.REAL),\n+                                \"History\", List.of()\n+                        )\n+                )\n+        );\n+\n+        builder.expect(expected).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+    }\n+\n+    private static List<TestSpec> test() {\n+\n+        List<TestSpec> data = new ArrayList<>();\n+\n+        Stream.of(\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string>\"),\n+                testSpec().expect(\"A\").xml(\"<a><string>B<\/string><\/a><key>foo<\/key><string>A<\/string>\"),\n+                testSpec().expect(\"\").xml(\"<key>foo<\/key> some text <string\/>\"),\n+                testSpec().xml(\"<key>foo<\/key><String\/>\"),\n+                testSpec().xml(\"<key>foo<\/key>\"),\n+                testSpec().xml(\"<key>foo<\/key><foo\/><string>A<\/string>\"),\n+                testSpec().expect(Boolean.TRUE).xml(\"<key>foo<\/key><true\/>\"),\n+                testSpec().expect(Boolean.FALSE).xml(\"<key>foo<\/key><false\/>\"),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><True\/>\"),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><False\/>\"),\n+                testSpec().expect(List.of(\"foo\", \"bar\")).xml(\"<key>foo<\/key><array><string>foo<\/string><random\/><dict\/><string>bar<\/string><true\/><\/array>\"),\n+                testSpec().expect(List.of()).xml(\"<key>foo<\/key><array\/>\"),\n+                testSpec(QueryType.STRING_ARRAY).xml(\"<key>foo<\/key><Array\/>\"),\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><string>B<\/string>\"),\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><string>B<\/string>\"),\n+\n+                testSpec().expect(Map.of()).xml(\"<key>foo<\/key><dict\/>\"),\n+\n+                \/\/\n+                \/\/ Test that if there are multiple keys with the same name, all but the first are ignored.\n+                \/\/\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><string>B<\/string><key>foo<\/key><string>C<\/string>\"),\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><String>B<\/String>\"),\n+                testSpec(QueryType.STRING).xml(\"<key>foo<\/key><String>B<\/String><key>foo<\/key><string>A<\/string>\"),\n+                testSpec().expect(Boolean.TRUE).xml(\"<key>foo<\/key><true\/><key>foo<\/key><false\/>\"),\n+                testSpec().expect(Boolean.TRUE).xml(\"<key>foo<\/key><true\/><key>foo<\/key><False\/>\"),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><False\/><key>foo<\/key><true\/>\"),\n+\n+                \/\/\n+                \/\/ Test that it doesn't look up keys in nested \"dict\" or \"array\" elements.\n+                \/\/\n+                testSpec().xml(\"<key>foo<\/key><dict><key>foo<\/key><string>A<\/string><\/dict>\"),\n+                testSpec().expect(\"B\").xml(\"<key>bar<\/key><dict><key>foo<\/key><string>A<\/string><\/dict><key>foo<\/key><string>B<\/string>\"),\n+                testSpec().xml(\"<key>foo<\/key><array><dict><key>foo<\/key><string>A<\/string><\/dict><\/array>\"),\n+                testSpec().expect(\"B\").xml(\"<key>bar<\/key><array><dict><key>foo<\/key><string>A<\/string><\/dict><\/array><key>foo<\/key><string>B<\/string>\"),\n+\n+                \/\/\n+                \/\/ Test empty arrays.\n+                \/\/\n+                testSpec().expect(List.of()).queryType(QueryType.RAW_ARRAY_RECURSIVE).xml(\"<key>foo<\/key><array\/>\"),\n+                testSpec().expect(List.of()).queryType(QueryType.RAW_ARRAY).xml(\"<key>foo<\/key><array\/>\")\n+\n+        ).map(TestSpec.Builder::create).forEach(data::add);\n+\n+        \/\/\n+        \/\/ Test toMap() method.\n+        \/\/\n+        Stream.of(\n+                testSpec().expect(Map.of()).xml(),\n+                testSpec().expect(Map.of()).xml(\"<key>foo<\/key><key>bar<\/key>\"),\n+                testSpec().expect(Map.of()).xml(\"<string>A<\/string><key>bar<\/key>\"),\n+                testSpec().expect(Map.of()).xml(\"<string>A<\/string>\"),\n+                testSpec().expect(Map.of()).xml(\"<key>foo<\/key><a\/><string>A<\/string>\"),\n+                testSpec().expect(Map.of(\"foo\", new Raw(\"A\", Raw.Type.STRING))).xml(\"<key>foo<\/key><string>A<\/string><string>B<\/string>\"),\n+                testSpec().expect(Map.of(\"foo\", new Raw(\"A\", Raw.Type.STRING))).xml(\"<key>foo<\/key><string>A<\/string> hello <key>foo<\/key> bye <string>B<\/string>\"),\n+                testSpec().expect(Map.of(\"foo\", new Raw(\"A\", Raw.Type.STRING), \"Foo\", new Raw(\"B\", Raw.Type.STRING))).xml(\"<key>foo<\/key><string>A<\/string><key>Foo<\/key><string>B<\/string>\")\n+        ).map(builder -> {\n+            return builder.queryType(QueryType.TO_MAP_RECURSIVE);\n+        }).map(TestSpec.Builder::create).forEach(data::add);\n+\n+        var arrayTestSpec = testSpec().expect(List.of(\n+                new Raw(\"Hello\", Raw.Type.STRING),\n+                Map.of(\"foo\", new Raw(\"Bye\", Raw.Type.STRING)),\n+                new Raw(\"integer\", Raw.Type.INTEGER),\n+                Map.of(),\n+                new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN)\n+        )).queryType(QueryType.RAW_ARRAY_RECURSIVE);\n+\n+        Stream.of(\n+                \"<string>Hello<\/string><random\/><dict><key>foo<\/key><string>Bye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<string>Hello<\/string><dict><data>Bingo<\/data><key>foo<\/key><string>Bye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<a><string>B<\/string><\/a><string>Hello<\/string><random\/><dict><key>foo<\/key><string>Bye<\/string><string>Byeee<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<string>Hello<\/string><random\/><dict><key>bar<\/key><key>foo<\/key><string>Bye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<string>Hello<\/string><random\/><dict><key>foo<\/key><string>Bye<\/string><key>foo<\/key><string>ByeBye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\"\n+        ).map(xml -> {\n+            return \"<key>foo<\/key><array>\" + xml + \"<\/array>\";\n+        }).map(arrayTestSpec::xml).map(TestSpec.Builder::create).forEach(data::add);\n+\n+        return data;\n@@ -239,2 +459,2 @@\n-    private static QueryValueTestSpec.Builder testSpec() {\n-        return new QueryValueTestSpec.Builder();\n+    private static TestSpec.Builder testSpec() {\n+        return new TestSpec.Builder();\n@@ -243,1 +463,1 @@\n-    private static QueryValueTestSpec.Builder testSpec(QueryType queryType) {\n+    private static TestSpec.Builder testSpec(QueryType queryType) {\n@@ -251,0 +471,1 @@\n+        content.add(\"<dict>\");\n@@ -252,0 +473,1 @@\n+        content.add(\"<\/dict>\");\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PListReaderTest.java","additions":256,"deletions":34,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static java.util.Map.entry;\n+\n@@ -27,4 +29,0 @@\n-import static java.util.Map.entry;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.MacHelper;\n@@ -33,0 +31,3 @@\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.TKit;\n@@ -83,3 +84,3 @@\n-    private static void checkBoolValue(PListReader plist, String key, Boolean value) {\n-        Boolean result = plist.queryBoolValue(key);\n-        TKit.assertEquals(value.toString(), result.toString(), String.format(\n+    private static void checkBoolValue(PListReader plist, String key, boolean value) {\n+        boolean result = plist.queryBoolValue(key);\n+        TKit.assertEquals(value, result, String.format(\n@@ -91,1 +92,1 @@\n-        List<String> result = plist.queryArrayValue(key);\n+        List<String> result = plist.queryStringArrayValue(key);\n@@ -97,1 +98,6 @@\n-        var plist = MacHelper.readPListFromAppImage(appImage);\n+        final var rootPlist = MacHelper.readPListFromAppImage(appImage);\n+\n+        TKit.traceFileContents(appImage.resolve(\"Contents\/Info.plist\"), \"Info.plist\");\n+\n+        var plist = rootPlist.queryArrayValue(\"CFBundleDocumentTypes\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n+\n@@ -106,2 +112,7 @@\n-        checkArrayValue(plist, \"NSExportableTypes\", List.of(\"public.png\",\n-                                                            \"public.jpg\"));\n+        plist = rootPlist.queryArrayValue(\"UTExportedTypeDeclarations\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n+\n+        checkArrayValue(plist, \"UTTypeConformsTo\", List.of(\"public.image\", \"public.data\"));\n+\n+        plist = plist.queryDictValue(\"UTTypeTagSpecification\");\n+\n+        checkArrayValue(plist, \"NSExportableTypes\", List.of(\"public.png\", \"public.jpg\"));\n@@ -109,2 +120,0 @@\n-        checkArrayValue(plist, \"UTTypeConformsTo\", List.of(\"public.image\",\n-                                                           \"public.data\"));\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"}]}