{"files":[{"patch":"@@ -88,0 +88,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -1905,0 +1906,14 @@\n+WB_ENTRY(void, WB_ForceInflateMonitorLockedObject(JNIEnv* env, jobject wb, jobject obj))\n+  oop obj_oop = JNIHandles::resolve(obj);\n+  if (obj_oop->mark().has_monitor()) {\n+    return; \/\/ Already inflated\n+  }\n+  ObjectSynchronizer::InflateCause cause = ObjectSynchronizer::InflateCause::inflate_cause_vm_internal;\n+  JavaThread* current = JavaThread::current();\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::inflate_fast_locked_object(obj_oop, cause, current, current);\n+  } else {\n+    ObjectSynchronizer::inflate(current, obj_oop, cause);\n+  }\n+WB_END\n+\n@@ -2909,0 +2924,1 @@\n+  {CC\"forceInflateMonitorLockedObject0\", CC\"(Ljava\/lang\/Object;)V\", (void*)&WB_ForceInflateMonitorLockedObject },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1838,9 +1838,0 @@\n-#ifndef _LP64\n-  if (LockingMode == LM_LEGACY) {\n-    FLAG_SET_CMDLINE(LockingMode, LM_LIGHTWEIGHT);\n-    \/\/ Self-forwarding in bit 3 of the mark-word conflicts\n-    \/\/ with 4-byte-aligned stack-locks.\n-    warning(\"Legacy locking not supported on this platform\");\n-  }\n-#endif\n-\n@@ -3772,3 +3763,0 @@\n-  if (UseCompactObjectHeaders && LockingMode != LM_LIGHTWEIGHT) {\n-    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1960,7 +1960,0 @@\n-  product(int, LockingMode, LM_LIGHTWEIGHT,                                 \\\n-          \"(Deprecated) Select locking mode: \"                              \\\n-          \"0: (Deprecated) monitors only (LM_MONITOR), \"                    \\\n-          \"1: (Deprecated) monitors & legacy stack-locking (LM_LEGACY), \"   \\\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT, default)\") \\\n-          range(0, 2)                                                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+const int LockingMode = LM_LIGHTWEIGHT;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1012,0 +1012,2 @@\n+extern const int LockingMode;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime;\n-\n-import sun.jvm.hotspot.types.TypeDataBase;\n-\n-\n-\/** Encapsulates the LockingMode enum in globalDefinitions.hpp in\n-    the VM. *\/\n-\n-public class LockingMode {\n-  private static int monitor;\n-  private static int legacy;\n-  private static int lightweight;\n-\n-  static {\n-    VM.registerVMInitializedObserver(\n-        (o, d) -> initialize(VM.getVM().getTypeDataBase()));\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    monitor     = db.lookupIntConstant(\"LM_MONITOR\").intValue();\n-    legacy      = db.lookupIntConstant(\"LM_LEGACY\").intValue();\n-    lightweight = db.lookupIntConstant(\"LM_LIGHTWEIGHT\").intValue();\n-  }\n-\n-  public static int getMonitor() {\n-    return monitor;\n-  }\n-\n-  public static int getLegacy() {\n-    return legacy;\n-  }\n-\n-  public static int getLightweight() {\n-    return lightweight;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/LockingMode.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -225,22 +225,6 @@\n-            if (VM.getVM().getCommandLineFlag(\"LockingMode\").getInt() == LockingMode.getLightweight()) {\n-                OopHandle object = monitor.object();\n-                for (int i = 0; i < getNumberOfThreads(); i++) {\n-                    JavaThread thread = getJavaThreadAt(i);\n-                    if (thread.isLockOwned(object)) {\n-                        return thread;\n-                     }\n-                }\n-                \/\/ We should have found the owner, however, as the VM could be in any state, including the middle\n-                \/\/ of performing GC, it is not always possible to do so. Just return null if we can't locate it.\n-                System.out.println(\"Warning: We failed to find a thread that owns an anonymous lock. This is likely\");\n-                System.out.println(\"due to the JVM currently running a GC. Locking information may not be accurate.\");\n-                return null;\n-            } else {\n-                assert(VM.getVM().getCommandLineFlag(\"LockingMode\").getInt() == LockingMode.getLegacy());\n-                Address o = (Address)monitor.stackLocker();\n-                for (int i = 0; i < getNumberOfThreads(); i++) {\n-                    JavaThread thread = getJavaThreadAt(i);\n-                    if (thread.isLockOwned(o))\n-                        return thread;\n-                }\n-                return null;\n+            OopHandle object = monitor.object();\n+            for (int i = 0; i < getNumberOfThreads(); i++) {\n+                JavaThread thread = getJavaThreadAt(i);\n+                if (thread.isLockOwned(object)) {\n+                    return thread;\n+                 }\n@@ -248,0 +232,5 @@\n+            \/\/ We should have found the owner, however, as the VM could be in any state, including the middle\n+            \/\/ of performing GC, it is not always possible to do so. Just return null if we can't locate it.\n+            System.out.println(\"Warning: We failed to find a thread that owns an anonymous lock. This is likely\");\n+            System.out.println(\"due to the JVM currently running a GC. Locking information may not be accurate.\");\n+            return null;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-gtest\/LockStackGtests.java                              8356201 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-StaticJdk.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-  gtest\/LockStackGtests.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n- * @run main\/othervm -Xbatch -XX:LockingMode=1\n- *                   -XX:CompileOnly=compiler.locks.TestSynchronizeWithEmptyBlock::*\n- *                   compiler.locks.TestSynchronizeWithEmptyBlock\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestSynchronizeWithEmptyBlock.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/* @test\n- * @summary Run LockStack gtests with LockingMode=2\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.xml\n- * @requires vm.flagless\n- * @run main\/native GTestWrapper --gtest_filter=LockStackTest* -XX:LockingMode=2\n- *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/LockStackGtests.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -37,1 +38,3 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedAsyncDeflationInterval=2000 -XX:LockingMode=0 ConcurrentDeflation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedAsyncDeflationInterval=2000 -XX:+WhiteBoxAPI ConcurrentDeflation\n@@ -41,0 +44,1 @@\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n@@ -76,0 +80,1 @@\n+                WB.forceInflateMonitorLockedObject(monitors[index]);\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/ConcurrentDeflation.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,15 +36,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 1\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 1\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=2\n@@ -66,15 +51,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 2\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 2\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=2\n@@ -97,15 +67,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 1\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 1\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=2\n@@ -128,15 +83,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 2\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 2\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=2\n@@ -159,15 +99,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 1\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:-EliminateNestedLocks\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 1\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:-EliminateNestedLocks\n- *     -XX:LockingMode=2\n@@ -185,1 +110,0 @@\n- *\n@@ -187,13 +111,0 @@\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:LockingMode=0\n- *     -XX:-EliminateNestedLocks\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 2\n- *\n- * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:LockingMode=1\n- *     -XX:-EliminateNestedLocks\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 120 2\n@@ -203,1 +114,0 @@\n- *     -XX:LockingMode=2\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -36,15 +36,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 1\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 1\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=2\n@@ -66,15 +51,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 2\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 2\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -Xint\n- *     -XX:LockingMode=2\n@@ -97,15 +67,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 1\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 1\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=2\n@@ -128,15 +83,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 2\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 2\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:TieredStopAtLevel=1\n- *     -XX:LockingMode=2\n@@ -159,15 +99,0 @@\n- *     -XX:LockingMode=0\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 1\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:-EliminateNestedLocks\n- *     -XX:LockingMode=1\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 1\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:-EliminateNestedLocks\n- *     -XX:LockingMode=2\n@@ -185,1 +110,0 @@\n- *\n@@ -187,13 +111,0 @@\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:LockingMode=0\n- *     -XX:-EliminateNestedLocks\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 2\n- *\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *     -XX:LockingMode=1\n- *     -XX:-EliminateNestedLocks\n- *     -Xms256m -Xmx256m\n- *     TestRecursiveLocking 5 2\n@@ -203,1 +114,0 @@\n- *     -XX:LockingMode=2\n@@ -215,1 +125,0 @@\n-    static final int flagLockingMode = WB.getIntVMFlag(\"LockingMode\").intValue();\n@@ -217,3 +126,0 @@\n-    static final int LM_MONITOR = 0;\n-    static final int LM_LEGACY = 1;\n-    static final int LM_LIGHTWEIGHT = 2;\n@@ -232,7 +138,3 @@\n-            \/\/ Legacy mode has no lock stack, i.e., there is no limit\n-            \/\/ on recursion, so for legacy mode we can't say that\n-            \/\/ \"outer\" must be inflated here, which we can say for all\n-            \/\/ the other locking modes.\n-            if (flagLockingMode != LM_LEGACY) {\n-                outer.assertInflated();\n-            }\n+            \/\/ There is limit on recursion, so \"outer\" must be\n+            \/\/ inflated here.\n+            outer.assertInflated();\n@@ -243,3 +145,1 @@\n-            if (flagLockingMode != LM_MONITOR) {\n-                assertNotInflated();\n-            }\n+            assertNotInflated();\n@@ -251,3 +151,1 @@\n-            if (flagLockingMode != LM_MONITOR) {\n-                assertNotInflated();\n-            }\n+            assertNotInflated();\n@@ -259,3 +157,1 @@\n-            if (flagLockingMode != LM_MONITOR) {\n-                assertNotInflated();\n-            }\n+            assertNotInflated();\n@@ -267,3 +163,1 @@\n-            if (flagLockingMode != LM_LEGACY) {\n-                assertInflated();\n-            }\n+            assertInflated();\n@@ -286,3 +180,1 @@\n-                if (flagLockingMode != LM_MONITOR) {\n-                    OUTER.assertNotInflated();\n-                }\n+                OUTER.assertNotInflated();\n@@ -291,7 +183,2 @@\n-\n-                if (flagLockingMode != LM_LEGACY) {\n-                    OUTER.assertInflated();\n-                }\n-                if (flagLockingMode != LM_MONITOR) {\n-                    INNER.assertNotInflated();\n-                }\n+                OUTER.assertInflated();\n+                INNER.assertNotInflated();\n@@ -311,16 +198,13 @@\n-            if (flagLockingMode == LM_LIGHTWEIGHT) {\n-                \/\/ First time we lock A, A is the only one on the lock\n-                \/\/ stack.\n-                if (counter == 1) {\n-                    assertNotInflated();\n-                } else {\n-                    \/\/ Second time we want to lock A, the lock stack\n-                    \/\/ looks like this [A, B]. Lightweight locking\n-                    \/\/ doesn't allow interleaving ([A, B, A]), instead\n-                    \/\/ it inflates A and removes it from the lock\n-                    \/\/ stack. Which leaves us with only [B] on the\n-                    \/\/ lock stack. After more recursions it will grow\n-                    \/\/ to [B, B ... B].\n-                    assertInflated();\n-                }\n-            } else if (flagLockingMode == LM_MONITOR) {\n+\n+            \/\/ First time we lock A, A is the only one on the lock\n+            \/\/ stack.\n+            if (counter == 1) {\n+                assertNotInflated();\n+            } else {\n+                \/\/ Second time we want to lock A, the lock stack\n+                \/\/ looks like this [A, B]. Lightweight locking\n+                \/\/ doesn't allow interleaving ([A, B, A]), instead\n+                \/\/ it inflates A and removes it from the lock\n+                \/\/ stack. Which leaves us with only [B] on the\n+                \/\/ lock stack. After more recursions it will grow\n+                \/\/ to [B, B ... B].\n@@ -330,0 +214,1 @@\n+\n@@ -337,10 +222,7 @@\n-            if (flagLockingMode != LM_MONITOR) {\n-                \/\/ Legacy tolerates endless recursions. While testing\n-                \/\/ lightweight we don't go deeper than the size of the\n-                \/\/ lock stack, which in this test case will be filled\n-                \/\/ with a number of B-elements. See comment in runA()\n-                \/\/ above for more info.\n-                assertNotInflated();\n-            } else {\n-                assertInflated();\n-            }\n+\n+            \/\/ Legacy tolerates endless recursions. While testing\n+            \/\/ lightweight we don't go deeper than the size of the\n+            \/\/ lock stack, which in this test case will be filled\n+            \/\/ with a number of B-elements. See comment in runA()\n+            \/\/ above for more info.\n+            assertNotInflated();\n@@ -373,6 +255,0 @@\n-            if (flagLockingMode == LM_LEGACY) {\n-                A.assertNotInflated();\n-            }\n-            \/\/ Implied else: for LM_MONITOR or LM_LIGHTWEIGHT it can be\n-            \/\/ either inflated or not because A is not locked anymore\n-            \/\/ and subject to deflation.\n@@ -380,3 +256,5 @@\n-            if (flagLockingMode != LM_MONITOR) {\n-                B.assertNotInflated();\n-            }\n+            \/\/ Here A can be either inflated or not because A is not\n+            \/\/ locked anymore and subject to deflation.\n+\n+            B.assertNotInflated();\n+\n@@ -446,1 +324,0 @@\n-        System.out.println(\"INFO: LockingMode=\" + flagLockingMode);\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/TestRecursiveLocking.java","additions":36,"deletions":159,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xint -XX:LockingMode=2 TestLockStackCapacity\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xint TestLockStackCapacity\n@@ -42,2 +42,0 @@\n-    static final int LockingMode = WB.getIntVMFlag(\"LockingMode\").intValue();\n-    static final int LM_LIGHTWEIGHT = 2;\n@@ -98,4 +96,0 @@\n-        if (LockingMode != LM_LIGHTWEIGHT) {\n-            throw new SkippedException(\"Test only valid for LM_LIGHTWEIGHT\");\n-        }\n-\n@@ -103,1 +97,1 @@\n-            throw new SkippedException(\"Test only valid if LM_LIGHTWEIGHT supports recursion\");\n+            throw new SkippedException(\"Test only valid if lightweight locking supports recursion\");\n","filename":"test\/hotspot\/jtreg\/runtime\/lockStack\/TestLockStackCapacity.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-    static final int LM_MONITOR = 0;\n@@ -57,2 +56,2 @@\n-        if (WB.getIntVMFlag(\"LockingMode\") == LM_MONITOR) {\n-            throw new SkippedException(\"LM_MONITOR always inflates. Invalid test.\");\n+        if (WB.getBooleanVMFlag(\"VerifyHeavyMonitors\")) {\n+            throw new SkippedException(\"VerifyHeavyMonitors always inflates. Invalid test.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,303 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/*\n- * Tests that JNI monitors work correctly with virtual threads,\n- * There are multiple test scenarios that we check using unified logging output\n- * (both positive and negative tests). Each test case is handled by its own @-test\n- * definition so that we can run each sub-test independently.\n- *\n- * The original bug was only discovered because the ForkJoinPool worker thread terminated\n- * and trigerred an assertion failure. So we use a custom scheduler to give us control.\n- *\/\n-\n-\/**\n- * @test id=normal\n- * @bug 8327743\n- * @summary Normal lock then unlock\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:+open\n- * @requires vm.continuations\n- * @run driver JNIMonitor Normal\n- *\/\n-\n-\/**\n- * @test id=multiNormal\n- * @bug 8327743\n- * @summary Normal lock then unlock by multiple threads\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:+open\n- * @requires vm.continuations\n- * @run driver JNIMonitor MultiNormal\n- *\/\n-\n-\/**\n- * @test id=missingUnlock\n- * @bug 8327743\n- * @summary Don't do the unlock and exit normally\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:+open\n- * @requires vm.continuations\n- * @run driver JNIMonitor MissingUnlock\n- *\/\n-\n-\/**\n- * @test id=multiMissingUnlock\n- * @bug 8327743\n- * @summary Don't do the unlock and exit normally, by multiple threads\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:+open\n- * @requires vm.continuations\n- * @run driver JNIMonitor MultiMissingUnlock\n- *\/\n-\n-\/**\n- * @test id=missingUnlockWithThrow\n- * @bug 8327743\n- * @summary Don't do the unlock and exit by throwing\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:+open\n- * @requires vm.continuations\n- * @run driver JNIMonitor MissingUnlockWithThrow\n- *\/\n-\n-\/**\n- * @test id=multiMissingUnlockWithThrow\n- * @bug 8327743\n- * @summary Don't do the unlock and exit by throwing, by multiple threads\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:+open\n- * @requires vm.continuations\n- * @run driver JNIMonitor MultiMissingUnlockWithThrow\n- *\/\n-\n-public class JNIMonitor {\n-\n-    public static void main(String[] args) throws Exception {\n-        String test = args[0];\n-        String[] cmdArgs = new String[] {\n-            \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-            \/\/ Grant access to ThreadBuilders$VirtualThreadBuilder\n-            \"--add-opens=java.base\/java.lang=ALL-UNNAMED\",\n-            \/\/ Enable the JNI warning\n-            \"-Xcheck:jni\",\n-            \"-Xlog:jni=debug\",\n-            \/\/ Enable thread termination logging as a visual cross-check\n-            \"-Xlog:thread+os=info\",\n-            \/\/ We only count monitors in LM_LEGACY mode\n-            \"-XX:LockingMode=1\",\n-            \/\/ Disable compact headers since that switches locking mode to LM_LIGHTWEIGHT\n-            \"-XX:-UseCompactObjectHeaders\",\n-            \"JNIMonitor$\" + test,\n-        };\n-        OutputAnalyzer oa = ProcessTools.executeTestJava(cmdArgs);\n-        oa.shouldHaveExitValue(0);\n-        oa.stdoutShouldMatch(terminated);\n-\n-        switch(test) {\n-            case \"Normal\":\n-            case \"MultiNormal\":\n-                oa.stdoutShouldNotMatch(stillLocked);\n-                break;\n-            case \"MissingUnlock\":\n-                oa.stdoutShouldMatch(stillLocked);\n-                break;\n-            case \"MultiMissingUnlock\":\n-                parseOutputForPattern(oa.stdoutAsLines(), stillLocked, MULTI_THREAD_COUNT);\n-                break;\n-            case \"MissingUnlockWithThrow\":\n-                oa.stdoutShouldMatch(stillLocked);\n-                oa.stderrShouldContain(throwMsg);\n-                break;\n-            case \"MultiMissingUnlockWithThrow\":\n-                parseOutputForPattern(oa.stdoutAsLines(), stillLocked, MULTI_THREAD_COUNT);\n-                parseOutputForPattern(oa.stderrAsLines(), throwMsg, MULTI_THREAD_COUNT);\n-                break;\n-\n-            default: throw new Error(\"Unknown arg: \" + args[0]);\n-        }\n-        oa.reportDiagnosticSummary();\n-    }\n-\n-    \/\/ The number of threads for a multi tests. Arbitrarily chosen to be > 1 but small\n-    \/\/ enough to not waste too much time.\n-    static final int MULTI_THREAD_COUNT = 5;\n-\n-    \/\/ The logging message for leaving a monitor JNI locked has the form\n-    \/\/   [0.187s][debug][jni] VirtualThread (tid: 28, carrier id: 29) exiting with Objects still locked by JNI MonitorEnter.\n-    \/\/ but if the test is run with other logging options then whitespace may get introduced in the\n-    \/\/ log decorator sections, so ignore those.\n-    static final String stillLocked = \"VirtualThread \\\\(tid:.*exiting with Objects still locked by JNI MonitorEnter\";\n-    \/\/ The carrier thread termination logging has the form:\n-    \/\/ [1.394s][info][os,thread] JavaThread exiting (name: \"pool-1-thread-1\", tid: 3090592).\n-    static final String terminated = \"JavaThread exiting \\\\(name: \\\"pool-1-thread-1\\\"\";\n-\n-    static final String throwMsg = \"Terminating via exception as requested\";\n-\n-    \/\/ Check the process logging output for the given pattern to see if the expected number of\n-    \/\/ lines are found.\n-    private static void parseOutputForPattern(List<String> lines, String pattern, int expected) {\n-        Pattern p = Pattern.compile(pattern);\n-        int found = 0;\n-        for (String line : lines) {\n-            Matcher m = p.matcher(line);\n-            if (m.find()) {\n-                found++;\n-            }\n-        }\n-        if (found != expected) {\n-            throw new RuntimeException(\"Checking for pattern \\\"\" + pattern + \"\\\": expected \"\n-                                       + expected + \" but found \" + found);\n-        }\n-    }\n-\n-\n-    \/\/ straight-forward interface to JNI monitor functions\n-    static native int monitorEnter(Object o);\n-    static native int monitorExit(Object o);\n-\n-    \/\/ Isolate the native library loading to the actual test cases, not the class that\n-    \/\/ jtreg Driver will load and execute.\n-    static class TestBase {\n-\n-        static {\n-            System.loadLibrary(\"JNIMonitor\");\n-        }\n-\n-        \/\/ This gives us a way to control the scheduler used for our virtual threads. The test\n-        \/\/ only works as intended when the virtual threads run on the same carrier thread (as\n-        \/\/ that carrier maintains ownership of the monitor if the virtual thread fails to unlock it).\n-        \/\/ The original issue was also only discovered due to the carrier thread terminating\n-        \/\/ unexpectedly, so we can force that condition too by shutting down our custom scheduler.\n-        private static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n-            Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n-            try {\n-                Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-                Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-                ctor.setAccessible(true);\n-                return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof RuntimeException re) {\n-                    throw re;\n-                }\n-                throw new RuntimeException(e);\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        static void runTest(int nThreads, boolean skipUnlock, boolean throwOnExit) throws Throwable {\n-            final Object[] monitors = new Object[nThreads];\n-            for (int i = 0; i < nThreads; i++) {\n-                monitors[i] = new Object();\n-            }\n-            final AtomicReference<Throwable> exception = new AtomicReference();\n-            \/\/ Ensure all our VT's operate of the same carrier, sequentially.\n-            ExecutorService scheduler = Executors.newSingleThreadExecutor();\n-            ThreadFactory factory = virtualThreadBuilder(scheduler).factory();\n-            for (int i = 0 ; i < nThreads; i++) {\n-                Object monitor = skipUnlock ? monitors[i] : monitors[0];\n-                Thread th = factory.newThread(() -> {\n-                        try {\n-                            int res = monitorEnter(monitor);\n-                            Asserts.assertTrue(res == 0, \"monitorEnter should return 0.\");\n-                            Asserts.assertTrue(Thread.holdsLock(monitor), \"monitor should be owned\");\n-                            Thread.yield();\n-                            if (!skipUnlock) {\n-                                res = monitorExit(monitor);\n-                                Asserts.assertTrue(res == 0, \"monitorExit should return 0.\");\n-                                Asserts.assertFalse(Thread.holdsLock(monitor), \"monitor should be unowned\");\n-                            }\n-                        } catch (Throwable t) {\n-                            exception.set(t);\n-                        }\n-                        if (throwOnExit) {\n-                            throw new RuntimeException(throwMsg);\n-                        }\n-                    });\n-                th.start();\n-                th.join();\n-                if (exception.get() != null) {\n-                    throw exception.get();\n-                }\n-            }\n-            \/\/ Now force carrier thread to shutdown.\n-            scheduler.shutdown();\n-        }\n-    }\n-\n-    \/\/ These are the actual test case classes that get exec'd.\n-\n-    static class Normal extends TestBase {\n-        public static void main(String[] args) throws Throwable {\n-            runTest(1, false, false);\n-        }\n-    }\n-\n-    static class MultiNormal extends TestBase {\n-        public static void main(String[] args) throws Throwable {\n-            runTest(MULTI_THREAD_COUNT, false, false);\n-        }\n-    }\n-\n-    static class MissingUnlock extends TestBase  {\n-        public static void main(String[] args) throws Throwable {\n-            runTest(1, true, false);\n-        }\n-    }\n-\n-    static class MultiMissingUnlock extends TestBase {\n-        public static void main(String[] args) throws Throwable {\n-            runTest(MULTI_THREAD_COUNT, true, false);\n-        }\n-    }\n-\n-    static class MissingUnlockWithThrow extends TestBase {\n-        public static void main(String[] args) throws Throwable {\n-            runTest(1, true, true);\n-        }\n-    }\n-\n-    static class MultiMissingUnlockWithThrow extends TestBase {\n-        public static void main(String[] args) throws Throwable {\n-            runTest(MULTI_THREAD_COUNT, true, true);\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/JNIMonitor\/JNIMonitor.java","additions":0,"deletions":303,"binary":false,"changes":303,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,3 +280,1 @@\n-        boolean legacyLockingMode = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n-                                        .getVMOption(\"LockingMode\").getValue().equals(\"1\");\n-        return is_virtual && !isBoundVThread && !legacyLockingMode;\n+        return is_virtual && !isBoundVThread;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/StopThreadTest\/StopThreadTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2025 SAP SE. All rights reserved.\n@@ -37,36 +37,0 @@\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n- *                 -XX:LockingMode=1\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n- *                 -XX:LockingMode=1\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n- *                 -XX:LockingMode=1\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n- *                 -XX:LockingMode=1\n@@ -82,1 +46,0 @@\n- *                 -XX:LockingMode=2\n@@ -91,1 +54,0 @@\n- *                 -XX:LockingMode=2\n@@ -100,1 +62,0 @@\n- *                 -XX:LockingMode=2\n@@ -109,1 +70,0 @@\n- *                 -XX:LockingMode=2\n@@ -127,10 +87,0 @@\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n- *                 -XX:LockingMode=1\n- *                 -XX:DiagnoseSyncOnValueBasedClasses=2\n@@ -147,1 +97,0 @@\n- *                 -XX:LockingMode=2\n@@ -150,12 +99,0 @@\n- * @comment Re-lock may race with deflation.\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n- *                 -XX:LockingMode=0\n- *                 -XX:GuaranteedAsyncDeflationInterval=1000\n- *\n@@ -163,1 +100,1 @@\n- * @comment Regression test for re-locking racing with deflation with LM_LIGHTWEIGHT.\n+ * @comment Regression test for re-locking racing with deflation with lightweight locking.\n@@ -172,1 +109,0 @@\n- *                 -XX:LockingMode=2\n@@ -1818,2 +1754,2 @@\n- * <code>-XX:LockingMode=2<\/code> the lock stack of the thread will be full\n- * because of this.\n+ * lightweight the lock stack of the thread will be full because of\n+ * this.\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":4,"deletions":68,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,24 +34,0 @@\n-\/**\n- * @test id=LM_LIGHTWEIGHT\n- * @requires vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @library \/test\/lib\n- * @run junit\/othervm -XX:LockingMode=2 CarrierThreadInfo\n- *\/\n-\n-\/**\n- * @test id=LM_LEGACY\n- * @requires vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @library \/test\/lib\n- * @run junit\/othervm -XX:LockingMode=1 CarrierThreadInfo\n- *\/\n-\n-\/**\n- * @test id=LM_MONITOR\n- * @requires vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @library \/test\/lib\n- * @run junit\/othervm -XX:LockingMode=0 CarrierThreadInfo\n- *\/\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CarrierThreadInfo.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.management.ManagementFactory;\n-import com.sun.management.HotSpotDiagnosticMXBean;\n-\n-class LockingMode {\n-    private LockingMode() { }\n-\n-    \/**\n-     * Returns true if using legacy locking mode.\n-     *\/\n-    static boolean isLegacy() {\n-        return ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n-                .getVMOption(\"LockingMode\")\n-                .getValue()\n-                .equals(\"1\");\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/LockingMode.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.continuations\n@@ -36,1 +36,1 @@\n- * @requires vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.continuations\n@@ -44,1 +44,1 @@\n- * @requires vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.continuations\n@@ -52,1 +52,1 @@\n- * @requires vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.continuations\n@@ -61,1 +61,1 @@\n- * @requires vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.continuations\n@@ -68,1 +68,1 @@\n- * @requires vm.debug == true & vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.debug == true & vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MiscMonitorTests.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @build LockingMode\n@@ -34,1 +33,1 @@\n- * @test id=LM_LEGACY\n+ * @test id=Xint\n@@ -37,2 +36,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -42,1 +40,1 @@\n- * @test id=LM_LIGHTWEIGHT\n+ * @test id=Xcomp\n@@ -45,2 +43,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -50,1 +47,1 @@\n- * @test id=Xint-LM_LEGACY\n+ * @test id=Xcomp-TieredStopAtLevel1\n@@ -53,2 +50,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xint -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -58,1 +54,1 @@\n- * @test id=Xint-LM_LIGHTWEIGHT\n+ * @test id=Xcomp-noTieredCompilation\n@@ -61,50 +57,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xint -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n- *\/\n-\n-\/*\n- * @test id=Xcomp-LM_LEGACY\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n- *\/\n-\n-\/*\n- * @test id=Xcomp-LM_LIGHTWEIGHT\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n- *\/\n-\n-\/*\n- * @test id=Xcomp-TieredStopAtLevel1-LM_LEGACY\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n- *\/\n-\n-\/*\n- * @test id=Xcomp-TieredStopAtLevel1-LM_LIGHTWEIGHT\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n- *\/\n-\n-\/*\n- * @test id=Xcomp-noTieredCompilation-LM_LEGACY\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n- *\/\n-\n-\/*\n- * @test id=Xcomp-noTieredCompilation-LM_LIGHTWEIGHT\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -132,1 +79,0 @@\n-import org.junit.jupiter.api.condition.DisabledIf;\n@@ -237,1 +183,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n@@ -362,1 +307,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n@@ -406,1 +350,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":8,"deletions":65,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @build LockingMode\n@@ -34,1 +33,1 @@\n- * @test id=LM_LEGACY\n+ * @test id=Xint\n@@ -37,2 +36,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -42,1 +40,1 @@\n- * @test id=LM_LIGHTWEIGHT\n+ * @test id=Xcomp\n@@ -45,2 +43,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -50,1 +47,1 @@\n- * @test id=Xint-LM_LEGACY\n+ * @test id=Xcomp-TieredStopAtLevel1\n@@ -53,2 +50,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xint -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -58,1 +54,1 @@\n- * @test id=Xint-LM_LIGHTWEIGHT\n+ * @test id=Xcomp-noTieredCompilation\n@@ -61,50 +57,1 @@\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xint -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n- *\/\n-\n-\/*\n- * @test id=Xcomp-LM_LEGACY\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n- *\/\n-\n-\/*\n- * @test id=Xcomp-LM_LIGHTWEIGHT\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n- *\/\n-\n-\/*\n- * @test id=Xcomp-TieredStopAtLevel1-LM_LEGACY\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n- *\/\n-\n-\/*\n- * @test id=Xcomp-TieredStopAtLevel1-LM_LIGHTWEIGHT\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n- *\/\n-\n-\/*\n- * @test id=Xcomp-noTieredCompilation-LM_LEGACY\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation -XX:LockingMode=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n- *\/\n-\n-\/*\n- * @test id=Xcomp-noTieredCompilation-LM_LIGHTWEIGHT\n- * @modules java.base\/java.lang:+open jdk.management\n- * @library \/test\/lib\n- * @build LockingMode\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation -XX:LockingMode=2 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -134,1 +81,0 @@\n-import org.junit.jupiter.api.condition.DisabledIf;\n@@ -309,1 +255,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n@@ -367,1 +312,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n@@ -705,1 +649,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n@@ -762,1 +705,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":8,"deletions":66,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @build LockingMode\n@@ -37,1 +36,0 @@\n- * @build LockingMode\n@@ -45,1 +43,0 @@\n- * @build LockingMode\n@@ -53,1 +50,0 @@\n- * @build LockingMode\n@@ -69,1 +65,0 @@\n-import org.junit.jupiter.api.condition.DisabledIf;\n@@ -388,1 +383,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n@@ -438,1 +432,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Parking.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @requires vm.opt.LockingMode != 1\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/RetryMonitorEnterWhenPinned.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @build LockingMode\n@@ -39,1 +38,0 @@\n- * @build LockingMode\n@@ -73,1 +71,0 @@\n-import org.junit.jupiter.api.condition.DisabledIf;\n@@ -1115,1 +1112,0 @@\n-    @DisabledIf(\"LockingMode#isLegacy\")\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @requires vm.opt.LockingMode != 1\n@@ -32,7 +31,0 @@\n-\/*\n- * @test id=LM_LIGHTWEIGHT\n- * @requires vm.opt.LockingMode != 1\n- * @library \/test\/lib\n- * @run main\/othervm -XX:LockingMode=2 LotsOfContendedMonitorEnter\n- *\/\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/LotsOfContendedMonitorEnter.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,12 +31,0 @@\n-\/*\n- * @test id=LM_LEGACY\n- * @library \/test\/lib\n- * @run main\/othervm -XX:LockingMode=1 LotsOfUncontendedMonitorEnter\n- *\/\n-\n-\/*\n- * @test id=LM_LIGHTWEIGHT\n- * @library \/test\/lib\n- * @run main\/othervm -XX:LockingMode=2 LotsOfUncontendedMonitorEnter\n- *\/\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/LotsOfUncontendedMonitorEnter.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires vm.debug != true & vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.debug != true & vm.continuations\n@@ -35,1 +35,1 @@\n- * @requires vm.debug == true & vm.continuations & vm.opt.LockingMode != 1\n+ * @requires vm.debug == true & vm.continuations\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet100kWithMonitors.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,9 +48,0 @@\n-\/*\n- * @test\n- * @summary Exercise multithreaded maps, using only heavy monitors.\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\" | os.arch == \"s390x\"\n- * @requires vm.debug\n- * @library \/test\/lib\n- * @run main\/othervm\/timeout=1600 -XX:LockingMode=0 -XX:+VerifyHeavyMonitors MapLoops\n- *\/\n-\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/MapLoops.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,33 +284,0 @@\n-    @Test\n-    public void testPinnedMonitor() {\n-        if (!legacyLockingMode()) return;\n-\n-        \/\/ Test pinning due to held monitor\n-        final AtomicReference<Continuation.Pinned> res = new AtomicReference<>();\n-\n-        Continuation cont = new Continuation(FOO, ()-> {\n-            syncFoo(1);\n-        }) {\n-            @Override\n-            protected void onPinned(Continuation.Pinned reason) {\n-                assert Continuation.isPinned(FOO);\n-                res.set(reason);\n-            }\n-        };\n-\n-        cont.run();\n-        assertEquals(res.get(), Continuation.Pinned.MONITOR);\n-        boolean isDone = cont.isDone();\n-        assertEquals(isDone, true);\n-    }\n-\n-    static double syncFoo(int a) {\n-        long x = 8;\n-        String s = \"yyy\";\n-        String r;\n-        synchronized(FOO) {\n-            r = bar2(a + 1);\n-        }\n-        return Integer.parseInt(r)+1;\n-    }\n-\n@@ -422,5 +389,0 @@\n-\n-    static boolean legacyLockingMode() {\n-        return ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n-                    .getVMOption(\"LockingMode\").getValue().equals(\"1\");\n-    }\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Basic.java","additions":1,"deletions":39,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -476,1 +476,2 @@\n-        return traceHas(Op.PIN::contains) && legacyLockingMode();\n+        \/\/ Returns false since we never pin after we removed legacy locking.\n+        return traceHas(Op.PIN::contains) && false;\n@@ -1035,5 +1036,0 @@\n-\n-    static boolean legacyLockingMode() {\n-        return ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n-                    .getVMOption(\"LockingMode\").getValue().equals(\"1\");\n-    }\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-        map.put(\"vm.rtm.compiler\", this::vmRTMCompiler);\n@@ -420,15 +419,0 @@\n-    \/**\n-     * @return \"true\" if compiler in use supports RTM and \"false\" otherwise.\n-     * Note: Lightweight locking does not support RTM (for now).\n-     *\/\n-    protected String vmRTMCompiler() {\n-        boolean isRTMCompiler = false;\n-\n-        if (Compiler.isC2Enabled() &&\n-            (Platform.isX86() || Platform.isX64() || Platform.isPPC()) &&\n-            is_LM_LIGHTWEIGHT().equals(\"false\")) {\n-            isRTMCompiler = true;\n-        }\n-        return \"\" + isRTMCompiler;\n-    }\n-\n@@ -535,28 +519,0 @@\n-    \/**\n-     * @return LockingMode.\n-     *\/\n-    protected String vmLockingMode() {\n-        return \"\" + WB.getIntVMFlag(\"LockingMode\");\n-    }\n-\n-    \/**\n-     * @return \"true\" if LockingMode == 0 (LM_MONITOR)\n-     *\/\n-    protected String is_LM_MONITOR() {\n-        return \"\" + vmLockingMode().equals(\"0\");\n-    }\n-\n-    \/**\n-     * @return \"true\" if LockingMode == 1 (LM_LEGACY)\n-     *\/\n-    protected String is_LM_LEGACY() {\n-        return \"\" + vmLockingMode().equals(\"1\");\n-    }\n-\n-    \/**\n-     * @return \"true\" if LockingMode == 2 (LM_LIGHTWEIGHT)\n-     *\/\n-    protected String is_LM_LIGHTWEIGHT() {\n-        return \"\" + vmLockingMode().equals(\"2\");\n-    }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -121,0 +121,6 @@\n+  private native void forceInflateMonitorLockedObject0(Object obj);\n+  public         void forceInflateMonitorLockedObject(Object obj) {\n+    Objects.requireNonNull(obj);\n+    forceInflateMonitorLockedObject0(obj);\n+  }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}