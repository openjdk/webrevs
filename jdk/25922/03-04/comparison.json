{"files":[{"patch":"@@ -66,2 +66,1 @@\n-\/\/         This function checks for the @jdk.internal.vm.annotation.AOTSafeClassInitializer annotation, which\n-\/\/         also allows AOT-initialized classes to declare runtimeSetup() methods for the production run.\n+\/\/         This function checks for the @jdk.internal.vm.annotation.AOTSafeClassInitializer annotation.\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -767,4 +767,1 @@\n-  \/\/ Does this class request explicit initialization in AOT archives when they are initialized in assembly phase,\n-  \/\/ with explicit production run runtimeSetup() access?\n-  \/\/ Classes with instances are always initialized in AOT archive. This status is represented by has_aot_initialized_mirror().\n-  \/\/ However, access to setup functionality must be requested.\n+  \/\/ Indicates presence of @AOTSafeClassInitializer. Also see AOTClassInitializer for more details.\n@@ -774,1 +771,1 @@\n-  \/\/ Indicates private static void runtimeSetup() presence; requires has_aot_safe_initializer() as above.\n+  \/\/ Indicates @AOTRuntimeSetup private static void runtimeSetup() presence.\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/DirectMethodHandleDescImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,6 @@\n+> This is not true in the current implementation - a \"special object\n+> graph\" is tracked; currently we only ensure initialization is complete\n+> before objects are returned. This double-initialization is risky but\n+> apparently worked for simple cases before JEP 483. `heapShared.hpp`\n+> has more details about this graph.\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOT.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}