{"files":[{"patch":"@@ -40,20 +40,13 @@\n-\/\/ Detector for class names we wish to handle specially.\n-\/\/ It is either an exact string match or a string prefix match.\n-class AOTClassInitializer::AllowedSpec {\n-  const char* _class_name;\n-  bool _is_prefix;\n-  int _len;\n-public:\n-  AllowedSpec(const char* class_name, bool is_prefix = false)\n-    : _class_name(class_name), _is_prefix(is_prefix)\n-  {\n-    _len = (class_name == nullptr) ? 0 : (int)strlen(class_name);\n-  }\n-  const char* class_name() { return _class_name; }\n-\n-  bool matches(Symbol* name, int len) {\n-    assert(_class_name != nullptr, \"caller resp.\");\n-    if (_is_prefix) {\n-      return len >= _len && name->starts_with(_class_name);\n-    } else {\n-      return len == _len && name->equals(_class_name);\n+\/\/ Tell if ik is marked as AOT initialized via an annotation.\n+bool AOTClassInitializer::has_aot_initialization(InstanceKlass* ik) {\n+  if (ik->has_aot_initialization()) {\n+    \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n+    \/\/   - all super classes must be included\n+    \/\/   - all super interfaces that have <clinit> must be included.\n+    \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n+    \/\/ ik's <clinit>.\n+    if (ik->java_super() != nullptr) {\n+      DEBUG_ONLY(ResourceMark rm);\n+      assert(AOTClassInitializer::can_archive_initialized_mirror(ik->java_super()),\n+             \"super class %s of %s must be aot-initialized\", ik->java_super()->external_name(),\n+             ik->external_name());\n@@ -61,3 +54,0 @@\n-  }\n-};\n-\n@@ -65,15 +55,7 @@\n-\/\/ Tell if ik has a name that matches one of the given specs.\n-bool AOTClassInitializer::is_allowed(AllowedSpec* specs, InstanceKlass* ik) {\n-  Symbol* name = ik->name();\n-  int len = name->utf8_length();\n-  for (AllowedSpec* s = specs; s->class_name() != nullptr; s++) {\n-    if (s->matches(name, len)) {\n-      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n-      \/\/   - all super classes must be included\n-      \/\/   - all super interfaces that have <clinit> must be included.\n-      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n-      \/\/ ik's <clinit>.\n-      if (ik->java_super() != nullptr) {\n-        DEBUG_ONLY(ResourceMark rm);\n-        assert(AOTClassInitializer::can_archive_initialized_mirror(ik->java_super()),\n-               \"super class %s of %s must be aot-initialized\", ik->java_super()->external_name(),\n+    Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+    int len = interfaces->length();\n+    for (int i = 0; i < len; i++) {\n+      InstanceKlass* intf = interfaces->at(i);\n+      if (intf->class_initializer() != nullptr) {\n+        assert(AOTClassInitializer::can_archive_initialized_mirror(intf),\n+               \"super interface %s (which has <clinit>) of %s must be aot-initialized\", intf->external_name(),\n@@ -82,0 +64,1 @@\n+    }\n@@ -83,12 +66,3 @@\n-      Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-      int len = interfaces->length();\n-      for (int i = 0; i < len; i++) {\n-        InstanceKlass* intf = interfaces->at(i);\n-        if (intf->class_initializer() != nullptr) {\n-          assert(AOTClassInitializer::can_archive_initialized_mirror(intf),\n-                 \"super interface %s (which has <clinit>) of %s must be aot-initialized\", intf->external_name(),\n-                 ik->external_name());\n-        }\n-      }\n-\n-      return true;\n+    if (log_is_enabled(Info, aot, init)) {\n+      ResourceMark rm;\n+      log_info(aot, init)(\"Found @AOTClassInitializer class %s\", ik->external_name());\n@@ -96,0 +70,2 @@\n+\n+    return true;\n@@ -263,4 +239,0 @@\n-  \/\/ IS_PREFIX means that we match all class names that start with a\n-  \/\/ prefix.  Otherwise, it is an exact match, of just one class name.\n-  const bool IS_PREFIX = true;\n-\n@@ -268,1 +240,1 @@\n-    static AllowedSpec specs[] = {\n+    if (ik == vmClasses::Object_klass()) {\n@@ -270,5 +242,0 @@\n-      {\"java\/lang\/Object\"},\n-\n-      {nullptr}\n-    };\n-    if (is_allowed(specs, ik)) {\n@@ -280,1 +247,1 @@\n-    \/\/ This table was created with the help of CDSHeapVerifier.\n+    \/\/ The list of @AOTClassInitializer was created with the help of CDSHeapVerifier.\n@@ -284,33 +251,0 @@\n-    \/\/\n-    \/\/ We hope we can reduce the size of this list over time, and move\n-    \/\/ the responsibility for identifying such classes into the JDK\n-    \/\/ code itself.  See tracking RFE JDK-8342481.\n-    static AllowedSpec indy_specs[] = {\n-      {\"java\/lang\/constant\/ConstantDescs\"},\n-      {\"java\/lang\/constant\/DynamicConstantDesc\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle$Specializer\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle$Species_\", IS_PREFIX},\n-      {\"java\/lang\/invoke\/ClassSpecializer\"},\n-      {\"java\/lang\/invoke\/ClassSpecializer$\", IS_PREFIX},\n-      {\"java\/lang\/invoke\/DelegatingMethodHandle\"},\n-      {\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\"},     \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/DirectMethodHandle\"},\n-      {\"java\/lang\/invoke\/DirectMethodHandle$Constructor\"},\n-      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},         \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/Invokers\"},\n-      {\"java\/lang\/invoke\/Invokers$Holder\"},                   \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/LambdaForm\"},\n-      {\"java\/lang\/invoke\/LambdaForm$Holder\"},                 \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/LambdaForm$NamedFunction\"},\n-      {\"java\/lang\/invoke\/LambdaMetafactory\"},\n-      {\"java\/lang\/invoke\/MethodHandle\"},\n-      {\"java\/lang\/invoke\/MethodHandles\"},\n-      {\"java\/lang\/invoke\/SimpleMethodHandle\"},\n-      {\"java\/lang\/invoke\/StringConcatFactory\"},\n-      {\"java\/lang\/invoke\/VarHandleGuards\"},\n-      {\"java\/util\/Collections\"},\n-      {\"java\/util\/stream\/Collectors\"},\n-      {\"jdk\/internal\/constant\/ConstantUtils\"},\n-      {\"jdk\/internal\/constant\/PrimitiveClassDescImpl\"},\n-      {\"jdk\/internal\/constant\/ReferenceClassDescImpl\"},\n@@ -318,2 +252,2 @@\n-    \/\/ Can't include this, as it will pull in MethodHandleStatics which has many environment\n-    \/\/ dependencies (on system properties, etc).\n+    \/\/ Can't include InvokerBytecodeGenerator, as it will pull in MethodHandleStatics which has many\n+    \/\/ environment dependencies (on system properties, etc).\n@@ -322,9 +256,1 @@\n-    \/\/{\"java\/lang\/invoke\/InvokerBytecodeGenerator\"},\n-\n-      {nullptr}\n-    };\n-    if (is_allowed(indy_specs, ik)) {\n-      return true;\n-    }\n-\n-    if (ik->name()->starts_with(\"java\/lang\/invoke\/MethodHandleImpl\")) {\n+    if (has_aot_initialization(ik)) {\n@@ -344,9 +270,10 @@\n-\/\/ TODO: currently we have a hard-coded list. We should turn this into\n-\/\/ an annotation: @jdk.internal.vm.annotation.RuntimeSetupRequired\n-\/\/ See JDK-8342481.\n-bool AOTClassInitializer::is_runtime_setup_required(InstanceKlass* ik) {\n-  return ik == vmClasses::Class_klass() ||\n-         ik == vmClasses::internal_Unsafe_klass() ||\n-         ik == vmClasses::ConcurrentHashMap_klass() ||\n-         ik == vmClasses::MethodHandleImpl_klass() ||\n-         ik == vmClasses::Reference_klass();\n+bool AOTClassInitializer::has_runtime_setup(InstanceKlass* ik) {\n+  if (ik->has_aot_initialization()) {\n+    Method* runtime_setup_method = ik->find_method(vmSymbols::runtimeSetup(), vmSymbols::void_method_signature());\n+    if (runtime_setup_method != nullptr) {\n+      assert(runtime_setup_method->access_flags().is_private() && runtime_setup_method->access_flags().is_static(),\n+             \"%s::runtimeSetup() not private static\", ik->external_name());\n+      return true;\n+    }\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":41,"deletions":114,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-  class AllowedSpec;\n-  static bool is_allowed(AllowedSpec* specs, InstanceKlass* ik);\n+  static bool has_aot_initialization(InstanceKlass* ik);\n@@ -42,1 +41,1 @@\n-  static bool is_runtime_setup_required(InstanceKlass* ik);\n+  static bool has_runtime_setup(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  if (AOTClassInitializer::is_runtime_setup_required(ik)) {\n+  if (AOTClassInitializer::has_runtime_setup(ik)) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -944,0 +944,1 @@\n+    _jdk_internal_vm_annotation_AOTClassInitializer,\n@@ -1899,0 +1900,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_AOTClassInitializer_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _jdk_internal_vm_annotation_AOTClassInitializer;\n+    }\n@@ -1978,0 +1984,3 @@\n+  if (has_annotation(_jdk_internal_vm_annotation_AOTClassInitializer)) {\n+    ik->set_has_aot_initialization();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -735,0 +735,1 @@\n+  template(jdk_internal_vm_annotation_AOTClassInitializer_signature, \"Ljdk\/internal\/vm\/annotation\/AOTClassInitializer;\")\\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -767,0 +767,10 @@\n+  \/\/ Does this class request explicit initialization in AOT archives when they are initialized in assembly phase,\n+  \/\/ with explicit assembly phase assemblyCleanup() or production run runtimeSetup() access?\n+  \/\/ Classes with instances are always initialized in AOT archive. This status is represented by has_aot_initialized_mirror().\n+  \/\/ However, access to setup\/cleanup functionality must be requested.\n+  bool has_aot_initialization() const { return _misc_flags.has_aot_initialization(); }\n+  void set_has_aot_initialization()   { _misc_flags.set_has_aot_initialization(true); }\n+\n+  bool is_runtime_setup_required() const { return _misc_flags.is_runtime_setup_required(); }\n+  void set_is_runtime_setup_required()   { _misc_flags.set_is_runtime_setup_required(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    flag(has_aot_initialization             , 1 << 14) \/* True if klass explicitly requests to be initialized in AOT archive *\/ \\\n+    flag(is_runtime_setup_required          , 1 << 15) \/* True if klass has a runtimeSetup method to be called *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,3 +189,0 @@\n-    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n-    \/\/ method during the production run?\n-    _is_runtime_setup_required             = 1 << 7,\n@@ -383,9 +380,0 @@\n-  void set_is_runtime_setup_required() {\n-    assert(has_aot_initialized_mirror(), \"sanity\");\n-    CDS_ONLY(_shared_class_flags |= _is_runtime_setup_required;)\n-  }\n-  bool is_runtime_setup_required() const {\n-    CDS_ONLY(return (_shared_class_flags & _is_runtime_setup_required) != 0;)\n-    NOT_CDS(return false;)\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -214,0 +215,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -59,0 +60,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n+\n@@ -59,0 +61,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicConstantDesc.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -47,0 +48,1 @@\n+@AOTClassInitializer\n@@ -236,0 +238,1 @@\n+    @AOTClassInitializer\n@@ -315,0 +318,1 @@\n+    @AOTClassInitializer\n@@ -405,0 +409,1 @@\n+    @AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -67,0 +68,1 @@\n+@AOTClassInitializer\n@@ -72,0 +74,3 @@\n+    private static final RuntimeVisibleAnnotationsAttribute AOT_INITIALIZER_ANNOTATION = RuntimeVisibleAnnotationsAttribute.of(\n+            Annotation.of(ConstantUtils.referenceClassDesc(AOTClassInitializer.class))\n+    );\n@@ -236,0 +241,1 @@\n+    @AOTClassInitializer\n@@ -472,0 +478,1 @@\n+    @AOTClassInitializer\n@@ -627,0 +634,1 @@\n+                       .with(AOT_INITIALIZER_ANNOTATION)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n+\n@@ -39,0 +42,1 @@\n+@AOTClassInitializer\n@@ -196,0 +200,1 @@\n+    @AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -52,0 +53,1 @@\n+@AOTClassInitializer\n@@ -469,0 +471,1 @@\n+    @AOTClassInitializer\n@@ -940,0 +943,1 @@\n+    @AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -30,0 +31,1 @@\n+import java.lang.classfile.Annotation;\n@@ -31,0 +33,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -70,0 +73,1 @@\n+    static final Annotation AOT_INITIALIZER_ANNOTATION = Annotation.of(AOTClassInitializer.class.describeConstable().orElseThrow());\n@@ -565,0 +569,1 @@\n+               .with(RuntimeVisibleAnnotationsAttribute.of(AOT_INITIALIZER_ANNOTATION))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -46,0 +47,1 @@\n+@AOTClassInitializer\n@@ -699,0 +701,1 @@\n+    @AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -125,0 +126,1 @@\n+@AOTClassInitializer\n@@ -1035,0 +1037,1 @@\n+    @AOTClassInitializer\n@@ -1731,0 +1734,1 @@\n+    @AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n+\n@@ -250,0 +252,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -445,0 +446,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -75,0 +76,1 @@\n+@AOTClassInitializer\n@@ -161,0 +163,1 @@\n+    @AOTClassInitializer\n@@ -456,0 +459,1 @@\n+    @AOTClassInitializer\n@@ -678,0 +682,1 @@\n+    @AOTClassInitializer\n@@ -713,0 +718,1 @@\n+    @AOTClassInitializer\n@@ -1038,0 +1044,1 @@\n+    @AOTClassInitializer\n@@ -1146,0 +1153,1 @@\n+        @AOTClassInitializer\n@@ -1288,0 +1296,1 @@\n+    @AOTClassInitializer\n@@ -1351,0 +1360,1 @@\n+    @AOTClassInitializer\n@@ -1781,0 +1791,1 @@\n+    @AOTClassInitializer\n@@ -2108,0 +2119,1 @@\n+    @AOTClassInitializer\n@@ -2137,0 +2149,1 @@\n+    @AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -86,0 +87,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -30,3 +31,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.*;\n-import static java.lang.invoke.MethodHandleStatics.*;\n-\n@@ -39,0 +37,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SimpleMethodHandle.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -119,0 +120,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -31,0 +32,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -751,0 +751,1 @@\n+\/\/            System.out.println(\"import jdk.internal.vm.annotation.MethodHandleArchived;\");\n@@ -755,0 +756,1 @@\n+\/\/            System.out.println(\"@MethodHandleArchived\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -46,1 +47,1 @@\n-\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n+\n@@ -71,1 +73,1 @@\n-\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -85,0 +86,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -266,0 +267,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -106,0 +107,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Collectors.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -44,0 +45,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -44,0 +45,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n+\n@@ -46,0 +48,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/DirectMethodHandleDescImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -53,0 +54,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -41,0 +42,1 @@\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTClassInitializer;\n@@ -55,1 +56,1 @@\n-\n+@AOTClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+AOTClassInitializer\n+------\n+\n+Normally, static initializers, if not triggered by an AOT cache, are\n+executed in a demand-driven order specified by the JVMS and JLS.\n+\n+The implementation of an AOT cache uses restricted execution of the\n+JVM during an \"assembly phase\", which executes certain class\n+initializers and bootstrap methods in a separate JVM, and then records\n+associated memory images of the results into the AOT cache.\n+\n+When a production run uses that AOT cache, it starts up in a state\n+which looks exactly as if the execution of that assembly phase was the\n+earliest part of the production run.  Thus, the application observes\n+the effect of classes having been loaded, linked, and even\n+initialized, as if the JVM did that work at the exact moment\n+requested, though unaccountably fast.\n+\n+This optimization only works if every operation in the assembly phase\n+is \"pure\" enough to execute in a separate JVM.  For example, such an\n+operation cannot be allowed to observe the process ID or a wall clock.\n+It must not write the file system, and may only read parts which (like\n+the classpath) we can prove will be the same for both JVM runs.  If a\n+special value like random seed is picked, it must be a value that will\n+not need to be picked again in the production run.\n+\n+Controlling the \"purity\" of all of these operations mandates that we\n+place very tight restrictions on what classes may be initialized\n+during AOT assembly.\n+\n+When a static initializer is executed during AOT assembly, the value\n+of each static field is recorded in the AOT cache.  When the JVM\n+starts its production run, using that same AOT cache, the JVM\n+immediately marks the class as initialized, and uses all static field\n+values recorded in the cache.\n+\n+AOT-cached static field values can refer to objects in the Java heap.\n+Also, AOT-resolved constant pool entries (like lambda creation sites)\n+can refer to heap objects as well.  Such heap objects are captured in\n+the AOT cache, along with all supporting metadata that may be\n+necessary.\n+\n+When an object exists in the AOT cache, it must be the case that the\n+class of each such cached heap object is also initialized.  This is\n+because the result of loading an AOT cache must look like a valid,\n+standard-conformant execution of the JVM.  But a heap object with an\n+uninitialized class is an impossibility within the JVMS.\n+\n+For such reasons, one class often has an \"initialization dependency\"\n+on another class.  Some class A cannot complete its initialization\n+until some other class B has at least started its initialization.  For\n+example, initialization of `PrimitiveClassDescImpl` is triggered by\n+initialization of `ConstantDescs`.\n+\n+This is sometimes called an \"init-dependency of A on B\".  Note that we\n+must assert that any initialization that is _started_ in the AOT cache\n+is also _finished_ before the AOT cache is fully generated.  This is\n+true because initializer threads cannot be stored in the AOT cache,\n+only the data images created by such threads.\n+\n+Therefore, if a class A is marked `AOTClassInitializer`, and it has\n+an init-dependency on some class B, that class B must also be marked\n+as `AOTClassInitializer`, if B in fact has a `<clinit>` method.\n+\n+Some dependencies are not explicitly expressed as field values, such\n+as `MemberName` references to methods in holder classes like\n+`DirectMethodHandle$Holder`, which requires the target class to be\n+AOT-initialized despite having no static methods.\n+\n+A class which is so simple that it has no `<clinit>` does not need to\n+be marked by this annotation, as long as all its super-classes, and\n+initialized super-interfaces, are also equally simple.  The AOT\n+assembly phase will pre-initialize it if necessary.  Every class which\n+has complex initialization, and either has instances in the AOT heap,\n+or certain kinds of method handle references in the AOT heap, must be\n+marked this way.\n+\n+During the AOT assembly phase, all of these dependencies are carefully\n+checked by a JVM class called `CDSHeapVerifier`.  See\n+`aotConstantPoolResolver.cpp` for more details.\n+\n+Note that many classes do not need marking with this annotation simply\n+because they are not used at AOT time, or because they are used as\n+pure types, without the need for initialization.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOT.md","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/\/\/ Indicates a class or interface that should have its static initializer\n+\/\/\/ (`<clinit>`) executed whenever it is referenced in an AOT cache, and may\n+\/\/\/ have custom runtime setup actions in a `private static void runtimeSetup()`\n+\/\/\/ method.  Note that classes with instances in the AOT cache are always\n+\/\/\/ initialized even without this annotation, but cannot define custom actions.\n+\/\/\/\n+\/\/\/ In AOT assembly run, an object graph from metaspace to heap objects is\n+\/\/\/ constructed.  When an object is in the heap, its class must be initialized.\n+\/\/\/ However, class initialization may have dependencies on other classes in the\n+\/\/\/ initializer that won't be initialized because they do not have live objects.\n+\/\/\/ For example, `MethodHandles.IMPL_NAMES` is copied to\n+\/\/\/ `DirectMethodHandle.IMPL_NAMES`, but there is no object relationship from\n+\/\/\/ DMH to MHs, therefore we need to mark MethodHandles as AOTCI so it is\n+\/\/\/ consistently initialized when it is ever referenced.\n+\/\/\/\n+\/\/\/ This annotation is only recognized on privileged code and is ignored\n+\/\/\/ elsewhere.\n+\/\/\/\n+\/\/\/ @since 26\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface AOTClassInitializer {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTClassInitializer.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}