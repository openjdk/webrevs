{"files":[{"patch":"@@ -66,0 +66,1 @@\n+\/\/         This function checks for the @jdk.internal.vm.annotation.AOTSafeClassInitializer annotation.\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,61 +40,0 @@\n-\/\/ Detector for class names we wish to handle specially.\n-\/\/ It is either an exact string match or a string prefix match.\n-class AOTClassInitializer::AllowedSpec {\n-  const char* _class_name;\n-  bool _is_prefix;\n-  int _len;\n-public:\n-  AllowedSpec(const char* class_name, bool is_prefix = false)\n-    : _class_name(class_name), _is_prefix(is_prefix)\n-  {\n-    _len = (class_name == nullptr) ? 0 : (int)strlen(class_name);\n-  }\n-  const char* class_name() { return _class_name; }\n-\n-  bool matches(Symbol* name, int len) {\n-    assert(_class_name != nullptr, \"caller resp.\");\n-    if (_is_prefix) {\n-      return len >= _len && name->starts_with(_class_name);\n-    } else {\n-      return len == _len && name->equals(_class_name);\n-    }\n-  }\n-};\n-\n-\n-\/\/ Tell if ik has a name that matches one of the given specs.\n-bool AOTClassInitializer::is_allowed(AllowedSpec* specs, InstanceKlass* ik) {\n-  Symbol* name = ik->name();\n-  int len = name->utf8_length();\n-  for (AllowedSpec* s = specs; s->class_name() != nullptr; s++) {\n-    if (s->matches(name, len)) {\n-      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n-      \/\/   - all super classes must be included\n-      \/\/   - all super interfaces that have <clinit> must be included.\n-      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n-      \/\/ ik's <clinit>.\n-      if (ik->java_super() != nullptr) {\n-        DEBUG_ONLY(ResourceMark rm);\n-        assert(AOTClassInitializer::can_archive_initialized_mirror(ik->java_super()),\n-               \"super class %s of %s must be aot-initialized\", ik->java_super()->external_name(),\n-               ik->external_name());\n-      }\n-\n-      Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-      int len = interfaces->length();\n-      for (int i = 0; i < len; i++) {\n-        InstanceKlass* intf = interfaces->at(i);\n-        if (intf->class_initializer() != nullptr) {\n-          assert(AOTClassInitializer::can_archive_initialized_mirror(intf),\n-                 \"super interface %s (which has <clinit>) of %s must be aot-initialized\", intf->external_name(),\n-                 ik->external_name());\n-        }\n-      }\n-\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\n@@ -263,4 +202,0 @@\n-  \/\/ IS_PREFIX means that we match all class names that start with a\n-  \/\/ prefix.  Otherwise, it is an exact match, of just one class name.\n-  const bool IS_PREFIX = true;\n-\n@@ -268,1 +203,1 @@\n-    static AllowedSpec specs[] = {\n+    if (ik == vmClasses::Object_klass()) {\n@@ -270,5 +205,0 @@\n-      {\"java\/lang\/Object\"},\n-\n-      {nullptr}\n-    };\n-    if (is_allowed(specs, ik)) {\n@@ -280,1 +210,1 @@\n-    \/\/ This table was created with the help of CDSHeapVerifier.\n+    \/\/ The minimal list of @AOTSafeClassInitializer was created with the help of CDSHeapVerifier.\n@@ -284,47 +214,1 @@\n-    \/\/\n-    \/\/ We hope we can reduce the size of this list over time, and move\n-    \/\/ the responsibility for identifying such classes into the JDK\n-    \/\/ code itself.  See tracking RFE JDK-8342481.\n-    static AllowedSpec indy_specs[] = {\n-      {\"java\/lang\/constant\/ConstantDescs\"},\n-      {\"java\/lang\/constant\/DynamicConstantDesc\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle$Specializer\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle$Species_\", IS_PREFIX},\n-      {\"java\/lang\/invoke\/ClassSpecializer\"},\n-      {\"java\/lang\/invoke\/ClassSpecializer$\", IS_PREFIX},\n-      {\"java\/lang\/invoke\/DelegatingMethodHandle\"},\n-      {\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\"},     \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/DirectMethodHandle\"},\n-      {\"java\/lang\/invoke\/DirectMethodHandle$Constructor\"},\n-      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},         \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/Invokers\"},\n-      {\"java\/lang\/invoke\/Invokers$Holder\"},                   \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/LambdaForm\"},\n-      {\"java\/lang\/invoke\/LambdaForm$Holder\"},                 \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/LambdaForm$NamedFunction\"},\n-      {\"java\/lang\/invoke\/LambdaMetafactory\"},\n-      {\"java\/lang\/invoke\/MethodHandle\"},\n-      {\"java\/lang\/invoke\/MethodHandles\"},\n-      {\"java\/lang\/invoke\/SimpleMethodHandle\"},\n-      {\"java\/lang\/invoke\/StringConcatFactory\"},\n-      {\"java\/lang\/invoke\/VarHandleGuards\"},\n-      {\"java\/util\/Collections\"},\n-      {\"java\/util\/stream\/Collectors\"},\n-      {\"jdk\/internal\/constant\/ConstantUtils\"},\n-      {\"jdk\/internal\/constant\/PrimitiveClassDescImpl\"},\n-      {\"jdk\/internal\/constant\/ReferenceClassDescImpl\"},\n-\n-    \/\/ Can't include this, as it will pull in MethodHandleStatics which has many environment\n-    \/\/ dependencies (on system properties, etc).\n-    \/\/ MethodHandleStatics is an example of a class that must NOT get the aot-init treatment,\n-    \/\/ because of its strong reliance on (a) final fields which are (b) environmentally determined.\n-    \/\/{\"java\/lang\/invoke\/InvokerBytecodeGenerator\"},\n-\n-      {nullptr}\n-    };\n-    if (is_allowed(indy_specs, ik)) {\n-      return true;\n-    }\n-\n-    if (ik->name()->starts_with(\"java\/lang\/invoke\/MethodHandleImpl\")) {\n+    if (ik->has_aot_safe_initializer()) {\n@@ -344,11 +228,0 @@\n-\/\/ TODO: currently we have a hard-coded list. We should turn this into\n-\/\/ an annotation: @jdk.internal.vm.annotation.RuntimeSetupRequired\n-\/\/ See JDK-8342481.\n-bool AOTClassInitializer::is_runtime_setup_required(InstanceKlass* ik) {\n-  return ik == vmClasses::Class_klass() ||\n-         ik == vmClasses::internal_Unsafe_klass() ||\n-         ik == vmClasses::ConcurrentHashMap_klass() ||\n-         ik == vmClasses::MethodHandleImpl_klass() ||\n-         ik == vmClasses::Reference_klass();\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":3,"deletions":130,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-  class AllowedSpec;\n-  static bool is_allowed(AllowedSpec* specs, InstanceKlass* ik);\n-\n@@ -42,1 +39,0 @@\n-  static bool is_runtime_setup_required(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -508,3 +508,0 @@\n-  if (AOTClassInitializer::is_runtime_setup_required(ik)) {\n-    ik->set_is_runtime_setup_required();\n-  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -944,0 +944,2 @@\n+    _jdk_internal_vm_annotation_AOTSafeClassInitializer,\n+    _method_AOTRuntimeSetup,\n@@ -979,0 +981,2 @@\n+\n+  bool has_aot_runtime_setup() const { return has_annotation(_method_AOTRuntimeSetup); }\n@@ -1899,0 +1903,10 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_AOTSafeClassInitializer_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _jdk_internal_vm_annotation_AOTSafeClassInitializer;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_AOTRuntimeSetup_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_AOTRuntimeSetup;\n+    }\n@@ -1978,0 +1992,3 @@\n+  if (has_annotation(_jdk_internal_vm_annotation_AOTSafeClassInitializer)) {\n+    ik->set_has_aot_safe_initializer();\n+  }\n@@ -2664,0 +2681,7 @@\n+  if (parsed_annotations.has_aot_runtime_setup()) {\n+    if (name != vmSymbols::runtimeSetup() || signature != vmSymbols::void_method_signature() ||\n+        !access_flags.is_private() || !access_flags.is_static()) {\n+      classfile_parse_error(\"@AOTRuntimeSetup method must be declared private static void runtimeSetup() for class %s\", CHECK_NULL);\n+    }\n+    _has_aot_runtime_setup_method = true;\n+  }\n@@ -3981,0 +4005,9 @@\n+\n+  \/\/ Propagate the AOT runtimeSetup method discovery\n+  if (_has_aot_runtime_setup_method) {\n+    ik->set_is_runtime_setup_required();\n+    if (log_is_enabled(Info, aot, init)) {\n+      ResourceMark rm;\n+      log_info(aot, init)(\"Found @AOTRuntimeSetup class %s\", ik->external_name());\n+    }\n+  }\n@@ -5120,1 +5153,1 @@\n-  if (_parsed_annotations->has_any_annotations()) {\n+  if (_parsed_annotations->has_any_annotations())\n@@ -5122,0 +5155,39 @@\n+\n+  \/\/ AOT-related checks.\n+  \/\/ Note we cannot check this in general due to instrumentation or module patching\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ Check the aot initialization safe status.\n+    \/\/ @AOTSafeClassInitializer is used only to support ahead-of-time initialization of classes\n+    \/\/ in the AOT assembly phase.\n+    if (ik->has_aot_safe_initializer()) {\n+      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n+      \/\/   - all super classes must be included\n+      \/\/   - all super interfaces that have <clinit> must be included.\n+      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n+      \/\/ ik's <clinit>.\n+      if (_super_klass != nullptr) {\n+        guarantee_property(_super_klass->has_aot_safe_initializer(),\n+                           \"Missing @AOTSafeClassInitializer in superclass %s for class %s\",\n+                           _super_klass->external_name(),\n+                           CHECK);\n+      }\n+\n+      int len = _local_interfaces->length();\n+      for (int i = 0; i < len; i++) {\n+        InstanceKlass* intf = _local_interfaces->at(i);\n+        guarantee_property(intf->class_initializer() == nullptr || intf->has_aot_safe_initializer(),\n+                           \"Missing @AOTSafeClassInitializer in superinterface %s for class %s\",\n+                           intf->external_name(),\n+                           CHECK);\n+      }\n+\n+      if (log_is_enabled(Info, aot, init)) {\n+        ResourceMark rm;\n+        log_info(aot, init)(\"Found @AOTSafeClassInitializer class %s\", ik->external_name());\n+      }\n+    } else {\n+      \/\/ @AOTRuntimeSetup only meaningful in @AOTClassInitializer\n+      guarantee_property(!ik->is_runtime_setup_required(),\n+                         \"@AOTRuntimeSetup meaningless in non-@AOTSafeClassInitializer class %s\",\n+                         CHECK);\n+    }\n@@ -5329,0 +5401,1 @@\n+  _has_aot_runtime_setup_method(false),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  bool _has_aot_runtime_setup_method;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -735,0 +735,1 @@\n+  template(jdk_internal_vm_annotation_AOTSafeClassInitializer_signature, \"Ljdk\/internal\/vm\/annotation\/AOTSafeClassInitializer;\")\\\n@@ -737,0 +738,1 @@\n+  template(jdk_internal_vm_annotation_AOTRuntimeSetup_signature, \"Ljdk\/internal\/vm\/annotation\/AOTRuntimeSetup;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -767,0 +767,8 @@\n+  \/\/ Indicates presence of @AOTSafeClassInitializer. Also see AOTClassInitializer for more details.\n+  bool has_aot_safe_initializer() const { return _misc_flags.has_aot_safe_initializer(); }\n+  void set_has_aot_safe_initializer()   { _misc_flags.set_has_aot_safe_initializer(true); }\n+\n+  \/\/ Indicates @AOTRuntimeSetup private static void runtimeSetup() presence.\n+  bool is_runtime_setup_required() const { return _misc_flags.is_runtime_setup_required(); }\n+  void set_is_runtime_setup_required()   { _misc_flags.set_is_runtime_setup_required(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    flag(has_aot_safe_initializer           , 1 << 14) \/* has @AOTSafeClassInitializer annotation *\/ \\\n+    flag(is_runtime_setup_required          , 1 << 15) \/* has a runtimeSetup method to be called *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,3 +189,0 @@\n-    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n-    \/\/ method during the production run?\n-    _is_runtime_setup_required             = 1 << 7,\n@@ -383,9 +380,0 @@\n-  void set_is_runtime_setup_required() {\n-    assert(has_aot_initialized_mirror(), \"sanity\");\n-    CDS_ONLY(_shared_class_flags |= _is_runtime_setup_required;)\n-  }\n-  bool is_runtime_setup_required() const {\n-    CDS_ONLY(return (_shared_class_flags & _is_runtime_setup_required) != 0;)\n-    NOT_CDS(return false;)\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import java.lang.reflect.Proxy;\n@@ -82,0 +81,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -214,0 +215,1 @@\n+@AOTSafeClassInitializer\n@@ -229,1 +231,3 @@\n-    \/\/ Called from JVM when loading an AOT cache\n+    \/\/\/ No significant static final fields; [#resetArchivedStates()] handles\n+    \/\/\/ prevents storing [#reflectionFactory] into AOT image.\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -38,0 +39,1 @@\n+@AOTSafeClassInitializer \/\/ for hierarchy checks\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -59,0 +60,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -59,0 +61,1 @@\n+@AOTSafeClassInitializer \/\/ for PrimitiveClassDescImpl\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicConstantDesc.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -47,0 +48,1 @@\n+@AOTSafeClassInitializer\n@@ -236,0 +238,1 @@\n+    @AOTSafeClassInitializer\n@@ -315,0 +318,1 @@\n+    @AOTSafeClassInitializer\n@@ -405,0 +409,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -67,0 +68,1 @@\n+@AOTSafeClassInitializer\n@@ -72,0 +74,3 @@\n+    private static final RuntimeVisibleAnnotationsAttribute AOT_SAFE_ANNOTATION = RuntimeVisibleAnnotationsAttribute.of(\n+            Annotation.of(ConstantUtils.referenceClassDesc(AOTSafeClassInitializer.class))\n+    );\n@@ -236,0 +241,1 @@\n+    @AOTSafeClassInitializer\n@@ -472,0 +478,1 @@\n+    @AOTSafeClassInitializer\n@@ -627,0 +634,1 @@\n+                       .with(AOT_SAFE_ANNOTATION)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -39,0 +42,1 @@\n+@AOTSafeClassInitializer\n@@ -196,0 +200,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -52,0 +53,1 @@\n+@AOTSafeClassInitializer\n@@ -469,0 +471,1 @@\n+    @AOTSafeClassInitializer\n@@ -940,0 +943,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -30,0 +31,1 @@\n+import java.lang.classfile.Annotation;\n@@ -31,0 +33,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -70,0 +73,1 @@\n+    static final Annotation AOT_SAFE_ANNOTATION = Annotation.of(AOTSafeClassInitializer.class.describeConstable().orElseThrow());\n@@ -565,0 +569,1 @@\n+               .with(RuntimeVisibleAnnotationsAttribute.of(AOT_SAFE_ANNOTATION))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -46,0 +47,1 @@\n+@AOTSafeClassInitializer\n@@ -699,0 +701,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -125,0 +126,1 @@\n+@AOTSafeClassInitializer\n@@ -1035,0 +1037,1 @@\n+    @AOTSafeClassInitializer\n@@ -1731,0 +1734,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -250,0 +252,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -445,0 +446,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -75,0 +77,1 @@\n+@AOTSafeClassInitializer\n@@ -161,0 +164,1 @@\n+    @AOTSafeClassInitializer\n@@ -456,0 +460,1 @@\n+    @AOTSafeClassInitializer\n@@ -678,0 +683,1 @@\n+    @AOTSafeClassInitializer\n@@ -713,0 +719,1 @@\n+    @AOTSafeClassInitializer\n@@ -1038,0 +1045,1 @@\n+    @AOTSafeClassInitializer\n@@ -1146,0 +1154,1 @@\n+        @AOTSafeClassInitializer\n@@ -1288,0 +1297,1 @@\n+    @AOTSafeClassInitializer\n@@ -1351,0 +1361,1 @@\n+    @AOTSafeClassInitializer\n@@ -1531,1 +1542,1 @@\n-    \/\/ Also called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n@@ -1781,0 +1792,1 @@\n+    @AOTSafeClassInitializer\n@@ -2108,0 +2120,1 @@\n+    @AOTSafeClassInitializer\n@@ -2137,0 +2150,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -86,0 +87,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -30,3 +31,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.*;\n-import static java.lang.invoke.MethodHandleStatics.*;\n-\n@@ -39,0 +37,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SimpleMethodHandle.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -119,0 +120,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -31,0 +32,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -749,0 +749,1 @@\n+\/\/            System.out.println(\"import jdk.internal.vm.annotation.AOTSafeClassInitializer;\");\n@@ -755,0 +756,1 @@\n+\/\/            System.out.println(\"@AOTSafeClassInitializer\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -44,1 +46,1 @@\n-\n+@AOTSafeClassInitializer\n@@ -295,1 +297,1 @@\n-    \/\/ Also called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -71,1 +73,1 @@\n-\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -85,0 +86,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -266,0 +268,1 @@\n+@AOTSafeClassInitializer\n@@ -605,1 +608,1 @@\n-    \/\/ Called from JVM when loading an AOT cache.\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -106,0 +107,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Collectors.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -44,0 +45,1 @@\n+@AOTSafeClassInitializer \/\/ initialization dependency of PrimitiveClassDescImpl\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -41,0 +42,1 @@\n+@AOTSafeClassInitializer \/\/ identity-sensitive static final fields\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -55,1 +57,1 @@\n-\n+@AOTSafeClassInitializer\n@@ -63,1 +65,3 @@\n-    \/\/ Called from JVM when loading an AOT cache\n+    \/\/\/ BASE_OFFSET, INDEX_SCALE, and ADDRESS_SIZE fields are equivalent if the\n+    \/\/\/ AOT initialized heap is reused, so just register natives\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/\/\/ Indicates that if the enclosing class or interface is present in the AOT\n+\/\/\/ cache in the AOT-initialized state, the annotated method must be executed\n+\/\/\/ before bootstrap phase 3 (that is, before [System#initPhase3]).\n+\/\/\/\n+\/\/\/ The annotated method must be declared `private` and `static`, must be named\n+\/\/\/ `runtimeSetup`, and must have no arguments or return value.  The enclosing\n+\/\/\/ class must be annotated with [AOTSafeClassInitializer], meaning that it is\n+\/\/\/ allowed to be stored in the AOT-initialized state.\n+\/\/\/\n+\/\/\/ The annotated method will be executed if and only if the class was loaded\n+\/\/\/ in the AOT-initialized state from the AOT cache.\n+\/\/\/\n+\/\/\/ The author of the class is responsible for deciding whether some or all of\n+\/\/\/ a class's initialization state should be re-initialized in any way.  In all\n+\/\/\/ cases, the static initializer (`<clinit>` method) of any given class or\n+\/\/\/ interface is run at most once, either in the assembly phase (only for an\n+\/\/\/ AOT-initialized class) or in the production run.\n+\/\/\/\n+\/\/\/ After a `static` `final` field is assigned a value in an AOT-initialized\n+\/\/\/ class, its value may never be changed, as such values are always immutable\n+\/\/\/ runtime constants.  (...Barring `System.out` and its two siblings.)\n+\/\/\/ Rarely, a `static` field may require differing values in the assembly phase\n+\/\/\/ for an AOT cache, and for the production run.  Such variables must be\n+\/\/\/ marked non-`final`, and should be adjusted by the `runtimeSetup` method.\n+\/\/\/ Full constant folding (as if with a `final` field) may usually be recovered\n+\/\/\/ by also marking the field as [Stable].  That annotation instructs the JIT\n+\/\/\/ to perform constant folding, and _only_ during the production run, after\n+\/\/\/ `runtimeSetup` has had a chance to give the field its \"finally final\"\n+\/\/\/ value.\n+\/\/\/\n+\/\/\/ A related method is `resetArchivedStates`, which allows special handling of\n+\/\/\/ an AOT-initialized class, at the end of the assembly phase run which builds\n+\/\/\/ an AOT cache.  The `resetArchivedStates` may \"tear down\" state that should\n+\/\/\/ not be stored in the AOT cache, which the `runtimeSetup` method may then\n+\/\/\/ \"build up again\" as the production run begins.  This additional method is\n+\/\/\/ currently only used by [Class] to reset a cache field, but it may be\n+\/\/\/ expanded to other classes and interfaces later on, using more\n+\/\/\/ annotation-driven logic.\n+\/\/\/\n+\/\/\/ The logic in `classFileParser.cpp` performs checks on the annotated method: If the\n+\/\/\/ annotated method's signature differs from that described above, or if (during the\n+\/\/\/ assembly phase) the class is not marked to have an AOT-safe initializer, a\n+\/\/\/ [ClassFormatError] will be thrown.\n+\/\/\/\n+\/\/\/ This annotation is only recognized on privileged code and is ignored elsewhere.\n+\/\/\/\n+\/\/\/ @since 26\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface AOTRuntimeSetup {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTRuntimeSetup.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/\/\/ Indicates that the static initializer of this class or interface\n+\/\/\/ (its `<clinit>` method) is allowed to be _AOT-initialized_,\n+\/\/\/ because its author considers it safe to execute during the AOT\n+\/\/\/ assembly phase.\n+\/\/\/\n+\/\/\/ This annotation directs the VM to expect that normal execution of Java code\n+\/\/\/ during the assembly phase could trigger initialization of this class,\n+\/\/\/ and if that happens, to store the resulting static field values in the\n+\/\/\/ AOT cache.  (These fields happen to be allocated in the `Class` mirror.)\n+\/\/\/\n+\/\/\/ During the production run, the static initializer (`<clinit>`) of\n+\/\/\/ this class or interface will not be executed, if it was already\n+\/\/\/ executed during the assembling of the AOT being used to start the\n+\/\/\/ production run.  In that case the resulting static field states\n+\/\/\/ (within the `Class` mirror) were already stored in the AOT cache.\n+\/\/\/\n+\/\/\/ Currently, this annotation is used mainly for supporting AOT\n+\/\/\/ linking of APIs, including bootstrap methods, in the\n+\/\/\/ `java.lang.invoke` package.\n+\/\/\/\n+\/\/\/ In more detail, the AOT assembly phase performs the following:\n+\/\/\/\n+\/\/\/ 1. It loads and links (but does not initialize) the classes that were loaded\n+\/\/\/    during the application's training run.\n+\/\/\/ 2. During linking of these classes, it resolves their constant pool\n+\/\/\/    entries, when it is safe and beneficial to do so.\n+\/\/\/ 3. As part of those resolutions, bootstrap methods may be called and may\n+\/\/\/    create graphs of Java objects to support linkage states.\n+\/\/\/ 4. Every object within those graphs must have its class AOT-initialized,\n+\/\/\/    along with every relevant superclass and implemented interface, along\n+\/\/\/    with classes for every object created during the course of static\n+\/\/\/    initialization (running `<clinit>` for each such class or interface).\n+\/\/\/\n+\/\/\/ Thus, in order to determine that a class or interface _X_ is safe to\n+\/\/\/ AOT-initialize requires evaluating every other class or interface _Y_ that\n+\/\/\/ the `<clinit>` of _X_ will initialize (during AOT cache assembly), and\n+\/\/\/ ensuring that each such _Y_ is (recursively) safe to AOT-initialize.\n+\/\/\/\n+\/\/\/ For example, an AOT-resolved constant pool entry for an invokedynamic or\n+\/\/\/ invokehandle bytecode can have direct or indirect references to Java objects.\n+\/\/\/ To ensure the correctness of the AOT-resolved constant pool entrties, the VM\n+\/\/\/ must AOT-initialize the classes of such Java objects.\n+\/\/\/\n+\/\/\/ In addition, such Java objects may have references to static fields whose\n+\/\/\/ object identity is important. For example, `PrimitiveClassDescImpl::CD_void`.\n+\/\/\/ To ensure correctness, we must also store classes like `PrimitiveClassDescImpl`\n+\/\/\/ in the initialized state. The VM requires implementor to manually annotate\n+\/\/\/ such classes with `@AOTSafeClassInitializer`.\n+\/\/\/\n+\/\/\/ There is one more requirement for a class to be safe for\n+\/\/\/ AOT initialization, and that is compatibility with all eventual production\n+\/\/\/ runs.  The state of an AOT-initialized class _X_ must not contain any data\n+\/\/\/ (anything reachable from _X_) that is incompatible with the eventual\n+\/\/\/ production run.\n+\/\/\/\n+\/\/\/ In general, if some sort of computed datum, environmental setting, or\n+\/\/\/ variable behavior may differ between the AOT assembly phase and the\n+\/\/\/ production run, it may not be immutably bound to _X_, if _X_ is to be\n+\/\/\/ marked AOT-initialized.  Here are specific examples:\n+\/\/\/\n+\/\/\/  - The value of an environment string (if it may differ in the production run).\n+\/\/\/\n+\/\/\/  - A transient configuration parameter specific to this VM run, such as\n+\/\/\/    wall clock time, process ID, host name, temporary directory names, etc.\n+\/\/\/\n+\/\/\/  - A random seed or key that may need to be re-sampled at production\n+\/\/\/    startup.\n+\/\/\/\n+\/\/\/ What is more, if the initialization of _X_ computes with some value _V_\n+\/\/\/ obtained from some other class _Y_, _Y_ should also be safe for AOT\n+\/\/\/ initialization, if there is any way for _X_ to detect a mismatch between\n+\/\/\/ the version of _V_ produced at AOT time, and the version of _V_ produced in\n+\/\/\/ the production run.  Specifically, if _V_ has an object identity, _X_\n+\/\/\/ should not test that identity (compare it against another or get its\n+\/\/\/ hashcode) unless _Y_ is also marked for AOT initialization.\n+\/\/\/\n+\/\/\/ Thus, to support AOT-time linkage, a class _X_ should be marked for (possible)\n+\/\/\/ AOT initialization whenever objects it creates (such as `MethodHandle`s)\n+\/\/\/ may be required to execute a `java.lang.invoke` API request, or (more\n+\/\/\/ remotely) if the execution of such an API touches _X_ for initialization,\n+\/\/\/ or even if such an API request is in any way sensitive to values stored in\n+\/\/\/ the fields of _X_, even if the sensitivity is a simple reference identity\n+\/\/\/ test.  As noted above, all supertypes of _X_ must also have the\n+\/\/\/ `@AOTSafeClassInitializer` annotation, and must also be safe for AOT\n+\/\/\/ initialization.\n+\/\/\/\n+\/\/\/ The author of an AOT-initialized class may elect to patch some states at\n+\/\/\/ production startup, using an [AOTRuntimeSetup] method, as long as the\n+\/\/\/ pre-patched field values (present during AOT assembly) are determined to be\n+\/\/\/ compatible with the post-patched values that apply to the production run.\n+\/\/\/\n+\/\/\/ In the assembly phase, `classFileParser.cpp` performs checks on the annotated\n+\/\/\/ classes, to ensure all supertypes of this class that must be initialized when\n+\/\/\/ this class is initialized have the `@AOTSafeClassInitializer` annotation.\n+\/\/\/ Otherwise, a [ClassFormatError] will be thrown. (This assembly phase restriction\n+\/\/\/ allows module patching and instrumentation to work on annotated classes when\n+\/\/\/ AOT is not enabled)\n+\/\/\/\n+\/\/\/ This annotation is only recognized on privileged code and is ignored elsewhere.\n+\/\/\/\n+\/\/\/ @since 26\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface AOTSafeClassInitializer {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTSafeClassInitializer.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}