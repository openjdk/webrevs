{"files":[{"patch":"@@ -66,0 +66,1 @@\n+\/\/         This function checks for the @jdk.internal.vm.annotation.AOTSafeClassInitializer annotation.\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,61 +40,0 @@\n-\/\/ Detector for class names we wish to handle specially.\n-\/\/ It is either an exact string match or a string prefix match.\n-class AOTClassInitializer::AllowedSpec {\n-  const char* _class_name;\n-  bool _is_prefix;\n-  int _len;\n-public:\n-  AllowedSpec(const char* class_name, bool is_prefix = false)\n-    : _class_name(class_name), _is_prefix(is_prefix)\n-  {\n-    _len = (class_name == nullptr) ? 0 : (int)strlen(class_name);\n-  }\n-  const char* class_name() { return _class_name; }\n-\n-  bool matches(Symbol* name, int len) {\n-    assert(_class_name != nullptr, \"caller resp.\");\n-    if (_is_prefix) {\n-      return len >= _len && name->starts_with(_class_name);\n-    } else {\n-      return len == _len && name->equals(_class_name);\n-    }\n-  }\n-};\n-\n-\n-\/\/ Tell if ik has a name that matches one of the given specs.\n-bool AOTClassInitializer::is_allowed(AllowedSpec* specs, InstanceKlass* ik) {\n-  Symbol* name = ik->name();\n-  int len = name->utf8_length();\n-  for (AllowedSpec* s = specs; s->class_name() != nullptr; s++) {\n-    if (s->matches(name, len)) {\n-      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n-      \/\/   - all super classes must be included\n-      \/\/   - all super interfaces that have <clinit> must be included.\n-      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n-      \/\/ ik's <clinit>.\n-      if (ik->java_super() != nullptr) {\n-        DEBUG_ONLY(ResourceMark rm);\n-        assert(AOTClassInitializer::can_archive_initialized_mirror(ik->java_super()),\n-               \"super class %s of %s must be aot-initialized\", ik->java_super()->external_name(),\n-               ik->external_name());\n-      }\n-\n-      Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-      int len = interfaces->length();\n-      for (int i = 0; i < len; i++) {\n-        InstanceKlass* intf = interfaces->at(i);\n-        if (intf->class_initializer() != nullptr) {\n-          assert(AOTClassInitializer::can_archive_initialized_mirror(intf),\n-                 \"super interface %s (which has <clinit>) of %s must be aot-initialized\", intf->external_name(),\n-                 ik->external_name());\n-        }\n-      }\n-\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\n@@ -263,4 +202,0 @@\n-  \/\/ IS_PREFIX means that we match all class names that start with a\n-  \/\/ prefix.  Otherwise, it is an exact match, of just one class name.\n-  const bool IS_PREFIX = true;\n-\n@@ -268,1 +203,1 @@\n-    static AllowedSpec specs[] = {\n+    if (ik == vmClasses::Object_klass()) {\n@@ -270,5 +205,0 @@\n-      {\"java\/lang\/Object\"},\n-\n-      {nullptr}\n-    };\n-    if (is_allowed(specs, ik)) {\n@@ -280,1 +210,1 @@\n-    \/\/ This table was created with the help of CDSHeapVerifier.\n+    \/\/ The minimal list of @AOTSafeClassInitializer was created with the help of CDSHeapVerifier.\n@@ -284,33 +214,0 @@\n-    \/\/\n-    \/\/ We hope we can reduce the size of this list over time, and move\n-    \/\/ the responsibility for identifying such classes into the JDK\n-    \/\/ code itself.  See tracking RFE JDK-8342481.\n-    static AllowedSpec indy_specs[] = {\n-      {\"java\/lang\/constant\/ConstantDescs\"},\n-      {\"java\/lang\/constant\/DynamicConstantDesc\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle$Specializer\"},\n-      {\"java\/lang\/invoke\/BoundMethodHandle$Species_\", IS_PREFIX},\n-      {\"java\/lang\/invoke\/ClassSpecializer\"},\n-      {\"java\/lang\/invoke\/ClassSpecializer$\", IS_PREFIX},\n-      {\"java\/lang\/invoke\/DelegatingMethodHandle\"},\n-      {\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\"},     \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/DirectMethodHandle\"},\n-      {\"java\/lang\/invoke\/DirectMethodHandle$Constructor\"},\n-      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},         \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/Invokers\"},\n-      {\"java\/lang\/invoke\/Invokers$Holder\"},                   \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/LambdaForm\"},\n-      {\"java\/lang\/invoke\/LambdaForm$Holder\"},                 \/\/ UNSAFE.ensureClassInitialized()\n-      {\"java\/lang\/invoke\/LambdaForm$NamedFunction\"},\n-      {\"java\/lang\/invoke\/LambdaMetafactory\"},\n-      {\"java\/lang\/invoke\/MethodHandle\"},\n-      {\"java\/lang\/invoke\/MethodHandles\"},\n-      {\"java\/lang\/invoke\/SimpleMethodHandle\"},\n-      {\"java\/lang\/invoke\/StringConcatFactory\"},\n-      {\"java\/lang\/invoke\/VarHandleGuards\"},\n-      {\"java\/util\/Collections\"},\n-      {\"java\/util\/stream\/Collectors\"},\n-      {\"jdk\/internal\/constant\/ConstantUtils\"},\n-      {\"jdk\/internal\/constant\/PrimitiveClassDescImpl\"},\n-      {\"jdk\/internal\/constant\/ReferenceClassDescImpl\"},\n@@ -318,2 +215,2 @@\n-    \/\/ Can't include this, as it will pull in MethodHandleStatics which has many environment\n-    \/\/ dependencies (on system properties, etc).\n+    \/\/ Can't include InvokerBytecodeGenerator, as it will pull in MethodHandleStatics which has many\n+    \/\/ environment dependencies (on system properties, etc).\n@@ -322,9 +219,1 @@\n-    \/\/{\"java\/lang\/invoke\/InvokerBytecodeGenerator\"},\n-\n-      {nullptr}\n-    };\n-    if (is_allowed(indy_specs, ik)) {\n-      return true;\n-    }\n-\n-    if (ik->name()->starts_with(\"java\/lang\/invoke\/MethodHandleImpl\")) {\n+    if (ik->has_aot_safe_initializer()) {\n@@ -344,11 +233,0 @@\n-\/\/ TODO: currently we have a hard-coded list. We should turn this into\n-\/\/ an annotation: @jdk.internal.vm.annotation.RuntimeSetupRequired\n-\/\/ See JDK-8342481.\n-bool AOTClassInitializer::is_runtime_setup_required(InstanceKlass* ik) {\n-  return ik == vmClasses::Class_klass() ||\n-         ik == vmClasses::internal_Unsafe_klass() ||\n-         ik == vmClasses::ConcurrentHashMap_klass() ||\n-         ik == vmClasses::MethodHandleImpl_klass() ||\n-         ik == vmClasses::Reference_klass();\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":5,"deletions":127,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-  class AllowedSpec;\n-  static bool is_allowed(AllowedSpec* specs, InstanceKlass* ik);\n-\n@@ -42,1 +39,0 @@\n-  static bool is_runtime_setup_required(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -509,3 +509,0 @@\n-  if (AOTClassInitializer::is_runtime_setup_required(ik)) {\n-    ik->set_is_runtime_setup_required();\n-  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -944,0 +944,2 @@\n+    _jdk_internal_vm_annotation_AOTSafeClassInitializer,\n+    _method_AOTRuntimeSetup,\n@@ -979,0 +981,2 @@\n+\n+  bool has_aot_runtime_setup() const { return has_annotation(_method_AOTRuntimeSetup); }\n@@ -1899,0 +1903,10 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_AOTSafeClassInitializer_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _jdk_internal_vm_annotation_AOTSafeClassInitializer;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_AOTRuntimeSetup_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_AOTRuntimeSetup;\n+    }\n@@ -1978,0 +1992,3 @@\n+  if (has_annotation(_jdk_internal_vm_annotation_AOTSafeClassInitializer)) {\n+    ik->set_has_aot_safe_initializer();\n+  }\n@@ -2664,0 +2681,7 @@\n+  if (parsed_annotations.has_aot_runtime_setup()) {\n+    if (name != vmSymbols::runtimeSetup() || signature != vmSymbols::void_method_signature() ||\n+        !access_flags.is_private() || !access_flags.is_static()) {\n+      classfile_parse_error(\"Incorrect runtimeSetup method declaration in class file %s\", CHECK_NULL);\n+    }\n+    _has_aot_runtime_setup_method = true;\n+  }\n@@ -3981,0 +4005,5 @@\n+\n+  \/\/ Propagate the AOT runtimeSetup method discovery\n+  if (_has_aot_runtime_setup_method) {\n+    ik->set_is_runtime_setup_required();\n+  }\n@@ -5120,1 +5149,1 @@\n-  if (_parsed_annotations->has_any_annotations()) {\n+  if (_parsed_annotations->has_any_annotations())\n@@ -5122,0 +5151,28 @@\n+\n+  \/\/ Check the aot initialization safe status\n+  if (ik->has_aot_safe_initializer() && CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n+    \/\/   - all super classes must be included\n+    \/\/   - all super interfaces that have <clinit> must be included.\n+    \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n+    \/\/ ik's <clinit>.\n+    if (_super_klass != nullptr) {\n+      if (!_super_klass->has_aot_safe_initializer()) {\n+        classfile_parse_error(\"aot-initialization safe %s requires an aot-initialization safe super class\", CHECK);\n+      }\n+    }\n+\n+    int len = _transitive_interfaces->length();\n+    for (int i = 0; i < len; i++) {\n+      InstanceKlass* intf = _transitive_interfaces->at(i);\n+      if (intf->class_initializer() != nullptr) {\n+        if (!intf->has_aot_safe_initializer()) {\n+          classfile_parse_error(\"superinterface %s not aot-initialization safe for %s\", intf->external_name(), CHECK);\n+        }\n+      }\n+    }\n+\n+    if (log_is_enabled(Info, aot, init)) {\n+      ResourceMark rm;\n+      log_info(aot, init)(\"Found @AOTSafeClassInitializer class %s\", ik->external_name());\n+    }\n@@ -5329,0 +5386,1 @@\n+  _has_aot_runtime_setup_method(false),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  bool _has_aot_runtime_setup_method;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -735,0 +735,1 @@\n+  template(jdk_internal_vm_annotation_AOTSafeClassInitializer_signature, \"Ljdk\/internal\/vm\/annotation\/AOTSafeClassInitializer;\")\\\n@@ -737,0 +738,1 @@\n+  template(jdk_internal_vm_annotation_AOTRuntimeSetup_signature, \"Ljdk\/internal\/vm\/annotation\/AOTRuntimeSetup;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -767,0 +767,8 @@\n+  \/\/ Indicates presence of @AOTSafeClassInitializer. Also see AOTClassInitializer for more details.\n+  bool has_aot_safe_initializer() const { return _misc_flags.has_aot_safe_initializer(); }\n+  void set_has_aot_safe_initializer()   { _misc_flags.set_has_aot_safe_initializer(true); }\n+\n+  \/\/ Indicates @AOTRuntimeSetup private static void runtimeSetup() presence.\n+  bool is_runtime_setup_required() const { return _misc_flags.is_runtime_setup_required(); }\n+  void set_is_runtime_setup_required()   { _misc_flags.set_is_runtime_setup_required(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    flag(has_aot_safe_initializer           , 1 << 14) \/* has @AOTSafeClassInitializer annotation *\/ \\\n+    flag(is_runtime_setup_required          , 1 << 15) \/* has a runtimeSetup method to be called *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,3 +189,0 @@\n-    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n-    \/\/ method during the production run?\n-    _is_runtime_setup_required             = 1 << 7,\n@@ -383,9 +380,0 @@\n-  void set_is_runtime_setup_required() {\n-    assert(has_aot_initialized_mirror(), \"sanity\");\n-    CDS_ONLY(_shared_class_flags |= _is_runtime_setup_required;)\n-  }\n-  bool is_runtime_setup_required() const {\n-    CDS_ONLY(return (_shared_class_flags & _is_runtime_setup_required) != 0;)\n-    NOT_CDS(return false;)\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import java.lang.reflect.Proxy;\n@@ -82,0 +81,1 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -229,1 +229,1 @@\n-    \/\/ Called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -38,0 +39,1 @@\n+@AOTSafeClassInitializer \/\/ for hierarchy checks\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -59,0 +60,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -59,0 +61,1 @@\n+@AOTSafeClassInitializer \/\/ for PrimitiveClassDescImpl\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicConstantDesc.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -47,1 +48,1 @@\n-\/*non-public*\/\n+@AOTSafeClassInitializer\n@@ -236,0 +237,1 @@\n+    @AOTSafeClassInitializer\n@@ -315,1 +317,1 @@\n-    \/*non-public*\/\n+    @AOTSafeClassInitializer\n@@ -405,1 +407,1 @@\n-    \/*non-public*\/\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -67,1 +68,1 @@\n-\/*non-public*\/\n+@AOTSafeClassInitializer\n@@ -72,0 +73,3 @@\n+    private static final RuntimeVisibleAnnotationsAttribute AOT_SAFE_ANNOTATION = RuntimeVisibleAnnotationsAttribute.of(\n+            Annotation.of(ConstantUtils.referenceClassDesc(AOTSafeClassInitializer.class))\n+    );\n@@ -236,0 +240,1 @@\n+    @AOTSafeClassInitializer\n@@ -472,0 +477,1 @@\n+    @AOTSafeClassInitializer\n@@ -627,0 +633,1 @@\n+                       .with(AOT_SAFE_ANNOTATION)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -39,1 +42,1 @@\n-\/*non-public*\/\n+@AOTSafeClassInitializer\n@@ -196,0 +199,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -52,0 +53,1 @@\n+@AOTSafeClassInitializer\n@@ -469,0 +471,1 @@\n+    @AOTSafeClassInitializer\n@@ -940,0 +943,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -30,0 +31,1 @@\n+import java.lang.classfile.Annotation;\n@@ -31,0 +33,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -70,0 +73,1 @@\n+    static final Annotation AOT_SAFE_ANNOTATION = Annotation.of(AOTSafeClassInitializer.class.describeConstable().orElseThrow());\n@@ -565,0 +569,1 @@\n+               .with(RuntimeVisibleAnnotationsAttribute.of(AOT_SAFE_ANNOTATION))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -46,0 +47,1 @@\n+@AOTSafeClassInitializer\n@@ -699,0 +701,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -125,0 +126,1 @@\n+@AOTSafeClassInitializer\n@@ -1035,0 +1037,1 @@\n+    @AOTSafeClassInitializer\n@@ -1731,0 +1734,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -250,0 +252,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -445,0 +446,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -75,1 +77,1 @@\n-\/*non-public*\/\n+@AOTSafeClassInitializer\n@@ -161,0 +163,1 @@\n+    @AOTSafeClassInitializer\n@@ -456,0 +459,1 @@\n+    @AOTSafeClassInitializer\n@@ -678,0 +682,1 @@\n+    @AOTSafeClassInitializer\n@@ -713,0 +718,1 @@\n+    @AOTSafeClassInitializer\n@@ -1038,0 +1044,1 @@\n+    @AOTSafeClassInitializer\n@@ -1146,0 +1153,1 @@\n+        @AOTSafeClassInitializer\n@@ -1288,0 +1296,1 @@\n+    @AOTSafeClassInitializer\n@@ -1351,0 +1360,1 @@\n+    @AOTSafeClassInitializer\n@@ -1531,1 +1541,1 @@\n-    \/\/ Also called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n@@ -1781,0 +1791,1 @@\n+    @AOTSafeClassInitializer\n@@ -2108,0 +2119,1 @@\n+    @AOTSafeClassInitializer\n@@ -2137,0 +2149,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -86,0 +87,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -30,3 +31,0 @@\n-import static java.lang.invoke.LambdaForm.BasicType.*;\n-import static java.lang.invoke.MethodHandleStatics.*;\n-\n@@ -39,0 +37,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SimpleMethodHandle.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -119,0 +120,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -31,0 +32,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -749,0 +749,1 @@\n+\/\/            System.out.println(\"import jdk.internal.vm.annotation.AOTSafeClassInitializer;\");\n@@ -755,0 +756,1 @@\n+\/\/            System.out.println(\"@AOTSafeClassInitializer\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -313,1 +314,1 @@\n-    \/\/ Also called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -85,0 +86,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -605,1 +606,1 @@\n-    \/\/ Called from JVM when loading an AOT cache.\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -106,0 +107,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Collectors.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -44,0 +45,1 @@\n+@AOTSafeClassInitializer \/\/ initialization dependency of PrimitiveClassDescImpl\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -41,0 +42,1 @@\n+@AOTSafeClassInitializer \/\/ identity-sensitive static final fields\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -63,1 +64,1 @@\n-    \/\/ Called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/\/\/ Indicates that if this class or interface is stored in the AOT cache in the\n+\/\/\/ \"initialized\" state, the `private static void runtimeSetup()` method will\n+\/\/\/ be executed instead of the static initializer in the production run.  In\n+\/\/\/ contrast, other \"initialized\" classes skip initialization methods altogether.\n+\/\/\/\n+\/\/\/ `classFileParser.cpp` performs checks on the annotated method - if the\n+\/\/\/ annotated method's signature differs from that described above, a\n+\/\/\/ [ClassFormatError] will be thrown.\n+\/\/\/\n+\/\/\/ This annotation is only recognized on privileged code and is ignored elsewhere.\n+\/\/\/\n+\/\/\/ @since 26\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface AOTRuntimeSetup {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTRuntimeSetup.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/\/\/ Indicates that the static initializer of this class or interface is\n+\/\/\/ considered \"safe\" for AOT assembly. I.e., if this class or interface\n+\/\/\/ has been initialized in the AOT assembly phase, then this class or interface\n+\/\/\/ can be safely stored in the AOT cache in the \"initialized\" state:\n+\/\/\/\n+\/\/\/ 1. During the production run, the static initializer of this class or\n+\/\/\/    interface will not be executed.\n+\/\/\/ 2. The values of the static fields of this class or interface will be the same\n+\/\/\/    as their values at the end of the assembly phase.\n+\/\/\/\n+\/\/\/ Currently, this annotation is used only for supporting AOT linking of\n+\/\/\/ java.lang.invoke primitives.\n+\/\/\/\n+\/\/\/ The AOT assembly phase performs the following:\n+\/\/\/\n+\/\/\/ 1. Load and link (but does not initialize) all classes that were loaded\n+\/\/\/    during the application's training run.\n+\/\/\/ 2. During linking of these classes, we resolve constant pool\n+\/\/\/    entries when it's safe and beneficial to do so.\n+\/\/\/\n+\/\/\/ An AOT-resolved constant pool entry for an invokedynamic or invokehandle bytecode can\n+\/\/\/ have direct or indirect references to Java objects. To ensure the correctness\n+\/\/\/ of the AOT-resolved constant pool entrties, we store the classes of such Java objects\n+\/\/\/ in the AOT cache in the initialized state (as described above).\n+\/\/\/\n+\/\/\/ However, such Java objects may have references to static fields whose object identity\n+\/\/\/ is important. For example, `PrimitiveClassDescImpl::CD_void`. To ensure correctness,\n+\/\/\/ we must also store classes like `PrimitiveClassDescImpl` in the initialized state.\n+\/\/\/ We require the implementors of java.lang.invoke to manually annotate such classes with\n+\/\/\/ `@AOTSafeClassInitializer`. This should be done when:\n+\/\/\/\n+\/\/\/ 1. It's possible for an artifact used in the linking java.lang.invoke primitives\n+\/\/\/    (usually a MethodHandle) to directly or indirectly remember the value of a static\n+\/\/\/    field in this class.\n+\/\/\/ 2. You have validated that the static initializer of this class doesn't depend on\n+\/\/\/    transient states (i.e., names of temporary directories) that cannot be carried over\n+\/\/\/    to a future production run.\n+\/\/\/ 3. All supertypes of this class must also have the `@AOTSafeClassInitializer`\n+\/\/\/    annotation.\n+\/\/\/\n+\/\/\/ This annotation is only recognized on privileged code and is ignored elsewhere.\n+\/\/\/\n+\/\/\/ @since 26\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface AOTSafeClassInitializer {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTSafeClassInitializer.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}