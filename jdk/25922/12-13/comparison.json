{"files":[{"patch":"@@ -33,16 +33,42 @@\n-\/\/\/ Indicates that if this class or interface is stored in the AOT cache in the\n-\/\/\/ \"initialized\" state, the `private static void runtimeSetup()` method will\n-\/\/\/ be executed instead of the static initializer in the production run.  In\n-\/\/\/ contrast, other \"initialized\" classes skip initialization methods altogether.\n-\/\/\/\n-\/\/\/ Another similar concept is `resetArchivedStates`, which allows handling\n-\/\/\/ before storing into the AOT cache in the \"initialized\" state in an assembly\n-\/\/\/ run. This is currently only used by [Class] to clear up a cache field, but\n-\/\/\/ may be expanded to other classes and interfaces later on.\n-\/\/\/\n-\/\/\/ Note that for a class to be stored initialized, it must be qualified as\n-\/\/\/ [AOTSafeClassInitializer].\n-\/\/\/\n-\/\/\/ `classFileParser.cpp` performs checks on the annotated method - if the\n-\/\/\/ annotated method's signature differs from that described above, or in the\n-\/\/\/ assembly phase, the class is not marked to have an AOT-safe initializer, a\n+\/\/\/ Indicates that if the enclosing class or interface is present in the AOT\n+\/\/\/ cache in the AOT-initialized state, the annotated method must be executed\n+\/\/\/ before bootstrap phase 3 (that is, before [System#initPhase3]).\n+\/\/\/\n+\/\/\/ The annotated method must be declared `private` and `static`, must be named\n+\/\/\/ `runtimeSetup`, and must have no arguments or return value.  The enclosing\n+\/\/\/ class must be annotated with [AOTSafeClassInitializer], meaning that it is\n+\/\/\/ allowed to be stored in the AOT-initialized state.\n+\/\/\/\n+\/\/\/ The annotated method will be executed if and only if the class was loaded\n+\/\/\/ in the AOT-initialized state from the AOT cache.\n+\/\/\/\n+\/\/\/ The author of the class is responsible for deciding whether some or all of\n+\/\/\/ a class's initialization state should be re-initialized in any way.  In all\n+\/\/\/ cases, the static initializer (`<clinit>` method) of any given class or\n+\/\/\/ interface is run at most once, either in the assembly phase (only for an\n+\/\/\/ AOT-initialized class) or in the production run.\n+\/\/\/\n+\/\/\/ After a `static` `final` field is assigned a value in an AOT-initialized\n+\/\/\/ class, its value may never be changed, as such values are always immutable\n+\/\/\/ runtime constants.  (...Barring `System.out` and its two siblings.)\n+\/\/\/ Rarely, a `static` field may require differing values in the assembly phase\n+\/\/\/ for an AOT cache, and for the production run.  Such variables must be\n+\/\/\/ marked non-`final`, and should be adjusted by the `runtimeSetup` method.\n+\/\/\/ Full constant folding (as if with a `final` field) may usually be recovered\n+\/\/\/ by also marking the field as [Stable].  That annotation instructs the JIT\n+\/\/\/ to perform constant folding, and _only_ during the production run, after\n+\/\/\/ `runtimeSetup` has had a chance to give the field its \"finally final\"\n+\/\/\/ value.\n+\/\/\/\n+\/\/\/ A related method is `resetArchivedStates`, which allows special handling of\n+\/\/\/ an AOT-initialized class, at the end of the assembly phase run which builds\n+\/\/\/ an AOT cache.  The `resetArchivedStates` may \"tear down\" state that should\n+\/\/\/ not be stored in the AOT cache, which the `runtimeSetup` method may then\n+\/\/\/ \"build up again\" as the production run begins.  This additional method is\n+\/\/\/ currently only used by [Class] to reset a cache field, but it may be\n+\/\/\/ expanded to other classes and interfaces later on, using more\n+\/\/\/ annotation-driven logic.\n+\/\/\/\n+\/\/\/ The logic in `classFileParser.cpp` performs checks on the annotated method: If the\n+\/\/\/ annotated method's signature differs from that described above, or if (during the\n+\/\/\/ assembly phase) the class is not marked to have an AOT-safe initializer, a\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTRuntimeSetup.java","additions":42,"deletions":16,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -33,4 +33,4 @@\n-\/\/\/ Indicates that the static initializer of this class or interface is\n-\/\/\/ considered \"safe\" for AOT assembly. I.e., if this class or interface\n-\/\/\/ has been initialized in the AOT assembly phase, then this class or interface\n-\/\/\/ can be safely stored in the AOT cache in the \"initialized\" state:\n+\/\/\/ Indicates that the static initializer of this class or interface\n+\/\/\/ (its `<clinit>` method) is allowed to be _AOT-initialized_,\n+\/\/\/ because its author considers it safe to execute during the AOT\n+\/\/\/ assembly phase.\n@@ -38,4 +38,4 @@\n-\/\/\/ 1. During the production run, the static initializer of this class or\n-\/\/\/    interface will not be executed.\n-\/\/\/ 2. The values of the static fields of this class or interface will be the same\n-\/\/\/    as their values at the end of the assembly phase.\n+\/\/\/ This annotation directs the VM to expect that normal execution of Java code\n+\/\/\/ during the assembly phase could trigger initialization of this class,\n+\/\/\/ and if that happens, to store the resulting static field values in the\n+\/\/\/ AOT cache.  (These fields happen to be allocated in the `Class` mirror.)\n@@ -43,2 +43,5 @@\n-\/\/\/ Currently, this annotation is used only for supporting AOT linking of\n-\/\/\/ java.lang.invoke primitives.\n+\/\/\/ During the production run, the static initializer (`<clinit>`) of\n+\/\/\/ this class or interface will not be executed, if it was already\n+\/\/\/ executed during the assembling of the AOT being used to start the\n+\/\/\/ production run.  In that case the resulting static field states\n+\/\/\/ (within the `Class` mirror) were already stored in the AOT cache.\n@@ -46,1 +49,3 @@\n-\/\/\/ The AOT assembly phase performs the following:\n+\/\/\/ Currently, this annotation is used mainly for supporting AOT\n+\/\/\/ linking of APIs, including bootstrap methods, in the\n+\/\/\/ `java.lang.invoke` package.\n@@ -48,1 +53,3 @@\n-\/\/\/ 1. Load and link (but does not initialize) all classes that were loaded\n+\/\/\/ In more detail, the AOT assembly phase performs the following:\n+\/\/\/\n+\/\/\/ 1. It loads and links (but does not initialize) the classes that were loaded\n@@ -50,22 +57,66 @@\n-\/\/\/ 2. During linking of these classes, we resolve constant pool\n-\/\/\/    entries when it's safe and beneficial to do so.\n-\/\/\/\n-\/\/\/ An AOT-resolved constant pool entry for an invokedynamic or invokehandle bytecode can\n-\/\/\/ have direct or indirect references to Java objects. To ensure the correctness\n-\/\/\/ of the AOT-resolved constant pool entrties, we store the classes of such Java objects\n-\/\/\/ in the AOT cache in the initialized state (as described above).\n-\/\/\/\n-\/\/\/ However, such Java objects may have references to static fields whose object identity\n-\/\/\/ is important. For example, `PrimitiveClassDescImpl::CD_void`. To ensure correctness,\n-\/\/\/ we must also store classes like `PrimitiveClassDescImpl` in the initialized state.\n-\/\/\/ We require the implementors of java.lang.invoke to manually annotate such classes with\n-\/\/\/ `@AOTSafeClassInitializer`. This should be done when:\n-\/\/\/\n-\/\/\/ 1. It's possible for an artifact used in the linking java.lang.invoke primitives\n-\/\/\/    (usually a MethodHandle) to directly or indirectly remember the value of a static\n-\/\/\/    field in this class.\n-\/\/\/ 2. You have validated that the static initializer of this class doesn't depend on\n-\/\/\/    transient states (i.e., names of temporary directories) that cannot be carried over\n-\/\/\/    to a future production run.\n-\/\/\/ 3. All supertypes of this class must also have the `@AOTSafeClassInitializer`\n-\/\/\/    annotation.\n+\/\/\/ 2. During linking of these classes, it resolves their constant pool\n+\/\/\/    entries, when it is safe and beneficial to do so.\n+\/\/\/ 3. As part of those resolutions, bootstrap methods may be called and may\n+\/\/\/    create graphs of Java objects to support linkage states.\n+\/\/\/ 4. Every object within those graphs must have its class AOT-initialized,\n+\/\/\/    along with every relevant superclass and implemented interface, along\n+\/\/\/    with classes for every object created during the course of static\n+\/\/\/    initialization (running `<clinit>` for each such class or interface).\n+\/\/\/\n+\/\/\/ Thus, in order to determine that a class or interface _X_ is safe to\n+\/\/\/ AOT-initialize requires evaluating every other class or interface _Y_ that\n+\/\/\/ the `<clinit>` of _X_ will initialize (during AOT cache assembly), and\n+\/\/\/ ensuring that each such _Y_ is (recursively) safe to AOT-initialize.\n+\/\/\/\n+\/\/\/ For example, an AOT-resolved constant pool entry for an invokedynamic or\n+\/\/\/ invokehandle bytecode can have direct or indirect references to Java objects.\n+\/\/\/ To ensure the correctness of the AOT-resolved constant pool entrties, the VM\n+\/\/\/ must AOT-initialize the classes of such Java objects.\n+\/\/\/\n+\/\/\/ In addition, such Java objects may have references to static fields whose\n+\/\/\/ object identity is important. For example, `PrimitiveClassDescImpl::CD_void`.\n+\/\/\/ To ensure correctness, we must also store classes like `PrimitiveClassDescImpl`\n+\/\/\/ in the initialized state. The VM requires implementor to manually annotate\n+\/\/\/ such classes with `@AOTSafeClassInitializer`.\n+\/\/\/\n+\/\/\/ There is one more requirement for a class to be safe for\n+\/\/\/ AOT initialization, and that is compatibility with all eventual production\n+\/\/\/ runs.  The state of an AOT-initialized class _X_ must not contain any data\n+\/\/\/ (anything reachable from _X_) that is incompatible with the eventual\n+\/\/\/ production run.\n+\/\/\/\n+\/\/\/ In general, if some sort of computed datum, environmental setting, or\n+\/\/\/ variable behavior may differ between the AOT assembly phase and the\n+\/\/\/ production run, it may not be immutably bound to _X_, if _X_ is to be\n+\/\/\/ marked AOT-initialized.  Here are specific examples:\n+\/\/\/\n+\/\/\/  - The value of an environment string (if it may differ in the production run).\n+\/\/\/\n+\/\/\/  - A transient configuration parameter specific to this VM run, such as\n+\/\/\/    wall clock time, process ID, host name, temporary directory names, etc.\n+\/\/\/\n+\/\/\/  - A random seed or key that may need to be re-sampled at production\n+\/\/\/    startup.\n+\/\/\/\n+\/\/\/ What is more, if the initialization of _X_ computes with some value _V_\n+\/\/\/ obtained from some other class _Y_, _Y_ should also be safe for AOT\n+\/\/\/ initialization, if there is any way for _X_ to detect a mismatch between\n+\/\/\/ the version of _V_ produced at AOT time, and the version of _V_ produced in\n+\/\/\/ the production run.  Specifically, if _V_ has an object identity, _X_\n+\/\/\/ should not test that identity (compare it against another or get its\n+\/\/\/ hashcode) unless _Y_ is also marked for AOT initialization.\n+\/\/\/\n+\/\/\/ Thus, to support AOT-time linkage, a class _X_ should be marked for (possible)\n+\/\/\/ AOT initialization whenever objects it creates (such as `MethodHandle`s)\n+\/\/\/ may be required to execute a `java.lang.invoke` API request, or (more\n+\/\/\/ remotely) if the execution of such an API touches _X_ for initialization,\n+\/\/\/ or even if such an API request is in any way sensitive to values stored in\n+\/\/\/ the fields of _X_, even if the sensitivity is a simple reference identity\n+\/\/\/ test.  As noted above, all supertypes of _X_ must also have the\n+\/\/\/ `@AOTSafeClassInitializer` annotation, and must also be safe for AOT\n+\/\/\/ initialization.\n+\/\/\/\n+\/\/\/ The author of an AOT-initialized class may elect to patch some states at\n+\/\/\/ production startup, using an [AOTRuntimeSetup] method, as long as the\n+\/\/\/ pre-patched field values (present during AOT assembly) are determined to be\n+\/\/\/ compatible with the post-patched values that apply to the production run.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTSafeClassInitializer.java","additions":85,"deletions":34,"binary":false,"changes":119,"status":"modified"}]}