{"files":[{"patch":"@@ -40,37 +40,0 @@\n-\/\/ Tell if ik is marked as AOT initialization safe via @jdk.internal.vm.annotation.AOTSafeClassInitializer.\n-bool AOTClassInitializer::allows_aot_initialization(InstanceKlass* ik) {\n-  if (ik->has_aot_safe_initializer()) {\n-    \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n-    \/\/   - all super classes must be included\n-    \/\/   - all super interfaces that have <clinit> must be included.\n-    \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n-    \/\/ ik's <clinit>.\n-    if (ik->java_super() != nullptr) {\n-      DEBUG_ONLY(ResourceMark rm);\n-      assert(AOTClassInitializer::can_archive_initialized_mirror(ik->java_super()),\n-             \"super class %s of %s must be aot-initialized\", ik->java_super()->external_name(),\n-             ik->external_name());\n-    }\n-\n-    Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-    int len = interfaces->length();\n-    for (int i = 0; i < len; i++) {\n-      InstanceKlass* intf = interfaces->at(i);\n-      if (intf->class_initializer() != nullptr) {\n-        assert(AOTClassInitializer::can_archive_initialized_mirror(intf),\n-               \"super interface %s (which has <clinit>) of %s must be aot-initialized\", intf->external_name(),\n-               ik->external_name());\n-      }\n-    }\n-\n-    if (log_is_enabled(Info, aot, init)) {\n-      ResourceMark rm;\n-      log_info(aot, init)(\"Found @AOTSafeClassInitializer class %s\", ik->external_name());\n-    }\n-\n-    return true;\n-  }\n-  return false;\n-}\n-\n-\n@@ -256,1 +219,1 @@\n-    if (allows_aot_initialization(ik)) {\n+    if (ik->has_aot_safe_initializer()) {\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-  static bool allows_aot_initialization(InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5149,1 +5149,1 @@\n-  if (_parsed_annotations->has_any_annotations()) {\n+  if (_parsed_annotations->has_any_annotations())\n@@ -5151,0 +5151,28 @@\n+\n+  \/\/ Check the aot initialization safe status\n+  if (ik->has_aot_safe_initializer()) {\n+    \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n+    \/\/   - all super classes must be included\n+    \/\/   - all super interfaces that have <clinit> must be included.\n+    \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n+    \/\/ ik's <clinit>.\n+    if (_super_klass != nullptr) {\n+      if (!_super_klass->has_aot_safe_initializer()) {\n+        classfile_parse_error(\"aot-initialization safe %s requires an aot-initialization safe super class\", CHECK);\n+      }\n+    }\n+\n+    int len = _transitive_interfaces->length();\n+    for (int i = 0; i < len; i++) {\n+      InstanceKlass* intf = _transitive_interfaces->at(i);\n+      if (intf->class_initializer() != nullptr) {\n+        if (!intf->has_aot_safe_initializer()) {\n+          classfile_parse_error(\"superinterface %s not aot-initialization safe for %s\", intf->external_name(), CHECK);\n+        }\n+      }\n+    }\n+\n+    if (log_is_enabled(Info, aot, init)) {\n+      ResourceMark rm;\n+      log_info(aot, init)(\"Found @AOTSafeClassInitializer class %s\", ik->external_name());\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -38,0 +39,1 @@\n+@AOTSafeClassInitializer \/\/ for hierarchy checks\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\/*non-public*\/\n@@ -319,1 +318,0 @@\n-    \/*non-public*\/\n@@ -410,1 +408,0 @@\n-    \/*non-public*\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-\/*non-public*\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-\/*non-public*\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-\/*non-public*\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-AOTClassInitializer\n-------\n-\n-Normally, static initializers, if not triggered by an AOT cache, are\n-executed in a demand-driven order specified by the JVMS and JLS.\n-\n-The implementation of an AOT cache uses restricted execution of the\n-JVM during an \"assembly phase\", which executes certain class\n-initializers and bootstrap methods in a separate JVM, and then records\n-associated memory images of the results into the AOT cache.\n-\n-When a production run uses that AOT cache, it starts up in a state\n-which looks exactly as if the execution of that assembly phase was the\n-earliest part of the production run.  Thus, the application observes\n-the effect of classes having been loaded, linked, and even\n-initialized, as if the JVM did that work at the exact moment\n-requested, though unaccountably fast.\n-\n-This optimization only works if every operation in the assembly phase\n-is \"pure\" enough to execute in a separate JVM.  For example, such an\n-operation cannot be allowed to observe the process ID or a wall clock.\n-It must not write the file system, and may only read parts which (like\n-the classpath) we can prove will be the same for both JVM runs.  If a\n-special value like random seed is picked, it must be a value that will\n-not need to be picked again in the production run.\n-\n-Controlling the \"purity\" of all of these operations mandates that we\n-place very tight restrictions on what classes may be initialized\n-during AOT assembly.\n-\n-When a static initializer is executed during AOT assembly, the value\n-of each static field is recorded in the AOT cache.  When the JVM\n-starts its production run, using that same AOT cache, the JVM\n-immediately marks the class as initialized, and uses all static field\n-values recorded in the cache.\n-\n-AOT-cached static field values can refer to objects in the Java heap.\n-Also, AOT-resolved constant pool entries (like lambda creation sites)\n-can refer to heap objects as well.  Such heap objects are captured in\n-the AOT cache, along with all supporting metadata that may be\n-necessary.\n-\n-When an object exists in the AOT cache, it must be the case that the\n-class of each such cached heap object is also initialized.  This is\n-because the result of loading an AOT cache must look like a valid,\n-standard-conformant execution of the JVM.  But a heap object with an\n-uninitialized class is an impossibility within the JVMS.\n-\n-> This is not true in the current implementation - a \"special object\n-> graph\" is tracked; currently we only ensure initialization is complete\n-> before objects are returned. This double-initialization is risky but\n-> apparently worked for simple cases before JEP 483. `heapShared.hpp`\n-> has more details about this graph.\n-\n-For such reasons, one class often has an \"initialization dependency\"\n-on another class.  Some class A cannot complete its initialization\n-until some other class B has at least started its initialization.  For\n-example, initialization of `PrimitiveClassDescImpl` is triggered by\n-initialization of `ConstantDescs`.\n-\n-This is sometimes called an \"init-dependency of A on B\".  Note that we\n-must assert that any initialization that is _started_ in the AOT cache\n-is also _finished_ before the AOT cache is fully generated.  This is\n-true because initializer threads cannot be stored in the AOT cache,\n-only the data images created by such threads.\n-\n-Therefore, if a class A is marked `AOTClassInitializer`, and it has\n-an init-dependency on some class B, that class B must also be marked\n-as `AOTClassInitializer`, if B in fact has a `<clinit>` method.\n-\n-Some dependencies are not explicitly expressed as field values, such\n-as `MemberName` references to methods in holder classes like\n-`DirectMethodHandle$Holder`, which requires the target class to be\n-AOT-initialized despite having no static methods.\n-\n-A class which is so simple that it has no `<clinit>` does not need to\n-be marked by this annotation, as long as all its super-classes, and\n-initialized super-interfaces, are also equally simple.  The AOT\n-assembly phase will pre-initialize it if necessary.  Every class which\n-has complex initialization, and either has instances in the AOT heap,\n-or certain kinds of method handle references in the AOT heap, must be\n-marked this way.\n-\n-During the AOT assembly phase, all of these dependencies are carefully\n-checked by a JVM class called `CDSHeapVerifier`.  See\n-`aotConstantPoolResolver.cpp` for more details.\n-\n-Note that many classes do not need marking with this annotation simply\n-because they are not used at AOT time, or because they are used as\n-pure types, without the need for initialization.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOT.md","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -53,1 +53,1 @@\n-\/\/\/ An AOT-resolved constant pool entry for an invokedynamic or invokehandle bytecodes can\n+\/\/\/ An AOT-resolved constant pool entry for an invokedynamic or invokehandle bytecode can\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTSafeClassInitializer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}