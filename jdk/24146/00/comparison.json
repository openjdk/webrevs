{"files":[{"patch":"@@ -663,0 +663,7 @@\n+\n+#ifdef ASSERT\n+  G1HeapRegion* r = _g1h->region_at(index);\n+  assert(live_bytes != 0,\n+         \"live bytes not set for %u used %zu garbage %zu cm-live %zu pinned %d\",\n+         index, r->used(), r->garbage_bytes(), live_bytes, r->has_pinned_objects());\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -290,2 +290,0 @@\n-    G1EvacFailureRegions* _evac_failure_regions;\n-    uint _worker_id;\n@@ -366,4 +364,1 @@\n-    G1PrepareRegionsClosure(G1CollectedHeap* g1h,\n-                            G1PrepareEvacuationTask* parent_task,\n-                            G1EvacFailureRegions* evac_failure_regions,\n-                            uint worker_id) :\n+    G1PrepareRegionsClosure(G1CollectedHeap* g1h, G1PrepareEvacuationTask* parent_task) :\n@@ -372,2 +367,0 @@\n-      _evac_failure_regions(evac_failure_regions),\n-      _worker_id(worker_id),\n@@ -383,7 +376,0 @@\n-      \/\/ All pinned regions in the collection set must be registered as failed\n-      \/\/ regions here as there is no guarantee that there is a reference\n-      \/\/ reachable by Java code (i.e. only by native code).\n-      if (hr->in_collection_set() && hr->has_pinned_objects()) {\n-        _evac_failure_regions->record(_worker_id, hr->hrm_index(), true \/* cause_pinned *\/);\n-      }\n-\n@@ -432,1 +418,0 @@\n-  G1EvacFailureRegions* _evac_failure_regions;\n@@ -440,1 +425,1 @@\n-  G1PrepareEvacuationTask(G1CollectedHeap* g1h, G1EvacFailureRegions* evac_failure_regions) :\n+  G1PrepareEvacuationTask(G1CollectedHeap* g1h) :\n@@ -443,1 +428,0 @@\n-    _evac_failure_regions(evac_failure_regions),\n@@ -446,2 +430,1 @@\n-    _humongous_candidates(0),\n-    _all_card_set_stats() { }\n+    _humongous_candidates(0) { }\n@@ -450,1 +433,1 @@\n-    G1PrepareRegionsClosure cl(_g1h, this, _evac_failure_regions, worker_id);\n+    G1PrepareRegionsClosure cl(_g1h, this);\n@@ -492,2 +475,1 @@\n-void G1YoungCollector::pre_evacuate_collection_set(G1EvacInfo* evacuation_info,\n-                                                   G1EvacFailureRegions* evac_failure_regions) {\n+void G1YoungCollector::pre_evacuate_collection_set(G1EvacInfo* evacuation_info) {\n@@ -532,1 +514,1 @@\n-    G1PrepareEvacuationTask g1_prep_task(_g1h, evac_failure_regions);\n+    G1PrepareEvacuationTask g1_prep_task(_g1h);\n@@ -1125,1 +1107,1 @@\n-    pre_evacuate_collection_set(jtm.evacuation_info(), &_evac_failure_regions);\n+    pre_evacuate_collection_set(jtm.evacuation_info());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":7,"deletions":25,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-  void pre_evacuate_collection_set(G1EvacInfo* evacuation_info,\n-                                   G1EvacFailureRegions* evac_failure_regions);\n+  void pre_evacuate_collection_set(G1EvacInfo* evacuation_info);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Test that pinned regions with no Java references into them\n- *          do not make the garbage collector reclaim that region.\n- *          This test simulates this behavior using Whitebox\/Unsafe methods\n- *          to pin a Java object in a region with no other pinnable objects and\n-*           lose the reference to it before the garbage collection.\n- * @requires vm.gc.G1\n- * @requires vm.debug\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc:+open\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC\n- *      -Xbootclasspath\/a:. -Xlog:gc=debug,gc+ergo+cset=trace,gc+phases=debug -XX:G1HeapRegionSize=1m -Xms30m  gc.g1.pinnedobjs.TestPinnedEvacEmpty\n- *\/\n-\n-package gc.g1.pinnedobjs;\n-\n-import jdk.internal.misc.Unsafe;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class TestPinnedEvacEmpty {\n-\n-    private static final jdk.internal.misc.Unsafe unsafe = Unsafe.getUnsafe();\n-    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-    private static final long objSize = wb.getObjectSize(new Object());\n-\n-    \/\/ How many j.l.Object should we allocate when creating garbage.\n-    private static final long numAllocations = 1024 * 1024 * 3 \/ objSize;\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Remove garbage from VM initialization.\n-        wb.fullGC();\n-\n-        \/\/ Allocate garbage so that the target object will be in a new region.\n-        for (int i = 0; i < numAllocations; i++) {\n-          Object z = new Object();\n-        }\n-        int[] o = new int[100];  \/\/ The target object to pin.\n-        \/\/ Further allocate garbage so that any additional allocations of potentially\n-        \/\/ pinned objects can not be allocated in the same region as the target object.\n-        for (int i = 0; i < numAllocations; i++) {\n-          Object z = new Object();\n-        }\n-\n-        Asserts.assertTrue(!wb.isObjectInOldGen(o), \"should not be in old gen already\");\n-\n-        \/\/ Pin the object.\n-        wb.pinObject(o);\n-\n-        \/\/ And forget the (Java) reference to the int array. After this, the garbage\n-        \/\/ collection should find a completely empty pinned region. The collector\n-        \/\/ must not collect\/free it.\n-        o = null;\n-\n-        \/\/ Do garbage collection to zap the data in the pinned region.\n-        wb.youngGC();\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedEvacEmpty.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"}]}