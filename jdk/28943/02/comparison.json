{"files":[{"patch":"@@ -700,1 +700,1 @@\n-    private void addDeserializationCase(MethodHandleSymbol refSym, Type targetType, MethodSymbol samSym,\n+    private void addDeserializationCase(MethodHandleSymbol refSym, Type targetType, MethodSymbol samSym, Type samType,\n@@ -705,6 +705,8 @@\n-        Symbol baseMethod = types.overriddenObjectMethod(refSym.enclClass(), refSym);\n-        if (baseMethod != null) {\n-            \/\/ The implementation method is a java.lang.Object method, runtime will resolve this method to\n-            \/\/ a java.lang.Object method, so do the same.\n-            \/\/ This case can be removed if JDK-8172817 is fixed.\n-            refSym = ((MethodSymbol) baseMethod).asHandle();\n+        if (refSym.enclClass().isInterface()) {\n+            Symbol baseMethod = types.overriddenObjectMethod(refSym.enclClass(), refSym);\n+            if (baseMethod != null) {\n+                \/\/ The implementation method is a java.lang.Object method, runtime will resolve this method to\n+                \/\/ a java.lang.Object method, so do the same.\n+                \/\/ This case can be removed if JDK-8172817 is fixed.\n+                refSym = ((MethodSymbol) baseMethod).asHandle();\n+            }\n@@ -715,0 +717,1 @@\n+        String instantiatedMethodType = typeSig(types.erasure(samType));\n@@ -727,7 +730,8 @@\n-                deserTest(deserTest(deserTest(deserTest(deserTest(\n-                                                        kindTest,\n-                                                        \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n-                                                \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n-                                        \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n-                                \"getImplClass\", implClass),\n-                        \"getImplMethodSignature\", implMethodSignature),\n+                deserTest(deserTest(deserTest(deserTest(deserTest(deserTest(\n+                                                                kindTest,\n+                                                                \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n+                                                        \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n+                                                \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n+                                        \"getImplClass\", implClass),\n+                                \"getImplMethodSignature\", implMethodSignature),\n+                        \"getInstantiatedMethodType\", instantiatedMethodType),\n@@ -754,0 +758,1 @@\n+        System.err.printf(\"*instantiatedMethodType: '%s'\\n\", instantiatedMethodType);\n@@ -815,0 +820,1 @@\n+        MethodType samType = typeToMethodType(tree.getDescriptorType(types));\n@@ -818,1 +824,1 @@\n-                typeToMethodType(tree.getDescriptorType(types)));\n+                samType);\n@@ -882,1 +888,1 @@\n-                    addDeserializationCase(refSym, tree.type, samSym,\n+                    addDeserializationCase(refSym, tree.type, samSym, samType,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+@test\n+@bug 8208752\n+@summary NPE generating serializedLambdaName for nested lambda\n+*\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.function.Function;\n+\n+public class LambdaSerializedClassCastException {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Function<String, String> lambda1 =\n+                (Function<String, String> & Serializable) Object::toString;\n+        Function<Object, String> lambda2 =\n+                (Function<Object, String> & Serializable) Object::toString;\n+\n+        Function<Object, String> deserial = serialDeserial(lambda2);\n+        deserial.apply(new Object());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T serialDeserial(T object) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(object);\n+        oos.close();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        T result = (T) ois.readObject();\n+        ois.close();\n+        return result;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaSerializedClassCastException.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -66,0 +66,4 @@\n+        enum E {\n+            ONE\n+        }\n+\n@@ -69,0 +73,2 @@\n+            F<E, Integer> f3 = E::hashCode;\n+            F<Object, Integer> f4 = Object::hashCode;\n@@ -88,0 +94,15 @@\n+                getInstantiatedMethodType (LSerializableObjectMethodReferencesOnInterfaces$Test$I1;)Ljava\/lang\/Integer;\n+                getImplMethodKind 5\n+                getFunctionalInterfaceClass SerializableObjectMethodReferencesOnInterfaces$Test$F\n+                getFunctionalInterfaceMethodName apply\n+                getFunctionalInterfaceMethodSignature (Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+                getImplClass java\/lang\/Object\n+                getImplMethodSignature ()I\n+                getInstantiatedMethodType (LSerializableObjectMethodReferencesOnInterfaces$Test$I2;)Ljava\/lang\/Integer;\n+                getImplMethodKind 5\n+                getFunctionalInterfaceClass SerializableObjectMethodReferencesOnInterfaces$Test$F\n+                getFunctionalInterfaceMethodName apply\n+                getFunctionalInterfaceMethodSignature (Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+                getImplClass java\/lang\/Enum\n+                getImplMethodSignature ()I\n+                getInstantiatedMethodType (LSerializableObjectMethodReferencesOnInterfaces$Test$E;)Ljava\/lang\/Integer;\n@@ -94,0 +115,1 @@\n+                getInstantiatedMethodType (Ljava\/lang\/Object;)Ljava\/lang\/Integer;\n","filename":"test\/langtools\/tools\/javac\/lambda\/SerializableObjectMethodReferencesOnInterfaces.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}