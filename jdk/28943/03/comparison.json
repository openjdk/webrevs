{"files":[{"patch":"@@ -704,1 +704,1 @@\n-    private void addDeserializationCase(MethodHandleSymbol refSym, Type targetType, MethodSymbol samSym,\n+    private void addDeserializationCase(MethodHandleSymbol refSym, Type targetType, MethodSymbol samSym, Type samType,\n@@ -721,0 +721,1 @@\n+        String instantiatedMethodType = typeSig(types.erasure(samType));\n@@ -734,7 +735,8 @@\n-                deserTest(deserTest(deserTest(deserTest(deserTest(\n-                                                        kindTest,\n-                                                        \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n-                                                \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n-                                        \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n-                                \"getImplClass\", implClass),\n-                        \"getImplMethodSignature\", implMethodSignature),\n+                deserTest(deserTest(deserTest(deserTest(deserTest(deserTest(\n+                                                                kindTest,\n+                                                                \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n+                                                        \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n+                                                \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n+                                        \"getImplClass\", implClass),\n+                                \"getImplMethodSignature\", implMethodSignature),\n+                        \"getInstantiatedMethodType\", instantiatedMethodType),\n@@ -760,1 +762,2 @@\n-                    implMethodSignature));\n+                    implMethodSignature,\n+                    instantiatedMethodType));\n@@ -822,0 +825,1 @@\n+        MethodType samType = typeToMethodType(tree.getDescriptorType(types));\n@@ -825,1 +829,1 @@\n-                typeToMethodType(tree.getDescriptorType(types)));\n+                samType);\n@@ -889,1 +893,1 @@\n-                    addDeserializationCase(refSym, tree.type, samSym,\n+                    addDeserializationCase(refSym, tree.type, samSym, samType,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1704,1 +1704,1 @@\n-# 0: string, 1: string, 2: string, 3: number, 4: string, 5: string, 6: string\n+# 0: string, 1: string, 2: string, 3: number, 4: string, 5: string, 6: string, 7: string\n@@ -1713,1 +1713,2 @@\n-    implMethodSignature: {6}\n+    implMethodSignature: {6}\\n\\\n+    instantiatedMethodType: {7}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8208752\n+ * @summary NPE generating serializedLambdaName for nested lambda\n+ * @compile\/ref=LambdaSerializedClassCastException.out -XDrawDiagnostics --debug=dumpLambdaDeserializationStats LambdaSerializedClassCastException.java\n+ * @run main LambdaSerializedClassCastException\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.function.Function;\n+\n+public class LambdaSerializedClassCastException {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Function<String, String> lambda1 =\n+                (Function<String, String> & Serializable) Object::toString;\n+        Function<Object, String> lambda2 =\n+                (Function<Object, String> & Serializable) Object::toString;\n+\n+        Function<Object, String> deserial = serialDeserial(lambda2);\n+        deserial.apply(new Object());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T serialDeserial(T object) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(object);\n+        }\n+        try (ObjectInputStream ois =\n+                new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()))) {\n+            return (T) ois.readObject();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaSerializedClassCastException.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+LambdaSerializedClassCastException.java:44:59: compiler.note.lambda.deserialization.stat: java\/util\/function\/Function, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, toString, ()Ljava\/lang\/String;, (Ljava\/lang\/String;)Ljava\/lang\/String;\n+LambdaSerializedClassCastException.java:46:59: compiler.note.lambda.deserialization.stat: java\/util\/function\/Function, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, toString, ()Ljava\/lang\/String;, (Ljava\/lang\/Object;)Ljava\/lang\/String;\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaSerializedClassCastException.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8374654 8208752\n@@ -27,5 +28,0 @@\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.jdeps\/com.sun.tools.javap\n- * @build toolbox.ToolBox toolbox.JavacTask\n@@ -33,0 +29,1 @@\n+ * @run main SerializableObjectMethodReferencesOnInterfaces\n@@ -35,0 +32,4 @@\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n@@ -36,1 +37,0 @@\n-import java.lang.classfile.*;\n@@ -40,0 +40,4 @@\n+    public static void main(String[] args) throws Exception {\n+        new Test().run();\n+    }\n+\n@@ -56,1 +60,1 @@\n-        void f() throws Exception {\n+        void run() throws Exception {\n@@ -61,0 +65,17 @@\n+\n+            serialDeserial(f1).apply(new I1() {});\n+            serialDeserial(f2).apply(new I2() {});\n+            serialDeserial(f3).apply(E.ONE);\n+            serialDeserial(f4).apply(new Object());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T serialDeserial(T object) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(object);\n+        }\n+        try (ObjectInputStream ois =\n+                new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()))) {\n+            return (T) ois.readObject();\n","filename":"test\/langtools\/tools\/javac\/lambda\/SerializableObjectMethodReferencesOnInterfaces.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-SerializableObjectMethodReferencesOnInterfaces.java:57:33: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I\n-SerializableObjectMethodReferencesOnInterfaces.java:58:33: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I\n-SerializableObjectMethodReferencesOnInterfaces.java:59:32: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Enum, hashCode, ()I\n-SerializableObjectMethodReferencesOnInterfaces.java:60:37: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I\n+SerializableObjectMethodReferencesOnInterfaces.java:61:33: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I, (LSerializableObjectMethodReferencesOnInterfaces$Test$I1;)Ljava\/lang\/Integer;\n+SerializableObjectMethodReferencesOnInterfaces.java:62:33: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I, (LSerializableObjectMethodReferencesOnInterfaces$Test$I2;)Ljava\/lang\/Integer;\n+SerializableObjectMethodReferencesOnInterfaces.java:63:32: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Enum, hashCode, ()I, (LSerializableObjectMethodReferencesOnInterfaces$Test$E;)Ljava\/lang\/Integer;\n+SerializableObjectMethodReferencesOnInterfaces.java:64:37: compiler.note.lambda.deserialization.stat: SerializableObjectMethodReferencesOnInterfaces$Test$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I, (Ljava\/lang\/Object;)Ljava\/lang\/Integer;\n","filename":"test\/langtools\/tools\/javac\/lambda\/SerializableObjectMethodReferencesOnInterfaces.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-SerializableObjectMethods.java:59:35: compiler.note.lambda.deserialization.stat: SerializableObjectMethods$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I\n-SerializableObjectMethods.java:60:35: compiler.note.lambda.deserialization.stat: SerializableObjectMethods$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I\n+SerializableObjectMethods.java:59:35: compiler.note.lambda.deserialization.stat: SerializableObjectMethods$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I, (LSerializableObjectMethods$I1;)Ljava\/lang\/Integer;\n+SerializableObjectMethods.java:60:35: compiler.note.lambda.deserialization.stat: SerializableObjectMethods$F, apply, (Ljava\/lang\/Object;)Ljava\/lang\/Object;, 5, java\/lang\/Object, hashCode, ()I, (LSerializableObjectMethods$I2;)Ljava\/lang\/Integer;\n","filename":"test\/langtools\/tools\/javac\/lambda\/SerializableObjectMethods.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}