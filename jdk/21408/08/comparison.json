{"files":[{"patch":"@@ -413,0 +413,7 @@\n+         * @implNote\n+         * In the JDK built-in implementation of the {@code HttpClient},\n+         * if a {@link HttpRequest} has an {@code Authorization} or {@code\n+         * Proxy-Authorization} header set then its value will be used and\n+         * the {@link Authenticator} will not be invoked for the corresponding\n+         * authentication.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -247,0 +247,8 @@\n+        if (req.getUserSetAuthFlag(SERVER) && status == UNAUTHORIZED) {\n+            \/\/ return the response. We don't handle it.\n+            return null;\n+        } else if (req.getUserSetAuthFlag(PROXY) && status == PROXY_UNAUTHORIZED) {\n+            \/\/ same\n+            return null;\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -94,1 +96,0 @@\n-\n@@ -107,1 +108,3 @@\n-                      connection.contextRestricted(request, client));\n+                      connection.contextRestricted(request));\n+\n+        Utils.setUserAuthFlags(request, userHeaders);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-    BiPredicate<String,String> contextRestricted(HttpRequestImpl request, HttpClient client) {\n+    BiPredicate<String,String> contextRestricted(HttpRequestImpl request) {\n@@ -363,1 +363,1 @@\n-            return Utils.PROXY_TUNNEL_RESTRICTED(client);\n+            return Utils.PROXY_TUNNEL_RESTRICTED();\n@@ -365,1 +365,1 @@\n-            return Utils.CONTEXT_RESTRICTED(client);\n+            return Utils.ACCEPT_ALL;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.net.Authenticator;\n@@ -50,0 +51,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -69,0 +72,2 @@\n+    private volatile boolean userSetAuthorization;\n+    private volatile boolean userSetProxyAuthorization;\n@@ -336,0 +341,24 @@\n+    \/**\n+     * These flags are set if the user set an Authorization or Proxy-Authorization header\n+     * overriding headers produced by an Authenticator that was also set\n+     *\n+     * The values are checked in the AuthenticationFilter which tells the library\n+     * to return whatever response received to the user instead of causing request\n+     * to be resent, in case of error.\n+     *\/\n+    public void setUserSetAuthFlag(Authenticator.RequestorType type, boolean value) {\n+        if (type == SERVER) {\n+            userSetAuthorization = value;\n+        } else {\n+            userSetProxyAuthorization = value;\n+        }\n+    }\n+\n+    public boolean getUserSetAuthFlag(Authenticator.RequestorType type) {\n+        if (type == SERVER) {\n+            return userSetAuthorization;\n+        } else {\n+            return userSetProxyAuthorization;\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -828,1 +828,2 @@\n-        userh = HttpHeaders.of(userh.map(), Utils.CONTEXT_RESTRICTED(client()));\n+        userh = HttpHeaders.of(userh.map(), Utils.ACCEPT_ALL);\n+        Utils.setUserAuthFlags(request, userh);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+import static java.net.Authenticator.RequestorType.PROXY;\n+import static java.net.Authenticator.RequestorType.SERVER;\n@@ -213,13 +215,0 @@\n-    \/\/ Headers that are not generally restricted, and can therefore be set by users,\n-    \/\/ but can in some contexts be overridden by the implementation.\n-    \/\/ Currently, only contains \"Authorization\" which will\n-    \/\/ be overridden, when an Authenticator is set on the HttpClient.\n-    \/\/ Needs to be BiPred<String,String> to fit with general form of predicates\n-    \/\/ used by caller.\n-\n-    public static final BiPredicate<String, String> CONTEXT_RESTRICTED(HttpClient client) {\n-        return (k, v) -> client.authenticator().isEmpty() ||\n-                (!k.equalsIgnoreCase(\"Authorization\")\n-                        && !k.equalsIgnoreCase(\"Proxy-Authorization\"));\n-    }\n-\n@@ -228,3 +217,2 @@\n-    private static final BiPredicate<String, String> HOST_RESTRICTED = (k,v) -> !\"host\".equalsIgnoreCase(k);\n-    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED(HttpClient client)  {\n-        return CONTEXT_RESTRICTED(client).and(HOST_RESTRICTED);\n+    public static final BiPredicate<String, String> PROXY_TUNNEL_RESTRICTED()  {\n+        return (k,v) -> !\"host\".equalsIgnoreCase(k);\n@@ -313,0 +301,13 @@\n+    \/**\n+     * Check the user headers to see if the Authorization or ProxyAuthorization\n+     * were set. We need to set special flags in the request if so. Otherwise\n+     * we can't distinguish user set from Authenticator set headers\n+     *\/\n+    public static void setUserAuthFlags(HttpRequestImpl request, HttpHeaders userHeaders) {\n+        if (userHeaders.firstValue(\"Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(SERVER, true);\n+        }\n+        if (userHeaders.firstValue(\"Proxy-Authorization\").isPresent()) {\n+            request.setUserSetAuthFlag(PROXY, true);\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import java.io.*;\n-import java.net.Authenticator;\n-import java.net.InetSocketAddress;\n-import java.net.ProxySelector;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.nio.channels.*;\n-import java.nio.charset.StandardCharsets;\n-\n-import jdk.test.lib.net.IPSupport;\n-\n-\/**\n- * @test\n- * @bug 8263442\n- * @summary Potential bug in jdk.internal.net.http.common.Utils.CONTEXT_RESTRICTED\n- * @library \/test\/lib\n- * @run main\/othervm AuthFilter\n- *\/\n-\n-public class AuthFilter {\n-    static class Auth extends Authenticator {\n-    }\n-\n-    static HttpServer createServer() throws IOException {\n-        HttpServer server = HttpServer.create(new InetSocketAddress(0), 5);\n-        HttpHandler handler = (HttpExchange e) -> {\n-            InputStream is = e.getRequestBody();\n-            is.readAllBytes();\n-            is.close();\n-            Headers reqh = e.getRequestHeaders();\n-            if (reqh.containsKey(\"authorization\")) {\n-                e.sendResponseHeaders(500, -1);\n-            } else {\n-                e.sendResponseHeaders(200, -1);\n-            }\n-        };\n-        server.createContext(\"\/\", handler);\n-        return server;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        test(false);\n-        test(true);\n-    }\n-\n-    \/**\n-     *  Fake proxy. Just looks for Proxy-Authorization header\n-     *  and returns error if seen. Returns 200 OK if not.\n-     *  Does not actually forward the request\n-     *\/\n-    static class ProxyServer extends Thread {\n-\n-        final ServerSocketChannel server;\n-        final int port;\n-        volatile SocketChannel c;\n-\n-        ProxyServer() throws IOException {\n-            server = ServerSocketChannel.open();\n-            server.bind(new InetSocketAddress(0));\n-            if (server.getLocalAddress() instanceof InetSocketAddress isa) {\n-                port = isa.getPort();\n-            } else {\n-                port = -1;\n-            }\n-        }\n-\n-        int getPort() {\n-            return port;\n-        }\n-\n-        static String ok = \"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok1 = \"HTTP\/1.1 500 Internal Server Error\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-        static String notok2 = \"HTTP\/1.1 501 Not Implemented\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n-\n-        static void reply(String msg, Writer writer) throws IOException {\n-            writer.write(msg);\n-            writer.flush();\n-        }\n-\n-        public void run() {\n-            try {\n-                c = server.accept();\n-                var cs = StandardCharsets.US_ASCII;\n-                LineNumberReader reader = new LineNumberReader(Channels.newReader(c, cs));\n-                Writer writer = Channels.newWriter(c, cs);\n-\n-                String line;\n-                while ((line=reader.readLine()) != null) {\n-                    if (line.indexOf(\"Proxy-Authorization\") != -1) {\n-                        reply(notok1, writer);\n-                        return;\n-                    }\n-                    if (line.equals(\"\")) {\n-                        \/\/ end of headers\n-                        reply(ok, writer);\n-                        return;\n-                    }\n-                }\n-                reply(notok2, writer);\n-            } catch (IOException e) {\n-            }\n-            try {\n-                server.close();\n-                c.close();\n-            } catch (IOException ee) {}\n-        }\n-    }\n-\n-    private static InetSocketAddress getLoopback(int port) throws IOException {\n-        if (IPSupport.hasIPv4()) {\n-            return new InetSocketAddress(\"127.0.0.1\", port);\n-        } else {\n-            return new InetSocketAddress(\"::1\", port);\n-        }\n-    }\n-\n-    public static void test(boolean useProxy) throws Exception {\n-        HttpServer server = createServer();\n-        int port = server.getAddress().getPort();\n-        ProxyServer proxy;\n-\n-        InetSocketAddress proxyAddr;\n-        String authHdr;\n-        if (useProxy) {\n-            proxy = new ProxyServer();\n-            proxyAddr = getLoopback(proxy.getPort());\n-            proxy.start();\n-            authHdr = \"Proxy-Authorization\";\n-        } else {\n-            authHdr = \"Authorization\";\n-            proxyAddr = null;\n-        }\n-\n-        server.start();\n-\n-        \/\/ proxyAddr == null => proxying disabled\n-        HttpClient client = HttpClient\n-                .newBuilder()\n-                .authenticator(new Auth())\n-                .proxy(ProxySelector.of(proxyAddr))\n-                .build();\n-\n-\n-        URI uri = new URI(\"http:\/\/127.0.0.1:\" + Integer.toString(port));\n-\n-        HttpRequest request = HttpRequest.newBuilder(uri)\n-                .header(authHdr, \"nonsense\")\n-                .GET()\n-                .build();\n-\n-        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n-        int r = response.statusCode();\n-        System.out.println(r);\n-        server.stop(0);\n-        if (r != 200)\n-            throw new RuntimeException(\"Test failed : \" + r);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilter.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -0,0 +1,503 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8326949\n+ * @summary Authorization header is removed when a proxy Authenticator is set\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ *        jdk.test.lib.net.IPSupport\n+ *\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ *\n+ * @run main\/othervm  -Djdk.httpclient.HttpClient.log=errors,requests,headers,ssl,trace,all UserAuthWithAuthenticator\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import javax.net.ssl.*;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.regex.*;\n+import java.util.*;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.lib.net.IPSupport;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import com.sun.net.httpserver.BasicAuthenticator;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n+public class UserAuthWithAuthenticator {\n+\n+    static class AuthTestHandler implements HttpTestHandler {\n+        volatile String authValue;\n+        final String response = \"Hello world\";\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = is.readAllBytes();\n+                authValue = t.getRequestHeaders().firstValue(\"Authorization\").orElse(\"\");\n+                t.sendResponseHeaders(200, response.length());\n+                os.write(response.getBytes(US_ASCII));\n+                t.close();\n+            }\n+        }\n+\n+        String authValue() {return authValue;}\n+    }\n+\n+    \/\/ if useHeader is true, we expect the Authenticator was not called\n+    \/\/ and the user set header used. If false, Authenticator must\n+    \/\/ be called and the user set header not used.\n+\n+    static void h2Test(final boolean useHeader) throws Exception {\n+        SSLContext ctx;\n+        HttpTestServer h2s = null;\n+        HttpClient client = null;\n+        ExecutorService ex=null;\n+        try {\n+            ctx = new SimpleSSLContext().get();\n+            ex = Executors.newCachedThreadPool();\n+            InetAddress addr = InetAddress.getLoopbackAddress();\n+\n+            h2s = HttpTestServer.of(new Http2TestServer(addr, \"::1\", true, 0, ex,\n+                    10, null, ctx, false));\n+            AuthTestHandler h = new AuthTestHandler();\n+            var context = h2s.addHandler(h, \"\/test1\");\n+            context.setAuthenticator(new BasicAuthenticator(\"realm\") {\n+                public boolean checkCredentials(String username, String password) {\n+                    if (useHeader) {\n+                        return username.equals(\"user\") && password.equals(\"pwd\");\n+                    } else {\n+                        return username.equals(\"serverUser\") && password.equals(\"serverPwd\");\n+                    }\n+                }\n+            });\n+            h2s.start();\n+\n+            int port = h2s.getAddress().getPort();\n+            ServerAuth sa = new ServerAuth();\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+\n+            URI uri = URIBuilder.newBuilder()\n+                 .scheme(\"https\")\n+                 .host(addr.getHostAddress())\n+                 .port(port)\n+                 .path(\"\/test1\/foo.txt\")\n+                 .build();\n+\n+            HttpClient.Builder builder = HttpClient.newBuilder()\n+                    .sslContext(ctx)\n+                    .executor(ex);\n+\n+            \/\/if (!useHeader) {\n+                builder.authenticator(sa);\n+            \/\/}\n+            client = builder.build();\n+\n+            HttpRequest req = HttpRequest.newBuilder(uri)\n+                    .version(HttpClient.Version.HTTP_2)\n+                    .header(useHeader ? \"Authorization\" : \"X-Ignore\", encoded)\n+                    .GET()\n+                    .build();\n+\n+            HttpResponse<String> resp = client.send(req, HttpResponse.BodyHandlers.ofString());\n+            if (useHeader) {\n+                assertTrue(h.authValue() == null, \"Expected user set header to be set\");\n+                assertTrue(!sa.wasCalled(), \"Expected authenticator not to be called\");\n+                System.out.println(\"h2Test: using user set header OK\");\n+            } else {\n+                assertTrue(!h.authValue().equals(encoded), \"Expected user set header to not be set\");\n+                assertTrue(sa.wasCalled(), \"Expected authenticator to be called\");\n+                System.out.println(\"h2Test: using authenticator OK\");\n+            }\n+        } finally {\n+            if (h2s != null)\n+                h2s.stop();\n+            if (client != null)\n+                client.close();\n+            if (ex != null)\n+                ex.shutdown();\n+        }\n+    }\n+\n+    static final String data = \"0123456789\";\n+\n+    static final String data1 = \"ABCDEFGHIJKL\";\n+\n+    static final String[] proxyResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data.length() + \"\\r\\n\\r\\n\" + data\n+    };\n+\n+    static final String[] proxyWithErrorResponses = {\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"Proxy-Authenticate: Basic realm=\\\"Access to the proxy\\\"\\r\\n\\r\\n\"\n+    };\n+\n+    static final String[] serverResponses = {\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    static final String[] authenticatorResponses = {\n+        \"HTTP\/1.1 401 Authentication Required\\r\\n\"+\n+        \"Content-Length: 0\\r\\n\" +\n+        \"WWW-Authenticate: Basic realm=\\\"Access to the server\\\"\\r\\n\\r\\n\"\n+        ,\n+        \"HTTP\/1.1 200 OK\\r\\n\"+\n+        \"Date: Mon, 15 Jan 2001 12:18:21 GMT\\r\\n\" +\n+        \"Server: Apache\/1.3.14 (Unix)\\r\\n\" +\n+        \"Content-Length: \" + data1.length() + \"\\r\\n\\r\\n\" + data1\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        testServerOnly();\n+        testServerWithProxy();\n+        testServerWithProxyError();\n+        testServerOnlyAuthenticator();\n+        h2Test(true);\n+        h2Test(false);\n+    }\n+\n+    static void testServerWithProxy() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyResponses);\n+        proxyMock.start();\n+        ProxyAuth p = new ProxyAuth();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(p)\n+                .build()) {\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            assertEquals(200, response.statusCode());\n+            assertTrue(p.wasCalled(), \"Proxy authenticator was not called\");\n+            assertEquals(data, response.body());\n+            var proxyStr = proxyMock.getRequest(1);\n+\n+            assertContains(proxyStr, \"\/some_url\");\n+            assertPattern(\".*^Proxy-Authorization:.*Basic \" + encoded + \".*\", proxyStr);\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", proxyStr);\n+            assertPattern(\".*^Authorization:.*Basic.*\", proxyStr);\n+            System.out.println(\"testServerWithProxy: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n+    static void testServerWithProxyError() throws IOException, InterruptedException {\n+        Mocker proxyMock = new Mocker(proxyWithErrorResponses);\n+        proxyMock.start();\n+        ProxyAuth p = new ProxyAuth();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .proxy(new ProxySel(proxyMock.getPort()))\n+                .authenticator(p)\n+                .build()) {\n+\n+            var badCreds = \"user:wrong\";\n+            var encoded1 = java.util.Base64.getEncoder().encodeToString(badCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(\"http:\/\/127.0.0.1\/some_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Proxy-Authorization\", \"Basic \" + encoded1)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+            var proxyStr = proxyMock.getRequest(0);\n+            assertEquals(407, response.statusCode());\n+            assertPattern(\".*^Proxy-Authorization:.*Basic \" + encoded1 + \".*\", proxyStr);\n+            assertTrue(!p.wasCalled(), \"Proxy Auth should not have been called\");\n+            System.out.println(\"testServerWithProxyError: OK\");\n+        } finally {\n+            proxyMock.stopMocker();\n+        }\n+    }\n+\n+    static void testServerOnly() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(serverResponses);\n+        serverMock.start();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .build()) {\n+\n+            var plainCreds = \"user:pwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .setHeader(\"Authorization\", \"Basic \" + encoded)\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(0);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnly: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    \/\/ This is effectively a regression test for existing behavior\n+    static void testServerOnlyAuthenticator() throws IOException, InterruptedException {\n+        Mocker serverMock = new Mocker(authenticatorResponses);\n+        serverMock.start();\n+        try (var client = HttpClient.newBuilder()\n+                .version(java.net.http.HttpClient.Version.HTTP_1_1)\n+                .authenticator(new ServerAuth())\n+                .build()) {\n+\n+            \/\/ credentials set in the server authenticator\n+            var plainCreds = \"serverUser:serverPwd\";\n+            var encoded = java.util.Base64.getEncoder().encodeToString(plainCreds.getBytes(US_ASCII));\n+            var request = HttpRequest.newBuilder().uri(URI.create(serverMock.baseURL() + \"\/some_serv_url\"))\n+                .setHeader(\"User-Agent\", \"myUserAgent\")\n+                .build();\n+\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            assertEquals(data1, response.body());\n+\n+            var serverStr = serverMock.getRequest(1);\n+            assertContains(serverStr, \"\/some_serv_url\");\n+            assertPattern(\".*^User-Agent:.*myUserAgent.*\", serverStr);\n+            assertPattern(\".*^Authorization:.*Basic \" + encoded + \".*\", serverStr);\n+            System.out.println(\"testServerOnlyAuthenticator: OK\");\n+        } finally {\n+            serverMock.stopMocker();\n+        }\n+    }\n+\n+    static void close(Closeable... clarray) {\n+        for (Closeable c : clarray) {\n+            try {\n+                c.close();\n+            } catch (Exception e) {}\n+        }\n+    }\n+\n+    static class Mocker extends Thread {\n+        final ServerSocket ss;\n+        final String[] responses;\n+        volatile List<String> requests;\n+        volatile InputStream in;\n+        volatile OutputStream out;\n+        volatile Socket s = null;\n+\n+        public Mocker(String[] responses) throws IOException {\n+            this.ss = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+            this.responses = responses;\n+            this.requests = new LinkedList<>();\n+        }\n+\n+        public void stopMocker() {\n+            close(ss, s, in, out);\n+        }\n+\n+        public int getPort() {\n+            return ss.getLocalPort();\n+        }\n+\n+        public String baseURL() {\n+            try {\n+                return URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(getPort())\n+                    .build()\n+                    .toString();\n+            } catch (URISyntaxException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private String readRequest() throws IOException {\n+            String req = \"\";\n+            while (!req.endsWith(\"\\r\\n\\r\\n\")) {\n+                int x = in.read();\n+                if (x == -1) {\n+                    s.close();\n+                    s = ss.accept();\n+                    in = s.getInputStream();\n+                    out = s.getOutputStream();\n+                }\n+                req += (char)x;\n+            }\n+            return req;\n+        }\n+\n+        public String getRequest(int i) {\n+            return requests.get(i);\n+        }\n+\n+        public void run() {\n+            try {\n+                int index=0;\n+                s = ss.accept();\n+                in = s.getInputStream();\n+                out = s.getOutputStream();\n+                while (index < responses.length) {\n+                    requests.add(readRequest());\n+                    out.write(responses[index++].getBytes(US_ASCII));\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    static class ProxySel extends ProxySelector {\n+        final int port;\n+\n+        ProxySel(int port) {\n+            this.port = port;\n+        }\n+        @Override\n+        public List<Proxy> select(URI uri) {\n+          return List.of(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\n+              InetAddress.getLoopbackAddress(), port)));\n+        }\n+\n+        @Override\n+        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}\n+\n+    }\n+\n+    static class ProxyAuth extends Authenticator {\n+        private volatile boolean called = false;\n+\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            called = true;\n+            return new PasswordAuthentication(\"proxyUser\", \"proxyPwd\".toCharArray());\n+        }\n+\n+        boolean wasCalled() {\n+            return called;\n+        }\n+    }\n+\n+    static class ServerAuth extends Authenticator {\n+        private volatile boolean called = false;\n+\n+        @Override\n+        protected PasswordAuthentication getPasswordAuthentication() {\n+            called = true;\n+            if (getRequestorType() != RequestorType.SERVER) {\n+                \/\/ We only want to handle server authentication here\n+                return null;\n+            }\n+            return new PasswordAuthentication(\"serverUser\", \"serverPwd\".toCharArray());\n+        }\n+\n+        boolean wasCalled() {\n+            return called;\n+        }\n+    }\n+\n+    static void assertTrue(boolean assertion, String failMsg) {\n+        if (!assertion) {\n+            throw new RuntimeException(failMsg);\n+        }\n+    }\n+\n+    static void assertEquals(int a, int b) {\n+        if (a != b) {\n+            String msg = String.format(\"Error: expected %d Got %d\", a, b);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertEquals(String s1, String s2) {\n+        if (!s1.equals(s2)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", s1, s2);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertContains(String container, String containee) {\n+        if (!container.contains(containee)) {\n+            String msg = String.format(\"Error: expected %s Got %s\", container, containee);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    static void assertPattern(String pattern, String candidate) {\n+        Pattern pat = Pattern.compile(pattern, Pattern.DOTALL | Pattern.MULTILINE);\n+        Matcher matcher = pat.matcher(candidate);\n+        if (!matcher.matches()) {\n+            String msg = String.format(\"Error: expected %s Got %s\", pattern, candidate);\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/UserAuthWithAuthenticator.java","additions":503,"deletions":0,"binary":false,"changes":503,"status":"added"}]}