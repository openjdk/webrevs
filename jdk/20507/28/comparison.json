{"files":[{"patch":"@@ -560,0 +560,8 @@\n+#ifndef PRODUCT\n+bool Assembler::needs_evex(XMMRegister reg1, XMMRegister reg2, XMMRegister reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+#endif\n+\n@@ -3528,1 +3536,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3545,1 +3553,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3565,1 +3573,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3586,1 +3594,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3606,1 +3614,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3621,0 +3629,13 @@\n+void Assembler::evmovdquw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x6F, (0xC0 | encode));\n+}\n+\n+\n@@ -4813,0 +4834,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4820,1 +4842,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4832,1 +4855,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4845,0 +4869,9 @@\n+void Assembler::evpcmpub(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x3E, (0xC0 | encode), vcc);\n+}\n+\n@@ -4846,1 +4879,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4853,0 +4887,8 @@\n+void Assembler::evpcmpud(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1E, (0xC0 | encode), vcc);\n+}\n+\n@@ -4854,1 +4896,1 @@\n-  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4862,1 +4904,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4876,0 +4919,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4887,1 +4931,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -8340,0 +8385,155 @@\n+void Assembler::vpaddsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xEC, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xEC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpaddsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xED, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xED);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpaddusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDC, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n+void Assembler::vpaddusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDD, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n+void Assembler::vpsubsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE8, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE9, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD9, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n@@ -8369,7 +8569,0 @@\n-void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n-}\n-\n@@ -8552,8 +8745,0 @@\n-void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n-        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16(0xDA, (0xC0 | encode));\n-}\n-\n@@ -8705,15 +8890,6 @@\n-\/\/ Shift packed integers left by specified number of bits.\n-void Assembler::psllw(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n-}\n-\n-void Assembler::pslld(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDA, (0xC0 | encode));\n@@ -8722,6 +8898,9 @@\n-void Assembler::psllq(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDA);\n+  emit_operand(dst, src, 0);\n@@ -8730,5 +8909,10 @@\n-void Assembler::psllw(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n+void Assembler::evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDA, (0xC0 | encode));\n@@ -8737,5 +8921,13 @@\n-void Assembler::pslld(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF2, (0xC0 | encode));\n+void Assembler::evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDA);\n+  emit_operand(dst, src, 0);\n@@ -8744,6 +8936,6 @@\n-void Assembler::psllq(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_rex_vex_w_reverted();\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF3, (0xC0 | encode));\n+void Assembler::vpminuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3A, (0xC0 | encode));\n@@ -8752,2 +8944,4 @@\n-void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n+void Assembler::vpminuw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n@@ -8755,3 +8949,4 @@\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n-  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3A);\n+  emit_operand(dst, src, 0);\n@@ -8760,7 +8955,10 @@\n-void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n-  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+void Assembler::evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3A, (0xC0 | encode));\n@@ -8769,4 +8967,331 @@\n-void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_rex_vex_w_reverted();\n+void Assembler::evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3A);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpminud(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::vpminud(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDE, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxub(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDE);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDE, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDE);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3E, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxuw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3E, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxud(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"\");\n+  assert((vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxud(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0, \"\");\n+  assert((vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\/\/ Shift packed integers left by specified number of bits.\n+void Assembler::psllw(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::pslld(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::psllq(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::psllw(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n+}\n+\n+void Assembler::pslld(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF2, (0xC0 | encode));\n+}\n+\n+void Assembler::psllq(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF3, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n+  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n+  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n@@ -10408,0 +10933,217 @@\n+void Assembler::evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xEC, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xEC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xED, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xED);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDC, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDD, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE8, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE9, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD9, (0xC0 | encode));\n+}\n+\n+\n+void Assembler::evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD9);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":821,"deletions":79,"binary":false,"changes":900,"status":"modified"},{"patch":"@@ -783,0 +783,1 @@\n+  NOT_PRODUCT(bool needs_evex(XMMRegister reg1, XMMRegister reg2 = xnoreg, XMMRegister reg3 = xnoreg);)\n@@ -1996,0 +1997,2 @@\n+  void evpcmpub(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n+\n@@ -1999,0 +2002,1 @@\n+  void evpcmpud(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n@@ -2679,0 +2683,34 @@\n+  \/\/ Saturating packed insturctions.\n+  void vpaddsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void vpsubsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void vpaddsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void vpsubsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n@@ -2822,1 +2860,0 @@\n-  void vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2848,1 +2885,0 @@\n-  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n@@ -2872,0 +2908,32 @@\n+  \/\/ Unsigned maximum packed integers.\n+  void vpmaxub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxuw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxud(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxub(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpmaxuw(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpmaxud(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n+  \/\/ Unsigned minimum packed integers.\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminuw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminud(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminub(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpminuw(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpminud(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -939,0 +939,66 @@\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, Address src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vpuminmaxq(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  \/\/ T1 = -1\n+  vpcmpeqq(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  \/\/ T1 = -1 << 63\n+  vpsllq(xtmp1, xtmp1, 63, vlen_enc);\n+  \/\/ Convert SRC2 to signed value i.e. T2 = T1 + SRC2\n+  vpaddq(xtmp2, xtmp1, src2, vlen_enc);\n+  \/\/ Convert SRC1 to signed value i.e. T1 = T1 + SRC1\n+  vpaddq(xtmp1, xtmp1, src1, vlen_enc);\n+  \/\/ Mask = T2 > T1\n+  vpcmpgtq(xtmp1, xtmp2, xtmp1, vlen_enc);\n+  if (opcode == Op_UMaxV) {\n+    \/\/ Res = Mask ? Src2 : Src1\n+    vpblendvb(dst, src1, src2, xtmp1, vlen_enc);\n+  } else {\n+    \/\/ Res = Mask ? Src1 : Src2\n+    vpblendvb(dst, src2, src1, xtmp1, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n@@ -2362,0 +2428,4 @@\n+void C2_MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  MacroAssembler::evmovdqu(type, kmask, dst, src, merge, vector_len);\n+}\n+\n@@ -2660,1 +2730,0 @@\n-  assert(UseAVX >= 2, \"required\");\n@@ -4634,1 +4703,120 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               XMMRegister src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                      XMMRegister src1, XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                        XMMRegister src1, XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               Address src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                      XMMRegister src1, Address src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                        XMMRegister src1, Address src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n@@ -4724,0 +4912,4 @@\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4731,1 +4923,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -4784,0 +4977,4 @@\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4791,1 +4988,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -6479,0 +6677,363 @@\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_sub_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                              XMMRegister src2, KRegister ktmp, int vlen_enc) {\n+  \/\/ For unsigned subtraction, overflow happens when magnitude of second input is greater than first input.\n+  \/\/ overflow_mask = Inp1 <u Inp2\n+  evpcmpu(elem_bt, ktmp,  src2, src1, Assembler::lt, vlen_enc);\n+  \/\/ Res = overflow_mask ? Zero : INP1 - INP2 (non-commutative and non-associative)\n+  evmasked_op(elem_bt == T_INT ? Op_SubVI : Op_SubVL, elem_bt, ktmp, dst, src1, src2, false, vlen_enc, false);\n+}\n+\n+void C2_MacroAssembler::vector_sub_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                              XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  \/\/ Emulate unsigned comparison using signed comparison\n+  \/\/ Mask = Inp1 <u Inp2 => Inp1 + MIN_VALUE < Inp2 + MIN_VALUE\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc, true);\n+  vpadd(elem_bt, xtmp2, src1, xtmp1, vlen_enc);\n+  vpadd(elem_bt, xtmp1, src2, xtmp1, vlen_enc);\n+\n+  vpcmpgt(elem_bt, xtmp2, xtmp1, xtmp2, vlen_enc);\n+\n+  \/\/ Res = INP1 - INP2 (non-commutative and non-associative)\n+  vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ Res = Mask ? Zero : Res\n+  vpxor(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpblendvb(dst, dst, xtmp1, xtmp2, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::vector_add_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                               XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp, int vlen_enc) {\n+  \/\/ Unsigned values ranges comprise of only +ve numbers, thus there exist only an upper bound saturation.\n+  \/\/ overflow_mask = (SRC1 + SRC2) <u (SRC1 | SRC2)\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ T1 = SRC1 | SRC2\n+  vpor(xtmp1, src1, src2, vlen_enc);\n+  \/\/ Max_Unsigned = -1\n+  vpternlogd(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+  \/\/ Unsigned compare:  Mask = Res <u T1\n+  evpcmpu(elem_bt, ktmp, dst, xtmp1, Assembler::lt, vlen_enc);\n+  \/\/ res  = Mask ? Max_Unsigned : Res\n+  evpblend(elem_bt, dst, ktmp,  dst, xtmp2, true, vlen_enc);\n+}\n+\n+\/\/\n+\/\/ Section 2-13 Hacker's Delight list following overflow detection check for saturating\n+\/\/ unsigned addition operation.\n+\/\/    overflow_mask = ((a & b) | ((a | b) & ~( a + b))) >>> 31 == 1\n+\/\/\n+\/\/ We empirically determined its semantic equivalence to following reduced expression\n+\/\/    overflow_mask =  (a + b) <u (a | b)\n+\/\/\n+\/\/ and also verified it though Alive2 solver.\n+\/\/ (https:\/\/alive2.llvm.org\/ce\/z\/XDQ7dY)\n+\/\/\n+\n+void C2_MacroAssembler::vector_add_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                              XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, int vlen_enc) {\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ Compute T1 = INP1 | INP2\n+  vpor(xtmp3, src1, src2, vlen_enc);\n+  \/\/ T1 = Minimum signed value.\n+  vpgenmin_value(elem_bt, xtmp2, xtmp1, vlen_enc, true);\n+  \/\/ Convert T1 to signed value, T1 = T1 + MIN_VALUE\n+  vpadd(elem_bt, xtmp3, xtmp3, xtmp2, vlen_enc);\n+  \/\/ Convert Res to signed value, Res<s> = Res + MIN_VALUE\n+  vpadd(elem_bt, xtmp2, xtmp2, dst, vlen_enc);\n+  \/\/ Compute overflow detection mask = Res<1> <s T1\n+  if (elem_bt == T_INT) {\n+    vpcmpgtd(xtmp3, xtmp3, xtmp2, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_LONG, \"\");\n+    vpcmpgtq(xtmp3, xtmp3, xtmp2, vlen_enc);\n+  }\n+  vpblendvb(dst, dst, xtmp1, xtmp3, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovq2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogq(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    evpsraq(xtmp1, src, 63, vlen_enc);\n+    evpcmpeqq(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovd2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogd(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    vpsrad(xtmp1, src, 31, vlen_enc);\n+    Assembler::evpcmpeqd(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+\n+void C2_MacroAssembler::vpsign_extend_dq(BasicType elem_bt, XMMRegister dst, XMMRegister src, int vlen_enc) {\n+  if (elem_bt == T_LONG) {\n+    if (VM_Version::supports_evex()) {\n+      evpsraq(dst, src, 63, vlen_enc);\n+    } else {\n+      vpsrad(dst, src, 31, vlen_enc);\n+      vpshufd(dst, dst, 0xF5, vlen_enc);\n+    }\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpsrad(dst, src, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmax_value(BasicType elem_bt, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (elem_bt == T_LONG) {\n+    vpsrlq(dst, allones, 1, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpsrld(dst, allones, 1, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmin_value(BasicType elem_bt, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (elem_bt == T_LONG) {\n+    vpsllq(dst, allones, 63, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpslld(dst, allones, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpcmpu(BasicType elem_bt, KRegister kmask,  XMMRegister src1, XMMRegister src2,\n+                                Assembler::ComparisonPredicate cond, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_LONG:  evpcmpuq(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_INT:   evpcmpud(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_SHORT: evpcmpuw(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_BYTE:  evpcmpub(kmask, src1, src2, cond, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpgt(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case  T_LONG:  vpcmpgtq(dst, src1, src2, vlen_enc); break;\n+    case  T_INT:   vpcmpgtd(dst, src1, src2, vlen_enc); break;\n+    case  T_SHORT: vpcmpgtw(dst, src1, src2, vlen_enc); break;\n+    case  T_BYTE:  vpcmpgtb(dst, src1, src2, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmov_vec_to_mask(BasicType elem_bt, KRegister ktmp, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1) {\n+  if (elem_bt == T_LONG) {\n+    evpmovq2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    evpmovd2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_addsub_dq_saturating_evex(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                         XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                         KRegister ktmp1, KRegister ktmp2, int vlen_enc) {\n+  assert(elem_bt == T_INT || elem_bt == T_LONG, \"\");\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (ideal_opc == Op_SaturatingAddV) {\n+    \/\/ res = src1 + src2\n+    vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(ideal_opc == Op_SaturatingSubV, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Compute overflow detection mask.\n+  evpmov_vec_to_mask(elem_bt, ktmp1, xtmp2, xtmp2, xtmp1, vlen_enc);\n+  \/\/ Note: xtmp1 hold -1 in all its lanes after above call.\n+\n+  \/\/ Compute mask based on first input polarity.\n+  evpmov_vec_to_mask(elem_bt, ktmp2, src1, xtmp2, xtmp1, vlen_enc, true);\n+\n+  vpgenmax_value(elem_bt, xtmp2, xtmp1, vlen_enc, true);\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose a vector of saturating (MAX\/MIN) values, where lanes corresponding to\n+  \/\/ set bits in first input polarity mask holds a min value.\n+  evpblend(elem_bt, xtmp2, ktmp2, xtmp2, xtmp1, true, vlen_enc);\n+  \/\/ Blend destination lanes with saturated values using overflow detection mask.\n+  evpblend(elem_bt, dst, ktmp1, dst, xtmp2, true, vlen_enc);\n+}\n+\n+\n+void C2_MacroAssembler::vector_addsub_dq_saturating_avx(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                        XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                        XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc) {\n+  assert(elem_bt == T_INT || elem_bt == T_LONG, \"\");\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (ideal_opc == Op_SaturatingAddV) {\n+    \/\/ res = src1 + src2\n+    vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(ideal_opc == Op_SaturatingSubV, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Sign-extend to compute overflow detection mask.\n+  vpsign_extend_dq(elem_bt, xtmp3, xtmp2, vlen_enc);\n+\n+  vpcmpeqd(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpgenmax_value(elem_bt, xtmp2, xtmp1, vlen_enc);\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose saturating min\/max vector using first input polarity mask.\n+  vpsign_extend_dq(elem_bt, xtmp4, src1, vlen_enc);\n+  vpblendvb(xtmp1, xtmp2, xtmp1, xtmp4, vlen_enc);\n+\n+  \/\/ Blend result with saturating vector using overflow detection mask.\n+  vpblendvb(dst, dst, xtmp1, xtmp3, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n@@ -6505,0 +7066,16 @@\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    vector_saturating_unsigned_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  } else {\n+    vector_saturating_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    vector_saturating_unsigned_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  } else {\n+    vector_saturating_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":581,"deletions":4,"binary":false,"changes":585,"status":"modified"},{"patch":"@@ -59,0 +59,8 @@\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                int vlen_enc);\n+\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, Address src2,\n+                int vlen_enc);\n+\n@@ -63,0 +71,3 @@\n+\n+  void vpuminmaxq(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n@@ -108,0 +119,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -508,0 +520,64 @@\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void vector_saturating_unsigned_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void vector_saturating_unsigned_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void vector_sub_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, KRegister ktmp, int vlen_enc);\n+\n+  void vector_sub_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                             XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n+  void vector_add_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                              XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp, int vlen_enc);\n+\n+  void vector_add_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                             XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, int vlen_enc);\n+\n+  void vector_addsub_dq_saturating_avx(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc);\n+\n+  void vector_addsub_dq_saturating_evex(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                        XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, int vlen_enc);\n+\n+  void evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void vpsign_extend_dq(BasicType etype, XMMRegister dst, XMMRegister src, int vlen_enc);\n+\n+  void vpgenmin_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void vpgenmax_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void evpcmpu(BasicType etype, KRegister kmask,  XMMRegister src1, XMMRegister src2, Assembler::ComparisonPredicate cond, int vlen_enc);\n+\n+  void vpcmpgt(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void evpmov_vec_to_mask(BasicType etype, KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                          int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       XMMRegister src2, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       Address src2, bool merge, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -9306,0 +9306,24 @@\n+void MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evmovdqub(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evmovdquw(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evmovdqul(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evmovdquq(dst, kmask, src, merge, vector_len);\n+      break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type));\n+      break;\n+  }\n+}\n+\n@@ -9497,0 +9521,60 @@\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1281,0 +1281,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -1587,0 +1588,5 @@\n+\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1768,0 +1768,6 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+      if (UseAVX == 0) {\n+        return false;\n+      }\n+      break;\n@@ -1938,0 +1944,9 @@\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (UseAVX < 1) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      if (is_subword_type(bt) && size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n@@ -2128,0 +2143,2 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n@@ -2135,0 +2152,9 @@\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (!is_subword_type(bt)) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 || !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n@@ -6494,0 +6520,74 @@\n+\/\/ ------------------------------ Unsigned vector Min\/Max ----------------------\n+\n+instruct vector_uminmax_reg(vec dst, vec a, vec b) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_LONG);\n+  match(Set dst (UMinV a b));\n+  match(Set dst (UMaxV a b));\n+  format %{ \"vector_uminmax $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_mem(vec dst, vec a, memory b) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_LONG);\n+  match(Set dst (UMinV a (LoadVector b)));\n+  match(Set dst (UMaxV a (LoadVector b)));\n+  format %{ \"vector_uminmax $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmaxq_reg(vec dst, vec a, vec b, vec xtmp1, vec xtmp2) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (UMinV a b));\n+  match(Set dst (UMaxV a b));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_uminmaxq $dst,$a,$b\\t! using xtmp1 and xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpuminmaxq(opcode, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_reg_masked(vec dst, vec src1, vec src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 src2) mask));\n+  match(Set dst (UMaxV (Binary src1 src2) mask));\n+  format %{ \"vector_uminmax_masked $dst, $src1, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_mem_masked(vec dst, vec src1, memory src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 (LoadVector src2)) mask));\n+  match(Set dst (UMaxV (Binary src1 (LoadVector src2)) mask));\n+  format %{ \"vector_uminmax_masked $dst, $dst, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $src1$$XMMRegister, $src2$$Address, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10486,0 +10586,230 @@\n+instruct vector_saturating_subword_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  format %{ \"vector_saturating_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$XMMRegister, false, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_unsigned_subword_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  format %{ \"vector_saturating_unsigned_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2);\n+  format %{ \"vector_saturating_evex $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_addsub_dq_saturating_evex(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                                        $src1$$XMMRegister, $src2$$XMMRegister,\n+                                        $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                                        $ktmp1$$KRegister, $ktmp2$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4);\n+  format %{ \"vector_saturating_avx $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_addsub_dq_saturating_avx(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister, $src1$$XMMRegister,\n+                                       $src2$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                                       $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_add_saturating_unsigned_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, kReg ktmp)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp);\n+  format %{ \"vector_add_saturating_unsigned_evex $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2 and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_add_dq_saturating_unsigned_evex(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                              $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_add_saturating_unsigned_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3);\n+  format %{ \"vector_add_saturating_unsigned_avx $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2 and $xtmp3 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_add_dq_saturating_unsigned_avx(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sub_saturating_unsigned_reg_evex(vec dst, vec src1, vec src2, kReg ktmp)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP ktmp);\n+  format %{ \"vector_sub_saturating_unsigned_evex $dst, $src1, $src2 \\t! using $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_sub_dq_saturating_unsigned_evex(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister,\n+                                              $src2$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sub_saturating_unsigned_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_sub_saturating_unsigned_avx $dst, $src1, $src2 \\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_sub_dq_saturating_unsigned_avx(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_subword_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubV src1 (LoadVector src2)));\n+  format %{ \"vector_saturating_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$Address, false, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_unsigned_subword_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubV src1 (LoadVector src2)));\n+  format %{ \"vector_saturating_unsigned_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$Address, true, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_subword_masked_reg(vec dst, vec src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst src) mask));\n+  match(Set dst (SaturatingSubV (Binary dst src) mask));\n+  format %{ \"vector_saturating_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$XMMRegister, false, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_saturating_unsigned_subword_masked_reg(vec dst, vec src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst src) mask));\n+  match(Set dst (SaturatingSubV (Binary dst src) mask));\n+  format %{ \"vector_saturating_unsigned_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$XMMRegister, true, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_saturating_subword_masked_mem(vec dst, memory src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubV (Binary dst (LoadVector src)) mask));\n+  format %{ \"vector_saturating_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$Address, false, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_saturating_unsigned_subword_masked_mem(vec dst, memory src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubV (Binary dst (LoadVector src)) mask));\n+  format %{ \"vector_saturating_unsigned_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$Address, true, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":330,"deletions":0,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -3960,2 +3960,2 @@\n-    \"OrI\",\"OrL\",\n-    \"XorI\",\"XorL\"\n+    \"OrI\",\"OrL\", \"XorI\",\"XorL\",\n+    \"UMax\",\"UMin\"\n@@ -3968,1 +3968,1 @@\n-    \"MaxV\", \"MinV\"\n+    \"MaxV\", \"MinV\", \"UMax\",\"UMin\"\n@@ -4342,1 +4342,1 @@\n-    \"MaxV\", \"MinV\",\n+    \"MaxV\", \"MinV\", \"UMinV\", \"UMaxV\",\n@@ -4365,1 +4365,1 @@\n-    \"CountLeadingZerosV\", \"CountTrailingZerosV\", \"SignumVF\", \"SignumVD\",\n+    \"CountLeadingZerosV\", \"CountTrailingZerosV\", \"SignumVF\", \"SignumVD\", \"SaturatingAddV\", \"SaturatingSubV\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -332,0 +332,2 @@\n+macro(SaturatingAddV)\n+macro(SaturatingSubV)\n@@ -438,0 +440,2 @@\n+macro(UMinV)\n+macro(UMaxV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+class SaturatingVectorNode;\n@@ -743,0 +744,1 @@\n+        DEFINE_CLASS_ID(SaturatingVector, Vector, 9)\n@@ -1010,0 +1012,1 @@\n+  DEFINE_CLASS_QUERY(SaturatingVector)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -368,0 +368,3 @@\n+  bool has_scalar_op = VectorSupport::has_scalar_op(opr->get_con());\n+  bool is_unsigned = VectorSupport::is_unsigned_op(opr->get_con());\n+\n@@ -370,1 +373,1 @@\n-  int sopc = VectorNode::opcode(opc, elem_bt);\n+  int sopc = has_scalar_op ? VectorNode::opcode(opc, elem_bt) : opc;\n@@ -484,1 +487,1 @@\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc));\n+        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc), is_unsigned);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -670,1 +670,1 @@\n-VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift) {\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift, bool is_unsigned) {\n@@ -742,0 +742,3 @@\n+  case Op_UMinV: return new UMinVNode(n1, n2, vt);\n+  case Op_UMaxV: return new UMaxVNode(n1, n2, vt);\n+\n@@ -762,0 +765,4 @@\n+\n+  case Op_SaturatingAddV: return new SaturatingAddVNode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingSubV: return new SaturatingSubVNode(n1, n2, vt, is_unsigned);\n+\n@@ -2082,0 +2089,43 @@\n+Node* UMinVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  bool match1 = in(1)->Opcode() == Op_UMinV || in(1)->Opcode() == Op_UMaxV;\n+  bool match2 = in(2)->Opcode() == Op_UMinV || in(2)->Opcode() == Op_UMaxV;\n+  \/\/ UMin (UMin(a, b), UMax(a, b))  => UMin(a, b)\n+  \/\/ UMin (UMin(a, b), UMax(b, a))  => UMin(a, b)\n+  if (match1 && match2) {\n+    if ((in(1)->in(1) == in(2)->in(1) && in(1)->in(2) == in(2)->in(2)) ||\n+         (in(1)->in(2) == in(2)->in(1) && in(1)->in(1) == in(2)->in(2))) {\n+      return new UMinVNode(in(1)->in(1), in(1)->in(2), vect_type());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+Node* UMinVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMin (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* UMaxVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  bool match1 = in(1)->Opcode() == Op_UMinV || in(1)->Opcode() == Op_UMaxV;\n+  bool match2 = in(2)->Opcode() == Op_UMinV || in(2)->Opcode() == Op_UMaxV;\n+  \/\/ UMax (UMin(a, b), UMax(a, b))  => UMax(a, b)\n+  \/\/ UMax (UMin(a, b), UMax(b, a))  => UMax(a, b)\n+  if (match1 && match2) {\n+    if ((in(1)->in(1) == in(2)->in(1) && in(1)->in(2) == in(2)->in(2)) ||\n+         (in(1)->in(2) == in(2)->in(1) && in(1)->in(1) == in(2)->in(2))) {\n+      return new UMaxVNode(in(1)->in(1), in(1)->in(2), vect_type());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+Node* UMaxVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMax (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n@@ -2087,1 +2137,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false, bool is_unsigned = false);\n@@ -147,0 +147,26 @@\n+\/\/ Base IR node for saturating signed \/ unsigned operations.\n+\/\/ Saturating operation prevents wrapping result value in over\/underflowing\n+\/\/ scenarios, instead returns delimiting MAX\/MIN value of result type.\n+class SaturatingVectorNode : public VectorNode {\n+ private:\n+  const bool _is_unsigned;\n+\n+ public:\n+  SaturatingVectorNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : VectorNode(in1, in2, vt), _is_unsigned(is_unsigned) {\n+    init_class_id(Class_SaturatingVector);\n+  }\n+\n+  \/\/ Needed for proper cloning.\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+#ifndef PRODUCT\n+  \/\/ Print node specific info\n+  virtual void dump_spec(outputStream *st) const {\n+    TypeNode::dump_spec(st);\n+    st->print(\"%s\", _is_unsigned ? \"{unsigned_vector_node}\" : \"{signed_vector_node}\");\n+  }\n+#endif\n+  virtual uint hash() const { return Node::hash() + _is_unsigned; }\n+\n+  bool is_unsigned() { return _is_unsigned; }\n+};\n@@ -358,0 +384,16 @@\n+\/\/------------------------------SaturatingAddVNode-----------------------------\n+\/\/ Vector saturating addition.\n+class SaturatingAddVNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------SaturatingSubVNode-----------------------------\n+\/\/ Vector saturating subtraction.\n+class SaturatingSubVNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingSubVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -564,0 +606,10 @@\n+class UMinVNode : public VectorNode {\n+ public:\n+  UMinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2 ,vt) {\n+    assert(is_integral_type(vt->element_basic_type()), \"\");\n+  }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual int Opcode() const;\n+};\n+\n@@ -572,0 +624,10 @@\n+class UMaxVNode : public VectorNode {\n+ public:\n+  UMaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    assert(is_integral_type(vt->element_basic_type()), \"\");\n+  }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -202,0 +202,30 @@\n+bool VectorSupport::has_scalar_op(jint id) {\n+  VectorOperation vop = (VectorOperation)id;\n+  switch (vop) {\n+    case VECTOR_OP_COMPRESS:\n+    case VECTOR_OP_EXPAND:\n+    case VECTOR_OP_SADD:\n+    case VECTOR_OP_SUADD:\n+    case VECTOR_OP_SSUB:\n+    case VECTOR_OP_SUSUB:\n+    case VECTOR_OP_UMIN:\n+    case VECTOR_OP_UMAX:\n+      return false;\n+    default:\n+      return true;\n+  }\n+}\n+\n+bool VectorSupport::is_unsigned_op(jint id) {\n+  VectorOperation vop = (VectorOperation)id;\n+  switch (vop) {\n+    case VECTOR_OP_SUADD:\n+    case VECTOR_OP_SUSUB:\n+    case VECTOR_OP_UMIN:\n+    case VECTOR_OP_UMAX:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -277,0 +307,20 @@\n+    case VECTOR_OP_UMIN: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+        case T_LONG:   return Op_UMinV;\n+        default: fatal(\"MIN: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_UMAX: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+        case T_LONG:   return Op_UMaxV;\n+        default: fatal(\"MAX: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n@@ -536,0 +586,22 @@\n+    case VECTOR_OP_SADD:\n+    case VECTOR_OP_SUADD: {\n+      switch(bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:   return Op_SaturatingAddV;\n+        default: fatal(\"S[U]ADD: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_SSUB:\n+    case VECTOR_OP_SUSUB: {\n+      switch(bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:   return Op_SaturatingSubV;\n+        default: fatal(\"S[U}SUB: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -124,0 +124,7 @@\n+    VECTOR_OP_SADD  = 119,\n+    VECTOR_OP_SSUB  = 120,\n+    VECTOR_OP_SUADD = 121,\n+    VECTOR_OP_SUSUB = 122,\n+    VECTOR_OP_UMIN  = 123,\n+    VECTOR_OP_UMAX  = 124,\n+\n@@ -146,0 +153,2 @@\n+  static bool has_scalar_op(jint id);\n+  static bool is_unsigned_op(jint id);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -117,0 +117,7 @@\n+    public static final int VECTOR_OP_SADD  = 119;\n+    public static final int VECTOR_OP_SSUB  = 120;\n+    public static final int VECTOR_OP_SUADD = 121;\n+    public static final int VECTOR_OP_SUSUB = 122;\n+    public static final int VECTOR_OP_UMIN  = 123;\n+    public static final int VECTOR_OP_UMAX  = 124;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -887,0 +887,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)VectorMath.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)VectorMath.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMath.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMath.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMath.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMath.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -887,0 +887,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)VectorMath.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)VectorMath.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMath.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMath.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMath.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMath.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -845,0 +845,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)VectorMath.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)VectorMath.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMath.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMath.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMath.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMath.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -887,0 +887,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)VectorMath.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)VectorMath.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMath.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMath.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMath.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMath.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,586 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+\/**\n+ * The class {@code VectorMath} contains methods for performing\n+ * scalar numeric operations in support of vector numeric operations.\n+ * @since   24\n+ *\/\n+public final class VectorMath {\n+\n+    private VectorMath() {\n+    }\n+\n+    \/**\n+     * Returns the smaller of two {@code long} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0L}. If the operands have the\n+     * same value, the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the smaller of {@code a} and {@code b}.\n+     * @see VectorOperators#UMIN\n+     *\/\n+    public static long minUnsigned(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Returns the greater of two {@code long} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0xFFFFFFFF_FFFFFFFFL} numerically\n+     * treating it as unsigned. If the operands have the same value,\n+     * the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the larger of {@code a} and {@code b}.\n+     * @see VectorOperators#UMAX\n+     *\/\n+    public static long maxUnsigned(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Adds two {@code long} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Long.MIN_VALUE} and {@code Long.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the addition would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Long.MAX_VALUE}.\n+     * If the result of the addition would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Long.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SADD\n+     *\/\n+    public static long addSaturating(long a, long b) {\n+        long res = a + b;\n+        \/\/ HD 2-12 Overflow iff both arguments have the opposite sign of the result\n+        if (((a ^ res) & (b ^ res)) < 0) {\n+            return res < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code long} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Long.MIN_VALUE} and {@code Long.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the subtraction would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Long.MAX_VALUE}.\n+     * If the result of the subtraction would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Long.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SSUB\n+     *\/\n+    public static long subSaturating(long a, long b) {\n+        long res = a - b;\n+        \/\/ HD 2-12 Overflow iff the arguments have different signs and\n+        \/\/ the sign of the result is different from the sign of a\n+        if (((a ^ b) & (a ^ res)) < 0) {\n+            return a < 0 ? Long.MIN_VALUE : Long.MAX_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Adds two {@code long} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0L} and {@code 0xFFFFFFFF_FFFFFFFFL}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned addition would otherwise overflow\n+     * from the greater of the two operands to a lesser value then the\n+     * result is clamped to the upper bound {@code 0xFFFFFFFF_FFFFFFFFL}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SUADD\n+     *\/\n+    public static long addSaturatingUnsigned(long a, long b) {\n+        long res = a + b;\n+        boolean overflow = Long.compareUnsigned(res, (a | b)) < 0;\n+        if (overflow) {\n+           return -1L;\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code long} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0L} and {@code 0xFFFFFFFF_FFFFFFFFL}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned subtraction would otherwise underflow\n+     * from the lesser of the two operands to a greater value then the\n+     * result is clamped to the lower bound {@code 0L}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SUSUB\n+     *\/\n+    public static long subSaturatingUnsigned(long a, long b) {\n+        if (Long.compareUnsigned(b, a) < 0) {\n+           return a - b;\n+        } else {\n+           return 0;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Returns the smaller of two {@code int} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0}. If the operands have the\n+     * same value, the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the smaller of {@code a} and {@code b}.\n+     * @see VectorOperators#UMIN\n+     *\/\n+    public static int minUnsigned(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Returns the greater of two {@code int} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0xFFFFFFFF} numerically\n+     * treating it as unsigned. If the operands have the same value,\n+     * the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the larger of {@code a} and {@code b}.\n+     * @see VectorOperators#UMAX\n+     *\/\n+    public static int maxUnsigned(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Adds two {@code int} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Integer.MIN_VALUE} and {@code Integer.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the addition would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Integer.MAX_VALUE}.\n+     * If the result of the addition would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Integer.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SADD\n+     *\/\n+    public static int addSaturating(int a, int b) {\n+        long res = (long)a + (long)b;\n+        if (res > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        } else if (res < Integer.MIN_VALUE) {\n+            return Integer.MIN_VALUE;\n+        } else {\n+            return (int)res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code int} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Integer.MIN_VALUE} and {@code Integer.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the subtraction would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Integer.MAX_VALUE}.\n+     * If the result of the subtraction would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Integer.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SSUB\n+     *\/\n+    public static int subSaturating(int a, int b) {\n+        long res = (long)a - (long)b;\n+        if (res > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        } else if (res < Integer.MIN_VALUE) {\n+            return Integer.MIN_VALUE;\n+        } else {\n+            return (int)res;\n+        }\n+    }\n+\n+    \/**\n+     * Adds two {@code int} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0} and {@code 0xFFFFFFFF}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned addition would otherwise overflow\n+     * from the greater of the two operands to a lesser value then the\n+     * result is clamped to the upper bound {@code 0xFFFFFFFF}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SUADD\n+     *\/\n+    public static int addSaturatingUnsigned(int a, int b) {\n+        int res = a + b;\n+        boolean overflow = Integer.compareUnsigned(res, (a | b)) < 0;\n+        if (overflow)  {\n+            return -1;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code int} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0} and {@code -0xFFFFFFFF}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned subtraction would otherwise underflow\n+     * from the lesser of the two operands to a greater value then the\n+     * result is clamped to the lower bound {@code 0}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SUSUB\n+     *\/\n+    public static int subSaturatingUnsigned(int a, int b) {\n+        if (Integer.compareUnsigned(b, a) < 0) {\n+            return a - b;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Returns the smaller of two {@code short} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0}. If the operands have the\n+     * same value, the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the smaller of {@code a} and {@code b}.\n+     * @see VectorOperators#UMIN\n+     *\/\n+    public static short minUnsigned(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Returns the greater of two {@code short} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0xFFFF} numerically\n+     * treating it as unsigned. If the operands have the same value,\n+     * the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the larger of {@code a} and {@code b}.\n+     * @see VectorOperators#UMAX\n+     *\/\n+    public static short maxUnsigned(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Adds two {@code short} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Short.MIN_VALUE} and {@code Short.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the addition would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Short.MAX_VALUE}.\n+     * If the result of the addition would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Short.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SADD\n+     *\/\n+    public static short addSaturating(short a, short b) {\n+        int res = a + b;\n+        if (res > Short.MAX_VALUE) {\n+            return Short.MAX_VALUE;\n+        } else if (res < Short.MIN_VALUE) {\n+            return Short.MIN_VALUE;\n+        } else {\n+            return (short)res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code short} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Short.MIN_VALUE} and {@code Short.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the subtraction would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Short.MAX_VALUE}.\n+     * If the result of the subtraction would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Short.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SSUB\n+     *\/\n+    public static short subSaturating(short a, short b) {\n+        int res = a - b;\n+        if (res > Short.MAX_VALUE) {\n+            return Short.MAX_VALUE;\n+        } else if (res < Short.MIN_VALUE) {\n+            return Short.MIN_VALUE;\n+        } else {\n+            return (short)res;\n+        }\n+    }\n+\n+    \/**\n+     * Adds two {@code short} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0} and {@code 0xFFFF}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned addition would otherwise overflow\n+     * from the greater of the two operands to a lesser value then the\n+     * result is clamped to the upper bound {@code 0xFFFF}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SUADD\n+     *\/\n+    public static short addSaturatingUnsigned(short a, short b) {\n+        short res = (short)(a + b);\n+        boolean overflow = Short.compareUnsigned(res, (short)(a | b)) < 0;\n+        if (overflow) {\n+           return (short)(-1);\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code short} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0} and {@code 0xFFFF}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned subtraction would otherwise underflow\n+     * from the lesser of the two operands to a greater value then the\n+     * result is clamped to the lower bound {@code 0}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SUSUB\n+     *\/\n+    public static short subSaturatingUnsigned(short a, short b) {\n+        if (Short.compareUnsigned(b, a) < 0) {\n+            return (short)(a - b);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Returns the smaller of two {@code byte} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0}. If the operands have the\n+     * same value, the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the smaller of {@code a} and {@code b}.\n+     * @see VectorOperators#UMIN\n+     *\/\n+    public static byte minUnsigned(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Returns the greater of two {@code byte} values numerically treating\n+     * the values as unsigned. That is, the result is the operand closer\n+     * to the value of the expression {@code 0xFF} numerically\n+     * treating it as unsigned. If the operands have the same value,\n+     * the result is that same value.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the larger of {@code a} and {@code b}.\n+     * @see VectorOperators#UMAX\n+     *\/\n+    public static byte maxUnsigned(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Adds two {@code byte} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Byte.MIN_VALUE} and {@code Byte.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the addition would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Byte.MAX_VALUE}.\n+     * If the result of the addition would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Byte.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SADD\n+     *\/\n+    public static byte addSaturating(byte a, byte b) {\n+        int res = a + b;\n+        if (res > Byte.MAX_VALUE) {\n+            return Byte.MAX_VALUE;\n+        } else if (res < Byte.MIN_VALUE) {\n+            return Byte.MIN_VALUE;\n+        } else {\n+           return (byte)res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code byte} values using saturation\n+     * arithemetic. The lower and upper (inclusive) bounds are\n+     * {@code Byte.MIN_VALUE} and {@code Byte.MAX_VALUE}, respectively.\n+     * <p>\n+     * If the result of the subtraction would otherwise overflow from\n+     * a positive value to a negative value then the result is clamped\n+     * to the upper bound {@code Byte.MAX_VALUE}.\n+     * If the result of the subtraction would otherwise underflow from\n+     * a negative value to a positive value then the result is clamped\n+     * to lower bound {@code Byte.MIN_VALUE}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SSUB\n+     *\/\n+    public static byte subSaturating(byte a, byte b) {\n+        int res = a - b;\n+        if (res > Byte.MAX_VALUE) {\n+            return Byte.MAX_VALUE;\n+        } else if (res < Byte.MIN_VALUE) {\n+            return Byte.MIN_VALUE;\n+        } else {\n+            return (byte)res;\n+        }\n+    }\n+\n+    \/**\n+     * Adds two {@code byte} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0} and {@code 0xFF}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned addition would otherwise overflow\n+     * from the greater of the two operands to a lesser value then the\n+     * result is clamped to the upper bound {@code 0xFF}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating addition of the operands.\n+     * @see VectorOperators#SUADD\n+     *\/\n+    public static byte addSaturatingUnsigned(byte a, byte b) {\n+        byte res = (byte)(a + b);\n+        boolean overflow = Byte.compareUnsigned(res, (byte)(a | b)) < 0;\n+        if (overflow) {\n+           return (byte)(-1);\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Subtracts two {@code byte} values using saturation\n+     * arithemetic and numerically treating the values\n+     * as unsigned. The lower and upper (inclusive) bounds\n+     * are {@code 0} and {@code 0xFF}, respectively,\n+     * numerically treating them as unsigned.\n+     * <p>\n+     * If the result of the unsigned subtraction would otherwise underflow\n+     * from the lesser of the two operands to a greater value then the\n+     * result is clamped to the lower bound {@code 0}.\n+     *\n+     * @param a the first operand.\n+     * @param b the second operand.\n+     * @return the saturating difference of the operands.\n+     * @see VectorOperators#SUSUB\n+     *\/\n+   public static byte subSaturatingUnsigned(byte a, byte b) {\n+        if (Byte.compareUnsigned(b, a) < 0) {\n+            return (byte)(a - b);\n+        } else {\n+            return 0;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMath.java","additions":586,"deletions":0,"binary":false,"changes":586,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,0 +570,26 @@\n+    \/** Produce saturating {@code a+b}.  Integral only.\n+     * @see VectorMath#addSaturating(int, int)\n+     *\/\n+    public static final Binary SADD = binary(\"SADD\", \"+\", VectorSupport.VECTOR_OP_SADD, VO_NOFP);\n+    \/** Produce saturating unsigned {@code a+b}.  Integral only.\n+     * @see VectorMath#addSaturatingUnsigned(int, int)\n+     *\/\n+    public static final Binary SUADD = binary(\"SUADD\", \"+\", VectorSupport.VECTOR_OP_SUADD, VO_NOFP);\n+    \/** Produce saturating {@code a-b}.  Integral only.\n+     * @see VectorMath#subSaturating(int, int)\n+     *\/\n+    public static final Binary SSUB = binary(\"SSUB\", \"-\", VectorSupport.VECTOR_OP_SSUB, VO_NOFP);\n+    \/** Produce saturating unsigned {@code a-b}.  Integral only.\n+     * @see VectorMath#subSaturatingUnsigned(int, int)\n+     *\/\n+    public static final Binary SUSUB = binary(\"SUSUB\", \"-\", VectorSupport.VECTOR_OP_SUSUB, VO_NOFP);\n+    \/** Produce unsigned {@code min(a,b)}.  Integral only.\n+     * @see VectorMath#minUnsigned(int, int) (int, int)\n+     *\/\n+    public static final Associative UMIN = assoc(\"UMIN\", \"umin\", VectorSupport.VECTOR_OP_UMIN, VO_NOFP+VO_ASSOC);\n+    \/** Produce unsigned {@code max(a,b)}.  Integral only.\n+     * @see VectorMath#maxUnsigned(int, int) (int, int)\n+     *\/\n+    public static final Associative UMAX = assoc(\"UMAX\", \"umax\", VectorSupport.VECTOR_OP_UMAX, VO_NOFP+VO_ASSOC);\n+\n+\n@@ -639,1 +665,1 @@\n-    public static final Comparison UNSIGNED_LT = compare(\"UNSIGNED_LT\", \"<\",  VectorSupport.BT_ult, VO_NOFP);\n+    public static final Comparison ULT = compare(\"ULT\", \"<\",  VectorSupport.BT_ult, VO_NOFP);\n@@ -644,1 +670,1 @@\n-    public static final Comparison UNSIGNED_LE = compare(\"UNSIGNED_LE\", \"<=\", VectorSupport.BT_ule, VO_NOFP);\n+    public static final Comparison ULE = compare(\"ULE\", \"<=\", VectorSupport.BT_ule, VO_NOFP);\n@@ -649,1 +675,1 @@\n-    public static final Comparison UNSIGNED_GT = compare(\"UNSIGNED_GT\", \">\",  VectorSupport.BT_ugt, VO_NOFP);\n+    public static final Comparison UGT = compare(\"UGT\", \">\",  VectorSupport.BT_ugt, VO_NOFP);\n@@ -654,1 +680,1 @@\n-    public static final Comparison UNSIGNED_GE = compare(\"UNSIGNED_GE\", \">=\", VectorSupport.BT_uge, VO_NOFP);\n+    public static final Comparison UGE = compare(\"UGE\", \">=\", VectorSupport.BT_uge, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -983,0 +983,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)VectorMath.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)VectorMath.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMath.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMath.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMath.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMath.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1111,0 +1111,40 @@\n+    public static final String UMIN_VB = VECTOR_PREFIX + \"UMIN_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VB, \"UMinV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMIN_VS = VECTOR_PREFIX + \"UMIN_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VS, \"UMinV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMIN_VI = VECTOR_PREFIX + \"UMIN_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VI, \"UMinV\", TYPE_INT);\n+    }\n+\n+    public static final String UMIN_VL = VECTOR_PREFIX + \"UMIN_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VL, \"UMinV\", TYPE_LONG);\n+    }\n+\n+    public static final String UMAX_VB = VECTOR_PREFIX + \"UMAX_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VB, \"UMaxV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMAX_VS = VECTOR_PREFIX + \"UMAX_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VS, \"UMaxV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMAX_VI = VECTOR_PREFIX + \"UMAX_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VI, \"UMaxV\", TYPE_INT);\n+    }\n+\n+    public static final String UMAX_VL = VECTOR_PREFIX + \"UMAX_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VL, \"UMaxV\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GT, 64).intoArray(br, 0);\n+        av.compare(VectorOperators.UGT, 64).intoArray(br, 0);\n@@ -166,1 +166,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GT, -91).intoArray(br, 0);\n+        av.compare(VectorOperators.UGT, -91).intoArray(br, 0);\n@@ -186,1 +186,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GE, 56).intoArray(sr, 0);\n+        av.compare(VectorOperators.UGE, 56).intoArray(sr, 0);\n@@ -206,1 +206,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GE, -85).intoArray(sr, 0);\n+        av.compare(VectorOperators.UGE, -85).intoArray(sr, 0);\n@@ -226,1 +226,1 @@\n-        av.compare(VectorOperators.UNSIGNED_LT, 101).intoArray(ir, 0);\n+        av.compare(VectorOperators.ULT, 101).intoArray(ir, 0);\n@@ -246,1 +246,1 @@\n-        av.compare(VectorOperators.UNSIGNED_LT, -110).intoArray(ir, 0);\n+        av.compare(VectorOperators.ULT, -110).intoArray(ir, 0);\n@@ -266,1 +266,1 @@\n-        av.compare(VectorOperators.UNSIGNED_LE, 95).intoArray(lr, 0);\n+        av.compare(VectorOperators.ULE, 95).intoArray(lr, 0);\n@@ -286,1 +286,1 @@\n-        av.compare(VectorOperators.UNSIGNED_LE, -99).intoArray(lr, 0);\n+        av.compare(VectorOperators.ULE, -99).intoArray(lr, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompareWithImmTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GT, 0).intoArray(ir, 0);\n+        av.compare(VectorOperators.UGT, 0).intoArray(ir, 0);\n@@ -250,1 +250,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GE, 0).intoArray(lr, 0);\n+        av.compare(VectorOperators.UGE, 0).intoArray(lr, 0);\n@@ -260,1 +260,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompareWithZeroTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,507 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8338201\n+* @summary Validate IR Transforms for new unsigned min\/max vector operations\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorUnsignedMinMaxIRTransformsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.stream.IntStream;\n+\n+public class VectorUnsignedMinMaxIRTransformsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public VectorUnsignedMinMaxIRTransformsTest() {\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT).forEach(\n+            i -> {\n+                if ((i & 1) == 0) {\n+                    long_in1[i] = Long.MAX_VALUE;\n+                    long_in2[i] = i;\n+                    int_in1[i]  = Integer.MAX_VALUE;\n+                    int_in2[i]  = i;\n+                    short_in1[i] = Short.MAX_VALUE;\n+                    short_in2[i] = (short)i;\n+                    byte_in1[i]  = Byte.MAX_VALUE;\n+                    byte_in2[i]  = (byte)i;\n+                } else {\n+                    long_in1[i] = Long.MIN_VALUE;\n+                    long_in2[i] = -i;\n+                    int_in1[i]  = Integer.MIN_VALUE;\n+                    int_in2[i]  = -i;\n+                    short_in1[i] = Short.MIN_VALUE;\n+                    short_in2[i] = (short)-i;\n+                    byte_in1[i]  = Byte.MIN_VALUE;\n+                    byte_in2[i]  = (byte)-i;\n+                }\n+            }\n+        );\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VB, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               ByteVector.fromArray(bspec, byte_in1, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_byte\")\n+    public void umin_ir_transform1_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.minUnsigned(byte_in1[i], byte_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VB, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               ByteVector.fromArray(bspec, byte_in1, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_byte\")\n+    public void umax_ir_transform1_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.maxUnsigned(byte_in1[i], byte_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VB, \" 0 \", IRNode.UMIN_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector vec1 = ByteVector.fromArray(bspec, byte_in1, i);\n+            ByteVector vec2 = ByteVector.fromArray(bspec, byte_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_byte\")\n+    public void umin_umax_ir_transform1_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = byte_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(byte_in1[i], byte_in2[i]),\n+                                                  VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VB, \" 0 \", IRNode.UMAX_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector vec1 = ByteVector.fromArray(bspec, byte_in1, i);\n+            ByteVector vec2 = ByteVector.fromArray(bspec, byte_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_byte\")\n+    public void umin_umax_ir_transform2_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(byte_in1[i], byte_in2[i]),\n+                                                   VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VS, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               ShortVector.fromArray(sspec, short_in1, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_short\")\n+    public void umin_ir_transform1_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.minUnsigned(short_in1[i], short_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VS, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               ShortVector.fromArray(sspec, short_in1, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_short\")\n+    public void umax_ir_transform1_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.maxUnsigned(short_in1[i], short_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VS, \" 0 \", IRNode.UMIN_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector vec1 = ShortVector.fromArray(sspec, short_in1, i);\n+            ShortVector vec2 = ShortVector.fromArray(sspec, short_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_short\")\n+    public void umin_umax_ir_transform1_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.minUnsigned(VectorMath.minUnsigned(short_in1[i], short_in2[i]),\n+                                                    VectorMath.maxUnsigned(short_in1[i], short_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VS, \" 0 \", IRNode.UMAX_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector vec1 = ShortVector.fromArray(sspec, short_in1, i);\n+            ShortVector vec2 = ShortVector.fromArray(sspec, short_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_short\")\n+    public void umin_umax_ir_transform2_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(short_in1[i], short_in2[i]),\n+                                                    VectorMath.maxUnsigned(short_in1[i], short_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_int\")\n+    public void umin_ir_transform1_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_int\")\n+    public void umax_ir_transform1_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_int\")\n+    public void umin_umax_ir_transform1_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_int\")\n+    public void umin_umax_ir_transform2_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VL, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               LongVector.fromArray(lspec, long_in1, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_long\")\n+    public void umin_ir_transform1_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.minUnsigned(long_in1[i], long_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VL, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               LongVector.fromArray(lspec, long_in1, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_long\")\n+    public void umax_ir_transform1_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.maxUnsigned(long_in1[i], long_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VL, \" 0 \", IRNode.UMIN_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector vec1 = LongVector.fromArray(lspec, long_in1, i);\n+            LongVector vec2 = LongVector.fromArray(lspec, long_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_long\")\n+    public void umin_umax_ir_transform1_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.minUnsigned(VectorMath.minUnsigned(long_in1[i], long_in2[i]),\n+                                                   VectorMath.maxUnsigned(long_in1[i], long_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VL, \" 0 \", IRNode.UMAX_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector vec1 = LongVector.fromArray(lspec, long_in1, i);\n+            LongVector vec2 = LongVector.fromArray(lspec, long_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_long\")\n+    public void umin_umax_ir_transform2_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(long_in1[i], int_in2[i]),\n+                                                   VectorMath.maxUnsigned(long_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxIRTransformsTest.java","additions":507,"deletions":0,"binary":false,"changes":507,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -965,0 +966,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -972,0 +992,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1002,0 +1027,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1008,0 +1039,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2942,0 +2982,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SUSUB);\n+    }\n+\n@@ -4150,1 +4436,1 @@\n-    static void UNSIGNED_LTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4158,1 +4444,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4169,1 +4455,1 @@\n-    static void UNSIGNED_LTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4181,1 +4467,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4192,1 +4478,1 @@\n-    static void UNSIGNED_GTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4200,1 +4486,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4211,1 +4497,1 @@\n-    static void UNSIGNED_GTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4223,1 +4509,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4234,1 +4520,1 @@\n-    static void UNSIGNED_LEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4242,1 +4528,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4253,1 +4539,1 @@\n-    static void UNSIGNED_LEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4265,1 +4551,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4276,1 +4562,1 @@\n-    static void UNSIGNED_GEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4284,1 +4570,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4295,1 +4581,1 @@\n-    static void UNSIGNED_GEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4307,1 +4593,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -965,0 +966,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -972,0 +992,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1002,0 +1027,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1008,0 +1039,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2942,0 +2982,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SUSUB);\n+    }\n+\n@@ -4150,1 +4436,1 @@\n-    static void UNSIGNED_LTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4158,1 +4444,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4169,1 +4455,1 @@\n-    static void UNSIGNED_LTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4181,1 +4467,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4192,1 +4478,1 @@\n-    static void UNSIGNED_GTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4200,1 +4486,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4211,1 +4497,1 @@\n-    static void UNSIGNED_GTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4223,1 +4509,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4234,1 +4520,1 @@\n-    static void UNSIGNED_LEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4242,1 +4528,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4253,1 +4539,1 @@\n-    static void UNSIGNED_LEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4265,1 +4551,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4276,1 +4562,1 @@\n-    static void UNSIGNED_GEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4284,1 +4570,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4295,1 +4581,1 @@\n-    static void UNSIGNED_GEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4307,1 +4593,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -965,0 +966,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -972,0 +992,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1002,0 +1027,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1008,0 +1039,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2942,0 +2982,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SUSUB);\n+    }\n+\n@@ -4150,1 +4436,1 @@\n-    static void UNSIGNED_LTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4158,1 +4444,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4169,1 +4455,1 @@\n-    static void UNSIGNED_LTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4181,1 +4467,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4192,1 +4478,1 @@\n-    static void UNSIGNED_GTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4200,1 +4486,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4211,1 +4497,1 @@\n-    static void UNSIGNED_GTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4223,1 +4509,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4234,1 +4520,1 @@\n-    static void UNSIGNED_LEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4242,1 +4528,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4253,1 +4539,1 @@\n-    static void UNSIGNED_LEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4265,1 +4551,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4276,1 +4562,1 @@\n-    static void UNSIGNED_GEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4284,1 +4570,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4295,1 +4581,1 @@\n-    static void UNSIGNED_GEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4307,1 +4593,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -965,0 +966,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -972,0 +992,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1002,0 +1027,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1008,0 +1039,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2942,0 +2982,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SUSUB);\n+    }\n+\n@@ -4150,1 +4436,1 @@\n-    static void UNSIGNED_LTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4158,1 +4444,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4169,1 +4455,1 @@\n-    static void UNSIGNED_LTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4181,1 +4467,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4192,1 +4478,1 @@\n-    static void UNSIGNED_GTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4200,1 +4486,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4211,1 +4497,1 @@\n-    static void UNSIGNED_GTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4223,1 +4509,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4234,1 +4520,1 @@\n-    static void UNSIGNED_LEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4242,1 +4528,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4253,1 +4539,1 @@\n-    static void UNSIGNED_LEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4265,1 +4551,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4276,1 +4562,1 @@\n-    static void UNSIGNED_GEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4284,1 +4570,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4295,1 +4581,1 @@\n-    static void UNSIGNED_GEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4307,1 +4593,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -970,0 +971,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -977,0 +997,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1007,0 +1032,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1013,0 +1044,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2947,0 +2987,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SUSUB);\n+    }\n+\n@@ -4155,1 +4441,1 @@\n-    static void UNSIGNED_LTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4163,1 +4449,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4174,1 +4460,1 @@\n-    static void UNSIGNED_LTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4186,1 +4472,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4197,1 +4483,1 @@\n-    static void UNSIGNED_GTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4205,1 +4491,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4216,1 +4502,1 @@\n-    static void UNSIGNED_GTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4228,1 +4514,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4239,1 +4525,1 @@\n-    static void UNSIGNED_LEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void ULEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4247,1 +4533,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4258,1 +4544,1 @@\n-    static void UNSIGNED_LEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void ULEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4270,1 +4556,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4281,1 +4567,1 @@\n-    static void UNSIGNED_GEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+    static void UGEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n@@ -4289,1 +4575,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4300,1 +4586,1 @@\n-    static void UNSIGNED_GEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+    static void UGEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n@@ -4312,1 +4598,1 @@\n-                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2986,0 +3026,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SUSUB);\n+    }\n+\n@@ -4194,1 +4480,1 @@\n-    static void UNSIGNED_LTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4202,1 +4488,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4213,1 +4499,1 @@\n-    static void UNSIGNED_LTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4225,1 +4511,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4236,1 +4522,1 @@\n-    static void UNSIGNED_GTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4244,1 +4530,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4255,1 +4541,1 @@\n-    static void UNSIGNED_GTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4267,1 +4553,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4278,1 +4564,1 @@\n-    static void UNSIGNED_LEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4286,1 +4572,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4297,1 +4583,1 @@\n-    static void UNSIGNED_LEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4309,1 +4595,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4320,1 +4606,1 @@\n-    static void UNSIGNED_GEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4328,1 +4614,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4339,1 +4625,1 @@\n-    static void UNSIGNED_GEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4351,1 +4637,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2986,0 +3026,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SUSUB);\n+    }\n+\n@@ -4194,1 +4480,1 @@\n-    static void UNSIGNED_LTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4202,1 +4488,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4213,1 +4499,1 @@\n-    static void UNSIGNED_LTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4225,1 +4511,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4236,1 +4522,1 @@\n-    static void UNSIGNED_GTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4244,1 +4530,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4255,1 +4541,1 @@\n-    static void UNSIGNED_GTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4267,1 +4553,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4278,1 +4564,1 @@\n-    static void UNSIGNED_LEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4286,1 +4572,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4297,1 +4583,1 @@\n-    static void UNSIGNED_LEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4309,1 +4595,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4320,1 +4606,1 @@\n-    static void UNSIGNED_GEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4328,1 +4614,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4339,1 +4625,1 @@\n-    static void UNSIGNED_GEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4351,1 +4637,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2986,0 +3026,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SUSUB);\n+    }\n+\n@@ -4194,1 +4480,1 @@\n-    static void UNSIGNED_LTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4202,1 +4488,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4213,1 +4499,1 @@\n-    static void UNSIGNED_LTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4225,1 +4511,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4236,1 +4522,1 @@\n-    static void UNSIGNED_GTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4244,1 +4530,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4255,1 +4541,1 @@\n-    static void UNSIGNED_GTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4267,1 +4553,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4278,1 +4564,1 @@\n-    static void UNSIGNED_LEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4286,1 +4572,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4297,1 +4583,1 @@\n-    static void UNSIGNED_LEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4309,1 +4595,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4320,1 +4606,1 @@\n-    static void UNSIGNED_GEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4328,1 +4614,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4339,1 +4625,1 @@\n-    static void UNSIGNED_GEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4351,1 +4637,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2986,0 +3026,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SUSUB);\n+    }\n+\n@@ -4194,1 +4480,1 @@\n-    static void UNSIGNED_LTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4202,1 +4488,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4213,1 +4499,1 @@\n-    static void UNSIGNED_LTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4225,1 +4511,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4236,1 +4522,1 @@\n-    static void UNSIGNED_GTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4244,1 +4530,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4255,1 +4541,1 @@\n-    static void UNSIGNED_GTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4267,1 +4553,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4278,1 +4564,1 @@\n-    static void UNSIGNED_LEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4286,1 +4572,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4297,1 +4583,1 @@\n-    static void UNSIGNED_LEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4309,1 +4595,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4320,1 +4606,1 @@\n-    static void UNSIGNED_GEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4328,1 +4614,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4339,1 +4625,1 @@\n-    static void UNSIGNED_GEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4351,1 +4637,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -960,0 +961,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -967,0 +987,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1022,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1034,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2991,0 +3031,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SUSUB);\n+    }\n+\n@@ -4199,1 +4485,1 @@\n-    static void UNSIGNED_LTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4207,1 +4493,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4218,1 +4504,1 @@\n-    static void UNSIGNED_LTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4230,1 +4516,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4241,1 +4527,1 @@\n-    static void UNSIGNED_GTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4249,1 +4535,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4260,1 +4546,1 @@\n-    static void UNSIGNED_GTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4272,1 +4558,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4283,1 +4569,1 @@\n-    static void UNSIGNED_LEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void ULEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4291,1 +4577,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4302,1 +4588,1 @@\n-    static void UNSIGNED_LEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void ULEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4314,1 +4600,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4325,1 +4611,1 @@\n-    static void UNSIGNED_GEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+    static void UGEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n@@ -4333,1 +4619,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4344,1 +4630,1 @@\n-    static void UNSIGNED_GEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+    static void UGEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n@@ -4356,1 +4642,1 @@\n-                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -945,0 +946,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -952,0 +972,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1007,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -988,0 +1019,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3008,0 +3048,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SUSUB);\n+    }\n+\n@@ -4216,1 +4502,1 @@\n-    static void UNSIGNED_LTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4224,1 +4510,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4235,1 +4521,1 @@\n-    static void UNSIGNED_LTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4247,1 +4533,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4258,1 +4544,1 @@\n-    static void UNSIGNED_GTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4266,1 +4552,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4277,1 +4563,1 @@\n-    static void UNSIGNED_GTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4289,1 +4575,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4300,1 +4586,1 @@\n-    static void UNSIGNED_LELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4308,1 +4594,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4319,1 +4605,1 @@\n-    static void UNSIGNED_LELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4331,1 +4617,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4342,1 +4628,1 @@\n-    static void UNSIGNED_GELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4350,1 +4636,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4361,1 +4647,1 @@\n-    static void UNSIGNED_GELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4373,1 +4659,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -945,0 +946,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -952,0 +972,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1007,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -988,0 +1019,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3008,0 +3048,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SUSUB);\n+    }\n+\n@@ -4216,1 +4502,1 @@\n-    static void UNSIGNED_LTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4224,1 +4510,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4235,1 +4521,1 @@\n-    static void UNSIGNED_LTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4247,1 +4533,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4258,1 +4544,1 @@\n-    static void UNSIGNED_GTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4266,1 +4552,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4277,1 +4563,1 @@\n-    static void UNSIGNED_GTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4289,1 +4575,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4300,1 +4586,1 @@\n-    static void UNSIGNED_LELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4308,1 +4594,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4319,1 +4605,1 @@\n-    static void UNSIGNED_LELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4331,1 +4617,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4342,1 +4628,1 @@\n-    static void UNSIGNED_GELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4350,1 +4636,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4361,1 +4647,1 @@\n-    static void UNSIGNED_GELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4373,1 +4659,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -945,0 +946,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -952,0 +972,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1007,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -988,0 +1019,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3008,0 +3048,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SUSUB);\n+    }\n+\n@@ -4216,1 +4502,1 @@\n-    static void UNSIGNED_LTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4224,1 +4510,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4235,1 +4521,1 @@\n-    static void UNSIGNED_LTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4247,1 +4533,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4258,1 +4544,1 @@\n-    static void UNSIGNED_GTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4266,1 +4552,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4277,1 +4563,1 @@\n-    static void UNSIGNED_GTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4289,1 +4575,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4300,1 +4586,1 @@\n-    static void UNSIGNED_LELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4308,1 +4594,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4319,1 +4605,1 @@\n-    static void UNSIGNED_LELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4331,1 +4617,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4342,1 +4628,1 @@\n-    static void UNSIGNED_GELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4350,1 +4636,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4361,1 +4647,1 @@\n-    static void UNSIGNED_GELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4373,1 +4659,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -945,0 +946,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -952,0 +972,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1007,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -988,0 +1019,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3008,0 +3048,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SUSUB);\n+    }\n+\n@@ -4216,1 +4502,1 @@\n-    static void UNSIGNED_LTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4224,1 +4510,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4235,1 +4521,1 @@\n-    static void UNSIGNED_LTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4247,1 +4533,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4258,1 +4544,1 @@\n-    static void UNSIGNED_GTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4266,1 +4552,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4277,1 +4563,1 @@\n-    static void UNSIGNED_GTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4289,1 +4575,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4300,1 +4586,1 @@\n-    static void UNSIGNED_LELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4308,1 +4594,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4319,1 +4605,1 @@\n-    static void UNSIGNED_LELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4331,1 +4617,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4342,1 +4628,1 @@\n-    static void UNSIGNED_GELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4350,1 +4636,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4361,1 +4647,1 @@\n-    static void UNSIGNED_GELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4373,1 +4659,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -950,0 +951,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -957,0 +977,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3013,0 +3053,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SUSUB);\n+    }\n+\n@@ -4221,1 +4507,1 @@\n-    static void UNSIGNED_LTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4229,1 +4515,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4240,1 +4526,1 @@\n-    static void UNSIGNED_LTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4252,1 +4538,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4263,1 +4549,1 @@\n-    static void UNSIGNED_GTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4271,1 +4557,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4282,1 +4568,1 @@\n-    static void UNSIGNED_GTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4294,1 +4580,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4305,1 +4591,1 @@\n-    static void UNSIGNED_LELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void ULELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4313,1 +4599,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4324,1 +4610,1 @@\n-    static void UNSIGNED_LELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void ULELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4336,1 +4622,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4347,1 +4633,1 @@\n-    static void UNSIGNED_GELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+    static void UGELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n@@ -4355,1 +4641,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4366,1 +4652,1 @@\n-    static void UNSIGNED_GELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+    static void UGELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n@@ -4378,1 +4664,1 @@\n-                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2933,0 +2973,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SUSUB);\n+    }\n+\n@@ -4141,1 +4427,1 @@\n-    static void UNSIGNED_LTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4149,1 +4435,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4160,1 +4446,1 @@\n-    static void UNSIGNED_LTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4172,1 +4458,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4183,1 +4469,1 @@\n-    static void UNSIGNED_GTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4191,1 +4477,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4202,1 +4488,1 @@\n-    static void UNSIGNED_GTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4214,1 +4500,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4225,1 +4511,1 @@\n-    static void UNSIGNED_LEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4233,1 +4519,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4244,1 +4530,1 @@\n-    static void UNSIGNED_LEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4256,1 +4542,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4267,1 +4553,1 @@\n-    static void UNSIGNED_GEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4275,1 +4561,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4286,1 +4572,1 @@\n-    static void UNSIGNED_GEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4298,1 +4584,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2933,0 +2973,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SUSUB);\n+    }\n+\n@@ -4141,1 +4427,1 @@\n-    static void UNSIGNED_LTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4149,1 +4435,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4160,1 +4446,1 @@\n-    static void UNSIGNED_LTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4172,1 +4458,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4183,1 +4469,1 @@\n-    static void UNSIGNED_GTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4191,1 +4477,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4202,1 +4488,1 @@\n-    static void UNSIGNED_GTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4214,1 +4500,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4225,1 +4511,1 @@\n-    static void UNSIGNED_LEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4233,1 +4519,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4244,1 +4530,1 @@\n-    static void UNSIGNED_LEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4256,1 +4542,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4267,1 +4553,1 @@\n-    static void UNSIGNED_GEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4275,1 +4561,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4286,1 +4572,1 @@\n-    static void UNSIGNED_GEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4298,1 +4584,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2933,0 +2973,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SUSUB);\n+    }\n+\n@@ -4141,1 +4427,1 @@\n-    static void UNSIGNED_LTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4149,1 +4435,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4160,1 +4446,1 @@\n-    static void UNSIGNED_LTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4172,1 +4458,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4183,1 +4469,1 @@\n-    static void UNSIGNED_GTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4191,1 +4477,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4202,1 +4488,1 @@\n-    static void UNSIGNED_GTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4214,1 +4500,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4225,1 +4511,1 @@\n-    static void UNSIGNED_LEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4233,1 +4519,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4244,1 +4530,1 @@\n-    static void UNSIGNED_LEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4256,1 +4542,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4267,1 +4553,1 @@\n-    static void UNSIGNED_GEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4275,1 +4561,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4286,1 +4572,1 @@\n-    static void UNSIGNED_GEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4298,1 +4584,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -955,0 +956,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -962,0 +982,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2933,0 +2973,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SUSUB);\n+    }\n+\n@@ -4141,1 +4427,1 @@\n-    static void UNSIGNED_LTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4149,1 +4435,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4160,1 +4446,1 @@\n-    static void UNSIGNED_LTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4172,1 +4458,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4183,1 +4469,1 @@\n-    static void UNSIGNED_GTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4191,1 +4477,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4202,1 +4488,1 @@\n-    static void UNSIGNED_GTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4214,1 +4500,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4225,1 +4511,1 @@\n-    static void UNSIGNED_LEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4233,1 +4519,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4244,1 +4530,1 @@\n-    static void UNSIGNED_LEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4256,1 +4542,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4267,1 +4553,1 @@\n-    static void UNSIGNED_GEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4275,1 +4561,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4286,1 +4572,1 @@\n-    static void UNSIGNED_GEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4298,1 +4584,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMath;\n@@ -960,0 +961,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -967,0 +987,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1022,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1034,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2938,0 +2978,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMath.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMath.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMath.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMath.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMath.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SUSUB);\n+    }\n+\n@@ -4146,1 +4432,1 @@\n-    static void UNSIGNED_LTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4154,1 +4440,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv);\n@@ -4165,1 +4451,1 @@\n-    static void UNSIGNED_LTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4177,1 +4463,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULT, bv, vmask);\n@@ -4188,1 +4474,1 @@\n-    static void UNSIGNED_GTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4196,1 +4482,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv);\n@@ -4207,1 +4493,1 @@\n-    static void UNSIGNED_GTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4219,1 +4505,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGT, bv, vmask);\n@@ -4230,1 +4516,1 @@\n-    static void UNSIGNED_LEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void ULEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4238,1 +4524,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv);\n@@ -4249,1 +4535,1 @@\n-    static void UNSIGNED_LEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void ULEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4261,1 +4547,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.ULE, bv, vmask);\n@@ -4272,1 +4558,1 @@\n-    static void UNSIGNED_GEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+    static void UGEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n@@ -4280,1 +4566,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv);\n@@ -4291,1 +4577,1 @@\n-    static void UNSIGNED_GEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+    static void UGEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n@@ -4303,1 +4589,1 @@\n-                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UGE, bv, vmask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":302,"deletions":16,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338021\n+ * @summary Test unsigned and saturating scalar operators for use with Vector API\n+ * @modules jdk.incubator.vector\n+ * @run testng VectorMathTest\n+ *\/\n+\n+import jdk.incubator.vector.VectorMath;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Array;\n+import java.util.function.BinaryOperator;\n+\n+public class VectorMathTest {\n+    \/\/ @formatter:off\n+    public static final byte  ZERO_B = (byte)0;\n+    public static final short ZERO_S = (short)0;\n+    public static final int   ZERO_I = 0;\n+    public static final long  ZERO_L = 0L;\n+\n+    public static final byte  TEN_B = (byte)10;\n+    public static final int   TEN_S = (short)10;\n+    public static final short TEN_I = 10;\n+    public static final long  TEN_L = 10L;\n+\n+    public static final byte  FIFTY_B = (byte)50;\n+    public static final int   FIFTY_S = (short)50;\n+    public static final short FIFTY_I = 50;\n+    public static final long  FIFTY_L = 50L;\n+\n+    public static final byte  SIXTY_B = (byte)60;\n+    public static final int   SIXTY_S = (short)60;\n+    public static final short SIXTY_I = 60;\n+    public static final long  SIXTY_L = 60L;\n+\n+    public static final byte  UMAX_B = (byte)-1;\n+    public static final short UMAX_S = (short)-1;\n+    public static final int   UMAX_I = -1;\n+    public static final long  UMAX_L = -1L;\n+\n+    public static byte[]  INPUT_SB = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TEN_B),   ZERO_B, (byte)(Byte.MAX_VALUE - TEN_B),   Byte.MAX_VALUE};\n+    public static short[] INPUT_SS = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TEN_S), ZERO_S, (short)(Short.MAX_VALUE - TEN_S), Short.MAX_VALUE};\n+    public static int[]   INPUT_SI = {Integer.MIN_VALUE, (Integer.MIN_VALUE + TEN_I),      ZERO_I, Integer.MAX_VALUE - TEN_I,        Integer.MAX_VALUE};\n+    public static long[]  INPUT_SL = {Long.MIN_VALUE,    Long.MIN_VALUE + TEN_L,           ZERO_L, Long.MAX_VALUE - TEN_L,           Long.MAX_VALUE};\n+\n+    public static int[]   INPUT_SADD_I    = {-FIFTY_I,          -FIFTY_I,          -FIFTY_I, FIFTY_I,           FIFTY_I};\n+    public static byte[]  EXPECTED_SADD_B = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTY_B, Byte.MAX_VALUE,    Byte.MAX_VALUE};\n+    public static short[] EXPECTED_SADD_S = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTY_S, Short.MAX_VALUE,   Short.MAX_VALUE};\n+    public static int[]   EXPECTED_SADD_I = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTY_I, Integer.MAX_VALUE, Integer.MAX_VALUE};\n+    public static long[]  EXPECTED_SADD_L = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTY_L, Long.MAX_VALUE,    Long.MAX_VALUE};\n+\n+    public static int[]   INPUT_SSUB_I    = {FIFTY_I,           FIFTY_I,            FIFTY_I, -FIFTY_I,          -FIFTY_I};\n+    public static byte[]  EXPECTED_SSUB_B = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTY_B, Byte.MAX_VALUE,    Byte.MAX_VALUE};\n+    public static short[] EXPECTED_SSUB_S = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTY_S, Short.MAX_VALUE,   Short.MAX_VALUE};\n+    public static int[]   EXPECTED_SSUB_I = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTY_I, Integer.MAX_VALUE, Integer.MAX_VALUE};\n+    public static long[]  EXPECTED_SSUB_L = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTY_L, Long.MAX_VALUE,    Long.MAX_VALUE};\n+\n+    public static byte[]  INPUT_UB = {ZERO_B, (byte)(ZERO_B + TEN_B),  (byte)(UMAX_B - TEN_B),  UMAX_B};\n+    public static short[] INPUT_US = {ZERO_S, (short)(ZERO_S + TEN_S), (short)(UMAX_S - TEN_S), UMAX_S};\n+    public static int[]   INPUT_UI = {ZERO_I, ZERO_I + TEN_I,          UMAX_I - TEN_I,          UMAX_I};\n+    public static long[]  INPUT_UL = {ZERO_L, ZERO_L + TEN_L,          UMAX_L - TEN_L,          UMAX_L};\n+\n+    public static int[]   INPUT_SUADD_I    = {FIFTY_I, FIFTY_I, FIFTY_I, FIFTY_I};\n+    public static byte[]  EXPECTED_SUADD_B = {FIFTY_B, SIXTY_B, UMAX_B,  UMAX_B};\n+    public static short[] EXPECTED_SUADD_S = {FIFTY_S, SIXTY_S, UMAX_S,  UMAX_S};\n+    public static int[]   EXPECTED_SUADD_I = {FIFTY_I, SIXTY_I, UMAX_I,  UMAX_I};\n+    public static long[]  EXPECTED_SUADD_L = {FIFTY_L, SIXTY_L, UMAX_L,  UMAX_L};\n+\n+    public static int[]   INPUT_SUSUB_I    = {FIFTY_I, FIFTY_I, FIFTY_I,           FIFTY_I};\n+    public static byte[]  EXPECTED_SUSUB_B = {ZERO_B,  ZERO_B,  UMAX_B - SIXTY_B,  UMAX_B - FIFTY_B};\n+    public static short[] EXPECTED_SUSUB_S = {ZERO_S,  ZERO_S,  UMAX_S - SIXTY_S,  UMAX_S - FIFTY_S};\n+    public static int[]   EXPECTED_SUSUB_I = {ZERO_I,  ZERO_I,  UMAX_I - SIXTY_I,  UMAX_I - FIFTY_I};\n+    public static long[]  EXPECTED_SUSUB_L = {ZERO_L,  ZERO_L,  UMAX_L - SIXTY_L,  UMAX_L - FIFTY_L};\n+\n+    public static byte[]  EXPECTED_UMIN_B = {ZERO_B, TEN_B, ZERO_B, Byte.MAX_VALUE - TEN_B};\n+    public static short[] EXPECTED_UMIN_S = {ZERO_S, TEN_S, ZERO_S, Short.MAX_VALUE - TEN_S};\n+    public static int[]   EXPECTED_UMIN_I = {ZERO_I, TEN_I, ZERO_I, Integer.MAX_VALUE - TEN_I};\n+    public static long[]  EXPECTED_UMIN_L = {ZERO_L, TEN_L, ZERO_L, Long.MAX_VALUE - TEN_L};\n+\n+    public static byte[]  EXPECTED_UMAX_B = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TEN_B),   (byte)(UMAX_B - TEN_B),  UMAX_B};\n+    public static short[] EXPECTED_UMAX_S = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TEN_S), (short)(UMAX_S - TEN_S), UMAX_S};\n+    public static int[]   EXPECTED_UMAX_I = {Integer.MIN_VALUE, Integer.MIN_VALUE + TEN_I,        (UMAX_I - TEN_I),        UMAX_I};\n+    public static long[]  EXPECTED_UMAX_L = {Long.MIN_VALUE,    Long.MIN_VALUE + TEN_L,           (UMAX_L - TEN_L),        UMAX_L};\n+    \/\/ @formatter:on\n+\n+    static Object conv(Object a, Class<?> ct) {\n+        Object na = Array.newInstance(ct, Array.getLength(a));\n+        for (int i = 0; i < Array.getLength(a); i++) {\n+            Number number = (Number) Array.get(a, i);\n+            if (ct == byte.class) {\n+                number = number.byteValue();\n+            } else if (ct == short.class) {\n+                number = number.shortValue();\n+            } else if (ct == int.class) {\n+                number = number.intValue();\n+            } else if (ct == long.class) {\n+                number = number.longValue();\n+            } else {\n+                assert false : \"should not reach here\";\n+            }\n+            Array.set(na, i, number);\n+        }\n+        return na;\n+    }\n+\n+    static <T> BinaryOperator<T> named(String name, BinaryOperator<T> op) {\n+        return new BinaryOperator<T>() {\n+            @Override\n+            public T apply(T a, T b) {\n+                return op.apply(a, b);\n+            }\n+\n+            public String toString() {\n+                return name;\n+            }\n+        };\n+    }\n+\n+    static final BinaryOperator<Object> OP_UMIN = named(\"minUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.minUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.minUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.minUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.minUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_UMAX = named(\"maxUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.maxUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.maxUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.maxUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.maxUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SADD = named(\"addSaturating\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.addSaturating((byte) a, (byte) b);\n+                case Short _ -> VectorMath.addSaturating((short) a, (short) b);\n+                case Integer _ -> VectorMath.addSaturating((int) a, (int) b);\n+                case Long _ -> VectorMath.addSaturating((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SSUB = named(\"subSaturating\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.subSaturating((byte) a, (byte) b);\n+                case Short _ -> VectorMath.subSaturating((short) a, (short) b);\n+                case Integer _ -> VectorMath.subSaturating((int) a, (int) b);\n+                case Long _ -> VectorMath.subSaturating((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SUADD = named(\"addSaturatingUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.addSaturatingUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.addSaturatingUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.addSaturatingUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.addSaturatingUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SUSUB = named(\"subSaturatingUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.subSaturatingUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.subSaturatingUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.subSaturatingUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.subSaturatingUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    @DataProvider\n+    public static Object[][] opProvider() {\n+        return new Object[][] {\n+                {OP_UMIN, byte.class, INPUT_UB, INPUT_SB, EXPECTED_UMIN_B, },\n+                {OP_UMIN, short.class, INPUT_US, INPUT_SS, EXPECTED_UMIN_S, },\n+                {OP_UMIN, int.class, INPUT_UI, INPUT_SI, EXPECTED_UMIN_I, },\n+                {OP_UMIN, long.class, INPUT_UL, INPUT_SL, EXPECTED_UMIN_L, },\n+\n+                {OP_UMAX, byte.class, INPUT_UB, INPUT_SB, EXPECTED_UMAX_B, },\n+                {OP_UMAX, short.class, INPUT_US, INPUT_SS, EXPECTED_UMAX_S, },\n+                {OP_UMAX, int.class, INPUT_UI, INPUT_SI, EXPECTED_UMAX_I, },\n+                {OP_UMAX, long.class, INPUT_UL, INPUT_SL, EXPECTED_UMAX_L, },\n+\n+                {OP_SADD, byte.class, INPUT_SB, conv(INPUT_SADD_I, byte.class), EXPECTED_SADD_B, },\n+                {OP_SADD, short.class, INPUT_SS, conv(INPUT_SADD_I, short.class), EXPECTED_SADD_S, },\n+                {OP_SADD, int.class, INPUT_SI, INPUT_SADD_I, EXPECTED_SADD_I, },\n+                {OP_SADD, long.class, INPUT_SL, conv(INPUT_SADD_I, long.class), EXPECTED_SADD_L, },\n+\n+                {OP_SSUB, byte.class, INPUT_SB, conv(INPUT_SSUB_I, byte.class), EXPECTED_SSUB_B, },\n+                {OP_SSUB, short.class, INPUT_SS, conv(INPUT_SSUB_I, short.class), EXPECTED_SSUB_S, },\n+                {OP_SSUB, int.class, INPUT_SI, INPUT_SSUB_I, EXPECTED_SSUB_I, },\n+                {OP_SSUB, long.class, INPUT_SL, conv(INPUT_SSUB_I, long.class), EXPECTED_SSUB_L, },\n+\n+                {OP_SUADD, byte.class, INPUT_UB, conv(INPUT_SUADD_I, byte.class), EXPECTED_SUADD_B, },\n+                {OP_SUADD, short.class, INPUT_US, conv(INPUT_SUADD_I, short.class), EXPECTED_SUADD_S, },\n+                {OP_SUADD, int.class, INPUT_UI, INPUT_SUADD_I, EXPECTED_SUADD_I, },\n+                {OP_SUADD, long.class, INPUT_UL, conv(INPUT_SUADD_I, long.class), EXPECTED_SUADD_L, },\n+\n+                {OP_SUSUB, byte.class, INPUT_UB, conv(INPUT_SUSUB_I, byte.class), EXPECTED_SUSUB_B, },\n+                {OP_SUSUB, short.class, INPUT_US, conv(INPUT_SUSUB_I, short.class), EXPECTED_SUSUB_S, },\n+                {OP_SUSUB, int.class, INPUT_UI, INPUT_SUSUB_I, EXPECTED_SUSUB_I, },\n+                {OP_SUSUB, long.class, INPUT_UL, conv(INPUT_SUSUB_I, long.class), EXPECTED_SUSUB_L, },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"opProvider\")\n+    public void test(BinaryOperator<Object> op, Class<?> type, Object a, Object b, Object expected) {\n+        assert Array.getLength(a) <= Array.getLength(b) && Array.getLength(a) <= Array.getLength(expected);\n+\n+        Object actual = Array.newInstance(type, Array.getLength(a));\n+        for (int i = 0; i < Array.getLength(a); i++) {\n+            Object e = op.apply(Array.get(a, i), Array.get(b, i));\n+            Array.set(actual, i, e);\n+        }\n+        Assert.assertEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorMathTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -45,0 +45,2 @@\n+saturating_binary=\"SaturatingBinary-op\"\n+saturating_binary_masked=\"SaturatingBinary-Masked-op\"\n@@ -313,0 +315,6 @@\n+function gen_saturating_binary_op {\n+  echo \"Generating binary op $1 ($2)...\"\n+  gen_op_tmpl $saturating_binary \"$@\"\n+  gen_op_tmpl $saturating_binary_masked \"$@\"\n+}\n+\n@@ -462,0 +470,6 @@\n+gen_binary_op \"UMIN\" \"VectorMath.minUnsigned(a, b)\" \"BITWISE\"\n+gen_binary_op \"UMAX\" \"VectorMath.maxUnsigned(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SADD\" \"VectorMath.addSaturating(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SSUB\" \"VectorMath.subSaturating(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SUADD\" \"VectorMath.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SUSUB\" \"VectorMath.subSaturatingUnsigned(a, b)\" \"BITWISE\"\n@@ -497,4 +511,4 @@\n-gen_compare_op \"UNSIGNED_LT\" \"ult\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_GT\" \"ugt\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_LE\" \"ule\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_GE\" \"uge\" \"BITWISE\"\n+gen_compare_op \"ULT\" \"ult\" \"BITWISE\"\n+gen_compare_op \"UGT\" \"ugt\" \"BITWISE\"\n+gen_compare_op \"ULE\" \"ule\" \"BITWISE\"\n+gen_compare_op \"UGE\" \"uge\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-Masked-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-Masked-op.template","status":"copied"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-op.template","status":"copied"},{"patch":"@@ -0,0 +1,7 @@\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-Masked-op.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\n+    static $type$ [[TEST]]($type$ a, $type$ b) {\n+        return ($type$)([[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -41,0 +41,3 @@\n+#if[!FP]\n+import jdk.incubator.vector.VectorMath;\n+#end[!FP]\n@@ -1224,0 +1227,21 @@\n+#if[!FP]\n+    static final List<IntFunction<$type$[]>> $TYPE$_SATURATING_GENERATORS = List.of(\n+            withToString(\"$type$[$Boxtype$.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MIN_VALUE));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE - 100));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MIN_VALUE + 100));\n+            })\n+    );\n+\n+#end[!FP]\n@@ -1231,0 +1255,7 @@\n+#if[!FP]\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_SATURATING_GENERATOR_PAIRS =\n+        Stream.of($TYPE$_GENERATORS.get(0)).\n+                flatMap(fa -> $TYPE$_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+#end[!FP]\n@@ -1261,0 +1292,8 @@\n+#if[!FP]\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpProvider() {\n+        return $TYPE$_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+#end[!FP]\n@@ -1267,0 +1306,11 @@\n+#if[!FP]\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+#end[!FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}