{"files":[{"patch":"@@ -2089,44 +2089,0 @@\n-Node* UMinVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  bool match1 = in(1)->Opcode() == Op_UMinV || in(1)->Opcode() == Op_UMaxV;\n-  bool match2 = in(2)->Opcode() == Op_UMinV || in(2)->Opcode() == Op_UMaxV;\n-  \/\/ UMin (UMin(a, b), UMax(a, b))  => UMin(a, b)\n-  \/\/ UMin (UMin(a, b), UMax(b, a))  => UMin(a, b)\n-  if (match1 && match2) {\n-    if ((in(1)->in(1) == in(2)->in(1) && in(1)->in(2) == in(2)->in(2)) ||\n-         (in(1)->in(2) == in(2)->in(1) && in(1)->in(1) == in(2)->in(2))) {\n-      return new UMinVNode(in(1)->in(1), in(1)->in(2), vect_type());\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-Node* UMinVNode::Identity(PhaseGVN* phase) {\n-  \/\/ UMin (a, a) => a\n-  if (in(1) == in(2)) {\n-    return in(1);\n-  }\n-  return this;\n-}\n-\n-Node* UMaxVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  bool match1 = in(1)->Opcode() == Op_UMinV || in(1)->Opcode() == Op_UMaxV;\n-  bool match2 = in(2)->Opcode() == Op_UMinV || in(2)->Opcode() == Op_UMaxV;\n-  \/\/ UMax (UMin(a, b), UMax(a, b))  => UMax(a, b)\n-  \/\/ UMax (UMin(a, b), UMax(b, a))  => UMax(a, b)\n-  if (match1 && match2) {\n-    if ((in(1)->in(1) == in(2)->in(1) && in(1)->in(2) == in(2)->in(2)) ||\n-         (in(1)->in(2) == in(2)->in(1) && in(1)->in(1) == in(2)->in(2))) {\n-      return new UMaxVNode(in(1)->in(1), in(1)->in(2), vect_type());\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-Node* UMaxVNode::Identity(PhaseGVN* phase) {\n-  \/\/ UMax (a, a) => a\n-  if (in(1) == in(2)) {\n-    return in(1);\n-  }\n-  return this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -611,2 +611,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  virtual Node* Identity(PhaseGVN* phase);\n@@ -629,2 +627,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1111,40 +1111,0 @@\n-    public static final String UMIN_VB = VECTOR_PREFIX + \"UMIN_VB\" + POSTFIX;\n-    static {\n-        vectorNode(UMIN_VB, \"UMinV\", TYPE_BYTE);\n-    }\n-\n-    public static final String UMIN_VS = VECTOR_PREFIX + \"UMIN_VS\" + POSTFIX;\n-    static {\n-        vectorNode(UMIN_VS, \"UMinV\", TYPE_SHORT);\n-    }\n-\n-    public static final String UMIN_VI = VECTOR_PREFIX + \"UMIN_VI\" + POSTFIX;\n-    static {\n-        vectorNode(UMIN_VI, \"UMinV\", TYPE_INT);\n-    }\n-\n-    public static final String UMIN_VL = VECTOR_PREFIX + \"UMIN_VL\" + POSTFIX;\n-    static {\n-        vectorNode(UMIN_VL, \"UMinV\", TYPE_LONG);\n-    }\n-\n-    public static final String UMAX_VB = VECTOR_PREFIX + \"UMAX_VB\" + POSTFIX;\n-    static {\n-        vectorNode(UMAX_VB, \"UMaxV\", TYPE_BYTE);\n-    }\n-\n-    public static final String UMAX_VS = VECTOR_PREFIX + \"UMAX_VS\" + POSTFIX;\n-    static {\n-        vectorNode(UMAX_VS, \"UMaxV\", TYPE_SHORT);\n-    }\n-\n-    public static final String UMAX_VI = VECTOR_PREFIX + \"UMAX_VI\" + POSTFIX;\n-    static {\n-        vectorNode(UMAX_VI, \"UMaxV\", TYPE_INT);\n-    }\n-\n-    public static final String UMAX_VL = VECTOR_PREFIX + \"UMAX_VL\" + POSTFIX;\n-    static {\n-        vectorNode(UMAX_VL, \"UMaxV\", TYPE_LONG);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,507 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-* @test\n-* @bug 8338201\n-* @summary Validate IR Transforms for new unsigned min\/max vector operations\n-* @modules jdk.incubator.vector\n-* @requires vm.compiler2.enabled\n-* @library \/test\/lib \/\n-* @run driver compiler.vectorapi.VectorUnsignedMinMaxIRTransformsTest\n-*\/\n-\n-package compiler.vectorapi;\n-\n-import jdk.incubator.vector.*;\n-import compiler.lib.ir_framework.*;\n-import java.util.stream.IntStream;\n-\n-public class VectorUnsignedMinMaxIRTransformsTest {\n-    private static final int COUNT = 2048;\n-    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n-\n-    private long[]  long_in1;\n-    private int[]   int_in1;\n-    private short[] short_in1;\n-    private byte[]  byte_in1;\n-\n-    private long[]  long_in2;\n-    private int[]   int_in2;\n-    private short[] short_in2;\n-    private byte[]  byte_in2;\n-\n-    private long[]  long_out;\n-    private int[]   int_out;\n-    private short[] short_out;\n-    private byte[]  byte_out;\n-\n-    public static void main(String[] args) {\n-        TestFramework testFramework = new TestFramework();\n-        testFramework.setDefaultWarmup(5000)\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n-                     .start();\n-    }\n-\n-    public VectorUnsignedMinMaxIRTransformsTest() {\n-        byte_in1  = new byte[COUNT];\n-        short_in1 = new short[COUNT];\n-        int_in1   = new int[COUNT];\n-        long_in1  = new long[COUNT];\n-\n-        byte_in2  = new byte[COUNT];\n-        short_in2 = new short[COUNT];\n-        int_in2   = new int[COUNT];\n-        long_in2  = new long[COUNT];\n-        IntStream.range(0, COUNT).forEach(\n-            i -> {\n-                if ((i & 1) == 0) {\n-                    long_in1[i] = Long.MAX_VALUE;\n-                    long_in2[i] = i;\n-                    int_in1[i]  = Integer.MAX_VALUE;\n-                    int_in2[i]  = i;\n-                    short_in1[i] = Short.MAX_VALUE;\n-                    short_in2[i] = (short)i;\n-                    byte_in1[i]  = Byte.MAX_VALUE;\n-                    byte_in2[i]  = (byte)i;\n-                } else {\n-                    long_in1[i] = Long.MIN_VALUE;\n-                    long_in2[i] = -i;\n-                    int_in1[i]  = Integer.MIN_VALUE;\n-                    int_in2[i]  = -i;\n-                    short_in1[i] = Short.MIN_VALUE;\n-                    short_in2[i] = (short)-i;\n-                    byte_in1[i]  = Byte.MIN_VALUE;\n-                    byte_in2[i]  = (byte)-i;\n-                }\n-            }\n-        );\n-        long_out  = new long[COUNT];\n-        int_out   = new int[COUNT];\n-        short_out = new short[COUNT];\n-        byte_out  = new byte[COUNT];\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VB, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_ir_transform1_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               ByteVector.fromArray(bspec, byte_in1, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_ir_transform1_byte\")\n-    public void umin_ir_transform1_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.minUnsigned(byte_in1[i], byte_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VB, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umax_ir_transform1_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               ByteVector.fromArray(bspec, byte_in1, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_ir_transform1_byte\")\n-    public void umax_ir_transform1_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.maxUnsigned(byte_in1[i], byte_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VB, \" 0 \", IRNode.UMIN_VB, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform1_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector vec1 = ByteVector.fromArray(bspec, byte_in1, i);\n-            ByteVector vec2 = ByteVector.fromArray(bspec, byte_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMIN,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform1_byte\")\n-    public void umin_umax_ir_transform1_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = byte_out[i];\n-            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(byte_in1[i], byte_in2[i]),\n-                                                  VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VB, \" 0 \", IRNode.UMAX_VB, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform2_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector vec1 = ByteVector.fromArray(bspec, byte_in1, i);\n-            ByteVector vec2 = ByteVector.fromArray(bspec, byte_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMAX,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform2_byte\")\n-    public void umin_umax_ir_transform2_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(byte_in1[i], byte_in2[i]),\n-                                                   VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VS, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_ir_transform1_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               ShortVector.fromArray(sspec, short_in1, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_ir_transform1_short\")\n-    public void umin_ir_transform1_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.minUnsigned(short_in1[i], short_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VS, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umax_ir_transform1_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               ShortVector.fromArray(sspec, short_in1, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_ir_transform1_short\")\n-    public void umax_ir_transform1_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.maxUnsigned(short_in1[i], short_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VS, \" 0 \", IRNode.UMIN_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform1_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector vec1 = ShortVector.fromArray(sspec, short_in1, i);\n-            ShortVector vec2 = ShortVector.fromArray(sspec, short_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMIN,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform1_short\")\n-    public void umin_umax_ir_transform1_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.minUnsigned(VectorMath.minUnsigned(short_in1[i], short_in2[i]),\n-                                                    VectorMath.maxUnsigned(short_in1[i], short_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VS, \" 0 \", IRNode.UMAX_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform2_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector vec1 = ShortVector.fromArray(sspec, short_in1, i);\n-            ShortVector vec2 = ShortVector.fromArray(sspec, short_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMAX,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform2_short\")\n-    public void umin_umax_ir_transform2_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(short_in1[i], short_in2[i]),\n-                                                    VectorMath.maxUnsigned(short_in1[i], short_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VI, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_ir_transform1_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               IntVector.fromArray(ispec, int_in1, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_ir_transform1_int\")\n-    public void umin_ir_transform1_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.minUnsigned(int_in1[i], int_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VI, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umax_ir_transform1_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               IntVector.fromArray(ispec, int_in1, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_ir_transform1_int\")\n-    public void umax_ir_transform1_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.maxUnsigned(int_in1[i], int_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform1_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n-            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMIN,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform1_int\")\n-    public void umin_umax_ir_transform1_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n-                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform2_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n-            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMAX,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform2_int\")\n-    public void umin_umax_ir_transform2_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n-                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VL, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_ir_transform1_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               LongVector.fromArray(lspec, long_in1, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_ir_transform1_long\")\n-    public void umin_ir_transform1_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.minUnsigned(long_in1[i], long_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VL, \" 0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umax_ir_transform1_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               LongVector.fromArray(lspec, long_in1, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_ir_transform1_long\")\n-    public void umax_ir_transform1_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.maxUnsigned(long_in1[i], long_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VL, \" 0 \", IRNode.UMIN_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform1_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector vec1 = LongVector.fromArray(lspec, long_in1, i);\n-            LongVector vec2 = LongVector.fromArray(lspec, long_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMIN,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform1_long\")\n-    public void umin_umax_ir_transform1_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.minUnsigned(VectorMath.minUnsigned(long_in1[i], long_in2[i]),\n-                                                   VectorMath.maxUnsigned(long_in1[i], long_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VL, \" 0 \", IRNode.UMAX_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n-    @Warmup(value = 10000)\n-    public void umin_umax_ir_transform2_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector vec1 = LongVector.fromArray(lspec, long_in1, i);\n-            LongVector vec2 = LongVector.fromArray(lspec, long_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMAX,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_umax_ir_transform2_long\")\n-    public void umin_umax_ir_transform2_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(long_in1[i], int_in2[i]),\n-                                                   VectorMath.maxUnsigned(long_in1[i], int_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxIRTransformsTest.java","additions":0,"deletions":507,"binary":false,"changes":507,"status":"deleted"}]}