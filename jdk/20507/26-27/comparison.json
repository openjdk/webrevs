{"files":[{"patch":"@@ -1,475 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-* @test\n-* @bug 8338201\n-* @summary Support new unsigned and saturating vector operators in VectorAPI\n-* @modules jdk.incubator.vector\n-* @requires vm.compiler2.enabled\n-* @library \/test\/lib \/\n-* @run driver compiler.vectorapi.VectorSaturatedOperationsTest\n-*\/\n-\n-package compiler.vectorapi;\n-\n-import jdk.incubator.vector.*;\n-import compiler.lib.ir_framework.*;\n-import java.util.stream.IntStream;\n-\n-public class VectorSaturatedOperationsTest {\n-    private static final int COUNT = 2048;\n-    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n-\n-    private long[]  long_in1;\n-    private int[]   int_in1;\n-    private short[] short_in1;\n-    private byte[]  byte_in1;\n-\n-    private long[]  long_in2;\n-    private int[]   int_in2;\n-    private short[] short_in2;\n-    private byte[]  byte_in2;\n-\n-    private long[]  long_out;\n-    private int[]   int_out;\n-    private short[] short_out;\n-    private byte[]  byte_out;\n-\n-    public static void main(String[] args) {\n-        TestFramework testFramework = new TestFramework();\n-        testFramework.setDefaultWarmup(5000)\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n-                     .start();\n-    }\n-\n-    public VectorSaturatedOperationsTest() {\n-        byte_in1  = new byte[COUNT];\n-        short_in1 = new short[COUNT];\n-        int_in1   = new int[COUNT];\n-        long_in1  = new long[COUNT];\n-\n-        byte_in2  = new byte[COUNT];\n-        short_in2 = new short[COUNT];\n-        int_in2   = new int[COUNT];\n-        long_in2  = new long[COUNT];\n-        IntStream.range(0, COUNT).forEach(\n-            i -> {\n-                if ((i & 1) == 0) {\n-                    long_in1[i] = Long.MAX_VALUE;\n-                    long_in2[i] = i;\n-                    int_in1[i]  = Integer.MAX_VALUE;\n-                    int_in2[i]  = i;\n-                    short_in1[i] = Short.MAX_VALUE;\n-                    short_in2[i] = (short)i;\n-                    byte_in1[i]  = Byte.MAX_VALUE;\n-                    byte_in2[i]  = (byte)i;\n-                } else {\n-                    long_in1[i] = Long.MIN_VALUE;\n-                    long_in2[i] = -i;\n-                    int_in1[i]  = Integer.MIN_VALUE;\n-                    int_in2[i]  = -i;\n-                    short_in1[i] = Short.MIN_VALUE;\n-                    short_in2[i] = (short)-i;\n-                    byte_in1[i]  = Byte.MIN_VALUE;\n-                    byte_in2[i]  = (byte)-i;\n-                }\n-            }\n-        );\n-        long_out  = new long[COUNT];\n-        int_out   = new int[COUNT];\n-        short_out = new short[COUNT];\n-        byte_out  = new byte[COUNT];\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void sadd_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.SADD,\n-                               ByteVector.fromArray(bspec, byte_in2, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"sadd_byte\")\n-    public void sadd_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.addSaturating(byte_in1[i], byte_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void sadd_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.SADD,\n-                               ShortVector.fromArray(sspec, short_in2, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"sadd_short\")\n-    public void sadd_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.addSaturating(short_in1[i], short_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void sadd_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.SADD,\n-                               IntVector.fromArray(ispec, int_in2, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"sadd_int\")\n-    public void sadd_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.addSaturating(int_in1[i], int_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void sadd_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.SADD,\n-                               LongVector.fromArray(lspec, long_in2, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"sadd_long\")\n-    public void sadd_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.addSaturating(long_in1[i], long_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void suadd_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.SUADD,\n-                               ByteVector.fromArray(bspec, byte_in2, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"suadd_byte\")\n-    public void suadd_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.addSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void suadd_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.SUADD,\n-                               ShortVector.fromArray(sspec, short_in2, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"suadd_short\")\n-    public void suadd_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.addSaturatingUnsigned(short_in1[i], short_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void suadd_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.SUADD,\n-                               IntVector.fromArray(ispec, int_in2, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"suadd_int\")\n-    public void suadd_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.addSaturatingUnsigned(int_in1[i], int_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SADD_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void suadd_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.SUADD,\n-                               LongVector.fromArray(lspec, long_in2, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"suadd_long\")\n-    public void suadd_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.addSaturatingUnsigned(long_in1[i], long_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VB, \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void ssub_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.SSUB,\n-                               ByteVector.fromArray(bspec, byte_in2, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"ssub_byte\")\n-    public void ssub_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.subSaturating(byte_in1[i], byte_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void ssub_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.SSUB,\n-                               ShortVector.fromArray(sspec, short_in2, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"ssub_short\")\n-    public void ssub_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.subSaturating(short_in1[i], short_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void ssub_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.SSUB,\n-                               IntVector.fromArray(ispec, int_in2, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"ssub_int\")\n-    public void ssub_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.subSaturating(int_in1[i], int_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void ssub_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.SSUB,\n-                               LongVector.fromArray(lspec, long_in2, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"ssub_long\")\n-    public void ssub_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.subSaturating(long_in1[i], long_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void susub_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.SUSUB,\n-                               ByteVector.fromArray(bspec, byte_in2, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"susub_byte\")\n-    public void susub_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.subSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void susub_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.SUSUB,\n-                               ShortVector.fromArray(sspec, short_in2, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"susub_short\")\n-    public void susub_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.subSaturatingUnsigned(short_in1[i], short_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void susub_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.SUSUB,\n-                               IntVector.fromArray(ispec, int_in2, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"susub_int\")\n-    public void susub_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.subSaturatingUnsigned(int_in1[i], int_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SSUB_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n-    @Warmup(value = 10000)\n-    public void susub_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.SUSUB,\n-                               LongVector.fromArray(lspec, long_in2, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"susub_long\")\n-    public void susub_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.subSaturatingUnsigned(long_in1[i], long_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorSaturatedOperationsTest.java","additions":0,"deletions":475,"binary":false,"changes":475,"status":"deleted"},{"patch":"@@ -0,0 +1,507 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8338201\n+* @summary Validate IR Transforms for new unsigned min\/max vector operations\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorUnsignedMinMaxIRTransformsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.stream.IntStream;\n+\n+public class VectorUnsignedMinMaxIRTransformsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public VectorUnsignedMinMaxIRTransformsTest() {\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT).forEach(\n+            i -> {\n+                if ((i & 1) == 0) {\n+                    long_in1[i] = Long.MAX_VALUE;\n+                    long_in2[i] = i;\n+                    int_in1[i]  = Integer.MAX_VALUE;\n+                    int_in2[i]  = i;\n+                    short_in1[i] = Short.MAX_VALUE;\n+                    short_in2[i] = (short)i;\n+                    byte_in1[i]  = Byte.MAX_VALUE;\n+                    byte_in2[i]  = (byte)i;\n+                } else {\n+                    long_in1[i] = Long.MIN_VALUE;\n+                    long_in2[i] = -i;\n+                    int_in1[i]  = Integer.MIN_VALUE;\n+                    int_in2[i]  = -i;\n+                    short_in1[i] = Short.MIN_VALUE;\n+                    short_in2[i] = (short)-i;\n+                    byte_in1[i]  = Byte.MIN_VALUE;\n+                    byte_in2[i]  = (byte)-i;\n+                }\n+            }\n+        );\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VB, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               ByteVector.fromArray(bspec, byte_in1, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_byte\")\n+    public void umin_ir_transform1_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.minUnsigned(byte_in1[i], byte_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VB, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               ByteVector.fromArray(bspec, byte_in1, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_byte\")\n+    public void umax_ir_transform1_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.maxUnsigned(byte_in1[i], byte_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VB, \" 0 \", IRNode.UMIN_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector vec1 = ByteVector.fromArray(bspec, byte_in1, i);\n+            ByteVector vec2 = ByteVector.fromArray(bspec, byte_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_byte\")\n+    public void umin_umax_ir_transform1_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = byte_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(byte_in1[i], byte_in2[i]),\n+                                                  VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VB, \" 0 \", IRNode.UMAX_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector vec1 = ByteVector.fromArray(bspec, byte_in1, i);\n+            ByteVector vec2 = ByteVector.fromArray(bspec, byte_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_byte\")\n+    public void umin_umax_ir_transform2_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(byte_in1[i], byte_in2[i]),\n+                                                   VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VS, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               ShortVector.fromArray(sspec, short_in1, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_short\")\n+    public void umin_ir_transform1_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.minUnsigned(short_in1[i], short_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VS, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               ShortVector.fromArray(sspec, short_in1, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_short\")\n+    public void umax_ir_transform1_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.maxUnsigned(short_in1[i], short_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VS, \" 0 \", IRNode.UMIN_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector vec1 = ShortVector.fromArray(sspec, short_in1, i);\n+            ShortVector vec2 = ShortVector.fromArray(sspec, short_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_short\")\n+    public void umin_umax_ir_transform1_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.minUnsigned(VectorMath.minUnsigned(short_in1[i], short_in2[i]),\n+                                                    VectorMath.maxUnsigned(short_in1[i], short_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VS, \" 0 \", IRNode.UMAX_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector vec1 = ShortVector.fromArray(sspec, short_in1, i);\n+            ShortVector vec2 = ShortVector.fromArray(sspec, short_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_short\")\n+    public void umin_umax_ir_transform2_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(short_in1[i], short_in2[i]),\n+                                                    VectorMath.maxUnsigned(short_in1[i], short_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_int\")\n+    public void umin_ir_transform1_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_int\")\n+    public void umax_ir_transform1_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_int\")\n+    public void umin_umax_ir_transform1_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_int\")\n+    public void umin_umax_ir_transform2_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VL, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               LongVector.fromArray(lspec, long_in1, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1_long\")\n+    public void umin_ir_transform1_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.minUnsigned(long_in1[i], long_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VL, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               LongVector.fromArray(lspec, long_in1, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1_long\")\n+    public void umax_ir_transform1_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.maxUnsigned(long_in1[i], long_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VL, \" 0 \", IRNode.UMIN_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform1_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector vec1 = LongVector.fromArray(lspec, long_in1, i);\n+            LongVector vec2 = LongVector.fromArray(lspec, long_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform1_long\")\n+    public void umin_umax_ir_transform1_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.minUnsigned(VectorMath.minUnsigned(long_in1[i], long_in2[i]),\n+                                                   VectorMath.maxUnsigned(long_in1[i], long_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VL, \" 0 \", IRNode.UMAX_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_umax_ir_transform2_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector vec1 = LongVector.fromArray(lspec, long_in1, i);\n+            LongVector vec2 = LongVector.fromArray(lspec, long_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_umax_ir_transform2_long\")\n+    public void umin_umax_ir_transform2_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(long_in1[i], int_in2[i]),\n+                                                   VectorMath.maxUnsigned(long_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxIRTransformsTest.java","additions":507,"deletions":0,"binary":false,"changes":507,"status":"added"},{"patch":"@@ -1,391 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-* @test\n-* @bug 8338201\n-* @summary Support new unsigned and saturating vector operators in VectorAPI\n-* @modules jdk.incubator.vector\n-* @requires vm.compiler2.enabled\n-* @library \/test\/lib \/\n-* @run driver compiler.vectorapi.VectorUnsignedMinMaxOperationsTest\n-*\/\n-\n-package compiler.vectorapi;\n-\n-import jdk.incubator.vector.*;\n-import compiler.lib.ir_framework.*;\n-import java.util.stream.IntStream;\n-\n-public class VectorUnsignedMinMaxOperationsTest {\n-    private static final int COUNT = 2048;\n-    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n-    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n-\n-    private long[]  long_in1;\n-    private int[]   int_in1;\n-    private short[] short_in1;\n-    private byte[]  byte_in1;\n-\n-    private long[]  long_in2;\n-    private int[]   int_in2;\n-    private short[] short_in2;\n-    private byte[]  byte_in2;\n-\n-    private long[]  long_out;\n-    private int[]   int_out;\n-    private short[] short_out;\n-    private byte[]  byte_out;\n-\n-    public static void main(String[] args) {\n-        TestFramework testFramework = new TestFramework();\n-        testFramework.setDefaultWarmup(5000)\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n-                     .start();\n-    }\n-\n-    public VectorUnsignedMinMaxOperationsTest() {\n-        byte_in1  = new byte[COUNT];\n-        short_in1 = new short[COUNT];\n-        int_in1   = new int[COUNT];\n-        long_in1  = new long[COUNT];\n-\n-        byte_in2  = new byte[COUNT];\n-        short_in2 = new short[COUNT];\n-        int_in2   = new int[COUNT];\n-        long_in2  = new long[COUNT];\n-        IntStream.range(0, COUNT).forEach(\n-            i -> {\n-                if ((i & 1) == 0) {\n-                    long_in1[i] = Long.MAX_VALUE;\n-                    long_in2[i] = i;\n-                    int_in1[i]  = Integer.MAX_VALUE;\n-                    int_in2[i]  = i;\n-                    short_in1[i] = Short.MAX_VALUE;\n-                    short_in2[i] = (short)i;\n-                    byte_in1[i]  = Byte.MAX_VALUE;\n-                    byte_in2[i]  = (byte)i;\n-                } else {\n-                    long_in1[i] = Long.MIN_VALUE;\n-                    long_in2[i] = -i;\n-                    int_in1[i]  = Integer.MIN_VALUE;\n-                    int_in2[i]  = -i;\n-                    short_in1[i] = Short.MIN_VALUE;\n-                    short_in2[i] = (short)-i;\n-                    byte_in1[i]  = Byte.MIN_VALUE;\n-                    byte_in2[i]  = (byte)-i;\n-                }\n-            }\n-        );\n-        long_out  = new long[COUNT];\n-        int_out   = new int[COUNT];\n-        short_out = new short[COUNT];\n-        byte_out  = new byte[COUNT];\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umax_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               ByteVector.fromArray(bspec, byte_in2, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_byte\")\n-    public void umax_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umax_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               ShortVector.fromArray(sspec, short_in2, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_short\")\n-    public void umax_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.maxUnsigned(short_in1[i], short_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umax_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               IntVector.fromArray(ispec, int_in2, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_int\")\n-    public void umax_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.maxUnsigned(int_in1[i], int_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umax_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               LongVector.fromArray(lspec, long_in2, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_long\")\n-    public void umax_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.maxUnsigned(long_in1[i], long_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umin_byte() {\n-        for (int i = 0; i < COUNT; i += bspec.length()) {\n-            ByteVector.fromArray(bspec, byte_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               ByteVector.fromArray(bspec, byte_in2, i))\n-                     .intoArray(byte_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_byte\")\n-    public void umin_byte_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            byte actual = byte_out[i];\n-            byte expected = VectorMath.minUnsigned(byte_in1[i], byte_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umin_short() {\n-        for (int i = 0; i < COUNT; i += sspec.length()) {\n-            ShortVector.fromArray(sspec, short_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               ShortVector.fromArray(sspec, short_in2, i))\n-                     .intoArray(short_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_short\")\n-    public void umin_short_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            short actual = short_out[i];\n-            short expected = VectorMath.minUnsigned(short_in1[i], short_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umin_int() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               IntVector.fromArray(ispec, int_in2, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_int\")\n-    public void umin_int_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.minUnsigned(int_in1[i], int_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umin_long() {\n-        for (int i = 0; i < COUNT; i += lspec.length()) {\n-            LongVector.fromArray(lspec, long_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               LongVector.fromArray(lspec, long_in2, i))\n-                     .intoArray(long_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_long\")\n-    public void umin_long_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            long actual = long_out[i];\n-            long expected = VectorMath.minUnsigned(long_in1[i], long_in2[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umin_ir_transform1() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.UMIN,\n-                               IntVector.fromArray(ispec, int_in1, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_ir_transform1\")\n-    public void umin_ir_transform1_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.minUnsigned(int_in1[i], int_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umax_ir_transform1() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector.fromArray(ispec, int_in1, i)\n-                     .lanewise(VectorOperators.UMAX,\n-                               IntVector.fromArray(ispec, int_in1, i))\n-                     .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umax_ir_transform1\")\n-    public void umax_ir_transform1_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.maxUnsigned(int_in1[i], int_in1[i]);\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umin_max_ir_transform1() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n-            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMIN,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_max_ir_transform1\")\n-    public void umin_max_ir_transform1_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n-                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n-    @Warmup(value = 10000)\n-    public void umin_max_ir_transform2() {\n-        for (int i = 0; i < COUNT; i += ispec.length()) {\n-            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n-            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n-            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n-            vec1.lanewise(VectorOperators.UMIN, vec2)\n-                .lanewise(VectorOperators.UMAX,\n-                          vec1.lanewise(VectorOperators.UMAX, vec2))\n-                .intoArray(int_out, i);\n-        }\n-    }\n-\n-    @Check(test = \"umin_max_ir_transform2\")\n-    public void umin_max_ir_transform2_verify() {\n-        for (int i = 0; i < COUNT; i++) {\n-            int actual = int_out[i];\n-            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n-                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n-            if (actual != expected) {\n-                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxOperationsTest.java","additions":0,"deletions":391,"binary":false,"changes":391,"status":"deleted"}]}