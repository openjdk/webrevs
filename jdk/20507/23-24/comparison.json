{"files":[{"patch":"@@ -2098,0 +2098,43 @@\n+Node* UMinVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  bool match1 = in(1)->Opcode() == Op_UMinV || in(1)->Opcode() == Op_UMaxV;\n+  bool match2 = in(2)->Opcode() == Op_UMinV || in(2)->Opcode() == Op_UMaxV;\n+  \/\/ UMin (UMin(a, b), UMax(a, b))  => UMin(a, b)\n+  \/\/ UMin (UMin(a, b), UMax(b, a))  => UMin(a, b)\n+  if (match1 && match2) {\n+    if ((in(1)->in(1) == in(2)->in(1) && in(1)->in(2) == in(2)->in(2)) ||\n+         (in(1)->in(2) == in(2)->in(1) && in(1)->in(1) == in(2)->in(2))) {\n+      return new UMinVNode(in(1)->in(1), in(1)->in(2), vect_type());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+Node* UMinVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMin (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* UMaxVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  bool match1 = in(1)->Opcode() == Op_UMinV || in(1)->Opcode() == Op_UMaxV;\n+  bool match2 = in(2)->Opcode() == Op_UMinV || in(2)->Opcode() == Op_UMaxV;\n+  \/\/ UMax (UMin(a, b), UMax(a, b))  => UMax(a, b)\n+  \/\/ UMax (UMin(a, b), UMax(b, a))  => UMax(a, b)\n+  if (match1 && match2) {\n+    if ((in(1)->in(1) == in(2)->in(1) && in(1)->in(2) == in(2)->in(2)) ||\n+         (in(1)->in(2) == in(2)->in(1) && in(1)->in(1) == in(2)->in(2))) {\n+      return new UMaxVNode(in(1)->in(1), in(1)->in(2), vect_type());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+Node* UMaxVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMax (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -161,0 +161,10 @@\n+\n+#ifndef PRODUCT\n+  \/\/ Print node specific info\n+  virtual void dump_spec(outputStream *st) const {\n+    TypeNode::dump_spec(st);\n+    st->print(\"%s\", _is_unsigned ? \"{unsigned_vector_node}\" : \"{signed_vector_node}\");\n+  }\n+#endif\n+  virtual uint hash() const { return Node::hash() + _is_unsigned; }\n+\n@@ -601,0 +611,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -617,0 +629,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -211,0 +211,2 @@\n+    case VECTOR_OP_UMIN:\n+    case VECTOR_OP_UMAX:\n@@ -222,0 +224,2 @@\n+    case VECTOR_OP_UMIN:\n+    case VECTOR_OP_UMAX:\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -252,0 +252,40 @@\n+    public static final String SADD_VB = VECTOR_PREFIX + \"SADD_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VB, \"SaturatingAddV\", TYPE_BYTE);\n+    }\n+\n+    public static final String SADD_VS = VECTOR_PREFIX + \"SADD_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VS, \"SaturatingAddV\", TYPE_SHORT);\n+    }\n+\n+    public static final String SADD_VI = VECTOR_PREFIX + \"SADD_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VI, \"SaturatingAddV\", TYPE_INT);\n+    }\n+\n+    public static final String SADD_VL = VECTOR_PREFIX + \"SADD_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VL, \"SaturatingAddV\", TYPE_LONG);\n+    }\n+\n+    public static final String SSUB_VB = VECTOR_PREFIX + \"SSUB_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VB, \"SaturatingSubV\", TYPE_BYTE);\n+    }\n+\n+    public static final String SSUB_VS = VECTOR_PREFIX + \"SSUB_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VS, \"SaturatingSubV\", TYPE_SHORT);\n+    }\n+\n+    public static final String SSUB_VI = VECTOR_PREFIX + \"SSUB_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VI, \"SaturatingSubV\", TYPE_INT);\n+    }\n+\n+    public static final String SSUB_VL = VECTOR_PREFIX + \"SSUB_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VL, \"SaturatingSubV\", TYPE_LONG);\n+    }\n+\n@@ -1111,0 +1151,40 @@\n+    public static final String UMIN_VB = VECTOR_PREFIX + \"UMIN_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VB, \"UMinV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMIN_VS = VECTOR_PREFIX + \"UMIN_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VS, \"UMinV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMIN_VI = VECTOR_PREFIX + \"UMIN_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VI, \"UMinV\", TYPE_INT);\n+    }\n+\n+    public static final String UMIN_VL = VECTOR_PREFIX + \"UMIN_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VL, \"UMinV\", TYPE_LONG);\n+    }\n+\n+    public static final String UMAX_VB = VECTOR_PREFIX + \"UMAX_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VB, \"UMaxV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMAX_VS = VECTOR_PREFIX + \"UMAX_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VS, \"UMaxV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMAX_VI = VECTOR_PREFIX + \"UMAX_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VI, \"UMaxV\", TYPE_INT);\n+    }\n+\n+    public static final String UMAX_VL = VECTOR_PREFIX + \"UMAX_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VL, \"UMaxV\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GT, 0).intoArray(ir, 0);\n+        av.compare(VectorOperators.UGT, 0).intoArray(ir, 0);\n@@ -250,1 +250,1 @@\n-        av.compare(VectorOperators.UNSIGNED_GE, 0).intoArray(lr, 0);\n+        av.compare(VectorOperators.UGE, 0).intoArray(lr, 0);\n@@ -260,1 +260,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompareWithZeroTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,475 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8338201\n+* @summary Support new unsigned and saturating vector operators in VectorAPI\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorSaturatedOperationsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.stream.IntStream;\n+\n+public class VectorSaturatedOperationsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public VectorSaturatedOperationsTest() {\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT).forEach(\n+            i -> {\n+                if ((i & 1) == 0) {\n+                    long_in1[i] = Long.MAX_VALUE;\n+                    long_in2[i] = i;\n+                    int_in1[i]  = Integer.MAX_VALUE;\n+                    int_in2[i]  = i;\n+                    short_in1[i] = Short.MAX_VALUE;\n+                    short_in2[i] = (short)i;\n+                    byte_in1[i]  = Byte.MAX_VALUE;\n+                    byte_in2[i]  = (byte)i;\n+                } else {\n+                    long_in1[i] = Long.MIN_VALUE;\n+                    long_in2[i] = -i;\n+                    int_in1[i]  = Integer.MIN_VALUE;\n+                    int_in2[i]  = -i;\n+                    short_in1[i] = Short.MIN_VALUE;\n+                    short_in2[i] = (short)-i;\n+                    byte_in1[i]  = Byte.MIN_VALUE;\n+                    byte_in2[i]  = (byte)-i;\n+                }\n+            }\n+        );\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void sadd_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_byte\")\n+    public void sadd_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.addSaturating(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void sadd_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_short\")\n+    public void sadd_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.addSaturating(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void sadd_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_int\")\n+    public void sadd_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.addSaturating(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void sadd_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_long\")\n+    public void sadd_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.addSaturating(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void suadd_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_byte\")\n+    public void suadd_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.addSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void suadd_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_short\")\n+    public void suadd_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.addSaturatingUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void suadd_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_int\")\n+    public void suadd_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.addSaturatingUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void suadd_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_long\")\n+    public void suadd_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.addSaturatingUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VB, \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void ssub_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_byte\")\n+    public void ssub_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.subSaturating(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void ssub_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_short\")\n+    public void ssub_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.subSaturating(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void ssub_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_int\")\n+    public void ssub_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.subSaturating(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void ssub_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_long\")\n+    public void ssub_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.subSaturating(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void susub_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_byte\")\n+    public void susub_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.subSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void susub_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_short\")\n+    public void susub_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.subSaturatingUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void susub_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_int\")\n+    public void susub_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.subSaturatingUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIf = {\"UseAVX\", \" >=1 \"})\n+    @Warmup(value = 10000)\n+    public void susub_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_long\")\n+    public void susub_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.subSaturatingUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorSaturatedOperationsTest.java","additions":475,"deletions":0,"binary":false,"changes":475,"status":"added"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8338201\n+* @summary Support new unsigned and saturating vector operators in VectorAPI\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorUnsignedMinMaxOperationsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.stream.IntStream;\n+\n+public class VectorUnsignedMinMaxOperationsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public VectorUnsignedMinMaxOperationsTest() {\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT).forEach(\n+            i -> {\n+                if ((i & 1) == 0) {\n+                    long_in1[i] = Long.MAX_VALUE;\n+                    long_in2[i] = i;\n+                    int_in1[i]  = Integer.MAX_VALUE;\n+                    int_in2[i]  = i;\n+                    short_in1[i] = Short.MAX_VALUE;\n+                    short_in2[i] = (short)i;\n+                    byte_in1[i]  = Byte.MAX_VALUE;\n+                    byte_in2[i]  = (byte)i;\n+                } else {\n+                    long_in1[i] = Long.MIN_VALUE;\n+                    long_in2[i] = -i;\n+                    int_in1[i]  = Integer.MIN_VALUE;\n+                    int_in2[i]  = -i;\n+                    short_in1[i] = Short.MIN_VALUE;\n+                    short_in2[i] = (short)-i;\n+                    byte_in1[i]  = Byte.MIN_VALUE;\n+                    byte_in2[i]  = (byte)-i;\n+                }\n+            }\n+        );\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_byte\")\n+    public void umax_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_short\")\n+    public void umax_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.maxUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_int\")\n+    public void umax_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_long\")\n+    public void umax_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.maxUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VB, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_byte\")\n+    public void umin_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.minUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VS, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_short\")\n+    public void umin_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.minUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_int\")\n+    public void umin_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VL, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_long\")\n+    public void umin_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.minUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1\")\n+    public void umin_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1\")\n+    public void umax_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform1\")\n+    public void umin_max_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIf = {\"UseAVX\", \" >0 \"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform2() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform2\")\n+    public void umin_max_ir_transform2_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxOperationsTest.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"}]}