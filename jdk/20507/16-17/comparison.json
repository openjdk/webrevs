{"files":[{"patch":"@@ -1,278 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.vectorapi;\n-\n-import jdk.incubator.vector.VectorMath;\n-import java.util.stream.IntStream;\n-\n-\/*\n- * @test\n- * @bug 8338021\n- * @summary Support new unsigned and saturating vector operators in VectorAPI\n- * @modules jdk.incubator.vector\n- * @library \/test\/lib\n- *\n- * @run main compiler.vectorapi.VectorMathTests\n- *\/\n-\n-\n-public class VectorMathTests {\n-    public static final byte  ZEROB = (byte)0;\n-    public static final short ZEROS = (short)0;\n-    public static final int   ZEROI = 0;\n-    public static final long  ZEROL = 0L;\n-\n-    public static final byte  TENB = (byte)10;\n-    public static final int   TENS = (short)10;\n-    public static final short TENI = 10;\n-    public static final long  TENL = 10L;\n-\n-    public static final byte  FIFTYB = (byte)50;\n-    public static final int   FIFTYS = (short)50;\n-    public static final short FIFTYI = 50;\n-    public static final long  FIFTYL = 50L;\n-\n-    public static final byte  SIXTYB = (byte)60;\n-    public static final int   SIXTYS = (short)60;\n-    public static final short SIXTYI = 60;\n-    public static final long  SIXTYL = 60L;\n-\n-    public static final byte  UMAXB = (byte)-1;\n-    public static final short UMAXS = (short)-1;\n-    public static final int   UMAXI = -1;\n-    public static final long  UMAXL = -1L;\n-\n-    public static byte  [] sbinput = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TENB),   ZEROB, (byte)(Byte.MAX_VALUE - TENB),   Byte.MAX_VALUE};\n-    public static short [] ssinput = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TENS), ZEROS, (short)(Short.MAX_VALUE - TENS), Short.MAX_VALUE};\n-    public static int   [] siinput = {Integer.MIN_VALUE, (Integer.MIN_VALUE + TENI),      ZEROI, Integer.MAX_VALUE - TENI,        Integer.MAX_VALUE};\n-    public static long  [] slinput = {Long.MIN_VALUE,    Long.MIN_VALUE + TENL,           ZEROL, Long.MAX_VALUE - TENL,           Long.MAX_VALUE};\n-\n-    public static int   [] saddended    = {-FIFTYI,           -FIFTYI,           -FIFTYI, FIFTYI,            FIFTYI};\n-    public static byte  [] boutput_sadd = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTYB, Byte.MAX_VALUE,    Byte.MAX_VALUE};\n-    public static short [] soutput_sadd = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTYS, Short.MAX_VALUE,   Short.MAX_VALUE};\n-    public static int   [] ioutput_sadd = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTYI, Integer.MAX_VALUE, Integer.MAX_VALUE};\n-    public static long  [] loutput_sadd = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTYL, Long.MAX_VALUE,    Long.MAX_VALUE};\n-\n-    public static int   [] ssubtrahend  = {FIFTYI,            FIFTYI,             FIFTYI, -FIFTYI,           -FIFTYI};\n-    public static byte  [] boutput_ssub = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTYB, Byte.MAX_VALUE,    Byte.MAX_VALUE};\n-    public static short [] soutput_ssub = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTYS, Short.MAX_VALUE,   Short.MAX_VALUE};\n-    public static int   [] ioutput_ssub = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTYI, Integer.MAX_VALUE, Integer.MAX_VALUE};\n-    public static long  [] loutput_ssub = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTYL, Long.MAX_VALUE,    Long.MAX_VALUE};\n-\n-    public static byte  [] ubinput = {ZEROB, (byte)(ZEROB + TENB),  (byte)(UMAXB - TENB),  UMAXB};\n-    public static short [] usinput = {ZEROS, (short)(ZEROS + TENS), (short)(UMAXS - TENS), UMAXS};\n-    public static int   [] uiinput = {ZEROI, ZEROI + TENI,          UMAXI - TENI,          UMAXI};\n-    public static long  [] ulinput = {ZEROL, ZEROL + TENL,          UMAXL - TENL,          UMAXL};\n-\n-    public static int   [] uaddended     = {FIFTYI, FIFTYI, FIFTYI, FIFTYI};\n-    public static byte  [] boutput_usadd = {FIFTYB, SIXTYB, UMAXB,  UMAXB};\n-    public static short [] soutput_usadd = {FIFTYS, SIXTYS, UMAXS,  UMAXS};\n-    public static int   [] ioutput_usadd = {FIFTYI, SIXTYI, UMAXI,  UMAXI};\n-    public static long  [] loutput_usadd = {FIFTYL, SIXTYL, UMAXL,  UMAXL};\n-\n-    public static int   [] usubtrahend   = {FIFTYI, FIFTYI, FIFTYI, FIFTYI};\n-    public static byte  [] boutput_ussub = {ZEROB,  ZEROB,  UMAXB - SIXTYB,  UMAXB - FIFTYB};\n-    public static short [] soutput_ussub = {ZEROS,  ZEROS,  UMAXS - SIXTYS,  UMAXS - FIFTYS};\n-    public static int   [] ioutput_ussub = {ZEROI,  ZEROI,  UMAXI - SIXTYI,  UMAXI - FIFTYI};\n-    public static long  [] loutput_ussub = {ZEROL,  ZEROL,  UMAXL - SIXTYL,  UMAXL - FIFTYL};\n-\n-    public static byte  [] boutput_umin = {ZEROB, TENB, ZEROB, Byte.MAX_VALUE - TENB};\n-    public static short [] soutput_umin = {ZEROS, TENS, ZEROS, Short.MAX_VALUE - TENS};\n-    public static int   [] ioutput_umin = {ZEROI, TENI, ZEROI, Integer.MAX_VALUE - TENI};\n-    public static long  [] loutput_umin = {ZEROL, TENL, ZEROL, Long.MAX_VALUE - TENL};\n-\n-    public static byte  [] boutput_umax = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TENB),   (byte)(UMAXB - TENB),  UMAXB};\n-    public static short [] soutput_umax = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TENS), (short)(UMAXS - TENS), UMAXS};\n-    public static int   [] ioutput_umax = {Integer.MIN_VALUE, Integer.MIN_VALUE + TENI,        (UMAXI - TENI),        UMAXI};\n-    public static long  [] loutput_umax = {Long.MIN_VALUE,    Long.MIN_VALUE + TENL,           (UMAXL - TENL),        UMAXL};\n-\n-    public static void test_saturated_add(Class<?> type) {\n-        if (type == byte.class) {\n-            IntStream.range(0, sbinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturating(sbinput[i], (byte)saddended[i]),\n-                                                                         boutput_sadd[i],\n-                                                                         \"[addSaturating byte] idx = \" + i + \" : \"));\n-        } else if (type == short.class) {\n-            IntStream.range(0, ssinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturating(ssinput[i], (short)saddended[i]),\n-                                                                         soutput_sadd[i],\n-                                                                         \"[addSaturating short] idx = \" + i + \" : \"));\n-        } else if (type == int.class) {\n-            IntStream.range(0, siinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturating(siinput[i], saddended[i]),\n-                                                                         ioutput_sadd[i],\n-                                                                         \"[addSaturating int] idx = \" + i + \" : \"));\n-        } else if (type == long.class) {\n-            IntStream.range(0, slinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturating(slinput[i], (long)saddended[i]),\n-                                                                         loutput_sadd[i],\n-                                                                         \"[addSaturating long] idx = \" + i + \" : \"));\n-        }\n-    }\n-\n-    public static void test_saturated_sub(Class<?> type) {\n-        if (type == byte.class) {\n-            IntStream.range(0, sbinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturating(sbinput[i], (byte)ssubtrahend[i]),\n-                                                                         boutput_ssub[i],\n-                                                                         \"[subSaturating byte] idx = \" + i + \" : \"));\n-        } else if (type == short.class) {\n-            IntStream.range(0, ssinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturating(ssinput[i], (short)ssubtrahend[i]),\n-                                                                         soutput_ssub[i],\n-                                                                         \"[subSaturating short] idx = \" + i + \" : \"));\n-        } else if (type == int.class) {\n-            IntStream.range(0, siinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturating(siinput[i], ssubtrahend[i]),\n-                                                                         ioutput_ssub[i],\n-                                                                         \"[subSaturating int] idx = \" + i + \" : \"));\n-        } else if (type == long.class) {\n-            IntStream.range(0, slinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturating(slinput[i], (long)ssubtrahend[i]),\n-                                                                         loutput_ssub[i],\n-                                                                         \"[subSaturating long] idx = \" + i + \" : \"));\n-        }\n-    }\n-\n-    public static void test_saturated_uadd(Class<?> type) {\n-        if (type == byte.class) {\n-            IntStream.range(0, ubinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(ubinput[i], (byte)uaddended[i]),\n-                                                                                 boutput_usadd[i],\n-                                                                                 \"[addSaturatingUnsigned byte] idx = \" + i + \" : \"));\n-        } else if (type == short.class) {\n-            IntStream.range(0, usinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(usinput[i], (short)uaddended[i]),\n-                                                                                 soutput_usadd[i],\n-                                                                                 \"[addSaturatingUnsigned short] idx = \" + i + \" : \"));\n-        } else if (type == int.class) {\n-            IntStream.range(0, uiinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(uiinput[i], uaddended[i]),\n-                                                                                 ioutput_usadd[i],\n-                                                                                 \"[addSaturatingUnsigned int] idx = \" + i + \" : \"));\n-        } else if (type == long.class) {\n-            IntStream.range(0, ulinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(ulinput[i], (long)uaddended[i]),\n-                                                                                 loutput_usadd[i],\n-                                                                                 \"[addSaturatingUnsigned long] idx = \" + i + \" : \"));\n-        }\n-    }\n-\n-    public static void test_saturated_usub(Class<?> type) {\n-        if (type == byte.class) {\n-            IntStream.range(0, ubinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(ubinput[i], (byte)usubtrahend[i]),\n-                                                                                 boutput_ussub[i],\n-                                                                                 \"[subSaturatingUnsigned byte] idx = \" + i + \" : \"));\n-        } else if (type == short.class) {\n-            IntStream.range(0, usinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(usinput[i], (short)usubtrahend[i]),\n-                                                                                 soutput_ussub[i],\n-                                                                                 \"[subSaturatingUnsigned short] idx = \" + i + \" : \"));\n-        } else if (type == int.class) {\n-            IntStream.range(0, uiinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(uiinput[i], usubtrahend[i]),\n-                                                                                 ioutput_ussub[i],\n-                                                                                 \"[subSaturatingUnsigned int] idx = \" + i + \" : \"));\n-        } else if (type == long.class) {\n-            IntStream.range(0, ulinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(ulinput[i], (long)usubtrahend[i]),\n-                                                                                 loutput_ussub[i],\n-                                                                                 \"[subSaturatingUnsigned long] idx = \" + i + \" : \"));\n-        }\n-    }\n-\n-    public static void test_umin(Class<?> type) {\n-        if (type == byte.class) {\n-            IntStream.range(0, ubinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.minUnsigned(ubinput[i], sbinput[i]), boutput_umin[i], \"[minUnsigned byte] idx = \" + i + \" : \"));\n-        } else if (type == short.class) {\n-            IntStream.range(0, usinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.minUnsigned(usinput[i], ssinput[i]), soutput_umin[i], \"[minUnsigned short] idx = \" + i + \" : \"));\n-        } else if (type == int.class) {\n-            IntStream.range(0, uiinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.minUnsigned(uiinput[i], siinput[i]), ioutput_umin[i], \"[minUnsigned int] idx = \" + i + \" : \"));\n-        } else if (type == long.class) {\n-            IntStream.range(0, ulinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.minUnsigned(ulinput[i], slinput[i]), loutput_umin[i], \"[minUnsigned long] idx = \" + i + \" : \"));\n-        }\n-    }\n-\n-    public static void test_umax(Class<?> type) {\n-        if (type == byte.class) {\n-            IntStream.range(0, ubinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(ubinput[i], sbinput[i]), boutput_umax[i], \"[maxUnsigned byte] idx = \" + i + \" : \"));\n-        } else if (type == short.class) {\n-            IntStream.range(0, usinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(usinput[i], ssinput[i]), soutput_umax[i], \"[maxUnsigned short] idx = \" + i + \" : \"));\n-        } else if (type == int.class) {\n-            IntStream.range(0, uiinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(uiinput[i], siinput[i]), ioutput_umax[i], \"[maxUnsigned int] idx = \" + i + \" : \"));\n-        } else if (type == long.class) {\n-            IntStream.range(0, ulinput.length)\n-                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(ulinput[i], slinput[i]), loutput_umax[i], \"[maxUnsigned long] idx = \" + i + \" : \"));\n-        }\n-    }\n-\n-    public static void assertEquals(Number res, Number ref, String msg) {\n-        if (!res.equals(ref)) {\n-            throw new RuntimeException(msg +  ref + \"(ref)  != \" + res + \"(res)\");\n-        }\n-    }\n-\n-    public static void main(String [] args) {\n-        for (int i = 0; i < 1; i++) {\n-            test_saturated_add(byte.class);\n-            test_saturated_add(short.class);\n-            test_saturated_add(int.class);\n-            test_saturated_add(long.class);\n-\n-            test_saturated_sub(byte.class);\n-            test_saturated_sub(short.class);\n-            test_saturated_sub(int.class);\n-            test_saturated_sub(long.class);\n-\n-            test_saturated_uadd(byte.class);\n-            test_saturated_uadd(short.class);\n-            test_saturated_uadd(int.class);\n-            test_saturated_uadd(long.class);\n-\n-            test_saturated_usub(byte.class);\n-            test_saturated_usub(short.class);\n-            test_saturated_usub(int.class);\n-            test_saturated_usub(long.class);\n-\n-            test_umin(byte.class);\n-            test_umin(short.class);\n-            test_umin(int.class);\n-            test_umin(long.class);\n-\n-            test_umax(byte.class);\n-            test_umax(short.class);\n-            test_umax(int.class);\n-            test_umax(long.class);\n-        }\n-        System.out.println(\"PASSED\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMathTests.java","additions":0,"deletions":278,"binary":false,"changes":278,"status":"deleted"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338021\n+ * @summary Test unsigned and saturating scalar operators for use with Vector API\n+ * @modules jdk.incubator.vector\n+ * @run testng VectorMathTest\n+ *\/\n+\n+import jdk.incubator.vector.VectorMath;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Array;\n+import java.util.function.BinaryOperator;\n+\n+public class VectorMathTest {\n+    \/\/ @formatter:off\n+    public static final byte  ZERO_B = (byte)0;\n+    public static final short ZERO_S = (short)0;\n+    public static final int   ZERO_I = 0;\n+    public static final long  ZERO_L = 0L;\n+\n+    public static final byte  TEN_B = (byte)10;\n+    public static final int   TEN_S = (short)10;\n+    public static final short TEN_I = 10;\n+    public static final long  TEN_L = 10L;\n+\n+    public static final byte  FIFTY_B = (byte)50;\n+    public static final int   FIFTY_S = (short)50;\n+    public static final short FIFTY_I = 50;\n+    public static final long  FIFTY_L = 50L;\n+\n+    public static final byte  SIXTY_B = (byte)60;\n+    public static final int   SIXTY_S = (short)60;\n+    public static final short SIXTY_I = 60;\n+    public static final long  SIXTY_L = 60L;\n+\n+    public static final byte  UMAX_B = (byte)-1;\n+    public static final short UMAX_S = (short)-1;\n+    public static final int   UMAX_I = -1;\n+    public static final long  UMAX_L = -1L;\n+\n+    public static byte[]  INPUT_SB = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TEN_B),   ZERO_B, (byte)(Byte.MAX_VALUE - TEN_B),   Byte.MAX_VALUE};\n+    public static short[] INPUT_SS = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TEN_S), ZERO_S, (short)(Short.MAX_VALUE - TEN_S), Short.MAX_VALUE};\n+    public static int[]   INPUT_SI = {Integer.MIN_VALUE, (Integer.MIN_VALUE + TEN_I),      ZERO_I, Integer.MAX_VALUE - TEN_I,        Integer.MAX_VALUE};\n+    public static long[]  INPUT_SL = {Long.MIN_VALUE,    Long.MIN_VALUE + TEN_L,           ZERO_L, Long.MAX_VALUE - TEN_L,           Long.MAX_VALUE};\n+\n+    public static int[]   INPUT_SADD_I    = {-FIFTY_I,          -FIFTY_I,          -FIFTY_I, FIFTY_I,           FIFTY_I};\n+    public static byte[]  EXPECTED_SADD_B = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTY_B, Byte.MAX_VALUE,    Byte.MAX_VALUE};\n+    public static short[] EXPECTED_SADD_S = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTY_S, Short.MAX_VALUE,   Short.MAX_VALUE};\n+    public static int[]   EXPECTED_SADD_I = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTY_I, Integer.MAX_VALUE, Integer.MAX_VALUE};\n+    public static long[]  EXPECTED_SADD_L = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTY_L, Long.MAX_VALUE,    Long.MAX_VALUE};\n+\n+    public static int[]   INPUT_SSUB_I    = {FIFTY_I,           FIFTY_I,            FIFTY_I, -FIFTY_I,          -FIFTY_I};\n+    public static byte[]  EXPECTED_SSUB_B = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTY_B, Byte.MAX_VALUE,    Byte.MAX_VALUE};\n+    public static short[] EXPECTED_SSUB_S = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTY_S, Short.MAX_VALUE,   Short.MAX_VALUE};\n+    public static int[]   EXPECTED_SSUB_I = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTY_I, Integer.MAX_VALUE, Integer.MAX_VALUE};\n+    public static long[]  EXPECTED_SSUB_L = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTY_L, Long.MAX_VALUE,    Long.MAX_VALUE};\n+\n+    public static byte[]  INPUT_UB = {ZERO_B, (byte)(ZERO_B + TEN_B),  (byte)(UMAX_B - TEN_B),  UMAX_B};\n+    public static short[] INPUT_US = {ZERO_S, (short)(ZERO_S + TEN_S), (short)(UMAX_S - TEN_S), UMAX_S};\n+    public static int[]   INPUT_UI = {ZERO_I, ZERO_I + TEN_I,          UMAX_I - TEN_I,          UMAX_I};\n+    public static long[]  INPUT_UL = {ZERO_L, ZERO_L + TEN_L,          UMAX_L - TEN_L,          UMAX_L};\n+\n+    public static int[]   INPUT_SUADD_I    = {FIFTY_I, FIFTY_I, FIFTY_I, FIFTY_I};\n+    public static byte[]  EXPECTED_SUADD_B = {FIFTY_B, SIXTY_B, UMAX_B,  UMAX_B};\n+    public static short[] EXPECTED_SUADD_S = {FIFTY_S, SIXTY_S, UMAX_S,  UMAX_S};\n+    public static int[]   EXPECTED_SUADD_I = {FIFTY_I, SIXTY_I, UMAX_I,  UMAX_I};\n+    public static long[]  EXPECTED_SUADD_L = {FIFTY_L, SIXTY_L, UMAX_L,  UMAX_L};\n+\n+    public static int[]   INPUT_SUSUB_I    = {FIFTY_I, FIFTY_I, FIFTY_I,           FIFTY_I};\n+    public static byte[]  EXPECTED_SUSUB_B = {ZERO_B,  ZERO_B,  UMAX_B - SIXTY_B,  UMAX_B - FIFTY_B};\n+    public static short[] EXPECTED_SUSUB_S = {ZERO_S,  ZERO_S,  UMAX_S - SIXTY_S,  UMAX_S - FIFTY_S};\n+    public static int[]   EXPECTED_SUSUB_I = {ZERO_I,  ZERO_I,  UMAX_I - SIXTY_I,  UMAX_I - FIFTY_I};\n+    public static long[]  EXPECTED_SUSUB_L = {ZERO_L,  ZERO_L,  UMAX_L - SIXTY_L,  UMAX_L - FIFTY_L};\n+\n+    public static byte[]  EXPECTED_UMIN_B = {ZERO_B, TEN_B, ZERO_B, Byte.MAX_VALUE - TEN_B};\n+    public static short[] EXPECTED_UMIN_S = {ZERO_S, TEN_S, ZERO_S, Short.MAX_VALUE - TEN_S};\n+    public static int[]   EXPECTED_UMIN_I = {ZERO_I, TEN_I, ZERO_I, Integer.MAX_VALUE - TEN_I};\n+    public static long[]  EXPECTED_UMIN_L = {ZERO_L, TEN_L, ZERO_L, Long.MAX_VALUE - TEN_L};\n+\n+    public static byte[]  EXPECTED_UMAX_B = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TEN_B),   (byte)(UMAX_B - TEN_B),  UMAX_B};\n+    public static short[] EXPECTED_UMAX_S = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TEN_S), (short)(UMAX_S - TEN_S), UMAX_S};\n+    public static int[]   EXPECTED_UMAX_I = {Integer.MIN_VALUE, Integer.MIN_VALUE + TEN_I,        (UMAX_I - TEN_I),        UMAX_I};\n+    public static long[]  EXPECTED_UMAX_L = {Long.MIN_VALUE,    Long.MIN_VALUE + TEN_L,           (UMAX_L - TEN_L),        UMAX_L};\n+    \/\/ @formatter:on\n+\n+    static Object conv(Object a, Class<?> ct) {\n+        Object na = Array.newInstance(ct, Array.getLength(a));\n+        for (int i = 0; i < Array.getLength(a); i++) {\n+            Number number = (Number) Array.get(a, i);\n+            if (ct == byte.class) {\n+                number = number.byteValue();\n+            } else if (ct == short.class) {\n+                number = number.shortValue();\n+            } else if (ct == int.class) {\n+                number = number.intValue();\n+            } else if (ct == long.class) {\n+                number = number.longValue();\n+            } else {\n+                assert false : \"should not reach here\";\n+            }\n+            Array.set(na, i, number);\n+        }\n+        return na;\n+    }\n+\n+    static <T> BinaryOperator<T> named(String name, BinaryOperator<T> op) {\n+        return new BinaryOperator<T>() {\n+            @Override\n+            public T apply(T a, T b) {\n+                return op.apply(a, b);\n+            }\n+\n+            public String toString() {\n+                return name;\n+            }\n+        };\n+    }\n+\n+    static final BinaryOperator<Object> OP_UMIN = named(\"minUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.minUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.minUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.minUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.minUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_UMAX = named(\"maxUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.maxUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.maxUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.maxUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.maxUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SADD = named(\"addSaturating\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.addSaturating((byte) a, (byte) b);\n+                case Short _ -> VectorMath.addSaturating((short) a, (short) b);\n+                case Integer _ -> VectorMath.addSaturating((int) a, (int) b);\n+                case Long _ -> VectorMath.addSaturating((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SSUB = named(\"subSaturating\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.subSaturating((byte) a, (byte) b);\n+                case Short _ -> VectorMath.subSaturating((short) a, (short) b);\n+                case Integer _ -> VectorMath.subSaturating((int) a, (int) b);\n+                case Long _ -> VectorMath.subSaturating((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SUADD = named(\"addSaturatingUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.addSaturatingUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.addSaturatingUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.addSaturatingUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.addSaturatingUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    static final BinaryOperator<Object> OP_SUSUB = named(\"subSaturatingUnsigned\",\n+            (a, b) -> switch (a) {\n+                case Byte _ -> VectorMath.subSaturatingUnsigned((byte) a, (byte) b);\n+                case Short _ -> VectorMath.subSaturatingUnsigned((short) a, (short) b);\n+                case Integer _ -> VectorMath.subSaturatingUnsigned((int) a, (int) b);\n+                case Long _ -> VectorMath.subSaturatingUnsigned((long) a, (long) b);\n+                default -> throw new UnsupportedOperationException(\"should not reach here\");\n+            });\n+\n+    @DataProvider\n+    public static Object[][] opProvider() {\n+        return new Object[][] {\n+                {OP_UMIN, byte.class, INPUT_UB, INPUT_SB, EXPECTED_UMIN_B, },\n+                {OP_UMIN, short.class, INPUT_US, INPUT_SS, EXPECTED_UMIN_S, },\n+                {OP_UMIN, int.class, INPUT_UI, INPUT_SI, EXPECTED_UMIN_I, },\n+                {OP_UMIN, long.class, INPUT_UL, INPUT_SL, EXPECTED_UMIN_L, },\n+\n+                {OP_UMAX, byte.class, INPUT_UB, INPUT_SB, EXPECTED_UMAX_B, },\n+                {OP_UMAX, short.class, INPUT_US, INPUT_SS, EXPECTED_UMAX_S, },\n+                {OP_UMAX, int.class, INPUT_UI, INPUT_SI, EXPECTED_UMAX_I, },\n+                {OP_UMAX, long.class, INPUT_UL, INPUT_SL, EXPECTED_UMAX_L, },\n+\n+                {OP_SADD, byte.class, INPUT_SB, conv(INPUT_SADD_I, byte.class), EXPECTED_SADD_B, },\n+                {OP_SADD, short.class, INPUT_SS, conv(INPUT_SADD_I, short.class), EXPECTED_SADD_S, },\n+                {OP_SADD, int.class, INPUT_SI, INPUT_SADD_I, EXPECTED_SADD_I, },\n+                {OP_SADD, long.class, INPUT_SL, conv(INPUT_SADD_I, long.class), EXPECTED_SADD_L, },\n+\n+                {OP_SSUB, byte.class, INPUT_SB, conv(INPUT_SSUB_I, byte.class), EXPECTED_SSUB_B, },\n+                {OP_SSUB, short.class, INPUT_SS, conv(INPUT_SSUB_I, short.class), EXPECTED_SSUB_S, },\n+                {OP_SSUB, int.class, INPUT_SI, INPUT_SSUB_I, EXPECTED_SSUB_I, },\n+                {OP_SSUB, long.class, INPUT_SL, conv(INPUT_SSUB_I, long.class), EXPECTED_SSUB_L, },\n+\n+                {OP_SUADD, byte.class, INPUT_UB, conv(INPUT_SUADD_I, byte.class), EXPECTED_SUADD_B, },\n+                {OP_SUADD, short.class, INPUT_US, conv(INPUT_SUADD_I, short.class), EXPECTED_SUADD_S, },\n+                {OP_SUADD, int.class, INPUT_UI, INPUT_SUADD_I, EXPECTED_SUADD_I, },\n+                {OP_SUADD, long.class, INPUT_UL, conv(INPUT_SUADD_I, long.class), EXPECTED_SUADD_L, },\n+\n+                {OP_SUSUB, byte.class, INPUT_UB, conv(INPUT_SUSUB_I, byte.class), EXPECTED_SUSUB_B, },\n+                {OP_SUSUB, short.class, INPUT_US, conv(INPUT_SUSUB_I, short.class), EXPECTED_SUSUB_S, },\n+                {OP_SUSUB, int.class, INPUT_UI, INPUT_SUSUB_I, EXPECTED_SUSUB_I, },\n+                {OP_SUSUB, long.class, INPUT_UL, conv(INPUT_SUSUB_I, long.class), EXPECTED_SUSUB_L, },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"opProvider\")\n+    public void test(BinaryOperator<Object> op, Class<?> type, Object a, Object b, Object expected) {\n+        assert Array.getLength(a) <= Array.getLength(b) && Array.getLength(a) <= Array.getLength(expected);\n+\n+        Object actual = Array.newInstance(type, Array.getLength(a));\n+        for (int i = 0; i < Array.getLength(a); i++) {\n+            Object e = op.apply(Array.get(a, i), Array.get(b, i));\n+            Array.set(actual, i, e);\n+        }\n+        Assert.assertEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorMathTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"}]}