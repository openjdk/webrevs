{"files":[{"patch":"@@ -560,0 +560,6 @@\n+bool Assembler::needs_evex(XMMRegister reg1, XMMRegister reg2, XMMRegister reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+\n@@ -3447,0 +3453,13 @@\n+void Assembler::evmovdquw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x6F, (0xC0 | encode));\n+}\n+\n+\n@@ -4555,0 +4574,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4563,0 +4583,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4575,0 +4596,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4587,0 +4609,9 @@\n+void Assembler::evpcmpub(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x3E, (0xC0 | encode), vcc);\n+}\n+\n@@ -4588,0 +4619,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4595,0 +4627,8 @@\n+void Assembler::evpcmpud(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1E, (0xC0 | encode), vcc);\n+}\n+\n@@ -4596,1 +4636,1 @@\n-  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4605,0 +4645,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4618,0 +4659,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4630,0 +4672,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -7657,0 +7700,139 @@\n+void Assembler::vpaddsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xEC, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xEC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpaddsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xED, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xED);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpaddusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDC, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n+void Assembler::vpaddusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDD, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n+void Assembler::vpsubsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE8, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE9, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds, src)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD9, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && ((vector_len < Assembler::AVX_512bit && !needs_evex(dst, nds)) || VM_Version::supports_avx512bw()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n@@ -7686,7 +7868,0 @@\n-void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n-}\n-\n@@ -7869,8 +8044,0 @@\n-void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n-        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16(0xDA, (0xC0 | encode));\n-}\n-\n@@ -8022,15 +8189,6 @@\n-\/\/ Shift packed integers left by specified number of bits.\n-void Assembler::psllw(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n-}\n-\n-void Assembler::pslld(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDA, (0xC0 | encode));\n@@ -8039,6 +8197,9 @@\n-void Assembler::psllq(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDA);\n+  emit_operand(dst, src, 0);\n@@ -8047,5 +8208,10 @@\n-void Assembler::psllw(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n+void Assembler::evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDA, (0xC0 | encode));\n@@ -8054,5 +8220,13 @@\n-void Assembler::pslld(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF2, (0xC0 | encode));\n+void Assembler::evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDA);\n+  emit_operand(dst, src, 0);\n@@ -8061,6 +8235,6 @@\n-void Assembler::psllq(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_rex_vex_w_reverted();\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF3, (0xC0 | encode));\n+void Assembler::vpminuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3A, (0xC0 | encode));\n@@ -8069,2 +8243,4 @@\n-void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n+void Assembler::vpminuw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n@@ -8072,3 +8248,4 @@\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n-  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3A);\n+  emit_operand(dst, src, 0);\n@@ -8077,7 +8254,10 @@\n-void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n-  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+void Assembler::evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3A, (0xC0 | encode));\n@@ -8086,7 +8266,13 @@\n-void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_rex_vex_w_reverted();\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n-  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+void Assembler::evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3A);\n+  emit_operand(dst, src, 0);\n@@ -8095,5 +8281,317 @@\n-void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src->encoding(), shift->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n+void Assembler::vpminud(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::vpminud(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDE, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxub(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDE);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDE, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDE);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3E, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxuw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3E, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxud(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxud(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\/\/ Shift packed integers left by specified number of bits.\n+void Assembler::psllw(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::pslld(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::psllq(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::psllw(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n+}\n+\n+void Assembler::pslld(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF2, (0xC0 | encode));\n+}\n+\n+void Assembler::psllq(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF3, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n+  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n+  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n+  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src->encoding(), shift->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n@@ -9716,0 +10214,217 @@\n+void Assembler::evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xEC, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xEC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xED, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xED);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDC, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDD, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE8, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE9, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD9, (0xC0 | encode));\n+}\n+\n+\n+void Assembler::evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD9);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":792,"deletions":77,"binary":false,"changes":869,"status":"modified"},{"patch":"@@ -783,0 +783,1 @@\n+  bool needs_evex(XMMRegister reg1, XMMRegister reg2 = xnoreg, XMMRegister reg3 = xnoreg);\n@@ -1900,0 +1901,2 @@\n+  void evpcmpub(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n+\n@@ -1903,0 +1906,1 @@\n+  void evpcmpud(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n@@ -2505,0 +2509,34 @@\n+  \/\/ Saturating packed insturctions.\n+  void vpaddsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void vpsubsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void vpaddsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void vpsubsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n@@ -2648,1 +2686,0 @@\n-  void vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2674,1 +2711,0 @@\n-  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n@@ -2698,0 +2734,32 @@\n+  \/\/ Unsigned maximum packed integers.\n+  void vpmaxub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxuw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxud(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxub(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpmaxuw(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpmaxud(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n+  \/\/ Unsigned minimum packed integers.\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminuw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminud(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminub(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpminuw(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpminud(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -906,0 +906,46 @@\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, Address src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n@@ -2329,0 +2375,4 @@\n+void C2_MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  MacroAssembler::evmovdqu(type, kmask, dst, src, merge, vector_len);\n+}\n+\n@@ -4601,1 +4651,120 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               XMMRegister src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                                     XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (ideal_opc) {\n+    case Op_SaturatingAddVB:\n+      evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVI:\n+    case Op_SaturatingAddVL:\n+    case Op_SaturatingSubVI:\n+    case Op_SaturatingSubVL:\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                                        XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (ideal_opc) {\n+    case Op_SaturatingAddVB:\n+      evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVI:\n+    case Op_SaturatingAddVL:\n+    case Op_SaturatingSubVI:\n+    case Op_SaturatingSubVL:\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               Address src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                                      Address src2, bool merge, int vlen_enc) {\n+  switch (ideal_opc) {\n+    case Op_SaturatingAddVB:\n+      evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVI:\n+    case Op_SaturatingAddVL:\n+    case Op_SaturatingSubVI:\n+    case Op_SaturatingSubVL:\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                                        Address src2, bool merge, int vlen_enc) {\n+  switch (ideal_opc) {\n+    case Op_SaturatingAddVB:\n+      evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVI:\n+    case Op_SaturatingAddVL:\n+    case Op_SaturatingSubVI:\n+    case Op_SaturatingSubVL:\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -4691,0 +4860,4 @@\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4698,1 +4871,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -4751,0 +4925,4 @@\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4758,1 +4936,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -6445,0 +6624,377 @@\n+\n+void C2_MacroAssembler::saturating_signed_vector_op(int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(opc) {\n+    case Op_SaturatingAddVB:\n+      vpaddsb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      vpaddsw(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      vpsubsb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      vpsubsw(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::saturating_unsigned_vector_op(int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(opc) {\n+    case Op_SaturatingAddVB:\n+      vpaddusb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      vpaddusw(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      vpsubusb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      vpsubusw(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::saturating_unsigned_sub_dq_evex(BasicType etype, XMMRegister dst, XMMRegister src1,\n+                                                        XMMRegister src2, KRegister ktmp, int vlen_enc) {\n+  \/\/ For unsigned subtraction, overflow happens when magnitude of second input is greater than first input.\n+  \/\/ overflow = Inp1 <u Inp2\n+  evpcmpu(etype, ktmp,  src2, src1, Assembler::lt, vlen_enc);\n+  \/\/ Res = INP1 - INP2 (non-commutative and non-associative)\n+  vpsub(etype, dst, src1, src2, vlen_enc);\n+  \/\/ Res = Mask ? Zero : Res\n+  evmovdqu(etype, ktmp, dst, dst, false, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::saturating_unsigned_sub_dq_avx(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                       XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  \/\/ Emulate unsigned comparison using signed comparison\n+  \/\/ Mask = Inp1 <u Inp2 => Inp1 + MIN_VALUE < Inp2 + MIN_VALUE\n+  vpgenmin_value(etype, xtmp1, xtmp1, vlen_enc, true);\n+  vpadd(etype, xtmp2, src1, xtmp1, vlen_enc);\n+  vpadd(etype, xtmp1, src2, xtmp1, vlen_enc);\n+\n+  vpcmpgt(etype, xtmp2, xtmp1, xtmp2, vlen_enc);\n+\n+  \/\/ Res = INP1 - INP2 (non-commutative and non-associative)\n+  vpsub(etype, dst, src1, src2, vlen_enc);\n+  \/\/ Res = Mask ? Zero : Res\n+  vpxor(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpblendvb(dst, dst, xtmp1, xtmp2, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::saturating_unsigned_add_dq_evex(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                        XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, KRegister ktmp,\n+                                                        int vlen_enc) {\n+  \/\/ Unsigned values ranges comprise of only +ve numbers, thus there exist only an upper bound saturation.\n+  \/\/ overflow = ((UMAX - MAX(SRC1 & SRC2)) <u MIN(SRC1, SRC2)) >>> 31 == 1\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(etype, dst, src1, src2, vlen_enc);\n+  \/\/ Max_Input = Unsigned MAX INP1, INP2\n+  evpmaxu(etype, xtmp1, k0, src1, src2, true, vlen_enc);\n+  \/\/ Max_Unsigned = -1\n+  vpternlogd(xtmp3, 0xff, xtmp3, xtmp3, vlen_enc);\n+  \/\/ X = Max_Unsigned - Max_Input\n+  vpsub(etype, xtmp1, xtmp3, xtmp1, vlen_enc);\n+  \/\/ Min_Input = Unsigned MIN INP1, INP2\n+  evpminu(etype, xtmp2, k0, src1, src2, true, vlen_enc);\n+  \/\/ Unsigned compare:  Mask = X <u Min_Unsigned\n+  evpcmpu(etype, ktmp, xtmp2, xtmp1, Assembler::nlt, vlen_enc);\n+  \/\/ res  = Mask ? Max_Unsigned : Res\n+  evpblend(etype, dst, ktmp,  dst, xtmp3, true, vlen_enc);\n+}\n+\n+\/\/\n+\/\/ Adaptation of unsigned addition overflow detection from hacker's delight\n+\/\/ section 2-13 : overflow = ((a & b) | ((a | b) & ~(s))) >>> 31 == 1\n+\/\/\n+\/\/ Apply Logic optimization on above overflow detection expression by substituting 'a'\n+\/\/ with boolean values:-\n+\/\/   V1 : a = 0  =>  b & ~s\n+\/\/   V2 : a = 1  =>  b | ~s\n+\/\/\n+\/\/        V1  V2\n+\/\/         |0  |1\n+\/\/      ___|___|___\n+\/\/       \\       \/____ a\n+\/\/        \\_____\/            a + b UMAX\n+\/\/           |                 |0   |1\n+\/\/        overflow          ___|____|___\n+\/\/           |_______________\\        \/\n+\/\/                            \\______\/\n+\/\/                                |\n+\/\/                                |\n+\/\/                               Res\n+void C2_MacroAssembler::saturating_unsigned_add_dq_avx(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                       XMMRegister xtmp4, int vlen_enc) {\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(etype, dst, src1, src2, vlen_enc);\n+  \/\/ T1 = SRC2 & ~Res\n+  vpandn(xtmp1, dst, src2, vlen_enc);\n+  \/\/ Compute Max_Unsigned (T2) = -1\n+  vpcmpeqd(xtmp3, xtmp3, xtmp3, vlen_enc);\n+  \/\/ T2 = ~Res\n+  vpxor(xtmp2, xtmp3, dst, vlen_enc);\n+  \/\/ T3 = SRC2 | ~Res\n+  vpor(xtmp2, xtmp2, src2, vlen_enc);\n+  \/\/ Compute mask for muxing T1 with T3 using SRC1.\n+  vpsign_extend_dq(etype, xtmp4, src1, vlen_enc);\n+  \/\/ Blend T1 and T3 using above mask.\n+  vpblendvb(xtmp4, xtmp1, xtmp2, xtmp4, vlen_enc);\n+  \/\/ Compute mask for blending result with saturated upper bound.\n+  vpsign_extend_dq(etype, xtmp4, xtmp4, vlen_enc);\n+  vpblendvb(dst, dst, xtmp3, xtmp4, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovq2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogq(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    evpsraq(xtmp1, src, 63, vlen_enc);\n+    evpcmpeqq(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovd2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogd(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    vpsrad(xtmp1, src, 31, vlen_enc);\n+    Assembler::evpcmpeqd(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+\n+void C2_MacroAssembler::vpsign_extend_dq(BasicType etype, XMMRegister dst, XMMRegister src, int vlen_enc) {\n+  if (etype == T_LONG) {\n+    if (VM_Version::supports_evex()) {\n+      evpsraq(dst, src, 63, vlen_enc);\n+    } else {\n+      vpsrad(dst, src, 31, vlen_enc);\n+      vpshufd(dst, dst, 0xF5, vlen_enc);\n+    }\n+  } else {\n+    assert(etype == T_INT, \"\");\n+    vpsrad(dst, src, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmax_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (etype == T_LONG) {\n+    vpsrlq(dst, allones, 1, vlen_enc);\n+  } else {\n+    assert(etype == T_INT, \"\");\n+    vpsrld(dst, allones, 1, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmin_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (etype == T_LONG) {\n+    vpsllq(dst, allones, 63, vlen_enc);\n+  } else {\n+    assert(etype == T_INT, \"\");\n+    vpslld(dst, allones, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpcmpu(BasicType etype, KRegister kmask,  XMMRegister src1, XMMRegister src2,\n+                                Assembler::ComparisonPredicate cond, int vlen_enc) {\n+  switch(etype) {\n+    case T_LONG:  evpcmpuq(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_INT:   evpcmpud(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_SHORT: evpcmpuw(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_BYTE:  evpcmpub(kmask, src1, src2, cond, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(etype)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpgt(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(etype) {\n+    case  T_LONG:  vpcmpgtq(dst, src1, src2, vlen_enc); break;\n+    case  T_INT:   vpcmpgtd(dst, src1, src2, vlen_enc); break;\n+    case  T_SHORT: vpcmpgtw(dst, src1, src2, vlen_enc); break;\n+    case  T_BYTE:  vpcmpgtb(dst, src1, src2, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(etype)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmov_vec_to_mask(BasicType etype, KRegister ktmp, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1) {\n+  if (etype == T_LONG) {\n+    evpmovq2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  } else {\n+    assert(etype == T_INT, \"\");\n+    evpmovd2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  }\n+}\n+\n+void C2_MacroAssembler::saturating_signed_add_sub_dq_evex(BasicType etype, int opc, XMMRegister dst, XMMRegister src1,\n+                                                          XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                          KRegister ktmp1, KRegister ktmp2, int vlen_enc) {\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (opc == Op_SaturatingAddVI || opc == Op_SaturatingAddVL) {\n+    \/\/ res = src1 + src2\n+    vpadd(etype, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(opc == Op_SaturatingSubVI || opc == Op_SaturatingSubVL, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(etype, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Compute overflow detection mask.\n+  evpmov_vec_to_mask(etype, ktmp1, xtmp2, xtmp2, xtmp1, vlen_enc);\n+  \/\/ Note: xtmp1 hold -1 in all its lanes after above call.\n+\n+  \/\/ Compute mask based on first input polarity.\n+  evpmov_vec_to_mask(etype, ktmp2, src1, xtmp2, xtmp1, vlen_enc, true);\n+\n+  vpgenmax_value(etype, xtmp2, xtmp1, vlen_enc, true);\n+  vpgenmin_value(etype, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose a vector of saturating (MAX\/MIN) values, where lanes corresponding to\n+  \/\/ set bits in first input polarity mask holds a min value.\n+  evpblend(etype, xtmp2, ktmp2, xtmp2, xtmp1, true, vlen_enc);\n+  \/\/ Blend destination lanes with saturated values using overflow detection mask.\n+  evpblend(etype, dst, ktmp1, dst, xtmp2, true, vlen_enc);\n+}\n+\n+\n+void C2_MacroAssembler::saturating_signed_add_sub_dq_avx(BasicType etype, int opc, XMMRegister dst, XMMRegister src1,\n+                                                         XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                         XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc) {\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (opc == Op_SaturatingAddVI || opc == Op_SaturatingAddVL) {\n+    \/\/ res = src1 + src2\n+    vpadd(etype, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(opc == Op_SaturatingSubVI || opc == Op_SaturatingSubVL, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(etype, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Sign-extend to compute overflow detection mask.\n+  vpsign_extend_dq(etype, xtmp3, xtmp2, vlen_enc);\n+\n+  vpcmpeqd(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpgenmax_value(etype, xtmp2, xtmp1, vlen_enc);\n+  vpgenmin_value(etype, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose saturating min\/max vector using first input polarity mask.\n+  vpsign_extend_dq(etype, xtmp4, src1, vlen_enc);\n+  vpblendvb(xtmp1, xtmp2, xtmp1, xtmp4, vlen_enc);\n+\n+  \/\/ Blend result with saturating vector using overflow detection mask.\n+  vpblendvb(dst, dst, xtmp1, xtmp3, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::saturating_signed_vector_op(int opc, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(opc) {\n+    case Op_SaturatingAddVB:\n+      vpaddsb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      vpaddsw(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      vpsubsb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      vpsubsw(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::saturating_unsigned_vector_op(int opc, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(opc) {\n+    case Op_SaturatingAddVB:\n+      vpaddusb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingAddVS:\n+      vpaddusw(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVB:\n+      vpsubusb(dst, src1, src2, vlen_enc);\n+      break;\n+    case Op_SaturatingSubVS:\n+      vpsubusw(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::saturating_vector_op(int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    saturating_unsigned_vector_op(opc, dst, src1, src2, vlen_enc);\n+  } else {\n+    saturating_signed_vector_op(opc, dst, src1, src2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::saturating_vector_op(int opc, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    saturating_unsigned_vector_op(opc, dst, src1, src2, vlen_enc);\n+  } else {\n+    saturating_signed_vector_op(opc, dst, src1, src2, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":559,"deletions":3,"binary":false,"changes":562,"status":"modified"},{"patch":"@@ -59,0 +59,8 @@\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                int vlen_enc);\n+\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, Address src2,\n+                int vlen_enc);\n+\n@@ -108,0 +116,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -508,0 +517,64 @@\n+  void saturating_vector_op(int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc);\n+\n+  void saturating_vector_op(int opc, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc);\n+\n+  void saturating_signed_vector_op(int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void saturating_signed_vector_op(int opc, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void saturating_unsigned_vector_op(int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void saturating_unsigned_vector_op(int opc, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void saturating_unsigned_sub_dq_evex(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2, KRegister ktmp, int vlen_enc);\n+\n+  void saturating_unsigned_sub_dq_avx(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                      XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n+  void saturating_unsigned_add_dq_evex(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, KRegister ktmp, int vlen_enc);\n+\n+  void saturating_unsigned_add_dq_avx(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                      XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                      XMMRegister xtmp4, int vlen_enc);\n+\n+  void saturating_signed_add_sub_dq_avx(BasicType etype, int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                        XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc);\n+\n+  void saturating_signed_add_sub_dq_evex(BasicType etype, int opc, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                         XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, int vlen_enc);\n+\n+  void evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void vpsign_extend_dq(BasicType etype, XMMRegister dst, XMMRegister src, int vlen_enc);\n+\n+  void vpgenmin_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void vpgenmax_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void evpcmpu(BasicType etype, KRegister kmask,  XMMRegister src1, XMMRegister src2, Assembler::ComparisonPredicate cond, int vlen_enc);\n+\n+  void vpcmpgt(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void evpmov_vec_to_mask(BasicType etype, KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                          int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evmasked_saturating_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       XMMRegister src2, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       Address src2, bool merge, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -9306,0 +9306,24 @@\n+void MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evmovdqub(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evmovdquw(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evmovdqul(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evmovdquq(dst, kmask, src, merge, vector_len);\n+      break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type));\n+      break;\n+  }\n+}\n+\n@@ -9497,0 +9521,60 @@\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1281,0 +1281,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -1587,0 +1588,5 @@\n+\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1768,0 +1768,9 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+      if (UseAVX == 0) {\n+        return false;\n+      }\n+      if (bt == T_LONG && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1938,0 +1947,16 @@\n+    case Op_SaturatingAddVB:\n+    case Op_SaturatingAddVS:\n+    case Op_SaturatingSubVB:\n+    case Op_SaturatingSubVS:\n+       if (UseAVX < 1 || size_in_bits < 128 || (size_in_bits == 512 && !VM_Version::supports_avx512bw())) {\n+         return false;\n+       }\n+       break;\n+    case Op_SaturatingAddVI:\n+    case Op_SaturatingAddVL:\n+    case Op_SaturatingSubVI:\n+    case Op_SaturatingSubVL:\n+      if (UseAVX < 1 || size_in_bits < 128) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      break;\n@@ -2114,0 +2139,2 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n@@ -2121,0 +2148,8 @@\n+    case Op_SaturatingAddVB:\n+    case Op_SaturatingAddVS:\n+    case Op_SaturatingSubVB:\n+    case Op_SaturatingSubVS:\n+      if (size_in_bits < 128 || !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n@@ -6480,0 +6515,58 @@\n+\/\/ ------------------------------ Unsigned vector Min\/Max ----------------------\n+\n+instruct uminmax_reg(vec dst, vec a, vec b) %{\n+  match(Set dst (UMinV a b));\n+  match(Set dst (UMaxV a b));\n+  format %{ \"vector_uminmax_reg  $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct uminmax_mem(vec dst, vec a, memory b) %{\n+  match(Set dst (UMinV a (LoadVector b)));\n+  match(Set dst (UMaxV a (LoadVector b)));\n+  format %{ \"vector_uminmax_mem  $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct uminmax_reg_masked(vec dst, vec src1, vec src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 src2) mask));\n+  match(Set dst (UMaxV (Binary src1 src2) mask));\n+  format %{ \"vector_uminmax_masked_reg $dst, $src1, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct uminmax_mem_masked(vec dst, vec src1, memory src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 (LoadVector src2)) mask));\n+  match(Set dst (UMaxV (Binary src1 (LoadVector src2)) mask));\n+  format %{ \"vector_uminmax_masked_mem $dst, $dst, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $src1$$XMMRegister, $src2$$Address, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10471,0 +10564,164 @@\n+\n+\n+instruct saturating_subword_op_reg(vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (SaturatingAddVB src1 src2));\n+  match(Set dst (SaturatingAddVS src1 src2));\n+  match(Set dst (SaturatingSubVB src1 src2));\n+  match(Set dst (SaturatingSubVS src1 src2));\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    bool is_unsigned = Type::is_utype(Matcher::vector_element_type(this));\n+    __ saturating_vector_op(this->ideal_Opcode(), $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, is_unsigned, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_op_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2)\n+%{\n+  predicate(!Type::is_utype(Matcher::vector_element_type(n)) && (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddVI src1 src2));\n+  match(Set dst (SaturatingAddVL src1 src2));\n+  match(Set dst (SaturatingSubVI src1 src2));\n+  match(Set dst (SaturatingSubVL src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2);\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType etype = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ saturating_signed_add_sub_dq_evex(etype, opc, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp1$$XMMRegister,\n+                                         $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_op_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4)\n+%{\n+  predicate(!Type::is_utype(Matcher::vector_element_type(n)) && Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddVI src1 src2));\n+  match(Set dst (SaturatingAddVL src1 src2));\n+  match(Set dst (SaturatingSubVI src1 src2));\n+  match(Set dst (SaturatingSubVL src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4);\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType etype = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ saturating_signed_add_sub_dq_avx(etype, opc, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp1$$XMMRegister,\n+                                        $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_unsigned_add_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3, kReg ktmp)\n+%{\n+  predicate(Type::is_utype(Matcher::vector_element_type(n)) && (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddVI src1 src2));\n+  match(Set dst (SaturatingAddVL src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP ktmp);\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $xtmp3 and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType etype = Matcher::vector_element_basic_type(this);\n+    __ saturating_unsigned_add_dq_evex(etype, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp1$$XMMRegister,\n+                                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_unsigned_add_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4)\n+%{\n+  predicate(Type::is_utype(Matcher::vector_element_type(n)) && Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddVI src1 src2));\n+  match(Set dst (SaturatingAddVL src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4);\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType etype = Matcher::vector_element_basic_type(this);\n+    __ saturating_unsigned_add_dq_avx(etype, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp1$$XMMRegister,\n+                                      $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_unsigned_sub_reg_evex(vec dst, vec src1, vec src2, kReg ktmp)\n+%{\n+  predicate(Type::is_utype(Matcher::vector_element_type(n)) && (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingSubVI src1 src2));\n+  match(Set dst (SaturatingSubVL src1 src2));\n+  effect(TEMP ktmp);\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t! using $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType etype = Matcher::vector_element_basic_type(this);\n+    __ saturating_unsigned_sub_dq_evex(etype, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_unsigned_sub_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2)\n+%{\n+  predicate(Type::is_utype(Matcher::vector_element_type(n)) && Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingSubVI src1 src2));\n+  match(Set dst (SaturatingSubVL src1 src2));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType etype = Matcher::vector_element_basic_type(this);\n+    __ saturating_unsigned_sub_dq_avx(etype, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $xtmp1$$XMMRegister,\n+                                      $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_subword_op_mem(vec dst, vec src1, memory src2)\n+%{\n+  match(Set dst (SaturatingAddVB src1 (LoadVector src2)));\n+  match(Set dst (SaturatingAddVS src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubVB src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubVS src1 (LoadVector src2)));\n+  format %{ \"saturating_vector_op $dst, $src1, $src2 \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    bool is_unsigned = Type::is_utype(Matcher::vector_element_type(this));\n+    __ saturating_vector_op(this->ideal_Opcode(), $dst$$XMMRegister, $src1$$XMMRegister, $src2$$Address, is_unsigned, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct saturating_subword_masked_op_reg(vec dst, vec src, kReg mask) %{\n+  match(Set dst (SaturatingAddVB (Binary dst src) mask));\n+  match(Set dst (SaturatingAddVS (Binary dst src) mask));\n+  match(Set dst (SaturatingSubVB (Binary dst src) mask));\n+  match(Set dst (SaturatingSubVS (Binary dst src) mask));\n+  format %{ \"saturating_vector_masked_op $dst, $mask, $src \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opc = this->ideal_Opcode();\n+    bool is_unsigned = Type::is_utype(Matcher::vector_element_type(this));\n+    __ evmasked_saturating_op(opc, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$XMMRegister, is_unsigned, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct saturating_subword_masked_op_mem(vec dst, memory src, kReg mask) %{\n+  match(Set dst (SaturatingAddVB (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingAddVS (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubVB (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubVS (Binary dst (LoadVector src)) mask));\n+  format %{ \"saturating_vector_masked_op $dst, $mask, $src \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opc = this->ideal_Opcode();\n+    bool is_unsigned = Type::is_utype(Matcher::vector_element_type(this));\n+    __ evmasked_saturating_op(opc, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$Address, is_unsigned, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":257,"deletions":0,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -4339,1 +4339,1 @@\n-    \"MaxV\", \"MinV\",\n+    \"MaxV\", \"MinV\", \"UMinV\", \"UMaxV\",\n@@ -4363,0 +4363,2 @@\n+    \"SaturatingAddVB\", \"SaturatingAddVS\", \"SaturatingAddVI\", \"SaturatingAddVL\",\n+    \"SaturatingSubVB\", \"SaturatingSubVS\", \"SaturatingSubVI\", \"SaturatingSubVL\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,0 +190,66 @@\n+\/\/------------------------------Saturating Operations ------------------------\n+\n+class SaturatingAddINode : public Node {\n+public:\n+  SaturatingAddINode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+class SaturatingAddLNode : public Node {\n+public:\n+  SaturatingAddLNode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class SaturatingSubINode : public Node {\n+public:\n+  SaturatingSubINode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+class SaturatingSubLNode : public Node {\n+public:\n+  SaturatingSubLNode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class SaturatingUAddINode : public Node {\n+public:\n+  SaturatingUAddINode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::UINT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+class SaturatingUAddLNode : public Node {\n+public:\n+  SaturatingUAddLNode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::ULONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class SaturatingUSubINode : public Node {\n+public:\n+  SaturatingUSubINode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::UINT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+class SaturatingUSubLNode : public Node {\n+public:\n+  SaturatingUSubLNode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::ULONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n@@ -336,0 +402,20 @@\n+\/\/------------------------------UMaxINode---------------------------------------\n+\/\/ Maximum of 2 unsigned integers.\n+class UMaxINode : public Node {\n+public:\n+  UMaxINode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::UINT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/------------------------------UMinINode---------------------------------------\n+\/\/ Minimum of 2 unsigned integers.\n+class UMinINode : public Node {\n+public:\n+  UMinINode(Node* in1, Node* in2 ) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::UINT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -374,0 +460,20 @@\n+\/\/------------------------------UMaxINode---------------------------------------\n+\/\/ Maximum of 2 unsigned integers.\n+class UMaxLNode : public Node {\n+public:\n+  UMaxLNode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::ULONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+\/\/------------------------------UMinINode---------------------------------------\n+\/\/ Minimum of 2 unsigned integers.\n+class UMinLNode : public Node {\n+public:\n+  UMinLNode(Node* in1, Node* in2) : Node(in1,in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::ULONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -224,0 +224,2 @@\n+macro(UMaxI)\n+macro(UMaxL)\n@@ -239,0 +241,2 @@\n+macro(UMinI)\n+macro(UMinL)\n@@ -331,0 +335,16 @@\n+macro(SaturatingAddI)\n+macro(SaturatingAddL)\n+macro(SaturatingUAddI)\n+macro(SaturatingUAddL)\n+macro(SaturatingSubI)\n+macro(SaturatingSubL)\n+macro(SaturatingUSubI)\n+macro(SaturatingUSubL)\n+macro(SaturatingAddVB)\n+macro(SaturatingAddVS)\n+macro(SaturatingAddVI)\n+macro(SaturatingAddVL)\n+macro(SaturatingSubVB)\n+macro(SaturatingSubVS)\n+macro(SaturatingSubVI)\n+macro(SaturatingSubVL)\n@@ -438,0 +458,2 @@\n+macro(UMinV)\n+macro(UMaxV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2817,0 +2817,12 @@\n+const Type* Matcher::vector_element_type(const Node* n) {\n+  const TypeVect* vt = n->bottom_type()->is_vect();\n+  return vt->element_type();\n+}\n+\n+const Type* Matcher::vector_element_type(const MachNode* use, const MachOper* opnd) {\n+  int def_idx = use->operand_index(opnd);\n+  Node* def = use->in(def_idx);\n+  return def->bottom_type()->is_vect()->element_type();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -379,0 +379,2 @@\n+  static const Type* vector_element_type(const Node* n);\n+  static const Type* vector_element_type(const MachNode* use, const MachOper* opnd);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+class SaturatingVectorNode;\n@@ -742,0 +743,1 @@\n+        DEFINE_CLASS_ID(SaturatingVector, Vector, 9)\n@@ -1007,0 +1009,1 @@\n+  DEFINE_CLASS_QUERY(SaturatingVector)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -161,0 +161,3 @@\n+    if (this == TypeInt::UBYTE)  return T_BYTE;\n+    if (this == TypeInt::USHORT) return T_SHORT;\n+    if (this == TypeInt::UINT)   return T_INT;\n@@ -488,0 +491,1 @@\n+  TypeInt::USHORT  = TypeInt::make(0,65535,      WidenMin); \/\/ Unsigned shorts\n@@ -491,0 +495,1 @@\n+  TypeInt::UINT    = TypeInt::make(0, max_juint, WidenMin); \/\/ Unsigned ints\n@@ -511,0 +516,1 @@\n+  TypeLong::ULONG   = TypeLong::make(0, max_julong, WidenMin); \/\/ Unsigned longs\n@@ -1526,0 +1532,20 @@\n+const Type* Type::get_utype(BasicType bt) {\n+  switch(bt) {\n+    case T_BYTE:  return TypeInt::UBYTE;\n+    case T_SHORT: return TypeInt::USHORT;\n+    case T_INT:   return TypeInt::UINT;\n+    case T_LONG:  return TypeLong::ULONG;\n+    default: fatal(\"Unexpected type: %s\", type2name(bt)); break;\n+  }\n+}\n+\n+bool Type::is_utype(const Type* elem_ty) {\n+  if (elem_ty == TypeInt::UBYTE  ||\n+      elem_ty == TypeInt::USHORT ||\n+      elem_ty == TypeInt::UINT   ||\n+      elem_ty == TypeLong::ULONG) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -1584,0 +1610,1 @@\n+const TypeInt *TypeInt::USHORT; \/\/ Unsigned shorts, 0-65535\n@@ -1587,0 +1614,1 @@\n+const TypeInt *TypeInt::UINT;\n@@ -1850,0 +1878,1 @@\n+const TypeLong *TypeLong::ULONG; \/\/ 64-bit unsigned long.\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -468,0 +468,2 @@\n+  static const Type* get_utype(BasicType elem_bt);\n+  static bool is_utype(const Type* elem_ty);\n@@ -628,0 +630,1 @@\n+  static const TypeInt *USHORT;\n@@ -631,0 +634,1 @@\n+  static const TypeInt *UINT;\n@@ -689,0 +693,1 @@\n+  static const TypeLong *ULONG;  \/\/ 64-bit unsigned [0..max_julong]\n@@ -820,1 +825,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -469,0 +469,1 @@\n+  bool is_unsigned_op = VectorNode::is_unsigned_opcode(opc);\n@@ -480,1 +481,6 @@\n-    const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n+    const TypeVect* vt = nullptr;\n+    if (!is_unsigned_op) {\n+      vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n+    } else {\n+      vt = TypeVect::make(Type::get_utype(elem_bt), num_elem, is_vector_mask(vbox_klass));\n+    }\n@@ -484,1 +490,1 @@\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc));\n+        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc), is_unsigned_op);\n@@ -494,1 +500,2 @@\n-\n+  \/\/ Reinterpret unsigned vector nodes to signed vectors before boxing it to\n+  \/\/ facilitate seamless unboxing-boxing optimization.\n@@ -499,0 +506,5 @@\n+      operation = gvn().transform(operation);\n+      if (is_unsigned_op) {\n+        const TypeVect* to_vect_type = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n+        operation = gvn().transform(new VectorReinterpretNode(operation, operation->bottom_type()->is_vect(), to_vect_type));\n+      }\n@@ -502,0 +514,4 @@\n+      if (is_unsigned_op) {\n+        const TypeVect* to_vect_type = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n+        operation = gvn().transform(new VectorReinterpretNode(operation, operation->bottom_type()->is_vect(), to_vect_type));\n+      }\n@@ -503,0 +519,7 @@\n+      operation = gvn().transform(operation);\n+    }\n+  } else {\n+    operation = gvn().transform(operation);\n+    if (is_unsigned_op) {\n+      const TypeVect* to_vect_type = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n+      operation = gvn().transform(new VectorReinterpretNode(operation, operation->bottom_type()->is_vect(), to_vect_type));\n@@ -505,1 +528,0 @@\n-  operation = gvn().transform(operation);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -271,0 +271,36 @@\n+  case Op_UMinI:\n+  case Op_UMinL:\n+    switch(bt) {\n+    case T_BYTE:\n+    case T_SHORT:\n+    case T_INT:\n+    case T_LONG: return Op_UMinV;\n+    default: return 0;\n+    }\n+  case Op_UMaxI:\n+  case Op_UMaxL:\n+    switch(bt) {\n+    case T_BYTE:\n+    case T_SHORT:\n+    case T_INT:\n+    case T_LONG: return Op_UMaxV;\n+    default: return 0;\n+    }\n+  case Op_SaturatingAddI:\n+  case Op_SaturatingUAddI:\n+    switch (bt) {\n+    case T_BYTE: return Op_SaturatingAddVB;\n+    case T_SHORT: return Op_SaturatingAddVS;\n+    case T_INT:  return Op_SaturatingAddVI;\n+    case T_LONG: return Op_SaturatingAddVL;\n+    default: return 0;\n+    }\n+  case Op_SaturatingSubI:\n+  case Op_SaturatingUSubI:\n+    switch (bt) {\n+    case T_BYTE: return Op_SaturatingSubVB;\n+    case T_SHORT: return Op_SaturatingSubVS;\n+    case T_INT:  return Op_SaturatingSubVI;\n+    case T_LONG: return Op_SaturatingSubVL;\n+    default: return 0;\n+    }\n@@ -510,0 +546,12 @@\n+bool VectorNode::is_unsigned_opcode(int opc) {\n+  switch (opc) {\n+  case Op_SaturatingUAddI:\n+  case Op_SaturatingUSubI:\n+  case Op_SaturatingUSubL:\n+  case Op_SaturatingUAddL:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n@@ -670,1 +718,1 @@\n-VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift) {\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift, bool is_unsigned) {\n@@ -742,0 +790,3 @@\n+  case Op_UMinV: return new UMinVNode(n1, n2, vt);\n+  case Op_UMaxV: return new UMaxVNode(n1, n2, vt);\n+\n@@ -762,0 +813,10 @@\n+\n+  case Op_SaturatingAddVB: return new SaturatingAddVBNode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingAddVS: return new SaturatingAddVSNode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingSubVB: return new SaturatingSubVBNode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingSubVS: return new SaturatingSubVSNode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingAddVI: return new SaturatingAddVINode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingAddVL: return new SaturatingAddVLNode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingSubVI: return new SaturatingSubVINode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingSubVL: return new SaturatingSubVLNode(n1, n2, vt, is_unsigned);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false, bool is_unsigned = false);\n@@ -87,0 +87,1 @@\n+  static bool is_unsigned_opcode(int opc);\n@@ -147,0 +148,13 @@\n+class SaturatingVectorNode : public VectorNode {\n+ private:\n+  bool _is_unsigned;\n+\n+ public:\n+  SaturatingVectorNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : VectorNode(in1, in2, vt), _is_unsigned(is_unsigned) {\n+    init_class_id(Class_SaturatingVector);\n+  }\n+\n+  \/\/ Needed for proper cloning.\n+  virtual uint size_of() const { return sizeof(*this); }\n+  bool is_unsigned() { return _is_unsigned; }\n+};\n@@ -156,0 +170,6 @@\n+class SaturatingAddVBNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingAddVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -164,0 +184,7 @@\n+class SaturatingAddVSNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingAddVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -172,0 +199,6 @@\n+class SaturatingAddVINode : public SaturatingVectorNode {\n+ public:\n+  SaturatingAddVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -180,0 +213,6 @@\n+class SaturatingAddVLNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingAddVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -334,0 +373,6 @@\n+class SaturatingSubVBNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingSubVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -342,0 +387,6 @@\n+class SaturatingSubVSNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingSubVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -350,0 +401,6 @@\n+class SaturatingSubVINode : public SaturatingVectorNode {\n+ public:\n+  SaturatingSubVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -358,0 +415,6 @@\n+class SaturatingSubVLNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingSubVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -564,0 +627,8 @@\n+class UMinVNode : public VectorNode {\n+ public:\n+  UMinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    assert(is_integral_type(vt->element_basic_type()), \"\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n@@ -572,0 +643,8 @@\n+class UMaxVNode : public VectorNode {\n+ public:\n+  UMaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    assert(is_integral_type(vt->element_basic_type()), \"\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":80,"deletions":1,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -277,0 +277,20 @@\n+    case VECTOR_OP_UMIN: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:    return Op_UMinI;\n+        case T_LONG:   return Op_UMinL;\n+        default: fatal(\"MIN: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_UMAX: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:    return Op_UMaxI;\n+        case T_LONG:   return Op_UMaxL;\n+        default: fatal(\"MAX: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n@@ -339,0 +359,40 @@\n+    case VECTOR_OP_SADD: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:  return Op_SaturatingAddI;\n+        case T_LONG: return Op_SaturatingAddL;\n+        default: fatal(\"RSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_SSUB: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:  return Op_SaturatingSubI;\n+        case T_LONG: return Op_SaturatingSubL;\n+        default: fatal(\"RSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_SUADD: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:  return Op_SaturatingUAddI;\n+        case T_LONG: return Op_SaturatingUAddL;\n+        default: fatal(\"RSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_SUSUB: {\n+      switch (bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:  return Op_SaturatingUSubI;\n+        case T_LONG: return Op_SaturatingUSubL;\n+        default: fatal(\"RSHIFT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -124,0 +124,7 @@\n+    VECTOR_OP_SADD  = 119,\n+    VECTOR_OP_SSUB  = 120,\n+    VECTOR_OP_SUADD = 121,\n+    VECTOR_OP_SUSUB = 122,\n+    VECTOR_OP_UMIN = 123,\n+    VECTOR_OP_UMAX = 124,\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -78,0 +78,10 @@\n+    \/**\n+     * A constant holding polarity(sign) mask used by saturating operations.\n+     *\/\n+    public static final byte POLARITY_MASK_BYTE = (byte)(1 << 7);\n+\n+    \/**\n+     * A constant holding maximum unsigned value used by saturating unsigned operations.\n+     *\/\n+    public static final byte UNSIGNED_MAX = (byte)0xFF;\n+\n@@ -577,0 +587,110 @@\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code byte} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte maxUnsigned(byte a, byte b) {\n+        return compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code byte} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte minUnsigned(byte a, byte b) {\n+        return compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Saturating addition of two {@code byte} values,\n+     * which returns a {@code Byte.MIN_VALUE} in underflowing or\n+     * {@code Byte.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code byte} value range else delimiting {@code Byte.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte addSaturating(byte a, byte b) {\n+        int res = a + b;\n+        if (res > Byte.MAX_VALUE) {\n+            return Byte.MAX_VALUE;\n+        } else if (res < Byte.MIN_VALUE) {\n+            return Byte.MIN_VALUE;\n+        } else {\n+           return (byte)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code byte} values,\n+     * which returns a {@code Byte.MIN_VALUE} in underflowing or\n+     * {@code Byte.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code byte} value range else delimiting {@code Byte.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte subSaturating(byte a, byte b) {\n+        byte res = (byte)(a - b);\n+        \/\/ Saturation occurs when result of computation over opposite polarity inputs exceeds the byte\n+        \/\/ value range, in this case, for a non-commutative operation like subtraction, result polarity does not\n+        \/\/ comply with first argument polarity.\n+        boolean opposite_polarity_inputs = ((a ^ b) & POLARITY_MASK_BYTE) == POLARITY_MASK_BYTE;\n+        if (opposite_polarity_inputs && ((res & POLARITY_MASK_BYTE) != (a & POLARITY_MASK_BYTE))) {\n+            return res < 0 ? Byte.MAX_VALUE : Byte.MIN_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code byte} values,\n+     * which returns a {@code Byte.UNSIGNED_MAX} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting {@code Byte.UNSIGNED_MAX} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte addSaturatingUnsigned(byte a, byte b) {\n+        byte res = (byte)(a + b);\n+        boolean overflow = Byte.compareUnsigned(res, (byte)(a | b)) < 0;\n+        if (overflow) {\n+           return Byte.UNSIGNED_MAX;\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned subtraction of two {@code byte} values,\n+     * which returns a zero in underflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned difference between {@code a} and {@code b} iff within unsigned value range else delimiting zero value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte subSaturatingUnsigned(byte a, byte b) {\n+        if (Byte.compareUnsigned(b, a) < 0) {\n+            return (byte)(a - b);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -90,0 +90,10 @@\n+    \/**\n+     * A constant holding polarity(sign) mask used by saturating operations.\n+     *\/\n+    public static final int POLARITY_MASK_INT  = 1 << 31;\n+\n+    \/**\n+     * A constant holding maximum unsigned value used by saturating unsigned operations.\n+     *\/\n+    public static final int UNSIGNED_MAX = 0xFFFFFFFF;\n+\n@@ -1987,0 +1997,111 @@\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code int} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 1.8\n+     *\/\n+    public static int maxUnsigned(int a, int b) {\n+        return compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code int} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 1.8\n+     *\/\n+    public static int minUnsigned(int a, int b) {\n+        return compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+\n+    \/**\n+     * Saturating addition of two {@code int} values,\n+     * which returns an {@code Integer.MIN_VALUE} in underflowing or\n+     * {@code Integer.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code int} value range else delimiting {@code Integer.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int addSaturating(int a, int b) {\n+        long res = (long)a + (long)b;\n+        if (res > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        } else if (res < Integer.MIN_VALUE) {\n+            return Integer.MIN_VALUE;\n+        } else {\n+            return (int)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code int} values,\n+     * which returns an {@code Integer.MIN_VALUE} in underflowing or\n+     * {@code Integer.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code int} value range else delimiting {@code Integer.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int subSaturating(int a, int b) {\n+        int res = a - b;\n+        boolean opposite_polarity_inputs = ((a ^ b) & POLARITY_MASK_INT) == POLARITY_MASK_INT;\n+        \/\/ Saturation occurs when result of computation over opposite polarity inputs exceeds the int\n+        \/\/ value range, in this case, for a non-commutative operation like subtraction, result polarity does not\n+        \/\/ comply with first argument polarity.\n+        if (opposite_polarity_inputs && ((res & POLARITY_MASK_INT) != (a & POLARITY_MASK_INT))) {\n+            return res < 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code int} values,\n+     * which returns a {@code Integer.UNSIGNED_MAX} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting {@code Integer.UNSIGNED_MAX} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int addSaturatingUnsigned(int a, int b) {\n+        int res = a + b;\n+        boolean overflow = Integer.compareUnsigned(res, (a | b)) < 0;\n+        if (overflow)  {\n+           return Integer.UNSIGNED_MAX;\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned subtraction of two {@code int} values,\n+     * which returns a zero in underflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned difference between {@code a} and {@code b} iff within unsigned value range else delimiting zero value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int subSaturatingUnsigned(int a, int b) {\n+        if (Integer.compareUnsigned(b, a) < 0) {\n+           return a - b;\n+        } else {\n+           return 0;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -90,0 +90,10 @@\n+    \/**\n+     * A constant holding polarity(sign) mask used by saturating operations.\n+     *\/\n+    public static final long POLARITY_MASK_LONG = 1L << 63;\n+\n+    \/**\n+     * A constant holding maximum unsigned value used by saturating unsigned operations.\n+     *\/\n+    public static final long UNSIGNED_MAX = 0xFFFFFFFFFFFFFFFFL;\n+\n@@ -1938,0 +1948,110 @@\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code long} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long maxUnsigned(long a, long b) {\n+        return compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code long} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long minUnsigned(long a, long b) {\n+        return compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Saturating addition of two {@code long} values,\n+     * which returns a {@code Long.MIN_VALUE} in underflowing or\n+     * {@code Long.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code long} value range else delimiting {@code Long.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long addSaturating(long a, long b) {\n+        long res = a + b;\n+        \/\/ Saturation occurs when result of computation over same polarity inputs exceeds the {@code long} value range.\n+        boolean same_polarity_inputs = ((a ^ b) & POLARITY_MASK_LONG) == 0;\n+        if (same_polarity_inputs && ((res & POLARITY_MASK_LONG) != (a & POLARITY_MASK_LONG))) {\n+            return res < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code long} values,\n+     * which returns a {@code Long.MIN_VALUE} in underflowing or\n+     * {@code Long.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code long} value range else delimiting {@code Long.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long subSaturating(long a, long b) {\n+        boolean opposite_polarity_inputs = ((a ^ b) & POLARITY_MASK_LONG) == POLARITY_MASK_LONG;\n+        long res = a - b;\n+        \/\/ Saturation occurs when result of computation over opposite polarity inputs exceeds the long\n+        \/\/ value range, in this case, for a non-commutative operation like subtraction, result polarity does not\n+        \/\/ comply with first argument polarity.\n+        if (opposite_polarity_inputs && ((res & POLARITY_MASK_LONG) != (a & POLARITY_MASK_LONG))) {\n+            return res < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code long} values,\n+     * which returns a {@code Long.UNSIGNED_MAX} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting {@code Long.UNSIGNED_MAX} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long addSaturatingUnsigned(long a, long b) {\n+        long res = a + b;\n+        boolean overflow = Long.compareUnsigned(res, (a | b)) < 0;\n+        if (overflow) {\n+           return Long.UNSIGNED_MAX;\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned subtraction of two {@code long} values,\n+     * which returns a zero in underflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned difference between {@code a} and {@code b} iff within unsigned value range else delimiting zero value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long subSaturatingUnsigned(long a, long b) {\n+        if (Long.compareUnsigned(b, a) < 0) {\n+           return a - b;\n+        } else {\n+           return 0;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -77,0 +77,10 @@\n+    \/**\n+     * A constant holding polarity(sign) mask used by saturating operations.\n+     *\/\n+    public static final short POLARITY_MASK_SHORT = (short)(1 << 15);\n+\n+    \/**\n+     * A constant holding maximum unsigned value used by saturating unsigned operations.\n+     *\/\n+    public static final short UNSIGNED_MAX = (short)0xFFFF;\n+\n@@ -612,0 +622,111 @@\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code short} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short maxUnsigned(short a, short b) {\n+        return compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code short} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short minUnsigned(short a, short b) {\n+        return compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Saturating addition of two {@code short} values,\n+     * which returns a {@code Short.MIN_VALUE} in underflowing or\n+     * {@code Short.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code short} value range else delimiting {@code Short.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short addSaturating(short a, short b) {\n+        int res = a + b;\n+        if (res > Short.MAX_VALUE) {\n+            return Short.MAX_VALUE;\n+        } else if (res < Short.MIN_VALUE) {\n+            return Short.MIN_VALUE;\n+        } else {\n+           return (short)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code short} values,\n+     * which returns a {@code Short.MIN_VALUE} in underflowing or\n+     * {@code Short.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code short} value range else delimiting {@code Short.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short subSaturating(short a, short b) {\n+        short res = (short)(a - b);\n+        \/\/ Saturation occurs when result of computation over opposite polarity inputs exceeds the short\n+        \/\/ value range, in this case, for a non-commutative operation like subtraction, result polarity does not\n+        \/\/ comply with first argument polarity.\n+        boolean opposite_polarity_inputs = ((a ^ b) & POLARITY_MASK_SHORT) == POLARITY_MASK_SHORT;\n+        if (opposite_polarity_inputs && ((res & POLARITY_MASK_SHORT) != (a & POLARITY_MASK_SHORT))) {\n+            return res < 0 ? Short.MAX_VALUE : Short.MIN_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code short} values,\n+     * which returns a {@code Short.UNSIGNED_MAX} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting {@code Short.UNSIGNED_MAX} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short addSaturatingUnsigned(short a, short b) {\n+        short res = (short)(a + b);\n+        boolean overflow = Short.compareUnsigned(res, (short)(a | b)) < 0;\n+        if (overflow) {\n+           return Short.UNSIGNED_MAX;\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned subtraction of two {@code short} values,\n+     * which returns a zero in underflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned difference between {@code a} and {@code b} iff within unsigned value range else delimiting zero value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short subSaturatingUnsigned(short a, short b) {\n+        if (Short.compareUnsigned(b, a) < 0) {\n+            return (short)(a - b);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -117,0 +117,7 @@\n+    public static final int VECTOR_OP_SADD  = 119;\n+    public static final int VECTOR_OP_SSUB  = 120;\n+    public static final int VECTOR_OP_SUADD = 121;\n+    public static final int VECTOR_OP_SUSUB = 122;\n+    public static final int VECTOR_OP_UMIN = 123;\n+    public static final int VECTOR_OP_UMAX = 124;\n+\n@@ -387,0 +394,2 @@\n+    \/* ============================================================================ *\/\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -874,0 +874,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)Byte.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)Byte.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(Byte.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(Byte.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(Byte.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(Byte.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -874,0 +874,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)Integer.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)Integer.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(Integer.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(Integer.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(Integer.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(Integer.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -832,0 +832,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)Long.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)Long.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(Long.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(Long.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(Long.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(Long.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -874,0 +874,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)Short.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)Short.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(Short.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(Short.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(Short.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(Short.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+\n@@ -569,0 +570,14 @@\n+    \/** Produce {@code a [+] b}.  *\/\n+    public static final Associative SADD = assoc(\"SADD\", \"+\", VectorSupport.VECTOR_OP_SADD, VO_NOFP+VO_ASSOC);\n+    \/** Produce {@code a [u+] b}. *\/\n+    public static final Associative SUADD = assoc(\"SUADD\", \"+\", VectorSupport.VECTOR_OP_SUADD, VO_NOFP+VO_ASSOC);\n+    \/** Produce {@code a [-] b}.  *\/\n+    public static final Binary SSUB = binary(\"SSUB\", \"-\", VectorSupport.VECTOR_OP_SSUB, VO_NOFP);\n+    \/** Produce {@code a [u-] b}. *\/\n+    public static final Binary SUSUB = binary(\"SUSUB\", \"-\", VectorSupport.VECTOR_OP_SUSUB, VO_NOFP);\n+    \/** Produce {@code umin(a,b)}. *\/\n+    public static final Associative UMIN = assoc(\"UMIN\", \"umin\", VectorSupport.VECTOR_OP_UMIN, VO_NOFP+VO_ASSOC);\n+    \/** Produce {@code umax(a,b)}. *\/\n+    public static final Associative UMAX = assoc(\"UMAX\", \"umax\", VectorSupport.VECTOR_OP_UMAX, VO_NOFP+VO_ASSOC);\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -970,0 +970,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)$Boxtype$.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)$Boxtype$.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)($Boxtype$.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)($Boxtype$.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)($Boxtype$.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)($Boxtype$.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -972,0 +972,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +998,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1021,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1033,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2974,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(Byte.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(Byte.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -972,0 +972,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +998,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1021,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1033,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2974,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(Byte.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(Byte.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -972,0 +972,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +998,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1021,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1033,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2974,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(Byte.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(Byte.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -972,0 +972,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +998,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1021,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1033,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2974,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(Byte.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(Byte.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -977,0 +977,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -984,0 +1003,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1002,0 +1026,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1008,0 +1038,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2940,0 +2979,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(Byte.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(Byte.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(Byte.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(Byte.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -1116,0 +1116,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1142,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1165,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1177,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1116,0 +1116,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1142,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1165,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1177,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1116,0 +1116,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1142,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1165,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1177,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1116,0 +1116,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1142,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1165,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1177,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1121,0 +1121,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1128,0 +1147,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1146,0 +1170,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1152,0 +1182,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1127,0 +1127,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1153,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1176,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1188,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1127,0 +1127,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1153,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1176,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1188,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1127,0 +1127,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1153,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1176,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1188,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1127,0 +1127,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1153,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1176,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1188,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1132,0 +1132,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1139,0 +1158,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1157,0 +1181,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1163,0 +1193,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3018,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(Integer.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(Integer.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(Integer.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(Integer.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(Integer.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(Integer.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3018,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(Integer.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(Integer.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(Integer.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(Integer.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(Integer.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(Integer.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3018,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(Integer.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(Integer.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(Integer.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(Integer.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(Integer.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(Integer.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3018,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(Integer.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(Integer.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(Integer.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(Integer.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(Integer.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(Integer.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -967,0 +967,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -974,0 +993,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1016,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1028,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2984,0 +3023,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(Integer.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(Integer.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(Integer.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(Integer.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(Integer.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(Integer.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -952,0 +952,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +978,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1001,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1013,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3040,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(Long.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(Long.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(Long.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(Long.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(Long.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(Long.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -952,0 +952,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +978,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1001,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1013,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3040,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(Long.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(Long.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(Long.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(Long.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(Long.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(Long.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -952,0 +952,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +978,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1001,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1013,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3040,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(Long.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(Long.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(Long.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(Long.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(Long.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(Long.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -952,0 +952,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +978,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1001,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1013,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3040,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(Long.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(Long.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(Long.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(Long.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(Long.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(Long.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -957,0 +957,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -964,0 +983,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1006,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -988,0 +1018,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3006,0 +3045,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(Long.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(Long.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(Long.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(Long.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(Long.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(Long.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2965,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(Short.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(Short.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(Short.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(Short.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(Short.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(Short.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2965,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(Short.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(Short.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(Short.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(Short.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(Short.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(Short.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2965,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(Short.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(Short.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(Short.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(Short.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(Short.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(Short.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -962,0 +962,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +988,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1011,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1023,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2965,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(Short.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(Short.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(Short.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(Short.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(Short.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(Short.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -967,0 +967,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -974,0 +993,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1016,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1028,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2931,0 +2970,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(Short.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(Short.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(Short.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(Short.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(Short.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(Short.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+saturating_binary=\"SaturatingBinary-op\"\n+saturating_binary_masked=\"SaturatingBinary-Masked-op\"\n@@ -313,0 +315,7 @@\n+function gen_saturating_binary_op {\n+  echo \"Generating binary op $1 ($2)...\"\n+#  gen_op_tmpl $binary_scalar \"$@\"\n+  gen_op_tmpl $saturating_binary \"$@\"\n+  gen_op_tmpl $saturating_binary_masked \"$@\"\n+}\n+\n@@ -462,0 +471,6 @@\n+gen_binary_op \"UMIN\" \"\\$Wideboxtype\\$.minUnsigned(a, b)\" \"BITWISE\"\n+gen_binary_op \"UMAX\" \"\\$Wideboxtype\\$.maxUnsigned(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SADD\" \"\\$Wideboxtype\\$.addSaturating(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SSUB\" \"\\$Wideboxtype\\$.subSaturating(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SUADD\" \"\\$Wideboxtype\\$.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SUSUB\" \"\\$Wideboxtype\\$.subSaturatingUnsigned(a, b)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-Masked-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-Masked-op.template","status":"copied"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-op.template","status":"copied"},{"patch":"@@ -0,0 +1,7 @@\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-Masked-op.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\n+    static $type$ [[TEST]]($type$ a, $type$ b) {\n+        return ($type$)([[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -1219,0 +1219,19 @@\n+    static final List<IntFunction<$type$[]>> $TYPE$_SATURATING_GENERATORS = List.of(\n+            withToString(\"$type$[$Boxtype$.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MIN_VALUE));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE - 100));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1226,0 +1245,5 @@\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_SATURATING_GENERATOR_PAIRS =\n+        Stream.of($TYPE$_GENERATORS.get(0)).\n+                flatMap(fa -> $TYPE$_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1244,0 +1268,6 @@\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpProvider() {\n+        return $TYPE$_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1250,0 +1280,9 @@\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"}]}