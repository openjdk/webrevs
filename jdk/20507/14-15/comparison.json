{"files":[{"patch":"@@ -6512,1 +6512,1 @@\n-  format %{ \"vector_uminmax_reg  $dst,$a,$b\\t!\" %}\n+  format %{ \"vector_uminmax $dst,$a,$b\\t!\" %}\n@@ -6527,1 +6527,1 @@\n-  format %{ \"vector_uminmax_mem  $dst,$a,$b\\t!\" %}\n+  format %{ \"vector_uminmax $dst,$a,$b\\t!\" %}\n@@ -6543,1 +6543,1 @@\n-  format %{ \"vector_uminmaxq_reg  $dst,$a,$b\\t! using xtmp1 and xtmp2 as TEMP\" %}\n+  format %{ \"vector_uminmaxq $dst,$a,$b\\t! using xtmp1 and xtmp2 as TEMP\" %}\n@@ -6555,1 +6555,1 @@\n-  format %{ \"vector_uminmax_masked_reg $dst, $src1, $src2, $mask\\t! umin\/max masked operation\" %}\n+  format %{ \"vector_uminmax_masked $dst, $src1, $src2, $mask\\t! umin\/max masked operation\" %}\n@@ -6569,1 +6569,1 @@\n-  format %{ \"vector_uminmax_masked_mem $dst, $dst, $src2, $mask\\t! umin\/max masked operation\" %}\n+  format %{ \"vector_uminmax_masked $dst, $dst, $src2, $mask\\t! umin\/max masked operation\" %}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.VectorMath;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @bug 8338021\n+ * @summary Support new unsigned and saturating vector operators in VectorAPI\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib\n+ *\n+ * @run main compiler.vectorapi.VectorMathTests\n+ *\/\n+\n+\n+public class VectorMathTests {\n+    public static final byte  ZEROB = (byte)0;\n+    public static final short ZEROS = (short)0;\n+    public static final int   ZEROI = 0;\n+    public static final long  ZEROL = 0L;\n+\n+    public static final byte  TENB = (byte)10;\n+    public static final int   TENS = (short)10;\n+    public static final short TENI = 10;\n+    public static final long  TENL = 10L;\n+\n+    public static final byte  FIFTYB = (byte)50;\n+    public static final int   FIFTYS = (short)50;\n+    public static final short FIFTYI = 50;\n+    public static final long  FIFTYL = 50L;\n+\n+    public static final byte  SIXTYB = (byte)60;\n+    public static final int   SIXTYS = (short)60;\n+    public static final short SIXTYI = 60;\n+    public static final long  SIXTYL = 60L;\n+\n+    public static final byte  UMAXB = (byte)-1;\n+    public static final short UMAXS = (short)-1;\n+    public static final int   UMAXI = -1;\n+    public static final long  UMAXL = -1L;\n+\n+    public static byte  [] sbinput = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TENB),     ZEROB,   (byte)(Byte.MAX_VALUE - TENB),    Byte.MAX_VALUE};\n+    public static short [] ssinput = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TENS),   ZEROS,   (short)(Short.MAX_VALUE - TENS),  Short.MAX_VALUE};\n+    public static int   [] siinput = {Integer.MIN_VALUE, (Integer.MIN_VALUE + TENI),        ZEROI,   Integer.MAX_VALUE - TENI,         Integer.MAX_VALUE};\n+    public static long  [] slinput = {Long.MIN_VALUE,    Long.MIN_VALUE + TENL,             ZEROL,   Long.MAX_VALUE - TENL,            Long.MAX_VALUE};\n+\n+    public static int   [] saddended    = {-FIFTYI,           -FIFTYI,           -FIFTYI,    FIFTYI,            FIFTYI};\n+    public static byte  [] boutput_sadd = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTYB,    Byte.MAX_VALUE,    Byte.MAX_VALUE};\n+    public static short [] soutput_sadd = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTYS,    Short.MAX_VALUE,   Short.MAX_VALUE};\n+    public static int   [] ioutput_sadd = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTYI,    Integer.MAX_VALUE, Integer.MAX_VALUE};\n+    public static long  [] loutput_sadd = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTYL,    Long.MAX_VALUE,    Long.MAX_VALUE};\n+\n+    public static int   [] ssubtrahend  = {FIFTYI,            FIFTYI,             FIFTYI,    -FIFTYI,           -FIFTYI};\n+    public static byte  [] boutput_ssub = {Byte.MIN_VALUE,    Byte.MIN_VALUE,    -FIFTYB,    Byte.MAX_VALUE,    Byte.MAX_VALUE};\n+    public static short [] soutput_ssub = {Short.MIN_VALUE,   Short.MIN_VALUE,   -FIFTYS,    Short.MAX_VALUE,   Short.MAX_VALUE};\n+    public static int   [] ioutput_ssub = {Integer.MIN_VALUE, Integer.MIN_VALUE, -FIFTYI,        Integer.MAX_VALUE, Integer.MAX_VALUE};\n+    public static long  [] loutput_ssub = {Long.MIN_VALUE,    Long.MIN_VALUE,    -FIFTYL,       Long.MAX_VALUE,    Long.MAX_VALUE};\n+\n+    public static byte  [] ubinput = {ZEROB,   (byte)(ZEROB + TENB),   (byte)(UMAXB - TENB),   UMAXB};\n+    public static short [] usinput = {ZEROS,   (short)(ZEROS + TENS),  (short)(UMAXS - TENS),  UMAXS};\n+    public static int   [] uiinput = {ZEROI,   ZEROI + TENI,           UMAXI - TENI,           UMAXI};\n+    public static long  [] ulinput = {ZEROL,   ZEROL + TENL,           UMAXL - TENL,           UMAXL};\n+\n+    public static int   [] uaddended     = {FIFTYI,  FIFTYI,   FIFTYI,    FIFTYI};\n+    public static byte  [] boutput_usadd = {FIFTYB,  SIXTYB,   UMAXB,     UMAXB};\n+    public static short [] soutput_usadd = {FIFTYS,  SIXTYS,   UMAXS,     UMAXS};\n+    public static int   [] ioutput_usadd = {FIFTYI,  SIXTYI,   UMAXI,     UMAXI};\n+    public static long  [] loutput_usadd = {FIFTYL,  SIXTYL,   UMAXL,     UMAXL};\n+\n+    public static int   [] usubtrahend   = {FIFTYI,  FIFTYI,  FIFTYI,  FIFTYI};\n+    public static byte  [] boutput_ussub = {ZEROB,   ZEROB,   UMAXB - SIXTYB,  UMAXB - FIFTYB};\n+    public static short [] soutput_ussub = {ZEROS,   ZEROS,   UMAXS - SIXTYS,  UMAXS - FIFTYS};\n+    public static int   [] ioutput_ussub = {ZEROI,   ZEROI,   UMAXI - SIXTYI,  UMAXI - FIFTYI};\n+    public static long  [] loutput_ussub = {ZEROL,   ZEROL,   UMAXL - SIXTYL,  UMAXL - FIFTYL};\n+\n+    public static byte  [] boutput_umin = {ZEROB,   TENB,   ZEROB,   Byte.MAX_VALUE - TENB};\n+    public static short [] soutput_umin = {ZEROS,   TENS,   ZEROS,   Short.MAX_VALUE - TENS};\n+    public static int   [] ioutput_umin = {ZEROI,   TENI,   ZEROI,   Integer.MAX_VALUE - TENI};\n+    public static long  [] loutput_umin = {ZEROL,   TENL,   ZEROL,   Long.MAX_VALUE - TENL};\n+\n+    public static byte  [] boutput_umax = {Byte.MIN_VALUE,    (byte)(Byte.MIN_VALUE + TENB),   (byte)(UMAXB - TENB),  UMAXB};\n+    public static short [] soutput_umax = {Short.MIN_VALUE,   (short)(Short.MIN_VALUE + TENS), (short)(UMAXS - TENS), UMAXS};\n+    public static int   [] ioutput_umax = {Integer.MIN_VALUE, Integer.MIN_VALUE + TENI,        (UMAXI - TENI),        UMAXI};\n+    public static long  [] loutput_umax = {Long.MIN_VALUE,    Long.MIN_VALUE + TENL,           (UMAXL - TENL),        UMAXL};\n+\n+    public static void test_saturated_add(Class<?> type) {\n+        if (type == byte.class) {\n+            IntStream.range(0, sbinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturating(sbinput[i], (byte)saddended[i]),\n+                                                                         boutput_sadd[i],\n+                                                                         \"[addSaturating byte] idx = \" + i + \" : \"));\n+        } else if (type == short.class) {\n+            IntStream.range(0, ssinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturating(ssinput[i], (short)saddended[i]),\n+                                                                         soutput_sadd[i],\n+                                                                         \"[addSaturating short] idx = \" + i + \" : \"));\n+        } else if (type == int.class) {\n+            IntStream.range(0, siinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturating(siinput[i], saddended[i]),\n+                                                                         ioutput_sadd[i],\n+                                                                         \"[addSaturating int] idx = \" + i + \" : \"));\n+        } else if (type == long.class) {\n+            IntStream.range(0, slinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturating(slinput[i], (long)saddended[i]),\n+                                                                         loutput_sadd[i],\n+                                                                         \"[addSaturating long] idx = \" + i + \" : \"));\n+        }\n+    }\n+\n+    public static void test_saturated_sub(Class<?> type) {\n+        if (type == byte.class) {\n+            IntStream.range(0, sbinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturating(sbinput[i], (byte)ssubtrahend[i]),\n+                                                                         boutput_ssub[i],\n+                                                                         \"[subSaturating byte] idx = \" + i + \" : \"));\n+        } else if (type == short.class) {\n+            IntStream.range(0, ssinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturating(ssinput[i], (short)ssubtrahend[i]),\n+                                                                         soutput_ssub[i],\n+                                                                         \"[subSaturating short] idx = \" + i + \" : \"));\n+        } else if (type == int.class) {\n+            IntStream.range(0, siinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturating(siinput[i], ssubtrahend[i]),\n+                                                                         ioutput_ssub[i],\n+                                                                         \"[subSaturating int] idx = \" + i + \" : \"));\n+        } else if (type == long.class) {\n+            IntStream.range(0, slinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturating(slinput[i], (long)ssubtrahend[i]),\n+                                                                         loutput_ssub[i],\n+                                                                         \"[subSaturating long] idx = \" + i + \" : \"));\n+        }\n+    }\n+\n+    public static void test_saturated_uadd(Class<?> type) {\n+        if (type == byte.class) {\n+            IntStream.range(0, ubinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(ubinput[i], (byte)uaddended[i]),\n+                                                                                 boutput_usadd[i],\n+                                                                                 \"[addSaturatingUnsigned byte] idx = \" + i + \" : \"));\n+        } else if (type == short.class) {\n+            IntStream.range(0, usinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(usinput[i], (short)uaddended[i]),\n+                                                                                 soutput_usadd[i],\n+                                                                                 \"[addSaturatingUnsigned short] idx = \" + i + \" : \"));\n+        } else if (type == int.class) {\n+            IntStream.range(0, uiinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(uiinput[i], uaddended[i]),\n+                                                                                 ioutput_usadd[i],\n+                                                                                 \"[addSaturatingUnsigned int] idx = \" + i + \" : \"));\n+        } else if (type == long.class) {\n+            IntStream.range(0, ulinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.addSaturatingUnsigned(ulinput[i], (long)uaddended[i]),\n+                                                                                 loutput_usadd[i],\n+                                                                                 \"[addSaturatingUnsigned long] idx = \" + i + \" : \"));\n+        }\n+    }\n+\n+    public static void test_saturated_usub(Class<?> type) {\n+        if (type == byte.class) {\n+            IntStream.range(0, ubinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(ubinput[i], (byte)usubtrahend[i]),\n+                                                                                 boutput_ussub[i],\n+                                                                                 \"[subSaturatingUnsigned byte] idx = \" + i + \" : \"));\n+        } else if (type == short.class) {\n+            IntStream.range(0, usinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(usinput[i], (short)usubtrahend[i]),\n+                                                                                 soutput_ussub[i],\n+                                                                                 \"[subSaturatingUnsigned short] idx = \" + i + \" : \"));\n+        } else if (type == int.class) {\n+            IntStream.range(0, uiinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(uiinput[i], usubtrahend[i]),\n+                                                                                 ioutput_ussub[i],\n+                                                                                 \"[subSaturatingUnsigned int] idx = \" + i + \" : \"));\n+        } else if (type == long.class) {\n+            IntStream.range(0, ulinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.subSaturatingUnsigned(ulinput[i], (long)usubtrahend[i]),\n+                                                                                 loutput_ussub[i],\n+                                                                                 \"[subSaturatingUnsigned long] idx = \" + i + \" : \"));\n+        }\n+    }\n+\n+    public static void test_umin(Class<?> type) {\n+        if (type == byte.class) {\n+            IntStream.range(0, ubinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.minUnsigned(ubinput[i], sbinput[i]), boutput_umin[i], \"[minUnsigned byte] idx = \" + i + \" : \"));\n+        } else if (type == short.class) {\n+            IntStream.range(0, usinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.minUnsigned(usinput[i], ssinput[i]), soutput_umin[i], \"[minUnsigned short] idx = \" + i + \" : \"));\n+        } else if (type == int.class) {\n+            IntStream.range(0, uiinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.minUnsigned(uiinput[i], siinput[i]), ioutput_umin[i], \"[minUnsigned int] idx = \" + i + \" : \"));\n+        } else if (type == long.class) {\n+            IntStream.range(0, ulinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.minUnsigned(ulinput[i], slinput[i]), loutput_umin[i], \"[minUnsigned long] idx = \" + i + \" : \"));\n+        }\n+    }\n+\n+    public static void test_umax(Class<?> type) {\n+        if (type == byte.class) {\n+            IntStream.range(0, ubinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(ubinput[i], sbinput[i]), boutput_umax[i], \"[maxUnsigned byte] idx = \" + i + \" : \"));\n+        } else if (type == short.class) {\n+            IntStream.range(0, usinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(usinput[i], ssinput[i]), soutput_umax[i], \"[maxUnsigned short] idx = \" + i + \" : \"));\n+        } else if (type == int.class) {\n+            IntStream.range(0, uiinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(uiinput[i], siinput[i]), ioutput_umax[i], \"[maxUnsigned int] idx = \" + i + \" : \"));\n+        } else if (type == long.class) {\n+            IntStream.range(0, ulinput.length)\n+                     .forEach(i -> assertEquals(VectorMath.maxUnsigned(ulinput[i], slinput[i]), loutput_umax[i], \"[maxUnsigned long] idx = \" + i + \" : \"));\n+        }\n+    }\n+\n+    public static void assertEquals(Number res, Number ref, String msg) {\n+        if (!res.equals(ref)) {\n+            throw new RuntimeException(msg +  ref + \"(ref)  != \" + res + \"(res)\");\n+        }\n+    }\n+\n+    public static void main(String [] args) {\n+        for (int i = 0; i < 1; i++) {\n+            test_saturated_add(byte.class);\n+            test_saturated_add(short.class);\n+            test_saturated_add(int.class);\n+            test_saturated_add(long.class);\n+\n+            test_saturated_sub(byte.class);\n+            test_saturated_sub(short.class);\n+            test_saturated_sub(int.class);\n+            test_saturated_sub(long.class);\n+\n+            test_saturated_uadd(byte.class);\n+            test_saturated_uadd(short.class);\n+            test_saturated_uadd(int.class);\n+            test_saturated_uadd(long.class);\n+\n+            test_saturated_usub(byte.class);\n+            test_saturated_usub(short.class);\n+            test_saturated_usub(int.class);\n+            test_saturated_usub(long.class);\n+\n+            test_umin(byte.class);\n+            test_umin(short.class);\n+            test_umin(int.class);\n+            test_umin(long.class);\n+\n+            test_umax(byte.class);\n+            test_umax(short.class);\n+            test_umax(int.class);\n+            test_umax(long.class);\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMathTests.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -1116,1 +1116,0 @@\n-\n@@ -1124,1 +1123,0 @@\n-\n@@ -1143,1 +1141,0 @@\n-\n@@ -1150,1 +1147,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1116,1 +1116,0 @@\n-\n@@ -1124,1 +1123,0 @@\n-\n@@ -1143,1 +1141,0 @@\n-\n@@ -1150,1 +1147,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1116,1 +1116,0 @@\n-\n@@ -1124,1 +1123,0 @@\n-\n@@ -1143,1 +1141,0 @@\n-\n@@ -1150,1 +1147,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1116,1 +1116,0 @@\n-\n@@ -1124,1 +1123,0 @@\n-\n@@ -1143,1 +1141,0 @@\n-\n@@ -1150,1 +1147,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1121,1 +1121,0 @@\n-\n@@ -1129,1 +1128,0 @@\n-\n@@ -1148,1 +1146,0 @@\n-\n@@ -1155,1 +1152,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1127,1 +1127,0 @@\n-\n@@ -1135,1 +1134,0 @@\n-\n@@ -1154,1 +1152,0 @@\n-\n@@ -1161,1 +1158,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1127,1 +1127,0 @@\n-\n@@ -1135,1 +1134,0 @@\n-\n@@ -1154,1 +1152,0 @@\n-\n@@ -1161,1 +1158,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1127,1 +1127,0 @@\n-\n@@ -1135,1 +1134,0 @@\n-\n@@ -1154,1 +1152,0 @@\n-\n@@ -1161,1 +1158,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1127,1 +1127,0 @@\n-\n@@ -1135,1 +1134,0 @@\n-\n@@ -1154,1 +1152,0 @@\n-\n@@ -1161,1 +1158,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1132,1 +1132,0 @@\n-\n@@ -1140,1 +1139,0 @@\n-\n@@ -1159,1 +1157,0 @@\n-\n@@ -1166,1 +1163,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1241,1 +1241,0 @@\n-#end[!FP]\n@@ -1243,0 +1242,1 @@\n+#end[!FP]\n@@ -1255,1 +1255,0 @@\n-#end[!FP]\n@@ -1257,0 +1256,1 @@\n+#end[!FP]\n@@ -1281,1 +1281,0 @@\n-#end[!FP]\n@@ -1283,0 +1282,1 @@\n+#end[!FP]\n@@ -1298,1 +1298,0 @@\n-#end[!FP]\n@@ -1300,0 +1299,1 @@\n+#end[!FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}