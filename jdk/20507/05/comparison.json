{"files":[{"patch":"@@ -560,0 +560,8 @@\n+#ifndef PRODUCT\n+bool Assembler::needs_evex(XMMRegister reg1, XMMRegister reg2, XMMRegister reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+#endif\n+\n@@ -3354,1 +3362,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3371,1 +3379,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3391,1 +3399,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3412,1 +3420,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3432,1 +3440,1 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n@@ -3447,0 +3455,13 @@\n+void Assembler::evmovdquw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x6F, (0xC0 | encode));\n+}\n+\n+\n@@ -4555,0 +4576,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4562,1 +4584,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4574,1 +4597,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4587,0 +4611,9 @@\n+void Assembler::evpcmpub(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x3E, (0xC0 | encode), vcc);\n+}\n+\n@@ -4588,1 +4621,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4595,0 +4629,8 @@\n+void Assembler::evpcmpud(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1E, (0xC0 | encode), vcc);\n+}\n+\n@@ -4596,1 +4638,1 @@\n-  assert(VM_Version::supports_avx512vl(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4604,1 +4646,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4618,0 +4661,1 @@\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -4629,1 +4673,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -7657,0 +7702,155 @@\n+void Assembler::vpaddsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xEC, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xEC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpaddsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xED, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xED);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpaddusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDC, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n+void Assembler::vpaddusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDD, (0xC0 | encode));\n+}\n+\n+void Assembler::vpaddusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n+void Assembler::vpsubsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE8, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE9, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpsubusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD9, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsubusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\n@@ -7686,7 +7886,0 @@\n-void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n-}\n-\n@@ -7869,8 +8062,0 @@\n-void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n-        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16(0xDA, (0xC0 | encode));\n-}\n-\n@@ -8022,15 +8207,6 @@\n-\/\/ Shift packed integers left by specified number of bits.\n-void Assembler::psllw(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n-}\n-\n-void Assembler::pslld(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds, src) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDA, (0xC0 | encode));\n@@ -8039,6 +8215,9 @@\n-void Assembler::psllq(XMMRegister dst, int shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n-  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDA);\n+  emit_operand(dst, src, 0);\n@@ -8047,5 +8226,10 @@\n-void Assembler::psllw(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n+void Assembler::evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDA, (0xC0 | encode));\n@@ -8054,5 +8238,13 @@\n-void Assembler::pslld(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF2, (0xC0 | encode));\n+void Assembler::evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDA);\n+  emit_operand(dst, src, 0);\n@@ -8061,6 +8253,6 @@\n-void Assembler::psllq(XMMRegister dst, XMMRegister shift) {\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_rex_vex_w_reverted();\n-  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16((unsigned char)0xF3, (0xC0 | encode));\n+void Assembler::vpminuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3A, (0xC0 | encode));\n@@ -8069,2 +8261,4 @@\n-void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n+void Assembler::vpminuw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  assert(!needs_evex(dst, nds) || VM_Version::supports_avx512bw(), \"\");\n+  InstructionMark im(this);\n@@ -8072,3 +8266,4 @@\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n-  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3A);\n+  emit_operand(dst, src, 0);\n@@ -8077,7 +8272,10 @@\n-void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n-  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+void Assembler::evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3A, (0xC0 | encode));\n@@ -8086,4 +8284,331 @@\n-void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_rex_vex_w_reverted();\n+void Assembler::evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3A);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpminud(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::vpminud(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3B);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDE, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxub(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDE);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDE, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDE);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3E, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxuw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  assert(UseAVX > 0 && (vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3E, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpmaxud(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"\");\n+  assert((vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds, src) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::vpmaxud(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(UseAVX > 0, \"\");\n+  assert((vector_len == Assembler::AVX_512bit || (!needs_evex(dst, nds) || VM_Version::supports_avx512vl())), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x3F, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x3F);\n+  emit_operand(dst, src, 0);\n+}\n+\n+\/\/ Shift packed integers left by specified number of bits.\n+void Assembler::psllw(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::pslld(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::psllq(XMMRegister dst, int shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 73 \/6 ib\n+  int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x73, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::psllw(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF1, (0xC0 | encode));\n+}\n+\n+void Assembler::pslld(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF2, (0xC0 | encode));\n+}\n+\n+void Assembler::psllq(XMMRegister dst, XMMRegister shift) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF3, (0xC0 | encode));\n+}\n+\n+void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 71 \/6 ib\n+  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x71, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  \/\/ XMM6 is for \/6 encoding: 66 0F 72 \/6 ib\n+  int encode = vex_prefix_and_encode(xmm6->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int24(0x72, (0xC0 | encode), shift & 0xFF);\n+}\n+\n+void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n@@ -9716,0 +10241,217 @@\n+void Assembler::evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xEC, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xEC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xED, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xED);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDC, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDC);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xDD, (0xC0 | encode));\n+}\n+\n+void Assembler::evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE8, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE9, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xE9);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n+}\n+\n+void Assembler::evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD8);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD9, (0xC0 | encode));\n+}\n+\n+\n+void Assembler::evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  InstructionMark im(this);\n+  assert(VM_Version::supports_avx512bw() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8((unsigned char)0xD9);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":821,"deletions":79,"binary":false,"changes":900,"status":"modified"},{"patch":"@@ -783,0 +783,1 @@\n+  bool needs_evex(XMMRegister reg1, XMMRegister reg2 = xnoreg, XMMRegister reg3 = xnoreg);\n@@ -1900,0 +1901,2 @@\n+  void evpcmpub(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n+\n@@ -1903,0 +1906,1 @@\n+  void evpcmpud(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n@@ -2505,0 +2509,34 @@\n+  \/\/ Saturating packed insturctions.\n+  void vpaddsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpaddusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void vpsubsb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubsw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void vpsubusw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void vpaddsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpaddusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evpaddsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpaddusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void vpsubsb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubsw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubusb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubusw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evpsubsb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubsw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubusb(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpsubusw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n@@ -2648,1 +2686,0 @@\n-  void vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2674,1 +2711,0 @@\n-  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n@@ -2698,0 +2734,32 @@\n+  \/\/ Unsigned maximum packed integers.\n+  void vpmaxub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxuw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxud(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmaxub(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpmaxuw(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpmaxud(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n+  \/\/ Unsigned minimum packed integers.\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminuw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminud(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpminub(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpminuw(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void vpminud(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n+  void evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminub(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminuw(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminud(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpminuq(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":70,"deletions":2,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -906,0 +906,66 @@\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, Address src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vpuminmaxq(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  \/\/ T1 = -1\n+  vpcmpeqq(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  \/\/ T1 = -1 << 63\n+  vpsllq(xtmp1, xtmp1, 63, vlen_enc);\n+  \/\/ Convert SRC2 to signed value i.e. T2 = T1 + SRC2\n+  vpaddq(xtmp2, xtmp1, src2, vlen_enc);\n+  \/\/ Convert SRC1 to signed value i.e. T1 = T1 + SRC1\n+  vpaddq(xtmp1, xtmp1, src1, vlen_enc);\n+  \/\/ Mask = T2 > T1\n+  vpcmpgtq(xtmp1, xtmp2, xtmp1, vlen_enc);\n+  if (opcode == Op_UMaxV) {\n+    \/\/ Res = Mask ? Src2 : Src1\n+    vpblendvb(dst, src1, src2, xtmp1, vlen_enc);\n+  } else {\n+    \/\/ Res = Mask ? Src1 : Src2\n+    vpblendvb(dst, src2, src1, xtmp1, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n@@ -2329,0 +2395,4 @@\n+void C2_MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  MacroAssembler::evmovdqu(type, kmask, dst, src, merge, vector_len);\n+}\n+\n@@ -4601,1 +4671,120 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               XMMRegister src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                      XMMRegister src1, XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                        XMMRegister src1, XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               Address src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                      XMMRegister src1, Address src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                        XMMRegister src1, Address src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n@@ -4691,0 +4880,4 @@\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4698,1 +4891,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -4751,0 +4945,4 @@\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4758,1 +4956,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -6445,0 +6644,379 @@\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_sub_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                              XMMRegister src2, KRegister ktmp, int vlen_enc) {\n+  \/\/ For unsigned subtraction, overflow happens when magnitude of second input is greater than first input.\n+  \/\/ overflow_mask = Inp1 <u Inp2\n+  evpcmpu(elem_bt, ktmp,  src2, src1, Assembler::lt, vlen_enc);\n+  \/\/ Res = overflow_mask ? Zero : INP1 - INP2 (non-commutative and non-associative)\n+  evmasked_op(elem_bt == T_INT ? Op_SubVI : Op_SubVL, elem_bt, ktmp, dst, src1, src2, false, vlen_enc, false);\n+}\n+\n+void C2_MacroAssembler::vector_sub_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                              XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  \/\/ Emulate unsigned comparison using signed comparison\n+  \/\/ Mask = Inp1 <u Inp2 => Inp1 + MIN_VALUE < Inp2 + MIN_VALUE\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc, true);\n+  vpadd(elem_bt, xtmp2, src1, xtmp1, vlen_enc);\n+  vpadd(elem_bt, xtmp1, src2, xtmp1, vlen_enc);\n+\n+  vpcmpgt(elem_bt, xtmp2, xtmp1, xtmp2, vlen_enc);\n+\n+  \/\/ Res = INP1 - INP2 (non-commutative and non-associative)\n+  vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ Res = Mask ? Zero : Res\n+  vpxor(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpblendvb(dst, dst, xtmp1, xtmp2, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::vector_add_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                               XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp, int vlen_enc) {\n+  \/\/ Unsigned values ranges comprise of only +ve numbers, thus there exist only an upper bound saturation.\n+  \/\/ overflow_mask = (SRC1 + SRC2) <u (SRC1 | SRC2)\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ T1 = SRC1 | SRC2\n+  vpor(xtmp1, src1, src2, vlen_enc);\n+  \/\/ Max_Unsigned = -1\n+  vpternlogd(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+  \/\/ Unsigned compare:  Mask = Res <u T1\n+  evpcmpu(elem_bt, ktmp, dst, xtmp1, Assembler::lt, vlen_enc);\n+  \/\/ res  = Mask ? Max_Unsigned : Res\n+  evpblend(elem_bt, dst, ktmp,  dst, xtmp2, true, vlen_enc);\n+}\n+\n+\/\/\n+\/\/ Section 2-13 Hacker's Delight list following overflow detection check for saturating\n+\/\/ unsigned addition operation.\n+\/\/    overflow_mask = ((a & b) | ((a | b) & ~( a + b))) >>> 31 == 1\n+\/\/\n+\/\/ We empirically determined its semantic equivalence to following reduced expression\n+\/\/    overflow_mask =  (a + b) <u (a | b)\n+\/\/\n+\/\/ and also verified it though Alive2 solver.\n+\/\/ (https:\/\/alive2.llvm.org\/ce\/z\/XDQ7dY)\n+\/\/\n+\n+void C2_MacroAssembler::vector_add_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                              XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, int vlen_enc) {\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ Compute T1 = INP1 | INP2\n+  vpor(xtmp3, src1, src2, vlen_enc);\n+  \/\/ T1 = Minimum signed value.\n+  vpgenmin_value(elem_bt, xtmp2, xtmp1, vlen_enc, true);\n+  \/\/ Convert T1 to signed value, T1 = T1 + MIN_VALUE\n+  vpadd(elem_bt, xtmp3, xtmp3, xtmp2, vlen_enc);\n+  \/\/ Convert Res to signed value, Res<s> = Res + MIN_VALUE\n+  vpadd(elem_bt, xtmp2, xtmp2, dst, vlen_enc);\n+  \/\/ Compute overflow detection mask = Res<1> <s T1\n+  if (elem_bt == T_INT) {\n+    vpcmpgtd(xtmp3, xtmp3, xtmp2, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_LONG, \"\");\n+    vpcmpgtq(xtmp3, xtmp3, xtmp2, vlen_enc);\n+  }\n+  vpblendvb(dst, dst, xtmp1, xtmp3, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovq2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogq(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    evpsraq(xtmp1, src, 63, vlen_enc);\n+    evpcmpeqq(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovd2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogd(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    vpsrad(xtmp1, src, 31, vlen_enc);\n+    Assembler::evpcmpeqd(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+\n+void C2_MacroAssembler::vpsign_extend_dq(BasicType elem_bt, XMMRegister dst, XMMRegister src, int vlen_enc) {\n+  if (elem_bt == T_LONG) {\n+    if (VM_Version::supports_evex()) {\n+      evpsraq(dst, src, 63, vlen_enc);\n+    } else {\n+      vpsrad(dst, src, 31, vlen_enc);\n+      vpshufd(dst, dst, 0xF5, vlen_enc);\n+    }\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpsrad(dst, src, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmax_value(BasicType elem_bt, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (elem_bt == T_LONG) {\n+    vpsrlq(dst, allones, 1, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpsrld(dst, allones, 1, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmin_value(BasicType elem_bt, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (elem_bt == T_LONG) {\n+    vpsllq(dst, allones, 63, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpslld(dst, allones, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpcmpu(BasicType elem_bt, KRegister kmask,  XMMRegister src1, XMMRegister src2,\n+                                Assembler::ComparisonPredicate cond, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_LONG:  evpcmpuq(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_INT:   evpcmpud(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_SHORT: evpcmpuw(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_BYTE:  evpcmpub(kmask, src1, src2, cond, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpgt(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case  T_LONG:  vpcmpgtq(dst, src1, src2, vlen_enc); break;\n+    case  T_INT:   vpcmpgtd(dst, src1, src2, vlen_enc); break;\n+    case  T_SHORT: vpcmpgtw(dst, src1, src2, vlen_enc); break;\n+    case  T_BYTE:  vpcmpgtb(dst, src1, src2, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmov_vec_to_mask(BasicType elem_bt, KRegister ktmp, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1) {\n+  if (elem_bt == T_LONG) {\n+    evpmovq2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    evpmovd2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_addsub_dq_saturating_evex(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                         XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                         KRegister ktmp1, KRegister ktmp2, int vlen_enc) {\n+  assert(elem_bt == T_INT || elem_bt == T_LONG, \"\");\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (ideal_opc == Op_SaturatingAddV) {\n+    \/\/ res = src1 + src2\n+    vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(ideal_opc == Op_SaturatingSubV, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Compute overflow detection mask.\n+  evpmov_vec_to_mask(elem_bt, ktmp1, xtmp2, xtmp2, xtmp1, vlen_enc);\n+  \/\/ Note: xtmp1 hold -1 in all its lanes after above call.\n+\n+  \/\/ Compute mask based on first input polarity.\n+  evpmov_vec_to_mask(elem_bt, ktmp2, src1, xtmp2, xtmp1, vlen_enc, true);\n+\n+  vpgenmax_value(elem_bt, xtmp2, xtmp1, vlen_enc, true);\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose a vector of saturating (MAX\/MIN) values, where lanes corresponding to\n+  \/\/ set bits in first input polarity mask holds a min value.\n+  evpblend(elem_bt, xtmp2, ktmp2, xtmp2, xtmp1, true, vlen_enc);\n+  \/\/ Blend destination lanes with saturated values using overflow detection mask.\n+  evpblend(elem_bt, dst, ktmp1, dst, xtmp2, true, vlen_enc);\n+}\n+\n+\n+void C2_MacroAssembler::vector_addsub_dq_saturating_avx(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                        XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                        XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc) {\n+  assert(elem_bt == T_INT || elem_bt == T_LONG, \"\");\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (ideal_opc == Op_SaturatingAddV) {\n+    \/\/ res = src1 + src2\n+    vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(ideal_opc == Op_SaturatingSubV, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Sign-extend to compute overflow detection mask.\n+  vpsign_extend_dq(elem_bt, xtmp3, xtmp2, vlen_enc);\n+\n+  vpcmpeqd(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpgenmax_value(elem_bt, xtmp2, xtmp1, vlen_enc);\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose saturating min\/max vector using first input polarity mask.\n+  vpsign_extend_dq(elem_bt, xtmp4, src1, vlen_enc);\n+  vpblendvb(xtmp1, xtmp2, xtmp1, xtmp4, vlen_enc);\n+\n+  \/\/ Blend result with saturating vector using overflow detection mask.\n+  vpblendvb(dst, dst, xtmp1, xtmp3, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    vector_saturating_unsigned_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  } else {\n+    vector_saturating_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    vector_saturating_unsigned_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  } else {\n+    vector_saturating_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":581,"deletions":3,"binary":false,"changes":584,"status":"modified"},{"patch":"@@ -59,0 +59,8 @@\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                int vlen_enc);\n+\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, Address src2,\n+                int vlen_enc);\n+\n@@ -63,0 +71,3 @@\n+\n+  void vpuminmaxq(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n@@ -108,0 +119,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -508,0 +520,63 @@\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void vector_saturating_unsigned_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void vector_saturating_unsigned_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void vector_sub_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, KRegister ktmp, int vlen_enc);\n+\n+  void vector_sub_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                             XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n+  void vector_add_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                              XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp, int vlen_enc);\n+\n+  void vector_add_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                             XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, int vlen_enc);\n+\n+  void vector_addsub_dq_saturating_avx(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc);\n+\n+  void vector_addsub_dq_saturating_evex(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                        XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, int vlen_enc);\n+\n+  void evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void vpsign_extend_dq(BasicType etype, XMMRegister dst, XMMRegister src, int vlen_enc);\n+\n+  void vpgenmin_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void vpgenmax_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void evpcmpu(BasicType etype, KRegister kmask,  XMMRegister src1, XMMRegister src2, Assembler::ComparisonPredicate cond, int vlen_enc);\n+\n+  void vpcmpgt(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void evpmov_vec_to_mask(BasicType etype, KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                          int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       XMMRegister src2, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       Address src2, bool merge, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -9306,0 +9306,24 @@\n+void MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evmovdqub(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evmovdquw(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evmovdqul(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evmovdquq(dst, kmask, src, merge, vector_len);\n+      break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type));\n+      break;\n+  }\n+}\n+\n@@ -9497,0 +9521,60 @@\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1281,0 +1281,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -1587,0 +1588,5 @@\n+\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1768,0 +1768,6 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+      if (UseAVX == 0) {\n+        return false;\n+      }\n+      break;\n@@ -1938,0 +1944,9 @@\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (UseAVX < 1) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      if (is_subword_type(bt) && size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n@@ -2114,0 +2129,2 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n@@ -2121,0 +2138,9 @@\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (!is_subword_type(bt)) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 || !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n@@ -6480,0 +6506,74 @@\n+\/\/ ------------------------------ Unsigned vector Min\/Max ----------------------\n+\n+instruct vector_uminmax_reg(vec dst, vec a, vec b) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_LONG);\n+  match(Set dst (UMinV a b));\n+  match(Set dst (UMaxV a b));\n+  format %{ \"vector_uminmax_reg  $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_mem(vec dst, vec a, memory b) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_LONG);\n+  match(Set dst (UMinV a (LoadVector b)));\n+  match(Set dst (UMaxV a (LoadVector b)));\n+  format %{ \"vector_uminmax_mem  $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmaxq_reg(vec dst, vec a, vec b, vec xtmp1, vec xtmp2) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (UMinV a b));\n+  match(Set dst (UMaxV a b));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_uminmaxq_reg  $dst,$a,$b\\t! using xtmp1 and xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpuminmaxq(opcode, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_reg_masked(vec dst, vec src1, vec src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 src2) mask));\n+  match(Set dst (UMaxV (Binary src1 src2) mask));\n+  format %{ \"vector_uminmax_masked_reg $dst, $src1, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_mem_masked(vec dst, vec src1, memory src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 (LoadVector src2)) mask));\n+  match(Set dst (UMaxV (Binary src1 (LoadVector src2)) mask));\n+  format %{ \"vector_uminmax_masked_mem $dst, $dst, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $src1$$XMMRegister, $src2$$Address, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10471,0 +10571,231 @@\n+\n+instruct vector_saturating_subword_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  format %{ \"vector_saturating_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$XMMRegister, false, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_unsigned_subword_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  format %{ \"vector_saturating_unsigned_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2);\n+  format %{ \"vector_saturating_evex $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_addsub_dq_saturating_evex(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                                        $src1$$XMMRegister, $src2$$XMMRegister,\n+                                        $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                                        $ktmp1$$KRegister, $ktmp2$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4);\n+  format %{ \"vector_saturating_avx $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_addsub_dq_saturating_avx(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister, $src1$$XMMRegister,\n+                                       $src2$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                                       $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_add_saturating_unsigned_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, kReg ktmp)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp);\n+  format %{ \"vector_add_saturating_unsigned_evex $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2 and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_add_dq_saturating_unsigned_evex(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                              $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_add_saturating_unsigned_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3);\n+  format %{ \"vector_add_saturating_unsigned_avx $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2 and $xtmp3 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_add_dq_saturating_unsigned_avx(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sub_saturating_unsigned_reg_evex(vec dst, vec src1, vec src2, kReg ktmp)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP ktmp);\n+  format %{ \"vector_sub_saturating_unsigned_evex $dst, $src1, $src2 \\t! using $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_sub_dq_saturating_unsigned_evex(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister,\n+                                              $src2$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sub_saturating_unsigned_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_sub_saturating_unsigned_avx $dst, $src1, $src2 \\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_sub_dq_saturating_unsigned_avx(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_subword_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubV src1 (LoadVector src2)));\n+  format %{ \"vector_saturating_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$Address, false, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_unsigned_subword_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubV src1 (LoadVector src2)));\n+  format %{ \"vector_saturating_unsigned_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$Address, true, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_saturating_subword_masked_reg(vec dst, vec src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst src) mask));\n+  match(Set dst (SaturatingSubV (Binary dst src) mask));\n+  format %{ \"vector_saturating_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$XMMRegister, false, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_saturating_unsigned_subword_masked_reg(vec dst, vec src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst src) mask));\n+  match(Set dst (SaturatingSubV (Binary dst src) mask));\n+  format %{ \"vector_saturating_unsigned_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$XMMRegister, true, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_saturating_subword_masked_mem(vec dst, memory src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubV (Binary dst (LoadVector src)) mask));\n+  format %{ \"vector_saturating_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$Address, false, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_saturating_unsigned_subword_masked_mem(vec dst, memory src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubV (Binary dst (LoadVector src)) mask));\n+  format %{ \"vector_saturating_unsigned_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$Address, true, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":331,"deletions":0,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -4339,1 +4339,1 @@\n-    \"MaxV\", \"MinV\",\n+    \"MaxV\", \"MinV\", \"UMinV\", \"UMaxV\",\n@@ -4362,1 +4362,1 @@\n-    \"CountLeadingZerosV\", \"CountTrailingZerosV\", \"SignumVF\", \"SignumVD\",\n+    \"CountLeadingZerosV\", \"CountTrailingZerosV\", \"SignumVF\", \"SignumVD\", \"SaturatingAddV\", \"SaturatingSubV\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -331,0 +331,2 @@\n+macro(SaturatingAddV)\n+macro(SaturatingSubV)\n@@ -438,0 +440,2 @@\n+macro(UMinV)\n+macro(UMaxV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+class SaturatingVectorNode;\n@@ -742,0 +743,1 @@\n+        DEFINE_CLASS_ID(SaturatingVector, Vector, 9)\n@@ -1007,0 +1009,1 @@\n+  DEFINE_CLASS_QUERY(SaturatingVector)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n+  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned bytes\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -820,1 +820,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -368,0 +368,3 @@\n+  bool has_scalar_op = VectorSupport::has_scalar_op(opr->get_con());\n+  bool is_unsigned = VectorSupport::is_unsigned_op(opr->get_con());\n+\n@@ -370,1 +373,1 @@\n-  int sopc = VectorNode::opcode(opc, elem_bt);\n+  int sopc = has_scalar_op ? VectorNode::opcode(opc, elem_bt) : opc;\n@@ -484,1 +487,1 @@\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc));\n+        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc), is_unsigned);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -670,1 +670,1 @@\n-VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift) {\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift, bool is_unsigned) {\n@@ -742,0 +742,3 @@\n+  case Op_UMinV: return new UMinVNode(n1, n2, vt);\n+  case Op_UMaxV: return new UMaxVNode(n1, n2, vt);\n+\n@@ -762,0 +765,4 @@\n+\n+  case Op_SaturatingAddV: return new SaturatingAddVNode(n1, n2, vt, is_unsigned);\n+  case Op_SaturatingSubV: return new SaturatingSubVNode(n1, n2, vt, is_unsigned);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false, bool is_unsigned = false);\n@@ -147,0 +147,16 @@\n+\/\/ Base IR node for saturating signed \/ unsigned operations.\n+\/\/ Saturating operation prevents wrapping result value in over\/underflowing\n+\/\/ scenarios, instead returns delimiting MAX\/MIN value of result type.\n+class SaturatingVectorNode : public VectorNode {\n+ private:\n+  const bool _is_unsigned;\n+\n+ public:\n+  SaturatingVectorNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : VectorNode(in1, in2, vt), _is_unsigned(is_unsigned) {\n+    init_class_id(Class_SaturatingVector);\n+  }\n+\n+  \/\/ Needed for proper cloning.\n+  virtual uint size_of() const { return sizeof(*this); }\n+  bool is_unsigned() { return _is_unsigned; }\n+};\n@@ -172,0 +188,1 @@\n+\n@@ -358,0 +375,16 @@\n+\/\/------------------------------SaturatingAddVNode-----------------------------\n+\/\/ Vector saturating addition.\n+class SaturatingAddVNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------SaturatingSubVNode-----------------------------\n+\/\/ Vector saturating subtraction.\n+class SaturatingSubVNode : public SaturatingVectorNode {\n+ public:\n+  SaturatingSubVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1,in2,vt,is_unsigned) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -564,0 +597,8 @@\n+class UMinVNode : public VectorNode {\n+ public:\n+  UMinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    assert(is_integral_type(vt->element_basic_type()), \"\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n@@ -572,0 +613,8 @@\n+class UMaxVNode : public VectorNode {\n+ public:\n+  UMaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    assert(is_integral_type(vt->element_basic_type()), \"\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -202,0 +202,26 @@\n+bool VectorSupport::has_scalar_op(jint id) {\n+  VectorOperation vop = (VectorOperation)id;\n+  switch (vop) {\n+    case VECTOR_OP_COMPRESS:\n+    case VECTOR_OP_EXPAND:\n+    case VECTOR_OP_SADD:\n+    case VECTOR_OP_SUADD:\n+    case VECTOR_OP_SSUB:\n+    case VECTOR_OP_SUSUB:\n+      return false;\n+    default:\n+      return true;\n+  }\n+}\n+\n+bool VectorSupport::is_unsigned_op(jint id) {\n+  VectorOperation vop = (VectorOperation)id;\n+  switch (vop) {\n+    case VECTOR_OP_SUADD:\n+    case VECTOR_OP_SUSUB:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -277,0 +303,20 @@\n+    case VECTOR_OP_UMIN: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+        case T_LONG:   return Op_UMinV;\n+        default: fatal(\"MIN: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_UMAX: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:\n+        case T_LONG:   return Op_UMaxV;\n+        default: fatal(\"MAX: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n@@ -536,0 +582,22 @@\n+    case VECTOR_OP_SADD:\n+    case VECTOR_OP_SUADD: {\n+      switch(bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:   return Op_SaturatingAddV;\n+        default: fatal(\"S[U]ADD: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_SSUB:\n+    case VECTOR_OP_SUSUB: {\n+      switch(bt) {\n+        case T_BYTE:   \/\/ fall-through\n+        case T_SHORT:  \/\/ fall-through\n+        case T_INT:    \/\/ fall-through\n+        case T_LONG:   return Op_SaturatingSubV;\n+        default: fatal(\"S[U}SUB: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -124,0 +124,7 @@\n+    VECTOR_OP_SADD  = 119,\n+    VECTOR_OP_SSUB  = 120,\n+    VECTOR_OP_SUADD = 121,\n+    VECTOR_OP_SUSUB = 122,\n+    VECTOR_OP_UMIN  = 123,\n+    VECTOR_OP_UMAX  = 124,\n+\n@@ -145,0 +152,2 @@\n+  static bool has_scalar_op(jint id);\n+  static bool is_unsigned_op(jint id);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -577,1 +577,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,0 +90,10 @@\n+    \/**\n+     * A constant holding polarity(sign) mask used by saturating operations.\n+     *\/\n+    public static final long POLARITY_MASK_LONG = 1L << 63;\n+\n+    \/**\n+     * A constant holding maximum unsigned value used by saturating unsigned operations.\n+     *\/\n+    public static final long UNSIGNED_MAX = 0xFFFFFFFFFFFFFFFFL;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,0 +117,7 @@\n+    public static final int VECTOR_OP_SADD  = 119;\n+    public static final int VECTOR_OP_SSUB  = 120;\n+    public static final int VECTOR_OP_SUADD = 121;\n+    public static final int VECTOR_OP_SUSUB = 122;\n+    public static final int VECTOR_OP_UMIN = 123;\n+    public static final int VECTOR_OP_UMAX = 124;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -874,0 +874,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)VectorMathUtils.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)VectorMathUtils.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMathUtils.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMathUtils.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMathUtils.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (byte)(VectorMathUtils.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -874,0 +874,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)VectorMathUtils.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)VectorMathUtils.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMathUtils.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMathUtils.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMathUtils.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (int)(VectorMathUtils.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -832,0 +832,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)VectorMathUtils.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)VectorMathUtils.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMathUtils.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMathUtils.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMathUtils.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (long)(VectorMathUtils.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -874,0 +874,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)VectorMathUtils.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)VectorMathUtils.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMathUtils.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMathUtils.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMathUtils.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> (short)(VectorMathUtils.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,456 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+\n+\/**\n+ * Following class declares utility routines used in the fallback implementation\n+ * various vector APIs.\n+ *\n+ *\/\n+public class VectorMathUtils {\n+\n+   \/**\n+    * Default Constructor definition.\n+    *\/\n+    private VectorMathUtils() {\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code long} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long maxUnsigned(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code long} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long minUnsigned(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Saturating addition of two {@code long} values,\n+     * which returns a {@code Long.MIN_VALUE} in underflowing or\n+     * {@code Long.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code long} value range else delimiting {@code Long.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long addSaturating(long a, long b) {\n+        long res = a + b;\n+        \/\/ HD 2-12 Overflow iff both arguments have the opposite sign of the result\n+        if (((a ^ res) & (b ^ res)) < 0) {\n+            return res < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code long} values,\n+     * which returns a {@code Long.MIN_VALUE} in underflowing or\n+     * {@code Long.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code long} value range else delimiting {@code Long.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long subSaturating(long a, long b) {\n+        long res = a - b;\n+        \/\/ HD 2-12 Overflow iff the arguments have different signs and\n+        \/\/ the sign of the result is different from the sign of a\n+        if (((a ^ b) & (a ^ res)) < 0) {\n+            return a < 0 ? Long.MIN_VALUE : Long.MAX_VALUE;\n+        } else {\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code long} values,\n+     * which returns maximum unsigned long value in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting maximum unsigned long value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long addSaturatingUnsigned(long a, long b) {\n+        long res = a + b;\n+        boolean overflow = Long.compareUnsigned(res, (a | b)) < 0;\n+        if (overflow) {\n+           return Long.UNSIGNED_MAX;\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned subtraction of two {@code long} values,\n+     * which returns a zero in underflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned difference between {@code a} and {@code b} iff within unsigned value range else delimiting zero value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static long subSaturatingUnsigned(long a, long b) {\n+        if (Long.compareUnsigned(b, a) < 0) {\n+           return a - b;\n+        } else {\n+           return 0;\n+        }\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code int} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int maxUnsigned(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code int} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int minUnsigned(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+\n+    \/**\n+     * Saturating addition of two {@code int} values,\n+     * which returns an {@code Integer.MIN_VALUE} in underflowing or\n+     * {@code Integer.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code int} value range else delimiting {@code Integer.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int addSaturating(int a, int b) {\n+        long res = (long)a + (long)b;\n+        if (res > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        } else if (res < Integer.MIN_VALUE) {\n+            return Integer.MIN_VALUE;\n+        } else {\n+            return (int)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code int} values,\n+     * which returns an {@code Integer.MIN_VALUE} in underflowing or\n+     * {@code Integer.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code int} value range else delimiting {@code Integer.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int subSaturating(int a, int b) {\n+        long res = (long)a - (long)b;\n+        if (res > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        } else if (res < Integer.MIN_VALUE) {\n+            return Integer.MIN_VALUE;\n+        } else {\n+            return (int)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code int} values,\n+     * which returns maximum unsigned int value in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting maximum unsigned int value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static int addSaturatingUnsigned(int a, int b) {\n+        int res = a + b;\n+        boolean overflow = Integer.compareUnsigned(res, (a | b)) < 0;\n+        if (overflow)  {\n+           return -1;\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code short} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short maxUnsigned(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code short} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short minUnsigned(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Saturating addition of two {@code short} values,\n+     * which returns a {@code Short.MIN_VALUE} in underflowing or\n+     * {@code Short.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code short} value range else delimiting {@code Short.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short addSaturating(short a, short b) {\n+        int res = a + b;\n+        if (res > Short.MAX_VALUE) {\n+            return Short.MAX_VALUE;\n+        } else if (res < Short.MIN_VALUE) {\n+            return Short.MIN_VALUE;\n+        } else {\n+            return (short)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code short} values,\n+     * which returns a {@code Short.MIN_VALUE} in underflowing or\n+     * {@code Short.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code short} value range else delimiting {@code Short.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short subSaturating(short a, short b) {\n+        int res = a - b;\n+        if (res > Short.MAX_VALUE) {\n+            return Short.MAX_VALUE;\n+        } else if (res < Short.MIN_VALUE) {\n+            return Short.MIN_VALUE;\n+        } else {\n+            return (short)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code short} values,\n+     * which returns maximum unsigned short value in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting maximum unsigned short value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short addSaturatingUnsigned(short a, short b) {\n+        short res = (short)(a + b);\n+        boolean overflow = Short.compareUnsigned(res, (short)(a | b)) < 0;\n+        if (overflow) {\n+           return (short)(-1);\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Saturating unsigned subtraction of two {@code short} values,\n+     * which returns a zero in underflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned difference between {@code a} and {@code b} iff within unsigned value range else delimiting zero value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static short subSaturatingUnsigned(short a, short b) {\n+        if (Short.compareUnsigned(b, a) < 0) {\n+            return (short)(a - b);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the greater of two {@code byte} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte maxUnsigned(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Based on the unsigned comparison returns the smaller of two {@code byte} values.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte minUnsigned(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Saturating addition of two {@code byte} values,\n+     * which returns a {@code Byte.MIN_VALUE} in underflowing or\n+     * {@code Byte.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b} iff within {@code byte} value range else delimiting {@code Byte.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte addSaturating(byte a, byte b) {\n+        int res = a + b;\n+        if (res > Byte.MAX_VALUE) {\n+            return Byte.MAX_VALUE;\n+        } else if (res < Byte.MIN_VALUE) {\n+            return Byte.MIN_VALUE;\n+        } else {\n+           return (byte)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating subtraction of two {@code byte} values,\n+     * which returns a {@code Byte.MIN_VALUE} in underflowing or\n+     * {@code Byte.MAX_VALUE} in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the difference between {@code a} and {@code b} iff within {@code byte} value range else delimiting {@code Byte.MIN_VALUE\/MAX_VALUE} value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte subSaturating(byte a, byte b) {\n+        int res = a - b;\n+        if (res > Byte.MAX_VALUE) {\n+            return Byte.MAX_VALUE;\n+        } else if (res < Byte.MIN_VALUE) {\n+            return Byte.MIN_VALUE;\n+        } else {\n+            return (byte)res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned addition of two {@code byte} values,\n+     * which returns an maximum unsigned byte value (0xFF) in overflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned sum of {@code a} and {@code b} iff within unsigned value range else delimiting maximum unsigned byte value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte addSaturatingUnsigned(byte a, byte b) {\n+        byte res = (byte)(a + b);\n+        boolean overflow = Byte.compareUnsigned(res, (byte)(a | b)) < 0;\n+        if (overflow) {\n+           return (byte)(-1);\n+        } else {\n+           return res;\n+        }\n+    }\n+\n+    \/**\n+     * Saturating unsigned subtraction of two {@code byte} values,\n+     * which returns a zero in underflowing scenario.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the unsigned difference between {@code a} and {@code b} iff within unsigned value range else delimiting zero value.\n+     * @see java.util.function.BinaryOperator\n+     * @since 24\n+     *\/\n+    public static byte subSaturatingUnsigned(byte a, byte b) {\n+        if (Byte.compareUnsigned(b, a) < 0) {\n+            return (byte)(a - b);\n+        } else {\n+            return 0;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMathUtils.java","additions":456,"deletions":0,"binary":false,"changes":456,"status":"added"},{"patch":"@@ -566,0 +566,1 @@\n+\n@@ -569,0 +570,14 @@\n+    \/** Produce {@code a [+] b}.  *\/\n+    public static final Associative SADD = assoc(\"SADD\", \"+\", VectorSupport.VECTOR_OP_SADD, VO_NOFP+VO_ASSOC);\n+    \/** Produce {@code a [u+] b}. *\/\n+    public static final Associative SUADD = assoc(\"SUADD\", \"+\", VectorSupport.VECTOR_OP_SUADD, VO_NOFP+VO_ASSOC);\n+    \/** Produce {@code a [-] b}.  *\/\n+    public static final Binary SSUB = binary(\"SSUB\", \"-\", VectorSupport.VECTOR_OP_SSUB, VO_NOFP);\n+    \/** Produce {@code a [u-] b}. *\/\n+    public static final Binary SUSUB = binary(\"SUSUB\", \"-\", VectorSupport.VECTOR_OP_SUSUB, VO_NOFP);\n+    \/** Produce {@code umin(a,b)}. *\/\n+    public static final Associative UMIN = assoc(\"UMIN\", \"umin\", VectorSupport.VECTOR_OP_UMIN, VO_NOFP+VO_ASSOC);\n+    \/** Produce {@code umax(a,b)}. *\/\n+    public static final Associative UMAX = assoc(\"UMAX\", \"umax\", VectorSupport.VECTOR_OP_UMAX, VO_NOFP+VO_ASSOC);\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -970,0 +970,12 @@\n+            case VECTOR_OP_UMAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)VectorMathUtils.maxUnsigned(a, b));\n+            case VECTOR_OP_UMIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)VectorMathUtils.minUnsigned(a, b));\n+            case VECTOR_OP_SADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMathUtils.addSaturating(a, b)));\n+            case VECTOR_OP_SSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMathUtils.subSaturating(a, b)));\n+            case VECTOR_OP_SUADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMathUtils.addSaturatingUnsigned(a, b)));\n+            case VECTOR_OP_SUSUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(VectorMathUtils.subSaturatingUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -972,0 +973,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +999,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1022,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1034,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2975,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -972,0 +973,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +999,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1022,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1034,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2975,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -972,0 +973,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +999,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1022,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1034,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2975,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -972,0 +973,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -979,0 +999,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1022,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1003,0 +1034,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2935,0 +2975,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Byte64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Byte64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -977,0 +978,19 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS = List.of(\n+            withToString(\"byte[Byte.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[Byte.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -984,0 +1004,5 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(BYTE_GENERATORS.get(0)).\n+                flatMap(fa -> BYTE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1002,0 +1027,6 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpProvider() {\n+        return BYTE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1008,0 +1039,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2940,0 +2980,246 @@\n+    static byte UMIN(byte a, byte b) {\n+        return (byte)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMINByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMINByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::UMIN);\n+    }\n+\n+    static byte UMAX(byte a, byte b) {\n+        return (byte)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void UMAXByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void UMAXByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::UMAX);\n+    }\n+\n+    static byte SADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SADDByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SADDByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SADD);\n+    }\n+\n+    static byte SSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SSUBByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SSUBByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SSUB);\n+    }\n+\n+    static byte SUADD(byte a, byte b) {\n+        return (byte)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUADDByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUADDByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SUADD);\n+    }\n+\n+    static byte SUSUB(byte a, byte b) {\n+        return (byte)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpProvider\")\n+    static void SUSUBByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ByteMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ByteMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1116,0 +1117,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1143,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1166,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1178,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1116,0 +1117,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1143,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1166,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1178,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1116,0 +1117,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1143,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1166,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1178,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1116,0 +1117,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1123,0 +1143,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1141,0 +1166,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1147,0 +1178,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1121,0 +1122,19 @@\n+    static final List<IntFunction<double[]>> DOUBLE_SATURATING_GENERATORS = List.of(\n+            withToString(\"double[Double.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE));\n+            }),\n+            withToString(\"double[Double.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MAX_VALUE - 100));\n+            }),\n+            withToString(\"double[Double.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(Double.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1128,0 +1148,5 @@\n+    static final List<List<IntFunction<double[]>>> DOUBLE_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(DOUBLE_GENERATORS.get(0)).\n+                flatMap(fa -> DOUBLE_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1146,0 +1171,6 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpProvider() {\n+        return DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1152,0 +1183,9 @@\n+    @DataProvider\n+    public Object[][] doubleSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> DOUBLE_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1127,0 +1128,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1154,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1177,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1189,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1127,0 +1128,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1154,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1177,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1189,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1127,0 +1128,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1154,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1177,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1189,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1127,0 +1128,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1134,0 +1154,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1152,0 +1177,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1158,0 +1189,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1132,0 +1133,19 @@\n+    static final List<IntFunction<float[]>> FLOAT_SATURATING_GENERATORS = List.of(\n+            withToString(\"float[Float.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE));\n+            }),\n+            withToString(\"float[Float.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MAX_VALUE - 100));\n+            }),\n+            withToString(\"float[Float.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(Float.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1139,0 +1159,5 @@\n+    static final List<List<IntFunction<float[]>>> FLOAT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(FLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> FLOAT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1157,0 +1182,6 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpProvider() {\n+        return FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1163,0 +1194,9 @@\n+    @DataProvider\n+    public Object[][] floatSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> FLOAT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3019,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3019,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3019,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2979,0 +3019,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -967,0 +968,19 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS = List.of(\n+            withToString(\"int[Integer.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[Integer.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -974,0 +994,5 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(INT_GENERATORS.get(0)).\n+                flatMap(fa -> INT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpProvider() {\n+        return INT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2984,0 +3024,246 @@\n+    static int UMIN(int a, int b) {\n+        return (int)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMINIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMINIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::UMIN);\n+    }\n+\n+    static int UMAX(int a, int b) {\n+        return (int)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void UMAXIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void UMAXIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::UMAX);\n+    }\n+\n+    static int SADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SADDIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SADDIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SADD);\n+    }\n+\n+    static int SSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SSUBIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SSUBIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SSUB);\n+    }\n+\n+    static int SUADD(int a, int b) {\n+        return (int)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUADDIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUADDIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SUADD);\n+    }\n+\n+    static int SUSUB(int a, int b) {\n+        return (int)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpProvider\")\n+    static void SUSUBIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -952,0 +953,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +979,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1002,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1014,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3041,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -952,0 +953,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +979,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1002,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1014,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3041,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -952,0 +953,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +979,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1002,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1014,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3041,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -952,0 +953,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -959,0 +979,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1002,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -983,0 +1014,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3001,0 +3041,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -957,0 +958,19 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS = List.of(\n+            withToString(\"long[Long.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[Long.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -964,0 +984,5 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(LONG_GENERATORS.get(0)).\n+                flatMap(fa -> LONG_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1007,6 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpProvider() {\n+        return LONG_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -988,0 +1019,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3006,0 +3046,246 @@\n+    static long UMIN(long a, long b) {\n+        return (long)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMINLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMINLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::UMIN);\n+    }\n+\n+    static long UMAX(long a, long b) {\n+        return (long)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void UMAXLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void UMAXLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::UMAX);\n+    }\n+\n+    static long SADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SADDLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SADDLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SADD);\n+    }\n+\n+    static long SSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SSUBLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SSUBLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SSUB);\n+    }\n+\n+    static long SUADD(long a, long b) {\n+        return (long)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUADDLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUADDLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SUADD);\n+    }\n+\n+    static long SUSUB(long a, long b) {\n+        return (long)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpProvider\")\n+    static void SUSUBLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2966,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short128VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short128VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2966,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short256VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short256VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2966,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short512VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short512VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -962,0 +963,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -969,0 +989,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1012,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -993,0 +1024,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2926,0 +2966,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Short64VectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Short64VectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -967,0 +968,19 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS = List.of(\n+            withToString(\"short[Short.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[Short.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -974,0 +994,5 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1017,6 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpProvider() {\n+        return SHORT_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -998,0 +1029,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -2931,0 +2971,246 @@\n+    static short UMIN(short a, short b) {\n+        return (short)(VectorMathUtils.minUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMINShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::UMIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMINShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::UMIN);\n+    }\n+\n+    static short UMAX(short a, short b) {\n+        return (short)(VectorMathUtils.maxUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void UMAXShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::UMAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void UMAXShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::UMAX);\n+    }\n+\n+    static short SADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SADDShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SADDShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SADD);\n+    }\n+\n+    static short SSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturating(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SSUBShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SSUBShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SSUB);\n+    }\n+\n+    static short SUADD(short a, short b) {\n+        return (short)(VectorMathUtils.addSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUADDShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUADDShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SUADD);\n+    }\n+\n+    static short SUSUB(short a, short b) {\n+        return (short)(VectorMathUtils.subSaturatingUnsigned(a, b));\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpProvider\")\n+    static void SUSUBShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, ShortMaxVectorTests::SUSUB);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpMaskProvider\")\n+    static void SUSUBShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, ShortMaxVectorTests::SUSUB);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+saturating_binary=\"SaturatingBinary-op\"\n+saturating_binary_masked=\"SaturatingBinary-Masked-op\"\n@@ -313,0 +315,6 @@\n+function gen_saturating_binary_op {\n+  echo \"Generating binary op $1 ($2)...\"\n+  gen_op_tmpl $saturating_binary \"$@\"\n+  gen_op_tmpl $saturating_binary_masked \"$@\"\n+}\n+\n@@ -462,0 +470,6 @@\n+gen_binary_op \"UMIN\" \"VectorMathUtils.minUnsigned(a, b)\" \"BITWISE\"\n+gen_binary_op \"UMAX\" \"VectorMathUtils.maxUnsigned(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SADD\" \"VectorMathUtils.addSaturating(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SSUB\" \"VectorMathUtils.subSaturating(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SUADD\" \"VectorMathUtils.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n+gen_saturating_binary_op \"SUSUB\" \"VectorMathUtils.subSaturatingUnsigned(a, b)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-Masked-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-Masked-op.template","status":"copied"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-op.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-op.template","status":"copied"},{"patch":"@@ -0,0 +1,7 @@\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-Masked-op.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\n+    static $type$ [[TEST]]($type$ a, $type$ b) {\n+        return ($type$)([[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, b, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.vector.VectorMathUtils;\n@@ -1219,0 +1220,19 @@\n+    static final List<IntFunction<$type$[]>> $TYPE$_SATURATING_GENERATORS = List.of(\n+            withToString(\"$type$[$Boxtype$.MIN_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MIN_VALUE));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE - 100));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MIN_VALUE + 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MIN_VALUE + 100));\n+            })\n+    );\n+\n@@ -1226,0 +1246,5 @@\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_SATURATING_GENERATOR_PAIRS =\n+        Stream.of($TYPE$_GENERATORS.get(0)).\n+                flatMap(fa -> $TYPE$_SATURATING_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n@@ -1244,0 +1269,6 @@\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpProvider() {\n+        return $TYPE$_SATURATING_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -1250,0 +1281,9 @@\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_SATURATING_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}