{"files":[{"patch":"@@ -929,3 +929,2 @@\n-                                                      int constant,\n-                                                      bool decrement) {\n-  increment_mdp_data_at(mdp_in, noreg, constant, decrement);\n+                                                      int constant) {\n+  increment_mdp_data_at(mdp_in, noreg, constant);\n@@ -935,3 +934,2 @@\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+                                                      Register index,\n+                                                      int constant) {\n@@ -939,2 +937,0 @@\n-  \/\/ %%% this does 64bit counters at best it is wasting space\n-  \/\/ at worst it is a rare bug when counters overflow\n@@ -942,1 +938,1 @@\n-  assert_different_registers(rscratch2, rscratch1, mdp_in, reg);\n+  assert_different_registers(rscratch2, rscratch1, mdp_in, index);\n@@ -945,1 +941,1 @@\n-  Address addr2(rscratch2, reg, Address::lsl(0));\n+  Address addr2(rscratch2, index, Address::lsl(0));\n@@ -947,1 +943,1 @@\n-  if (reg != noreg) {\n+  if (index != noreg) {\n@@ -952,31 +948,6 @@\n-  if (decrement) {\n-    \/\/ Decrement the register.  Set condition codes.\n-    \/\/ Intel does this\n-    \/\/ addptr(data, (int32_t) -DataLayout::counter_increment);\n-    \/\/ If the decrement causes the counter to overflow, stay negative\n-    \/\/ Label L;\n-    \/\/ jcc(Assembler::negative, L);\n-    \/\/ addptr(data, (int32_t) DataLayout::counter_increment);\n-    \/\/ so we do this\n-    ldr(rscratch1, addr);\n-    subs(rscratch1, rscratch1, (unsigned)DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::LO, L);       \/\/ skip store if counter underflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    \/\/ Intel does this\n-    \/\/ Increment the register.  Set carry flag.\n-    \/\/ addptr(data, DataLayout::counter_increment);\n-    \/\/ If the increment causes the counter to overflow, pull back by 1.\n-    \/\/ sbbptr(data, (int32_t)0);\n-    \/\/ so we do this\n-    ldr(rscratch1, addr);\n-    adds(rscratch1, rscratch1, DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::CS, L);       \/\/ skip store if counter overflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  }\n+  assert(DataLayout::counter_increment == 1,\n+          \"flow-free idiom only works with 1\");\n+\n+  ldr(rscratch1, addr);\n+  add(rscratch1, rscratch1, DataLayout::counter_increment);\n+  str(rscratch1, addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":13,"deletions":42,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -250,5 +250,2 @@\n-  void increment_mdp_data_at(Address data, bool decrement = false);\n-  void increment_mdp_data_at(Register mdp_in, int constant,\n-                             bool decrement = false);\n-  void increment_mdp_data_at(Register mdp_in, Register reg, int constant,\n-                             bool decrement = false);\n+  void increment_mdp_data_at(Register mdp_in, int constant);\n+  void increment_mdp_data_at(Register mdp_in, Register index, int constant);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}