{"files":[{"patch":"@@ -380,2 +380,1 @@\n-                                       full_gc_count,\n-                                       GCCause::_metadata_GC_threshold);\n+                                       full_gc_count);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,3 +200,2 @@\n-                                                                 uint full_gc_count_before,\n-                                                                 GCCause::Cause gc_cause)\n-    : VM_GC_Collect_Operation(gc_count_before, gc_cause, full_gc_count_before, true),\n+                                                                 uint full_gc_count_before)\n+    : VM_GC_Collect_Operation(gc_count_before, GCCause::_metadata_GC_threshold, full_gc_count_before, true),\n@@ -212,1 +211,6 @@\n-  GCCauseSetter gccs(heap, _gc_cause);\n+\n+  \/\/ Note: GCCauseSetter is intentionally not used here.\n+  \/\/ The specific GC cause is set directly in downstream calls that initiate\n+  \/\/ collections, allowing us to accurately reflect different situations:\n+  \/\/ - A typical metadata allocation failure triggers a collection.\n+  \/\/ - As a last resort, a collection clears soft references if prior attempts fail.\n@@ -236,1 +240,1 @@\n-  heap->collect_as_vm_thread(GCCause::_metadata_GC_threshold);\n+  heap->collect_as_vm_thread(_gc_cause);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -217,2 +217,1 @@\n-                                  uint full_gc_count_before,\n-                                  GCCause::Cause gc_cause);\n+                                  uint full_gc_count_before);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}