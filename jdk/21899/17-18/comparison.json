{"files":[{"patch":"@@ -68,0 +68,2 @@\n+    TreapNode(const K& k, uint64_t p) : _priority(p), _key(k), _left(nullptr), _right(nullptr) {}\n+\n@@ -307,0 +309,24 @@\n+  struct FindResult {\n+    FindResult(TreapNode* node, bool new_node) : node(node), new_node(new_node) {}\n+    TreapNode* const node;\n+    bool const new_node;\n+  };\n+\n+  \/\/ Finds the node for the given k in the tree or inserts a new node with the default constructed value.\n+  FindResult find(const K& k) {\n+    if (TreapNode* found = find(_root, k)) {\n+      return FindResult(found, false);\n+    }\n+    _node_count++;\n+    \/\/ Doesn't exist, make node\n+    void* node_place = _allocator.allocate(sizeof(TreapNode));\n+    uint64_t prio = prng_next();\n+    TreapNode* node = new (node_place) TreapNode(k, prio);\n+\n+    \/\/ (LEQ_k, GT_k)\n+    node_pair split_up = split(this->_root, k);\n+    \/\/ merge(merge(LEQ_k, EQ_k), GT_k)\n+    this->_root = merge(merge(split_up.left, node), split_up.right);\n+    return FindResult(node, true);\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-      _inline_printer(comp_arena(), this),\n+      _inline_printer(this),\n@@ -940,1 +940,1 @@\n-      _inline_printer(comp_arena(), this),\n+      _inline_printer(this),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-InlinePrinter::InlinePrinter(Arena* arena, Compile* compile) : C(compile), _root(new(arena) IPInlineSite(nullptr, arena, 0)) {}\n-\n@@ -37,3 +35,0 @@\n-\n-InlinePrinter::IPInlineAttempt::IPInlineAttempt(InliningResult result) : result(result) {}\n-\n@@ -44,1 +39,1 @@\n-  IPInlineAttempt* attempt = locate(state, callee)->add(result);\n+  outputStream* stream = locate(state, callee)->add(result);\n@@ -46,1 +41,1 @@\n-    attempt->msg.print(\"%s\", msg);\n+    stream->print(\"%s\", msg);\n@@ -48,1 +43,1 @@\n-  return &attempt->msg; \/\/ IPInlineAttempts are heap allocated so this address is safe\n+  return stream; \/\/ Pointer stays valid, see IPInlineSite::add()\n@@ -51,1 +46,1 @@\n-void InlinePrinter::print_on(outputStream* tty) {\n+void InlinePrinter::print_on(outputStream* tty) const {\n@@ -55,1 +50,1 @@\n-  _root->dump(tty, -1);\n+  _root.dump(tty, -1);\n@@ -66,1 +61,1 @@\n-  IPInlineSite* site = _root;\n+  IPInlineSite* site = &_root;\n@@ -68,1 +63,1 @@\n-    site = site->at_bci(growableArray->at(i)->bci(), i == 0 ? callee : nullptr);\n+    site = &site->at_bci(growableArray->at(i)->bci(), i == 0 ? callee : nullptr);\n@@ -76,4 +71,5 @@\n-InlinePrinter::IPInlineSite* InlinePrinter::IPInlineSite::at_bci(int bci, ciMethod* callee) {\n-  int index = (bci == -1) ? 0 : bci; \/\/ -1 is a special case for some intrinsics (e.g. java.lang.ref.reference.get)\n-  assert(index >= 0, \"index cannot be negative\");\n-  if (_children.length() <= index) {\n+InlinePrinter::IPInlineSite& InlinePrinter::IPInlineSite::at_bci(int bci, ciMethod* callee) {\n+  auto find_result = _children.find(bci);\n+  IPInlineSite& child = find_result.node->val();\n+\n+  if (find_result.new_node) {\n@@ -81,9 +77,6 @@\n-    auto child = new (_arena) IPInlineSite(callee, _arena, bci);\n-    _children.at_put_grow(index, child, nullptr);\n-    return child;\n-  }\n-  if (IPInlineSite* child = _children.at(index)) {\n-    if (callee != nullptr && callee != child->_method) {\n-      IPInlineAttempt* attempt = child->add(InliningResult::SUCCESS);\n-      attempt->msg.print(\"callee changed to \");\n-      CompileTask::print_inline_inner_method_info(&attempt->msg, callee);\n+    child.set_source(callee, bci);\n+  } else { \/\/ We already saw a call at this site before\n+    if (callee != nullptr && callee != child._method) {\n+      outputStream* stream = child.add(InliningResult::SUCCESS);\n+      stream->print(\"callee changed to \");\n+      CompileTask::print_inline_inner_method_info(stream, callee);\n@@ -91,1 +84,0 @@\n-    return child;\n@@ -93,2 +85,1 @@\n-  auto child = new (_arena) IPInlineSite(callee, _arena, bci);\n-  _children.at_put(index, child);\n+\n@@ -98,4 +89,3 @@\n-InlinePrinter::IPInlineAttempt* InlinePrinter::IPInlineSite::add(InliningResult result) {\n-  auto attempt = new (_arena) IPInlineAttempt(result);\n-  _attempts.push(attempt);\n-  return attempt;\n+outputStream* InlinePrinter::IPInlineSite::add(InliningResult result) {\n+  _attempts.push(IPInlineAttempt(result));\n+  return _attempts.last().make_stream();\n@@ -104,1 +94,3 @@\n-void InlinePrinter::IPInlineSite::dump(outputStream* tty, int level) {\n+void InlinePrinter::IPInlineSite::dump(outputStream* tty, int level) const {\n+  assert(_bci != -999, \"trying to dump site without source\");\n+\n@@ -108,2 +100,2 @@\n-  for (IPInlineAttempt* attempt : _attempts) {\n-    CompileTask::print_inlining_inner_message(tty, attempt->result, attempt->msg.base());\n+  for (int i = 0; i < _attempts.length(); i++) {\n+    CompileTask::print_inlining_inner_message(tty, _attempts.at(i).result(), _attempts.at(i).stream()->base());\n@@ -115,5 +107,3 @@\n-  for (IPInlineSite* child : _children) {\n-    if (child != nullptr) {\n-      child->dump(tty, level + 1);\n-    }\n-  }\n+  _children.visit_in_order([=](auto* node) {\n+    node->val().dump(tty, level + 1);\n+  });\n","filename":"src\/hotspot\/share\/opto\/printinlining.cpp","additions":30,"deletions":40,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -40,5 +40,33 @@\n-  struct IPInlineAttempt : public ArenaObj {\n-    IPInlineAttempt(InliningResult result);\n-    const InliningResult result;\n-    stringStream msg;\n-    int bci;\n+  class IPInlineAttempt {\n+  private:\n+    InliningResult _result;\n+    stringStream* _stream = nullptr;\n+\n+  public:\n+    IPInlineAttempt() {}\n+\n+    IPInlineAttempt(InliningResult result) : _result(result) {}\n+\n+    InliningResult result() const { return _result; }\n+\n+    stringStream* make_stream() {\n+      assert(_stream == nullptr, \"stream already exists\");\n+      _stream = new (mtCompiler) stringStream;\n+      return _stream;\n+    }\n+\n+    stringStream* stream() const {\n+      assert(_stream != nullptr, \"stream was not created yet!\");\n+      return _stream;\n+    }\n+\n+    void deallocate_stream() {\n+      delete _stream;\n+      _stream = nullptr;\n+    }\n+  };\n+\n+  struct Cmp {\n+    static int cmp(int a, int b) {\n+      return a - b;\n+    }\n@@ -47,1 +75,1 @@\n-  class IPInlineSite : public ArenaObj {\n+  class IPInlineSite : public CHeapObj<mtCompiler> {\n@@ -49,5 +77,4 @@\n-    Arena* const _arena;\n-    ciMethod* const _method;\n-    int const _bci;\n-    GrowableArray<IPInlineAttempt*> _attempts;\n-    GrowableArray<IPInlineSite*> _children;\n+    ciMethod* _method;\n+    int _bci;\n+    GrowableArrayCHeap<IPInlineAttempt, mtCompiler> _attempts;\n+    TreapCHeap<int, IPInlineSite, Cmp> _children;\n@@ -56,4 +83,18 @@\n-    \/\/ Method may be null iff this is the root of the tree.\n-    IPInlineSite(ciMethod* method, Arena* arena, int bci) : _arena(arena), _method(method), _bci(bci),\n-                                                            _attempts(arena, 2, 0, nullptr),\n-                                                            _children(arena, 2, 0, nullptr) {}\n+    IPInlineSite(ciMethod* method, int bci) : _method(method), _bci(bci) {}\n+\n+    IPInlineSite() : _method(nullptr), _bci(-999) {}\n+\n+    ~IPInlineSite() {\n+      \/\/ Since GrowableArrayCHeap uses copy semantics to resize itself we\n+      \/\/ cannot free the stream inside IPInlineAttempt's destructor unfortunately\n+      \/\/ and have to take care of this here instead.\n+      for (int i = 0; i < _attempts.length(); i++) {\n+        _attempts.at(i).deallocate_stream();\n+      }\n+    }\n+\n+    void set_source(ciMethod* method, int bci) {\n+      _method = method;\n+      _bci = bci;\n+    }\n+\n@@ -62,2 +103,4 @@\n-    IPInlineSite* at_bci(int bci, ciMethod* callee);\n-    InlinePrinter::IPInlineAttempt* add(InliningResult result);\n+    \/\/ Returned pointer is valid until any at_bci is called with non-null callee.\n+    InlinePrinter::IPInlineSite& at_bci(int bci, ciMethod* callee);\n+    \/\/ The returned pointer stays valid until InlinePrinter is destructed.\n+    outputStream* add(InliningResult result);\n@@ -65,1 +108,1 @@\n-    void dump(outputStream* tty, int level);\n+    void dump(outputStream* tty, int level) const;\n@@ -70,1 +113,1 @@\n-  Compile *C;\n+  Compile* C;\n@@ -78,0 +121,1 @@\n+  \/\/ Returned pointer is valid until InlinePrinter is destructed.\n@@ -80,1 +124,1 @@\n-  IPInlineSite* const _root;\n+  IPInlineSite _root{nullptr, 0};\n@@ -83,1 +127,1 @@\n-  InlinePrinter(Arena* arena, Compile* compile);\n+  InlinePrinter(Compile* compile) : C(compile) {}\n@@ -87,1 +131,1 @@\n-  \/\/ Returns an output stream which stores the message associated with this attempt. The buffer stays valid until InlinePrinter is deallocated.\n+  \/\/ Returns an output stream which stores the message associated with this attempt. The buffer stays valid until InlinePrinter is destructed.\n@@ -92,1 +136,1 @@\n-  void print_on(outputStream* tty);\n+  void print_on(outputStream* tty) const;\n","filename":"src\/hotspot\/share\/opto\/printinlining.hpp","additions":67,"deletions":23,"binary":false,"changes":90,"status":"modified"}]}