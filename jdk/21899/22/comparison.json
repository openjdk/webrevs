{"files":[{"patch":"@@ -286,15 +286,0 @@\n-void CompileTask::print_inline_indent(int inline_level, outputStream* st) {\n-  \/\/         1234567\n-  st->print(\"        \");     \/\/ print timestamp\n-  \/\/         1234\n-  st->print(\"     \");        \/\/ print compilation number\n-  \/\/         %s!bn\n-  st->print(\"      \");       \/\/ print method attributes\n-  if (TieredCompilation) {\n-    st->print(\"  \");\n-  }\n-  st->print(\"     \");        \/\/ more indent\n-  st->print(\"    \");         \/\/ initial inlining indent\n-  for (int i = 0; i < inline_level; i++)  st->print(\"  \");\n-}\n-\n@@ -414,0 +399,6 @@\n+  print_inlining_header(st, method, inline_level, bci);\n+  print_inlining_inner_message(st, result, msg);\n+  st->cr();\n+}\n+\n+void CompileTask::print_inlining_header(outputStream* st, ciMethod* method, int inline_level, int bci) {\n@@ -415,1 +406,1 @@\n-  st->print(\"        \");     \/\/ print timestamp\n+  st->print(\"        \"); \/\/ print timestamp\n@@ -417,1 +408,1 @@\n-  st->print(\"     \");        \/\/ print compilation number\n+  st->print(\"     \"); \/\/ print compilation number\n@@ -421,1 +412,1 @@\n-    const char sync_char      = method->is_synchronized()        ? 's' : ' ';\n+    const char sync_char = method->is_synchronized() ? 's' : ' ';\n@@ -423,1 +414,1 @@\n-    const char monitors_char  = method->has_monitor_bytecodes()  ? 'm' : ' ';\n+    const char monitors_char = method->has_monitor_bytecodes() ? 'm' : ' ';\n@@ -429,1 +420,1 @@\n-    st->print(\"      \");     \/\/ print method attributes\n+    st->print(\"      \"); \/\/ print method attributes\n@@ -435,2 +426,2 @@\n-  st->print(\"     \");        \/\/ more indent\n-  st->print(\"    \");         \/\/ initial inlining indent\n+  st->print(\"     \"); \/\/ more indent\n+  st->print(\"    \");  \/\/ initial inlining indent\n@@ -438,1 +429,7 @@\n-  for (int i = 0; i < inline_level; i++)  st->print(\"  \");\n+  for (int i = 0; i < inline_level; i++) {\n+    st->print(\"  \");\n+  }\n+\n+  st->print(\"@ %d  \", bci); \/\/ print bci\n+  print_inline_inner_method_info(st, method);\n+}\n@@ -440,1 +437,1 @@\n-  st->print(\"@ %d  \", bci);  \/\/ print bci\n+void CompileTask::print_inline_inner_method_info(outputStream* st, ciMethod* method) {\n@@ -442,1 +439,1 @@\n-  if (method->is_loaded())\n+  if (method->is_loaded()) {\n@@ -444,1 +441,1 @@\n-  else\n+  } else {\n@@ -446,0 +443,19 @@\n+  }\n+}\n+\n+void CompileTask::print_inline_indent(int inline_level, outputStream* st) {\n+  \/\/         1234567\n+  st->print(\"        \"); \/\/ print timestamp\n+  \/\/         1234\n+  st->print(\"     \"); \/\/ print compilation number\n+  \/\/         %s!bn\n+  st->print(\"      \"); \/\/ print method attributes\n+  if (TieredCompilation) {\n+    st->print(\"  \");\n+  }\n+  st->print(\"     \"); \/\/ more indent\n+  st->print(\"    \");  \/\/ initial inlining indent\n+  for (int i = 0; i < inline_level; i++) {\n+    st->print(\"  \");\n+  }\n+}\n@@ -447,0 +463,1 @@\n+void CompileTask::print_inlining_inner_message(outputStream* st, InliningResult result, const char* msg) {\n@@ -452,1 +469,0 @@\n-  st->cr();\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":43,"deletions":27,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -221,0 +221,3 @@\n+  \/**\n+   * @deprecated Please rely on Compile::inline_printer. Do not directly write inlining information to tty.\n+   *\/\n@@ -238,0 +241,1 @@\n+  static void print_inlining_header(outputStream* st, ciMethod* method, int inline_level, int bci);\n@@ -239,0 +243,3 @@\n+  static void print_inline_inner_method_info(outputStream* st, ciMethod* method);\n+  static void print_inlining_inner_message(outputStream* st, InliningResult result, const char* msg);\n+\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    TreapNode(const K& k, uint64_t p) : _priority(p), _key(k), _left(nullptr), _right(nullptr) {}\n+\n@@ -311,0 +313,24 @@\n+  struct FindResult {\n+    FindResult(TreapNode* node, bool new_node) : node(node), new_node(new_node) {}\n+    TreapNode* const node;\n+    bool const new_node;\n+  };\n+\n+  \/\/ Finds the node for the given k in the tree or inserts a new node with the default constructed value.\n+  FindResult find(const K& k) {\n+    if (TreapNode* found = find(_root, k)) {\n+      return FindResult(found, false);\n+    }\n+    _node_count++;\n+    \/\/ Doesn't exist, make node\n+    void* node_place = _allocator.allocate(sizeof(TreapNode));\n+    uint64_t prio = prng_next();\n+    TreapNode* node = new (node_place) TreapNode(k, prio);\n+\n+    \/\/ (LEQ_k, GT_k)\n+    node_pair split_up = split(this->_root, k);\n+    \/\/ merge(merge(LEQ_k, EQ_k), GT_k)\n+    this->_root = merge(merge(split_up.left, node), split_up.right);\n+    return FindResult(node, true);\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -117,1 +117,2 @@\n-                               int caller_bci, bool& should_delay, ciCallProfile& profile) {\n+                               JVMState* caller_jvms, bool& should_delay, ciCallProfile& profile) {\n+  int caller_bci = caller_jvms->bci();\n@@ -147,3 +148,4 @@\n-    if (C->print_inlining() && Verbose) {\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\"Inlined method with many throws (throws=%d):\", callee_method->interpreter_throwout_count());\n+    if (Verbose) {\n+      C->inline_printer()\n+          ->record(callee_method, caller_jvms, InliningResult::SUCCESS)\n+          ->print(\"Inlined method with many throws (throws=%d):\", callee_method->interpreter_throwout_count());\n@@ -172,5 +174,3 @@\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\"Inlined frequent method (freq=%lf):\", freq);\n-      CompileTask::print_inline_indent(inline_level());\n-      callee_method->print();\n-      tty->cr();\n+      C->inline_printer()\n+          ->record(callee_method, caller_jvms, InliningResult::SUCCESS)\n+          ->print(\"Inlined frequent method (freq=%lf):\", freq);\n@@ -380,1 +380,1 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, should_delay, profile)) {\n+  if (!should_inline(callee_method, caller_method, jvms, should_delay, profile)) {\n@@ -538,2 +538,3 @@\n-void InlineTree::print_inlining(ciMethod* callee_method, int caller_bci,\n-                                ciMethod* caller_method, bool success) const {\n+void InlineTree::print_inlining(ciMethod* callee_method, JVMState* jvm, bool success) const {\n+  int caller_bci = jvm->bci();\n+  ciMethod* caller_method = jvm->method();\n@@ -549,11 +550,2 @@\n-  CompileTask::print_inlining_ul(callee_method, inline_level(),\n-                                 caller_bci, inlining_result_of(success), inline_msg);\n-  if (C->print_inlining()) {\n-    C->print_inlining(callee_method, inline_level(), caller_bci, inlining_result_of(success), inline_msg);\n-    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n-    if (Verbose) {\n-      const InlineTree *top = this;\n-      while (top->caller_tree() != nullptr) { top = top->caller_tree(); }\n-      \/\/tty->print(\"  bcs: %d+%d  invoked: %d\", top->count_inline_bcs(), callee_method->code_size(), callee_method->interpreter_invocation_count());\n-    }\n-  }\n+  CompileTask::print_inlining_ul(callee_method, inline_level(), caller_bci, inlining_result_of(success), inline_msg);\n+  C->inline_printer()->record(callee_method, jvm, inlining_result_of(success), inline_msg);\n@@ -562,0 +554,1 @@\n+    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n@@ -586,1 +579,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/);\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -593,1 +586,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/);\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -605,1 +598,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, true \/* success *\/);\n+    print_inlining(callee_method, jvms, true \/* success *\/);\n@@ -617,1 +610,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/ );\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -638,2 +631,1 @@\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\" \\\\-> discounting inline depth\");\n+      C->inline_printer()->record(callee_method, caller_jvms, InliningResult::SUCCESS, \" \\\\-> discounting inline depth\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-  C->print_inlining_update(this);\n@@ -147,1 +146,0 @@\n-  kit.C->print_inlining_update(this);\n@@ -222,2 +220,0 @@\n-  kit.C->print_inlining_update(this);\n-\n@@ -357,9 +353,0 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) {\n-    CallNode* call = call_node();\n-    Compile* C = Compile::current();\n-    C->print_inlining_assert_ready();\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n-    C->print_inlining_move_to(this);\n-    C->print_inlining_update_delayed(this);\n-  }\n-\n@@ -435,3 +422,3 @@\n-    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n-      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late method handle call resolution\");\n+    if (!allow_inline) {\n+      C->inline_printer()->record(cg->method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                  \"late method handle call resolution\");\n@@ -503,9 +490,0 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) {\n-    CallNode* call = call_node();\n-    Compile* C = Compile::current();\n-    C->print_inlining_assert_ready();\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n-    C->print_inlining_move_to(this);\n-    C->print_inlining_update_delayed(this);\n-  }\n-\n@@ -535,4 +513,2 @@\n-    if (C->print_inlining() || C->print_intrinsics()) {\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization failed (receiver may be null)\");\n-    }\n+    C->inline_printer()->record(method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                \"late call devirtualization failed (receiver may be null)\");\n@@ -545,4 +521,2 @@\n-    if (C->print_inlining() || C->print_intrinsics()) {\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization failed (interface call)\");\n-    }\n+    C->inline_printer()->record(method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                \"late call devirtualization failed (interface call)\");\n@@ -561,3 +535,2 @@\n-    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n-      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization\");\n+    if (!allow_inline) {\n+      C->inline_printer()->record(cg->method(), call_node()->jvms(), InliningResult::FAILURE, \"late call devirtualization\");\n@@ -686,4 +659,0 @@\n-    C->print_inlining_assert_ready();\n-\n-    C->print_inlining_move_to(this);\n-\n@@ -695,1 +664,0 @@\n-      C->print_inlining_update_delayed(this);\n@@ -698,3 +666,0 @@\n-    if (C->print_inlining() && (is_mh_late_inline() || is_virtual_late_inline())) {\n-      C->print_inlining_update_delayed(this);\n-    }\n@@ -715,0 +680,12 @@\n+    if (is_mh_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (method handle)\");\n+    } else if (is_string_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (string method)\");\n+    } else if (is_boxing_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (boxing method)\");\n+    } else if (is_vector_reboxing_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (vector reboxing method)\");\n+    } else {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded\");\n+    }\n+\n@@ -786,0 +763,2 @@\n+  virtual bool is_boxing_late_inline() const { return true; }\n+\n@@ -814,0 +793,2 @@\n+  virtual bool is_vector_reboxing_late_inline() const { return true; }\n+\n@@ -879,1 +860,0 @@\n-  kit.C->print_inlining_update(this);\n@@ -1049,2 +1029,1 @@\n-            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                   \"signatures mismatch\");\n+            print_inlining_failure(C, callee, jvms, \"signatures mismatch\");\n@@ -1063,2 +1042,1 @@\n-          print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                 \"receiver is always null\");\n+          print_inlining_failure(C, callee, jvms, \"receiver is always null\");\n@@ -1067,2 +1045,1 @@\n-        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                               \"receiver not constant\");\n+        print_inlining_failure(C, callee, jvms, \"receiver not constant\");\n@@ -1070,2 +1047,1 @@\n-    }\n-    break;\n+  } break;\n@@ -1086,2 +1062,1 @@\n-          print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                 \"signatures mismatch\");\n+          print_inlining_failure(C, callee, jvms, \"signatures mismatch\");\n@@ -1102,2 +1077,1 @@\n-            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                   \"argument types mismatch\");\n+            print_inlining_failure(C, callee, jvms, \"argument types mismatch\");\n@@ -1116,2 +1090,1 @@\n-              print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                     \"argument types mismatch\");\n+              print_inlining_failure(C, callee, jvms, \"argument types mismatch\");\n@@ -1155,2 +1128,1 @@\n-        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                               \"member_name not constant\");\n+        print_inlining_failure(C, callee, jvms, \"member_name not constant\");\n@@ -1158,2 +1130,1 @@\n-    }\n-    break;\n+  } break;\n@@ -1161,3 +1132,2 @@\n-    case vmIntrinsics::_linkToNative:\n-    print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                           \"native call\");\n+  case vmIntrinsics::_linkToNative:\n+    print_inlining_failure(C, callee, jvms, \"native call\");\n@@ -1408,1 +1378,0 @@\n-  kit.C->print_inlining_update(this);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":36,"deletions":67,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+  virtual bool      is_boxing_late_inline() const  { return false; }\n+  virtual bool      is_vector_reboxing_late_inline() const  { return false; }\n@@ -174,8 +176,2 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) { ShouldNotReachHere(); }\n-\n-  static void print_inlining(Compile* C, ciMethod* callee, int inline_level, int bci, const char* msg) {\n-    print_inlining_impl(C, callee, inline_level, bci, InliningResult::SUCCESS, msg);\n-  }\n-\n-  static void print_inlining_failure(Compile* C, ciMethod* callee, int inline_level, int bci, const char* msg) {\n-    print_inlining_impl(C, callee, inline_level, bci, InliningResult::FAILURE, msg);\n+  static void print_inlining_failure(Compile* C, ciMethod* callee, JVMState* jvms, const char* msg) {\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -188,8 +184,0 @@\n-\n-private:\n-  static void print_inlining_impl(Compile* C, ciMethod* callee, int inline_level, int bci,\n-                                  InliningResult result, const char* msg) {\n-    if (C->print_inlining()) {\n-      C->print_inlining(callee, inline_level, bci, result, msg);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -614,18 +614,18 @@\n-Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,\n-                  Options options, DirectiveSet* directive)\n-                : Phase(Compiler),\n-                  _compile_id(ci_env->compile_id()),\n-                  _options(options),\n-                  _method(target),\n-                  _entry_bci(osr_bci),\n-                  _ilt(nullptr),\n-                  _stub_function(nullptr),\n-                  _stub_name(nullptr),\n-                  _stub_entry_point(nullptr),\n-                  _max_node_limit(MaxNodeLimit),\n-                  _post_loop_opts_phase(false),\n-                  _allow_macro_nodes(true),\n-                  _inlining_progress(false),\n-                  _inlining_incrementally(false),\n-                  _do_cleanup(false),\n-                  _has_reserved_stack_access(target->has_reserved_stack_access()),\n+Compile::Compile(ciEnv* ci_env, ciMethod* target, int osr_bci,\n+                 Options options, DirectiveSet* directive)\n+    : Phase(Compiler),\n+      _compile_id(ci_env->compile_id()),\n+      _options(options),\n+      _method(target),\n+      _entry_bci(osr_bci),\n+      _ilt(nullptr),\n+      _stub_function(nullptr),\n+      _stub_name(nullptr),\n+      _stub_entry_point(nullptr),\n+      _max_node_limit(MaxNodeLimit),\n+      _post_loop_opts_phase(false),\n+      _allow_macro_nodes(true),\n+      _inlining_progress(false),\n+      _inlining_incrementally(false),\n+      _do_cleanup(false),\n+      _has_reserved_stack_access(target->has_reserved_stack_access()),\n@@ -633,2 +633,2 @@\n-                  _igv_idx(0),\n-                  _trace_opto_output(directive->TraceOptoOutputOption),\n+      _igv_idx(0),\n+      _trace_opto_output(directive->TraceOptoOutputOption),\n@@ -636,47 +636,44 @@\n-                  _has_method_handle_invokes(false),\n-                  _clinit_barrier_on_entry(false),\n-                  _stress_seed(0),\n-                  _comp_arena(mtCompiler),\n-                  _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n-                  _env(ci_env),\n-                  _directive(directive),\n-                  _log(ci_env->log()),\n-                  _first_failure_details(nullptr),\n-                  _intrinsics        (comp_arena(), 0, 0, nullptr),\n-                  _macro_nodes       (comp_arena(), 8, 0, nullptr),\n-                  _parse_predicates  (comp_arena(), 8, 0, nullptr),\n-                  _template_assertion_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n-                  _expensive_nodes   (comp_arena(), 8, 0, nullptr),\n-                  _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n-                  _unstable_if_traps (comp_arena(), 8, 0, nullptr),\n-                  _coarsened_locks   (comp_arena(), 8, 0, nullptr),\n-                  _congraph(nullptr),\n-                  NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n-                  _unique(0),\n-                  _dead_node_count(0),\n-                  _dead_node_list(comp_arena()),\n-                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n-                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n-                  _node_arena(&_node_arena_one),\n-                  _mach_constant_base_node(nullptr),\n-                  _Compile_types(mtCompiler),\n-                  _initial_gvn(nullptr),\n-                  _igvn_worklist(nullptr),\n-                  _types(nullptr),\n-                  _node_hash(nullptr),\n-                  _late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _string_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _late_inlines_pos(0),\n-                  _number_of_mh_late_inlines(0),\n-                  _oom(false),\n-                  _print_inlining_stream(new (mtCompiler) stringStream()),\n-                  _print_inlining_list(nullptr),\n-                  _print_inlining_idx(0),\n-                  _print_inlining_output(nullptr),\n-                  _replay_inline_data(nullptr),\n-                  _java_calls(0),\n-                  _inner_loops(0),\n-                  _interpreter_frame_size(0),\n-                  _output(nullptr)\n+      _has_method_handle_invokes(false),\n+      _clinit_barrier_on_entry(false),\n+      _stress_seed(0),\n+      _comp_arena(mtCompiler),\n+      _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n+      _env(ci_env),\n+      _directive(directive),\n+      _log(ci_env->log()),\n+      _first_failure_details(nullptr),\n+      _intrinsics(comp_arena(), 0, 0, nullptr),\n+      _macro_nodes(comp_arena(), 8, 0, nullptr),\n+      _parse_predicates(comp_arena(), 8, 0, nullptr),\n+      _template_assertion_predicate_opaqs(comp_arena(), 8, 0, nullptr),\n+      _expensive_nodes(comp_arena(), 8, 0, nullptr),\n+      _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+      _unstable_if_traps(comp_arena(), 8, 0, nullptr),\n+      _coarsened_locks(comp_arena(), 8, 0, nullptr),\n+      _congraph(nullptr),\n+      NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n+          _unique(0),\n+      _dead_node_count(0),\n+      _dead_node_list(comp_arena()),\n+      _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena(&_node_arena_one),\n+      _mach_constant_base_node(nullptr),\n+      _Compile_types(mtCompiler),\n+      _initial_gvn(nullptr),\n+      _igvn_worklist(nullptr),\n+      _types(nullptr),\n+      _node_hash(nullptr),\n+      _late_inlines(comp_arena(), 2, 0, nullptr),\n+      _string_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _late_inlines_pos(0),\n+      _number_of_mh_late_inlines(0),\n+      _oom(false),\n+      _replay_inline_data(nullptr),\n+      _inline_printer(this),\n+      _java_calls(0),\n+      _inner_loops(0),\n+      _interpreter_frame_size(0),\n+      _output(nullptr)\n@@ -684,1 +681,2 @@\n-                  , _in_dump_cnt(0)\n+      ,\n+      _in_dump_cnt(0)\n@@ -747,1 +745,0 @@\n-  print_inlining_init();\n@@ -890,22 +887,22 @@\n-Compile::Compile( ciEnv* ci_env,\n-                  TypeFunc_generator generator,\n-                  address stub_function,\n-                  const char *stub_name,\n-                  int is_fancy_jump,\n-                  bool pass_tls,\n-                  bool return_pc,\n-                  DirectiveSet* directive)\n-  : Phase(Compiler),\n-    _compile_id(0),\n-    _options(Options::for_runtime_stub()),\n-    _method(nullptr),\n-    _entry_bci(InvocationEntryBci),\n-    _stub_function(stub_function),\n-    _stub_name(stub_name),\n-    _stub_entry_point(nullptr),\n-    _max_node_limit(MaxNodeLimit),\n-    _post_loop_opts_phase(false),\n-    _allow_macro_nodes(true),\n-    _inlining_progress(false),\n-    _inlining_incrementally(false),\n-    _has_reserved_stack_access(false),\n+Compile::Compile(ciEnv* ci_env,\n+                 TypeFunc_generator generator,\n+                 address stub_function,\n+                 const char* stub_name,\n+                 int is_fancy_jump,\n+                 bool pass_tls,\n+                 bool return_pc,\n+                 DirectiveSet* directive)\n+    : Phase(Compiler),\n+      _compile_id(0),\n+      _options(Options::for_runtime_stub()),\n+      _method(nullptr),\n+      _entry_bci(InvocationEntryBci),\n+      _stub_function(stub_function),\n+      _stub_name(stub_name),\n+      _stub_entry_point(nullptr),\n+      _max_node_limit(MaxNodeLimit),\n+      _post_loop_opts_phase(false),\n+      _allow_macro_nodes(true),\n+      _inlining_progress(false),\n+      _inlining_incrementally(false),\n+      _has_reserved_stack_access(false),\n@@ -913,2 +910,2 @@\n-    _igv_idx(0),\n-    _trace_opto_output(directive->TraceOptoOutputOption),\n+      _igv_idx(0),\n+      _trace_opto_output(directive->TraceOptoOutputOption),\n@@ -916,35 +913,32 @@\n-    _has_method_handle_invokes(false),\n-    _clinit_barrier_on_entry(false),\n-    _stress_seed(0),\n-    _comp_arena(mtCompiler),\n-    _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n-    _env(ci_env),\n-    _directive(directive),\n-    _log(ci_env->log()),\n-    _first_failure_details(nullptr),\n-    _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n-    _congraph(nullptr),\n-    NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n-    _unique(0),\n-    _dead_node_count(0),\n-    _dead_node_list(comp_arena()),\n-    _node_arena_one(mtCompiler),\n-    _node_arena_two(mtCompiler),\n-    _node_arena(&_node_arena_one),\n-    _mach_constant_base_node(nullptr),\n-    _Compile_types(mtCompiler),\n-    _initial_gvn(nullptr),\n-    _igvn_worklist(nullptr),\n-    _types(nullptr),\n-    _node_hash(nullptr),\n-    _number_of_mh_late_inlines(0),\n-    _oom(false),\n-    _print_inlining_stream(new (mtCompiler) stringStream()),\n-    _print_inlining_list(nullptr),\n-    _print_inlining_idx(0),\n-    _print_inlining_output(nullptr),\n-    _replay_inline_data(nullptr),\n-    _java_calls(0),\n-    _inner_loops(0),\n-    _interpreter_frame_size(0),\n-    _output(nullptr),\n+      _has_method_handle_invokes(false),\n+      _clinit_barrier_on_entry(false),\n+      _stress_seed(0),\n+      _comp_arena(mtCompiler),\n+      _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n+      _env(ci_env),\n+      _directive(directive),\n+      _log(ci_env->log()),\n+      _first_failure_details(nullptr),\n+      _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+      _congraph(nullptr),\n+      NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n+          _unique(0),\n+      _dead_node_count(0),\n+      _dead_node_list(comp_arena()),\n+      _node_arena_one(mtCompiler),\n+      _node_arena_two(mtCompiler),\n+      _node_arena(&_node_arena_one),\n+      _mach_constant_base_node(nullptr),\n+      _Compile_types(mtCompiler),\n+      _initial_gvn(nullptr),\n+      _igvn_worklist(nullptr),\n+      _types(nullptr),\n+      _node_hash(nullptr),\n+      _number_of_mh_late_inlines(0),\n+      _oom(false),\n+      _replay_inline_data(nullptr),\n+      _inline_printer(this),\n+      _java_calls(0),\n+      _inner_loops(0),\n+      _interpreter_frame_size(0),\n+      _output(nullptr),\n@@ -952,1 +946,1 @@\n-    _in_dump_cnt(0),\n+      _in_dump_cnt(0),\n@@ -954,1 +948,1 @@\n-    _allowed_reasons(0) {\n+      _allowed_reasons(0) {\n@@ -995,1 +989,0 @@\n-  delete _print_inlining_stream;\n@@ -2116,1 +2109,1 @@\n-              cg->print_inlining_late(InliningResult::FAILURE, msg);\n+              inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE, msg);\n@@ -2236,2 +2229,0 @@\n-  print_inlining_reinit();\n-\n@@ -2488,2 +2479,0 @@\n- process_print_inlining();\n-\n@@ -4439,116 +4428,0 @@\n-\/\/ The message about the current inlining is accumulated in\n-\/\/ _print_inlining_stream and transferred into the _print_inlining_list\n-\/\/ once we know whether inlining succeeds or not. For regular\n-\/\/ inlining, messages are appended to the buffer pointed by\n-\/\/ _print_inlining_idx in the _print_inlining_list. For late inlining,\n-\/\/ a new buffer is added after _print_inlining_idx in the list. This\n-\/\/ way we can update the inlining message for late inlining call site\n-\/\/ when the inlining is attempted again.\n-void Compile::print_inlining_init() {\n-  if (print_inlining() || print_intrinsics()) {\n-    \/\/ print_inlining_init is actually called several times.\n-    print_inlining_reset();\n-    _print_inlining_list = new (comp_arena())GrowableArray<PrintInliningBuffer*>(comp_arena(), 1, 1, new PrintInliningBuffer());\n-  }\n-}\n-\n-void Compile::print_inlining_reinit() {\n-  if (print_inlining() || print_intrinsics()) {\n-    print_inlining_reset();\n-  }\n-}\n-\n-void Compile::print_inlining_reset() {\n-  _print_inlining_stream->reset();\n-}\n-\n-void Compile::print_inlining_commit() {\n-  assert(print_inlining() || print_intrinsics(), \"PrintInlining off?\");\n-  \/\/ Transfer the message from _print_inlining_stream to the current\n-  \/\/ _print_inlining_list buffer and clear _print_inlining_stream.\n-  _print_inlining_list->at(_print_inlining_idx)->ss()->write(_print_inlining_stream->base(), _print_inlining_stream->size());\n-  print_inlining_reset();\n-}\n-\n-void Compile::print_inlining_push() {\n-  \/\/ Add new buffer to the _print_inlining_list at current position\n-  _print_inlining_idx++;\n-  _print_inlining_list->insert_before(_print_inlining_idx, new PrintInliningBuffer());\n-}\n-\n-Compile::PrintInliningBuffer* Compile::print_inlining_current() {\n-  return _print_inlining_list->at(_print_inlining_idx);\n-}\n-\n-void Compile::print_inlining_update(CallGenerator* cg) {\n-  if (print_inlining() || print_intrinsics()) {\n-    if (cg->is_late_inline()) {\n-      if (print_inlining_current()->cg() != cg &&\n-          (print_inlining_current()->cg() != nullptr ||\n-           print_inlining_current()->ss()->size() != 0)) {\n-        print_inlining_push();\n-      }\n-      print_inlining_commit();\n-      print_inlining_current()->set_cg(cg);\n-    } else {\n-      if (print_inlining_current()->cg() != nullptr) {\n-        print_inlining_push();\n-      }\n-      print_inlining_commit();\n-    }\n-  }\n-}\n-\n-void Compile::print_inlining_move_to(CallGenerator* cg) {\n-  \/\/ We resume inlining at a late inlining call site. Locate the\n-  \/\/ corresponding inlining buffer so that we can update it.\n-  if (print_inlining() || print_intrinsics()) {\n-    for (int i = 0; i < _print_inlining_list->length(); i++) {\n-      if (_print_inlining_list->at(i)->cg() == cg) {\n-        _print_inlining_idx = i;\n-        return;\n-      }\n-    }\n-    ShouldNotReachHere();\n-  }\n-}\n-\n-void Compile::print_inlining_update_delayed(CallGenerator* cg) {\n-  if (print_inlining() || print_intrinsics()) {\n-    assert(_print_inlining_stream->size() > 0, \"missing inlining msg\");\n-    assert(print_inlining_current()->cg() == cg, \"wrong entry\");\n-    \/\/ replace message with new message\n-    _print_inlining_list->at_put(_print_inlining_idx, new PrintInliningBuffer());\n-    print_inlining_commit();\n-    print_inlining_current()->set_cg(cg);\n-  }\n-}\n-\n-void Compile::print_inlining_assert_ready() {\n-  assert(!_print_inlining || _print_inlining_stream->size() == 0, \"losing data\");\n-}\n-\n-void Compile::process_print_inlining() {\n-  assert(_late_inlines.length() == 0, \"not drained yet\");\n-  if (print_inlining() || print_intrinsics()) {\n-    ResourceMark rm;\n-    stringStream ss;\n-    assert(_print_inlining_list != nullptr, \"process_print_inlining should be called only once.\");\n-    for (int i = 0; i < _print_inlining_list->length(); i++) {\n-      PrintInliningBuffer* pib = _print_inlining_list->at(i);\n-      ss.print(\"%s\", pib->ss()->freeze());\n-      delete pib;\n-      DEBUG_ONLY(_print_inlining_list->at_put(i, nullptr));\n-    }\n-    \/\/ Reset _print_inlining_list, it only contains destructed objects.\n-    \/\/ It is on the arena, so it will be freed when the arena is reset.\n-    _print_inlining_list = nullptr;\n-    \/\/ _print_inlining_stream won't be used anymore, either.\n-    print_inlining_reset();\n-    size_t end = ss.size();\n-    _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);\n-    strncpy(_print_inlining_output, ss.freeze(), end+1);\n-    _print_inlining_output[end] = 0;\n-  }\n-}\n-\n@@ -4556,3 +4429,1 @@\n-  if (_print_inlining_output != nullptr) {\n-    tty->print_raw(_print_inlining_output);\n-  }\n+  inline_printer()->print_on(tty);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":126,"deletions":255,"binary":false,"changes":381,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"opto\/printinlining.hpp\"\n@@ -475,23 +476,0 @@\n-  \/\/ Inlining may not happen in parse order which would make\n-  \/\/ PrintInlining output confusing. Keep track of PrintInlining\n-  \/\/ pieces in order.\n-  class PrintInliningBuffer : public CHeapObj<mtCompiler> {\n-   private:\n-    CallGenerator* _cg;\n-    stringStream   _ss;\n-    static const size_t default_stream_buffer_size = 128;\n-\n-   public:\n-    PrintInliningBuffer()\n-      : _cg(nullptr), _ss(default_stream_buffer_size) {}\n-\n-    stringStream* ss()             { return &_ss; }\n-    CallGenerator* cg()            { return _cg; }\n-    void set_cg(CallGenerator* cg) { _cg = cg; }\n-  };\n-\n-  stringStream* _print_inlining_stream;\n-  GrowableArray<PrintInliningBuffer*>* _print_inlining_list;\n-  int _print_inlining_idx;\n-  char* _print_inlining_output;\n-\n@@ -509,6 +487,0 @@\n-  void print_inlining_init();\n-  void print_inlining_reinit();\n-  void print_inlining_commit();\n-  void print_inlining_push();\n-  PrintInliningBuffer* print_inlining_current();\n-\n@@ -520,1 +492,1 @@\n- public:\n+  InlinePrinter _inline_printer;\n@@ -522,0 +494,1 @@\n+public:\n@@ -524,16 +497,1 @@\n-  stringStream* print_inlining_stream() {\n-    assert(print_inlining() || print_intrinsics(), \"PrintInlining off?\");\n-    return _print_inlining_stream;\n-  }\n-\n-  void print_inlining_update(CallGenerator* cg);\n-  void print_inlining_update_delayed(CallGenerator* cg);\n-  void print_inlining_move_to(CallGenerator* cg);\n-  void print_inlining_assert_ready();\n-  void print_inlining_reset();\n-\n-  void print_inlining(ciMethod* method, int inline_level, int bci, InliningResult result, const char* msg = nullptr) {\n-    stringStream ss;\n-    CompileTask::print_inlining_inner(&ss, method, inline_level, bci, result, msg);\n-    print_inlining_stream()->print(\"%s\", ss.freeze());\n-  }\n+  InlinePrinter* inline_printer() { return &_inline_printer; }\n@@ -1105,1 +1063,0 @@\n-  void process_print_inlining();\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":4,"deletions":47,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -53,2 +53,5 @@\n-static void print_trace_type_profile(outputStream* out, int depth, ciKlass* prof_klass, int site_count, int receiver_count) {\n-  CompileTask::print_inline_indent(depth, out);\n+static void print_trace_type_profile(outputStream* out, int depth, ciKlass* prof_klass, int site_count, int receiver_count,\n+                                     bool with_deco) {\n+  if (with_deco) {\n+    CompileTask::print_inline_indent(depth, out);\n+  }\n@@ -57,1 +60,3 @@\n-  out->cr();\n+  if (with_deco) {\n+    out->cr();\n+  }\n@@ -60,2 +65,4 @@\n-static void trace_type_profile(Compile* C, ciMethod* method, int depth, int bci, ciMethod* prof_method,\n-                               ciKlass* prof_klass, int site_count, int receiver_count) {\n+static void trace_type_profile(Compile* C, ciMethod* method, JVMState* jvms,\n+                               ciMethod* prof_method, ciKlass* prof_klass, int site_count, int receiver_count) {\n+  int depth = jvms->depth() - 1;\n+  int bci = jvms->bci();\n@@ -63,1 +70,0 @@\n-    outputStream* out = tty;\n@@ -70,0 +76,1 @@\n+      print_trace_type_profile(tty, depth, prof_klass, site_count, receiver_count, true);\n@@ -71,1 +78,2 @@\n-      out = C->print_inlining_stream();\n+      auto stream = C->inline_printer()->record(method, jvms, InliningResult::SUCCESS);\n+      print_trace_type_profile(stream, depth, prof_klass, site_count, receiver_count, false);\n@@ -73,1 +81,0 @@\n-    print_trace_type_profile(out, depth, prof_klass, site_count, receiver_count);\n@@ -79,1 +86,1 @@\n-    print_trace_type_profile(&ls, depth, prof_klass, site_count, receiver_count);\n+    print_trace_type_profile(&ls, depth, prof_klass, site_count, receiver_count, true);\n@@ -298,1 +305,1 @@\n-              trace_type_profile(C, jvms->method(), jvms->depth() - 1, jvms->bci(), next_receiver_method, profile.receiver(1), site_count, profile.receiver_count(1));\n+              trace_type_profile(C, jvms->method(), jvms, next_receiver_method, profile.receiver(1), site_count, profile.receiver_count(1));\n@@ -305,1 +312,1 @@\n-              trace_type_profile(C, jvms->method(), jvms->depth() - 1, jvms->bci(), receiver_method, k, site_count, receiver_count);\n+              trace_type_profile(C, jvms->method(), jvms, receiver_method, k, site_count, receiver_count);\n@@ -308,1 +315,3 @@\n-              if (cg != nullptr)  return cg;\n+              if (cg != nullptr) {\n+                return cg;\n+              }\n@@ -375,3 +384,1 @@\n-    if (C->print_inlining()) {\n-      print_inlining(callee, jvms->depth() - 1, jvms->bci(), InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -516,2 +523,0 @@\n-  C->print_inlining_assert_ready();\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -122,3 +122,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::SUCCESS, inline_msg);\n@@ -134,1 +132,0 @@\n-    C->print_inlining_update(this);\n@@ -150,3 +147,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -167,1 +162,0 @@\n-  C->print_inlining_update(this);\n@@ -193,3 +187,2 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::SUCCESS, inline_msg);\n+\n@@ -211,3 +204,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(kit.callee(), jvms, InliningResult::FAILURE, msg);\n@@ -223,3 +214,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining_stream()->print(\"%s\", msg);\n-    }\n+    C->inline_printer()->record(kit.callee(), jvms, InliningResult::FAILURE, msg);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -551,4 +551,0 @@\n-\n-      C->print_inlining_assert_ready();\n-      C->print_inlining_move_to(cg);\n-      C->print_inlining_update(cloned_cg);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,4 +77,3 @@\n-                            ciMethod* caller_method,\n-                            int caller_bci,\n-                            bool& should_delay,\n-                            ciCallProfile& profile);\n+                     ciMethod* caller_method,\n+                     JVMState* caller_jvms,\n+                     bool& should_delay, ciCallProfile& profile);\n@@ -90,2 +89,1 @@\n-  void        print_inlining(ciMethod* callee_method, int caller_bci,\n-                             ciMethod* caller_method, bool success) const;\n+  void print_inlining(ciMethod* callee_method, JVMState* jvm, bool success) const;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"printinlining.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+bool InlinePrinter::is_enabled() const {\n+  return C->print_intrinsics() || C->print_inlining();\n+}\n+\n+outputStream* InlinePrinter::record(ciMethod* callee, JVMState* state, InliningResult result, const char* msg) {\n+  if (!is_enabled()) {\n+    return &_nullStream;\n+  }\n+  outputStream* stream = locate(state, callee)->add(result);\n+  if (msg != nullptr) {\n+    stream->print(\"%s\", msg);\n+  }\n+  return stream; \/\/ Pointer stays valid, see IPInlineSite::add()\n+}\n+\n+void InlinePrinter::print_on(outputStream* tty) const {\n+  if (!is_enabled()) {\n+    return;\n+  }\n+  _root.dump(tty, -1);\n+}\n+\n+InlinePrinter::IPInlineSite* InlinePrinter::locate(JVMState* state, ciMethod* callee) {\n+  auto growableArray = new GrowableArrayCHeap<JVMState*, mtCompiler>(2);\n+\n+  while (state != nullptr) {\n+    growableArray->push(state);\n+    state = state->caller();\n+  }\n+\n+  IPInlineSite* site = &_root;\n+  for (int i = growableArray->length() - 1; i >= 0; i--) {\n+    site = &site->at_bci(growableArray->at(i)->bci(), i == 0 ? callee : nullptr);\n+  }\n+\n+  delete growableArray;\n+\n+  return site;\n+}\n+\n+InlinePrinter::IPInlineSite& InlinePrinter::IPInlineSite::at_bci(int bci, ciMethod* callee) {\n+  auto find_result = _children.find(bci);\n+  IPInlineSite& child = find_result.node->val();\n+\n+  if (find_result.new_node) {\n+    assert(callee != nullptr, \"an inline call is missing in the chain up to the root\");\n+    child.set_source(callee, bci);\n+  } else { \/\/ We already saw a call at this site before\n+    if (callee != nullptr && callee != child._method) {\n+      outputStream* stream = child.add(InliningResult::SUCCESS);\n+      stream->print(\"callee changed to \");\n+      CompileTask::print_inline_inner_method_info(stream, callee);\n+    }\n+  }\n+\n+  return child;\n+}\n+\n+outputStream* InlinePrinter::IPInlineSite::add(InliningResult result) {\n+  _attempts.push(IPInlineAttempt(result));\n+  return _attempts.last().make_stream();\n+}\n+\n+void InlinePrinter::IPInlineSite::dump(outputStream* tty, int level) const {\n+  assert(_bci != -999, \"trying to dump site without source\");\n+\n+  if (_attempts.is_nonempty()) {\n+    CompileTask::print_inlining_header(tty, _method, level, _bci);\n+  }\n+  for (int i = 0; i < _attempts.length(); i++) {\n+    CompileTask::print_inlining_inner_message(tty, _attempts.at(i).result(), _attempts.at(i).stream()->base());\n+  }\n+  if (_attempts.is_nonempty()) {\n+    tty->cr();\n+  }\n+\n+  _children.visit_in_order([=](auto* node) {\n+    node->val().dump(tty, level + 1);\n+  });\n+}\n","filename":"src\/hotspot\/share\/opto\/printinlining.cpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef PRINTINLINING_HPP\n+#define PRINTINLINING_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"nmt\/nmtTreap.hpp\"\n+\n+class JVMState;\n+class ciMethod;\n+class Compile;\n+enum class InliningResult;\n+\n+\/\/ If not enabled, all method calls are no-ops.\n+class InlinePrinter {\n+private:\n+  class IPInlineAttempt {\n+  private:\n+    InliningResult _result;\n+    stringStream* _stream = nullptr;\n+\n+  public:\n+    IPInlineAttempt() {}\n+\n+    IPInlineAttempt(InliningResult result) : _result(result) {}\n+\n+    InliningResult result() const { return _result; }\n+\n+    stringStream* make_stream() {\n+      assert(_stream == nullptr, \"stream already exists\");\n+      _stream = new (mtCompiler) stringStream;\n+      return _stream;\n+    }\n+\n+    stringStream* stream() const {\n+      assert(_stream != nullptr, \"stream was not created yet!\");\n+      return _stream;\n+    }\n+\n+    void deallocate_stream() {\n+      delete _stream;\n+      _stream = nullptr;\n+    }\n+  };\n+\n+  struct Cmp {\n+    static int cmp(int a, int b) {\n+      return a - b;\n+    }\n+  };\n+\n+  class IPInlineSite : public CHeapObj<mtCompiler> {\n+  private:\n+    ciMethod* _method;\n+    int _bci;\n+    GrowableArrayCHeap<IPInlineAttempt, mtCompiler> _attempts;\n+    TreapCHeap<int, IPInlineSite, Cmp> _children;\n+\n+  public:\n+    IPInlineSite(ciMethod* method, int bci) : _method(method), _bci(bci) {}\n+\n+    IPInlineSite() : _method(nullptr), _bci(-999) {}\n+\n+    ~IPInlineSite() {\n+      \/\/ Since GrowableArrayCHeap uses copy semantics to resize itself we\n+      \/\/ cannot free the stream inside IPInlineAttempt's destructor unfortunately\n+      \/\/ and have to take care of this here instead.\n+      for (int i = 0; i < _attempts.length(); i++) {\n+        _attempts.at(i).deallocate_stream();\n+      }\n+    }\n+\n+    void set_source(ciMethod* method, int bci) {\n+      _method = method;\n+      _bci = bci;\n+    }\n+\n+    \/\/ Finds the node for an inline attempt that occurred inside this inline.\n+    \/\/ If this is a new site, provide the callee otherwise null.\n+    \/\/ Returned pointer is valid until any at_bci is called with non-null callee.\n+    InlinePrinter::IPInlineSite& at_bci(int bci, ciMethod* callee);\n+    \/\/ The returned pointer stays valid until InlinePrinter is destructed.\n+    outputStream* add(InliningResult result);\n+\n+    void dump(outputStream* tty, int level) const;\n+  };\n+\n+  bool is_enabled() const;\n+\n+  Compile* C;\n+\n+  \/\/ In case print inline is disabled, this null stream is returned from ::record()\n+  nullStream _nullStream;\n+\n+  \/\/ Locates the IPInlineSite node that corresponds to this JVM state.\n+  \/\/ state may be null. In this case, the root node is returned.\n+  \/\/ If this is a new site, provide the callee otherwise null.\n+  \/\/ Returned pointer is valid until InlinePrinter is destructed.\n+  IPInlineSite* locate(JVMState* state, ciMethod* callee);\n+\n+  IPInlineSite _root{nullptr, 0};\n+\n+public:\n+  InlinePrinter(Compile* compile) : C(compile) {}\n+\n+  \/\/ Saves the result of an inline attempt of method at state.\n+  \/\/ An optional string message with more details that is copied to the stream for this attempt. Pointer is not captured.\n+  \/\/ Returns an output stream which stores the message associated with this attempt. The buffer stays valid until InlinePrinter is destructed.\n+  \/\/ You can print arbitrary information to this stream but do not add line breaks, as this will break formatting.\n+  outputStream* record(ciMethod* callee, JVMState* state, InliningResult result, const char* msg = nullptr);\n+\n+  \/\/ Prints all collected inlining information to the given output stream.\n+  void print_on(outputStream* tty) const;\n+};\n+\n+#endif \/\/ PRINTINLINING_HPP\n","filename":"src\/hotspot\/share\/opto\/printinlining.hpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -89,1 +89,1 @@\n-            return reason.equals(\"inline (hot)\");\n+            return reason.startsWith(\"inline (hot)\");\n@@ -93,1 +93,1 @@\n-            return reason.equals(\"force inline by ciReplay\");\n+            return reason.startsWith(\"force inline by ciReplay\");\n@@ -97,1 +97,1 @@\n-            return reason.equals(\"failed to inline: disallowed by ciReplay\");\n+            return reason.startsWith(\"failed to inline: disallowed by ciReplay\");\n@@ -101,1 +101,1 @@\n-            return reason.equals(\"failed to inline: unloaded signature classes\");\n+            return reason.startsWith(\"failed to inline: unloaded signature classes\");\n@@ -105,1 +105,1 @@\n-            return reason.equals(\"force (incremental) inline by ciReplay\");\n+            return reason.startsWith(\"force (incremental) inline by ciReplay\");\n@@ -109,1 +109,1 @@\n-            return reason.equals(\"force inline by annotation\");\n+            return reason.startsWith(\"force inline by annotation\");\n@@ -113,1 +113,1 @@\n-            return reason.equals(\"failed to inline: inlining too deep\");\n+            return reason.startsWith(\"failed to inline: inlining too deep\");\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/InliningBase.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @bug 8319850\n+ * @summary PrintInlining should print which methods are late inlines\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ *\n+ * @run driver compiler.inlining.LateInlinePrinting\n+ *\/\n+\n+package compiler.inlining;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LateInlinePrinting {\n+    public static class TestLateInlining {\n+          public static void main(String[] args) {\n+              for (int i = 0; i < 20_000; i++) {\n+                  test1();\n+                  test2();\n+              }\n+          }\n+\n+          private static void test1() {\n+              test3();\n+              testFailInline();\n+              testFailInline();\n+              test2();\n+          }\n+\n+          private static void test2() {\n+              inlined1();\n+              inlined2();\n+          }\n+\n+          private static void test3() {}\n+\n+          private static void testFailInline() {}\n+\n+          private static void inlined1() {}\n+\n+          private static void inlined2() {}\n+      }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:-TieredCompilation\", \"-XX:-UseOnStackReplacement\", \"-XX:-BackgroundCompilation\",\n+            \"-XX:+PrintCompilation\",\n+            \"-XX:CompileCommand=compileonly,compiler.inlining.LateInlinePrinting$TestLateInlining::test1\",\n+            \"-XX:CompileCommand=compileonly,compiler.inlining.LateInlinePrinting$TestLateInlining::test2\",\n+            \"-XX:CompileCommand=quiet\", \"-XX:+PrintInlining\", \"-XX:+AlwaysIncrementalInline\",\n+            \"-XX:CompileCommand=dontinline,compiler.inlining.LateInlinePrinting$TestLateInlining::testFailInline\",\n+            TestLateInlining.class.getName()\n+        );\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+\n+        analyzer.shouldContain(\"\"\"\n+compiler.inlining.LateInlinePrinting$TestLateInlining::test2 (7 bytes)\n+                            @ 0   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined1 (1 bytes)   inline (hot)   late inline succeeded\n+                            @ 3   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined2 (1 bytes)   inline (hot)   late inline succeeded\n+                            \"\"\");\n+        analyzer.shouldContain(\"\"\"\n+compiler.inlining.LateInlinePrinting$TestLateInlining::test1 (13 bytes)\n+                            @ 0   compiler.inlining.LateInlinePrinting$TestLateInlining::test3 (1 bytes)   inline (hot)   late inline succeeded\n+                            @ 3   compiler.inlining.LateInlinePrinting$TestLateInlining::testFailInline (1 bytes)   failed to inline: disallowed by CompileCommand\n+                            @ 6   compiler.inlining.LateInlinePrinting$TestLateInlining::testFailInline (1 bytes)   failed to inline: disallowed by CompileCommand\n+                            @ 9   compiler.inlining.LateInlinePrinting$TestLateInlining::test2 (7 bytes)   inline (hot)   late inline succeeded\n+                              @ 0   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined1 (1 bytes)   inline (hot)   late inline succeeded\n+                              @ 3   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined2 (1 bytes)   inline (hot)   late inline succeeded\n+                              \"\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/LateInlinePrinting.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -48,1 +48,1 @@\n-            \"@ (\\\\d+)\\\\s+java\\\\.lang\\\\.invoke\\\\.LambdaForm\\\\$DMH\\\\\/0x[0-9a-f]+::invokeStatic \\\\(\\\\d+ bytes\\\\)\\\\s+force inline by annotation\",\n+            \"@ (\\\\d+)\\\\s+java\\\\.lang\\\\.invoke\\\\.MethodHandle::invokeBasic\\\\(\\\\)V \\\\(\\\\d+ bytes\\\\)\\\\s+failed to inline: receiver not constant\\\\s+callee changed to\\\\s+java\\\\.lang\\\\.invoke\\\\.LambdaForm\\\\$DMH\\\\\/0x[0-9a-f]+::invokeStatic \\\\(\\\\d+ bytes\\\\)\\\\s+force inline by annotation\\\\s+late inline succeeded \\\\(method handle\\\\)\",\n@@ -53,1 +53,1 @@\n-            \"@ (\\\\d+)\\\\s+compiler\\\\.inlining\\\\.TestDuplicatedLateInliningOutput\\\\$VirtualCallLauncher\\\\$B::lateInlined2 \\\\(\\\\d+ bytes\\\\)\\\\s+inline \\\\(hot\\\\)\",\n+            \"@ (\\\\d+)\\\\s+compiler\\\\.inlining\\\\.TestDuplicatedLateInliningOutput\\\\$VirtualCallLauncher\\\\$A::lateInlined2 \\\\(\\\\d+ bytes\\\\)\\\\s+failed to inline: virtual call\\\\s+callee changed to\\\\s+\\\\s+compiler\\\\.inlining\\\\.TestDuplicatedLateInliningOutput\\\\$VirtualCallLauncher\\\\$B::lateInlined2 \\\\(\\\\d+ bytes\\\\)\\\\s+inline \\\\(hot\\\\)\\\\s+late inline succeeded\",\n@@ -78,1 +78,1 @@\n-                .orElseThrow(() -> new Exception(\"No inlining found\"));\n+                .orElseThrow(() -> new Exception(\"No inlining found\" + pattern1));\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestDuplicatedLateInliningOutput.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}