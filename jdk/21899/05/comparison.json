{"files":[{"patch":"@@ -286,15 +286,0 @@\n-void CompileTask::print_inline_indent(int inline_level, outputStream* st) {\n-  \/\/         1234567\n-  st->print(\"        \");     \/\/ print timestamp\n-  \/\/         1234\n-  st->print(\"     \");        \/\/ print compilation number\n-  \/\/         %s!bn\n-  st->print(\"      \");       \/\/ print method attributes\n-  if (TieredCompilation) {\n-    st->print(\"  \");\n-  }\n-  st->print(\"     \");        \/\/ more indent\n-  st->print(\"    \");         \/\/ initial inlining indent\n-  for (int i = 0; i < inline_level; i++)  st->print(\"  \");\n-}\n-\n@@ -414,0 +399,6 @@\n+  print_inlining_header(st, method, inline_level, bci);\n+  print_inlining_inner_message(st, result, msg);\n+  st->cr();\n+}\n+\n+void CompileTask::print_inlining_header(outputStream* st, ciMethod* method, int inline_level, int bci) {\n@@ -415,1 +406,1 @@\n-  st->print(\"        \");     \/\/ print timestamp\n+  st->print(\"        \"); \/\/ print timestamp\n@@ -417,1 +408,1 @@\n-  st->print(\"     \");        \/\/ print compilation number\n+  st->print(\"     \"); \/\/ print compilation number\n@@ -421,1 +412,1 @@\n-    const char sync_char      = method->is_synchronized()        ? 's' : ' ';\n+    const char sync_char = method->is_synchronized() ? 's' : ' ';\n@@ -423,1 +414,1 @@\n-    const char monitors_char  = method->has_monitor_bytecodes()  ? 'm' : ' ';\n+    const char monitors_char = method->has_monitor_bytecodes() ? 'm' : ' ';\n@@ -429,1 +420,1 @@\n-    st->print(\"      \");     \/\/ print method attributes\n+    st->print(\"      \"); \/\/ print method attributes\n@@ -435,2 +426,2 @@\n-  st->print(\"     \");        \/\/ more indent\n-  st->print(\"    \");         \/\/ initial inlining indent\n+  st->print(\"     \"); \/\/ more indent\n+  st->print(\"    \");  \/\/ initial inlining indent\n@@ -438,1 +429,3 @@\n-  for (int i = 0; i < inline_level; i++)  st->print(\"  \");\n+  for (int i = 0; i < inline_level; i++) {\n+    st->print(\"  \");\n+  }\n@@ -440,1 +433,1 @@\n-  st->print(\"@ %d  \", bci);  \/\/ print bci\n+  st->print(\"@ %d  \", bci); \/\/ print bci\n@@ -442,1 +435,1 @@\n-  if (method->is_loaded())\n+  if (method->is_loaded()) {\n@@ -444,1 +437,1 @@\n-  else\n+  } else {\n@@ -446,0 +439,2 @@\n+  }\n+}\n@@ -447,0 +442,18 @@\n+void CompileTask::print_inline_indent(int inline_level, outputStream* st) {\n+  \/\/         1234567\n+  st->print(\"        \"); \/\/ print timestamp\n+  \/\/         1234\n+  st->print(\"     \"); \/\/ print compilation number\n+  \/\/         %s!bn\n+  st->print(\"      \"); \/\/ print method attributes\n+  if (TieredCompilation) {\n+    st->print(\"  \");\n+  }\n+  st->print(\"     \"); \/\/ more indent\n+  st->print(\"    \");  \/\/ initial inlining indent\n+  for (int i = 0; i < inline_level; i++) {\n+    st->print(\"  \");\n+  }\n+}\n+\n+void CompileTask::print_inlining_inner_message(outputStream* st, InliningResult result, const char* msg) {\n@@ -452,1 +465,0 @@\n-  st->cr();\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -221,0 +221,3 @@\n+  \/**\n+   * @deprecated Please rely on Compile::inline_printer. Do not directly write inlining information to tty.\n+   *\/\n@@ -238,0 +241,1 @@\n+  static void print_inlining_header(outputStream* st, ciMethod* method, int inline_level, int bci);\n@@ -239,0 +243,2 @@\n+  static void print_inlining_inner_message(outputStream* st, InliningResult result, const char* msg);\n+\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,1 +117,2 @@\n-                               int caller_bci, bool& should_delay, ciCallProfile& profile) {\n+                               JVMState* caller_jvms, bool& should_delay, ciCallProfile& profile) {\n+  int caller_bci = caller_jvms->bci();\n@@ -147,3 +148,4 @@\n-    if (C->print_inlining() && Verbose) {\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\"Inlined method with many throws (throws=%d):\", callee_method->interpreter_throwout_count());\n+    if (Verbose) {\n+      C->inline_printer()\n+          ->record(callee_method, caller_jvms, InliningResult::SUCCESS)\n+          ->print(\"Inlined method with many throws (throws=%d):\", callee_method->interpreter_throwout_count());\n@@ -172,5 +174,3 @@\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\"Inlined frequent method (freq=%lf):\", freq);\n-      CompileTask::print_inline_indent(inline_level());\n-      callee_method->print();\n-      tty->cr();\n+      C->inline_printer()\n+          ->record(callee_method, caller_jvms, InliningResult::SUCCESS)\n+          ->print(\"Inlined frequent method (freq=%lf):\", freq);\n@@ -380,1 +380,1 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, should_delay, profile)) {\n+  if (!should_inline(callee_method, caller_method, jvms, should_delay, profile)) {\n@@ -538,2 +538,3 @@\n-void InlineTree::print_inlining(ciMethod* callee_method, int caller_bci,\n-                                ciMethod* caller_method, bool success) const {\n+void InlineTree::print_inlining(ciMethod* callee_method, JVMState* jvm, bool success) const {\n+  int caller_bci = jvm->bci();\n+  ciMethod* caller_method = jvm->method();\n@@ -549,11 +550,2 @@\n-  CompileTask::print_inlining_ul(callee_method, inline_level(),\n-                                 caller_bci, inlining_result_of(success), inline_msg);\n-  if (C->print_inlining()) {\n-    C->print_inlining(callee_method, inline_level(), caller_bci, inlining_result_of(success), inline_msg);\n-    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n-    if (Verbose) {\n-      const InlineTree *top = this;\n-      while (top->caller_tree() != nullptr) { top = top->caller_tree(); }\n-      \/\/tty->print(\"  bcs: %d+%d  invoked: %d\", top->count_inline_bcs(), callee_method->code_size(), callee_method->interpreter_invocation_count());\n-    }\n-  }\n+  CompileTask::print_inlining_ul(callee_method, inline_level(), caller_bci, inlining_result_of(success), inline_msg);\n+  C->inline_printer()->record(callee_method, jvm, inlining_result_of(success), inline_msg);\n@@ -562,0 +554,1 @@\n+    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n@@ -586,1 +579,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/);\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -593,1 +586,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/);\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -605,1 +598,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, true \/* success *\/);\n+    print_inlining(callee_method, jvms, true \/* success *\/);\n@@ -617,1 +610,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/ );\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -638,2 +631,1 @@\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\" \\\\-> discounting inline depth\");\n+      C->inline_printer()->record(callee_method, caller_jvms, InliningResult::SUCCESS, \" \\\\-> discounting inline depth\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-  C->print_inlining_update(this);\n@@ -147,1 +146,0 @@\n-  kit.C->print_inlining_update(this);\n@@ -222,2 +220,0 @@\n-  kit.C->print_inlining_update(this);\n-\n@@ -357,9 +353,0 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) {\n-    CallNode* call = call_node();\n-    Compile* C = Compile::current();\n-    C->print_inlining_assert_ready();\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n-    C->print_inlining_move_to(this);\n-    C->print_inlining_update_delayed(this);\n-  }\n-\n@@ -435,3 +422,3 @@\n-    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n-      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late method handle call resolution\");\n+    if (!allow_inline) {\n+      C->inline_printer()->record(cg->method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                  \"late method handle call resolution\");\n@@ -503,9 +490,0 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) {\n-    CallNode* call = call_node();\n-    Compile* C = Compile::current();\n-    C->print_inlining_assert_ready();\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n-    C->print_inlining_move_to(this);\n-    C->print_inlining_update_delayed(this);\n-  }\n-\n@@ -535,4 +513,2 @@\n-    if (C->print_inlining() || C->print_intrinsics()) {\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization failed (receiver may be null)\");\n-    }\n+    C->inline_printer()->record(method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                \"late call devirtualization failed (receiver may be null)\");\n@@ -545,4 +521,2 @@\n-    if (C->print_inlining() || C->print_intrinsics()) {\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization failed (interface call)\");\n-    }\n+    C->inline_printer()->record(method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                \"late call devirtualization failed (interface call)\");\n@@ -561,3 +535,2 @@\n-    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n-      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization\");\n+    if (!allow_inline) {\n+      C->inline_printer()->record(cg->method(), call_node()->jvms(), InliningResult::FAILURE, \"late call devirtualization\");\n@@ -686,4 +659,0 @@\n-    C->print_inlining_assert_ready();\n-\n-    C->print_inlining_move_to(this);\n-\n@@ -695,1 +664,0 @@\n-      C->print_inlining_update_delayed(this);\n@@ -698,3 +666,0 @@\n-    if (C->print_inlining() && (is_mh_late_inline() || is_virtual_late_inline())) {\n-      C->print_inlining_update_delayed(this);\n-    }\n@@ -715,0 +680,12 @@\n+    if (is_mh_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (method handle)\");\n+    } else if (is_string_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (string method)\");\n+    } else if (is_boxing_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (boxing method)\");\n+    } else if (is_vector_reboxing_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (vector reboxing method)\");\n+    } else {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded\");\n+    }\n+\n@@ -786,0 +763,2 @@\n+  virtual bool is_boxing_late_inline() const { return true; }\n+\n@@ -814,0 +793,2 @@\n+  virtual bool is_vector_reboxing_late_inline() const { return true; }\n+\n@@ -879,1 +860,0 @@\n-  kit.C->print_inlining_update(this);\n@@ -1049,2 +1029,1 @@\n-            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                   \"signatures mismatch\");\n+            print_inlining_failure(C, callee, jvms, \"signatures mismatch\");\n@@ -1063,2 +1042,1 @@\n-          print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                 \"receiver is always null\");\n+          print_inlining_failure(C, callee, jvms, \"receiver is always null\");\n@@ -1067,2 +1045,1 @@\n-        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                               \"receiver not constant\");\n+        print_inlining_failure(C, callee, jvms, \"receiver not constant\");\n@@ -1070,2 +1047,1 @@\n-    }\n-    break;\n+  } break;\n@@ -1086,2 +1062,1 @@\n-          print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                 \"signatures mismatch\");\n+          print_inlining_failure(C, callee, jvms, \"signatures mismatch\");\n@@ -1102,2 +1077,1 @@\n-            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                   \"argument types mismatch\");\n+            print_inlining_failure(C, callee, jvms, \"argument types mismatch\");\n@@ -1116,2 +1090,1 @@\n-              print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                     \"argument types mismatch\");\n+              print_inlining_failure(C, callee, jvms, \"argument types mismatch\");\n@@ -1155,2 +1128,1 @@\n-        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                               \"member_name not constant\");\n+        print_inlining_failure(C, callee, jvms, \"member_name not constant\");\n@@ -1158,2 +1130,1 @@\n-    }\n-    break;\n+  } break;\n@@ -1161,3 +1132,2 @@\n-    case vmIntrinsics::_linkToNative:\n-    print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                           \"native call\");\n+  case vmIntrinsics::_linkToNative:\n+    print_inlining_failure(C, callee, jvms, \"native call\");\n@@ -1408,1 +1378,0 @@\n-  kit.C->print_inlining_update(this);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":36,"deletions":67,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+  virtual bool      is_boxing_late_inline() const  { return false; }\n+  virtual bool      is_vector_reboxing_late_inline() const  { return false; }\n@@ -174,8 +176,2 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) { ShouldNotReachHere(); }\n-\n-  static void print_inlining(Compile* C, ciMethod* callee, int inline_level, int bci, const char* msg) {\n-    print_inlining_impl(C, callee, inline_level, bci, InliningResult::SUCCESS, msg);\n-  }\n-\n-  static void print_inlining_failure(Compile* C, ciMethod* callee, int inline_level, int bci, const char* msg) {\n-    print_inlining_impl(C, callee, inline_level, bci, InliningResult::FAILURE, msg);\n+  static void print_inlining_failure(Compile* C, ciMethod* callee, JVMState* jvms, const char* msg) {\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -188,8 +184,0 @@\n-\n-private:\n-  static void print_inlining_impl(Compile* C, ciMethod* callee, int inline_level, int bci,\n-                                  InliningResult result, const char* msg) {\n-    if (C->print_inlining()) {\n-      C->print_inlining(callee, inline_level, bci, result, msg);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -614,18 +614,18 @@\n-Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,\n-                  Options options, DirectiveSet* directive)\n-                : Phase(Compiler),\n-                  _compile_id(ci_env->compile_id()),\n-                  _options(options),\n-                  _method(target),\n-                  _entry_bci(osr_bci),\n-                  _ilt(nullptr),\n-                  _stub_function(nullptr),\n-                  _stub_name(nullptr),\n-                  _stub_entry_point(nullptr),\n-                  _max_node_limit(MaxNodeLimit),\n-                  _post_loop_opts_phase(false),\n-                  _allow_macro_nodes(true),\n-                  _inlining_progress(false),\n-                  _inlining_incrementally(false),\n-                  _do_cleanup(false),\n-                  _has_reserved_stack_access(target->has_reserved_stack_access()),\n+Compile::Compile(ciEnv* ci_env, ciMethod* target, int osr_bci,\n+                 Options options, DirectiveSet* directive)\n+    : Phase(Compiler),\n+      _compile_id(ci_env->compile_id()),\n+      _options(options),\n+      _method(target),\n+      _entry_bci(osr_bci),\n+      _ilt(nullptr),\n+      _stub_function(nullptr),\n+      _stub_name(nullptr),\n+      _stub_entry_point(nullptr),\n+      _max_node_limit(MaxNodeLimit),\n+      _post_loop_opts_phase(false),\n+      _allow_macro_nodes(true),\n+      _inlining_progress(false),\n+      _inlining_incrementally(false),\n+      _do_cleanup(false),\n+      _has_reserved_stack_access(target->has_reserved_stack_access()),\n@@ -633,2 +633,2 @@\n-                  _igv_idx(0),\n-                  _trace_opto_output(directive->TraceOptoOutputOption),\n+      _igv_idx(0),\n+      _trace_opto_output(directive->TraceOptoOutputOption),\n@@ -636,47 +636,44 @@\n-                  _has_method_handle_invokes(false),\n-                  _clinit_barrier_on_entry(false),\n-                  _stress_seed(0),\n-                  _comp_arena(mtCompiler),\n-                  _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n-                  _env(ci_env),\n-                  _directive(directive),\n-                  _log(ci_env->log()),\n-                  _first_failure_details(nullptr),\n-                  _intrinsics        (comp_arena(), 0, 0, nullptr),\n-                  _macro_nodes       (comp_arena(), 8, 0, nullptr),\n-                  _parse_predicates  (comp_arena(), 8, 0, nullptr),\n-                  _template_assertion_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n-                  _expensive_nodes   (comp_arena(), 8, 0, nullptr),\n-                  _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n-                  _unstable_if_traps (comp_arena(), 8, 0, nullptr),\n-                  _coarsened_locks   (comp_arena(), 8, 0, nullptr),\n-                  _congraph(nullptr),\n-                  NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n-                  _unique(0),\n-                  _dead_node_count(0),\n-                  _dead_node_list(comp_arena()),\n-                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n-                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n-                  _node_arena(&_node_arena_one),\n-                  _mach_constant_base_node(nullptr),\n-                  _Compile_types(mtCompiler),\n-                  _initial_gvn(nullptr),\n-                  _igvn_worklist(nullptr),\n-                  _types(nullptr),\n-                  _node_hash(nullptr),\n-                  _late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _string_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _late_inlines_pos(0),\n-                  _number_of_mh_late_inlines(0),\n-                  _oom(false),\n-                  _print_inlining_stream(new (mtCompiler) stringStream()),\n-                  _print_inlining_list(nullptr),\n-                  _print_inlining_idx(0),\n-                  _print_inlining_output(nullptr),\n-                  _replay_inline_data(nullptr),\n-                  _java_calls(0),\n-                  _inner_loops(0),\n-                  _interpreter_frame_size(0),\n-                  _output(nullptr)\n+      _has_method_handle_invokes(false),\n+      _clinit_barrier_on_entry(false),\n+      _stress_seed(0),\n+      _comp_arena(mtCompiler),\n+      _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n+      _env(ci_env),\n+      _directive(directive),\n+      _log(ci_env->log()),\n+      _first_failure_details(nullptr),\n+      _intrinsics(comp_arena(), 0, 0, nullptr),\n+      _macro_nodes(comp_arena(), 8, 0, nullptr),\n+      _parse_predicates(comp_arena(), 8, 0, nullptr),\n+      _template_assertion_predicate_opaqs(comp_arena(), 8, 0, nullptr),\n+      _expensive_nodes(comp_arena(), 8, 0, nullptr),\n+      _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+      _unstable_if_traps(comp_arena(), 8, 0, nullptr),\n+      _coarsened_locks(comp_arena(), 8, 0, nullptr),\n+      _congraph(nullptr),\n+      NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n+          _unique(0),\n+      _dead_node_count(0),\n+      _dead_node_list(comp_arena()),\n+      _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena(&_node_arena_one),\n+      _mach_constant_base_node(nullptr),\n+      _Compile_types(mtCompiler),\n+      _initial_gvn(nullptr),\n+      _igvn_worklist(nullptr),\n+      _types(nullptr),\n+      _node_hash(nullptr),\n+      _late_inlines(comp_arena(), 2, 0, nullptr),\n+      _string_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _late_inlines_pos(0),\n+      _number_of_mh_late_inlines(0),\n+      _oom(false),\n+      _replay_inline_data(nullptr),\n+      _inline_printer(comp_arena(), directive->PrintInliningOption || PrintOptoInlining),\n+      _java_calls(0),\n+      _inner_loops(0),\n+      _interpreter_frame_size(0),\n+      _output(nullptr)\n@@ -684,1 +681,2 @@\n-                  , _in_dump_cnt(0)\n+      ,\n+      _in_dump_cnt(0)\n@@ -712,1 +710,0 @@\n-  set_print_inlining(directive->PrintInliningOption || PrintOptoInlining);\n@@ -727,1 +724,1 @@\n-  Init(\/*do_aliasing=*\/ true);\n+  Init(\/*do_aliasing=*\/true);\n@@ -736,1 +733,1 @@\n-#define MINIMUM_NODE_HASH  1023\n+#define MINIMUM_NODE_HASH 1023\n@@ -739,1 +736,1 @@\n-  uint estimated_size = method()->code_size()*4+64;\n+  uint estimated_size = method()->code_size() * 4 + 64;\n@@ -747,1 +744,0 @@\n-  print_inlining_init();\n@@ -757,2 +753,2 @@\n-      const TypeTuple *domain = StartOSRNode::osr_domain();\n-      const TypeTuple *range = TypeTuple::make_range(method()->signature());\n+      const TypeTuple* domain = StartOSRNode::osr_domain();\n+      const TypeTuple* range = TypeTuple::make_range(method()->signature());\n@@ -784,1 +780,3 @@\n-    if (failing())  return;\n+    if (failing()) {\n+      return;\n+    }\n@@ -825,1 +823,3 @@\n-    if (failing())  return;\n+    if (failing()) {\n+      return;\n+    }\n@@ -835,1 +835,3 @@\n-  if (failing())  return;\n+  if (failing()) {\n+    return;\n+  }\n@@ -848,2 +850,4 @@\n-  if (failing())  return;\n-  NOT_PRODUCT( verify_graph_edges(); )\n+  if (failing()) {\n+    return;\n+  }\n+  NOT_PRODUCT(verify_graph_edges();)\n@@ -853,2 +857,4 @@\n-  if (failing())  return;\n-  NOT_PRODUCT( verify_graph_edges(); )\n+  if (failing()) {\n+    return;\n+  }\n+  NOT_PRODUCT(verify_graph_edges();)\n@@ -890,22 +896,22 @@\n-Compile::Compile( ciEnv* ci_env,\n-                  TypeFunc_generator generator,\n-                  address stub_function,\n-                  const char *stub_name,\n-                  int is_fancy_jump,\n-                  bool pass_tls,\n-                  bool return_pc,\n-                  DirectiveSet* directive)\n-  : Phase(Compiler),\n-    _compile_id(0),\n-    _options(Options::for_runtime_stub()),\n-    _method(nullptr),\n-    _entry_bci(InvocationEntryBci),\n-    _stub_function(stub_function),\n-    _stub_name(stub_name),\n-    _stub_entry_point(nullptr),\n-    _max_node_limit(MaxNodeLimit),\n-    _post_loop_opts_phase(false),\n-    _allow_macro_nodes(true),\n-    _inlining_progress(false),\n-    _inlining_incrementally(false),\n-    _has_reserved_stack_access(false),\n+Compile::Compile(ciEnv* ci_env,\n+                 TypeFunc_generator generator,\n+                 address stub_function,\n+                 const char* stub_name,\n+                 int is_fancy_jump,\n+                 bool pass_tls,\n+                 bool return_pc,\n+                 DirectiveSet* directive)\n+    : Phase(Compiler),\n+      _compile_id(0),\n+      _options(Options::for_runtime_stub()),\n+      _method(nullptr),\n+      _entry_bci(InvocationEntryBci),\n+      _stub_function(stub_function),\n+      _stub_name(stub_name),\n+      _stub_entry_point(nullptr),\n+      _max_node_limit(MaxNodeLimit),\n+      _post_loop_opts_phase(false),\n+      _allow_macro_nodes(true),\n+      _inlining_progress(false),\n+      _inlining_incrementally(false),\n+      _has_reserved_stack_access(false),\n@@ -913,2 +919,2 @@\n-    _igv_idx(0),\n-    _trace_opto_output(directive->TraceOptoOutputOption),\n+      _igv_idx(0),\n+      _trace_opto_output(directive->TraceOptoOutputOption),\n@@ -916,35 +922,32 @@\n-    _has_method_handle_invokes(false),\n-    _clinit_barrier_on_entry(false),\n-    _stress_seed(0),\n-    _comp_arena(mtCompiler),\n-    _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n-    _env(ci_env),\n-    _directive(directive),\n-    _log(ci_env->log()),\n-    _first_failure_details(nullptr),\n-    _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n-    _congraph(nullptr),\n-    NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n-    _unique(0),\n-    _dead_node_count(0),\n-    _dead_node_list(comp_arena()),\n-    _node_arena_one(mtCompiler),\n-    _node_arena_two(mtCompiler),\n-    _node_arena(&_node_arena_one),\n-    _mach_constant_base_node(nullptr),\n-    _Compile_types(mtCompiler),\n-    _initial_gvn(nullptr),\n-    _igvn_worklist(nullptr),\n-    _types(nullptr),\n-    _node_hash(nullptr),\n-    _number_of_mh_late_inlines(0),\n-    _oom(false),\n-    _print_inlining_stream(new (mtCompiler) stringStream()),\n-    _print_inlining_list(nullptr),\n-    _print_inlining_idx(0),\n-    _print_inlining_output(nullptr),\n-    _replay_inline_data(nullptr),\n-    _java_calls(0),\n-    _inner_loops(0),\n-    _interpreter_frame_size(0),\n-    _output(nullptr),\n+      _has_method_handle_invokes(false),\n+      _clinit_barrier_on_entry(false),\n+      _stress_seed(0),\n+      _comp_arena(mtCompiler),\n+      _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n+      _env(ci_env),\n+      _directive(directive),\n+      _log(ci_env->log()),\n+      _first_failure_details(nullptr),\n+      _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+      _congraph(nullptr),\n+      NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n+          _unique(0),\n+      _dead_node_count(0),\n+      _dead_node_list(comp_arena()),\n+      _node_arena_one(mtCompiler),\n+      _node_arena_two(mtCompiler),\n+      _node_arena(&_node_arena_one),\n+      _mach_constant_base_node(nullptr),\n+      _Compile_types(mtCompiler),\n+      _initial_gvn(nullptr),\n+      _igvn_worklist(nullptr),\n+      _types(nullptr),\n+      _node_hash(nullptr),\n+      _number_of_mh_late_inlines(0),\n+      _oom(false),\n+      _replay_inline_data(nullptr),\n+      _inline_printer(comp_arena(), directive->PrintInliningOption || PrintOptoInlining),\n+      _java_calls(0),\n+      _inner_loops(0),\n+      _interpreter_frame_size(0),\n+      _output(nullptr),\n@@ -952,1 +955,1 @@\n-    _in_dump_cnt(0),\n+      _in_dump_cnt(0),\n@@ -954,1 +957,1 @@\n-    _allowed_reasons(0) {\n+      _allowed_reasons(0) {\n@@ -969,1 +972,1 @@\n-  Init(\/*do_aliasing=*\/ false);\n+  Init(\/*do_aliasing=*\/false);\n@@ -982,1 +985,1 @@\n-    set_initial_gvn(&gvn);    \/\/ not significant, but GraphKit guys use it pervasively\n+    set_initial_gvn(&gvn); \/\/ not significant, but GraphKit guys use it pervasively\n@@ -989,1 +992,1 @@\n-  NOT_PRODUCT( verify_graph_edges(); )\n+  NOT_PRODUCT(verify_graph_edges();)\n@@ -995,1 +998,0 @@\n-  delete _print_inlining_stream;\n@@ -2112,1 +2114,1 @@\n-              cg->print_inlining_late(InliningResult::FAILURE, msg);\n+              inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE, msg);\n@@ -2232,2 +2234,0 @@\n-  print_inlining_reinit();\n-\n@@ -2484,2 +2484,0 @@\n- process_print_inlining();\n-\n@@ -4422,116 +4420,0 @@\n-\/\/ The message about the current inlining is accumulated in\n-\/\/ _print_inlining_stream and transferred into the _print_inlining_list\n-\/\/ once we know whether inlining succeeds or not. For regular\n-\/\/ inlining, messages are appended to the buffer pointed by\n-\/\/ _print_inlining_idx in the _print_inlining_list. For late inlining,\n-\/\/ a new buffer is added after _print_inlining_idx in the list. This\n-\/\/ way we can update the inlining message for late inlining call site\n-\/\/ when the inlining is attempted again.\n-void Compile::print_inlining_init() {\n-  if (print_inlining() || print_intrinsics()) {\n-    \/\/ print_inlining_init is actually called several times.\n-    print_inlining_reset();\n-    _print_inlining_list = new (comp_arena())GrowableArray<PrintInliningBuffer*>(comp_arena(), 1, 1, new PrintInliningBuffer());\n-  }\n-}\n-\n-void Compile::print_inlining_reinit() {\n-  if (print_inlining() || print_intrinsics()) {\n-    print_inlining_reset();\n-  }\n-}\n-\n-void Compile::print_inlining_reset() {\n-  _print_inlining_stream->reset();\n-}\n-\n-void Compile::print_inlining_commit() {\n-  assert(print_inlining() || print_intrinsics(), \"PrintInlining off?\");\n-  \/\/ Transfer the message from _print_inlining_stream to the current\n-  \/\/ _print_inlining_list buffer and clear _print_inlining_stream.\n-  _print_inlining_list->at(_print_inlining_idx)->ss()->write(_print_inlining_stream->base(), _print_inlining_stream->size());\n-  print_inlining_reset();\n-}\n-\n-void Compile::print_inlining_push() {\n-  \/\/ Add new buffer to the _print_inlining_list at current position\n-  _print_inlining_idx++;\n-  _print_inlining_list->insert_before(_print_inlining_idx, new PrintInliningBuffer());\n-}\n-\n-Compile::PrintInliningBuffer* Compile::print_inlining_current() {\n-  return _print_inlining_list->at(_print_inlining_idx);\n-}\n-\n-void Compile::print_inlining_update(CallGenerator* cg) {\n-  if (print_inlining() || print_intrinsics()) {\n-    if (cg->is_late_inline()) {\n-      if (print_inlining_current()->cg() != cg &&\n-          (print_inlining_current()->cg() != nullptr ||\n-           print_inlining_current()->ss()->size() != 0)) {\n-        print_inlining_push();\n-      }\n-      print_inlining_commit();\n-      print_inlining_current()->set_cg(cg);\n-    } else {\n-      if (print_inlining_current()->cg() != nullptr) {\n-        print_inlining_push();\n-      }\n-      print_inlining_commit();\n-    }\n-  }\n-}\n-\n-void Compile::print_inlining_move_to(CallGenerator* cg) {\n-  \/\/ We resume inlining at a late inlining call site. Locate the\n-  \/\/ corresponding inlining buffer so that we can update it.\n-  if (print_inlining() || print_intrinsics()) {\n-    for (int i = 0; i < _print_inlining_list->length(); i++) {\n-      if (_print_inlining_list->at(i)->cg() == cg) {\n-        _print_inlining_idx = i;\n-        return;\n-      }\n-    }\n-    ShouldNotReachHere();\n-  }\n-}\n-\n-void Compile::print_inlining_update_delayed(CallGenerator* cg) {\n-  if (print_inlining() || print_intrinsics()) {\n-    assert(_print_inlining_stream->size() > 0, \"missing inlining msg\");\n-    assert(print_inlining_current()->cg() == cg, \"wrong entry\");\n-    \/\/ replace message with new message\n-    _print_inlining_list->at_put(_print_inlining_idx, new PrintInliningBuffer());\n-    print_inlining_commit();\n-    print_inlining_current()->set_cg(cg);\n-  }\n-}\n-\n-void Compile::print_inlining_assert_ready() {\n-  assert(!_print_inlining || _print_inlining_stream->size() == 0, \"losing data\");\n-}\n-\n-void Compile::process_print_inlining() {\n-  assert(_late_inlines.length() == 0, \"not drained yet\");\n-  if (print_inlining() || print_intrinsics()) {\n-    ResourceMark rm;\n-    stringStream ss;\n-    assert(_print_inlining_list != nullptr, \"process_print_inlining should be called only once.\");\n-    for (int i = 0; i < _print_inlining_list->length(); i++) {\n-      PrintInliningBuffer* pib = _print_inlining_list->at(i);\n-      ss.print(\"%s\", pib->ss()->freeze());\n-      delete pib;\n-      DEBUG_ONLY(_print_inlining_list->at_put(i, nullptr));\n-    }\n-    \/\/ Reset _print_inlining_list, it only contains destructed objects.\n-    \/\/ It is on the arena, so it will be freed when the arena is reset.\n-    _print_inlining_list = nullptr;\n-    \/\/ _print_inlining_stream won't be used anymore, either.\n-    print_inlining_reset();\n-    size_t end = ss.size();\n-    _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);\n-    strncpy(_print_inlining_output, ss.freeze(), end+1);\n-    _print_inlining_output[end] = 0;\n-  }\n-}\n-\n@@ -4539,3 +4421,1 @@\n-  if (_print_inlining_output != nullptr) {\n-    tty->print_raw(_print_inlining_output);\n-  }\n+  inline_printer()->dump(tty);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":151,"deletions":271,"binary":false,"changes":422,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"opto\/printinlining.hpp\"\n@@ -474,23 +475,0 @@\n-  \/\/ Inlining may not happen in parse order which would make\n-  \/\/ PrintInlining output confusing. Keep track of PrintInlining\n-  \/\/ pieces in order.\n-  class PrintInliningBuffer : public CHeapObj<mtCompiler> {\n-   private:\n-    CallGenerator* _cg;\n-    stringStream   _ss;\n-    static const size_t default_stream_buffer_size = 128;\n-\n-   public:\n-    PrintInliningBuffer()\n-      : _cg(nullptr), _ss(default_stream_buffer_size) {}\n-\n-    stringStream* ss()             { return &_ss; }\n-    CallGenerator* cg()            { return _cg; }\n-    void set_cg(CallGenerator* cg) { _cg = cg; }\n-  };\n-\n-  stringStream* _print_inlining_stream;\n-  GrowableArray<PrintInliningBuffer*>* _print_inlining_list;\n-  int _print_inlining_idx;\n-  char* _print_inlining_output;\n-\n@@ -508,6 +486,0 @@\n-  void print_inlining_init();\n-  void print_inlining_reinit();\n-  void print_inlining_commit();\n-  void print_inlining_push();\n-  PrintInliningBuffer* print_inlining_current();\n-\n@@ -519,1 +491,1 @@\n- public:\n+  InlinePrinter _inline_printer;\n@@ -521,0 +493,1 @@\n+public:\n@@ -523,16 +496,1 @@\n-  stringStream* print_inlining_stream() {\n-    assert(print_inlining() || print_intrinsics(), \"PrintInlining off?\");\n-    return _print_inlining_stream;\n-  }\n-\n-  void print_inlining_update(CallGenerator* cg);\n-  void print_inlining_update_delayed(CallGenerator* cg);\n-  void print_inlining_move_to(CallGenerator* cg);\n-  void print_inlining_assert_ready();\n-  void print_inlining_reset();\n-\n-  void print_inlining(ciMethod* method, int inline_level, int bci, InliningResult result, const char* msg = nullptr) {\n-    stringStream ss;\n-    CompileTask::print_inlining_inner(&ss, method, inline_level, bci, result, msg);\n-    print_inlining_stream()->print(\"%s\", ss.freeze());\n-  }\n+  InlinePrinter* inline_printer() { return &_inline_printer; }\n@@ -669,2 +627,1 @@\n-  bool              print_inlining() const       { return _print_inlining; }\n-  void          set_print_inlining(bool z)       { _print_inlining = z; }\n+  bool print_inlining() const { return _inline_printer.is_enabled(); }\n@@ -1102,1 +1059,0 @@\n-  void process_print_inlining();\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":49,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -53,2 +53,5 @@\n-static void print_trace_type_profile(outputStream* out, int depth, ciKlass* prof_klass, int site_count, int receiver_count) {\n-  CompileTask::print_inline_indent(depth, out);\n+static void print_trace_type_profile(outputStream* out, int depth, ciKlass* prof_klass, int site_count, int receiver_count,\n+                                     bool with_deco) {\n+  if (with_deco) {\n+    CompileTask::print_inline_indent(depth, out);\n+  }\n@@ -57,1 +60,3 @@\n-  out->cr();\n+  if (with_deco) {\n+    out->cr();\n+  }\n@@ -60,2 +65,4 @@\n-static void trace_type_profile(Compile* C, ciMethod* method, int depth, int bci, ciMethod* prof_method,\n-                               ciKlass* prof_klass, int site_count, int receiver_count) {\n+static void trace_type_profile(Compile* C, ciMethod* method, JVMState* jvms,\n+                               ciMethod* prof_method, ciKlass* prof_klass, int site_count, int receiver_count) {\n+  int depth = jvms->depth() - 1;\n+  int bci = jvms->bci();\n@@ -63,1 +70,0 @@\n-    outputStream* out = tty;\n@@ -70,0 +76,1 @@\n+      print_trace_type_profile(tty, depth, prof_klass, site_count, receiver_count, true);\n@@ -71,1 +78,2 @@\n-      out = C->print_inlining_stream();\n+      auto stream = C->inline_printer()->record(method, jvms, InliningResult::SUCCESS);\n+      print_trace_type_profile(stream, depth, prof_klass, site_count, receiver_count, false);\n@@ -73,1 +81,0 @@\n-    print_trace_type_profile(out, depth, prof_klass, site_count, receiver_count);\n@@ -79,1 +86,1 @@\n-    print_trace_type_profile(&ls, depth, prof_klass, site_count, receiver_count);\n+    print_trace_type_profile(&ls, depth, prof_klass, site_count, receiver_count, true);\n@@ -89,4 +96,4 @@\n-  ciMethod*       caller      = jvms->method();\n-  int             bci         = jvms->bci();\n-  Bytecodes::Code bytecode    = caller->java_code_at_bci(bci);\n-  ciMethod*       orig_callee = caller->get_method_at_bci(bci);\n+  ciMethod* caller = jvms->method();\n+  int bci = jvms->bci();\n+  Bytecodes::Code bytecode = caller->java_code_at_bci(bci);\n+  ciMethod* orig_callee = caller->get_method_at_bci(bci);\n@@ -120,2 +127,2 @@\n-    int rid = (receiver_count >= 0)? log->identify(profile.receiver(0)): -1;\n-    int r2id = (rid != -1 && profile.has_receiver(1))? log->identify(profile.receiver(1)):-1;\n+    int rid = (receiver_count >= 0) ? log->identify(profile.receiver(0)) : -1;\n+    int r2id = (rid != -1 && profile.has_receiver(1)) ? log->identify(profile.receiver(1)) : -1;\n@@ -124,2 +131,6 @@\n-    if (call_does_dispatch)  log->print(\" virtual='1'\");\n-    if (allow_inline)     log->print(\" inline='1'\");\n+    if (call_does_dispatch) {\n+      log->print(\" virtual='1'\");\n+    }\n+    if (allow_inline) {\n+      log->print(\" inline='1'\");\n+    }\n@@ -148,1 +159,1 @@\n-              vtable_index, call_does_dispatch, jvms, allow_inline, prof_factor, speculative_receiver_type, false);\n+                                                        vtable_index, call_does_dispatch, jvms, allow_inline, prof_factor, speculative_receiver_type, false);\n@@ -199,1 +210,1 @@\n-              Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n+                                                                    Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n@@ -225,1 +236,1 @@\n-      bool have_major_receiver = profile.has_receiver(0) && (100.*profile.receiver_prob(0) >= (float)TypeProfileMajorReceiverPercent);\n+      bool have_major_receiver = profile.has_receiver(0) && (100. * profile.receiver_prob(0) >= (float)TypeProfileMajorReceiverPercent);\n@@ -254,1 +265,1 @@\n-                                                      profile.receiver(0));\n+                                                 profile.receiver(0));\n@@ -259,1 +270,1 @@\n-              vtable_index, !call_does_dispatch, jvms, allow_inline, prof_factor);\n+                                                     vtable_index, !call_does_dispatch, jvms, allow_inline, prof_factor);\n@@ -266,1 +277,1 @@\n-                                                               profile.receiver(1));\n+                                                          profile.receiver(1));\n@@ -269,2 +280,2 @@\n-                                  vtable_index, !call_does_dispatch, jvms,\n-                                  allow_inline, prof_factor);\n+                                                 vtable_index, !call_does_dispatch, jvms,\n+                                                 allow_inline, prof_factor);\n@@ -273,2 +284,2 @@\n-                  \/\/ Skip if we can't inline second receiver's method\n-                  next_hit_cg = nullptr;\n+                \/\/ Skip if we can't inline second receiver's method\n+                next_hit_cg = nullptr;\n@@ -280,2 +291,2 @@\n-                                               ? Deoptimization::Reason_bimorphic\n-                                               : Deoptimization::reason_class_check(speculative_receiver_type != nullptr));\n+                                                    ? Deoptimization::Reason_bimorphic\n+                                                    : Deoptimization::reason_class_check(speculative_receiver_type != nullptr));\n@@ -283,2 +294,1 @@\n-              !too_many_traps_or_recompiles(caller, bci, reason)\n-             ) {\n+              !too_many_traps_or_recompiles(caller, bci, reason)) {\n@@ -288,1 +298,1 @@\n-                        Deoptimization::Action_maybe_recompile);\n+                                                       Deoptimization::Action_maybe_recompile);\n@@ -298,1 +308,1 @@\n-              trace_type_profile(C, jvms->method(), jvms->depth() - 1, jvms->bci(), next_receiver_method, profile.receiver(1), site_count, profile.receiver_count(1));\n+              trace_type_profile(C, jvms->method(), jvms, next_receiver_method, profile.receiver(1), site_count, profile.receiver_count(1));\n@@ -305,1 +315,1 @@\n-              trace_type_profile(C, jvms->method(), jvms->depth() - 1, jvms->bci(), receiver_method, k, site_count, receiver_count);\n+              trace_type_profile(C, jvms->method(), jvms, receiver_method, k, site_count, receiver_count);\n@@ -308,1 +318,3 @@\n-              if (cg != nullptr)  return cg;\n+              if (cg != nullptr) {\n+                return cg;\n+              }\n@@ -346,1 +358,1 @@\n-              vtable_index, !call_does_dispatch, jvms, allow_inline, prof_factor);\n+                                                 vtable_index, !call_does_dispatch, jvms, allow_inline, prof_factor);\n@@ -350,1 +362,1 @@\n-              Deoptimization::Reason_class_check, Deoptimization::Action_none);\n+                                                                    Deoptimization::Reason_class_check, Deoptimization::Action_none);\n@@ -375,3 +387,1 @@\n-    if (C->print_inlining()) {\n-      print_inlining(callee, jvms->depth() - 1, jvms->bci(), InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -391,1 +401,1 @@\n-          Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n+                                                                Deoptimization::Reason_receiver_constraint, Deoptimization::Action_none);\n@@ -412,30 +422,27 @@\n-      case vmIntrinsics::_StringBuilder_void:\n-      case vmIntrinsics::_StringBuilder_int:\n-      case vmIntrinsics::_StringBuilder_String:\n-      case vmIntrinsics::_StringBuilder_append_char:\n-      case vmIntrinsics::_StringBuilder_append_int:\n-      case vmIntrinsics::_StringBuilder_append_String:\n-      case vmIntrinsics::_StringBuilder_toString:\n-      case vmIntrinsics::_StringBuffer_void:\n-      case vmIntrinsics::_StringBuffer_int:\n-      case vmIntrinsics::_StringBuffer_String:\n-      case vmIntrinsics::_StringBuffer_append_char:\n-      case vmIntrinsics::_StringBuffer_append_int:\n-      case vmIntrinsics::_StringBuffer_append_String:\n-      case vmIntrinsics::_StringBuffer_toString:\n-      case vmIntrinsics::_Integer_toString:\n-        return true;\n-\n-      case vmIntrinsics::_String_String:\n-        {\n-          Node* receiver = jvms->map()->in(jvms->argoff() + 1);\n-          if (receiver->is_Proj() && receiver->in(0)->is_CallStaticJava()) {\n-            CallStaticJavaNode* csj = receiver->in(0)->as_CallStaticJava();\n-            ciMethod* m = csj->method();\n-            if (m != nullptr &&\n-                (m->intrinsic_id() == vmIntrinsics::_StringBuffer_toString ||\n-                 m->intrinsic_id() == vmIntrinsics::_StringBuilder_toString))\n-              \/\/ Delay String.<init>(new SB())\n-              return true;\n-          }\n-          return false;\n+    case vmIntrinsics::_StringBuilder_void:\n+    case vmIntrinsics::_StringBuilder_int:\n+    case vmIntrinsics::_StringBuilder_String:\n+    case vmIntrinsics::_StringBuilder_append_char:\n+    case vmIntrinsics::_StringBuilder_append_int:\n+    case vmIntrinsics::_StringBuilder_append_String:\n+    case vmIntrinsics::_StringBuilder_toString:\n+    case vmIntrinsics::_StringBuffer_void:\n+    case vmIntrinsics::_StringBuffer_int:\n+    case vmIntrinsics::_StringBuffer_String:\n+    case vmIntrinsics::_StringBuffer_append_char:\n+    case vmIntrinsics::_StringBuffer_append_int:\n+    case vmIntrinsics::_StringBuffer_append_String:\n+    case vmIntrinsics::_StringBuffer_toString:\n+    case vmIntrinsics::_Integer_toString:\n+      return true;\n+\n+    case vmIntrinsics::_String_String: {\n+      Node* receiver = jvms->map()->in(jvms->argoff() + 1);\n+      if (receiver->is_Proj() && receiver->in(0)->is_CallStaticJava()) {\n+        CallStaticJavaNode* csj = receiver->in(0)->as_CallStaticJava();\n+        ciMethod* m = csj->method();\n+        if (m != nullptr &&\n+            (m->intrinsic_id() == vmIntrinsics::_StringBuffer_toString ||\n+             m->intrinsic_id() == vmIntrinsics::_StringBuilder_toString)) {\n+          \/\/ Delay String.<init>(new SB())\n+          return true;\n@@ -443,0 +450,3 @@\n+      }\n+      return false;\n+    }\n@@ -444,2 +454,2 @@\n-      default:\n-        return false;\n+    default:\n+      return false;\n@@ -468,1 +478,1 @@\n-bool Parse::can_not_compile_call_site(ciMethod *dest_method, ciInstanceKlass* klass) {\n+bool Parse::can_not_compile_call_site(ciMethod* dest_method, ciInstanceKlass* klass) {\n@@ -473,1 +483,1 @@\n-  assert( dest_method->is_loaded(), \"ciTypeFlow should not let us get here\" );\n+  assert(dest_method->is_loaded(), \"ciTypeFlow should not let us get here\");\n@@ -499,1 +509,2 @@\n-    jvms->method()->get_method_at_bci(jvms->bci())->print(); tty->cr();\n+    jvms->method()->get_method_at_bci(jvms->bci())->print();\n+    tty->cr();\n@@ -501,1 +512,2 @@\n-    cg->method()->print(); tty->cr();\n+    cg->method()->print();\n+    tty->cr();\n@@ -516,2 +528,0 @@\n-  C->print_inlining_assert_ready();\n-\n@@ -524,3 +534,3 @@\n-  bool             will_link;\n-  ciSignature*     declared_signature = nullptr;\n-  ciMethod*        orig_callee  = iter().get_method(will_link, &declared_signature);  \/\/ callee in the bytecode\n+  bool will_link;\n+  ciSignature* declared_signature = nullptr;\n+  ciMethod* orig_callee = iter().get_method(will_link, &declared_signature); \/\/ callee in the bytecode\n@@ -528,1 +538,1 @@\n-  ciKlass*         holder       = iter().get_declared_method_holder();\n+  ciKlass* holder = iter().get_declared_method_holder();\n@@ -535,1 +545,1 @@\n-    C->set_max_node_limit(3*MaxNodeLimit);\n+    C->set_max_node_limit(3 * MaxNodeLimit);\n@@ -542,2 +552,4 @@\n-      method()->print_name(); tty->print_cr(\" can not compile call at bci %d to:\", bci());\n-      orig_callee->print_name(); tty->cr();\n+      method()->print_name();\n+      tty->print_cr(\" can not compile call at bci %d to:\", bci());\n+      orig_callee->print_name();\n+      tty->cr();\n@@ -548,3 +560,3 @@\n-  \/\/assert((bc_callee->is_static() || is_invokedynamic) == !has_receiver , \"must match bc\");  \/\/ XXX invokehandle (cur_bc_raw)\n-  \/\/ Note: this takes into account invokeinterface of methods declared in java\/lang\/Object,\n-  \/\/ which should be invokevirtuals but according to the VM spec may be invokeinterfaces\n+  \/\/ assert((bc_callee->is_static() || is_invokedynamic) == !has_receiver , \"must match bc\");  \/\/ XXX invokehandle (cur_bc_raw)\n+  \/\/  Note: this takes into account invokeinterface of methods declared in java\/lang\/Object,\n+  \/\/  which should be invokevirtuals but according to the VM spec may be invokeinterfaces\n@@ -576,3 +588,3 @@\n-  ciMethod* callee             = orig_callee;\n-  int       vtable_index       = Method::invalid_vtable_index;\n-  bool      call_does_dispatch = false;\n+  ciMethod* callee = orig_callee;\n+  int vtable_index = Method::invalid_vtable_index;\n+  bool call_does_dispatch = false;\n@@ -583,1 +595,1 @@\n-    Node* receiver_node             = stack(sp() - nargs);\n+    Node* receiver_node = stack(sp() - nargs);\n@@ -594,1 +606,1 @@\n-                                      call_does_dispatch, vtable_index);  \/\/ out-parameters\n+                                      call_does_dispatch, vtable_index); \/\/ out-parameters\n@@ -634,1 +646,1 @@\n-  dec_sp(nargs);              \/\/ Temporarily pop args for JVM state of call\n+  dec_sp(nargs); \/\/ Temporarily pop args for JVM state of call\n@@ -663,1 +675,1 @@\n-  assert(jvms_in_sync(),       \"jvms must carry full info into CG\");\n+  assert(jvms_in_sync(), \"jvms must carry full info into CG\");\n@@ -682,1 +694,3 @@\n-    if (failing())  return;\n+    if (failing()) {\n+      return;\n+    }\n@@ -733,1 +747,1 @@\n-          pop_node(rt);  \/\/ whatever it was, pop it\n+          pop_node(rt); \/\/ whatever it was, pop it\n@@ -741,1 +755,1 @@\n-            const Type*       sig_type = TypeOopPtr::make_from_klass(ctype->as_klass());\n+            const Type* sig_type = TypeOopPtr::make_from_klass(ctype->as_klass());\n@@ -772,2 +786,4 @@\n-        method()->print_name(); tty->print_cr(\" asserting nullness of result at bci: %d\", bci());\n-        cg->method()->print_name(); tty->cr();\n+        method()->print_name();\n+        tty->print_cr(\" asserting nullness of result at bci: %d\", bci());\n+        cg->method()->print_name();\n+        tty->cr();\n@@ -813,3 +829,3 @@\n-    ciExceptionHandler* h       = handlers.handler();\n-    int                 h_bci   = h->handler_bci();\n-    ciInstanceKlass*    h_klass = h->is_catch_all() ? env()->Throwable_klass() : h->catch_klass();\n+    ciExceptionHandler* h = handlers.handler();\n+    int h_bci = h->handler_bci();\n+    ciInstanceKlass* h_klass = h->is_catch_all() ? env()->Throwable_klass() : h->catch_klass();\n@@ -847,2 +863,2 @@\n-  CatchNode *cn = new CatchNode(control(), i_o, len+1);\n-  Node *catch_ = _gvn.transform(cn);\n+  CatchNode* cn = new CatchNode(control(), i_o, len + 1);\n+  Node* catch_ = _gvn.transform(cn);\n@@ -852,1 +868,1 @@\n-  for(int i=0; i < len; i++) {\n+  for (int i = 0; i < len; i++) {\n@@ -858,1 +874,1 @@\n-    Node* ctrl = _gvn.transform( new CatchProjNode(catch_, i+1,handler_bci));\n+    Node* ctrl = _gvn.transform(new CatchProjNode(catch_, i + 1, handler_bci));\n@@ -860,1 +876,3 @@\n-    if (ctrl == top())  continue;\n+    if (ctrl == top()) {\n+      continue;\n+    }\n@@ -875,1 +893,2 @@\n-        method()->print_name(); tty->cr();\n+        method()->print_name();\n+        tty->cr();\n@@ -880,1 +899,2 @@\n-        method()->print_name(); tty->cr();\n+        method()->print_name();\n+        tty->cr();\n@@ -894,1 +914,1 @@\n-    if (handler_bci < 0) {     \/\/ merge with corresponding rethrow node\n+    if (handler_bci < 0) { \/\/ merge with corresponding rethrow node\n@@ -896,2 +916,2 @@\n-    } else {                      \/\/ Else jump to corresponding handle\n-      push_ex_oop(ex_oop);        \/\/ Clear stack and push just the oop.\n+    } else {               \/\/ Else jump to corresponding handle\n+      push_ex_oop(ex_oop); \/\/ Clear stack and push just the oop.\n@@ -904,1 +924,1 @@\n-  set_control(_gvn.transform( new CatchProjNode(catch_, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci)));\n+  set_control(_gvn.transform(new CatchProjNode(catch_, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci)));\n@@ -907,1 +927,0 @@\n-\n@@ -929,2 +948,2 @@\n-  NOT_PRODUCT(if (ex_type==nullptr) tty->print_cr(\"*** Exception not InstPtr\"));\n-  if (ex_type == nullptr)\n+  NOT_PRODUCT(if (ex_type == nullptr) tty->print_cr(\"*** Exception not InstPtr\"));\n+  if (ex_type == nullptr) {\n@@ -932,0 +951,1 @@\n+  }\n@@ -945,1 +965,1 @@\n-    Node* p = basic_plus_adr( ex_node, ex_node, oopDesc::klass_offset_in_bytes());\n+    Node* p = basic_plus_adr(ex_node, ex_node, oopDesc::klass_offset_in_bytes());\n@@ -964,2 +984,2 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n-        ex_klass_node->init_req( i, k );\n+        Node* k = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        ex_klass_node->init_req(i, k);\n@@ -980,1 +1000,1 @@\n-  for (;!handlers.is_done(); handlers.next()) {\n+  for (; !handlers.is_done(); handlers.next()) {\n@@ -996,1 +1016,1 @@\n-      push_ex_oop(ex_node);        \/\/ Push exception oop for handler\n+      push_ex_oop(ex_node); \/\/ Push exception oop for handler\n@@ -1003,1 +1023,1 @@\n-      return;                   \/\/ No more handling to be done here!\n+      return;                       \/\/ No more handling to be done here!\n@@ -1009,1 +1029,1 @@\n-    if (!klass->is_loaded()) {  \/\/ klass is not loaded?\n+    if (!klass->is_loaded()) { \/\/ klass is not loaded?\n@@ -1015,2 +1035,3 @@\n-    if (klass->is_interface())  \/\/ should not happen, but...\n-      break;                    \/\/ bail out\n+    if (klass->is_interface()) { \/\/ should not happen, but...\n+      break;                     \/\/ bail out\n+    }\n@@ -1019,1 +1040,1 @@\n-    const TypeKlassPtr *tk = TypeKlassPtr::make(klass);\n+    const TypeKlassPtr* tk = TypeKlassPtr::make(klass);\n@@ -1027,1 +1048,1 @@\n-      push_ex_oop(ex_oop);      \/\/ Push exception oop for handler\n+      push_ex_oop(ex_oop); \/\/ Push exception oop for handler\n@@ -1063,1 +1084,0 @@\n-\n@@ -1066,1 +1086,0 @@\n-\n@@ -1069,2 +1088,2 @@\n-  if( CountCompiledCalls ) {\n-    if( at_method_entry ) {\n+  if (CountCompiledCalls) {\n+    if (at_method_entry) {\n@@ -1080,2 +1099,6 @@\n-      case Bytecodes::_invokevirtual:   increment_counter(SharedRuntime::nof_inlined_calls_addr()); break;\n-      case Bytecodes::_invokeinterface: increment_counter(SharedRuntime::nof_inlined_interface_calls_addr()); break;\n+      case Bytecodes::_invokevirtual:\n+        increment_counter(SharedRuntime::nof_inlined_calls_addr());\n+        break;\n+      case Bytecodes::_invokeinterface:\n+        increment_counter(SharedRuntime::nof_inlined_interface_calls_addr());\n+        break;\n@@ -1084,2 +1107,5 @@\n-      case Bytecodes::_invokespecial:   increment_counter(SharedRuntime::nof_inlined_static_calls_addr()); break;\n-      default: fatal(\"unexpected call bytecode\");\n+      case Bytecodes::_invokespecial:\n+        increment_counter(SharedRuntime::nof_inlined_static_calls_addr());\n+        break;\n+      default:\n+        fatal(\"unexpected call bytecode\");\n@@ -1089,2 +1115,6 @@\n-      case Bytecodes::_invokevirtual:   increment_counter(SharedRuntime::nof_normal_calls_addr()); break;\n-      case Bytecodes::_invokeinterface: increment_counter(SharedRuntime::nof_interface_calls_addr()); break;\n+      case Bytecodes::_invokevirtual:\n+        increment_counter(SharedRuntime::nof_normal_calls_addr());\n+        break;\n+      case Bytecodes::_invokeinterface:\n+        increment_counter(SharedRuntime::nof_interface_calls_addr());\n+        break;\n@@ -1093,2 +1123,5 @@\n-      case Bytecodes::_invokespecial:   increment_counter(SharedRuntime::nof_static_calls_addr()); break;\n-      default: fatal(\"unexpected call bytecode\");\n+      case Bytecodes::_invokespecial:\n+        increment_counter(SharedRuntime::nof_static_calls_addr());\n+        break;\n+      default:\n+        fatal(\"unexpected call bytecode\");\n@@ -1099,2 +1132,1 @@\n-#endif \/\/PRODUCT\n-\n+#endif \/\/ PRODUCT\n@@ -1109,1 +1141,1 @@\n-  vtable_index       = Method::invalid_vtable_index;\n+  vtable_index = Method::invalid_vtable_index;\n@@ -1117,1 +1149,1 @@\n-    callee             = optimized_virtual_method;\n+    callee = optimized_virtual_method;\n@@ -1170,1 +1202,1 @@\n-  ciInstanceKlass*   calling_klass = caller->holder();\n+  ciInstanceKlass* calling_klass = caller->holder();\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":178,"deletions":146,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -122,3 +122,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::SUCCESS, inline_msg);\n@@ -134,1 +132,0 @@\n-    C->print_inlining_update(this);\n@@ -150,3 +147,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -167,1 +162,0 @@\n-  C->print_inlining_update(this);\n@@ -193,3 +187,2 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::SUCCESS, inline_msg);\n+\n@@ -211,3 +204,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(kit.callee(), jvms, InliningResult::FAILURE, msg);\n@@ -223,3 +214,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining_stream()->print(\"%s\", msg);\n-    }\n+    C->inline_printer()->record(kit.callee(), jvms, InliningResult::FAILURE, msg);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -551,4 +551,0 @@\n-\n-      C->print_inlining_assert_ready();\n-      C->print_inlining_move_to(cg);\n-      C->print_inlining_update(cloned_cg);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,4 +77,3 @@\n-                            ciMethod* caller_method,\n-                            int caller_bci,\n-                            bool& should_delay,\n-                            ciCallProfile& profile);\n+                     ciMethod* caller_method,\n+                     JVMState* caller_jvms,\n+                     bool& should_delay, ciCallProfile& profile);\n@@ -90,2 +89,1 @@\n-  void        print_inlining(ciMethod* callee_method, int caller_bci,\n-                             ciMethod* caller_method, bool success) const;\n+  void print_inlining(ciMethod* callee_method, JVMState* jvm, bool success) const;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"printinlining.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+InlinePrinter::InlinePrinter(Arena* arena, bool enabled) : _enabled(enabled), _root(new(arena) IPInlineSite(nullptr, arena)) {\n+}\n+\n+InlinePrinter::IPInlineAttempt::IPInlineAttempt(InliningResult result) : result(result) {\n+}\n+\n+outputStream* InlinePrinter::record(ciMethod* method, JVMState* state, InliningResult result, const char* msg) {\n+  if (!_enabled) {\n+    return &_nullStream;\n+  }\n+  auto attempt = locate_call(state, method)->add(result);\n+  if (msg != nullptr) {\n+    attempt->msg.print(\"%s\", msg);\n+  }\n+  return &attempt->msg; \/\/ IPInlineAttempts are heap allocated so this address is safe\n+}\n+\n+void InlinePrinter::dump(outputStream* tty) {\n+  if (!_enabled) {\n+    return;\n+  }\n+  _root->dump(tty, -1, -1);\n+}\n+\n+InlinePrinter::IPInlineSite* InlinePrinter::locate_call(JVMState* state, ciMethod* create_for) {\n+  if (state == nullptr) {\n+    return _root;\n+  }\n+\n+  return locate_call(state->caller(), nullptr)->at_bci(state->bci(), create_for);\n+}\n+\n+InlinePrinter::IPInlineSite* InlinePrinter::IPInlineSite::at_bci(int bci, ciMethod* create_for) {\n+  if (_children.length() <= bci) {\n+    assert(create_for != nullptr, \"an inline call is missing in the chain up to the root\");\n+    auto child = new (_arena) IPInlineSite(create_for, _arena);\n+    _children.at_put_grow(bci, child, nullptr);\n+    return child;\n+  }\n+  if (auto child = _children.at(bci)) {\n+    return child;\n+  }\n+  auto child = new (_arena) IPInlineSite(create_for, _arena);\n+  _children.at_put(bci, child);\n+  return child;\n+}\n+\n+InlinePrinter::IPInlineAttempt* InlinePrinter::IPInlineSite::add(InliningResult result) {\n+  auto attempt = new (_arena) IPInlineAttempt(result);\n+  _attempts.push(attempt);\n+  return attempt;\n+}\n+\n+void InlinePrinter::IPInlineSite::dump(outputStream* tty, int level, int bci) {\n+  if (_attempts.is_nonempty()) {\n+    CompileTask::print_inlining_header(tty, _method, level, bci);\n+  }\n+  for (auto* attempt : _attempts) {\n+    assert(bci >= 0, \"BCI cannot be negative. Is there an inline attempt for the root?\");\n+    CompileTask::print_inlining_inner_message(tty, attempt->result, attempt->msg.base());\n+  }\n+  if (_attempts.is_nonempty()) {\n+    tty->cr();\n+  }\n+\n+  for (int bci = 0; bci < _children.length(); bci++) {\n+    auto child = _children.at(bci);\n+    if (child != nullptr) {\n+      child->dump(tty, level + 1, bci);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/printinlining.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef PRINTINLINING_HPP\n+#define PRINTINLINING_HPP\n+\n+class JVMState;\n+class ciMethod;\n+enum class InliningResult;\n+\n+class InlinePrinter {\n+public:\n+  \/**\n+   * @param If enabled is false, all method calls are no-ops.\n+   *\/\n+  InlinePrinter(Arena* arena, bool enabled);\n+\n+  \/**\n+   * Saves the result of an inline attempt of `method` at `state`.\n+   * @param method The method that was attempted to inline\n+   * @param state Where the attempt was made.\n+   * @param result Whether the inline was successful.\n+   * @param msg An optional string message with more details that is copied to the stream for this attempt. Pointer is not captured.\n+   * @returns An output stream which stores the message associated with this attempt. The buffer stays valid until InlinePrinter is deallocated.\n+   *          You can print arbitrary information to this stream but do not add line breaks, as this will break formatting.\n+   *\/\n+  outputStream* record(ciMethod* method, JVMState* state, InliningResult result, const char* msg = nullptr);\n+\n+  \/**\n+   * Prints all collected inlining information to the given output stream.\n+   *\/\n+  void dump(outputStream* tty);\n+\n+  \/**\n+   * Whether inline printing is enabled. If not enabled, all method calls are no-ops.\n+   *\/\n+  bool is_enabled() const { return _enabled; }\n+\n+private:\n+  struct IPInlineAttempt : public ArenaObj {\n+    IPInlineAttempt(InliningResult result);\n+    const InliningResult result;\n+    stringStream msg;\n+  };\n+\n+  class IPInlineSite : public ArenaObj {\n+  public:\n+    \/**\n+     * @param The method being called. May be null iff this is the root of the tree.\n+     *\/\n+    IPInlineSite(ciMethod* method, Arena* arena) : _arena(arena), _method(method),\n+                                                   _attempts(arena, 2, 0, nullptr),\n+                                                   _children(arena, 2, 0, nullptr) {}\n+    \/**\n+     * Finds the node for an inline attempt that occurred inside this inline.\n+     * @param If the method is allowed to create a missing inline site inside this inline, provide\n+     *        the method which is being inline. If no new inline site should be created, provide\n+     *        null.\n+     * @param arena\n+     *\/\n+    IPInlineSite* at_bci(int bci, ciMethod* create_for);\n+    InlinePrinter::IPInlineAttempt* add(InliningResult result);\n+\n+    void dump(outputStream* tty, int level, int bci);\n+\n+  private:\n+    Arena* const _arena;\n+    ciMethod* const _method;\n+    GrowableArray<IPInlineAttempt*> _attempts;\n+    GrowableArray<IPInlineSite*> _children;\n+  };\n+\n+  bool _enabled;\n+\n+  \/**\n+   * In case print inline is disabled, this null stream is returned from ::record()\n+   *\/\n+  nullStream _nullStream;\n+\n+  \/**\n+   * Locates the IPCall node that corresponds to this JVM state.\n+   * state may be null. In this case, the root node is returned.\n+   * @param Set is_leaf to true if you call this method to add an new inline attempt.\n+   *        Must be false for recursive calls.\n+   * @param create_for\n+   *\/\n+  IPInlineSite* locate_call(JVMState* state, ciMethod* create_for);\n+\n+  IPInlineSite* const _root;\n+};\n+\n+#endif \/\/ PRINTINLINING_HPP\n","filename":"src\/hotspot\/share\/opto\/printinlining.hpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @bug 8319850\n+ * @summary PrintInlining should print which methods are late inlines\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ *\n+ * @run driver compiler.inlining.LateInlinePrinting\n+ *\/\n+\n+package compiler.inlining;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LateInlinePrinting {\n+    public static class TestLateInlining {\n+          public static void main(String[] args) {\n+              for (int i = 0; i < 20_000; i++) {\n+                  test1();\n+                  test2();\n+              }\n+          }\n+\n+          private static void test1() {\n+              test3();\n+              testFailInline();\n+              testFailInline();\n+              test2();\n+          }\n+\n+          private static void test2() {\n+              inlined1();\n+              inlined2();\n+          }\n+\n+          private static void test3() {}\n+\n+          private static void testFailInline() {}\n+\n+          private static void inlined1() {}\n+\n+          private static void inlined2() {}\n+      }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:-TieredCompilation\", \"-XX:-UseOnStackReplacement\", \"-XX:-BackgroundCompilation\",\n+            \"-XX:+PrintCompilation\",\n+            \"-XX:CompileCommand=compileonly,compiler.inlining.LateInlinePrinting$TestLateInlining::test1\",\n+            \"-XX:CompileCommand=compileonly,compiler.inlining.LateInlinePrinting$TestLateInlining::test2\",\n+            \"-XX:CompileCommand=quiet\", \"-XX:+PrintInlining\", \"-XX:+AlwaysIncrementalInline\",\n+            \"-XX:CompileCommand=dontinline,compiler.inlining.LateInlinePrinting$TestLateInlining::testFailInline\",\n+            TestLateInlining.class.getName()\n+        );\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+\n+        analyzer.shouldContain(\"\"\"\n+compiler.inlining.LateInlinePrinting$TestLateInlining::test2 (7 bytes)\n+                            @ 0   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined1 (1 bytes)   inline (hot)   late inline succeeded\n+                            @ 3   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined2 (1 bytes)   inline (hot)   late inline succeeded\n+                            \"\"\");\n+        analyzer.shouldContain(\"\"\"\n+compiler.inlining.LateInlinePrinting$TestLateInlining::test1 (13 bytes)\n+                            @ 0   compiler.inlining.LateInlinePrinting$TestLateInlining::test3 (1 bytes)   inline (hot)   late inline succeeded\n+                            @ 3   compiler.inlining.LateInlinePrinting$TestLateInlining::testFailInline (1 bytes)   failed to inline: disallowed by CompileCommand\n+                            @ 6   compiler.inlining.LateInlinePrinting$TestLateInlining::testFailInline (1 bytes)   failed to inline: disallowed by CompileCommand\n+                            @ 9   compiler.inlining.LateInlinePrinting$TestLateInlining::test2 (7 bytes)   inline (hot)   late inline succeeded\n+                              @ 0   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined1 (1 bytes)   inline (hot)   late inline succeeded\n+                              @ 3   compiler.inlining.LateInlinePrinting$TestLateInlining::inlined2 (1 bytes)   inline (hot)   late inline succeeded\n+                              \"\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/LateInlinePrinting.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}