{"files":[{"patch":"@@ -1241,0 +1241,3 @@\n+ \/\/NOT-XOR\n+#define VNX_ZOPC    (unsigned long)(0xe7L << 40 | 0x6cL << 0)   \/\/ V1 := !(V2 | V3),  element size = 2**m\n+\n@@ -1292,0 +1295,7 @@\n+#define VFA_ZOPC   (unsigned long)(0xe7L << 40 | 0xE3L << 0)    \/\/ V1 := V2 + V3, element size = 2**m\n+#define VFS_ZOPC   (unsigned long)(0xe7L << 40 | 0xE2L << 0)    \/\/ V1 := V2 - V3, element size = 2**m\n+#define VFM_ZOPC   (unsigned long)(0xe7L << 40 | 0xE7L << 0)    \/\/ V1 := V2 * V3, element size = 2**m\n+#define VFD_ZOPC   (unsigned long)(0xe7L << 40 | 0xE5L << 0)    \/\/ V1 := V2 \/ V3, element size = 2**m\n+#define VFSQ_ZOPC  (unsigned long)(0xe7L << 40 | 0xCEL << 0)    \/\/ V1 := sqrt of V2, element size = 2**m\n+#define VFLR_ZOPC  (unsigned long)(0xe7L << 40 | 0xC5L << 0)    \/\/ V1 := sqrt of V2, element size = 2**m\n+\n@@ -2488,0 +2498,1 @@\n+  inline void z_vl(VectorRegister v1, const Address& a);\n@@ -2522,4 +2533,4 @@\n-  inline void z_vlvgb( VectorRegister v1, Register r3, int64_t d2, Register b2);\n-  inline void z_vlvgh( VectorRegister v1, Register r3, int64_t d2, Register b2);\n-  inline void z_vlvgf( VectorRegister v1, Register r3, int64_t d2, Register b2);\n-  inline void z_vlvgg( VectorRegister v1, Register r3, int64_t d2, Register b2);\n+  inline void z_vlvgb( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n+  inline void z_vlvgh( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n+  inline void z_vlvgf( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n+  inline void z_vlvgg( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n@@ -2617,0 +2628,1 @@\n+  inline void z_vst(VectorRegister v1, const Address& a);\n@@ -2673,0 +2685,3 @@\n+  inline void z_vmlb(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vmlhw(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vmlf(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n@@ -2737,0 +2752,3 @@\n+  \/\/NOT-XOR\n+  inline void z_vnx(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n@@ -2803,0 +2821,4 @@\n+  inline void z_vpopctb( VectorRegister v1, VectorRegister v2);\n+  inline void z_vpopcth( VectorRegister v1, VectorRegister v2);\n+  inline void z_vpopctf( VectorRegister v1, VectorRegister v2);\n+  inline void z_vpopctg( VectorRegister v1, VectorRegister v2);\n@@ -2893,0 +2915,28 @@\n+  \/\/ Add\n+  inline void z_vfa(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfasb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfadb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/SUB\n+  inline void z_vfs(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfssb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfsdb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/MUL\n+  inline void z_vfm(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfmsb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfmdb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/DIV\n+  inline void z_vfd(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfdsb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfddb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/square root\n+  inline void z_vfsq(VectorRegister v1, VectorRegister v2, int64_t m3);\n+  inline void z_vfsqsb(VectorRegister v1, VectorRegister v2);\n+  inline void z_vfsqdb(VectorRegister v1, VectorRegister v2);\n+\n+  \/\/vector fp load rounded\n+  inline void z_vflr( VectorRegister v1, VectorRegister v2, int64_t m3, int64_t m5);\n+  inline void z_vflrd( VectorRegister v1, VectorRegister v2, int64_t m5);\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":54,"deletions":4,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -781,0 +781,1 @@\n+inline void Assembler::z_vl(VectorRegister v1, const Address& a)  { z_vl(v1, a.disp(), a.indexOrR0(), a.baseOrR0()); }\n@@ -814,1 +815,1 @@\n-inline void Assembler::z_vlvg(   VectorRegister v1, Register r3, int64_t d2, Register b2, int64_t m4) {emit_48(VLVG_ZOPC  | vreg(v1,  8)     |  reg(r3, 12, 48) | rsmask_48(d2,     b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n+inline void Assembler::z_vlvg(   VectorRegister v1, Register r3, int64_t d2, Register b2, int64_t m4) {emit_48(VLVG_ZOPC  | vreg(v1,  8)     |  reg(r3, 12, 48) | rsmaskt_32(d2,     b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n@@ -910,0 +911,1 @@\n+inline void Assembler::z_vst(VectorRegister v1, const Address& a)  { z_vst(v1, a.disp(), a.indexOrR0(), a.baseOrR0()); }\n@@ -949,0 +951,2 @@\n+                                                                                                                                           \/\/\n+\n@@ -967,0 +971,3 @@\n+inline void Assembler::z_vmlb(   VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vml(v1, v2, v3, VRET_BYTE);}       \/\/ vector element type 'B'\n+inline void Assembler::z_vmlhw(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vml(v1, v2, v3, VRET_HW);}         \/\/ vector element type 'H'\n+inline void Assembler::z_vmlf(   VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vml(v1, v2, v3, VRET_FW);}         \/\/ vector element type 'F'\n@@ -1029,0 +1036,3 @@\n+\/\/NOT-XOR\n+inline void Assembler::z_vnx(    VectorRegister v1, VectorRegister v2, VectorRegister v3)             {emit_48(VNX_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16)); }\n+\n@@ -1095,0 +1105,4 @@\n+inline void Assembler::z_vpopctb( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_BYTE); }\n+inline void Assembler::z_vpopcth( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_HW); }\n+inline void Assembler::z_vpopctf( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_FW); }\n+inline void Assembler::z_vpopctg( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_DW); }\n@@ -1102,1 +1116,1 @@\n-inline void Assembler::z_verll(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4) {emit_48(VERLL_ZOPC | vreg(v1,  8) | vreg(v3, 12) | rsmask_48(d2, b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n+inline void Assembler::z_verll(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2, int64_t m4) {emit_48(VERLL_ZOPC | vreg(v1,  8) | vreg(v3, 12) | rsmask_48(d2, b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n@@ -1182,1 +1196,0 @@\n-\n@@ -1184,1 +1197,1 @@\n-\/\/ FLOAT INSTRUCTIONS\n+\/\/ Vector FLOAT INSTRUCTIONS\n@@ -1186,0 +1199,4 @@\n+\/\/Add\n+inline void Assembler::z_vfa(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFA_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfasb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfa(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfadb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfa(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n@@ -1187,0 +1204,1 @@\n+\/\/SUB\n@@ -1188,0 +1206,26 @@\n+inline void Assembler::z_vfs(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFS_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfssb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfs(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfsdb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfs(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n+                                                                                                                                             \/\/\n+\/\/MUL\n+inline void Assembler::z_vfm(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFM_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfmsb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfm(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfmdb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfm(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n+\n+\/\/DIV\n+inline void Assembler::z_vfd(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFD_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfdsb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfd(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfddb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfd(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n+\n+\/\/ square root\n+\/\/---------------\n+inline void Assembler::z_vfsq(  VectorRegister v1, VectorRegister v2, int64_t m3)                     {emit_48(VFSQ_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vesc_mask(m3, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfsqsb( VectorRegister v1, VectorRegister v2)                                {z_vfsq(v1, v2, VRET_FW); }\n+inline void Assembler::z_vfsqdb( VectorRegister v1, VectorRegister v2)                                {z_vfsq(v1, v2, VRET_DW); }\n+\n+inline void Assembler::z_vflr( VectorRegister v1, VectorRegister v2, int64_t m5, int64_t m3)          {emit_48(VFLR_ZOPC    | vreg(v1,  8) | vreg(v2, 12) | vesc_mask(m5, VRET_FW, 7, 24) | vesc_mask(m3, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vflrd( VectorRegister v1, VectorRegister v2, int64_t m5)                     {z_vflr(v1, v2, m5, VRET_DW); }\n+\n+\/\/-------------------------------\n+\/\/ FLOAT INSTRUCTIONS\n+\/\/-------------------------------\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-define_pd_global(bool, SuperWordLoopUnrollAnalysis,  false);\n+define_pd_global(bool, SuperWordLoopUnrollAnalysis,  true);\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,5 @@\n+  \/* special instructions *\/                                                  \\\n+  product(bool, SuperwordUseVX, false,                                        \\\n+          \"Use Z15 Vector instructions for superword optimization.\")          \\\n+  product(bool, UseSFPV, false,                                               \\\n+          \"Use SFPV Vector instructions for superword optimization.\")         \\\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  static int live_reg_frame_size(RegisterSet reg_set);\n+  static int live_reg_frame_size(RegisterSet reg_set, bool save_vectors = false);\n@@ -52,2 +52,2 @@\n-  static OopMap* save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc = Z_R14);\n-  static void restore_live_registers(MacroAssembler* masm, RegisterSet reg_set);\n+  static OopMap* save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc = Z_R14, bool save_vectors = false);\n+  static void restore_live_registers(MacroAssembler* masm, RegisterSet reg_set, bool save_vectors = false);\n@@ -68,0 +68,1 @@\n+    v_reg             = 3\n@@ -73,0 +74,1 @@\n+    v_reg_size        = 16\n","filename":"src\/hotspot\/cpu\/s390\/registerSaver_s390.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,5 +29,0 @@\n-\n-const int ConcreteRegisterImpl::max_gpr = Register::number_of_registers * 2;\n-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +\n-                                          FloatRegister::number_of_registers * 2;\n-\n@@ -57,1 +52,7 @@\n-  return is_valid() ? names[encoding()] : \"fnoreg\";\n+  return is_valid() ? names[encoding()] : \"vnoreg\";\n+}\n+\n+\/\/ Method to convert a FloatRegister to a VectorRegister (VectorRegister)\n+VectorRegister FloatRegister::to_vr() const {\n+  if (*this == fnoreg) { return vnoreg; }\n+  return as_VectorRegister(encoding());\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    max_slots_per_register  = 2,\n@@ -167,1 +168,1 @@\n-\n+class VectorRegister;\n@@ -173,0 +174,1 @@\n+    max_slots_per_register  = 2,\n@@ -195,0 +197,2 @@\n+  \/\/ convert to VR\n+  VectorRegister to_vr() const;\n@@ -288,0 +292,1 @@\n+    max_slots_per_register  = 4,\n@@ -382,1 +387,0 @@\n-\n@@ -386,5 +390,9 @@\n-    number_of_registers =\n-      (Register::number_of_registers +\n-      FloatRegister::number_of_registers)\n-      * 2 \/\/ register halves\n-      + 1 \/\/ condition code register\n+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n+    max_vr  = max_fpr + VectorRegister::number_of_registers * VectorRegister::max_slots_per_register,\n+\n+    \/\/ A big enough number for C2: all the registers plus flags\n+    \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n+    \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n+    \/\/ it's optoregs.\n+    number_of_registers = max_vr + 1 \/\/ gpr\/fpr\/vr + flags\n@@ -392,2 +400,0 @@\n-  static const int max_gpr;\n-  static const int max_fpr;\n@@ -396,1 +402,0 @@\n-\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -185,0 +185,159 @@\n+  reg_def Z_VR0   ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n+  reg_def Z_VR0_H ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n+  reg_def Z_VR0_J ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n+  reg_def Z_VR0_K ( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n+\n+  reg_def Z_VR1   ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n+  reg_def Z_VR1_H ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n+  reg_def Z_VR1_J ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n+  reg_def Z_VR1_K ( SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n+\n+  reg_def Z_VR2   ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n+  reg_def Z_VR2_H ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n+  reg_def Z_VR2_J ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n+  reg_def Z_VR2_K ( SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n+\n+  reg_def Z_VR3   ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n+  reg_def Z_VR3_H ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n+  reg_def Z_VR3_J ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n+  reg_def Z_VR3_K ( SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n+\n+  reg_def Z_VR4   ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n+  reg_def Z_VR4_H ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n+  reg_def Z_VR4_J ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n+  reg_def Z_VR4_K ( SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n+\n+  reg_def Z_VR5   ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n+  reg_def Z_VR5_H ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n+  reg_def Z_VR5_J ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n+  reg_def Z_VR5_K ( SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n+\n+  reg_def Z_VR6   ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n+  reg_def Z_VR6_H ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n+  reg_def Z_VR6_J ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n+  reg_def Z_VR6_K ( SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n+\n+  reg_def Z_VR7   ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n+  reg_def Z_VR7_H ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n+  reg_def Z_VR7_J ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n+  reg_def Z_VR7_K ( SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n+\n+  reg_def Z_VR8   ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n+  reg_def Z_VR8_H ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n+  reg_def Z_VR8_J ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n+  reg_def Z_VR8_K ( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n+\n+  reg_def Z_VR9   ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n+  reg_def Z_VR9_H ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n+  reg_def Z_VR9_J ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n+  reg_def Z_VR9_K ( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n+\n+  reg_def Z_VR10   ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n+  reg_def Z_VR10_H ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n+  reg_def Z_VR10_J ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n+  reg_def Z_VR10_K ( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n+\n+  reg_def Z_VR11   ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n+  reg_def Z_VR11_H ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n+  reg_def Z_VR11_J ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n+  reg_def Z_VR11_K ( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n+\n+  reg_def Z_VR12   ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n+  reg_def Z_VR12_H ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n+  reg_def Z_VR12_J ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n+  reg_def Z_VR12_K ( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n+\n+  reg_def Z_VR13   ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n+  reg_def Z_VR13_H ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n+  reg_def Z_VR13_J ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n+  reg_def Z_VR13_K ( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n+\n+  reg_def Z_VR14   ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n+  reg_def Z_VR14_H ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n+  reg_def Z_VR14_J ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n+  reg_def Z_VR14_K ( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n+\n+  reg_def Z_VR15   ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n+  reg_def Z_VR15_H ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n+  reg_def Z_VR15_J ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n+  reg_def Z_VR15_K ( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n+\n+  reg_def Z_VR16   ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()          );\n+  reg_def Z_VR16_H ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()->next()  );\n+  reg_def Z_VR16_J ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()->next(2) );\n+  reg_def Z_VR16_K ( SOC, SOC, Op_RegF, 16, Z_V16->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR17   ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()          );\n+  reg_def Z_VR17_H ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()->next()  );\n+  reg_def Z_VR17_J ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()->next(2) );\n+  reg_def Z_VR17_K ( SOC, SOC, Op_RegF, 17, Z_V17->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR18   ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()          );\n+  reg_def Z_VR18_H ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()->next()  );\n+  reg_def Z_VR18_J ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()->next(2) );\n+  reg_def Z_VR18_K ( SOC, SOC, Op_RegF, 18, Z_V18->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR19   ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()          );\n+  reg_def Z_VR19_H ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()->next()  );\n+  reg_def Z_VR19_J ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()->next(2) );\n+  reg_def Z_VR19_K ( SOC, SOC, Op_RegF, 19, Z_V19->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR20   ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()          );\n+  reg_def Z_VR20_H ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()->next()  );\n+  reg_def Z_VR20_J ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()->next(2) );\n+  reg_def Z_VR20_K ( SOC, SOC, Op_RegF, 20, Z_V20->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR21   ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()          );\n+  reg_def Z_VR21_H ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()->next()  );\n+  reg_def Z_VR21_J ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()->next(2) );\n+  reg_def Z_VR21_K ( SOC, SOC, Op_RegF, 21, Z_V21->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR22   ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()          );\n+  reg_def Z_VR22_H ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()->next()  );\n+  reg_def Z_VR22_J ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()->next(2) );\n+  reg_def Z_VR22_K ( SOC, SOC, Op_RegF, 22, Z_V22->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR23   ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()          );\n+  reg_def Z_VR23_H ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()->next()  );\n+  reg_def Z_VR23_J ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()->next(2) );\n+  reg_def Z_VR23_K ( SOC, SOC, Op_RegF, 23, Z_V23->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR24   ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()          );\n+  reg_def Z_VR24_H ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()->next()  );\n+  reg_def Z_VR24_J ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()->next(2) );\n+  reg_def Z_VR24_K ( SOC, SOC, Op_RegF, 24, Z_V24->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR25   ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()          );\n+  reg_def Z_VR25_H ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()->next()  );\n+  reg_def Z_VR25_J ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()->next(2) );\n+  reg_def Z_VR25_K ( SOC, SOC, Op_RegF, 25, Z_V25->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR26   ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()          );\n+  reg_def Z_VR26_H ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()->next()  );\n+  reg_def Z_VR26_J ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()->next(2) );\n+  reg_def Z_VR26_K ( SOC, SOC, Op_RegF, 26, Z_V26->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR27   ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()          );\n+  reg_def Z_VR27_H ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()->next()  );\n+  reg_def Z_VR27_J ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()->next(2) );\n+  reg_def Z_VR27_K ( SOC, SOC, Op_RegF, 27, Z_V27->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR28   ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()          );\n+  reg_def Z_VR28_H ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()->next()  );\n+  reg_def Z_VR28_J ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()->next(2) );\n+  reg_def Z_VR28_K ( SOC, SOC, Op_RegF, 28, Z_V28->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR29   ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()          );\n+  reg_def Z_VR29_H ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()->next()  );\n+  reg_def Z_VR29_J ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()->next(2) );\n+  reg_def Z_VR29_K ( SOC, SOC, Op_RegF, 29, Z_V29->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR30   ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()          );\n+  reg_def Z_VR30_H ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()->next()  );\n+  reg_def Z_VR30_J ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()->next(2) );\n+  reg_def Z_VR30_K ( SOC, SOC, Op_RegF, 30, Z_V30->as_VMReg()->next(3) );\n+\n+  reg_def Z_VR31   ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()          );\n+  reg_def Z_VR31_H ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()->next()  );\n+  reg_def Z_VR31_J ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()->next(2) );\n+  reg_def Z_VR31_K ( SOC, SOC, Op_RegF, 31, Z_V31->as_VMReg()->next(3) );\n@@ -198,0 +357,1 @@\n+\n@@ -271,0 +431,35 @@\n+ Z_VR0, Z_VR0_H, Z_VR0_J, Z_VR0_K,\n+ Z_VR1, Z_VR1_H, Z_VR1_J, Z_VR1_K,\n+ Z_VR2, Z_VR2_H, Z_VR2_J, Z_VR2_K,\n+ Z_VR3, Z_VR3_H, Z_VR3_J, Z_VR3_K,\n+ Z_VR4, Z_VR4_H, Z_VR4_J, Z_VR4_K,\n+ Z_VR5, Z_VR5_H, Z_VR5_J, Z_VR5_K,\n+ Z_VR6, Z_VR6_H, Z_VR6_J, Z_VR6_K,\n+ Z_VR7, Z_VR7_H, Z_VR7_J, Z_VR7_K,\n+ Z_VR8, Z_VR8_H, Z_VR8_J, Z_VR8_K,\n+ Z_VR9, Z_VR9_H, Z_VR9_J, Z_VR9_K,\n+ Z_VR10, Z_VR10_H, Z_VR10_J, Z_VR10_K,\n+ Z_VR11, Z_VR11_H, Z_VR11_J, Z_VR11_K,\n+ Z_VR12, Z_VR12_H, Z_VR12_J, Z_VR12_K,\n+ Z_VR13, Z_VR13_H, Z_VR13_J, Z_VR13_K,\n+ Z_VR14, Z_VR14_H, Z_VR14_J, Z_VR14_K,\n+ Z_VR15, Z_VR15_H, Z_VR15_J, Z_VR15_K,\n+ Z_VR16, Z_VR16_H, Z_VR16_J, Z_VR16_K,\n+ Z_VR17, Z_VR17_H, Z_VR17_J, Z_VR17_K,\n+ Z_VR18, Z_VR18_H, Z_VR18_J, Z_VR18_K,\n+ Z_VR19, Z_VR19_H, Z_VR19_J, Z_VR19_K,\n+ Z_VR20, Z_VR20_H, Z_VR20_J, Z_VR20_K,\n+ Z_VR21, Z_VR21_H, Z_VR21_J, Z_VR21_K,\n+ Z_VR22, Z_VR22_H, Z_VR22_J, Z_VR22_K,\n+ Z_VR23, Z_VR23_H, Z_VR23_J, Z_VR23_K,\n+ Z_VR24, Z_VR24_H, Z_VR24_J, Z_VR24_K,\n+ Z_VR25, Z_VR25_H, Z_VR25_J, Z_VR25_K,\n+ Z_VR26, Z_VR26_H, Z_VR26_J, Z_VR26_K,\n+ Z_VR27, Z_VR27_H, Z_VR27_J, Z_VR27_K,\n+ Z_VR28, Z_VR28_H, Z_VR28_J, Z_VR28_K,\n+ Z_VR29, Z_VR29_H, Z_VR29_J, Z_VR29_K,\n+ Z_VR30, Z_VR30_H, Z_VR30_J, Z_VR30_K,\n+ Z_VR31, Z_VR31_H, Z_VR31_J, Z_VR31_K,\n+);\n+\n+alloc_class chunk3(\n@@ -543,0 +738,19 @@\n+reg_class z_v_reg(\n+ Z_VR16, Z_VR16_H, Z_VR16_J, Z_VR16_K,\n+ Z_VR17, Z_VR17_H, Z_VR17_J, Z_VR17_K,\n+ Z_VR18, Z_VR18_H, Z_VR18_J, Z_VR18_K,\n+ Z_VR19, Z_VR19_H, Z_VR19_J, Z_VR19_K,\n+ Z_VR20, Z_VR20_H, Z_VR20_J, Z_VR20_K,\n+ Z_VR21, Z_VR21_H, Z_VR21_J, Z_VR21_K,\n+ Z_VR22, Z_VR22_H, Z_VR22_J, Z_VR22_K,\n+ Z_VR23, Z_VR23_H, Z_VR23_J, Z_VR23_K,\n+ Z_VR24, Z_VR24_H, Z_VR24_J, Z_VR24_K,\n+ Z_VR25, Z_VR25_H, Z_VR25_J, Z_VR25_K,\n+ Z_VR26, Z_VR26_H, Z_VR26_J, Z_VR26_K,\n+ Z_VR27, Z_VR27_H, Z_VR27_J, Z_VR27_K,\n+ Z_VR28, Z_VR28_H, Z_VR28_J, Z_VR28_K,\n+ Z_VR29, Z_VR29_H, Z_VR29_J, Z_VR29_K,\n+ Z_VR30, Z_VR30_H, Z_VR30_J, Z_VR30_K,\n+ Z_VR31, Z_VR31_H, Z_VR31_J, Z_VR31_K,\n+);\n+\n@@ -545,0 +759,2 @@\n+\n+\n@@ -965,2 +1181,2 @@\n-\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_stack.\n-enum RC { rc_bad, rc_int, rc_float, rc_stack };\n+\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_vector, rc_stack.\n+enum RC { rc_bad, rc_int, rc_float, rc_vector, rc_stack };\n@@ -987,0 +1203,5 @@\n+  \/\/ we have 32 vector register * 4 halves\n+  if (reg < 32+32+128) {\n+    return rc_vector;\n+  }\n+\n@@ -988,0 +1209,1 @@\n+  \/\/assert(OptoReg::is_stack(reg) || reg < 64+64+128, \"blow up if spilling flags\");\n@@ -1048,1 +1270,1 @@\n-\n+  int size = 0;\n@@ -1062,0 +1284,37 @@\n+  if (bottom_type()->isa_vect() != NULL && ideal_reg() == Op_VecX) {\n+        if (src_lo_rc == rc_stack && dst_lo_rc == rc_stack) {\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_mvc(Address(Z_SP, 0,  dst_offset), Address(Z_SP, 0, src_offset), 16);\n+        }\n+      size += 6;\n+      } else if (src_lo_rc == rc_vector && dst_lo_rc == rc_stack) {\n+      VectorRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]);\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_vst(Rsrc,\n+              Address(Z_SP, 0, dst_offset));\n+      }\n+      size += 6;\n+      } else if (src_lo_rc == rc_stack && dst_lo_rc == rc_vector) {\n+      VectorRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]);\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_vl(Rdst,\n+              Address(Z_SP, 0, src_offset));\n+      }\n+      size += 6;\n+      } else if (src_lo_rc == rc_vector && dst_lo_rc == rc_vector) {\n+      VectorRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]);\n+      VectorRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]);\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_vlr(Rdst, Rsrc);\n+      }\n+      size += 6;\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    return size;\n+  }\n+\n@@ -1302,1 +1561,1 @@\n-\n+#include \"opto\/convertnode.hpp\"\n@@ -1468,0 +1727,26 @@\n+    case Op_AddVB:\n+    case Op_AddVS:\n+    case Op_AddVI:\n+    case Op_AddVL:\n+    case Op_AddVD:\n+    case Op_SubVB:\n+    case Op_SubVS:\n+    case Op_SubVI:\n+    case Op_SubVL:\n+    case Op_SubVD:\n+    case Op_MulVB:\n+    case Op_MulVS:\n+    case Op_MulVI:\n+    case Op_MulVD:\n+    case Op_DivVD:\n+    case Op_SqrtVD:\n+    case Op_RoundDoubleModeV:\n+      return SuperwordUseVX;\n+    case Op_AddVF:\n+    case Op_SubVF:\n+    case Op_MulVF:\n+    case Op_DivVF:\n+    case Op_SqrtVF:\n+      return (SuperwordUseVX && UseSFPV);\n+    case Op_PopCountVI:\n+      return (SuperwordUseVX && UsePopCountInstruction);\n@@ -1517,2 +1802,7 @@\n-  assert(MaxVectorSize == 8, \"\");\n-  return 8;\n+  if (SuperwordUseVX) {\n+    assert(MaxVectorSize == 16, \"\");\n+    return 16;\n+  } else {\n+    assert(MaxVectorSize == 8, \"\");\n+    return 8;\n+  }\n@@ -1523,2 +1813,7 @@\n-  assert(MaxVectorSize == 8 && size == 8, \"\");\n-  return Op_RegL;\n+  if (SuperwordUseVX) {\n+    assert(MaxVectorSize == 16 && size == 16, \"\");\n+    return Op_VecX;\n+  } else {\n+    assert(MaxVectorSize == 8 && size == 8, \"\");\n+    return Op_RegL;\n+  }\n@@ -2431,0 +2726,8 @@\n+operand vecX() %{\n+  constraint(ALLOC_IN_RC(z_v_reg));\n+  match(VecX);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -7295,1 +7598,1 @@\n-  match(Set dst (ConvD2F (SqrtD (ConvF2D src))));\n+  match(Set dst (SqrtF src));\n@@ -7318,1 +7621,1 @@\n-  match(Set dst (ConvD2F (SqrtD (ConvF2D src))));\n+  match(Set dst (SqrtF src));\n@@ -10384,0 +10687,39 @@\n+instruct repl8S_reg_Ex(vecX dst, iRegI src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgh($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vreph($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+\n+  format %{ \"VONE      $dst, $src \\t\/\/ replicate8S\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl8S_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate8S\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10436,1 +10778,38 @@\n-\/\/\n+instruct repl4I_reg_Ex(vecX dst, iRegI src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgf($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vrepf($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl4I_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+\n+  format %{ \"VONE      $dst, $dst, $dst \\t\/\/ replicate4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n@@ -10500,0 +10879,133 @@\n+instruct repl4F_reg_Ex(vecX dst, regF src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+\n+  format %{ \"VREP  $dst, $src \\t\/\/ replicate4F\" %}\n+  size(6);\n+\n+  ins_encode %{\n+    __ z_vrepf($dst$$VectorRegister, $src$$FloatRegister->to_vr(), 0);\n+  %}\n+   ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl4F_immF0(vecX dst, immFp0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate4F\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2D_reg_Ex(vecX dst, regD src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+\n+  format %{ \"VREP  $dst, $src \\t\/\/ replicate2D\" %}\n+  size(6);\n+\n+  ins_encode %{\n+    __ z_vrepg($dst$$VectorRegister, $src$$FloatRegister->to_vr(), 0);\n+  %}\n+   ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2D_immD0(vecX dst, immDp0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate2D\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl16B_reg_Ex(vecX dst, iRegI src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgb($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vrepb($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl16B_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+\n+  format %{ \"VONE      $dst, $src \\t\/\/ replicate16B\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl16B_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate16B\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2L_reg_Ex(vecX dst, iRegL src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgg($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vrepg($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+\n+  format %{ \"VONE      $dst, $src \\t\/\/ replicate2L\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2L_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate16B\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\n@@ -10514,0 +11026,15 @@\n+\/\/ Store Packed Byte long register to memory\n+instruct storeV16(memoryRX mem, vecX src) %{\n+  predicate(n->as_StoreVector()->memory_size() == 16);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(MEMORY_REF_COST);\n+\n+  format %{ \"VST  $mem, $src \\t\/\/ store 16-byte Vector\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vst($src$$VectorRegister,\n+              Address(reg_to_register_object($mem$$base), $mem$$index$$Register, $mem$$disp));\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10525,0 +11052,15 @@\n+\/\/ Load Aligned Packed Byte\n+instruct loadV16(vecX dst, memoryRX mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 16);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(MEMORY_REF_COST);\n+\n+  format %{ \"VL  $dst, $mem \\t\/\/ load 16-byte Vector\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vl($dst$$VectorRegister,\n+              Address(reg_to_register_object($mem$$base), $mem$$index$$Register, $mem$$disp));\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10534,0 +11076,295 @@\n+instruct reinterpretX(vecX dst) %{\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"reinterpret $dst\" %}\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\/\/----------Vector Arithmetic Instructions--------------------------------------\n+\n+\/\/ Vector Addition Instructions\n+\n+instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVB src1 src2));\n+  predicate(n->as_Vector()->length() == 16);\n+  format %{ \"VAB  $dst,$src1,$src2\\t\/\/ add packed16B\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vab($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVS src1 src2));\n+  predicate(n->as_Vector()->length() == 8);\n+  format %{ \"VAH  $dst,$src1,$src2\\t\/\/ add packed8S\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vah($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVI src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VAF  $dst,$src1,$src2\\t\/\/ add packed4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vaf($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul16B_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVB src1 src2));\n+  predicate(n->as_Vector()->length() == 16);\n+  format %{ \"VMLB  $dst,$src1,$src2\\t\/\/ mul packed16B\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vmlb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul8S_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVS src1 src2));\n+  predicate(n->as_Vector()->length() == 8);\n+  format %{ \"VMLHW  $dst,$src1,$src2\\t\/\/ mul packed8S\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vmlhw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVI src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VMLF  $dst,$src1,$src2\\t\/\/ mul packed4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vmlf($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVL src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VAG  $dst,$src1,$src2\\t\/\/ add packed2L\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vag($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub416B_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVB src1 src2));\n+  predicate(n->as_Vector()->length() == 16);\n+  format %{ \"VSB  $dst,$src1,$src2\\t\/\/ sub packed16B\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVS src1 src2));\n+  predicate(n->as_Vector()->length() == 8);\n+  format %{ \"VSH  $dst,$src1,$src2\\t\/\/ sub packed8S\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsh($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVI src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VSF  $dst,$src1,$src2\\t\/\/ sub packed4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsf($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVL src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VSG  $dst,$src1,$src2\\t\/\/ sub packed2L\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsg($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFASB  $dst,$src1,$src2\\t\/\/ add packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfasb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFADB  $dst,$src1,$src2\\t\/\/ add packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfadb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFSSB  $dst,$src1,$src2\\t\/\/ sub packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfssb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFSDB  $dst,$src1,$src2\\t\/\/ sub packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfsdb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFMSB  $dst,$src1,$src2\\t\/\/ mul packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfmsb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFMDB  $dst,$src1,$src2\\t\/\/ mul packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfmdb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (DivVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFDSB  $dst,$src1,$src2\\t\/\/ div packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfdsb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (DivVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFDDB  $dst,$src1,$src2\\t\/\/ div packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfddb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Vector Square Root Instructions\n+\n+instruct vsqrt4F_reg(vecX dst, vecX src) %{\n+  match(Set dst (SqrtVF src));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFSQSB $dst,$src\\t\/\/ sqrt packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfsqsb($dst$$VectorRegister, $src$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsqrt2D_reg(vecX dst, vecX src) %{\n+  match(Set dst (SqrtVD src));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFSQDB $dst,$src\\t\/\/ sqrt packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfsqdb($dst$$VectorRegister, $src$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Vector Population Count Instructions\n+\n+instruct vpopcnt_reg(vecX dst, vecX src) %{\n+  match(Set dst (PopCountVI src));\n+  format %{ \"VPOPCT $dst,$src\\t\/\/ pop count packed\" %}\n+  size(6);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_BYTE:\n+        __ z_vpopctb($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      case T_SHORT:\n+        __ z_vpopcth($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      case T_INT:\n+        __ z_vpopctf($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ z_vpopctg($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Vector Round Instructions\n+instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"RoundDoubleModeV $src,$rmode\" %}\n+  size(6);\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ z_vflrd($dst$$VectorRegister, $src$$VectorRegister, 0);\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ z_vflrd($dst$$VectorRegister, $src$$VectorRegister, 7);\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ z_vflrd($dst$$VectorRegister, $src$$VectorRegister, 6);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":848,"deletions":11,"binary":false,"changes":859,"status":"modified"},{"patch":"@@ -83,0 +83,3 @@\n+#define RegisterSaver_LiveVReg(regname) \\\n+  { RegisterSaver::v_reg,      regname->encoding(), regname->as_VMReg() }\n+\n@@ -260,0 +263,20 @@\n+static const RegisterSaver::LiveRegType RegisterSaver_LiveVRegs[] = {\n+  \/\/ live vector registers (optional, only these ones are used by C2):\n+  RegisterSaver_LiveVReg( Z_V16 ),\n+  RegisterSaver_LiveVReg( Z_V17 ),\n+  RegisterSaver_LiveVReg( Z_V18 ),\n+  RegisterSaver_LiveVReg( Z_V19 ),\n+  RegisterSaver_LiveVReg( Z_V20 ),\n+  RegisterSaver_LiveVReg( Z_V21 ),\n+  RegisterSaver_LiveVReg( Z_V22 ),\n+  RegisterSaver_LiveVReg( Z_V23 ),\n+  RegisterSaver_LiveVReg( Z_V24 ),\n+  RegisterSaver_LiveVReg( Z_V25 ),\n+  RegisterSaver_LiveVReg( Z_V26 ),\n+  RegisterSaver_LiveVReg( Z_V27 ),\n+  RegisterSaver_LiveVReg( Z_V28 ),\n+  RegisterSaver_LiveVReg( Z_V29 ),\n+  RegisterSaver_LiveVReg( Z_V30 ),\n+  RegisterSaver_LiveVReg( Z_V31 )\n+};\n+\n@@ -274,2 +297,6 @@\n-int RegisterSaver::live_reg_frame_size(RegisterSet reg_set) {\n-  return live_reg_save_size(reg_set) + frame::z_abi_160_size;\n+int RegisterSaver::live_reg_frame_size(RegisterSet reg_set, bool save_vectors) {\n+  const int vregstosave_num = save_vectors ? (sizeof(RegisterSaver_LiveVRegs) \/\n+                                              sizeof(RegisterSaver::LiveRegType))\n+                                            : 0;\n+\n+  return live_reg_save_size(reg_set) + vregstosave_num * v_reg_size + frame::z_abi_160_size;\n@@ -280,1 +307,1 @@\n-OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc) {\n+OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc, bool save_vectors) {\n@@ -287,1 +314,5 @@\n-  const int frame_size_in_bytes  = live_reg_frame_size(reg_set);\n+    const int vregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVRegs) \/\n+                                                   sizeof(RegisterSaver::LiveRegType))\n+                                                  : 0;\n+  const int register_save_size   = live_reg_save_size(reg_set) + vregstosave_num * v_reg_size;\n+  const int frame_size_in_bytes  = frame::z_abi_160_size + register_save_size;\n@@ -289,1 +320,1 @@\n-  const int register_save_offset = frame_size_in_bytes - live_reg_save_size(reg_set);\n+  const int register_save_offset = frame_size_in_bytes - register_save_size;\n@@ -384,0 +415,19 @@\n+  for (int i = 0; i < vregstosave_num; i++) {\n+    int reg_num  = RegisterSaver_LiveVRegs[i].reg_num;\n+    \/\/int reg_type = RegisterSaver_LiveVRegs[i].reg_type;\n+\n+    __ z_vst(as_VectorRegister(reg_num), Address(Z_SP, offset));\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(offset>>2),\n+        RegisterSaver_LiveVRegs[i].vmreg);\n+    map->set_callee_saved(VMRegImpl::stack2reg((offset + half_reg_size ) >> 2),\n+        RegisterSaver_LiveVRegs[i].vmreg->next());\n+    map->set_callee_saved(VMRegImpl::stack2reg((offset + (half_reg_size * 2)) >> 2),\n+        RegisterSaver_LiveVRegs[i].vmreg->next(2));\n+    map->set_callee_saved(VMRegImpl::stack2reg((offset + (half_reg_size * 3)) >> 2),\n+        RegisterSaver_LiveVRegs[i].vmreg->next(3));\n+    offset += v_reg_size;\n+  }\n+\n+  assert(offset == frame_size_in_bytes, \"consistency check\");\n+\n@@ -435,0 +485,1 @@\n+  assert(offset == frame_size_in_bytes, \"consistency check\");\n@@ -440,1 +491,1 @@\n-void RegisterSaver::restore_live_registers(MacroAssembler* masm, RegisterSet reg_set) {\n+void RegisterSaver::restore_live_registers(MacroAssembler* masm, RegisterSet reg_set, bool save_vectors) {\n@@ -442,1 +493,8 @@\n-  const int register_save_offset = live_reg_frame_size(reg_set) - live_reg_save_size(reg_set);\n+  \/\/const int register_save_offset = live_reg_frame_size(reg_set) - live_reg_save_size(reg_set);\n+    \/\/ Calculate frame size.\n+  const int vregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVRegs) \/\n+                                                   sizeof(RegisterSaver::LiveRegType))\n+                                                  : 0;\n+  const int register_save_size   = live_reg_save_size(reg_set) + vregstosave_num * v_reg_size;\n+  const int frame_size_in_bytes  = frame::z_abi_160_size + register_save_size;\n+  const int register_save_offset = frame_size_in_bytes - register_save_size;\n@@ -519,0 +577,10 @@\n+  for (int i = 0; i < vregstosave_num; i++) {\n+    int reg_num  = RegisterSaver_LiveVRegs[i].reg_num;\n+    \/\/int reg_type = RegisterSaver_LiveVRegs[i].reg_type;\n+\n+    __ z_vl(as_VectorRegister(reg_num), Address(Z_SP, offset));\n+\n+    offset += v_reg_size;\n+  }\n+\n+  assert(offset == frame_size_in_bytes, \"consistency check\");\n@@ -529,2 +597,0 @@\n-  int i;\n-  int offset;\n@@ -536,1 +602,1 @@\n-  offset = register_save_offset;\n+  int offset = register_save_offset;\n@@ -559,0 +625,1 @@\n+  assert(offset == live_reg_frame_size(all_registers), \"consistency check\");\n@@ -982,2 +1049,2 @@\n-  \/\/ Note, MaxVectorSize == 8 on this platform.\n-  assert(size <= 8, \"%d bytes vectors are not supported\", size);\n+  \/\/ Note, MaxVectorSize == 8\/16 on this platform.\n+  assert(size <= (SuperwordUseVX ? 16 : 8), \"%d bytes vectors are not supported\", size);\n@@ -2851,0 +2918,1 @@\n+  bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n@@ -2852,1 +2920,1 @@\n-  map = RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers);\n+  map = RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers, Z_R14, save_vectors);\n@@ -2884,1 +2952,1 @@\n-  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);\n+  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers, save_vectors);\n@@ -2897,1 +2965,1 @@\n-    const int offset_of_return_pc = _z_common_abi(return_pc) + RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers);\n+    const int offset_of_return_pc = _z_common_abi(return_pc) + RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers, save_vectors);\n@@ -2910,1 +2978,1 @@\n-  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);\n+  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers, save_vectors);\n@@ -2918,1 +2986,1 @@\n-  return SafepointBlob::create(&buffer, oop_maps, RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers)\/wordSize);\n+  return SafepointBlob::create(&buffer, oop_maps, RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers, save_vectors)\/wordSize);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":85,"deletions":17,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -100,1 +100,20 @@\n-  MaxVectorSize = 8;\n+  int model_ix = get_model_index();\n+  if ( model_ix >= 7 ) {\n+    if (FLAG_IS_DEFAULT(SuperwordUseVX)) {\n+      FLAG_SET_ERGO(SuperwordUseVX, true);\n+    }\n+    if (model_ix > 7 && FLAG_IS_DEFAULT(UseSFPV)) {\n+      FLAG_SET_ERGO(UseSFPV, true);\n+    } else {\n+      if (model_ix == 7 && UseSFPV) {\n+        warning(\"UseSFPV specified, but needs at least Z14.\");\n+        FLAG_SET_DEFAULT(UseSFPV, false);\n+      }\n+    }\n+  } else {\n+    if (SuperwordUseVX) {\n+      warning(\"SuperwordUseVX specified, but needs at least Z13.\");\n+      FLAG_SET_DEFAULT(SuperwordUseVX, false);\n+    }\n+  }\n+  MaxVectorSize = SuperwordUseVX ? 16 : 8;\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,0 +46,10 @@\n+\n+  VectorRegister vreg = ::as_VectorRegister(0);\n+  for (; i < ConcreteRegisterImpl::max_vr;) {\n+    regName[i++] = vreg->name();\n+    regName[i++] = vreg->name();\n+    regName[i++] = vreg->name();\n+    regName[i++] = vreg->name();\n+    vreg = vreg->successor();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+inline bool is_VectorRegister() {\n+  return value() >= ConcreteRegisterImpl::max_fpr &&\n+         value() < ConcreteRegisterImpl::max_vr;\n+}\n+\n@@ -40,1 +45,1 @@\n-  return ::as_Register(value() >> 1);\n+  return ::as_Register(value() \/ Register::max_slots_per_register);\n@@ -45,1 +50,9 @@\n-  return ::as_FloatRegister((value() - ConcreteRegisterImpl::max_gpr) >> 1);\n+  return ::as_FloatRegister((value() - ConcreteRegisterImpl::max_gpr)\n+          \/ FloatRegister::max_slots_per_register);\n+}\n+\n+inline VectorRegister as_VectorRegister() {\n+  assert(is_VectorRegister()\n+         && (value() % VectorRegister::max_slots_per_register == 0), \"must be\");\n+  return ::as_VectorRegister((value() - ConcreteRegisterImpl::max_fpr)\n+          \/ VectorRegister::max_slots_per_register);\n@@ -50,1 +63,9 @@\n-  return is_even(value());\n+  if (is_FloatRegister()) {\n+    int base = value() - ConcreteRegisterImpl::max_gpr;\n+    return (base % FloatRegister::max_slots_per_register) == 0;\n+  } else if (is_VectorRegister()) {\n+    int base = value() - ConcreteRegisterImpl::max_fpr;\n+    return (base % VectorRegister::max_slots_per_register) == 0;\n+  } else {\n+    return is_even(value());\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.hpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-  return VMRegImpl::as_VMReg(encoding() << 1);\n+  return VMRegImpl::as_VMReg(encoding() * Register::max_slots_per_register);\n@@ -34,1 +34,7 @@\n-  return VMRegImpl::as_VMReg((encoding() << 1) + ConcreteRegisterImpl::max_gpr);\n+  return VMRegImpl::as_VMReg((encoding() * FloatRegister::max_slots_per_register) +\n+                             ConcreteRegisterImpl::max_gpr);\n+}\n+\n+inline VMReg VectorRegister::as_VMReg() const {\n+  return VMRegImpl::as_VMReg((encoding() * VectorRegister::max_slots_per_register) +\n+                             ConcreteRegisterImpl::max_fpr);\n@@ -38,1 +44,1 @@\n-  return VMRegImpl::as_VMReg((encoding() << 1) + ConcreteRegisterImpl::max_fpr);\n+  return VMRegImpl::as_VMReg(encoding() + ConcreteRegisterImpl::max_vr);\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.inline.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2366,0 +2366,3 @@\n+#if defined(S390)\n+    if (strcmp(rep_var,\"$VectorRegister\") == 0)   return \"as_VectorRegister\";\n+#endif\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,0 +138,8 @@\n+#if defined(S390)\n+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {\n+    return ::as_VectorRegister(reg(ra_, node));\n+  }\n+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {\n+    return ::as_VectorRegister(reg(ra_, node, idx));\n+ }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  { Bad,             T_ILLEGAL,    \"vectorx:\",      false, 0,                    relocInfo::none          },  \/\/ VectorX\n+  { Bad,             T_ILLEGAL,    \"vectorx:\",      false, Op_VecX,              relocInfo::none          },  \/\/ VectorX\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}