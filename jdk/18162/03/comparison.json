{"files":[{"patch":"@@ -1241,0 +1241,3 @@\n+ \/\/NOT-XOR\n+#define VNX_ZOPC    (unsigned long)(0xe7L << 40 | 0x6cL << 0)   \/\/ V1 := !(V2 | V3),  element size = 2**m\n+\n@@ -1292,0 +1295,7 @@\n+#define VFA_ZOPC   (unsigned long)(0xe7L << 40 | 0xE3L << 0)    \/\/ V1 := V2 + V3, element size = 2**m\n+#define VFS_ZOPC   (unsigned long)(0xe7L << 40 | 0xE2L << 0)    \/\/ V1 := V2 - V3, element size = 2**m\n+#define VFM_ZOPC   (unsigned long)(0xe7L << 40 | 0xE7L << 0)    \/\/ V1 := V2 * V3, element size = 2**m\n+#define VFD_ZOPC   (unsigned long)(0xe7L << 40 | 0xE5L << 0)    \/\/ V1 := V2 \/ V3, element size = 2**m\n+#define VFSQ_ZOPC  (unsigned long)(0xe7L << 40 | 0xCEL << 0)    \/\/ V1 := sqrt of V2, element size = 2**m\n+#define VFLR_ZOPC  (unsigned long)(0xe7L << 40 | 0xC5L << 0)    \/\/ V1 := sqrt of V2, element size = 2**m\n+\n@@ -2488,0 +2498,1 @@\n+  inline void z_vl(VectorRegister v1, const Address& a);\n@@ -2522,4 +2533,4 @@\n-  inline void z_vlvgb( VectorRegister v1, Register r3, int64_t d2, Register b2);\n-  inline void z_vlvgh( VectorRegister v1, Register r3, int64_t d2, Register b2);\n-  inline void z_vlvgf( VectorRegister v1, Register r3, int64_t d2, Register b2);\n-  inline void z_vlvgg( VectorRegister v1, Register r3, int64_t d2, Register b2);\n+  inline void z_vlvgb( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n+  inline void z_vlvgh( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n+  inline void z_vlvgf( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n+  inline void z_vlvgg( VectorRegister v1, Register r3, int64_t d2, Register b2=Z_R0);\n@@ -2617,0 +2628,1 @@\n+  inline void z_vst(VectorRegister v1, const Address& a);\n@@ -2673,0 +2685,3 @@\n+  inline void z_vmlb(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vmlhw(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vmlf(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n@@ -2737,0 +2752,3 @@\n+  \/\/NOT-XOR\n+  inline void z_vnx(    VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n@@ -2803,0 +2821,4 @@\n+  inline void z_vpopctb( VectorRegister v1, VectorRegister v2);\n+  inline void z_vpopcth( VectorRegister v1, VectorRegister v2);\n+  inline void z_vpopctf( VectorRegister v1, VectorRegister v2);\n+  inline void z_vpopctg( VectorRegister v1, VectorRegister v2);\n@@ -2891,1 +2913,32 @@\n-  \/\/ Floatingpoint instructions\n+  \/\/ Vector Floatingpoint instructions\n+  \/\/ ==========================\n+  \/\/ Add\n+  inline void z_vfa(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfasb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfadb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/SUB\n+  inline void z_vfs(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfssb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfsdb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/MUL\n+  inline void z_vfm(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfmsb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfmdb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/DIV\n+  inline void z_vfd(VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);\n+  inline void z_vfdsb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+  inline void z_vfddb(VectorRegister v1, VectorRegister v2, VectorRegister v3);\n+\n+  \/\/square root\n+  inline void z_vfsq(VectorRegister v1, VectorRegister v2, int64_t m3);\n+  inline void z_vfsqsb(VectorRegister v1, VectorRegister v2);\n+  inline void z_vfsqdb(VectorRegister v1, VectorRegister v2);\n+\n+  \/\/vector fp load rounded\n+  inline void z_vflr( VectorRegister v1, VectorRegister v2, int64_t m3, int64_t m5);\n+  inline void z_vflrd( VectorRegister v1, VectorRegister v2, int64_t m5);\n+\n+  \/\/ Vector Floatingpoint instructions\n@@ -2893,1 +2946,0 @@\n-\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":58,"deletions":6,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -781,0 +781,1 @@\n+inline void Assembler::z_vl(VectorRegister v1, const Address& a)  { z_vl(v1, a.disp(), a.indexOrR0(), a.baseOrR0()); }\n@@ -814,1 +815,1 @@\n-inline void Assembler::z_vlvg(   VectorRegister v1, Register r3, int64_t d2, Register b2, int64_t m4) {emit_48(VLVG_ZOPC  | vreg(v1,  8)     |  reg(r3, 12, 48) | rsmask_48(d2,     b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n+inline void Assembler::z_vlvg(   VectorRegister v1, Register r3, int64_t d2, Register b2, int64_t m4) {emit_48(VLVG_ZOPC  | vreg(v1,  8)     |  reg(r3, 12, 48) | rsmaskt_32(d2,     b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n@@ -910,0 +911,1 @@\n+inline void Assembler::z_vst(VectorRegister v1, const Address& a)  { z_vst(v1, a.disp(), a.indexOrR0(), a.baseOrR0()); }\n@@ -967,0 +969,3 @@\n+inline void Assembler::z_vmlb(   VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vml(v1, v2, v3, VRET_BYTE);}       \/\/ vector element type 'B'\n+inline void Assembler::z_vmlhw(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vml(v1, v2, v3, VRET_HW);}         \/\/ vector element type 'H'\n+inline void Assembler::z_vmlf(   VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vml(v1, v2, v3, VRET_FW);}         \/\/ vector element type 'F'\n@@ -1029,0 +1034,3 @@\n+\/\/NOT-XOR\n+inline void Assembler::z_vnx(    VectorRegister v1, VectorRegister v2, VectorRegister v3)             {emit_48(VNX_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16)); }\n+\n@@ -1095,0 +1103,4 @@\n+inline void Assembler::z_vpopctb( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_BYTE); }\n+inline void Assembler::z_vpopcth( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_HW); }\n+inline void Assembler::z_vpopctf( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_FW); }\n+inline void Assembler::z_vpopctg( VectorRegister v1, VectorRegister v2)                                {z_vpopct(v1, v2, VRET_DW); }\n@@ -1102,1 +1114,1 @@\n-inline void Assembler::z_verll(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4) {emit_48(VERLL_ZOPC | vreg(v1,  8) | vreg(v3, 12) | rsmask_48(d2, b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n+inline void Assembler::z_verll(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2, int64_t m4) {emit_48(VERLL_ZOPC | vreg(v1,  8) | vreg(v3, 12) | rsmask_48(d2, b2) | vesc_mask(m4, VRET_BYTE, VRET_DW, 32)); }\n@@ -1182,1 +1194,0 @@\n-\n@@ -1184,1 +1195,1 @@\n-\/\/ FLOAT INSTRUCTIONS\n+\/\/ Vector FLOAT INSTRUCTIONS\n@@ -1186,0 +1197,4 @@\n+\/\/Add\n+inline void Assembler::z_vfa(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFA_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfasb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfa(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfadb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfa(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n@@ -1187,0 +1202,1 @@\n+\/\/SUB\n@@ -1188,0 +1204,26 @@\n+inline void Assembler::z_vfs(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFS_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfssb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfs(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfsdb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfs(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n+                                                                                                                                             \/\/\n+\/\/MUL\n+inline void Assembler::z_vfm(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFM_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfmsb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfm(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfmdb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfm(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n+\n+\/\/DIV\n+inline void Assembler::z_vfd(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4)   {emit_48(VFD_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vreg(v3, 16) | vesc_mask(m4, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfdsb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfd(v1, v2, v3, VRET_FW); }         \/\/ vector element type 'F'\n+inline void Assembler::z_vfddb(  VectorRegister v1, VectorRegister v2, VectorRegister v3)             {z_vfd(v1, v2, v3, VRET_DW); }         \/\/ vector element type 'G'\n+\n+\/\/ square root\n+\/\/---------------\n+inline void Assembler::z_vfsq(  VectorRegister v1, VectorRegister v2, int64_t m3)                     {emit_48(VFSQ_ZOPC   | vreg(v1,  8) | vreg(v2, 12) | vesc_mask(m3, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vfsqsb( VectorRegister v1, VectorRegister v2)                                {z_vfsq(v1, v2, VRET_FW); }\n+inline void Assembler::z_vfsqdb( VectorRegister v1, VectorRegister v2)                                {z_vfsq(v1, v2, VRET_DW); }\n+\n+inline void Assembler::z_vflr( VectorRegister v1, VectorRegister v2, int64_t m5, int64_t m3)          {emit_48(VFLR_ZOPC    | vreg(v1,  8) | vreg(v2, 12) | vesc_mask(m5, VRET_FW, 7, 24) | vesc_mask(m3, VRET_FW, VRET_QW, 32)); }\n+inline void Assembler::z_vflrd( VectorRegister v1, VectorRegister v2, int64_t m5)                     {z_vflr(v1, v2, m5, VRET_DW); }\n+\n+\/\/-------------------------------\n+\/\/ FLOAT INSTRUCTIONS\n+\/\/-------------------------------\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-define_pd_global(bool, SuperWordLoopUnrollAnalysis,  false);\n+define_pd_global(bool, SuperWordLoopUnrollAnalysis,  true);\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,5 @@\n+  \/* special instructions *\/                                                  \\\n+  product(bool, SuperwordUseVX, false,                                        \\\n+          \"Use Z15 Vector instructions for superword optimization.\")          \\\n+  product(bool, UseSFPV, false, DIAGNOSTIC,                                               \\\n+          \"Use SFPV Vector instructions for superword optimization.\")         \\\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  static int live_reg_frame_size(RegisterSet reg_set);\n+  static int live_reg_frame_size(RegisterSet reg_set, bool save_vectors = false);\n@@ -52,2 +52,2 @@\n-  static OopMap* save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc = Z_R14);\n-  static void restore_live_registers(MacroAssembler* masm, RegisterSet reg_set);\n+  static OopMap* save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc = Z_R14, bool save_vectors = false);\n+  static void restore_live_registers(MacroAssembler* masm, RegisterSet reg_set, bool save_vectors = false);\n@@ -68,0 +68,1 @@\n+    v_reg             = 3\n@@ -73,0 +74,1 @@\n+    v_reg_size        = 16\n","filename":"src\/hotspot\/cpu\/s390\/registerSaver_s390.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,5 +29,0 @@\n-\n-const int ConcreteRegisterImpl::max_gpr = Register::number_of_registers * 2;\n-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::max_gpr +\n-                                          FloatRegister::number_of_registers * 2;\n-\n@@ -57,1 +52,7 @@\n-  return is_valid() ? names[encoding()] : \"fnoreg\";\n+  return is_valid() ? names[encoding()] : \"vnoreg\";\n+}\n+\n+\/\/ Method to convert a FloatRegister to a VectorRegister (VectorRegister)\n+VectorRegister FloatRegister::to_vr() const {\n+  if (*this == fnoreg) { return vnoreg; }\n+  return as_VectorRegister(encoding());\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-\n+class VectorRegister;\n@@ -195,0 +195,2 @@\n+  \/\/ convert to VR\n+  VectorRegister to_vr() const;\n@@ -382,1 +384,0 @@\n-\n@@ -386,5 +387,9 @@\n-    number_of_registers =\n-      (Register::number_of_registers +\n-      FloatRegister::number_of_registers)\n-      * 2 \/\/ register halves\n-      + 1 \/\/ condition code register\n+    max_gpr = Register::number_of_registers * 2,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * 2,\n+    max_vr  = max_fpr + VectorRegister::number_of_registers,\n+\n+    \/\/ A big enough number for C2: all the registers plus flags\n+    \/\/ This number must be large enough to cover REG_COUNT (defined by c2) registers.\n+    \/\/ There is no requirement that any ordering here matches any ordering c2 gives\n+    \/\/ it's optoregs.\n+    number_of_registers = max_vr + 1 \/\/ gpr\/fpr\/vr + flags\n@@ -392,2 +397,0 @@\n-  static const int max_gpr;\n-  static const int max_fpr;\n@@ -396,1 +399,0 @@\n-\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.hpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -100,2 +100,3 @@\n-  \/\/ Integer\/Long Registers\n-  \/\/ ----------------------------\n+\/\/ ----------------------------\n+\/\/ Integer\/Long Registers\n+\/\/ ----------------------------\n@@ -139,1 +140,3 @@\n-  \/\/ Float\/Double Registers\n+\/\/ ----------------------------\n+\/\/ Float\/Double Registers\n+\/\/ ----------------------------\n@@ -185,0 +188,36 @@\n+\/\/ ----------------------------\n+\/\/ Vector Registers\n+\/\/ ----------------------------\n+  \/\/ 1st 16 VRs are aliases for the FPRs which are already defined above.\n+  reg_def Z_VR0   ( SOC, SOC, Op_VecX, 0, VMRegImpl::Bad());\n+  reg_def Z_VR1   ( SOC, SOC, Op_VecX, 1, VMRegImpl::Bad());\n+  reg_def Z_VR2   ( SOC, SOC, Op_VecX, 2, VMRegImpl::Bad());\n+  reg_def Z_VR3   ( SOC, SOC, Op_VecX, 3, VMRegImpl::Bad());\n+  reg_def Z_VR4   ( SOC, SOC, Op_VecX, 4, VMRegImpl::Bad());\n+  reg_def Z_VR5   ( SOC, SOC, Op_VecX, 5, VMRegImpl::Bad());\n+  reg_def Z_VR6   ( SOC, SOC, Op_VecX, 6, VMRegImpl::Bad());\n+  reg_def Z_VR7   ( SOC, SOC, Op_VecX, 7, VMRegImpl::Bad());\n+  reg_def Z_VR8   ( SOC, SOC, Op_VecX, 8, VMRegImpl::Bad());\n+  reg_def Z_VR9   ( SOC, SOC, Op_VecX, 9, VMRegImpl::Bad());\n+  reg_def Z_VR10   ( SOC, SOC, Op_VecX, 10, VMRegImpl::Bad());\n+  reg_def Z_VR11   ( SOC, SOC, Op_VecX, 11, VMRegImpl::Bad());\n+  reg_def Z_VR12   ( SOC, SOC, Op_VecX, 12, VMRegImpl::Bad());\n+  reg_def Z_VR13   ( SOC, SOC, Op_VecX, 13, VMRegImpl::Bad());\n+  reg_def Z_VR14   ( SOC, SOC, Op_VecX, 14, VMRegImpl::Bad());\n+  reg_def Z_VR15   ( SOC, SOC, Op_VecX, 15, VMRegImpl::Bad());\n+  reg_def Z_VR16   ( SOC, SOC, Op_VecX, 16, Z_V16->as_VMReg());\n+  reg_def Z_VR17   ( SOC, SOC, Op_VecX, 17, Z_V17->as_VMReg());\n+  reg_def Z_VR18   ( SOC, SOC, Op_VecX, 18, Z_V18->as_VMReg());\n+  reg_def Z_VR19   ( SOC, SOC, Op_VecX, 19, Z_V19->as_VMReg());\n+  reg_def Z_VR20   ( SOC, SOC, Op_VecX, 20, Z_V20->as_VMReg());\n+  reg_def Z_VR21   ( SOC, SOC, Op_VecX, 21, Z_V21->as_VMReg());\n+  reg_def Z_VR22   ( SOC, SOC, Op_VecX, 22, Z_V22->as_VMReg());\n+  reg_def Z_VR23   ( SOC, SOC, Op_VecX, 23, Z_V23->as_VMReg());\n+  reg_def Z_VR24   ( SOC, SOC, Op_VecX, 24, Z_V24->as_VMReg());\n+  reg_def Z_VR25   ( SOC, SOC, Op_VecX, 25, Z_V25->as_VMReg());\n+  reg_def Z_VR26   ( SOC, SOC, Op_VecX, 26, Z_V26->as_VMReg());\n+  reg_def Z_VR27   ( SOC, SOC, Op_VecX, 27, Z_V27->as_VMReg());\n+  reg_def Z_VR28   ( SOC, SOC, Op_VecX, 28, Z_V28->as_VMReg());\n+  reg_def Z_VR29   ( SOC, SOC, Op_VecX, 29, Z_V29->as_VMReg());\n+  reg_def Z_VR30   ( SOC, SOC, Op_VecX, 30, Z_V30->as_VMReg());\n+  reg_def Z_VR31   ( SOC, SOC, Op_VecX, 31, Z_V31->as_VMReg());\n@@ -197,1 +236,0 @@\n-\n@@ -271,0 +309,35 @@\n+  Z_VR0,\n+  Z_VR1,\n+  Z_VR2,\n+  Z_VR3,\n+  Z_VR4,\n+  Z_VR5,\n+  Z_VR6,\n+  Z_VR7,\n+  Z_VR8,\n+  Z_VR9,\n+  Z_VR10,\n+  Z_VR11,\n+  Z_VR12,\n+  Z_VR13,\n+  Z_VR14,\n+  Z_VR15,\n+  Z_VR16,\n+  Z_VR17,\n+  Z_VR18,\n+  Z_VR19,\n+  Z_VR20,\n+  Z_VR21,\n+  Z_VR22,\n+  Z_VR23,\n+  Z_VR24,\n+  Z_VR25,\n+  Z_VR26,\n+  Z_VR27,\n+  Z_VR28,\n+  Z_VR29,\n+  Z_VR30,\n+  Z_VR31\n+);\n+\n+alloc_class chunk3(\n@@ -543,0 +616,21 @@\n+reg_class z_v_reg(\n+  \/\/ Attention: Only these ones are saved & restored at safepoint by RegisterSaver.\n+  \/\/1st 16 VRs overlaps with 1st 16 FPRs.\n+  Z_VR16,\n+  Z_VR17,\n+  Z_VR18,\n+  Z_VR19,\n+  Z_VR20,\n+  Z_VR21,\n+  Z_VR22,\n+  Z_VR23,\n+  Z_VR24,\n+  Z_VR25,\n+  Z_VR26,\n+  Z_VR27,\n+  Z_VR28,\n+  Z_VR29,\n+  Z_VR30,\n+  Z_VR31\n+);\n+\n@@ -965,2 +1059,2 @@\n-\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_stack.\n-enum RC { rc_bad, rc_int, rc_float, rc_stack };\n+\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_vector, rc_stack.\n+enum RC { rc_bad, rc_int, rc_float, rc_vector, rc_stack };\n@@ -987,0 +1081,5 @@\n+  \/\/ we have 32 vector register * 4 halves\n+  if (reg < 32+32+32) {\n+    return rc_vector;\n+  }\n+\n@@ -988,1 +1087,1 @@\n-  assert(reg >= OptoReg::stack0(), \"blow up if spilling flags\");\n+  assert(OptoReg::is_stack(reg) || reg < 32+32+32, \"blow up if spilling flags\");\n@@ -1048,1 +1147,1 @@\n-\n+  int size = 0;\n@@ -1062,0 +1161,35 @@\n+  if (bottom_type()->isa_vect() != nullptr && ideal_reg() == Op_VecX) {\n+    if (src_lo_rc == rc_stack && dst_lo_rc == rc_stack) {\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_mvc(Address(Z_SP, 0,  dst_offset), Address(Z_SP, 0, src_offset), 16);\n+      }\n+      size += 6;\n+    } else if (src_lo_rc == rc_vector && dst_lo_rc == rc_stack) {\n+      VectorRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]);\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_vst(Rsrc, Address(Z_SP, 0, dst_offset));\n+      }\n+      size += 6;\n+    } else if (src_lo_rc == rc_stack && dst_lo_rc == rc_vector) {\n+      VectorRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]);\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_vl(Rdst, Address(Z_SP, 0, src_offset));\n+      }\n+      size += 6;\n+    } else if (src_lo_rc == rc_vector && dst_lo_rc == rc_vector) {\n+      VectorRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]);\n+      VectorRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]);\n+      if (cbuf) {\n+        C2_MacroAssembler _masm(cbuf);\n+        __ z_vlr(Rdst, Rsrc);\n+      }\n+      size += 6;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+    return size;\n+  }\n+\n@@ -1302,1 +1436,1 @@\n-\n+#include \"opto\/convertnode.hpp\"\n@@ -1468,0 +1602,26 @@\n+    case Op_AddVB:\n+    case Op_AddVS:\n+    case Op_AddVI:\n+    case Op_AddVL:\n+    case Op_AddVD:\n+    case Op_SubVB:\n+    case Op_SubVS:\n+    case Op_SubVI:\n+    case Op_SubVL:\n+    case Op_SubVD:\n+    case Op_MulVB:\n+    case Op_MulVS:\n+    case Op_MulVI:\n+    case Op_MulVD:\n+    case Op_DivVD:\n+    case Op_SqrtVD:\n+    case Op_RoundDoubleModeV:\n+      return SuperwordUseVX;\n+    case Op_AddVF:\n+    case Op_SubVF:\n+    case Op_MulVF:\n+    case Op_DivVF:\n+    case Op_SqrtVF:\n+      return (SuperwordUseVX && UseSFPV);\n+    case Op_PopCountVI:\n+      return (SuperwordUseVX && UsePopCountInstruction);\n@@ -1517,2 +1677,7 @@\n-  assert(MaxVectorSize == 8, \"\");\n-  return 8;\n+  if (SuperwordUseVX) {\n+    assert(MaxVectorSize == 16, \"\");\n+    return 16;\n+  } else {\n+    assert(MaxVectorSize == 8, \"\");\n+    return 8;\n+  }\n@@ -1523,2 +1688,7 @@\n-  assert(MaxVectorSize == 8 && size == 8, \"\");\n-  return Op_RegL;\n+  if (SuperwordUseVX) {\n+    assert(MaxVectorSize == 16 && size == 16, \"\");\n+    return Op_VecX;\n+  } else {\n+    assert(MaxVectorSize == 8 && size == 8, \"\");\n+    return Op_RegL;\n+  }\n@@ -2431,0 +2601,8 @@\n+operand vecX() %{\n+  constraint(ALLOC_IN_RC(z_v_reg));\n+  match(VecX);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -7295,1 +7473,1 @@\n-  match(Set dst (ConvD2F (SqrtD (ConvF2D src))));\n+  match(Set dst (SqrtF src));\n@@ -7318,1 +7496,1 @@\n-  match(Set dst (ConvD2F (SqrtD (ConvF2D src))));\n+  match(Set dst (SqrtF src));\n@@ -10384,0 +10562,39 @@\n+instruct repl8S_reg_Ex(vecX dst, iRegI src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgh($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vreph($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+\n+  format %{ \"VONE      $dst, $src \\t\/\/ replicate8S\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl8S_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 8 &&\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate8S\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10436,1 +10653,38 @@\n-\/\/\n+instruct repl4I_reg_Ex(vecX dst, iRegI src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgf($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vrepf($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl4I_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+\n+  format %{ \"VONE      $dst, $dst, $dst \\t\/\/ replicate4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n@@ -10500,0 +10754,133 @@\n+instruct repl4F_reg_Ex(vecX dst, regF src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+\n+  format %{ \"VREP  $dst, $src \\t\/\/ replicate4F\" %}\n+  size(6);\n+\n+  ins_encode %{\n+    __ z_vrepf($dst$$VectorRegister, $src$$FloatRegister->to_vr(), 0);\n+  %}\n+   ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl4F_immF0(vecX dst, immFp0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 4 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate4F\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2D_reg_Ex(vecX dst, regD src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+\n+  format %{ \"VREP  $dst, $src \\t\/\/ replicate2D\" %}\n+  size(6);\n+\n+  ins_encode %{\n+    __ z_vrepg($dst$$VectorRegister, $src$$FloatRegister->to_vr(), 0);\n+  %}\n+   ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2D_immD0(vecX dst, immDp0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate2D\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl16B_reg_Ex(vecX dst, iRegI src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgb($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vrepb($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl16B_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+\n+  format %{ \"VONE      $dst, $src \\t\/\/ replicate16B\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl16B_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate16B\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2L_reg_Ex(vecX dst, iRegL src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+\n+  size(12);\n+  ins_encode %{\n+    __ z_vlvgg($dst$$VectorRegister, $src$$Register, 0);\n+    __ z_vrepg($dst$$VectorRegister, $dst$$VectorRegister, 0);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{\n+  match(Set dst (Replicate src));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+\n+  format %{ \"VONE      $dst, $src \\t\/\/ replicate2L\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vone($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct repl2L_immI0(vecX dst, immI_0 zero) %{\n+  match(Set dst (Replicate zero));\n+  predicate(n->as_Vector()->length() == 2 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+\n+  format %{ \"VZERO      $dst, $zero \\t\/\/ replicate16B\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vzero($dst$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\n@@ -10514,0 +10901,15 @@\n+\/\/ Store Packed Byte long register to memory\n+instruct storeV16(memoryRX mem, vecX src) %{\n+  predicate(n->as_StoreVector()->memory_size() == 16);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(MEMORY_REF_COST);\n+\n+  format %{ \"VST  $mem, $src \\t\/\/ store 16-byte Vector\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vst($src$$VectorRegister,\n+              Address(reg_to_register_object($mem$$base), $mem$$index$$Register, $mem$$disp));\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10525,0 +10927,15 @@\n+\/\/ Load Aligned Packed Byte\n+instruct loadV16(vecX dst, memoryRX mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 16);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(MEMORY_REF_COST);\n+\n+  format %{ \"VL  $dst, $mem \\t\/\/ load 16-byte Vector\" %}\n+  size(6);\n+  ins_encode %{\n+     __ z_vl($dst$$VectorRegister,\n+              Address(reg_to_register_object($mem$$base), $mem$$index$$Register, $mem$$disp));\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10534,0 +10951,296 @@\n+instruct reinterpretX(vecX dst) %{\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"reinterpret $dst\" %}\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\/\/----------Vector Arithmetic Instructions--------------------------------------\n+\n+\/\/ Vector Addition Instructions\n+\n+instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVB src1 src2));\n+  predicate(n->as_Vector()->length() == 16);\n+  format %{ \"VAB  $dst,$src1,$src2\\t\/\/ add packed16B\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vab($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVS src1 src2));\n+  predicate(n->as_Vector()->length() == 8);\n+  format %{ \"VAH  $dst,$src1,$src2\\t\/\/ add packed8S\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vah($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVI src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VAF  $dst,$src1,$src2\\t\/\/ add packed4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vaf($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul16B_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVB src1 src2));\n+  predicate(n->as_Vector()->length() == 16);\n+  format %{ \"VMLB  $dst,$src1,$src2\\t\/\/ mul packed16B\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vmlb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul8S_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVS src1 src2));\n+  predicate(n->as_Vector()->length() == 8);\n+  format %{ \"VMLHW  $dst,$src1,$src2\\t\/\/ mul packed8S\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vmlhw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVI src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VMLF  $dst,$src1,$src2\\t\/\/ mul packed4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vmlf($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVL src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VAG  $dst,$src1,$src2\\t\/\/ add packed2L\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vag($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub416B_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVB src1 src2));\n+  predicate(n->as_Vector()->length() == 16);\n+  format %{ \"VSB  $dst,$src1,$src2\\t\/\/ sub packed16B\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVS src1 src2));\n+  predicate(n->as_Vector()->length() == 8);\n+  format %{ \"VSH  $dst,$src1,$src2\\t\/\/ sub packed8S\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsh($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVI src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VSF  $dst,$src1,$src2\\t\/\/ sub packed4I\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsf($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVL src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VSG  $dst,$src1,$src2\\t\/\/ sub packed2L\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vsg($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFASB  $dst,$src1,$src2\\t\/\/ add packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfasb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AddVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFADB  $dst,$src1,$src2\\t\/\/ add packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfadb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFSSB  $dst,$src1,$src2\\t\/\/ sub packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfssb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (SubVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFSDB  $dst,$src1,$src2\\t\/\/ sub packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfsdb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFMSB  $dst,$src1,$src2\\t\/\/ mul packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfmsb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MulVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFMDB  $dst,$src1,$src2\\t\/\/ mul packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfmdb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (DivVF src1 src2));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFDSB  $dst,$src1,$src2\\t\/\/ div packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfdsb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (DivVD src1 src2));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFDDB  $dst,$src1,$src2\\t\/\/ div packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfddb($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Vector Square Root Instructions\n+\n+instruct vsqrt4F_reg(vecX dst, vecX src) %{\n+  match(Set dst (SqrtVF src));\n+  predicate(n->as_Vector()->length() == 4);\n+  format %{ \"VFSQSB $dst,$src\\t\/\/ sqrt packed4F\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfsqsb($dst$$VectorRegister, $src$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct vsqrt2D_reg(vecX dst, vecX src) %{\n+  match(Set dst (SqrtVD src));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"VFSQDB $dst,$src\\t\/\/ sqrt packed2D\" %}\n+  size(6);\n+  ins_encode %{\n+    __ z_vfsqdb($dst$$VectorRegister, $src$$VectorRegister);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Vector Population Count Instructions\n+\n+instruct vpopcnt_reg(vecX dst, vecX src) %{\n+  match(Set dst (PopCountVI src));\n+  format %{ \"VPOPCT $dst,$src\\t\/\/ pop count packed\" %}\n+  size(6);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_BYTE:\n+        __ z_vpopctb($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      case T_SHORT:\n+        __ z_vpopcth($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      case T_INT:\n+        __ z_vpopctf($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      case T_LONG:\n+        __ z_vpopctg($dst$$VectorRegister, $src$$VectorRegister);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+\/\/ Vector Round Instructions\n+instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  predicate(n->as_Vector()->length() == 2);\n+  format %{ \"RoundDoubleModeV $src,$rmode\" %}\n+  size(6);\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ z_vflrd($dst$$VectorRegister, $src$$VectorRegister, 0);\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ z_vflrd($dst$$VectorRegister, $src$$VectorRegister, 7);\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ z_vflrd($dst$$VectorRegister, $src$$VectorRegister, 6);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":729,"deletions":16,"binary":false,"changes":745,"status":"modified"},{"patch":"@@ -83,0 +83,3 @@\n+#define RegisterSaver_LiveVReg(regname) \\\n+  { RegisterSaver::v_reg,      regname->encoding(), regname->as_VMReg() }\n+\n@@ -260,0 +263,20 @@\n+static const RegisterSaver::LiveRegType RegisterSaver_LiveVRegs[] = {\n+  \/\/ live vector registers (optional, only these ones are used by C2):\n+  RegisterSaver_LiveVReg( Z_V16 ),\n+  RegisterSaver_LiveVReg( Z_V17 ),\n+  RegisterSaver_LiveVReg( Z_V18 ),\n+  RegisterSaver_LiveVReg( Z_V19 ),\n+  RegisterSaver_LiveVReg( Z_V20 ),\n+  RegisterSaver_LiveVReg( Z_V21 ),\n+  RegisterSaver_LiveVReg( Z_V22 ),\n+  RegisterSaver_LiveVReg( Z_V23 ),\n+  RegisterSaver_LiveVReg( Z_V24 ),\n+  RegisterSaver_LiveVReg( Z_V25 ),\n+  RegisterSaver_LiveVReg( Z_V26 ),\n+  RegisterSaver_LiveVReg( Z_V27 ),\n+  RegisterSaver_LiveVReg( Z_V28 ),\n+  RegisterSaver_LiveVReg( Z_V29 ),\n+  RegisterSaver_LiveVReg( Z_V30 ),\n+  RegisterSaver_LiveVReg( Z_V31 )\n+};\n+\n@@ -274,2 +297,6 @@\n-int RegisterSaver::live_reg_frame_size(RegisterSet reg_set) {\n-  return live_reg_save_size(reg_set) + frame::z_abi_160_size;\n+int RegisterSaver::live_reg_frame_size(RegisterSet reg_set, bool save_vectors) {\n+  const int vregstosave_num = save_vectors ? (sizeof(RegisterSaver_LiveVRegs) \/\n+                                              sizeof(RegisterSaver::LiveRegType))\n+                                            : 0;\n+\n+  return live_reg_save_size(reg_set) + vregstosave_num * v_reg_size + frame::z_abi_160_size;\n@@ -280,1 +307,1 @@\n-OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc) {\n+OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc, bool save_vectors) {\n@@ -287,1 +314,5 @@\n-  const int frame_size_in_bytes  = live_reg_frame_size(reg_set);\n+    const int vregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVRegs) \/\n+                                                   sizeof(RegisterSaver::LiveRegType))\n+                                                  : 0;\n+  const int register_save_size   = live_reg_save_size(reg_set) + vregstosave_num * v_reg_size;\n+  const int frame_size_in_bytes  = frame::z_abi_160_size + register_save_size;\n@@ -289,1 +320,1 @@\n-  const int register_save_offset = frame_size_in_bytes - live_reg_save_size(reg_set);\n+  const int register_save_offset = frame_size_in_bytes - register_save_size;\n@@ -384,0 +415,11 @@\n+  for (int i = 0; i < vregstosave_num; i++) {\n+    int reg_num  = RegisterSaver_LiveVRegs[i].reg_num;\n+\n+    __ z_vst(as_VectorRegister(reg_num), Address(Z_SP, offset));\n+\n+    map->set_callee_saved(VMRegImpl::stack2reg(offset>>2), RegisterSaver_LiveVRegs[i].vmreg);\n+    offset += v_reg_size;\n+  }\n+\n+  assert(offset == frame_size_in_bytes, \"consistency check\");\n+\n@@ -435,0 +477,3 @@\n+#ifdef ASSERT\n+  assert(offset == frame_size_in_bytes, \"consistency check\");\n+#endif\n@@ -440,1 +485,1 @@\n-void RegisterSaver::restore_live_registers(MacroAssembler* masm, RegisterSet reg_set) {\n+void RegisterSaver::restore_live_registers(MacroAssembler* masm, RegisterSet reg_set, bool save_vectors) {\n@@ -442,1 +487,8 @@\n-  const int register_save_offset = live_reg_frame_size(reg_set) - live_reg_save_size(reg_set);\n+  \/\/const int register_save_offset = live_reg_frame_size(reg_set) - live_reg_save_size(reg_set);\n+    \/\/ Calculate frame size.\n+  const int vregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVRegs) \/\n+                                                   sizeof(RegisterSaver::LiveRegType))\n+                                                  : 0;\n+  const int register_save_size   = live_reg_save_size(reg_set) + vregstosave_num * v_reg_size;\n+  const int frame_size_in_bytes  = frame::z_abi_160_size + register_save_size;\n+  const int register_save_offset = frame_size_in_bytes - register_save_size;\n@@ -519,0 +571,9 @@\n+  for (int i = 0; i < vregstosave_num; i++) {\n+    int reg_num  = RegisterSaver_LiveVRegs[i].reg_num;\n+\n+    __ z_vl(as_VectorRegister(reg_num), Address(Z_SP, offset));\n+\n+    offset += v_reg_size;\n+  }\n+\n+  assert(offset == frame_size_in_bytes, \"consistency check\");\n@@ -529,2 +590,0 @@\n-  int i;\n-  int offset;\n@@ -536,1 +595,1 @@\n-  offset = register_save_offset;\n+  int offset = register_save_offset;\n@@ -559,0 +618,1 @@\n+  assert(offset == live_reg_frame_size(all_registers), \"consistency check\");\n@@ -982,2 +1042,2 @@\n-  \/\/ Note, MaxVectorSize == 8 on this platform.\n-  assert(size <= 8, \"%d bytes vectors are not supported\", size);\n+  \/\/ Note, MaxVectorSize == 8\/16 on this platform.\n+  assert(size <= (SuperwordUseVX ? 16 : 8), \"%d bytes vectors are not supported\", size);\n@@ -2851,0 +2911,1 @@\n+  bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n@@ -2852,1 +2913,1 @@\n-  map = RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers);\n+  map = RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers, Z_R14, save_vectors);\n@@ -2884,1 +2945,1 @@\n-  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);\n+  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers, save_vectors);\n@@ -2897,1 +2958,1 @@\n-    const int offset_of_return_pc = _z_common_abi(return_pc) + RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers);\n+    const int offset_of_return_pc = _z_common_abi(return_pc) + RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers, save_vectors);\n@@ -2910,1 +2971,1 @@\n-  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);\n+  RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers, save_vectors);\n@@ -2918,1 +2979,1 @@\n-  return SafepointBlob::create(&buffer, oop_maps, RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers)\/wordSize);\n+  return SafepointBlob::create(&buffer, oop_maps, RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers, save_vectors)\/wordSize);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":78,"deletions":17,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -100,1 +100,17 @@\n-  MaxVectorSize = 8;\n+  int model_ix = get_model_index();\n+\n+  if ( model_ix >= 7 ) {\n+    if (FLAG_IS_DEFAULT(SuperwordUseVX)) {\n+      FLAG_SET_ERGO(SuperwordUseVX, true);\n+    }\n+    if (model_ix > 7 && FLAG_IS_DEFAULT(UseSFPV) && SuperwordUseVX) {\n+      FLAG_SET_ERGO(UseSFPV, true);\n+    } else if (model_ix == 7 && UseSFPV) {\n+      warning(\"UseSFPV specified, but needs at least Z14.\");\n+      FLAG_SET_DEFAULT(UseSFPV, false);\n+    }\n+  } else if (SuperwordUseVX) {\n+    warning(\"SuperwordUseVX specified, but needs at least Z13.\");\n+    FLAG_SET_DEFAULT(SuperwordUseVX, false);\n+  }\n+  MaxVectorSize = SuperwordUseVX ? 16 : 8;\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,0 +46,7 @@\n+\n+  VectorRegister vreg = ::as_VectorRegister(0);\n+  for (; i < ConcreteRegisterImpl::max_vr;) {\n+    regName[i++] = vreg->name();\n+    vreg = vreg->successor();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+inline bool is_VectorRegister() {\n+  return value() >= ConcreteRegisterImpl::max_fpr &&\n+         value() < ConcreteRegisterImpl::max_vr;\n+}\n+\n@@ -48,0 +53,5 @@\n+inline VectorRegister as_VectorRegister() {\n+  assert(is_VectorRegister(), \"must be\");\n+  return ::as_VectorRegister((value() - ConcreteRegisterImpl::max_fpr));\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+inline VMReg VectorRegister::as_VMReg() const {\n+  return VMRegImpl::as_VMReg((encoding()) + ConcreteRegisterImpl::max_fpr);\n+}\n+\n@@ -38,1 +42,1 @@\n-  return VMRegImpl::as_VMReg((encoding() << 1) + ConcreteRegisterImpl::max_fpr);\n+  return VMRegImpl::as_VMReg(encoding() + ConcreteRegisterImpl::max_vr);\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2366,0 +2366,3 @@\n+#if defined(S390)\n+    if (strcmp(rep_var,\"$VectorRegister\") == 0)   return \"as_VectorRegister\";\n+#endif\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,0 +138,8 @@\n+#if defined(S390)\n+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {\n+    return ::as_VectorRegister(reg(ra_, node));\n+  }\n+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {\n+    return ::as_VectorRegister(reg(ra_, node, idx));\n+ }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  { Bad,             T_ILLEGAL,    \"vectorx:\",      false, 0,                    relocInfo::none          },  \/\/ VectorX\n+  { Bad,             T_ILLEGAL,    \"vectorx:\",      false, Op_VecX,              relocInfo::none          },  \/\/ VectorX\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}