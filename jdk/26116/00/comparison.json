{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkAreAnnotations;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkIsAnnotation;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.getFirstAnnotationOrNull;\n@@ -237,0 +240,1 @@\n+            checkIsAnnotation(annotationType);\n@@ -239,1 +243,1 @@\n-        return getAnnotationData0(annotationType).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(annotationType));\n@@ -244,0 +248,3 @@\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n@@ -245,1 +252,1 @@\n-            return Collections.emptyList();\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkAreAnnotations;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.checkIsAnnotation;\n+import static jdk.vm.ci.hotspot.HotSpotResolvedJavaType.getFirstAnnotationOrNull;\n@@ -778,0 +781,1 @@\n+            checkIsAnnotation(type);\n@@ -780,1 +784,1 @@\n-        return getAnnotationData0(type).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(type));\n@@ -785,0 +789,3 @@\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n@@ -786,1 +793,1 @@\n-            return Collections.emptyList();\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.List;\n+\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -64,0 +67,16 @@\n+\n+    static void checkIsAnnotation(ResolvedJavaType type) {\n+        if (!type.isAnnotation()) {\n+            throw new IllegalArgumentException(type.toJavaName() + \" is not an annotation interface\");\n+        }\n+    }\n+\n+    static void checkAreAnnotations(ResolvedJavaType... types) {\n+        for (ResolvedJavaType type : types) {\n+            checkIsAnnotation(type);\n+        }\n+    }\n+\n+    static AnnotationData getFirstAnnotationOrNull(List<AnnotationData> list) {\n+        return list.isEmpty() ? null : list.get(0);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaType.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1123,0 +1123,1 @@\n+            checkIsAnnotation(annotationType);\n@@ -1125,1 +1126,1 @@\n-        return getAnnotationData0(annotationType).get(0);\n+        return getFirstAnnotationOrNull(getAnnotationData0(annotationType));\n@@ -1131,1 +1132,4 @@\n-            return Collections.emptyList();\n+            checkIsAnnotation(type1);\n+            checkIsAnnotation(type2);\n+            checkAreAnnotations(types);\n+            return List.of();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+        checkIsAnnotation(type);\n@@ -335,1 +336,4 @@\n-        return Collections.emptyList();\n+        checkIsAnnotation(type1);\n+        checkIsAnnotation(type2);\n+        checkAreAnnotations(types);\n+        return List.of();\n@@ -337,1 +341,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,0 +53,9 @@\n+    \/**\n+     * Returns true if this type represents an annotation interface.\n+     *\n+     * @return {@code true} if this type represents an annotation interface\n+     *\/\n+    default boolean isAnnotation() {\n+        return (getModifiers() & java.lang.reflect.AccessFlag.ANNOTATION.mask()) != 0;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -161,0 +161,10 @@\n+    @Test\n+    public void isAnnotationTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            boolean expected = c.isAnnotation();\n+            boolean actual = type.isAnnotation();\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n@@ -1270,0 +1280,15 @@\n+    private static void getAnnotationDataExpectedToFail(Annotated annotated, ResolvedJavaType... annotationTypes) {\n+        try {\n+            if (annotationTypes.length == 1) {\n+                annotated.getAnnotationData(annotationTypes[0]);\n+            } else {\n+                var tail = Arrays.copyOfRange(annotationTypes, 2, annotationTypes.length);\n+                annotated.getAnnotationData(annotationTypes[0], annotationTypes[1], tail);\n+            }\n+            String s = Stream.of(annotationTypes).map(ResolvedJavaType::toJavaName).collect(Collectors.joining(\", \"));\n+            throw new AssertionError(\"Expected IllegalArgumentException for retrieving (\" + s + \" from \" + annotated);\n+        } catch (IllegalArgumentException iae) {\n+            assertTrue(iae.getMessage(), iae.getMessage().contains(\"not an annotation interface\"));\n+        }\n+    }\n+\n@@ -1275,1 +1300,1 @@\n-     * @param annotated a {@link Class}, {@link Method} or {@link Field} object\n+     * @param annotatedElement a {@link Class}, {@link Method} or {@link Field} object\n@@ -1277,2 +1302,16 @@\n-    public static void getAnnotationDataTest(AnnotatedElement annotated) throws Exception {\n-        testGetAnnotationData(annotated, List.of(annotated.getAnnotations()));\n+    public static void getAnnotationDataTest(AnnotatedElement annotatedElement) throws Exception {\n+        Annotated annotated = toAnnotated(annotatedElement);\n+        ResolvedJavaType objectType = metaAccess.lookupJavaType(Object.class);\n+        ResolvedJavaType suppressWarningsType = metaAccess.lookupJavaType(SuppressWarnings.class);\n+        getAnnotationDataExpectedToFail(annotated, objectType);\n+        getAnnotationDataExpectedToFail(annotated, suppressWarningsType, objectType);\n+        getAnnotationDataExpectedToFail(annotated, suppressWarningsType, suppressWarningsType, objectType);\n+\n+        \/\/ Check that querying a missing annotation returns null\n+        assertNull(annotated.getAnnotationData(suppressWarningsType));\n+        List<AnnotationData> data = annotated.getAnnotationData(suppressWarningsType, suppressWarningsType);\n+        assertTrue(data.toString(), data.isEmpty());\n+        data = annotated.getAnnotationData(suppressWarningsType, suppressWarningsType, suppressWarningsType, suppressWarningsType);\n+        assertTrue(data.toString(), data.isEmpty());\n+\n+        testGetAnnotationData(annotatedElement, List.of(annotatedElement.getAnnotations()));\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"}]}