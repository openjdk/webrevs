{"files":[{"patch":"@@ -458,4 +458,2 @@\n-  if (if_node_profile->Opcode() == Op_If) {\n-    return new IfNode(ctrl, bol, if_node_profile->_prob, if_node_profile->_fcnt);\n-  } else {\n-    assert(if_node_profile->Opcode() == Op_RangeCheck, \"only IfNode or RangeCheckNode expected\");\n+  if (if_node_profile->is_RangeCheck()) {\n+    \/\/ RangeCheck nodes could be further optimized.\n@@ -463,0 +461,8 @@\n+  } else {\n+    \/\/ Not a RangeCheckNode? Fall back to IfNode. Assert here that we only try to create a clone from an If node with\n+    \/\/ the same profiling if that actually makes sense. Some If node subtypes should not be cloned in this way.\n+    \/\/ In theory, we should not clone BaseCountedLoopEndNodes. But they can end up being used as normal If nodes when\n+    \/\/ peeling a loop - they serve as zero-trip guard. Allow them as well.\n+    assert(if_node_profile->Opcode() == Op_If || if_node_profile->is_RangeCheck()\n+           || if_node_profile->is_BaseCountedLoopEnd(), \"should not clone other nodes\");\n+    return new IfNode(ctrl, bol, if_node_profile->_prob, if_node_profile->_fcnt);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+              assert(iff->Opcode() == Op_If || iff->is_RangeCheck() || iff->is_BaseCountedLoopEnd(), \"valid ifs\");\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325746\n+ * @summary Test Loop Unswitching with BaseCountedLoopEnd nodes as unswitch candidate.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.loopopts.TestBaseCountedEndLoopUnswitchCandidate::test*\n+ *                   -Xcomp -XX:LoopMaxUnroll=0 -XX:-UseLoopPredicate -XX:-RangeCheckElimination\n+ *                   compiler.loopopts.TestBaseCountedEndLoopUnswitchCandidate\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestBaseCountedEndLoopUnswitchCandidate {\n+    static int iFld;\n+    static long lFld;\n+    static A a = new A();\n+    static boolean flag;\n+\n+    public static void main(String[] k) {\n+        for (int i = 0; i < 10000; i++) {\n+            testLongCountedLoopEnd();\n+            testCountedLoopEnd();\n+        }\n+    }\n+\n+\n+    public static void testLongCountedLoopEnd() {\n+        long limit = lFld;\n+        for (int i = 0; i < 100; i++) {\n+\n+            \/\/ After peeling & IGNV:\n+            \/\/      LongCountedEndLoop\n+            \/\/           \/      \\\n+            \/\/         True    False\n+            \/\/        \/ \\       \/\n+            \/\/  Store    Region\n+            \/\/\n+            \/\/ LongCountedEndLoop has both paths inside loop and is therefore selected as unswitch candidate If in\n+            \/\/ Loop Unswitching.\n+\n+            \/\/ Use stride > Integer.MAX_VALUE such that LongCountedLoopNode is not split further into loop nests.\n+            for (long j = 0; j < limit; j+=2147483648L) {\n+                a.i += 34; \/\/ NullCheck with trap on false path -> reason to peel\n+                if (j > 0) { \/\/ After peeling: j > 0 always true -> loop folded away\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void testCountedLoopEnd() {\n+        int limit = iFld;\n+        for (int i = 0; i < 100; i++) {\n+\n+            \/\/ After peeling & IGNV:\n+            \/\/        CountedLoopEnd\n+            \/\/           \/      \\\n+            \/\/         True    False\n+            \/\/        \/ \\       \/\n+            \/\/  Store    Region\n+            \/\/\n+            \/\/ CountedEndLoop has both paths inside loop and is therefore selected as unswitch candidate If in\n+            \/\/ Loop Unswitching.\n+\n+            for (int j = 0; j < limit; j++) {\n+                a.i += 34; \/\/ NullCheck with trap on false path -> reason to peel\n+                if (j > 0) { \/\/ After peeling: j > 0 always true -> loop folded away\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+class A {\n+    int i;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestBaseCountedEndLoopUnswitchCandidate.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}