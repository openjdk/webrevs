{"files":[{"patch":"@@ -27,0 +27,2 @@\n+#include \"opto\/castnode.hpp\"\n+#include \"opto\/cfgnode.hpp\"\n@@ -35,3 +37,18 @@\n-\/\/ This is done by duplicating the loop and placing the if-path in one unswitched loop version (i.e. the true-path-loop)\n-\/\/ and the else-path in the other (i.e. the false-path-loop). The invariant test only needs to be checked once and\n-\/\/ depending on the outcome, one or the other unswitched loop version is executed:\n+\/\/ Such a test is either always true or always false in all loop iterations and could therefore only be executed once.\n+\/\/ To achieve that, we duplicate the loop and change the original and cloned loop as follows:\n+\/\/ - Original loop -> true-path-loop: The true-path-block of the invariant, non-loop-exiting test in the original loop\n+\/\/                                    is kept while the false-path-block is killed. We call this unswitched loop version\n+\/\/                                    the true-path-loop.\n+\/\/ - Cloned loop -> False-path-loop:  The false-path-block of the invariant, non-loop-exiting test in the cloned loop\n+\/\/                                    is kept while the true-path-block is killed. We call this unswitched loop version\n+\/\/                                    the false-path loop.\n+\/\/\n+\/\/ The invariant, non-loop-exiting test can now be moved before both loops (to only execute it once) and turned into a\n+\/\/ loop selector If node to select at runtime which unswitched loop version should be executed.\n+\/\/ - Loop selector true?  Execute the true-path-loop.\n+\/\/ - Loop selector false? Execute the false-path-loop.\n+\/\/\n+\/\/ Note that even though an invariant test that exits the loop could also be optimized with Loop Unswitching, it is more\n+\/\/ efficient to simply peel the loop which achieves the same result in a simpler manner (also see policy_peeling()).\n+\/\/\n+\/\/ The following graph summarizes the Loop Unswitching optimization:\n@@ -41,1 +58,1 @@\n-\/\/    [Predicates]                                                             if (invariant-test)\n+\/\/    [Predicates]                                                         loop selector If (invariant-test)\n@@ -130,1 +147,1 @@\n-        _outer_loop(loop->_head->as_Loop()->is_strip_mined() ? loop->_parent->_parent : loop->_parent),\n+        _outer_loop(loop->skip_strip_mined()->_parent),\n@@ -159,2 +176,6 @@\n-    IfProjNode* proj_to_loop = (path_to_loop == TRUE_PATH) ? new IfTrueNode(_selector)\n-                                                             new IfFalseNode(_selector);\n+    IfProjNode* proj_to_loop;\n+    if (path_to_loop == TRUE_PATH) {\n+      proj_to_loop = new IfTrueNode(_selector);\n+    } else {\n+      proj_to_loop = new IfFalseNode(_selector);\n+    }\n@@ -183,0 +204,80 @@\n+\/\/ Class to unswitch the original loop and create Predicates at the new unswitched loop versions. The newly cloned loop\n+\/\/ becomes the false-path-loop while original loop becomes the true-path-loop.\n+class OriginalLoop : public StackObj {\n+  LoopNode* const _strip_mined_loop_head;\n+  IdealLoopTree* const _loop;\n+  Node_List& _old_new;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  OriginalLoop(IdealLoopTree* loop, Node_List& old_new)\n+      : _strip_mined_loop_head(loop->_head->as_Loop()->skip_strip_mined()),\n+        _loop(loop),\n+        _old_new(old_new),\n+        _phase(loop->_phase) {}\n+  NONCOPYABLE(OriginalLoop);\n+\n+ private:\n+  void fix_loop_entries(IfProjNode* true_path_loop_entry, IfProjNode* false_path_loop_entry) {\n+    _phase->replace_loop_entry(_strip_mined_loop_head, true_path_loop_entry);\n+    LoopNode* false_path_loop_strip_mined_head = old_to_new(_strip_mined_loop_head)->as_Loop();\n+    _phase->replace_loop_entry(false_path_loop_strip_mined_head, false_path_loop_entry);\n+  }\n+\n+  Node* old_to_new(const Node* old) const {\n+    return _old_new[old->_idx];\n+  }\n+\n+#ifdef ASSERT\n+  void verify_unswitched_loop_versions(LoopNode* true_path_loop_head,\n+                                       const UnswitchedLoopSelector& unswitched_loop_selector) const {\n+    verify_unswitched_loop_version(true_path_loop_head, unswitched_loop_selector.true_path_loop_proj());\n+    verify_unswitched_loop_version(old_to_new(true_path_loop_head)->as_Loop(),\n+                                   unswitched_loop_selector.false_path_loop_proj());\n+  }\n+\n+  static void verify_unswitched_loop_version(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n+    Node* entry = loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+    const Predicates predicates(entry);\n+    \/\/ When skipping all predicates, we should end up at 'loop_selector_if_proj'.\n+    assert(loop_selector_if_proj == predicates.entry(), \"should end up at loop selector If\");\n+  }\n+#endif \/\/ ASSERT\n+\n+\/\/ Remove the unswitch candidate If nodes in both unswitched loop versions which are now dominated by the loop selector\n+\/\/ If node. Keep the true-path-block in the true-path-loop and the false-path-block in the false-path-loop by setting\n+\/\/ the bool input accordingly. The unswitch candidate If nodes are folded in the next IGVN round.\n+  void remove_unswitch_candidate_from_loops(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    IfNode* unswitching_candidate = unswitched_loop_selector.unswitch_candidate();\n+    _phase->igvn().rehash_node_delayed(unswitching_candidate);\n+    _phase->dominated_by(unswitched_loop_selector.true_path_loop_proj(), unswitching_candidate);\n+\n+    IfNode* unswitching_candidate_clone = _old_new[unswitching_candidate->_idx]->as_If();\n+    _phase->igvn().rehash_node_delayed(unswitching_candidate_clone);\n+    _phase->dominated_by(unswitched_loop_selector.false_path_loop_proj(), unswitching_candidate_clone);\n+  }\n+\n+ public:\n+  \/\/ Unswitch the original loop on the invariant loop selector by creating a true-path-loop and a false-path-loop.\n+  \/\/ Remove the unswitch candidate If from both unswitched loop versions which are now covered by the loop selector If.\n+  void unswitch(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_strip_mined_loop_head),\n+                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n+\n+    \/\/ At this point, the selector If projections are the corresponding loop entries.\n+    \/\/ clone_parse_and_assertion_predicates_to_unswitched_loop() could clone additional predicates after the selector\n+    \/\/ If projections. The loop entries are updated accordingly.\n+    IfProjNode* true_path_loop_entry = unswitched_loop_selector.true_path_loop_proj();\n+    IfProjNode* false_path_loop_entry = unswitched_loop_selector.false_path_loop_proj();\n+    _phase->clone_parse_and_assertion_predicates_to_unswitched_loop(_loop, _old_new,\n+                                                                    true_path_loop_entry, false_path_loop_entry);\n+\n+    fix_loop_entries(true_path_loop_entry, false_path_loop_entry);\n+\n+    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n+\n+    _phase->recompute_dom_depth();\n+    remove_unswitch_candidate_from_loops(unswitched_loop_selector);\n+  }\n+};\n+\n@@ -199,1 +300,3 @@\n-  create_unswitched_loop_versions(loop, old_new, unswitched_loop_selector);\n+  OriginalLoop original_loop(loop, old_new);\n+  original_loop.unswitch(unswitched_loop_selector);\n+\n@@ -255,0 +358,2 @@\n+\/\/ When unswitching a counted loop, we need to convert it back to a normal loop since it's not a proper pre, main or,\n+\/\/ post loop anymore after loop unswitching.\n@@ -256,38 +361,3 @@\n-  if (loop_head->is_CountedLoop() && !loop_head->as_CountedLoop()->is_normal_loop()) {\n-    loop_head->as_CountedLoop()->set_normal_loop();\n-  }\n-}\n-\n-\/\/ Class to unswitch the original loop and create Predicates at the new unswitched loop versions. The newly cloned loop\n-\/\/ becomes the false-path-loop while original loop becomes the true-path-loop.\n-class OriginalLoop : public StackObj {\n-  LoopNode* const _strip_mined_loop_head;\n-  IdealLoopTree* const _loop;\n-  Node_List* const _old_new;\n-  PhaseIdealLoop* const _phase;\n-\n- public:\n-  OriginalLoop(IdealLoopTree* loop, Node_List* old_new)\n-      : _strip_mined_loop_head(loop->_head->as_Loop()->skip_strip_mined()),\n-        _loop(loop),\n-        _old_new(old_new),\n-        _phase(loop->_phase) {}\n-  NONCOPYABLE(OriginalLoop);\n-\n- private:\n-  void fix_loop_entries(IfProjNode* true_path_loop_entry, IfProjNode* false_path_loop_entry) {\n-    _phase->replace_loop_entry(_strip_mined_loop_head, true_path_loop_entry);\n-    LoopNode* false_path_loop_strip_mined_head = old_to_new(_strip_mined_loop_head)->as_Loop();\n-    _phase->replace_loop_entry(false_path_loop_strip_mined_head, false_path_loop_entry);\n-  }\n-\n-  Node* old_to_new(const Node* old) const {\n-    return _old_new->at(old->_idx);\n-  }\n-\n-#ifdef ASSERT\n-  void verify_unswitched_loop_versions(LoopNode* true_path_loop_head,\n-                                       const UnswitchedLoopSelector& unswitched_loop_selector) const {\n-    verify_unswitched_loop_version(true_path_loop_head, unswitched_loop_selector.true_path_loop_proj());\n-    verify_unswitched_loop_version(old_to_new(true_path_loop_head)->as_Loop(),\n-                                   unswitched_loop_selector.false_path_loop_proj());\n+  CountedLoopNode* cl = loop_head->isa_CountedLoop();\n+  if (cl != nullptr && !cl->is_normal_loop()) {\n+    cl->set_normal_loop();\n@@ -295,53 +365,0 @@\n-\n-  static void verify_unswitched_loop_version(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n-    Node* entry = loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n-    const Predicates predicates(entry);\n-    \/\/ When skipping all predicates, we should end up at 'loop_selector_if_proj'.\n-    assert(loop_selector_if_proj == predicates.entry(), \"should end up at loop selector If\");\n-  }\n-#endif \/\/ ASSERT\n-\n- public:\n-  \/\/ Unswitch on the invariant loop selector by creating two unswitched loop versions.\n-  void unswitch(const UnswitchedLoopSelector& unswitched_loop_selector) {\n-    _phase->clone_loop(_loop, *_old_new, _phase->dom_depth(_strip_mined_loop_head),\n-                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n-\n-    \/\/ At this point, the selector If projections are the corresponding loop entries.\n-    \/\/ clone_parse_and_assertion_predicates_to_unswitched_loop() could clone additional predicates after the selector\n-    \/\/ If projections. The loop entries are updated accordingly.\n-    IfProjNode* true_path_loop_entry = unswitched_loop_selector.true_path_loop_proj();\n-    IfProjNode* false_path_loop_entry = unswitched_loop_selector.false_path_loop_proj();\n-    _phase->clone_parse_and_assertion_predicates_to_unswitched_loop(_loop, *_old_new,\n-                                                                    true_path_loop_entry, false_path_loop_entry);\n-\n-    fix_loop_entries(true_path_loop_entry, false_path_loop_entry);\n-\n-    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n-  }\n-};\n-\n-\/\/ Create a true-path- and a false-path-loop version of the original loop by cloning the loop and inserting an If to\n-\/\/ select one of the versions at runtime. Remove the unswitch candidate If node from both unswitched loop versions.\n-void PhaseIdealLoop::create_unswitched_loop_versions(IdealLoopTree* loop, Node_List& old_new,\n-                                                     const UnswitchedLoopSelector& unswitched_loop_selector) {\n-\n-  OriginalLoop original_loop(loop, &old_new);\n-  original_loop.unswitch(unswitched_loop_selector);\n-  recompute_dom_depth();\n-\n-  remove_unswitch_candidate_from_loops(old_new, unswitched_loop_selector);\n-}\n-\n-\/\/ Remove the unswitch candidate If nodes in both unswitched loop versions which are now dominated by the loop selector\n-\/\/ If node. Keep the true path block in the true-path-loop and the false path block in the false-path-loop by setting\n-\/\/ the bool input accordingly. The unswitch candidate If nodes are folded in the next IGVN round.\n-void PhaseIdealLoop::remove_unswitch_candidate_from_loops(const Node_List& old_new,\n-                                                          const UnswitchedLoopSelector& unswitched_loop_selector) {\n-  IfNode* unswitching_candidate = unswitched_loop_selector.unswitch_candidate();\n-  _igvn.rehash_node_delayed(unswitching_candidate);\n-  dominated_by(unswitched_loop_selector.true_path_loop_proj(), unswitching_candidate);\n-\n-  IfNode* unswitching_candidate_clone = old_new[unswitching_candidate->_idx]->as_If();\n-  _igvn.rehash_node_delayed(unswitching_candidate_clone);\n-  dominated_by(unswitched_loop_selector.false_path_loop_proj(), unswitching_candidate_clone);\n@@ -361,1 +378,1 @@\n-      Node* check_cast = proj->fast_out(j)->isa_CheckCastPP();\n+      CheckCastPPNode* check_cast = proj->fast_out(j)->isa_CheckCastPP();\n@@ -367,1 +384,1 @@\n-    while (loop_invariant_check_casts.size() > 0) {\n+    while (loop_invariant_check_casts.length() > 0) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":118,"deletions":101,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -774,0 +774,5 @@\n+  \/\/ Return the strip mined loop tree if there is an outer strip mined loop. Otherwise, return this.\n+  IdealLoopTree* skip_strip_mined() {\n+    return _head->as_Loop()->is_strip_mined() ? _parent : this;\n+  }\n+\n@@ -1419,2 +1424,1 @@\n-  void create_unswitched_loop_versions(IdealLoopTree* loop, Node_List& old_new,\n-                                       const UnswitchedLoopSelector& unswitched_loop_selector);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4195,1 +4195,2 @@\n-  fix_data_uses(wq, loop, ControlAroundStripMined, head->is_strip_mined() ? loop->_parent : loop, new_counter, old_new, worklist, split_if_set, split_bool_set, split_cex_set);\n+  fix_data_uses(wq, loop, ControlAroundStripMined, loop->skip_strip_mined(), new_counter, old_new, worklist,\n+                split_if_set, split_bool_set, split_cex_set);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}