{"files":[{"patch":"@@ -424,0 +424,3 @@\n+\n+  static IfNode* make_with_same_profile(IfNode* if_node_profile, Node* ctrl, BoolNode* bol);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -457,0 +457,9 @@\n+IfNode* IfNode::make_with_same_profile(IfNode* if_node_profile, Node* ctrl, BoolNode* bol) {\n+  if (if_node_profile->Opcode() == Op_If) {\n+    return new IfNode(ctrl, bol, if_node_profile->_prob, if_node_profile->_fcnt);\n+  } else {\n+    assert(if_node_profile->Opcode() == Op_RangeCheck, \"only IfNode or RangeCheckNode expected\");\n+    return new RangeCheckNode(ctrl, bol, if_node_profile->_prob, if_node_profile->_fcnt);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,1 +34,4 @@\n-\/\/================= Loop Unswitching =====================\n+\/\/ Loop Unswitching is a loop optimization to move an invariant, non-loop-exiting test in the loop body before the loop.\n+\/\/ This is done by duplicating the loop and placing the if-path in one unswitched loop version (i.e. the true-path-loop)\n+\/\/ and the else-path in the other (i.e. the false-path-loop). The invariant test only needs to be checked once and\n+\/\/ depending on the outcome, one or the other unswitched loop version is executed:\n@@ -36,23 +39,19 @@\n-\/\/ orig:                       transformed:\n-\/\/                               if (invariant-test) then\n-\/\/  predicates                     predicates\n-\/\/  loop                           loop\n-\/\/    stmt1                          stmt1\n-\/\/    if (invariant-test) then       stmt2\n-\/\/      stmt2                        stmt4\n-\/\/    else                         endloop\n-\/\/      stmt3                    else\n-\/\/    endif                        predicates [clone]\n-\/\/    stmt4                        loop [clone]\n-\/\/  endloop                          stmt1 [clone]\n-\/\/                                   stmt3\n-\/\/                                   stmt4 [clone]\n-\/\/                                 endloop\n-\/\/                               endif\n-\/\/\n-\/\/ Note: the \"else\" clause may be empty\n-\n-\/\/------------------------------policy_unswitching-----------------------------\n-\/\/ Return TRUE or FALSE if the loop should be unswitched\n-\/\/ (ie. clone loop with an invariant test that does not exit the loop)\n-bool IdealLoopTree::policy_unswitching( PhaseIdealLoop *phase ) const {\n+\/\/                                                                    [Initialized Assertion Predicates]\n+\/\/                                                                                    |\n+\/\/    [Predicates]                                                             if (invariant-test)\n+\/\/         |                                                                  \/                   \\\n+\/\/    Original Loop                                                       true?                  false?\n+\/\/      stmt1                                                             \/                         \\\n+\/\/      if (invariant-test)           UNSWITCHED              [Cloned Parse Predicates]         [Cloned Parse Predicates]\n+\/\/        if-block                    =========>              [Cloned Template                  [Cloned Template\n+\/\/      else                                                   Assertion Predicates]             Assertion Predicates]\n+\/\/        \/\/ could be empty                                         |                                  |\n+\/\/        [else-block]                                        True-Path-Loop                    False-Path-Loop\n+\/\/      stmt2                                                   cloned stmt1                      cloned stmt1\n+\/\/    Endloop                                                   cloned if-block                   [cloned else-block]\n+\/\/                                                              cloned stmt2                      cloned stmt2\n+\/\/                                                            Endloop                           Endloop\n+\n+\n+\/\/ Return true if the loop should be unswitched or false otherwise.\n+bool IdealLoopTree::policy_unswitching(PhaseIdealLoop* phase) const {\n@@ -78,1 +77,1 @@\n-  if (phase->find_unswitching_candidate(this) == nullptr) {\n+  if (phase->find_unswitch_candidate(this) == nullptr) {\n@@ -86,7 +85,5 @@\n-\/\/------------------------------find_unswitching_candidate-----------------------------\n-\/\/ Find candidate \"if\" for unswitching\n-IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop) const {\n-\n-  \/\/ Find first invariant test that doesn't exit the loop\n-  LoopNode *head = loop->_head->as_Loop();\n-  IfNode* unswitch_iff = nullptr;\n+\/\/ Find an invariant test in the loop body that does not exit the loop. If multiple tests are found, we pick the first\n+\/\/ one in the loop body. Return the \"unswitch candidate\" If to apply Loop Unswitching on.\n+IfNode* PhaseIdealLoop::find_unswitch_candidate(const IdealLoopTree* loop) const {\n+  LoopNode* head = loop->_head->as_Loop();\n+  IfNode* unswitch_candidate = nullptr;\n@@ -105,1 +102,1 @@\n-              unswitch_iff = iff;\n+              unswitch_candidate = iff;\n@@ -113,1 +110,1 @@\n-  return unswitch_iff;\n+  return unswitch_candidate;\n@@ -116,8 +113,32 @@\n-\/\/------------------------------do_unswitching-----------------------------\n-\/\/ Clone loop with an invariant test (that does not exit) and\n-\/\/ insert a clone of the test that selects which version to\n-\/\/ execute.\n-void PhaseIdealLoop::do_unswitching(IdealLoopTree *loop, Node_List &old_new) {\n-  LoopNode* head = loop->_head->as_Loop();\n-  if (has_control_dependencies_from_predicates(head)) {\n-    return;\n+\/\/ This class creates an If node (i.e. loop selector) that selects if the true-path-loop or the false-path-loop should be\n+\/\/ executed at runtime. This is done by finding an invariant and non-loop-exiting unswitch candidate If node (guaranteed\n+\/\/ to exist at this point) to perform Loop Unswitching on.\n+class UnswitchedLoopSelector : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+  IdealLoopTree* const _outer_loop;\n+  Node* const _original_loop_entry;\n+  IfNode* const _unswitch_candidate;\n+  IfNode* const _selector;\n+  IfTrueNode* const _true_path_loop_proj;\n+  IfFalseNode* const _false_path_loop_proj;\n+\n+  enum PathToLoop { TRUE_PATH, FALSE_PATH };\n+\n+ public:\n+  UnswitchedLoopSelector(IdealLoopTree* loop)\n+      : _phase(loop->_phase),\n+        _outer_loop(loop->_head->as_Loop()->is_strip_mined() ? loop->_parent->_parent : loop->_parent),\n+        _original_loop_entry(loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl)),\n+        _unswitch_candidate(find_unswitch_candidate(loop)),\n+        _selector(create_selector_if()),\n+        _true_path_loop_proj(create_proj_to_loop(TRUE_PATH)->as_IfTrue()),\n+        _false_path_loop_proj(create_proj_to_loop(FALSE_PATH)->as_IfFalse()) {\n+  }\n+  NONCOPYABLE(UnswitchedLoopSelector);\n+\n+ private:\n+  IfNode* find_unswitch_candidate(IdealLoopTree* loop) {\n+    IfNode* unswitch_candidate = _phase->find_unswitch_candidate(loop);\n+    assert(unswitch_candidate != nullptr, \"guaranteed to exist by policy_unswitching\");\n+    assert(_phase->is_member(loop, unswitch_candidate), \"must be inside original loop\");\n+    return unswitch_candidate;\n@@ -126,3 +147,9 @@\n-  \/\/ Find first invariant test that doesn't exit the loop\n-  IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop);\n-  assert(unswitch_iff != nullptr, \"should be at least one\");\n+  IfNode* create_selector_if() const {\n+    const uint dom_depth = _phase->dom_depth(_original_loop_entry);\n+    _phase->igvn().rehash_node_delayed(_original_loop_entry);\n+    BoolNode* unswitch_candidate_bool = _unswitch_candidate->in(1)->as_Bool();\n+    IfNode* selector_if = IfNode::make_with_same_profile(_unswitch_candidate, _original_loop_entry,\n+                                                         unswitch_candidate_bool);\n+    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, dom_depth);\n+    return selector_if;\n+  }\n@@ -130,4 +157,6 @@\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"Unswitch   %d \", head->unswitch_count()+1);\n-    loop->dump_head();\n+  IfProjNode* create_proj_to_loop(const PathToLoop path_to_loop) {\n+    const uint dom_depth = _phase->dom_depth(_original_loop_entry);\n+    IfProjNode* proj_to_loop = (path_to_loop == TRUE_PATH) ? new IfTrueNode(_selector)\n+                                                             new IfFalseNode(_selector);\n+    _phase->register_node(proj_to_loop, _outer_loop, _selector, dom_depth);\n+    return proj_to_loop;\n@@ -135,1 +164,0 @@\n-#endif\n@@ -137,1 +165,4 @@\n-  C->print_method(PHASE_BEFORE_LOOP_UNSWITCHING, 4, head);\n+ public:\n+  IfNode* unswitch_candidate() const {\n+    return _unswitch_candidate;\n+  }\n@@ -139,3 +170,2 @@\n-  \/\/ Need to revert back to normal loop\n-  if (head->is_CountedLoop() && !head->as_CountedLoop()->is_normal_loop()) {\n-    head->as_CountedLoop()->set_normal_loop();\n+  IfNode* selector() const {\n+    return _selector;\n@@ -144,3 +174,3 @@\n-  IfNode* invar_iff = create_slow_version_of_loop(loop, old_new, unswitch_iff, CloneIncludesStripMined);\n-  ProjNode* proj_true = invar_iff->proj_out(1);\n-  verify_fast_loop(head, proj_true);\n+  IfTrueNode* true_path_loop_proj() const {\n+    return _true_path_loop_proj;\n+  }\n@@ -148,5 +178,4 @@\n-  \/\/ Increment unswitch count\n-  LoopNode* head_clone = old_new[head->_idx]->as_Loop();\n-  int nct = head->unswitch_count() + 1;\n-  head->set_unswitch_count(nct);\n-  head_clone->set_unswitch_count(nct);\n+  IfFalseNode* false_path_loop_proj() const {\n+    return _false_path_loop_proj;\n+  }\n+};\n@@ -154,2 +183,3 @@\n-  \/\/ Hoist invariant casts out of each loop to the appropriate\n-  \/\/ control projection.\n+\/\/ See comments below file header for more information about Loop Unswitching.\n+void PhaseIdealLoop::do_unswitching(IdealLoopTree* loop, Node_List& old_new) {\n+  assert(LoopUnswitching, \"LoopUnswitching must be enabled\");\n@@ -157,21 +187,4 @@\n-  Node_List worklist;\n-  for (DUIterator_Fast imax, i = unswitch_iff->fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj= unswitch_iff->fast_out(i)->as_Proj();\n-    \/\/ Copy to a worklist for easier manipulation\n-    for (DUIterator_Fast jmax, j = proj->fast_outs(jmax); j < jmax; j++) {\n-      Node* use = proj->fast_out(j);\n-      if (use->Opcode() == Op_CheckCastPP && loop->is_invariant(use->in(1))) {\n-        worklist.push(use);\n-      }\n-    }\n-    ProjNode* invar_proj = invar_iff->proj_out(proj->_con)->as_Proj();\n-    while (worklist.size() > 0) {\n-      Node* use = worklist.pop();\n-      Node* nuse = use->clone();\n-      nuse->set_req(0, invar_proj);\n-      _igvn.replace_input_of(use, 1, nuse);\n-      register_new_node(nuse, invar_proj);\n-      \/\/ Same for the clone\n-      Node* use_clone = old_new[use->_idx];\n-      _igvn.replace_input_of(use_clone, 1, nuse);\n-    }\n+  LoopNode* original_head = loop->_head->as_Loop();\n+  if (has_control_dependencies_from_predicates(original_head)) {\n+    NOT_PRODUCT(trace_loop_unswitching_impossible(original_head);)\n+    return;\n@@ -180,3 +193,2 @@\n-  \/\/ Hardwire the control paths in the loops into if(true) and if(false)\n-  _igvn.rehash_node_delayed(unswitch_iff);\n-  dominated_by(proj_true->as_IfProj(), unswitch_iff);\n+  NOT_PRODUCT(trace_loop_unswitching_count(loop, original_head);)\n+  C->print_method(PHASE_BEFORE_LOOP_UNSWITCHING, 4, original_head);\n@@ -184,4 +196,1 @@\n-  IfNode* unswitch_iff_clone = old_new[unswitch_iff->_idx]->as_If();\n-  _igvn.rehash_node_delayed(unswitch_iff_clone);\n-  ProjNode* proj_false = invar_iff->proj_out(0);\n-  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone);\n+  revert_to_normal_loop(original_head);\n@@ -189,7 +198,4 @@\n-  \/\/ Reoptimize loops\n-  loop->record_for_igvn();\n-  for(int i = loop->_body.size() - 1; i >= 0 ; i--) {\n-    Node *n = loop->_body[i];\n-    Node *n_clone = old_new[n->_idx];\n-    _igvn._worklist.push(n_clone);\n-  }\n+  const UnswitchedLoopSelector unswitched_loop_selector(loop);\n+  create_unswitched_loop_versions(loop, old_new, unswitched_loop_selector);\n+  hoist_invariant_check_casts(loop, old_new, unswitched_loop_selector);\n+  add_unswitched_loop_version_bodies_to_igvn(loop, old_new);\n@@ -197,9 +203,2 @@\n-#ifndef PRODUCT\n-  if (TraceLoopUnswitching) {\n-    tty->print_cr(\"Loop unswitching orig: %d @ %d  new: %d @ %d\",\n-                  head->_idx,                unswitch_iff->_idx,\n-                  old_new[head->_idx]->_idx, unswitch_iff_clone->_idx);\n-  }\n-#endif\n-\n-  C->print_method(PHASE_AFTER_LOOP_UNSWITCHING, 4, head_clone);\n+  LoopNode* new_head = old_new[original_head->_idx]->as_Loop();\n+  increment_unswitch_counts(original_head, new_head);\n@@ -207,0 +206,2 @@\n+  NOT_PRODUCT(trace_loop_unswitching_result(unswitched_loop_selector, original_head, new_head);)\n+  C->print_method(PHASE_AFTER_LOOP_UNSWITCHING, 4, new_head);\n@@ -210,1 +211,1 @@\n-bool PhaseIdealLoop::has_control_dependencies_from_predicates(LoopNode* head) const {\n+bool PhaseIdealLoop::has_control_dependencies_from_predicates(LoopNode* head) {\n@@ -212,1 +213,1 @@\n-  Predicates predicates(entry);\n+  const Predicates predicates(entry);\n@@ -225,42 +226,7 @@\n-\/\/-------------------------create_slow_version_of_loop------------------------\n-\/\/ Create a slow version of the loop by cloning the loop\n-\/\/ and inserting an if to select fast-slow versions.\n-\/\/ Return the inserted if.\n-IfNode* PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree *loop,\n-                                                      Node_List &old_new,\n-                                                      IfNode* unswitch_iff,\n-                                                      CloneLoopMode mode) {\n-  LoopNode* head  = loop->_head->as_Loop();\n-  Node*     entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  _igvn.rehash_node_delayed(entry);\n-  IdealLoopTree* outer_loop = loop->_parent;\n-\n-  head->verify_strip_mined(1);\n-\n-  \/\/ Add test to new \"if\" outside of loop\n-  Node *bol   = unswitch_iff->in(1)->as_Bool();\n-  IfNode* iff = (unswitch_iff->Opcode() == Op_RangeCheck) ? new RangeCheckNode(entry, bol, unswitch_iff->_prob, unswitch_iff->_fcnt) :\n-    new IfNode(entry, bol, unswitch_iff->_prob, unswitch_iff->_fcnt);\n-  register_node(iff, outer_loop, entry, dom_depth(entry));\n-  IfProjNode* iffast = new IfTrueNode(iff);\n-  register_node(iffast, outer_loop, iff, dom_depth(iff));\n-  IfProjNode* ifslow = new IfFalseNode(iff);\n-  register_node(ifslow, outer_loop, iff, dom_depth(iff));\n-\n-  \/\/ Clone the loop body.  The clone becomes the slow loop.  The\n-  \/\/ original pre-header will (illegally) have 3 control users\n-  \/\/ (old & new loops & new if).\n-  clone_loop(loop, old_new, dom_depth(head->skip_strip_mined()), mode, iff);\n-  assert(old_new[head->_idx]->is_Loop(), \"\" );\n-\n-  \/\/ Fast (true) and Slow (false) control\n-  IfProjNode* iffast_pred = iffast;\n-  IfProjNode* ifslow_pred = ifslow;\n-  clone_parse_and_assertion_predicates_to_unswitched_loop(loop, old_new, iffast_pred, ifslow_pred);\n-\n-  Node* l = head->skip_strip_mined();\n-  _igvn.replace_input_of(l, LoopNode::EntryControl, iffast_pred);\n-  set_idom(l, iffast_pred, dom_depth(l));\n-  LoopNode* slow_l = old_new[head->_idx]->as_Loop()->skip_strip_mined();\n-  _igvn.replace_input_of(slow_l, LoopNode::EntryControl, ifslow_pred);\n-  set_idom(slow_l, ifslow_pred, dom_depth(l));\n+#ifndef PRODUCT\n+void PhaseIdealLoop::trace_loop_unswitching_impossible(const LoopNode* original_head) {\n+  if (TraceLoopUnswitching) {\n+    tty->print_cr(\"Loop Unswitching \\\"%d %s\\\" not possible due to control dependencies\",\n+                  original_head->_idx, original_head->Name());\n+  }\n+}\n@@ -268,1 +234,6 @@\n-  recompute_dom_depth();\n+void PhaseIdealLoop::trace_loop_unswitching_count(IdealLoopTree* loop, LoopNode* original_head) {\n+  if (TraceLoopOpts) {\n+    tty->print(\"Unswitch   %d \", original_head->unswitch_count() + 1);\n+    loop->dump_head();\n+  }\n+}\n@@ -270,1 +241,11 @@\n-  return iff;\n+void PhaseIdealLoop::trace_loop_unswitching_result(const UnswitchedLoopSelector& unswitched_loop_selector,\n+                                                   const LoopNode* original_head, const LoopNode* new_head) {\n+  if (TraceLoopUnswitching) {\n+    IfNode* unswitch_candidate = unswitched_loop_selector.unswitch_candidate();\n+    IfNode* loop_selector = unswitched_loop_selector.selector();\n+    tty->print_cr(\"Loop Unswitching:\");\n+    tty->print_cr(\"- Unswitch-Candidate-If: %d %s\", unswitch_candidate->_idx, unswitch_candidate->Name());\n+    tty->print_cr(\"- Loop-Selector-If: %d %s\", loop_selector->_idx, loop_selector->Name());\n+    tty->print_cr(\"- True-Path-Loop (=Orig): %d %s\", original_head->_idx, original_head->Name());\n+    tty->print_cr(\"- False-Path-Loop (=Clone): %d %s\", new_head->_idx, new_head->Name());\n+  }\n@@ -272,0 +253,1 @@\n+#endif\n@@ -273,14 +255,3 @@\n-#ifdef ASSERT\n-void PhaseIdealLoop::verify_fast_loop(LoopNode* head, const ProjNode* proj_true) const {\n-  assert(proj_true->is_IfTrue(), \"must be true projection\");\n-  Node* entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  Predicates predicates(entry);\n-  if (!predicates.has_any()) {\n-    \/\/ No Parse Predicate.\n-    Node* uniqc = proj_true->unique_ctrl_out();\n-    assert((uniqc == head && !head->is_strip_mined()) || (uniqc == head->in(LoopNode::EntryControl)\n-                                                          && head->is_strip_mined()), \"must hold by construction if no predicates\");\n-  } else {\n-    \/\/ There is at least one Parse Predicate. When skipping all predicates\/predicate blocks, we should end up\n-    \/\/ at 'proj_true'.\n-    assert(proj_true == predicates.entry(), \"must hold by construction if at least one Parse Predicate\");\n+void PhaseIdealLoop::revert_to_normal_loop(const LoopNode* loop_head) {\n+  if (loop_head->is_CountedLoop() && !loop_head->as_CountedLoop()->is_normal_loop()) {\n+    loop_head->as_CountedLoop()->set_normal_loop();\n@@ -289,0 +260,42 @@\n+\n+\/\/ Class to unswitch the original loop and create Predicates at the new unswitched loop versions. The newly cloned loop\n+\/\/ becomes the false-path-loop while original loop becomes the true-path-loop.\n+class OriginalLoop : public StackObj {\n+  LoopNode* const _strip_mined_loop_head;\n+  IdealLoopTree* const _loop;\n+  Node_List* const _old_new;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  OriginalLoop(IdealLoopTree* loop, Node_List* old_new)\n+      : _strip_mined_loop_head(loop->_head->as_Loop()->skip_strip_mined()),\n+        _loop(loop),\n+        _old_new(old_new),\n+        _phase(loop->_phase) {}\n+  NONCOPYABLE(OriginalLoop);\n+\n+ private:\n+  void fix_loop_entries(IfProjNode* true_path_loop_entry, IfProjNode* false_path_loop_entry) {\n+    _phase->replace_loop_entry(_strip_mined_loop_head, true_path_loop_entry);\n+    LoopNode* false_path_loop_strip_mined_head = old_to_new(_strip_mined_loop_head)->as_Loop();\n+    _phase->replace_loop_entry(false_path_loop_strip_mined_head, false_path_loop_entry);\n+  }\n+\n+  Node* old_to_new(const Node* old) const {\n+    return _old_new->at(old->_idx);\n+  }\n+\n+#ifdef ASSERT\n+  void verify_unswitched_loop_versions(LoopNode* true_path_loop_head,\n+                                       const UnswitchedLoopSelector& unswitched_loop_selector) const {\n+    verify_unswitched_loop_version(true_path_loop_head, unswitched_loop_selector.true_path_loop_proj());\n+    verify_unswitched_loop_version(old_to_new(true_path_loop_head)->as_Loop(),\n+                                   unswitched_loop_selector.false_path_loop_proj());\n+  }\n+\n+  static void verify_unswitched_loop_version(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n+    Node* entry = loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+    const Predicates predicates(entry);\n+    \/\/ When skipping all predicates, we should end up at 'loop_selector_if_proj'.\n+    assert(loop_selector_if_proj == predicates.entry(), \"should end up at loop selector If\");\n+  }\n@@ -291,0 +304,92 @@\n+ public:\n+  \/\/ Unswitch on the invariant loop selector by creating two unswitched loop versions.\n+  void unswitch(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    _phase->clone_loop(_loop, *_old_new, _phase->dom_depth(_strip_mined_loop_head),\n+                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n+\n+    \/\/ At this point, the selector If projections are the corresponding loop entries.\n+    \/\/ clone_parse_and_assertion_predicates_to_unswitched_loop() could clone additional predicates after the selector\n+    \/\/ If projections. The loop entries are updated accordingly.\n+    IfProjNode* true_path_loop_entry = unswitched_loop_selector.true_path_loop_proj();\n+    IfProjNode* false_path_loop_entry = unswitched_loop_selector.false_path_loop_proj();\n+    _phase->clone_parse_and_assertion_predicates_to_unswitched_loop(_loop, *_old_new,\n+                                                                    true_path_loop_entry, false_path_loop_entry);\n+\n+    fix_loop_entries(true_path_loop_entry, false_path_loop_entry);\n+\n+    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n+  }\n+};\n+\n+\/\/ Create a true-path- and a false-path-loop version of the original loop by cloning the loop and inserting an If to\n+\/\/ select one of the versions at runtime. Remove the unswitch candidate If node from both unswitched loop versions.\n+void PhaseIdealLoop::create_unswitched_loop_versions(IdealLoopTree* loop, Node_List& old_new,\n+                                                     const UnswitchedLoopSelector& unswitched_loop_selector) {\n+\n+  OriginalLoop original_loop(loop, &old_new);\n+  original_loop.unswitch(unswitched_loop_selector);\n+  recompute_dom_depth();\n+\n+  remove_unswitch_candidate_from_loops(old_new, unswitched_loop_selector);\n+}\n+\n+\/\/ Remove the unswitch candidate If nodes in both unswitched loop versions which are now dominated by the loop selector\n+\/\/ If node. Keep the true path block in the true-path-loop and the false path block in the false-path-loop by setting\n+\/\/ the bool input accordingly. The unswitch candidate If nodes are folded in the next IGVN round.\n+void PhaseIdealLoop::remove_unswitch_candidate_from_loops(const Node_List& old_new,\n+                                                          const UnswitchedLoopSelector& unswitched_loop_selector) {\n+  IfNode* unswitching_candidate = unswitched_loop_selector.unswitch_candidate();\n+  _igvn.rehash_node_delayed(unswitching_candidate);\n+  dominated_by(unswitched_loop_selector.true_path_loop_proj(), unswitching_candidate);\n+\n+  IfNode* unswitching_candidate_clone = old_new[unswitching_candidate->_idx]->as_If();\n+  _igvn.rehash_node_delayed(unswitching_candidate_clone);\n+  dominated_by(unswitched_loop_selector.false_path_loop_proj(), unswitching_candidate_clone);\n+}\n+\n+\/\/ Hoist invariant CheckCastPPNodes out of each unswitched loop version to the appropriate loop selector If projection.\n+void PhaseIdealLoop::hoist_invariant_check_casts(const IdealLoopTree* loop, const Node_List& old_new,\n+                                                 const UnswitchedLoopSelector& unswitched_loop_selector) {\n+  IfNode* unswitch_candidate = unswitched_loop_selector.unswitch_candidate();\n+  IfNode* loop_selector = unswitched_loop_selector.selector();\n+  ResourceMark rm;\n+  GrowableArray<CheckCastPPNode*> loop_invariant_check_casts;\n+  for (DUIterator_Fast imax, i = unswitch_candidate->fast_outs(imax); i < imax; i++) {\n+    IfProjNode* proj = unswitch_candidate->fast_out(i)->as_IfProj();\n+    \/\/ Copy to a worklist for easier manipulation\n+    for (DUIterator_Fast jmax, j = proj->fast_outs(jmax); j < jmax; j++) {\n+      Node* check_cast = proj->fast_out(j)->isa_CheckCastPP();\n+      if (check_cast != nullptr && loop->is_invariant(check_cast->in(1))) {\n+        loop_invariant_check_casts.push(check_cast);\n+      }\n+    }\n+    IfProjNode* loop_selector_if_proj = loop_selector->proj_out(proj->_con)->as_IfProj();\n+    while (loop_invariant_check_casts.size() > 0) {\n+      CheckCastPPNode* cast = loop_invariant_check_casts.pop();\n+      Node* cast_clone = cast->clone();\n+      cast_clone->set_req(0, loop_selector_if_proj);\n+      _igvn.replace_input_of(cast, 1, cast_clone);\n+      register_new_node(cast_clone, loop_selector_if_proj);\n+      \/\/ Same for the clone\n+      Node* use_clone = old_new[cast->_idx];\n+      _igvn.replace_input_of(use_clone, 1, cast_clone);\n+    }\n+  }\n+}\n+\n+\/\/ Enable more optimizations possibilities in the next IGVN round.\n+void PhaseIdealLoop::add_unswitched_loop_version_bodies_to_igvn(IdealLoopTree* loop, const Node_List& old_new) {\n+  loop->record_for_igvn();\n+  for(int i = loop->_body.size() - 1; i >= 0 ; i--) {\n+    Node* n = loop->_body[i];\n+    Node* n_clone = old_new[n->_idx];\n+    _igvn._worklist.push(n_clone);\n+  }\n+}\n+\n+void PhaseIdealLoop::increment_unswitch_counts(LoopNode* original_head, LoopNode* new_head) {\n+  const int unswitch_count = original_head->unswitch_count() + 1;\n+  original_head->set_unswitch_count(unswitch_count);\n+  new_head->set_unswitch_count(unswitch_count);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":273,"deletions":168,"binary":false,"changes":441,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class UnswitchedLoopSelector;\n@@ -1350,0 +1351,5 @@\n+  void replace_loop_entry(LoopNode* loop_head, Node* new_entry) {\n+    _igvn.replace_input_of(loop_head, LoopNode::EntryControl, new_entry);\n+    set_idom(loop_head, new_entry, dom_depth(new_entry));\n+  }\n+\n@@ -1389,2 +1395,0 @@\n-  bool has_control_dependencies_from_predicates(LoopNode* head) const;\n-  void verify_fast_loop(LoopNode* head, const ProjNode* proj_true) const NOT_DEBUG_RETURN;\n@@ -1405,8 +1409,0 @@\n-  \/\/ Create a slow version of the loop by cloning the loop\n-  \/\/ and inserting an if to select fast-slow versions.\n-  \/\/ Return the inserted if.\n-  IfNode* create_slow_version_of_loop(IdealLoopTree *loop,\n-                                        Node_List &old_new,\n-                                        IfNode* unswitch_iff,\n-                                        CloneLoopMode mode);\n-\n@@ -1416,1 +1412,1 @@\n-  void do_unswitching (IdealLoopTree *loop, Node_List &old_new);\n+  void do_unswitching(IdealLoopTree* loop, Node_List& old_new);\n@@ -1418,2 +1414,20 @@\n-  \/\/ Find candidate \"if\" for unswitching\n-  IfNode* find_unswitching_candidate(const IdealLoopTree *loop) const;\n+  IfNode* find_unswitch_candidate(const IdealLoopTree* loop) const;\n+\n+ private:\n+  static bool has_control_dependencies_from_predicates(LoopNode* head);\n+  static void revert_to_normal_loop(const LoopNode* loop_head);\n+  void create_unswitched_loop_versions(IdealLoopTree* loop, Node_List& old_new,\n+                                       const UnswitchedLoopSelector& unswitched_loop_selector);\n+  void hoist_invariant_check_casts(const IdealLoopTree* loop, const Node_List& old_new,\n+                                   const UnswitchedLoopSelector& unswitched_loop_selector);\n+  void add_unswitched_loop_version_bodies_to_igvn(IdealLoopTree* loop, const Node_List& old_new);\n+  static void increment_unswitch_counts(LoopNode* original_head, LoopNode* new_head);\n+  void remove_unswitch_candidate_from_loops(const Node_List& old_new, const UnswitchedLoopSelector& unswitched_loop_selector);\n+#ifndef PRODUCT\n+  static void trace_loop_unswitching_count(IdealLoopTree* loop, LoopNode* original_head);\n+  static void trace_loop_unswitching_impossible(const LoopNode* original_head);\n+  static void trace_loop_unswitching_result(const UnswitchedLoopSelector& unswitched_loop_selector,\n+                                            const LoopNode* original_head, const LoopNode* new_head);\n+#endif\n+\n+ public:\n@@ -1626,0 +1640,1 @@\n+ public:\n@@ -1629,0 +1644,1 @@\n+ private:\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":29,"deletions":13,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2870,2 +2870,1 @@\n-  IfNode* new_if = (opcode == Op_If) ? new IfNode(proj2, bol, iff->_prob, iff->_fcnt):\n-    new RangeCheckNode(proj2, bol, iff->_prob, iff->_fcnt);\n+  IfNode* new_if = IfNode::make_with_same_profile(iff, proj2, bol);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}