{"files":[{"patch":"@@ -1716,6 +1716,1 @@\n-        FormatStyle fStyle;\n-        try {\n-            fStyle = FormatStyle.fromString(style);\n-        } catch (IllegalArgumentException iae) {\n-            fStyle = FormatStyle.SUBFORMATPATTERN;\n-        }\n+        FormatStyle fStyle = FormatStyle.fromString(style);\n@@ -1979,0 +1974,1 @@\n+    \/\/ WARNING: fromString is dependent on ordinal positioning and Enum names.\n@@ -1980,25 +1976,21 @@\n-        DEFAULT(\"\"),\n-        SHORT(\"short\"),\n-        MEDIUM(\"medium\"),\n-        LONG(\"long\"),\n-        FULL(\"full\"),\n-        INTEGER(\"integer\"),\n-        CURRENCY(\"currency\"),\n-        PERCENT(\"percent\"),\n-        COMPACT_SHORT(\"compact_short\"),\n-        COMPACT_LONG(\"compact_long\"),\n-        OR(\"or\"),\n-        UNIT(\"unit\"),\n-        SUBFORMATPATTERN(null);\n-\n-        private final String text;\n-\n-        \/\/ Differs from FormatType in that the text String is\n-        \/\/ not guaranteed to match the Enum name, thus a text field is used\n-        FormatStyle(String text) {\n-            this.text = text;\n-        }\n-\n-        \/\/ This method returns a FormatStyle (excluding SUBFORMATPATTERN)\n-        \/\/ that matches the passed String. If no FormatStyle is found,\n-        \/\/ an IllegalArgumentException is thrown\n+        \/\/ Special styles\n+        DEFAULT,\n+        SUBFORMATPATTERN,\n+        \/\/ Pre-defined styles\n+        SHORT,\n+        MEDIUM,\n+        LONG,\n+        FULL,\n+        INTEGER,\n+        CURRENCY,\n+        PERCENT,\n+        COMPACT_SHORT,\n+        COMPACT_LONG,\n+        OR,\n+        UNIT;\n+\n+        \/\/ Returns a FormatStyle corresponding to the input text.\n+        \/\/ DEFAULT is the empty String.\n+        \/\/ Pre-defined styles are lower case versions of their enum name\n+        \/\/ (but compared case-insensitive for historical compatibility).\n+        \/\/ SUBFORMATPATTERN is anything else.\n@@ -2006,5 +1998,10 @@\n-            for (FormatStyle style : values()) {\n-                \/\/ Also check trimmed case-insensitive for historical reasons\n-                if (style != FormatStyle.SUBFORMATPATTERN &&\n-                        text.trim().compareToIgnoreCase(style.text) == 0) {\n-                    return style;\n+            var style = text.trim();\n+            if (style.isEmpty()) {\n+                return FormatStyle.DEFAULT;\n+            }\n+            var styles = values();\n+            \/\/ Match starting at the pre-defined styles -> [SHORT:]\n+            for (int i = SHORT.ordinal(); i < styles.length; i ++) {\n+                var fStyle = styles[i];\n+                if (style.compareToIgnoreCase(fStyle.name()) == 0) {\n+                    return fStyle;\n@@ -2013,1 +2010,1 @@\n-            throw new IllegalArgumentException();\n+            return FormatStyle.SUBFORMATPATTERN;\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":34,"deletions":37,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +55,2 @@\n+    private String choicePattern;\n+    private String numberPattern;\n@@ -63,0 +66,2 @@\n+        choicePattern = \"{0,choice,0#|1#{1}|2#{1} ({2})}\";\n+        numberPattern = \"{0,number,000}\";\n@@ -75,0 +80,10 @@\n+    @Benchmark\n+    public MessageFormat testSubformatChoice() {\n+        return new MessageFormat(choicePattern);\n+    }\n+\n+    @Benchmark\n+    public MessageFormat testSubformatNumber() {\n+        return new MessageFormat(numberPattern);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/MessageFormatterBench.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}