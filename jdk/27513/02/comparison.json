{"files":[{"patch":"@@ -228,6 +228,0 @@\n-  MemRegion cmr((HeapWord*)_virtual_space.low(),\n-                (HeapWord*)_virtual_space.high());\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  gch->rem_set()->resize_covered_region(cmr);\n-\n@@ -238,0 +232,2 @@\n+  init_spaces();\n+\n@@ -259,1 +255,0 @@\n-  compute_space_boundaries(0, SpaceDecorator::Clear, SpaceDecorator::Mangle);\n@@ -271,9 +266,4 @@\n-void DefNewGeneration::compute_space_boundaries(uintx minimum_eden_size,\n-                                                bool clear_space,\n-                                                bool mangle_space) {\n-  \/\/ If the spaces are being cleared (only done at heap initialization\n-  \/\/ currently), the survivor spaces need not be empty.\n-  \/\/ Otherwise, no care is taken for used areas in the survivor spaces\n-  \/\/ so check.\n-  assert(clear_space || (to()->is_empty() && from()->is_empty()),\n-    \"Initialization of the survivor spaces assumes these are empty\");\n+void DefNewGeneration::init_spaces() {\n+  \/\/ Using layout: from, to, eden, so only from can be non-empty.\n+  assert(eden()->is_empty(), \"precondition\");\n+  assert(to()->is_empty(), \"precondition\");\n@@ -281,11 +271,2 @@\n-  \/\/ Compute sizes\n-  uintx size = _virtual_space.committed_size();\n-  uintx survivor_size = compute_survivor_size(size, SpaceAlignment);\n-  uintx eden_size = size - (2*survivor_size);\n-  if (eden_size > max_eden_size()) {\n-    \/\/ Need to reduce eden_size to satisfy the max constraint. The delta needs\n-    \/\/ to be 2*SpaceAlignment aligned so that both survivors are properly\n-    \/\/ aligned.\n-    uintx eden_delta = align_up(eden_size - max_eden_size(), 2*SpaceAlignment);\n-    eden_size     -= eden_delta;\n-    survivor_size += eden_delta\/2;\n+  if (!from()->is_empty()) {\n+    assert((char*) from()->bottom() == _virtual_space.low(), \"inv\");\n@@ -293,1 +274,0 @@\n-  assert(eden_size > 0 && survivor_size <= eden_size, \"just checking\");\n@@ -295,11 +275,7 @@\n-  if (eden_size < minimum_eden_size) {\n-    \/\/ May happen due to 64Kb rounding, if so adjust eden size back up\n-    minimum_eden_size = align_up(minimum_eden_size, SpaceAlignment);\n-    uintx maximum_survivor_size = (size - minimum_eden_size) \/ 2;\n-    uintx unaligned_survivor_size =\n-      align_down(maximum_survivor_size, SpaceAlignment);\n-    survivor_size = MAX2(unaligned_survivor_size, SpaceAlignment);\n-    eden_size = size - (2*survivor_size);\n-    assert(eden_size > 0 && survivor_size <= eden_size, \"just checking\");\n-    assert(eden_size >= minimum_eden_size, \"just checking\");\n-  }\n+  \/\/ Compute sizes\n+  size_t size = _virtual_space.committed_size();\n+  size_t survivor_size = compute_survivor_size(size, SpaceAlignment);\n+  assert(survivor_size >= from()->used(), \"inv\");\n+  assert(size > 2 * survivor_size, \"inv\");\n+  size_t eden_size = size - (2 * survivor_size);\n+  assert(eden_size > 0 && survivor_size <= eden_size, \"just checking\");\n@@ -307,4 +283,5 @@\n-  char *eden_start = _virtual_space.low();\n-  char *from_start = eden_start + eden_size;\n-  char *to_start   = from_start + survivor_size;\n-  char *to_end     = to_start   + survivor_size;\n+  \/\/ layout: from, to, eden\n+  char* from_start = _virtual_space.low();\n+  char* to_start = from_start + survivor_size;\n+  char* eden_start = to_start + survivor_size;\n+  char* eden_end = eden_start + eden_size;\n@@ -312,2 +289,1 @@\n-  assert(to_end == _virtual_space.high(), \"just checking\");\n-  assert(is_aligned(eden_start, SpaceAlignment), \"checking alignment\");\n+  assert(eden_end == _virtual_space.high(), \"just checking\");\n@@ -316,0 +292,2 @@\n+  assert(is_aligned(eden_start, SpaceAlignment), \"checking alignment\");\n+  assert(is_aligned(eden_end, SpaceAlignment), \"checking alignment\");\n@@ -317,1 +295,0 @@\n-  MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)from_start);\n@@ -319,6 +296,2 @@\n-  MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)to_end);\n-\n-  \/\/ A minimum eden size implies that there is a part of eden that\n-  \/\/ is being used and that affects the initialization of any\n-  \/\/ newly formed eden.\n-  bool live_in_eden = minimum_eden_size > 0;\n+  MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)eden_start);\n+  MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);\n@@ -327,12 +300,11 @@\n-  eden()->initialize(edenMR,\n-                     clear_space && !live_in_eden,\n-                     SpaceDecorator::Mangle);\n-  \/\/ If clear_space and live_in_eden, we will not have cleared any\n-  \/\/ portion of eden above its top. This can cause newly\n-  \/\/ expanded space not to be mangled if using ZapUnusedHeapArea.\n-  \/\/ We explicitly do such mangling here.\n-  if (ZapUnusedHeapArea && clear_space && live_in_eden && mangle_space) {\n-    eden()->mangle_unused_area();\n-  }\n-  from()->initialize(fromMR, clear_space, mangle_space);\n-  to()->initialize(toMR, clear_space, mangle_space);\n+  from()->initialize(fromMR, from()->is_empty(), SpaceDecorator::Mangle);\n+  to()->initialize(toMR, true, SpaceDecorator::Mangle);\n+  eden()->initialize(edenMR, true, SpaceDecorator::Mangle);\n+\n+  post_resize();\n+}\n+\n+void DefNewGeneration::post_resize() {\n+  MemRegion cmr((HeapWord*)_virtual_space.low(),\n+                (HeapWord*)_virtual_space.high());\n+  SerialHeap::heap()->rem_set()->resize_covered_region(cmr);\n@@ -354,1 +326,3 @@\n-  HeapWord* prev_high = (HeapWord*) _virtual_space.high();\n+  assert(bytes != 0, \"precondition\");\n+  assert(is_aligned(bytes, SpaceAlignment), \"precondition\");\n+\n@@ -356,7 +330,2 @@\n-  if (success && ZapUnusedHeapArea) {\n-    \/\/ Mangle newly committed space immediately because it\n-    \/\/ can be done here more simply that after the new\n-    \/\/ spaces have been computed.\n-    HeapWord* new_high = (HeapWord*) _virtual_space.high();\n-    MemRegion mangle_region(prev_high, new_high);\n-    SpaceMangler::mangle_region(mangle_region);\n+  if (!success) {\n+    log_info(gc)(\"Failed to expand young-gen by %zu bytes\", bytes);\n@@ -368,0 +337,11 @@\n+void DefNewGeneration::expand_eden_by(size_t delta_bytes) {\n+  if (!expand(delta_bytes)) {\n+    return;\n+  }\n+\n+  MemRegion eden_mr{eden()->bottom(), (HeapWord*)_virtual_space.high()};\n+  eden()->initialize(eden_mr, eden()->is_empty(), SpaceDecorator::Mangle);\n+\n+  post_resize();\n+}\n+\n@@ -400,12 +380,2 @@\n-void DefNewGeneration::compute_new_size() {\n-  \/\/ This is called after a GC that includes the old generation, so from-space\n-  \/\/ will normally be empty.\n-  \/\/ Note that we check both spaces, since if scavenge failed they revert roles.\n-  \/\/ If not we bail out (otherwise we would have to relocate the objects).\n-  if (!from()->is_empty() || !to()->is_empty()) {\n-    return;\n-  }\n-\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  size_t old_size = gch->old_gen()->capacity();\n+size_t DefNewGeneration::calculate_desired_young_gen_bytes() const {\n+  size_t old_size = SerialHeap::heap()->old_gen()->capacity();\n@@ -432,8 +402,32 @@\n-  assert(desired_new_size <= max_new_size, \"just checking\");\n-\n-  bool changed = false;\n-  if (desired_new_size > new_size_before) {\n-    size_t change = desired_new_size - new_size_before;\n-    assert(change % alignment == 0, \"just checking\");\n-    if (expand(change)) {\n-       changed = true;\n+  if (!from()->is_empty()) {\n+    \/\/ Mininum constraint to hold all live objs inside from-space.\n+    size_t min_survivor_size = align_up(from()->used(), alignment);\n+\n+    \/\/ SurvivorRatio := eden_size \/ survivor_size\n+    \/\/ young-gen-size = eden_size                     + 2 * survivor_size\n+    \/\/                = SurvivorRatio * survivor_size + 2 * survivor_size\n+    \/\/                = (SurvivorRatio + 2) * survivor_size\n+    size_t min_young_gen_size = min_survivor_size * (SurvivorRatio + 2);\n+\n+    desired_new_size = MAX2(min_young_gen_size, desired_new_size);\n+  }\n+  assert(is_aligned(desired_new_size, alignment), \"postcondition\");\n+\n+  return desired_new_size;\n+}\n+\n+void DefNewGeneration::resize_inner() {\n+  assert(eden()->is_empty(), \"precondition\");\n+  assert(to()->is_empty(), \"precondition\");\n+\n+  size_t current_young_gen_size_bytes = _virtual_space.committed_size();\n+  size_t desired_young_gen_size_bytes = calculate_desired_young_gen_bytes();\n+  if (current_young_gen_size_bytes == desired_young_gen_size_bytes) {\n+    return;\n+  }\n+\n+  \/\/ Commit\/uncommit\n+  if (desired_young_gen_size_bytes > current_young_gen_size_bytes) {\n+    size_t delta_bytes = desired_young_gen_size_bytes - current_young_gen_size_bytes;\n+    if (!expand(delta_bytes)) {\n+      return;\n@@ -441,31 +435,43 @@\n-    \/\/ If the heap failed to expand to the desired size,\n-    \/\/ \"changed\" will be false.  If the expansion failed\n-    \/\/ (and at this point it was expected to succeed),\n-    \/\/ ignore the failure (leaving \"changed\" as false).\n-  }\n-  if (desired_new_size < new_size_before && eden()->is_empty()) {\n-    \/\/ bail out of shrinking if objects in eden\n-    size_t change = new_size_before - desired_new_size;\n-    assert(change % alignment == 0, \"just checking\");\n-    _virtual_space.shrink_by(change);\n-    changed = true;\n-  }\n-  if (changed) {\n-    \/\/ The spaces have already been mangled at this point but\n-    \/\/ may not have been cleared (set top = bottom) and should be.\n-    \/\/ Mangling was done when the heap was being expanded.\n-    compute_space_boundaries(eden()->used(),\n-                             SpaceDecorator::Clear,\n-                             SpaceDecorator::DontMangle);\n-    MemRegion cmr((HeapWord*)_virtual_space.low(),\n-                  (HeapWord*)_virtual_space.high());\n-    gch->rem_set()->resize_covered_region(cmr);\n-\n-    log_debug(gc, ergo, heap)(\n-        \"New generation size %zuK->%zuK [eden=%zuK,survivor=%zuK]\",\n-        new_size_before\/K, _virtual_space.committed_size()\/K,\n-        eden()->capacity()\/K, from()->capacity()\/K);\n-    log_trace(gc, ergo, heap)(\n-        \"  [allowed %zuK extra for %d threads]\",\n-          thread_increase_size\/K, threads_count);\n-      }\n+  } else {\n+    size_t delta_bytes = current_young_gen_size_bytes - desired_young_gen_size_bytes;\n+    _virtual_space.shrink_by(delta_bytes);\n+  }\n+\n+  assert(desired_young_gen_size_bytes == _virtual_space.committed_size(), \"inv\");\n+\n+  init_spaces();\n+\n+  log_debug(gc, ergo, heap)(\"New generation size %zuK->%zuK [eden=%zuK,survivor=%zuK]\",\n+    current_young_gen_size_bytes\/K, _virtual_space.committed_size()\/K,\n+    eden()->capacity()\/K, from()->capacity()\/K);\n+}\n+\n+void DefNewGeneration::resize_after_young_gc() {\n+  \/\/ Called only after successful young-gc.\n+  assert(eden()->is_empty(), \"precondition\");\n+  assert(to()->is_empty(), \"precondition\");\n+\n+  if ((char*)to()->bottom() == _virtual_space.low()) {\n+    \/\/ layout: to, from, eden; can't resize.\n+    return;\n+  }\n+\n+  assert((char*)from()->bottom() == _virtual_space.low(), \"inv\");\n+  resize_inner();\n+}\n+\n+void DefNewGeneration::resize_after_full_gc() {\n+  if (eden()->is_empty() && from()->is_empty() && to()->is_empty()) {\n+    resize_inner();\n+    return;\n+  }\n+\n+  \/\/ Usually the young-gen is empty after full-gc.\n+  \/\/ This is the extreme case; expand young-gen to its max size.\n+  if (_virtual_space.uncommitted_size() == 0) {\n+    \/\/ Already at its max size.\n+    return;\n+  }\n+\n+  \/\/ Keep from\/to and expand eden.\n+  expand_eden_by(_virtual_space.uncommitted_size());\n@@ -486,1 +492,0 @@\n-\n@@ -492,1 +497,0 @@\n-\n@@ -500,1 +504,2 @@\n-  return reserved_bytes - compute_survivor_size(reserved_bytes, SpaceAlignment);\n+  const size_t min_survivor_bytes = SpaceAlignment;\n+  return reserved_bytes - min_survivor_bytes;\n@@ -592,1 +597,0 @@\n-  to()->clear(SpaceDecorator::Mangle);\n@@ -842,7 +846,12 @@\n-HeapWord* DefNewGeneration::allocate(size_t word_size) {\n-  \/\/ This is the slow-path allocation for the DefNewGeneration.\n-  \/\/ Most allocations are fast-path in compiled code.\n-  \/\/ We try to allocate from the eden.  If that works, we are happy.\n-  \/\/ Note that since DefNewGeneration supports lock-free allocation, we\n-  \/\/ have to use it here, as well.\n-  HeapWord* result = eden()->par_allocate(word_size);\n+HeapWord* DefNewGeneration::expand_and_allocate(size_t word_size) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+  assert(Thread::current()->is_VM_thread(), \"precondition\");\n+\n+  size_t eden_free_bytes = eden()->free();\n+  size_t requested_bytes = word_size * HeapWordSize;\n+  if (eden_free_bytes < requested_bytes) {\n+    size_t expand_bytes = requested_bytes - eden_free_bytes;\n+    expand_eden_by(align_up(expand_bytes, SpaceAlignment));\n+  }\n+\n+  HeapWord* result = eden()->allocate(word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":143,"deletions":134,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -134,0 +134,7 @@\n+  size_t calculate_desired_young_gen_bytes() const;\n+\n+  void expand_eden_by(size_t delta_bytes);\n+\n+  void resize_inner();\n+  void post_resize();\n+\n@@ -186,2 +193,0 @@\n-  \/\/ Allocate requested size or return null; single-threaded and lock-free versions.\n-  HeapWord* allocate(size_t word_size);\n@@ -189,0 +194,1 @@\n+  HeapWord* expand_and_allocate(size_t word_size);\n@@ -199,2 +205,2 @@\n-  \/\/ GC support\n-  void compute_new_size();\n+  void resize_after_young_gc();\n+  void resize_after_full_gc();\n@@ -223,7 +229,3 @@\n- protected:\n-  \/\/ If clear_space is true, clear the survivor spaces.  Eden is\n-  \/\/ cleared if the minimum size of eden is 0.  If mangle_space\n-  \/\/ is true, also mangle the space in debug mode.\n-  void compute_space_boundaries(uintx minimum_eden_size,\n-                                bool clear_space,\n-                                bool mangle_space);\n+ private:\n+  \/\/ Initialize eden\/from\/to spaces.\n+  void init_spaces();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-  HeapWord* result = _young_gen->allocate(size);\n+  HeapWord* result = _young_gen->expand_and_allocate(size);\n@@ -286,1 +286,1 @@\n-  if (result == nullptr) {\n+  if (result == nullptr && !is_tlab) {\n@@ -403,0 +403,1 @@\n+    _young_gen->resize_after_young_gc();\n@@ -409,2 +410,0 @@\n-  _young_gen->compute_new_size();\n-\n@@ -596,1 +595,1 @@\n-  _young_gen->compute_new_size();\n+  _young_gen->resize_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -58,4 +58,4 @@\n-\/\/ +-----------------+--------+--------+--------+---------------+-------------------+\n-\/\/ |       eden      |  from  |   to   |        |      old      |                   |\n-\/\/ |                 |  (to)  | (from) |        |               |                   |\n-\/\/ +-----------------+--------+--------+--------+---------------+-------------------+\n+\/\/ +--------+--------+-----------------+--------+---------------+-------------------+\n+\/\/ |  from  |   to   |       eden      |        |      old      |                   |\n+\/\/ |  (to)  | (from) |                 |        |               |                   |\n+\/\/ +--------+--------+-----------------+--------+---------------+-------------------+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,1 +56,4 @@\n-    clear(mangle_space);\n+    clear(SpaceDecorator::DontMangle);\n+  }\n+  if (ZapUnusedHeapArea && mangle_space) {\n+    mangle_unused_area();\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}