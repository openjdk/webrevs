{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n+\n@@ -70,1 +73,1 @@\n-        String hoststr, portstr = null;\n+        String hoststr = null, portstr = null;\n@@ -80,1 +83,2 @@\n-                throw new IllegalArgumentException(\"invalid IPv6 address: \" + str);\n+                throwException(IllegalArgumentException.class, \"invalid IPv6 address%s\",\n+                               filterNetInfo(str).prefixWith(\": \"));\n@@ -159,1 +163,2 @@\n-            throw new IllegalArgumentException(\"invalid port range: \" + portstr);\n+            throwException(IllegalArgumentException.class, \"invalid port range%s\",\n+                           filterNetInfo(portstr).prefixWith(\": \"));\n","filename":"src\/java.base\/share\/classes\/java\/net\/HostPortrange.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import static jdk.internal.util.Exceptions.filterLookupInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -41,1 +43,1 @@\n-            throw new UnknownHostException(hostname);\n+            throwException(UnknownHostException.class, filterLookupInfo(hostname));\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4AddressImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+import static jdk.internal.util.Exceptions.filterLookupInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -584,1 +586,2 @@\n-                throw new UnknownHostException(addressLiteral + \": invalid IPv4-mapped address\");\n+                throwException(UnknownHostException.class, \"%sinvalid IPv4-mapped address\",\n+                               filterLookupInfo(addressLiteral).suffixWith(\": \"));\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6Address.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+import jdk.internal.util.Exceptions;\n@@ -71,0 +72,3 @@\n+import static jdk.internal.util.Exceptions.exception;\n+import static jdk.internal.util.Exceptions.filterLookupInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -385,0 +389,1 @@\n+        Exceptions.setup(); \/\/ needed for native exceptions\n@@ -905,1 +910,1 @@\n-                throw new UnknownHostException(host);\n+                throwException(UnknownHostException.class, filterLookupInfo(host));\n@@ -1098,1 +1103,5 @@\n-                        throw ex == null ? new UnknownHostException(host) : ex;\n+                        if (ex == null) {\n+                            throwException(UnknownHostException.class, filterLookupInfo(host));\n+                        } else {\n+                            throw ex;\n+                        }\n@@ -1206,3 +1215,5 @@\n-                throw new UnknownHostException(\"Unable to resolve address \"\n-                        + Arrays.toString(addr) + \" as hosts file \" + hostsFile\n-                        + \" not found \");\n+                throwException(UnknownHostException.class,\n+                               \"Unable to resolve address %s as hosts file %s not found\",\n+                               filterLookupInfo(Arrays.toString(addr)),\n+                               filterLookupInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\"));\n@@ -1212,4 +1223,5 @@\n-                throw new UnknownHostException(\"Requested address \"\n-                        + Arrays.toString(addr)\n-                        + \" resolves to an invalid entry in hosts file \"\n-                        + hostsFile);\n+                throwException(UnknownHostException.class,\n+                               \"Requested address %s resolves to an invalid entry in hosts file %s\",\n+                               filterLookupInfo(Arrays.toString(addr)),\n+                               filterLookupInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\"));\n@@ -1276,2 +1288,5 @@\n-                throw new UnknownHostException(\"Unable to resolve host \" + host\n-                        + \" as hosts file \" + hostsFile + \" not found \");\n+                throwException(UnknownHostException.class,\n+                               \"Unable to resolve host %s as hosts file %s not found\",\n+                               filterLookupInfo(host), filterLookupInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\"));\n+\n@@ -1308,2 +1323,3 @@\n-                throw new UnknownHostException(\"Unable to resolve host \" + hostName\n-                        + \" in hosts file \" + hostsFile);\n+                throwException(UnknownHostException.class, \"Unable to resolve host %s in hosts file %s\",\n+                               filterLookupInfo(hostName), filterLookupInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\"));\n@@ -1546,1 +1562,2 @@\n-                    var uhe = new UnknownHostException(host);\n+                    UnknownHostException uhe = exception(UnknownHostException.class,\n+                                                         filterLookupInfo(host));\n@@ -1573,1 +1590,2 @@\n-        return new UnknownHostException(hostString + \": invalid IPv6 address literal\");\n+        return exception(UnknownHostException.class, \"%sinvalid IPv6 address literal\",\n+                         filterLookupInfo(hostString).suffixWith(\": \"));\n@@ -1711,1 +1729,2 @@\n-            throw ex == null ? new UnknownHostException(host) : ex;\n+            throw ex == null ? exception(UnknownHostException.class, filterLookupInfo(host))\n+                             : ex;\n@@ -1783,3 +1802,2 @@\n-                UnknownHostException uhe2 =\n-                        new UnknownHostException(local + \": \" +\n-                                uhe.getMessage());\n+                    UnknownHostException uhe2 = exception(UnknownHostException.class,\n+                        filterLookupInfo(local).suffixWith(\": \") + uhe.getMessage());\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -326,1 +328,2 @@\n-            throw new IllegalArgumentException(\"invalid address type: \" + addr);\n+            throwException(IllegalArgumentException.class, \"invalid address type%s\",\n+                           filterNetInfo(addr.toString()).prefixWith(\": \"));\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetworkInterface.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -96,2 +98,6 @@\n-        if ((type == Type.DIRECT) || !(sa instanceof InetSocketAddress))\n-            throw new IllegalArgumentException(\"type \" + type + \" is not compatible with address \" + sa);\n+        if ((type == Type.DIRECT) || !(sa instanceof InetSocketAddress)) {\n+            throwException(IllegalArgumentException.class,\n+                           \"type \" + type + \" is not compatible with address %s\",\n+                           filterNetInfo(sa.toString())\n+                               .replaceWith(\"type \" + sa.getClass().toString()));\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/Proxy.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -395,2 +397,2 @@\n-                throw new\n-                    IllegalArgumentException(\"invalid host\/port: \"+host);\n+                throwException(IllegalArgumentException.class,\n+                               \"invalid host\/port%s\", filterNetInfo(host).prefixWith(\": \"));\n@@ -413,2 +415,2 @@\n-                throw new\n-                    IllegalArgumentException(\"invalid port range: \"+port);\n+                throwException(IllegalArgumentException.class,\n+                               \"invalid port range%s\", filterNetInfo(port).prefixWith(\": \"));\n@@ -787,1 +789,1 @@\n-            throw new UnknownHostException(getName());\n+            throwException(UnknownHostException.class, filterNetInfo(getName()));\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import static jdk.internal.util.Exceptions.filterSocketInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -333,1 +335,1 @@\n-                throw new UnknownHostException(epoint.toString());\n+                throwException(UnknownHostException.class, filterSocketInfo(epoint.toString()));\n@@ -352,1 +354,1 @@\n-                throw new UnknownHostException(epoint.toString());\n+                throwException(UnknownHostException.class, filterSocketInfo(epoint.toString()));\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocksSocketImpl.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import jdk.internal.util.Exceptions;\n@@ -47,0 +48,3 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwURISyntaxException;\n+\n@@ -2035,1 +2039,1 @@\n-                throw new URISyntaxException(s, \"Relative path in absolute URI\");\n+                throwURISyntaxException(\"%s\", \"Relative path in absolute URI\", -1, filterNetInfo(s));\n@@ -2991,1 +2995,1 @@\n-            throw new URISyntaxException(input, reason);\n+            throwURISyntaxException(\"%s\", reason, -1, filterNetInfo(input));\n@@ -2995,1 +2999,4 @@\n-            throw new URISyntaxException(input, reason, p);\n+            if (!Exceptions.enhancedNetExceptions()) {\n+                p = -1;\n+            }\n+            throwURISyntaxException(\"%s\", reason, p, filterNetInfo(input));\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+import static jdk.internal.util.Exceptions.throwURISyntaxException;\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n@@ -1171,1 +1173,2 @@\n-            if (s != null) throw new URISyntaxException(authority, s);\n+            if (s != null)\n+                throwURISyntaxException(\"%s\", s, -1, filterNetInfo(authority));\n","filename":"src\/java.base\/share\/classes\/java\/net\/URL.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import static jdk.internal.util.Exceptions.throwException;\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+\n@@ -208,2 +211,2 @@\n-                            throw new IllegalArgumentException(\n-                                \"Invalid host: \"+ host);\n+                            throwException(IllegalArgumentException.class, \"Invalid host%s\",\n+                                           filterNetInfo(host).prefixWith(\": \"));\n@@ -222,2 +225,2 @@\n-                                throw new IllegalArgumentException(\n-                                    \"Invalid authority field: \" + authority);\n+                                throwException(IllegalArgumentException.class, \"Invalid authority field%s\",\n+                                               filterNetInfo(authority).prefixWith(\": \"));\n@@ -227,2 +230,2 @@\n-                        throw new IllegalArgumentException(\n-                            \"Invalid authority field: \" + authority);\n+                        throwException(IllegalArgumentException.class, \"Invalid authority field%s\",\n+                                       filterNetInfo(authority).prefixWith(\": \"));\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLStreamHandler.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnixDomainSocketAddress;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import sun.security.util.SecurityProperties;\n+import jdk.internal.misc.VM;\n+\n+\/**\n+ * Contains static utility methods which can filter exception\n+ * message strings for sensitive information.\n+ *\n+ * Code using this mechanism should use one of the static throwException\n+ * methods below to generate and throw the exception in one method.\n+ * exception() methods are also provided to generate an exception which\n+ * then be modified before being thrown or used. Lastly, formatMsg()\n+ * can generate a formatted (enhanced or restricted) string only.\n+ *\n+ * The methods above take variable numbers of SensitiveInfo objects\n+ * as parameters which contain the text that may have to be filtered.\n+ *\n+ * The SensitiveInfo objects should be generated with one of the following:\n+ *     public static SensitiveInfo filterLookupInfo(String host)\n+ *     public static SensitiveInfo filterSocketInfo(String s)\n+ *     public static SensitiveInfo filterNetInfo(String s)\n+ *     public static SensitiveInfo filterJarName(String name)\n+ *     public static SensitiveInfo filterUserName(String name)\n+ *\/\n+public final class Exceptions {\n+    private Exceptions() {}\n+\n+    private static volatile boolean enhancedSocketExceptionText;\n+    private static volatile boolean enhancedNetExceptionText;\n+    private static volatile boolean enhancedLookupExceptionText;\n+    private static volatile boolean enhancedUserExceptionText;\n+    private static volatile boolean enhancedJarExceptionText;\n+    private static volatile boolean initialized = false;\n+\n+    \/**\n+     * Base class for generating exception messages that may\n+     * contain sensitive information which in certain contexts\n+     * needs to be filtered out, in case it gets revealed in\n+     * unexpected places. Exception messages are either enhanced\n+     * or restricted. Enhanced messages include sensitive information.\n+     * Restricted messages don't.\n+     *\n+     * Sub-class for any new category that needs to be independently\n+     * controlled. Consider using a unique value for the\n+     * SecurityProperties.includedInExceptions(String value) mechanism\n+     * Current values defined are \"socket\", \"jar\", \"userInfo\"\n+     * \"net\", \"addressLookup\". The value \"hostInfo\" exists for\n+     * compatibility and is the same as the combination of\n+     * \"socket,addressLookup,net\"\n+     * New code can also piggy back on existing categories\n+     *\n+     * A SensitiveInfo contains the following components\n+     * all of which default to empty strings.\n+     *\n+     * prefix, the sensitive info itself, a suffix\n+     * and a replacement string.\n+     *\n+     * The output(boolean enhance) method generates an enhanced\n+     * string when enhance is true.\n+     * This comprises (enhance == true)\n+     *     prefix + info + suffix\n+     * When (enhance == false), then by default the output is:\n+     *     \"\" empty string\n+     * However, if a replacement is set, then when enhance == false\n+     * the output is the replacement string.\n+     *\/\n+    public abstract static class SensitiveInfo {\n+        String info, suffix, prefix, replacement;\n+        boolean enhanced;\n+\n+        SensitiveInfo(String info) {\n+            this.info = info;\n+            prefix = suffix = replacement = \"\";\n+        }\n+        public SensitiveInfo prefixWith(String prefix) {\n+            this.prefix = prefix;\n+            return this;\n+        }\n+        public SensitiveInfo suffixWith(String suffix) {\n+            this.suffix = suffix;\n+            return this;\n+        }\n+        public SensitiveInfo replaceWith(String replacement) {\n+            this.replacement = replacement;\n+            return this;\n+        }\n+\n+        public boolean enhanced() {\n+            return enhanced;\n+        }\n+\n+        \/**\n+         * Implementation should call output(boolean flag)\n+         * where flag contains the boolean value of whether\n+         * the category is enabled or not.\n+         *\/\n+        public abstract String output();\n+\n+        protected String output(boolean enhance) {\n+            if (enhance) {\n+                this.enhanced = true;\n+                return prefix + info + suffix;\n+            } else {\n+                return replacement;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Throw an exception of the given class (which has a single arg (String) constructor\n+     * with the given format string. For each %s in the format string, there must be a\n+     * SensitiveInfo following that generates a message string in either enhanced or\n+     * restricted mode. The entire string is then passed to the exception constructor\n+     * Format specifiers other than %s are not supported, and will cause a runtime exception.\n+     *\/\n+    public static <X extends Throwable> void throwException(Class<X> exClass, String format,\n+                                                            SensitiveInfo... infos) throws X\n+    {\n+        throw exception(exClass, format, infos);\n+    }\n+\n+    \/**\n+     * Simplified version of above with one SensitiveInfo and a \"%s\" format string\n+     *\/\n+    public static <X extends Throwable> void throwException(Class<X> exClass, SensitiveInfo... infos) throws X\n+    {\n+        throwException(exClass, \"%s\", infos);\n+    }\n+\n+    \/**\n+     * Returns the exception without throwing it\n+     *\/\n+    public static <X extends Throwable> X exception(Class<X> exClass, String format,\n+                                                    SensitiveInfo... infos)\n+    {\n+        try {\n+            Constructor<X> ctor = exClass.getConstructor(String.class);\n+            String msg = formatMsg(format, infos);\n+            return ctor.newInstance(msg);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    public static <X extends Throwable> X exception(Class<X> exClass, SensitiveInfo... infos)\n+    {\n+        return exception(exClass, \"%s\", infos);\n+    }\n+\n+    \/**\n+     * Special case for URISyntaxException (has two additional parameters)\n+     *\/\n+    public static URISyntaxException throwURISyntaxException(String format, String arg2,\n+                                                             int index, SensitiveInfo... infos)\n+    throws URISyntaxException\n+    {\n+        String msg = formatMsg(format, infos);\n+        URISyntaxException ex = new URISyntaxException(msg, arg2, index);\n+        throw ex;\n+    }\n+\n+    static final class SocketInfo extends SensitiveInfo {\n+        public SocketInfo(String host) {\n+             super(host);\n+        }\n+        @Override\n+        public String output() {\n+            setup();\n+            return super.output(enhancedSocketExceptionText);\n+        }\n+    }\n+\n+    static final class NetInfo extends SensitiveInfo {\n+        public NetInfo(String host) {\n+             super(host);\n+        }\n+        @Override\n+        public String output() {\n+            setup();\n+            return super.output(enhancedNetExceptionText);\n+        }\n+    }\n+\n+\n+    static final class LookupInfo extends SensitiveInfo {\n+        public LookupInfo(String host) {\n+             super(host);\n+        }\n+        @Override\n+        public String output() {\n+            setup();\n+            return super.output(enhancedLookupExceptionText);\n+        }\n+    }\n+\n+    static final class JarInfo extends SensitiveInfo {\n+        public JarInfo(String name) {\n+             super(name);\n+        }\n+        @Override\n+        public String output() {\n+            setup();\n+            return super.output(enhancedJarExceptionText);\n+        }\n+    }\n+\n+    static final class UserInfo extends SensitiveInfo {\n+        public UserInfo(String host) {\n+             super(host);\n+        }\n+        @Override\n+        public String output() {\n+            setup();\n+            return super.output(enhancedUserExceptionText);\n+        }\n+    }\n+\n+    \/\/ remove leading, trailing and duplicated space characters\n+    static String trim(String s) {\n+        int len = s.length();\n+        if (len == 0) return s;\n+\n+        StringBuilder sb = new StringBuilder();\n+\n+        \/\/ initial value deals with leading spaces\n+        boolean inSpace = true;\n+        for (int i=0; i<len; i++) {\n+            char c = s.charAt(i);\n+            if (c == ' ') {\n+                if (inSpace)\n+                    continue;\n+                inSpace = true;\n+            } else\n+                inSpace = false;\n+            sb.append(c);\n+        }\n+        int sblen = sb.length();\n+        \/\/ last char could be a space\n+        if (sblen > 0 && sb.charAt(sblen - 1) == ' ')\n+            sb.deleteCharAt(sblen - 1);\n+        return sb.toString();\n+    }\n+\n+    public static SensitiveInfo filterSocketInfo(String host) {\n+        return new SocketInfo(host);\n+    }\n+\n+    public static SensitiveInfo filterNetInfo(String host) {\n+        return new NetInfo(host);\n+    }\n+\n+    public static SensitiveInfo filterLookupInfo(String host) {\n+        return new LookupInfo(host);\n+    }\n+\n+    public static SensitiveInfo filterJarName(String name) {\n+        return new JarInfo(name);\n+    }\n+\n+    public static SensitiveInfo filterUserName(String name) {\n+        return new UserInfo(name);\n+    }\n+\n+    \/**\n+     * Transform each SensitiveInfo into a String argument which is passed\n+     * to String.format(). This string is then trimmed.\n+     *\/\n+    public static String formatMsg(String format, SensitiveInfo... infos) {\n+        String[] args = new String[infos.length];\n+\n+        int i = 0;\n+        boolean enhanced = true;\n+\n+        for (SensitiveInfo info : infos) {\n+            args[i++] = info.output();\n+            if (!info.enhanced())\n+                enhanced = false;\n+        }\n+        return trim(String.format(format, (Object[])args));\n+    }\n+\n+    \/**\n+     * Simplification of above. Equivalent to:\n+     *       formatMsg(\"%s\", SensitiveInfo[1]); \/\/ ie with one arg\n+     *\/\n+    private static String formatMsg(SensitiveInfo info) {\n+        return trim(info.output());\n+    }\n+\n+    public static void setup() {\n+        if (initialized || !VM.isBooted())\n+            return;\n+        \/\/ for compatibility\n+        var hostCompatFlag = SecurityProperties.includedInExceptions(\"hostInfo\");\n+        enhancedSocketExceptionText = SecurityProperties.includedInExceptions(\"socket\")\n+                                      | hostCompatFlag;\n+        enhancedNetExceptionText = SecurityProperties.includedInExceptions(\"net\")\n+                                      | hostCompatFlag;\n+        enhancedLookupExceptionText = SecurityProperties.includedInExceptions(\"addressLookup\")\n+                                      | hostCompatFlag;\n+        enhancedUserExceptionText = SecurityProperties.includedInExceptions(\"userInfo\");\n+        enhancedJarExceptionText = SecurityProperties.INCLUDE_JAR_NAME_IN_EXCEPTIONS;\n+        initialized = true;\n+    }\n+\n+    public static boolean enhancedNetExceptions() {\n+        setup();\n+        return enhancedNetExceptionText;\n+    }\n+\n+    public static boolean enhancedSocketExceptions() {\n+        setup();\n+        return enhancedSocketExceptionText;\n+    }\n+\n+    public static boolean enhancedLookupExceptions() {\n+        setup();\n+        return enhancedLookupExceptionText;\n+    }\n+\n+    \/**\n+     * The enhanced message text is the socket address appended to\n+     * the original IOException message\n+     *\/\n+    public static IOException ioException(IOException e, SocketAddress addr) {\n+        setup();\n+        if (addr == null) {\n+            return e;\n+        }\n+        if (!enhancedSocketExceptionText) {\n+            return create(e, e.getMessage());\n+        }\n+        if (addr instanceof UnixDomainSocketAddress) {\n+            return ofUnixDomain(e, (UnixDomainSocketAddress)addr);\n+        } else if (addr instanceof InetSocketAddress) {\n+            return ofInet(e, (InetSocketAddress)addr);\n+        } else {\n+            return e;\n+        }\n+    }\n+\n+    private static IOException ofInet(IOException e, InetSocketAddress addr) {\n+        return create(e, String.join(\": \", e.getMessage(), addr.toString()));\n+    }\n+\n+    private static IOException ofUnixDomain(IOException e, UnixDomainSocketAddress addr) {\n+        String path = addr.getPath().toString();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(e.getMessage());\n+        sb.append(\": \");\n+        sb.append(path);\n+        String enhancedMsg = sb.toString();\n+        return create(e, enhancedMsg);\n+    }\n+\n+    \/\/ return a new instance of the same type with the given detail\n+    \/\/ msg, or if the type doesn't support detail msgs, return given\n+    \/\/ instance.\n+    private static <T extends Exception> T create(T e, String msg) {\n+        try {\n+            Class<? extends Exception> clazz = e.getClass();\n+            @SuppressWarnings(\"unchecked\")\n+            Constructor<T> ctor = (Constructor<T>)clazz.getConstructor(String.class);\n+            T e1 = (ctor.newInstance(msg));\n+            e1.setStackTrace(e.getStackTrace());\n+            return e1;\n+        } catch (Exception e0) {\n+            \/\/ Some eg AsynchronousCloseException have no detail msg\n+            return e;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Exceptions.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -274,0 +274,1 @@\n+        java.net.http,\n@@ -276,0 +277,1 @@\n+        jdk.httpserver,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+import static jdk.internal.util.Exceptions.exception;\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+\n@@ -164,1 +167,2 @@\n-        return new IllegalArgumentException(\"Invalid IP address literal: \" + src);\n+        return exception(IllegalArgumentException.class, \"Invalid IP address literal%s\",\n+                         filterNetInfo(src).prefixWith(\": \"));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.util;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Constructor;\n-import java.net.InetSocketAddress;\n-import java.net.UnixDomainSocketAddress;\n-import java.net.SocketAddress;\n-\n-import sun.security.util.SecurityProperties;\n-\n-public final class SocketExceptions {\n-    private SocketExceptions() {}\n-\n-    private static final boolean enhancedExceptionText =\n-        SecurityProperties.includedInExceptions(\"hostInfo\");\n-\n-    \/**\n-     * Utility which takes an exception and returns either the same exception\n-     * or a new exception of the same type with the same stack trace\n-     * and detail message enhanced with addressing information from the\n-     * given InetSocketAddress.\n-     *\n-     * If the system\/security property \"jdk.includeInExceptions\" is not\n-     * set or does not contain the category hostInfo,\n-     * then the original exception is returned.\n-     *\n-     * Only specific IOException subtypes are supported.\n-     *\/\n-    public static IOException of(IOException e, SocketAddress addr) {\n-        if (!enhancedExceptionText || addr == null) {\n-            return e;\n-        }\n-        if (addr instanceof UnixDomainSocketAddress) {\n-            return ofUnixDomain(e, (UnixDomainSocketAddress)addr);\n-        } else if (addr instanceof InetSocketAddress) {\n-            return ofInet(e, (InetSocketAddress)addr);\n-        } else {\n-            return e;\n-        }\n-    }\n-\n-    private static IOException ofInet(IOException e, InetSocketAddress addr) {\n-        return create(e, String.join(\": \", e.getMessage(), addr.toString()));\n-    }\n-\n-    private static IOException ofUnixDomain(IOException e, UnixDomainSocketAddress addr) {\n-        String path = addr.getPath().toString();\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(e.getMessage());\n-        sb.append(\": \");\n-        sb.append(path);\n-        String enhancedMsg = sb.toString();\n-        return create(e, enhancedMsg);\n-    }\n-\n-    \/\/ return a new instance of the same type with the given detail\n-    \/\/ msg, or if the type doesn't support detail msgs, return given\n-    \/\/ instance.\n-    private static IOException create(final IOException e, final String msg) {\n-        try {\n-            Class<?> clazz = e.getClass();\n-            Constructor<?> ctor = clazz.getConstructor(String.class);\n-            IOException e1 = (IOException)(ctor.newInstance(msg));\n-            e1.setStackTrace(e.getStackTrace());\n-            return e1;\n-        } catch (Exception e0) {\n-            \/\/ Some eg AsynchronousCloseException have no detail msg\n-            return e;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/SocketExceptions.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwURISyntaxException;\n@@ -505,2 +507,2 @@\n-                throw new URISyntaxException(s,\n-                                             \"Relative path in absolute URI\");\n+                throwURISyntaxException(\"%s\", \"Relative path in absolute URI\",\n+                                        -1, filterNetInfo(s));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/ParseUtil.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import static jdk.internal.util.Exceptions.filterJarName;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -184,2 +186,4 @@\n-            throw new NullPointerException(\"invalid url: \" +\n-                                           spec + \" (\" + e + \")\");\n+            throwException(NullPointerException.class, \"invalid url: %s %s\",\n+                           filterJarName(spec), filterJarName(e.getMessage())\n+                                                    .prefixWith(\"(\")\n+                                                    .suffixWith(\")\"));\n@@ -196,4 +200,2 @@\n-                throw new NullPointerException(\"malformed \" +\n-                                               \"context url:\" +\n-                                               url +\n-                                               \": no !\/\");\n+                throwException(NullPointerException.class, \"malformed context url%s : no !\/\",\n+                               filterJarName(url.toString()).prefixWith(\": \"));\n@@ -206,3 +208,2 @@\n-                throw new NullPointerException(\"malformed \" +\n-                                               \"context url:\" +\n-                                               url);\n+                throwException(NullPointerException.class, \"malformed context url%s\",\n+                               filterJarName(url.toString()).prefixWith(\": \"));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/Handler.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static jdk.internal.util.Exceptions.filterJarName;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -110,1 +112,1 @@\n-            throw new FileNotFoundException(url.toString());\n+            throwException(FileNotFoundException.class, filterJarName(url.toString()));\n@@ -201,1 +203,1 @@\n-            throw new FileNotFoundException(url.toString());\n+            throwException(FileNotFoundException.class, filterJarName(url.toString()));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+import static jdk.internal.util.Exceptions.filterJarName;\n+import static jdk.internal.util.Exceptions.throwException;\n+\n@@ -129,3 +132,4 @@\n-                    throw new FileNotFoundException(\"JAR entry \" + entryName +\n-                            \" not found in \" +\n-                            jarFile.getName());\n+                    throwException(FileNotFoundException.class,\n+                                   \"JAR entry %s not found in jar file %s\",\n+                                   filterJarName(entryName),\n+                                   filterJarName(jarFile.getName()));\n@@ -169,3 +173,4 @@\n-                throw new FileNotFoundException(\"JAR entry \" + entryName +\n-                                                \" not found in \" +\n-                                                jarFile.getName());\n+                throwException(FileNotFoundException.class,\n+                               \"JAR entry %s not found in jar file %s\",\n+                               filterJarName(entryName),\n+                               filterJarName(jarFile.getName()));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarURLConnection.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import static jdk.internal.util.Exceptions.filterJarName;\n+import static jdk.internal.util.Exceptions.throwException;\n+\n@@ -46,1 +49,2 @@\n-            throw new MalformedURLException(\"no !\/ found in url spec:\" + s);\n+            throwException(MalformedURLException.class, \"no !\/ found in url spec%s\",\n+                           filterJarName(s).prefixWith(\": \"));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jmod\/Handler.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,2 @@\n+import static jdk.internal.util.Exceptions.throwException;\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n@@ -493,1 +495,2 @@\n-            throw new SocketException(\"No network interface with address \" + address);\n+            throwException(SocketException.class, \"No network interface found with address %s\",\n+                           filterNetInfo(address));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-import sun.net.util.SocketExceptions;\n+import jdk.internal.util.Exceptions;\n@@ -608,1 +608,1 @@\n-                throw SocketExceptions.of(ioe, isa);\n+                throw Exceptions.ioException(ioe, isa);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-import sun.net.util.SocketExceptions;\n+import jdk.internal.util.Exceptions;\n@@ -978,1 +978,1 @@\n-            throw SocketExceptions.of(ioe, sa);\n+            throw Exceptions.ioException(ioe, sa);\n@@ -1068,1 +1068,1 @@\n-            throw SocketExceptions.of(ioe, remoteAddress);\n+            throw Exceptions.ioException(ioe, remoteAddress);\n@@ -1328,1 +1328,1 @@\n-            throw SocketExceptions.of(ioe, sa);\n+            throw Exceptions.ioException(ioe, sa);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1257,2 +1257,5 @@\n-# By default, exception messages should not include potentially sensitive\n-# information such as file names, host names, or port numbers. This property\n+# Exception messages may include potentially sensitive information such as file\n+# names, host names, or port numbers. By default, socket related exceptions\n+# have this information restricted (meaning the sensitive details are removed).\n+# This property can be used to relax this restriction or to place further\n+# restrictions on other categories, defined below. The property\n@@ -1271,1 +1274,1 @@\n-#  hostInfo - IOExceptions thrown by java.net.Socket and the socket types in the\n+#  socket   - IOExceptions thrown by java.net.Socket and the socket types in the\n@@ -1275,1 +1278,12 @@\n-#  jar      - enables more detailed information in the IOExceptions thrown\n+#  addressLookup - UnknownHostExceptions and other exceptions thrown by the\n+#             java.net.InetAddress class\n+#\n+#  net      - All other exceptions thrown in networking code not included\n+#             in the categories above. This include URL\/URI, NetworkInterface\n+#             and URLConnection among others.\n+#\n+#  hostInfo - Special value which signifies the three categories above combined\n+#             (socket, addressLookup, net). This is provided for compatibility\n+#             with previous releases.\n+#\n+#  jar     - enables more detailed information in the IOExceptions thrown\n@@ -1278,0 +1292,3 @@\n+#  userInfo - enables more detailed information in exceptions which may contain\n+#             user identity information\n+#\n@@ -1281,2 +1298,5 @@\n-#jdk.includeInExceptions=hostInfo,jar\n-\n+# If the property is not set or set to an empty string, then this is the most \n+# restricted setting with all categories disabled. The following is the default\n+# (out of the box) setting, meaning these categories are not restricted.\n+#\n+jdk.includeInExceptions=addressLookup,net,userInfo\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+\n@@ -92,0 +93,26 @@\n+static int enhancedExceptionsInitialized = 0;\n+static int enhancedExceptionsAllowed = -1;\n+\n+#define CHECK_NULL_THROW_ERROR(X) \\\n+    if (X == NULL) {                                        \\\n+        JNU_ThrowByName(env, \"java\/lang\/InternalError\",     \\\n+            \"can't initialize enhanced exceptions\");        \\\n+        return -1;                                          \\\n+    }\n+\n+int getEnhancedExceptionsAllowed(JNIEnv *env) {\n+    jclass cls;\n+    jfieldID fid;\n+\n+    if (enhancedExceptionsInitialized) {\n+        return enhancedExceptionsAllowed;\n+    }\n+    cls = (*env)->FindClass(env, \"jdk\/internal\/util\/Exceptions\");\n+    CHECK_NULL_THROW_ERROR(cls);\n+    fid = (*env)->GetStaticFieldID(env, cls, \"enhancedLookupExceptionText\", \"Z\");\n+    CHECK_NULL_THROW_ERROR(fid);\n+    enhancedExceptionsAllowed = (*env)->GetStaticBooleanField(env, cls, fid);\n+    enhancedExceptionsInitialized = 1;\n+    return enhancedExceptionsAllowed;\n+}\n+\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.c","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,0 +186,2 @@\n+int getEnhancedExceptionsAllowed(JNIEnv *env);\n+\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.util.Exceptions;\n+\n@@ -37,1 +39,0 @@\n-import sun.net.util.SocketExceptions;\n@@ -267,1 +268,1 @@\n-                e = SocketExceptions.of((IOException)e, isa);\n+                e = Exceptions.ioException((IOException)e, isa);\n@@ -358,1 +359,1 @@\n-                e = SocketExceptions.of((IOException)e, isa);\n+                e = Exceptions.ioException((IOException)e, isa);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixAsynchronousSocketChannelImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import static jdk.internal.util.Exceptions.filterUserName;\n+import static jdk.internal.util.Exceptions.throwException;\n+\n@@ -135,1 +138,1 @@\n-        int id;\n+        int id = -1;\n@@ -139,1 +142,2 @@\n-            throw new IOException(name + \": \" + x.errorString());\n+            throwException(IOException.class, \"%s \" + x.errorString(),\n+                           filterUserName(name).suffixWith(\": \"));\n@@ -146,1 +150,1 @@\n-                throw new UserPrincipalNotFoundException(name);\n+                throwException(UserPrincipalNotFoundException.class, filterUserName(name));\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserPrincipals.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,0 @@\n-    const char *format = \"%s: %s\";\n@@ -191,0 +190,8 @@\n+    int enhancedExceptions = getEnhancedExceptionsAllowed(env);\n+\n+    if (enhancedExceptions) {\n+        size = strlen(hostname);\n+    } else {\n+        size = 0;\n+    }\n+    size += strlen(error_string) + 3;\n@@ -192,1 +199,0 @@\n-    size = strlen(format) + strlen(hostname) + strlen(error_string) + 2;\n@@ -196,1 +202,5 @@\n-        snprintf(buf, size, format, hostname, error_string);\n+        if (enhancedExceptions) {\n+            snprintf(buf, size, \"%s: %s\", hostname, error_string);\n+        } else {\n+            snprintf(buf, size, \" %s\", error_string);\n+        }\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.util.Exceptions;\n@@ -38,1 +39,0 @@\n-import sun.net.util.SocketExceptions;\n@@ -256,1 +256,1 @@\n-                exc = SocketExceptions.of(toIOException(exc), remote);\n+                exc = Exceptions.ioException(toIOException(exc), remote);\n@@ -283,1 +283,1 @@\n-                ee = SocketExceptions.of(ee, remote);\n+                ee = Exceptions.ioException(ee, remote);\n@@ -299,1 +299,1 @@\n-            x = SocketExceptions.of(x, remote);\n+            x = Exceptions.ioException(x, remote);\n@@ -304,1 +304,1 @@\n-                x = SocketExceptions.of(new AsynchronousCloseException(), remote);\n+                x = Exceptions.ioException(new AsynchronousCloseException(), remote);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousSocketChannelImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import static jdk.internal.util.Exceptions.filterUserName;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -139,2 +141,2 @@\n-                    throw new IOException(\"Failed to get SID for \" + user.getName()\n-                        + \": \" + x.errorString());\n+                    throwException(IOException.class, \"Failed to get SID %s : \" + x.errorString(),\n+                                   filterUserName(user.getName()).prefixWith(\"for \"));\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsSecurityDescriptor.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static jdk.internal.util.Exceptions.throwException;\n+import static jdk.internal.util.Exceptions.filterUserName;\n@@ -135,1 +137,1 @@\n-        int size;\n+        int size = 0;\n@@ -141,1 +143,2 @@\n-            throw new IOException(name + \": \" + x.errorString());\n+            throwException(IOException.class, \"%s \" + x.errorString(),\n+                           filterUserName(name).suffixWith(\": \"));\n@@ -156,1 +159,2 @@\n-            throw new IOException(name + \": \" + x.errorString());\n+            throwException(IOException.class, \"%s \" + x.errorString(),\n+                           filterUserName(name).suffixWith(\": \"));\n@@ -158,0 +162,1 @@\n+        return null; \/\/ can't happen. Exception will be thrown\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsUserPrincipals.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,2 +91,3 @@\n-        NET_ThrowByNameWithLastError(env, \"java\/net\/UnknownHostException\",\n-                                     hostname);\n+        NET_ThrowByNameWithLastError(\n+            env, \"java\/net\/UnknownHostException\",\n+            getEnhancedExceptionsAllowed(env) ? hostname : \"\");\n","filename":"src\/java.base\/windows\/native\/libnet\/Inet4AddressImpl.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-                                     hostname);\n+            getEnhancedExceptionsAllowed(env) ? hostname : \"\");\n","filename":"src\/java.base\/windows\/native\/libnet\/Inet6AddressImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -85,1 +87,2 @@\n-            throw newIAE(\"unsupported URI %s\", uri);\n+            throwException(IllegalArgumentException.class, \"unsupported URI %s\",\n+                           filterNetInfo(uri.toString()));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestBuilderImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import jdk.internal.util.Exceptions;\n@@ -193,1 +194,6 @@\n-            String s = String.format(\"%s in response [%d, %s]\", msg, rinfo.statusCode(), rinfo.headers());\n+            String s;\n+            if (Exceptions.enhancedNetExceptions()) {\n+                s = String.format(\"%s in response [%d, %s]\", msg, rinfo.statusCode(), rinfo.headers());\n+            } else {\n+                s = String.format(\"%s in response [%d]\", msg, rinfo.statusCode());\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseBodyHandlers.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,2 @@\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.throwException;\n@@ -339,1 +341,2 @@\n-            throw illegal(\"URI must contain a host: \" + uri);\n+            throwException(IllegalArgumentException.class, \"URI must contain a host%s\",\n+                           filterNetInfo(uri.toString()).prefixWith(\": \"));\n@@ -341,1 +344,2 @@\n-            throw illegal(\"URI must not contain a fragment: \" + uri);\n+            throwException(IllegalArgumentException.class, \"URI must not contain a fragment%s\",\n+                           filterNetInfo(uri.toString()).prefixWith(\": \"));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/OpeningHandshake.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+    private static final String SYS_PROP_ENHANCED_EXCEP = \"jdk.includeInExceptions\";\n+    private static final String DEFAULT_ENHANCED_EXCEP = \"net\";\n@@ -66,0 +68,1 @@\n+        setEnhancedExceptions();\n@@ -85,0 +88,8 @@\n+    static void setEnhancedExceptions() {\n+        if (System.getProperty(SYS_PROP_ENHANCED_EXCEP) != null) {\n+            \/\/ an explicit value has already been set, so we don't override it\n+            return;\n+        }\n+        System.setProperty(SYS_PROP_ENHANCED_EXCEP, DEFAULT_ENHANCED_EXCEP);\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/JWebServer.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,1 +238,5 @@\n-        var pb = new ProcessBuilder(args)\n+        String[] nargs = new String[args.length + 1];\n+        nargs[0] = args[0];\n+        System.arraycopy(args, 1, nargs, 2, args.length-1);\n+        nargs[1] = \"-Djdk.includeInExceptions=hostInfo\";\n+        var pb = new ProcessBuilder(nargs)\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CommandLineNegativeTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/othervm -Djdk.includeInExceptions=hostInfo Test\n","filename":"test\/jdk\/java\/net\/URI\/Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @comment In OpenJDK, this property is empty by default and on purpose.\n+ * @comment In OpenJDK, this property has value \"addressLookup,net\" by default\n@@ -39,1 +39,1 @@\n-        if (incInExc != null) {\n+        if (incInExc == null || !incInExc.equals(\"addressLookup,net,userInfo\")) {\n@@ -41,1 +41,1 @@\n-                \"jdk.includeInExceptions security property is not null: \" +\n+                \"jdk.includeInExceptions security property does not have expected value: \" +\n","filename":"test\/jdk\/jdk\/security\/JavaDotSecurity\/TestJDKIncludeInExceptions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import jdk.internal.util.Exceptions;\n+import jdk.internal.util.Exceptions.SensitiveInfo;\n+import static jdk.internal.util.Exceptions.formatMsg;\n+import static jdk.internal.util.Exceptions.filterNetInfo;\n+import static jdk.internal.util.Exceptions.enhancedLookupExceptions;\n+import static jdk.internal.util.Exceptions.enhancedNetExceptions;\n+\n+\/*\n+ * @test\n+ * @bug 8348986\n+ * @summary Improve coverage of enhanced exception messages\n+ * @modules java.base\/jdk.internal.util\n+ * @run main\/othervm -Djdk.includeInExceptions=hostInfo ExceptionsTest\n+ * @run main\/othervm ExceptionsTest\n+ * @run main\/othervm -Djdk.includeInExceptions=userInfo ExceptionsTest\n+ * @run main\/othervm -Djdk.net.hosts.file=does.not.exist -Djdk.includeInExceptions=userInfo ExceptionsTest\n+ * @run main\/othervm -Djdk.net.hosts.file=does.not.exist -Djdk.includeInExceptions=hostInfo ExceptionsTest\n+ *\/\n+public class ExceptionsTest {\n+\n+    static boolean netEnabled() {\n+        System.out.printf(\"netEnabled = %b\\n\", enhancedNetExceptions());\n+        return enhancedNetExceptions();\n+    }\n+\n+    static boolean dnsEnabled() {\n+        System.out.printf(\"dnsEnabled = %b\\n\", enhancedLookupExceptions());\n+        return enhancedLookupExceptions();\n+    }\n+\n+    static boolean hostFileEnabled() {\n+        return System.getProperty(\"jdk.net.hosts.file\", \"\").length() > 0;\n+    }\n+\n+    static String[][][] tests = {\n+    \/\/\n+    \/\/ If a format argument is of the form \".pre(xxx)\" or \".suf(yyy)\", then that is\n+    \/\/ interpreted as a .prefixWith(\"xxx\") or .suffixWith(\"yyy\") call to the preceding\n+    \/\/ argument. .rep() signifies .replaceWith()\n+    \/\/\n+    \/\/                  Number of elements in array\n+    \/\/                  ---------------------------\n+    \/\/                1              N                 2\n+    \/\/\n+    \/\/       Format string         args to format                  Enhanced o\/p     non-enhanced o\/p\n+    \/\/\n+    \/*  1 *\/ {{\"foo: %s bar\"},     {\"abc\"},                        {\"foo: abc bar\", \"foo: bar\"}},\n+    \/*  2 *\/ {{\"foo: %s bar\"},     {\"a\", \"b\"},                     {\"foo: a bar\", \"foo: bar\"}},\n+    \/*  3 *\/ {{\"foo: %s bar\"},     {null},                         {\"foo: null bar\", \"foo: bar\"}},\n+    \/*  4 *\/ {{\"foo: %s bar\"},     {\"\"},                           {\"foo: bar\", \"foo: bar\"}},\n+    \/*  5 *\/ {{\"%s foo: %s bar\"},  {\"a\", \"b\"},                     {\"a foo: b bar\", \"foo: bar\"}},\n+    \/*  6 *\/ {{\"foo: %s bar %s\"},  {\"a\", \"b\"},                     {\"foo: a bar b\", \"foo: bar\"}},\n+    \/*  7 *\/ {{\"foo: %s bar %s\"},  {\"abc\", \"def\"},                 {\"foo: abc bar def\", \"foo: bar\"}},\n+    \/*  8 *\/ {{\"%s bar %s\"},       {\"abc\", \".pre(foo: )\", \"def\"},  {\"foo: abc bar def\", \"bar\"}},\n+    \/*  9 *\/ {{\"%s baz\"},          {\"abc\", \".suf(: bar)\"},         {\"abc: bar baz\", \"baz\"}},\n+    \/* 10 *\/ {{\"%s baz\"},          {\"abc\", \".suf(: bar)\"\n+                                         , \".rep(bob)\"},           {\"abc: bar baz\", \"bob baz\"}}\n+    };\n+\n+\n+    static void dnsTest() {\n+        String host = \"fub.z.a.bar.foo\";\n+        try {\n+            var addr = InetAddress.getByName(host);\n+        } catch (IOException e) {\n+            if (!dnsEnabled() && e.toString().contains(host))\n+                throw new RuntimeException(\"Name lookup failed\");\n+        }\n+    }\n+\n+    static void hostFileTest() {\n+        String result1 = \"Unable to resolve host www.rte.ie as hosts file does.not.exist not found\";\n+        String result2 = \"Unable to resolve host as hosts file \" +\n+                         \"from ${jdk.net.hosts.file} system property not found\";\n+\n+        try {\n+            var a = InetAddress.getByName(\"www.rte.ie\");\n+        } catch (IOException e) {\n+            if (dnsEnabled() && !e.toString().contains(result1)) {\n+                System.out.println(\"Lookup failed: \" + e.toString());\n+                throw new RuntimeException(\"Name lookup failed\");\n+            }\n+            if (!dnsEnabled() && !e.toString().contains(result2)) {\n+                System.out.println(\"Lookup failed: \" + e.toString());\n+                throw new RuntimeException(\"Name lookup failed\");\n+            }\n+        }\n+    }\n+\n+\n+    final static String PRE = \".pre(\";\n+    final static String SUF = \".suf(\";\n+    final static String REP = \".rep(\";\n+\n+    static SensitiveInfo[] getArgs(String[] args) {\n+        SensitiveInfo[] sa = new SensitiveInfo[args.length];\n+\n+        int index = 0;\n+        for (String s : args) {\n+            if (s != null && s.startsWith(PRE)) {\n+                var preArg = s.substring(PRE.length(), s.indexOf(')'));\n+                sa[index-1] = sa[index-1].prefixWith(preArg);\n+            } else if (s != null && s.startsWith(SUF)) {\n+                var sufArg = s.substring(SUF.length(), s.indexOf(')'));\n+                sa[index-1] = sa[index-1].suffixWith(sufArg);\n+            } else if (s != null && s.startsWith(REP)) {\n+                var repArg = s.substring(REP.length(), s.indexOf(')'));\n+                sa[index-1] = sa[index-1].replaceWith(repArg);\n+            } else {\n+                sa[index++] = filterNetInfo(s);\n+            }\n+        }\n+        return Arrays.copyOf(sa, index);\n+    }\n+\n+    public static void main(String[] a) {\n+        if (!hostFileEnabled()) {\n+            dnsTest();\n+        } else {\n+            hostFileTest();\n+            return;\n+        }\n+\n+        int count = 1;\n+        for (String[][] test : tests) {\n+            String format = test[0][0];\n+            String expectedEnhanced = test[2][0];\n+            String expectedNormal = test[2][1];\n+            SensitiveInfo[] args = getArgs(test[1]);\n+\n+            String output = formatMsg(format, args);\n+            if (netEnabled()) {\n+                if (!output.equals(expectedEnhanced)) {\n+                    var msg = String.format(\"FAIL %d: got: \\\"%s\\\" Expected: \\\"%s\\\"\", count,\n+                                output, expectedEnhanced);\n+                    throw new RuntimeException(msg);\n+                }\n+            } else {\n+                if (!output.equals(expectedNormal)) {\n+                    var msg = String.format(\"FAIL %d: got: \\\"%s\\\" Expected: \\\"%s\\\"\", count,\n+                                output, expectedNormal);\n+                    throw new RuntimeException(msg);\n+                }\n+            }\n+            count++;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/util\/ExceptionsTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"}]}