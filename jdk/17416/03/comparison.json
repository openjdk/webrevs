{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -556,0 +556,4 @@\n+     * @implNote The implementation in {@link MessageFormat} returns a string\n+     * that can be used to create a new instance that is semantically equivalent\n+     * to this instance.\n+     *\n@@ -567,0 +571,1 @@\n+            String subformatPattern = null;\n@@ -579,4 +584,6 @@\n-                    if (fmt instanceof DecimalFormat) {\n-                        result.append(\",number,\").append(((DecimalFormat)fmt).toPattern());\n-                    } else if (fmt instanceof ChoiceFormat) {\n-                        result.append(\",choice,\").append(((ChoiceFormat)fmt).toPattern());\n+                    if (fmt instanceof DecimalFormat dfmt) {\n+                        result.append(\",number\");\n+                        subformatPattern = dfmt.toPattern();\n+                    } else if (fmt instanceof ChoiceFormat cfmt) {\n+                        result.append(\",choice\");\n+                        subformatPattern = cfmt.toPattern();\n@@ -604,2 +611,3 @@\n-                    if (fmt instanceof SimpleDateFormat) {\n-                        result.append(\",date,\").append(((SimpleDateFormat)fmt).toPattern());\n+                    if (fmt instanceof SimpleDateFormat sdfmt) {\n+                        result.append(\",date\");\n+                        subformatPattern = sdfmt.toPattern();\n@@ -615,0 +623,8 @@\n+            if (subformatPattern != null) {\n+                result.append(',');\n+\n+                \/\/ The subformat pattern comes already quoted, but only for those characters that are\n+                \/\/ special to the subformat. Therefore, we may need to quote additional characters.\n+                \/\/ The ones we care about at the MessageFormat level are '{' and '}'.\n+                copyAndQuoteBraces(subformatPattern, result);\n+            }\n@@ -1643,0 +1659,45 @@\n+    \/\/ Copy the text, but add quotes around any quotables that aren't already quoted\n+    private static void copyAndQuoteBraces(String source, StringBuilder target) {\n+\n+        \/\/ Analyze existing string for already quoted and newly quotable characters\n+        record Qchar(char ch, boolean quoted) { };\n+        ArrayList<Qchar> qchars = new ArrayList<>();\n+        boolean quoted = false;\n+        boolean anyChangeNeeded = false;\n+        for (int i = 0; i < source.length(); i++) {\n+            char ch = source.charAt(i);\n+            if (ch == '\\'') {\n+                if (i + 1 < source.length() && source.charAt(i + 1) == '\\'') {\n+                    qchars.add(new Qchar('\\'', quoted));\n+                    i++;\n+                } else\n+                    quoted = !quoted;\n+            } else {\n+                boolean quotable = ch == '{' || ch == '}';\n+                anyChangeNeeded |= quotable && !quoted;\n+                qchars.add(new Qchar(ch, quoted || quotable));\n+            }\n+        }\n+\n+        \/\/ Was any change needed?\n+        if (!anyChangeNeeded) {\n+            target.append(source);\n+            return;\n+        }\n+\n+        \/\/ Build new string, automaticaly consolidating adjacent runs of quoted chars\n+        quoted = false;\n+        for (Qchar qchar : qchars) {\n+            char ch = qchar.ch;\n+            if (ch == '\\'')\n+                target.append(ch);          \/\/ doubling works whether quoted or not\n+            else if (qchar.quoted() != quoted) {\n+                target.append('\\'');\n+                quoted = qchar.quoted();\n+            }\n+            target.append(ch);\n+        }\n+        if (quoted)\n+            target.append('\\'');\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":68,"deletions":7,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,360 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify MessageFormat.toPattern() is equivalent to original pattern\n+ * @bug 8323699\n+ * @run junit MessageFormatToPatternTest\n+ *\/\n+\n+import java.text.ChoiceFormat;\n+import java.text.DateFormat;\n+import java.text.DecimalFormat;\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MessageFormatToPatternTest {\n+\n+    private static final int NUM_RANDOM_TEST_CASES = 1000;\n+\n+    \/\/ Max levels of nesting of ChoiceFormats inside MessageFormats\n+    private static final int MAX_FORMAT_NESTING = 3;\n+\n+    private static Locale savedLocale;\n+    private static long randomSeed;             \/\/ set this to a non-zero value for reproducibility\n+    private static Random random;\n+    private static boolean spitSeed;\n+    private static int textCount;\n+\n+\/\/ Setup & Teardown\n+\n+    @BeforeAll\n+    public static void setup() {\n+        savedLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+        if (randomSeed == 0)\n+            randomSeed = new Random().nextLong();\n+        random = new Random(randomSeed);\n+    }\n+\n+    @AfterAll\n+    public static void teardown() {\n+        Locale.setDefault(savedLocale);\n+    }\n+\n+\/\/ Tests\n+\n+    \/\/ Test expected output when given a MessageFormat pattern string and value 1.23\n+    @ParameterizedTest\n+    @MethodSource(\"generateOutputTestCases\")\n+    public void testOutput(String pattern, String expected) {\n+\n+        \/\/ Test we get the expected output\n+        MessageFormat format = new MessageFormat(pattern);\n+        String actual = format.format(new Object[] { 1.23 });\n+        assertEquals(expected, actual);\n+\n+        \/\/ Test round trip as well\n+        testRoundTrip(format);\n+    }\n+\n+    public static Stream<Arguments> generateOutputTestCases() {\n+        return Stream.of(\n+\n+            \/\/ This is the test case from JDK-8323699\n+            Arguments.of(\"{0,choice,0.0#option A: {0}|1.0#option B: {0}'}'}\", \"option B: 1.23}\"),\n+            Arguments.of(\"{0,choice,0.0#option A: {0}|2.0#option B: {0}'}'}\", \"option A: 1.23\"),\n+\n+            \/\/ A few more test cases from the PR#17416 discussion\n+            Arguments.of(\"Test: {0,number,foo'{'#.00}\", \"Test: foo{1.23\"),\n+            Arguments.of(\"Test: {0,number,foo'}'#.00}\", \"Test: foo}1.23\"),\n+            Arguments.of(\"{0,number,' abc }'' ' 0.00}\", \" abc }'  1.23\"),\n+            Arguments.of(\"Wayne ''The Great One'' Gretsky\", \"Wayne 'The Great One' Gretsky\"),\n+            Arguments.of(\"'Wayne ''The Great One'' Gretsky'\", \"Wayne 'The Great One' Gretsky\"),\n+            Arguments.of(\"{0,choice,0.0#'''{''curly''}'' braces'}\", \"{curly} braces\"),\n+            Arguments.of(\"{0,choice,0.0#''{''curly''}'' braces}\", \"{curly} braces\"),\n+            Arguments.of(\"{0,choice,0.0#'{0,choice,0.0#''{0,choice,0.0#''''{0,choice,0.0#foo}''''}''}'}\", \"foo\"),\n+\n+            \/\/ An absurdly complicated example\n+            Arguments.of(\"{0,choice,0.0#text2887 [] '{'1,date,YYYY-MM-DD'}' text2888 [''*'']|1.0#found|2.0#'text2901 [oog'')!''] {2,choice,0.0#''text2897 ['''']''''wq1Q] {2,choice,0.0#''''text2891 [s''''''''&''''''''] {0,number,#0.##} text2892 [8''''''''|$'''''''''''''''''''''''']''''|1.0#''''text2893 [] {0,number,#0.##} text2894 [S'''''''']'''''''']''''|2.0#text2895 [''''''''.''''''''eB] {1,date,YYYY-MM-DD} text2896 [9Y]} text2898 []''|1.0#''text2899 [xk7] {0,number,#0.##} text2900 []''} text2902 [7'':$)''O]'}{0,choice,0.0#'text2903 [] {0,number,#0.##} text2904 [S'':'']'|1.0#'me'}\", \"foundme\")\n+        );\n+    }\n+\n+    \/\/ Go roundrip from MessageFormat -> pattern string -> MessageFormat and verify equivalence\n+    @ParameterizedTest\n+    @MethodSource(\"generateRoundTripTestCases\")\n+    public void testRoundTrip(MessageFormat format1) {\n+\n+        \/\/ Prepare MessageFormat argument\n+        Object[] args = new Object[] {\n+            8.5,                            \/\/ argument for DecimalFormat\n+            new Date(1705502102677L),       \/\/ argument for SimpleDateFormat\n+            random.nextInt(6)               \/\/ argument for ChoiceFormat\n+        };\n+\n+        String pattern1 = null;\n+        String result1 = null;\n+        String pattern2 = null;\n+        String result2 = null;\n+        try {\n+\n+            \/\/ Format using the given MessageFormat\n+            pattern1 = format1.toPattern();\n+            result1 = format1.format(args);\n+\n+            \/\/ Round-trip via toPattern() and repeat\n+            MessageFormat format2 = new MessageFormat(pattern1);\n+            pattern2 = format2.toPattern();\n+            result2 = format2.format(args);\n+\n+            \/\/ Check equivalence\n+            assertEquals(result1, result2);\n+            assertEquals(pattern1, pattern2);\n+\n+            \/\/ Debug\n+            \/\/showRoundTrip(format1, pattern1, result1, pattern2, result2);\n+        } catch (RuntimeException | Error e) {\n+            System.out.println(String.format(\"%n********** FAILURE **********%n\"));\n+            System.out.println(String.format(\"%s%n\", e));\n+            if (!spitSeed) {\n+                System.out.println(String.format(\"*** Random seed was 0x%016xL%n\", randomSeed));\n+                spitSeed = true;\n+            }\n+            showRoundTrip(format1, pattern1, result1, pattern2, result2);\n+            throw e;\n+        }\n+    }\n+\n+    public static Stream<Arguments> generateRoundTripTestCases() {\n+        final ArrayList<Arguments> argList = new ArrayList<>();\n+        for (int i = 0; i < NUM_RANDOM_TEST_CASES; i++)\n+            argList.add(Arguments.of(randomFormat()));\n+        return argList.stream();\n+    }\n+\n+    \/\/ Generate a \"random\" MessageFormat. We do this by creating a MessageFormat with \"{0}\" placeholders\n+    \/\/ and then substituting in random DecimalFormat, DateFormat, and ChoiceFormat subformats. The goal here\n+    \/\/ is to avoid using pattern strings to construct formats, because they're what we're trying to check.\n+    private static MessageFormat randomFormat() {\n+\n+        \/\/ Create a temporary MessageFormat containing \"{0}\" placeholders and random text\n+        StringBuilder tempPattern = new StringBuilder();\n+        int numParts = random.nextInt(3) + 1;\n+        for (int i = 0; i < numParts; i++) {\n+            if (random.nextBoolean())\n+                tempPattern.append(\"{0}\");      \/\/ temporary placeholder for a subformat\n+            else\n+                tempPattern.append(quoteText(randomText()));\n+        }\n+\n+        \/\/ Replace all the \"{0}\" placeholders with random subformats\n+        MessageFormat format = new MessageFormat(tempPattern.toString());\n+        Format[] formats = format.getFormats();\n+        for (int i = 0; i < formats.length; i++)\n+            formats[i] = randomSubFormat(0);\n+        format.setFormats(formats);\n+\n+        \/\/ Done\n+        return format;\n+    }\n+\n+    \/\/ Generate some random text\n+    private static String randomText() {\n+        StringBuilder buf = new StringBuilder();\n+        int length = random.nextInt(6);\n+        for (int i = 0; i < length; i++) {\n+            char ch = (char)(0x20 + random.nextInt(0x5f));\n+            buf.append(ch);\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/\/ Quote non-alphanumeric characters in the given plain text\n+    private static String quoteText(String string) {\n+        StringBuilder buf = new StringBuilder();\n+        boolean quoted = false;\n+        for (int i = 0; i < string.length(); i++) {\n+            char ch = string.charAt(i);\n+            if (ch == '\\'')\n+                buf.append(\"''\");\n+            else if (!(ch == ' ' || Character.isLetter(ch) || Character.isDigit(ch))) {\n+                if (!quoted) {\n+                    buf.append('\\'');\n+                    quoted = true;\n+                }\n+                buf.append(ch);\n+            } else {\n+                if (quoted) {\n+                    buf.append('\\'');\n+                    quoted = false;\n+                }\n+                buf.append(ch);\n+            }\n+        }\n+        if (quoted)\n+            buf.append('\\'');\n+        return buf.toString();\n+    }\n+\n+    \/\/ Create a random subformat for a MessageFormat\n+    private static Format randomSubFormat(int nesting) {\n+        int which;\n+        if (nesting >= MAX_FORMAT_NESTING)\n+            which = random.nextInt(2);          \/\/ no more recursion\n+        else\n+            which = random.nextInt(3);\n+        switch (which) {\n+        case 0:\n+            return new DecimalFormat(\"#.##\");\n+        case 1:\n+            return new SimpleDateFormat(\"YYYY-MM-DD\");\n+        default:\n+            int numChoices = random.nextInt(3) + 1;\n+            assert numChoices > 0;\n+            final double[] limits = new double[numChoices];\n+            final String[] formats = new String[numChoices];\n+            for (int i = 0; i < limits.length; i++) {\n+                limits[i] = (double)i;\n+                formats[i] = randomMessageFormatContaining(randomSubFormat(nesting + 1));\n+            }\n+            return new ChoiceFormat(limits, formats);\n+        }\n+    }\n+\n+    \/\/ Create a MessageFormat pattern string that includes the given Format as a subformat.\n+    \/\/ The result will be one option in a ChoiceFormat which is nested in an outer MessageFormat.\n+    \/\/ A ChoiceFormat option string is just a plain string; it's only when that plain string\n+    \/\/ bubbles up to a containing MessageFormat that it gets interpreted as a MessageFormat string,\n+    \/\/ and that only happens if the option string contains a '{' character. That will always\n+    \/\/ be the case for the strings returned by this method of course.\n+    private static String randomMessageFormatContaining(Format format) {\n+        String beforeText = quoteText(randomText().replaceAll(\"\\\\{\", \"\"));     \/\/ avoid invalid MessageFormat syntax\n+        String afterText = quoteText(randomText().replaceAll(\"\\\\{\", \"\"));      \/\/ avoid invalid MessageFormat syntax\n+        String middleText;\n+        if (format instanceof DecimalFormat dfmt)\n+            middleText = String.format(\"{0,number,%s}\", dfmt.toPattern());\n+        else if (format instanceof SimpleDateFormat sdfmt)\n+            middleText = String.format(\"{1,date,%s}\", sdfmt.toPattern());\n+        else if (format instanceof ChoiceFormat cfmt)\n+            middleText = String.format(\"{2,choice,%s}\", cfmt.toPattern());\n+        else\n+            throw new RuntimeException(\"internal error\");\n+        return String.format(\"text%d [%s] %s text%d [%s]\", ++textCount, beforeText, middleText, ++textCount, afterText);\n+    }\n+\n+\/\/ Debug printing\n+\n+    private void showRoundTrip(MessageFormat format1, String pattern1, String result1, String pattern2, String result2) {\n+        print(0, format1);\n+        System.out.println();\n+        if (pattern1 != null)\n+            System.out.println(String.format(\"  pattern1 = %s\", javaLiteral(pattern1)));\n+        if (result1 != null)\n+            System.out.println(String.format(\"   result1 = %s\", javaLiteral(result1)));\n+        if (pattern2 != null)\n+            System.out.println(String.format(\"  pattern2 = %s\", javaLiteral(pattern2)));\n+        if (result2 != null)\n+            System.out.println(String.format(\"   result2 = %s\", javaLiteral(result2)));\n+        System.out.println();\n+    }\n+\n+    private static void print(int depth, Object format) {\n+        if (format == null)\n+            return;\n+        if (format instanceof String)\n+            System.out.println(String.format(\"%s- %s\", indent(depth), javaLiteral((String)format)));\n+        else if (format instanceof MessageFormat)\n+            print(depth, (MessageFormat)format);\n+        else if (format instanceof DecimalFormat)\n+            print(depth, (DecimalFormat)format);\n+        else if (format instanceof SimpleDateFormat)\n+            print(depth, (SimpleDateFormat)format);\n+        else if (format instanceof ChoiceFormat)\n+            print(depth, (ChoiceFormat)format);\n+        else\n+            throw new RuntimeException(\"internal error: \" + format.getClass());\n+    }\n+\n+    private static void print(int depth, MessageFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"MessageFormat\", javaLiteral(format.toPattern())));\n+        for (Format subformat : format.getFormats())\n+            print(depth + 1, subformat);\n+    }\n+\n+    private static void print(int depth, DecimalFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"DecimalFormat\", javaLiteral(format.toPattern())));\n+    }\n+\n+    private static void print(int depth, SimpleDateFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"SimpleDateFormat\", javaLiteral(format.toPattern())));\n+    }\n+\n+    private static void print(int depth, ChoiceFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"ChoiceFormat\", javaLiteral(format.toPattern())));\n+        for (Object subformat : format.getFormats())\n+            print(depth + 1, subformat);\n+    }\n+\n+    private static String indent(int depth) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < depth; i++)\n+            buf.append(\"    \");\n+        return buf.toString();\n+    }\n+\n+    \/\/ Print a Java string in double quotes so it looks like a String literal (for easy pasting into jshell)\n+    private static String javaLiteral(String string) {\n+        StringBuilder buf = new StringBuilder();\n+        buf.append('\"');\n+        for (int i = 0; i < string.length(); i++) {\n+            char ch = string.charAt(i);\n+            switch (ch) {\n+            case '\"':\n+            case '\\\\':\n+                buf.append('\\\\');\n+                \/\/ FALLTHROUGH\n+            default:\n+                buf.append(ch);\n+                break;\n+            }\n+        }\n+        return buf.append('\"').toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageFormatToPatternTest.java","additions":360,"deletions":0,"binary":false,"changes":360,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+    private static String quotedChoicePattern = choicePattern.replaceAll(\"([{}])\", \"'$1'\");\n@@ -59,1 +60,1 @@\n-        checkPattern(format.toPattern(), \"{3,choice,\" + choicePattern + \"}, {2}, {0,number}\");\n+        checkPattern(format.toPattern(), \"{3,choice,\" + quotedChoicePattern + \"}, {2}, {0,number}\");\n@@ -76,1 +77,2 @@\n-        checkPattern(format.toPattern(), \"{3,choice,\" + choicePattern + \"}, {2,number}, {0,choice,\" + choicePattern + \"}\");\n+        checkPattern(format.toPattern(),\n+          \"{3,choice,\" + quotedChoicePattern + \"}, {2,number}, {0,choice,\" + quotedChoicePattern + \"}\");\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageFormatsByArgumentIndex.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        MessageFormat fmt = new MessageFormat(\"{0,choice,0#no files|1#one file|1< {0,number,integer} files}\");\n+        MessageFormat fmt = new MessageFormat(\"{0,choice,0.0#no files|1.0#one file|1.0< '{'0,number,integer'}' files}\");\n@@ -119,1 +119,1 @@\n-        if (!pat.equals(\"{0,choice,0.0#no files|1.0#one file|1.0< {0,number,integer} files}\")) {\n+        if (!pat.equals(\"{0,choice,0.0#no files|1.0#one file|1.0< '{'0,number,integer'}' files}\")) {\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageRegression.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}