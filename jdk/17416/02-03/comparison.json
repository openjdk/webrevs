{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -556,2 +556,3 @@\n-     * @implNote The string returned by this method can be used to create\n-     * an instance that is semantically equivalent to this instance.\n+     * @implNote The implementation in {@link MessageFormat} returns a string\n+     * that can be used to create a new instance that is semantically equivalent\n+     * to this instance.\n@@ -583,1 +584,1 @@\n-                    if (fmt instanceof DecimalFormat) {\n+                    if (fmt instanceof DecimalFormat dfmt) {\n@@ -585,2 +586,2 @@\n-                        subformatPattern = ((DecimalFormat)fmt).toPattern();\n-                    } else if (fmt instanceof ChoiceFormat) {\n+                        subformatPattern = dfmt.toPattern();\n+                    } else if (fmt instanceof ChoiceFormat cfmt) {\n@@ -588,1 +589,1 @@\n-                        subformatPattern = ((ChoiceFormat)fmt).toPattern();\n+                        subformatPattern = cfmt.toPattern();\n@@ -610,1 +611,1 @@\n-                    if (fmt instanceof SimpleDateFormat) {\n+                    if (fmt instanceof SimpleDateFormat sdfmt) {\n@@ -612,1 +613,1 @@\n-                        subformatPattern = ((SimpleDateFormat)fmt).toPattern();\n+                        subformatPattern = sdfmt.toPattern();\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+\n+    \/\/ Max levels of nesting of ChoiceFormats inside MessageFormats\n@@ -82,2 +84,4 @@\n-    @Test\n-    public void testJDK_8323699() {\n+    \/\/ Test expected output when given a MessageFormat pattern string and value 1.23\n+    @ParameterizedTest\n+    @MethodSource(\"generateOutputTestCases\")\n+    public void testOutput(String pattern, String expected) {\n@@ -85,2 +89,4 @@\n-        \/\/ This is the test case from JDK-8323699\n-        testRoundTrip(new MessageFormat(\"{2,choice,0.0#option A: {0}|1.0#option B: {0}'}'}\"));\n+        \/\/ Test we get the expected output\n+        MessageFormat format = new MessageFormat(pattern);\n+        String actual = format.format(new Object[] { 1.23 });\n+        assertEquals(expected, actual);\n@@ -88,3 +94,24 @@\n-        \/\/ A few more test cases from the PR#17416 discussion\n-        testRoundTrip(new MessageFormat(\"Test: {0,number,foo'{'#.00}\"));\n-        testRoundTrip(new MessageFormat(\"Test: {0,number,foo'}'#.00}\"));\n+        \/\/ Test round trip as well\n+        testRoundTrip(format);\n+    }\n+\n+    public static Stream<Arguments> generateOutputTestCases() {\n+        return Stream.of(\n+\n+            \/\/ This is the test case from JDK-8323699\n+            Arguments.of(\"{0,choice,0.0#option A: {0}|1.0#option B: {0}'}'}\", \"option B: 1.23}\"),\n+            Arguments.of(\"{0,choice,0.0#option A: {0}|2.0#option B: {0}'}'}\", \"option A: 1.23\"),\n+\n+            \/\/ A few more test cases from the PR#17416 discussion\n+            Arguments.of(\"Test: {0,number,foo'{'#.00}\", \"Test: foo{1.23\"),\n+            Arguments.of(\"Test: {0,number,foo'}'#.00}\", \"Test: foo}1.23\"),\n+            Arguments.of(\"{0,number,' abc }'' ' 0.00}\", \" abc }'  1.23\"),\n+            Arguments.of(\"Wayne ''The Great One'' Gretsky\", \"Wayne 'The Great One' Gretsky\"),\n+            Arguments.of(\"'Wayne ''The Great One'' Gretsky'\", \"Wayne 'The Great One' Gretsky\"),\n+            Arguments.of(\"{0,choice,0.0#'''{''curly''}'' braces'}\", \"{curly} braces\"),\n+            Arguments.of(\"{0,choice,0.0#''{''curly''}'' braces}\", \"{curly} braces\"),\n+            Arguments.of(\"{0,choice,0.0#'{0,choice,0.0#''{0,choice,0.0#''''{0,choice,0.0#foo}''''}''}'}\", \"foo\"),\n+\n+            \/\/ An absurdly complicated example\n+            Arguments.of(\"{0,choice,0.0#text2887 [] '{'1,date,YYYY-MM-DD'}' text2888 [''*'']|1.0#found|2.0#'text2901 [oog'')!''] {2,choice,0.0#''text2897 ['''']''''wq1Q] {2,choice,0.0#''''text2891 [s''''''''&''''''''] {0,number,#0.##} text2892 [8''''''''|$'''''''''''''''''''''''']''''|1.0#''''text2893 [] {0,number,#0.##} text2894 [S'''''''']'''''''']''''|2.0#text2895 [''''''''.''''''''eB] {1,date,YYYY-MM-DD} text2896 [9Y]} text2898 []''|1.0#''text2899 [xk7] {0,number,#0.##} text2900 []''} text2902 [7'':$)''O]'}{0,choice,0.0#'text2903 [] {0,number,#0.##} text2904 [S'':'']'|1.0#'me'}\", \"foundme\")\n+        );\n@@ -95,1 +122,1 @@\n-    @MethodSource(\"testCases\")\n+    @MethodSource(\"generateRoundTripTestCases\")\n@@ -123,0 +150,3 @@\n+\n+            \/\/ Debug\n+            \/\/showRoundTrip(format1, pattern1, result1, pattern2, result2);\n@@ -130,11 +160,1 @@\n-            print(0, format1);\n-            System.out.println();\n-            if (pattern1 != null)\n-                System.out.println(String.format(\"  pattern1 = %s\", javaLiteral(pattern1)));\n-            if (result1 != null)\n-                System.out.println(String.format(\"   result1 = %s\", javaLiteral(result1)));\n-            if (pattern2 != null)\n-                System.out.println(String.format(\"  pattern2 = %s\", javaLiteral(pattern2)));\n-            if (result2 != null)\n-                System.out.println(String.format(\"   result2 = %s\", javaLiteral(result2)));\n-            System.out.println();\n+            showRoundTrip(format1, pattern1, result1, pattern2, result2);\n@@ -145,1 +165,1 @@\n-    public static Stream<Arguments> testCases() {\n+    public static Stream<Arguments> generateRoundTripTestCases() {\n@@ -170,1 +190,1 @@\n-        for (int i = 0; i < formats.length; i++) {\n+        for (int i = 0; i < formats.length; i++)\n@@ -172,2 +192,0 @@\n-\n-        }\n@@ -218,1 +236,1 @@\n-    \/\/ Create a random subformat\n+    \/\/ Create a random subformat for a MessageFormat\n@@ -237,1 +255,1 @@\n-                formats[i] = toChoiceOption(randomSubFormat(nesting + 1));\n+                formats[i] = randomMessageFormatContaining(randomSubFormat(nesting + 1));\n@@ -243,4 +261,9 @@\n-    \/\/ Create one ChoiceFormat option containing the given subformat\n-    private static String toChoiceOption(Format format) {\n-        String beforeText = \"\";     \/\/quoteText(randomText());\n-        String afterText = \"\";      \/\/quoteText(randomText());\n+    \/\/ Create a MessageFormat pattern string that includes the given Format as a subformat.\n+    \/\/ The result will be one option in a ChoiceFormat which is nested in an outer MessageFormat.\n+    \/\/ A ChoiceFormat option string is just a plain string; it's only when that plain string\n+    \/\/ bubbles up to a containing MessageFormat that it gets interpreted as a MessageFormat string,\n+    \/\/ and that only happens if the option string contains a '{' character. That will always\n+    \/\/ be the case for the strings returned by this method of course.\n+    private static String randomMessageFormatContaining(Format format) {\n+        String beforeText = quoteText(randomText().replaceAll(\"\\\\{\", \"\"));     \/\/ avoid invalid MessageFormat syntax\n+        String afterText = quoteText(randomText().replaceAll(\"\\\\{\", \"\"));      \/\/ avoid invalid MessageFormat syntax\n@@ -248,6 +271,6 @@\n-        if (format instanceof DecimalFormat)\n-            middleText = String.format(\"{0,number,%s}\", ((DecimalFormat)format).toPattern());\n-        else if (format instanceof SimpleDateFormat)\n-            middleText = String.format(\"{1,date,%s}\", ((SimpleDateFormat)format).toPattern());\n-        else if (format instanceof ChoiceFormat)\n-            middleText = String.format(\"{2,choice,%s}\", ((ChoiceFormat)format).toPattern());\n+        if (format instanceof DecimalFormat dfmt)\n+            middleText = String.format(\"{0,number,%s}\", dfmt.toPattern());\n+        else if (format instanceof SimpleDateFormat sdfmt)\n+            middleText = String.format(\"{1,date,%s}\", sdfmt.toPattern());\n+        else if (format instanceof ChoiceFormat cfmt)\n+            middleText = String.format(\"{2,choice,%s}\", cfmt.toPattern());\n@@ -261,0 +284,14 @@\n+    private void showRoundTrip(MessageFormat format1, String pattern1, String result1, String pattern2, String result2) {\n+        print(0, format1);\n+        System.out.println();\n+        if (pattern1 != null)\n+            System.out.println(String.format(\"  pattern1 = %s\", javaLiteral(pattern1)));\n+        if (result1 != null)\n+            System.out.println(String.format(\"   result1 = %s\", javaLiteral(result1)));\n+        if (pattern2 != null)\n+            System.out.println(String.format(\"  pattern2 = %s\", javaLiteral(pattern2)));\n+        if (result2 != null)\n+            System.out.println(String.format(\"   result2 = %s\", javaLiteral(result2)));\n+        System.out.println();\n+    }\n+\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageFormatToPatternTest.java","additions":72,"deletions":35,"binary":false,"changes":107,"status":"modified"}]}