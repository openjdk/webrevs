{"files":[{"patch":"@@ -621,1 +621,5 @@\n-                copyAndQuoteExtraClosingBraces(subformatPattern, result);\n+\n+                \/\/ The subformat pattern comes already quoted, but only for those characters that are\n+                \/\/ special to the subformat. Therefore, we may need to quote additional characters.\n+                \/\/ The ones we care about at the MessageFormat level are '{' and '}'.\n+                copyAndQuoteBraces(subformatPattern, result);\n@@ -1651,6 +1655,6 @@\n-    \/\/ Quote runs of extra unquoted closing braces, where \"extra\" means not matching some unquoted opening brace.\n-    \/\/ Why? Because when a subformat pattern with unquoted extra closing braces is concatenated into a larger\n-    \/\/ containing pattern, the extra closing braces suddenly become significant because they can now match an\n-    \/\/ opening brace in the containing pattern. See JDK-8323699 for an example.\n-    private static void copyAndQuoteExtraClosingBraces(String source, StringBuilder target) {\n-        int braceDepth = 0;\n+    \/\/ Copy the text, but add quotes around any quotables that aren't already quoted\n+    private static void copyAndQuoteBraces(String source, StringBuilder target) {\n+\n+        \/\/ Analyze existing string for already quoted and newly quotable characters\n+        record Qchar(char ch, boolean quoted) { };\n+        ArrayList<Qchar> qchars = new ArrayList<>();\n@@ -1658,0 +1662,1 @@\n+        boolean anyChangeNeeded = false;\n@@ -1660,18 +1665,3 @@\n-            switch (ch) {\n-            case '\\'':\n-                quoted = !quoted;\n-                break;\n-            case '{':\n-                if (!quoted)\n-                    braceDepth++;\n-                break;\n-            case '}':\n-                if (quoted)\n-                    break;\n-                if (braceDepth > 0) {\n-                    braceDepth--;\n-                    break;\n-                }\n-                target.append(\"'}\");\n-                while (i + 1 < source.length() && source.charAt(i + 1) == '}') {\n-                    target.append('}');\n+            if (ch == '\\'') {\n+                if (i + 1 < source.length() && source.charAt(i + 1) == '\\'') {\n+                    qchars.add(new Qchar('\\'', quoted));\n@@ -1679,1 +1669,22 @@\n-                }\n+                } else\n+                    quoted = !quoted;\n+            } else {\n+                boolean quotable = ch == '{' || ch == '}';\n+                anyChangeNeeded |= quotable && !quoted;\n+                qchars.add(new Qchar(ch, quoted || quotable));\n+            }\n+        }\n+\n+        \/\/ Was any change needed?\n+        if (!anyChangeNeeded) {\n+            target.append(source);\n+            return;\n+        }\n+\n+        \/\/ Build new string, automaticaly consolidating adjacent runs of quoted chars\n+        quoted = false;\n+        for (Qchar qchar : qchars) {\n+            char ch = qchar.ch;\n+            if (ch == '\\'')\n+                target.append(ch);          \/\/ doubling works whether quoted or not\n+            else if (qchar.quoted() != quoted) {\n@@ -1681,3 +1692,1 @@\n-                continue;\n-            default:\n-                break;\n+                quoted = qchar.quoted();\n@@ -1687,0 +1696,2 @@\n+        if (quoted)\n+            target.append('\\'');\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":40,"deletions":29,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Check MessageFormat.toPattern() is equivalent to original pattern\n+ * @summary Verify MessageFormat.toPattern() is equivalent to original pattern\n@@ -31,0 +31,4 @@\n+import java.text.ChoiceFormat;\n+import java.text.DateFormat;\n+import java.text.DecimalFormat;\n+import java.text.Format;\n@@ -32,0 +36,7 @@\n+import java.text.NumberFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.stream.Stream;\n@@ -33,0 +44,2 @@\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -34,0 +47,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,2 +55,27 @@\n-    \/\/ Converting from MessageFormat to pattern string and back should give the same result.\n-    \/\/ For this to work the pattern string needs to quote any \"extra\" closing brace \"}\" characters.\n+    private static final int NUM_RANDOM_TEST_CASES = 1000;\n+    private static final int MAX_FORMAT_NESTING = 3;\n+\n+    private static Locale savedLocale;\n+    private static long randomSeed;             \/\/ set this to a non-zero value for reproducibility\n+    private static Random random;\n+    private static boolean spitSeed;\n+    private static int textCount;\n+\n+\/\/ Setup & Teardown\n+\n+    @BeforeAll\n+    public static void setup() {\n+        savedLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+        if (randomSeed == 0)\n+            randomSeed = new Random().nextLong();\n+        random = new Random(randomSeed);\n+    }\n+\n+    @AfterAll\n+    public static void teardown() {\n+        Locale.setDefault(savedLocale);\n+    }\n+\n+\/\/ Tests\n+\n@@ -42,1 +83,89 @@\n-    public void toPatternTest() {\n+    public void testJDK_8323699() {\n+\n+        \/\/ This is the test case from JDK-8323699\n+        testRoundTrip(new MessageFormat(\"{2,choice,0.0#option A: {0}|1.0#option B: {0}'}'}\"));\n+\n+        \/\/ A few more test cases from the PR#17416 discussion\n+        testRoundTrip(new MessageFormat(\"Test: {0,number,foo'{'#.00}\"));\n+        testRoundTrip(new MessageFormat(\"Test: {0,number,foo'}'#.00}\"));\n+    }\n+\n+    \/\/ Go roundrip from MessageFormat -> pattern string -> MessageFormat and verify equivalence\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    public void testRoundTrip(MessageFormat format1) {\n+\n+        \/\/ Prepare MessageFormat argument\n+        Object[] args = new Object[] {\n+            8.5,                            \/\/ argument for DecimalFormat\n+            new Date(1705502102677L),       \/\/ argument for SimpleDateFormat\n+            random.nextInt(6)               \/\/ argument for ChoiceFormat\n+        };\n+\n+        String pattern1 = null;\n+        String result1 = null;\n+        String pattern2 = null;\n+        String result2 = null;\n+        try {\n+\n+            \/\/ Format using the given MessageFormat\n+            pattern1 = format1.toPattern();\n+            result1 = format1.format(args);\n+\n+            \/\/ Round-trip via toPattern() and repeat\n+            MessageFormat format2 = new MessageFormat(pattern1);\n+            pattern2 = format2.toPattern();\n+            result2 = format2.format(args);\n+\n+            \/\/ Check equivalence\n+            assertEquals(result1, result2);\n+            assertEquals(pattern1, pattern2);\n+        } catch (RuntimeException | Error e) {\n+            System.out.println(String.format(\"%n********** FAILURE **********%n\"));\n+            System.out.println(String.format(\"%s%n\", e));\n+            if (!spitSeed) {\n+                System.out.println(String.format(\"*** Random seed was 0x%016xL%n\", randomSeed));\n+                spitSeed = true;\n+            }\n+            print(0, format1);\n+            System.out.println();\n+            if (pattern1 != null)\n+                System.out.println(String.format(\"  pattern1 = %s\", javaLiteral(pattern1)));\n+            if (result1 != null)\n+                System.out.println(String.format(\"   result1 = %s\", javaLiteral(result1)));\n+            if (pattern2 != null)\n+                System.out.println(String.format(\"  pattern2 = %s\", javaLiteral(pattern2)));\n+            if (result2 != null)\n+                System.out.println(String.format(\"   result2 = %s\", javaLiteral(result2)));\n+            System.out.println();\n+            throw e;\n+        }\n+    }\n+\n+    public static Stream<Arguments> testCases() {\n+        final ArrayList<Arguments> argList = new ArrayList<>();\n+        for (int i = 0; i < NUM_RANDOM_TEST_CASES; i++)\n+            argList.add(Arguments.of(randomFormat()));\n+        return argList.stream();\n+    }\n+\n+    \/\/ Generate a \"random\" MessageFormat. We do this by creating a MessageFormat with \"{0}\" placeholders\n+    \/\/ and then substituting in random DecimalFormat, DateFormat, and ChoiceFormat subformats. The goal here\n+    \/\/ is to avoid using pattern strings to construct formats, because they're what we're trying to check.\n+    private static MessageFormat randomFormat() {\n+\n+        \/\/ Create a temporary MessageFormat containing \"{0}\" placeholders and random text\n+        StringBuilder tempPattern = new StringBuilder();\n+        int numParts = random.nextInt(3) + 1;\n+        for (int i = 0; i < numParts; i++) {\n+            if (random.nextBoolean())\n+                tempPattern.append(\"{0}\");      \/\/ temporary placeholder for a subformat\n+            else\n+                tempPattern.append(quoteText(randomText()));\n+        }\n+\n+        \/\/ Replace all the \"{0}\" placeholders with random subformats\n+        MessageFormat format = new MessageFormat(tempPattern.toString());\n+        Format[] formats = format.getFormats();\n+        for (int i = 0; i < formats.length; i++) {\n+            formats[i] = randomSubFormat(0);\n@@ -44,3 +173,2 @@\n-        String pattern1 = \"{0,choice,0.0#option A: {1}|1.0#option B: {1}'}'}\";\n-        MessageFormat format1 = new MessageFormat(pattern1);\n-        String result1 = format1.format(new Object[] { 0, 5 });\n+        }\n+        format.setFormats(formats);\n@@ -48,3 +176,128 @@\n-        String pattern2 = format1.toPattern();\n-        MessageFormat format2 = new MessageFormat(pattern2);\n-        String result2 = format2.format(new Object[] { 0, 5 });\n+        \/\/ Done\n+        return format;\n+    }\n+\n+    \/\/ Generate some random text\n+    private static String randomText() {\n+        StringBuilder buf = new StringBuilder();\n+        int length = random.nextInt(6);\n+        for (int i = 0; i < length; i++) {\n+            char ch = (char)(0x20 + random.nextInt(0x5f));\n+            buf.append(ch);\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/\/ Quote non-alphanumeric characters in the given plain text\n+    private static String quoteText(String string) {\n+        StringBuilder buf = new StringBuilder();\n+        boolean quoted = false;\n+        for (int i = 0; i < string.length(); i++) {\n+            char ch = string.charAt(i);\n+            if (ch == '\\'')\n+                buf.append(\"''\");\n+            else if (!(ch == ' ' || Character.isLetter(ch) || Character.isDigit(ch))) {\n+                if (!quoted) {\n+                    buf.append('\\'');\n+                    quoted = true;\n+                }\n+                buf.append(ch);\n+            } else {\n+                if (quoted) {\n+                    buf.append('\\'');\n+                    quoted = false;\n+                }\n+                buf.append(ch);\n+            }\n+        }\n+        if (quoted)\n+            buf.append('\\'');\n+        return buf.toString();\n+    }\n+\n+    \/\/ Create a random subformat\n+    private static Format randomSubFormat(int nesting) {\n+        int which;\n+        if (nesting >= MAX_FORMAT_NESTING)\n+            which = random.nextInt(2);          \/\/ no more recursion\n+        else\n+            which = random.nextInt(3);\n+        switch (which) {\n+        case 0:\n+            return new DecimalFormat(\"#.##\");\n+        case 1:\n+            return new SimpleDateFormat(\"YYYY-MM-DD\");\n+        default:\n+            int numChoices = random.nextInt(3) + 1;\n+            assert numChoices > 0;\n+            final double[] limits = new double[numChoices];\n+            final String[] formats = new String[numChoices];\n+            for (int i = 0; i < limits.length; i++) {\n+                limits[i] = (double)i;\n+                formats[i] = toChoiceOption(randomSubFormat(nesting + 1));\n+            }\n+            return new ChoiceFormat(limits, formats);\n+        }\n+    }\n+\n+    \/\/ Create one ChoiceFormat option containing the given subformat\n+    private static String toChoiceOption(Format format) {\n+        String beforeText = \"\";     \/\/quoteText(randomText());\n+        String afterText = \"\";      \/\/quoteText(randomText());\n+        String middleText;\n+        if (format instanceof DecimalFormat)\n+            middleText = String.format(\"{0,number,%s}\", ((DecimalFormat)format).toPattern());\n+        else if (format instanceof SimpleDateFormat)\n+            middleText = String.format(\"{1,date,%s}\", ((SimpleDateFormat)format).toPattern());\n+        else if (format instanceof ChoiceFormat)\n+            middleText = String.format(\"{2,choice,%s}\", ((ChoiceFormat)format).toPattern());\n+        else\n+            throw new RuntimeException(\"internal error\");\n+        return String.format(\"text%d [%s] %s text%d [%s]\", ++textCount, beforeText, middleText, ++textCount, afterText);\n+    }\n+\n+\/\/ Debug printing\n+\n+    private static void print(int depth, Object format) {\n+        if (format == null)\n+            return;\n+        if (format instanceof String)\n+            System.out.println(String.format(\"%s- %s\", indent(depth), javaLiteral((String)format)));\n+        else if (format instanceof MessageFormat)\n+            print(depth, (MessageFormat)format);\n+        else if (format instanceof DecimalFormat)\n+            print(depth, (DecimalFormat)format);\n+        else if (format instanceof SimpleDateFormat)\n+            print(depth, (SimpleDateFormat)format);\n+        else if (format instanceof ChoiceFormat)\n+            print(depth, (ChoiceFormat)format);\n+        else\n+            throw new RuntimeException(\"internal error: \" + format.getClass());\n+    }\n+\n+    private static void print(int depth, MessageFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"MessageFormat\", javaLiteral(format.toPattern())));\n+        for (Format subformat : format.getFormats())\n+            print(depth + 1, subformat);\n+    }\n+\n+    private static void print(int depth, DecimalFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"DecimalFormat\", javaLiteral(format.toPattern())));\n+    }\n+\n+    private static void print(int depth, SimpleDateFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"SimpleDateFormat\", javaLiteral(format.toPattern())));\n+    }\n+\n+    private static void print(int depth, ChoiceFormat format) {\n+        System.out.println(String.format(\"%s- %s: %s\", indent(depth), \"ChoiceFormat\", javaLiteral(format.toPattern())));\n+        for (Object subformat : format.getFormats())\n+            print(depth + 1, subformat);\n+    }\n+\n+    private static String indent(int depth) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < depth; i++)\n+            buf.append(\"    \");\n+        return buf.toString();\n+    }\n@@ -52,1 +305,17 @@\n-        assertEquals(result1, result2);\n+    \/\/ Print a Java string in double quotes so it looks like a String literal (for easy pasting into jshell)\n+    private static String javaLiteral(String string) {\n+        StringBuilder buf = new StringBuilder();\n+        buf.append('\"');\n+        for (int i = 0; i < string.length(); i++) {\n+            char ch = string.charAt(i);\n+            switch (ch) {\n+            case '\"':\n+            case '\\\\':\n+                buf.append('\\\\');\n+                \/\/ FALLTHROUGH\n+            default:\n+                buf.append(ch);\n+                break;\n+            }\n+        }\n+        return buf.append('\"').toString();\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageFormatToPatternTest.java","additions":280,"deletions":11,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+    private static String quotedChoicePattern = choicePattern.replaceAll(\"([{}])\", \"'$1'\");\n@@ -59,1 +60,1 @@\n-        checkPattern(format.toPattern(), \"{3,choice,\" + choicePattern + \"}, {2}, {0,number}\");\n+        checkPattern(format.toPattern(), \"{3,choice,\" + quotedChoicePattern + \"}, {2}, {0,number}\");\n@@ -76,1 +77,2 @@\n-        checkPattern(format.toPattern(), \"{3,choice,\" + choicePattern + \"}, {2,number}, {0,choice,\" + choicePattern + \"}\");\n+        checkPattern(format.toPattern(),\n+          \"{3,choice,\" + quotedChoicePattern + \"}, {2,number}, {0,choice,\" + quotedChoicePattern + \"}\");\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageFormatsByArgumentIndex.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        MessageFormat fmt = new MessageFormat(\"{0,choice,0#no files|1#one file|1< {0,number,integer} files}\");\n+        MessageFormat fmt = new MessageFormat(\"{0,choice,0.0#no files|1.0#one file|1.0< '{'0,number,integer'}' files}\");\n@@ -119,1 +119,1 @@\n-        if (!pat.equals(\"{0,choice,0.0#no files|1.0#one file|1.0< {0,number,integer} files}\")) {\n+        if (!pat.equals(\"{0,choice,0.0#no files|1.0#one file|1.0< '{'0,number,integer'}' files}\")) {\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageRegression.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}