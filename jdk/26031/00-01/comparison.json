{"files":[{"patch":"@@ -123,0 +123,1 @@\n+  assert(!_method->is_old(), \"the breakpoint method shouldn't be old\");\n@@ -186,0 +187,2 @@\n+\/\/ The caller of VM_ChangeBreakpoints operation should ensure that\n+\/\/ _bp.method is preserved until VM_ChangeBreakpoints is processed.\n@@ -188,4 +191,4 @@\n- if (_bp->method() != Method::resolve_jmethod_id(_preservred_method)) {\n-   \/\/ the jmethod_id's method was updated if class redefintion happened for this class\n-   \/\/ after JvmtBreakpoint was created but before JVM_ChangeBreakpoints started\n-   \/\/ all class breakpoints are cleared during redefinition so don't set\/clear this breakpoint\n+  if (_bp->method()->is_old()) {\n+    \/\/ The bp->_method become old because VMOp with class redefinition happened for this class\n+    \/\/ fter JvmtBreakpoint was created but before JVM_ChangeBreakpoints started.\n+    \/\/ All class breakpoints are cleared during redefinition, so don't set\/clear this breakpoint.\n@@ -258,0 +261,3 @@\n+\n+  \/\/ ensure that bp._method is not deallocated before VM_ChangeBreakpoints::doit()\n+  methodHandle mh(Thread::current(), bp.method());\n@@ -268,0 +274,2 @@\n+  \/\/ ensure that bp._method is not deallocated before VM_ChangeBreakpoints::doit()\n+  methodHandle mh(Thread::current(), bp.method());\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"oops\/method.hpp\"\n@@ -144,1 +143,1 @@\n-  jmethodID         _preservred_method; \/\/needed to track class redefintion\n+\n@@ -154,1 +153,0 @@\n-    _preservred_method = bp->method()->jmethod_id();\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}