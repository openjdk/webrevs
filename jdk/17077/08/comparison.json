{"files":[{"patch":"@@ -61,1 +61,1 @@\n-G1ConcurrentRefineThreadControl::G1ConcurrentRefineThreadControl() :\n+G1ConcurrentRefineThreadControl::G1ConcurrentRefineThreadControl(uint max_num_threads) :\n@@ -63,2 +63,1 @@\n-  _threads(nullptr),\n-  _max_num_threads(0)\n+  _threads(max_num_threads)\n@@ -68,13 +67,12 @@\n-  if (_threads != nullptr) {\n-    for (uint i = 0; i < _max_num_threads; i++) {\n-      G1ConcurrentRefineThread* t = _threads[i];\n-      if (t == nullptr) {\n-#ifdef ASSERT\n-        for (uint j = i + 1; j < _max_num_threads; ++j) {\n-          assert(_threads[j] == nullptr, \"invariant\");\n-        }\n-#endif \/\/ ASSERT\n-        break;\n-      } else {\n-        delete t;\n-      }\n+  while (_threads.is_nonempty()) {\n+    delete _threads.pop();\n+  }\n+}\n+\n+bool G1ConcurrentRefineThreadControl::ensure_threads_created(uint worker_id, bool initializing) {\n+  assert(worker_id < max_num_threads(), \"precondition\");\n+\n+  while ((uint)_threads.length() <= worker_id) {\n+    G1ConcurrentRefineThread* rt = create_refinement_thread(_threads.length(), initializing);\n+    if (rt == nullptr) {\n+      return false;\n@@ -82,1 +80,1 @@\n-    FREE_C_HEAP_ARRAY(G1ConcurrentRefineThread*, _threads);\n+    _threads.push(rt);\n@@ -84,0 +82,2 @@\n+\n+  return true;\n@@ -86,1 +86,1 @@\n-jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint max_num_threads) {\n+jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr) {\n@@ -89,4 +89,0 @@\n-  _max_num_threads = max_num_threads;\n-\n-  if (max_num_threads > 0) {\n-    _threads = NEW_C_HEAP_ARRAY(G1ConcurrentRefineThread*, max_num_threads, mtGC);\n@@ -94,2 +90,3 @@\n-    _threads[0] = create_refinement_thread(0, true);\n-    if (_threads[0] == nullptr) {\n+  if (max_num_threads() > 0) {\n+    _threads.push(create_refinement_thread(0, true));\n+    if (_threads.at(0) == nullptr) {\n@@ -100,11 +97,4 @@\n-    if (UseDynamicNumberOfGCThreads) {\n-      for (uint i = 1; i < max_num_threads; ++i) {\n-        _threads[i] = nullptr;\n-      }\n-    } else {\n-      for (uint i = 1; i < max_num_threads; ++i) {\n-        _threads[i] = create_refinement_thread(i, true);\n-        if (_threads[i] == nullptr) {\n-          vm_shutdown_during_initialization(\"Could not allocate refinement threads.\");\n-          return JNI_ENOMEM;\n-        }\n+    if (!UseDynamicNumberOfGCThreads) {\n+      if (!ensure_threads_created(max_num_threads() - 1, true)) {\n+        vm_shutdown_during_initialization(\"Could not allocate refinement threads\");\n+        return JNI_ENOMEM;\n@@ -120,2 +110,1 @@\n-  assert(_threads != nullptr, \"No threads\");\n-  assert(Thread::current() == _threads[0], \"Not primary thread\");\n+  assert(Thread::current() == _threads.at(0), \"Not primary thread\");\n@@ -126,8 +115,3 @@\n-  assert(worker_id < _max_num_threads, \"precondition\");\n-  G1ConcurrentRefineThread* thread_to_activate = _threads[worker_id];\n-  if (thread_to_activate == nullptr) {\n-    thread_to_activate = create_refinement_thread(worker_id, false);\n-    if (thread_to_activate == nullptr) {\n-      return false;\n-    }\n-    _threads[worker_id] = thread_to_activate;\n+  if (ensure_threads_created(worker_id, false)) {\n+    _threads.at(worker_id)->activate();\n+    return true;\n@@ -135,2 +119,2 @@\n-  thread_to_activate->activate();\n-  return true;\n+\n+  return false;\n@@ -140,4 +124,2 @@\n-  for (uint i = 0; i < _max_num_threads; i++) {\n-    if (_threads[i] != nullptr) {\n-      tc->do_thread(_threads[i]);\n-    }\n+  for (uint i = 0; i < (uint)_threads.length(); i++) {\n+    tc->do_thread(_threads.at(i));\n@@ -148,4 +130,2 @@\n-  for (uint i = 0; i < _max_num_threads; i++) {\n-    if (_threads[i] != nullptr) {\n-      _threads[i]->stop();\n-    }\n+  for (uint i = 0; i < (uint)_threads.length(); i++) {\n+    _threads.at(i)->stop();\n@@ -173,1 +153,1 @@\n-  _thread_control(),\n+  _thread_control(G1ConcRefinementThreads),\n@@ -178,1 +158,1 @@\n-  return _thread_control.initialize(this, G1ConcRefinementThreads);\n+  return _thread_control.initialize(this);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":37,"deletions":57,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -46,2 +47,1 @@\n-  G1ConcurrentRefineThread** _threads;\n-  uint _max_num_threads;\n+  GrowableArrayCHeap<G1ConcurrentRefineThread*, mtGC> _threads;\n@@ -53,0 +53,2 @@\n+  bool ensure_threads_created(uint worker_id, bool initializing);\n+\n@@ -56,1 +58,1 @@\n-  G1ConcurrentRefineThreadControl();\n+  G1ConcurrentRefineThreadControl(uint max_num_threads);\n@@ -59,1 +61,1 @@\n-  jint initialize(G1ConcurrentRefine* cr, uint max_num_threads);\n+  jint initialize(G1ConcurrentRefine* cr);\n@@ -63,1 +65,1 @@\n-  uint max_num_threads() const { return _max_num_threads; }\n+  uint max_num_threads() const { return _threads.capacity(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}