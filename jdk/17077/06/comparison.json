{"files":[{"patch":"@@ -61,1 +61,1 @@\n-G1ConcurrentRefineThreadControl::G1ConcurrentRefineThreadControl() :\n+G1ConcurrentRefineThreadControl::G1ConcurrentRefineThreadControl(uint max_num_threads) :\n@@ -63,2 +63,1 @@\n-  _threads(nullptr),\n-  _max_num_threads(0)\n+  _threads(max_num_threads)\n@@ -68,13 +67,15 @@\n-  if (_threads != nullptr) {\n-    for (uint i = 0; i < _max_num_threads; i++) {\n-      G1ConcurrentRefineThread* t = _threads[i];\n-      if (t == nullptr) {\n-#ifdef ASSERT\n-        for (uint j = i + 1; j < _max_num_threads; ++j) {\n-          assert(_threads[j] == nullptr, \"invariant\");\n-        }\n-#endif \/\/ ASSERT\n-        break;\n-      } else {\n-        delete t;\n-      }\n+  while (_threads.is_nonempty()) {\n+    delete _threads.pop();\n+  }\n+}\n+\n+bool G1ConcurrentRefineThreadControl::ensure_threads_created(uint worker_id, bool initializing) {\n+  assert(worker_id < max_num_threads(), \"precondition\");\n+\n+  while ((uint)_threads.length() <= worker_id) {\n+    G1ConcurrentRefineThread* rt = create_refinement_thread(_threads.length(), initializing);\n+    _threads.push(rt);\n+\n+    if (rt == nullptr) {\n+      _threads.pop();\n+      return false;\n@@ -82,1 +83,0 @@\n-    FREE_C_HEAP_ARRAY(G1ConcurrentRefineThread*, _threads);\n@@ -84,0 +84,2 @@\n+\n+  return true;\n@@ -86,1 +88,1 @@\n-jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint max_num_threads) {\n+jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr) {\n@@ -89,4 +91,0 @@\n-  _max_num_threads = max_num_threads;\n-\n-  if (max_num_threads > 0) {\n-    _threads = NEW_C_HEAP_ARRAY(G1ConcurrentRefineThread*, max_num_threads, mtGC);\n@@ -94,2 +92,3 @@\n-    _threads[0] = create_refinement_thread(0, true);\n-    if (_threads[0] == nullptr) {\n+  if (max_num_threads() > 0) {\n+    uint ensure_id = UseDynamicNumberOfGCThreads ? 0 : max_num_threads() - 1;\n+    if (!ensure_threads_created(ensure_id, true)) {\n@@ -99,14 +98,0 @@\n-\n-    if (UseDynamicNumberOfGCThreads) {\n-      for (uint i = 1; i < max_num_threads; ++i) {\n-        _threads[i] = nullptr;\n-      }\n-    } else {\n-      for (uint i = 1; i < max_num_threads; ++i) {\n-        _threads[i] = create_refinement_thread(i, true);\n-        if (_threads[i] == nullptr) {\n-          vm_shutdown_during_initialization(\"Could not allocate refinement threads.\");\n-          return JNI_ENOMEM;\n-        }\n-      }\n-    }\n@@ -120,2 +105,1 @@\n-  assert(_threads != nullptr, \"No threads\");\n-  assert(Thread::current() == _threads[0], \"Not primary thread\");\n+  assert(Thread::current() == _threads.at(0), \"Not primary thread\");\n@@ -126,8 +110,3 @@\n-  assert(worker_id < _max_num_threads, \"precondition\");\n-  G1ConcurrentRefineThread* thread_to_activate = _threads[worker_id];\n-  if (thread_to_activate == nullptr) {\n-    thread_to_activate = create_refinement_thread(worker_id, false);\n-    if (thread_to_activate == nullptr) {\n-      return false;\n-    }\n-    _threads[worker_id] = thread_to_activate;\n+  if (ensure_threads_created(worker_id, false)) {\n+    _threads.at(worker_id)->activate();\n+    return true;\n@@ -135,2 +114,2 @@\n-  thread_to_activate->activate();\n-  return true;\n+\n+  return false;\n@@ -140,3 +119,3 @@\n-  for (uint i = 0; i < _max_num_threads; i++) {\n-    if (_threads[i] != nullptr) {\n-      tc->do_thread(_threads[i]);\n+  for (uint i = 0; i < max_num_threads(); i++) {\n+    if (_threads.at(i) != nullptr) {\n+      tc->do_thread(_threads.at(i));\n@@ -148,3 +127,3 @@\n-  for (uint i = 0; i < _max_num_threads; i++) {\n-    if (_threads[i] != nullptr) {\n-      _threads[i]->stop();\n+  for (uint i = 0; i < max_num_threads(); i++) {\n+    if (_threads.at(i) != nullptr) {\n+      _threads.at(i)->stop();\n@@ -173,1 +152,1 @@\n-  _thread_control(),\n+  _thread_control(G1ConcRefinementThreads),\n@@ -178,1 +157,1 @@\n-  return _thread_control.initialize(this, G1ConcRefinementThreads);\n+  return _thread_control.initialize(this);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":37,"deletions":58,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -46,2 +47,1 @@\n-  G1ConcurrentRefineThread** _threads;\n-  uint _max_num_threads;\n+  GrowableArrayCHeap<G1ConcurrentRefineThread*, mtGC> _threads;\n@@ -56,1 +56,1 @@\n-  G1ConcurrentRefineThreadControl();\n+  G1ConcurrentRefineThreadControl(uint max_num_threads);\n@@ -59,1 +59,1 @@\n-  jint initialize(G1ConcurrentRefine* cr, uint max_num_threads);\n+  jint initialize(G1ConcurrentRefine* cr);\n@@ -63,1 +63,1 @@\n-  uint max_num_threads() const { return _max_num_threads; }\n+  uint max_num_threads() const { return _threads.capacity(); }\n@@ -74,0 +74,3 @@\n+\n+private:\n+  bool ensure_threads_created(uint worker_id, bool initializing);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"}]}