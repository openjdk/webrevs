{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n@@ -34,2 +32,0 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n@@ -37,0 +33,1 @@\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -38,0 +35,1 @@\n+import java.util.Arrays;\n@@ -45,1 +43,3 @@\n-import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n@@ -48,0 +48,23 @@\n+ * An adapter for {@link BasicImageReader} to present jimage resources in a\n+ * file system friendly way. The jimage entries (resources, module and package\n+ * information) are mapped into a unified hierarchy of named nodes, which serve\n+ * as the underlying structure for the {@code JrtFileSystem} and other utilities.\n+ *\n+ * <p>This class is not a conceptual subtype of {@code BasicImageReader} and\n+ * deliberately hides types such as {@code ImageLocation} to give a focused API\n+ * based only on the {@link Node} type. Entries in jimage are expressed as one\n+ * of three {@link Node} types resource nodes, directory nodes and link nodes.\n+ *\n+ * <p>When remapping jimage entries, jimage location names (e.g. {@code\n+ * \"\/java.base\/java\/lang\/Integer.class\"}) are prefixed with {@code \"\/modules\"}\n+ * to form the names of resource nodes. This aligns with the naming of module\n+ * entries in jimage (e.g. \"\/modules\/java.base\/java\/lang\"), which appear as\n+ * directory nodes in {@code ImageReader}.\n+ *\n+ * <p>Package entries (e.g. {@code \"\/packages\/java.lang\"} appear as directory\n+ * nodes containing link nodes, which resolve back to the root directory of the\n+ * module in which that package exists (e.g. {@code \"\/modules\/java.base\"}).\n+ * Unlike other nodes, the jimage file does not contain explicit entries for\n+ * link nodes, and their existence is derived only from the contents of the\n+ * parent directory.\n+ *\n@@ -63,0 +86,8 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * given byte order.\n+     *\n+     * <p>Almost all callers should use {@link #open(Path)} to obtain a reader\n+     * with the platform native byte ordering. Using a non-native ordering is\n+     * extremely unusual.\n+     *\/\n@@ -70,0 +101,7 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * platform native byte order.\n+     *\n+     * <p>This is the expected was to open an {@code ImageReader}, and it should\n+     * be rare for anything other than the native byte order to be needed.\n+     *\/\n@@ -95,7 +133,7 @@\n-    \/\/ directory management interface\n-    public Directory getRootDirectory() throws IOException {\n-        ensureOpen();\n-        return reader.getRootDirectory();\n-    }\n-\n-\n+    \/**\n+     * Finds the node for the given JRT file system name.\n+     *\n+     * @param name a JRT file system name (path) of the form\n+     * {@code \"\/modules\/<module>\/...} or {@code \"\/packages\/<package>\/...}.\n+     * @return a node representing a resource, directory or symbolic link.\n+     *\/\n@@ -107,0 +145,8 @@\n+    \/**\n+     * Returns a copy of the content of a resource node. The buffer returned by\n+     * this method is not cached by the node, and each call returns a new array\n+     * instance.\n+     *\n+     * @throws IOException if the content cannot be returned (including if the\n+     * given node is not a resource node).\n+     *\/\n@@ -112,10 +158,7 @@\n-    public byte[] getResource(Resource rs) throws IOException {\n-        ensureOpen();\n-        return reader.getResource(rs);\n-    }\n-\n-    public ImageHeader getHeader() {\n-        requireOpen();\n-        return reader.getHeader();\n-    }\n-\n+    \/**\n+     * Releases a (possibly cached) {@link ByteBuffer} obtained via\n+     * {@link #getResourceBuffer(Node)}.\n+     *\n+     * <p>Note that no testing is performed to check whether the buffer about\n+     * to be released actually came from a call to {@code getResourceBuffer()}.\n+     *\/\n@@ -126,31 +169,6 @@\n-    public String getName() {\n-        requireOpen();\n-        return reader.getName();\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        requireOpen();\n-        return reader.getByteOrder();\n-    }\n-\n-    public Path getImagePath() {\n-        requireOpen();\n-        return reader.getImagePath();\n-    }\n-\n-    public ImageStringsReader getStrings() {\n-        requireOpen();\n-        return reader.getStrings();\n-    }\n-\n-    public ImageLocation findLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.findLocation(mn, rn);\n-    }\n-\n-    public boolean verifyLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.verifyLocation(mn, rn);\n-    }\n-\n-    public ImageLocation findLocation(String name) {\n+    \/**\n+     * Returns the content of a resource node in a possibly cached byte buffer.\n+     * Callers of this method must call {@link #releaseByteBuffer(ByteBuffer)}\n+     * when they are finished with it.\n+     *\/\n+    public ByteBuffer getResourceBuffer(Node node) {\n@@ -158,47 +176,4 @@\n-        return reader.findLocation(name);\n-    }\n-\n-    public String[] getEntryNames() {\n-        requireOpen();\n-        return reader.getEntryNames();\n-    }\n-\n-    public String[] getModuleNames() {\n-        requireOpen();\n-        int off = \"\/modules\/\".length();\n-        return reader.findNode(\"\/modules\")\n-                     .getChildren()\n-                     .stream()\n-                     .map(Node::getNameString)\n-                     .map(s -> s.substring(off, s.length()))\n-                     .toArray(String[]::new);\n-    }\n-\n-    public long[] getAttributes(int offset) {\n-        requireOpen();\n-        return reader.getAttributes(offset);\n-    }\n-\n-    public String getString(int offset) {\n-        requireOpen();\n-        return reader.getString(offset);\n-    }\n-\n-    public byte[] getResource(String name) {\n-        requireOpen();\n-        return reader.getResource(name);\n-    }\n-\n-    public byte[] getResource(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResource(loc);\n-    }\n-\n-    public ByteBuffer getResourceBuffer(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResourceBuffer(loc);\n-    }\n-\n-    public InputStream getResourceStream(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResourceStream(loc);\n+        if (!node.isResource()) {\n+            throw new IllegalStateException(\"Not a resource node: \" + node);\n+        }\n+        return reader.getResourceBuffer(node.getLocation());\n@@ -208,3 +183,7 @@\n-        static final int SIZE_OF_OFFSET = Integer.BYTES;\n-\n-        static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        private static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        private static final String MODULES_ROOT = \"\/modules\";\n+        private static final String PACKAGES_ROOT = \"\/packages\";\n+        \/\/ There are >30,000 nodes in a complete jimage tree, and even relatively\n+        \/\/ common tasks (e.g. starting up javac) load somewhere in the region of\n+        \/\/ 1000 classes. Thus, an initial capacity of 2000 is a reasonable guess.\n+        private static final int INITIAL_NODE_CACHE_CAPACITY = 2000;\n@@ -213,1 +192,1 @@\n-        final Set<ImageReader> openers;\n+        private final Set<ImageReader> openers = new HashSet<>();\n@@ -215,1 +194,1 @@\n-        \/\/ attributes of the .jimage file. jimage file does not contain\n+        \/\/ Attributes of the .jimage file. The jimage file does not contain\n@@ -218,6 +197,1 @@\n-        \/\/ Iniitalized lazily, see {@link #imageFileAttributes()}.\n-        BasicFileAttributes imageFileAttributes;\n-\n-        \/\/ directory management implementation\n-        final HashMap<String, Node> nodes;\n-        volatile Directory rootDir;\n+        private final BasicFileAttributes imageFileAttributes;\n@@ -225,2 +199,5 @@\n-        Directory packagesDir;\n-        Directory modulesDir;\n+        \/\/ Cache of all user visible nodes, guarded by synchronizing 'this' instance.\n+        private final HashMap<String, Node> nodes;\n+        \/\/ Used to classify ImageLocation instances without string comparison.\n+        private final int modulesStringOffset;\n+        private final int packagesStringOffset;\n@@ -230,5 +207,31 @@\n-            this.openers = new HashSet<>();\n-            this.nodes = new HashMap<>();\n-        }\n-\n-        public static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n+            this.imageFileAttributes = Files.readAttributes(imagePath, BasicFileAttributes.class);\n+            this.nodes = new HashMap<>(INITIAL_NODE_CACHE_CAPACITY);\n+            \/\/ Pick stable jimage names from which to extract string offsets (we cannot\n+            \/\/ use \"\/modules\" or \"\/packages\", since those have a module offset of zero).\n+            this.modulesStringOffset = getModuleOffset(\"\/modules\/java.base\");\n+            this.packagesStringOffset = getModuleOffset(\"\/packages\/java.lang\");\n+\n+            \/\/ Node creation is very lazy, so we can just make the top-level directories\n+            \/\/ now without the risk of triggering the building of lots of other nodes.\n+            Directory packages = newDirectory(PACKAGES_ROOT);\n+            nodes.put(packages.getName(), packages);\n+            Directory modules = newDirectory(MODULES_ROOT);\n+            nodes.put(modules.getName(), modules);\n+\n+            Directory root = newDirectory(\"\/\");\n+            root.setChildren(Arrays.asList(packages, modules));\n+            nodes.put(root.getName(), root);\n+        }\n+\n+        \/\/\/ Returns the offset of the string denoting the leading \"module\" segment\n+        \/\/\/ in the given path (e.g. `<module>\/<path>`). We can't just pass in the\n+        \/\/\/ `\/<module>` string here because that has a module offset of zero.\n+        private int getModuleOffset(String path) {\n+            ImageLocation location = findLocation(path);\n+            assert location != null : \"Cannot find expected jimage location: \" + path;\n+            int offset = location.getModuleOffset();\n+            assert offset != 0 : \"Invalid module offset for jimage location: \" + path;\n+            return offset;\n+        }\n+\n+        private static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n@@ -267,1 +270,0 @@\n-                    rootDir = null;\n@@ -276,36 +278,20 @@\n-        void addOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                openers.add(reader);\n-            }\n-        }\n-\n-        boolean removeOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                return openers.remove(reader);\n-            }\n-        }\n-\n-        \/\/ directory management interface\n-        Directory getRootDirectory() {\n-            return buildRootDirectory();\n-        }\n-\n-        \/**\n-         * Lazily build a node from a name.\n-         *\/\n-        synchronized Node buildNode(String name) {\n-            Node n;\n-            boolean isPackages = name.startsWith(\"\/packages\");\n-            boolean isModules = !isPackages && name.startsWith(\"\/modules\");\n-\n-            if (!(isModules || isPackages)) {\n-                return null;\n-            }\n-\n-            ImageLocation loc = findLocation(name);\n-\n-            if (loc != null) { \/\/ A sub tree node\n-                if (isPackages) {\n-                    n = handlePackages(name, loc);\n-                } else { \/\/ modules sub tree\n-                    n = handleModulesSubTree(name, loc);\n+        \/\/\/ Returns a node in the JRT filesystem namespace, or null if no resource or\n+        \/\/\/ directory of that name exists.\n+        \/\/\/\n+        \/\/\/ This is the only public API by which anything outside this class can access\n+        \/\/\/ `Node` instances either directly, or by resolving symbolic links.\n+        \/\/\/\n+        \/\/\/ Note also that there is no reentrant calling back to this method from within\n+        \/\/\/ the node handling code.\n+        \/\/\/\n+        \/\/\/ @param name an absolute, `\/`-separated path string, prefixed with either\n+        \/\/\/     \"\/modules\" or \"\/packages\".\n+        synchronized Node findNode(String name) {\n+            Node node = nodes.get(name);\n+            if (node == null) {\n+                \/\/ We cannot get the root paths (\"\/modules\" or \"\/packages\") here\n+                \/\/ because those nodes are already in the nodes cache.\n+                if (name.startsWith(MODULES_ROOT + \"\/\")) {\n+                    node = buildModulesNode(name);\n+                } else if (name.startsWith(PACKAGES_ROOT + \"\/\")) {\n+                    node = buildPackagesNode(name);\n@@ -313,7 +299,2 @@\n-            } else { \/\/ Asking for a resource? \/modules\/java.base\/java\/lang\/Object.class\n-                if (isModules) {\n-                    n = handleResource(name);\n-                } else {\n-                    \/\/ Possibly ask for \/packages\/java.lang\/java.base\n-                    \/\/ although \/packages\/java.base not created\n-                    n = handleModuleLink(name);\n+                if (node != null) {\n+                    nodes.put(node.getName(), node);\n@@ -321,0 +302,4 @@\n+            } else if (!node.isCompleted()) {\n+                \/\/ Only directories can be incomplete.\n+                assert node instanceof Directory : \"Invalid incomplete node: \" + node;\n+                completeDirectory((Directory) node);\n@@ -322,1 +307,2 @@\n-            return n;\n+            assert node == null || node.isCompleted() : \"Incomplete node: \" + node;\n+            return node;\n@@ -325,37 +311,12 @@\n-        synchronized Directory buildRootDirectory() {\n-            Directory root = rootDir; \/\/ volatile read\n-            if (root != null) {\n-                return root;\n-            }\n-\n-            root = newDirectory(null, \"\/\");\n-            root.setIsRootDir();\n-\n-            \/\/ \/packages dir\n-            packagesDir = newDirectory(root, \"\/packages\");\n-            packagesDir.setIsPackagesDir();\n-\n-            \/\/ \/modules dir\n-            modulesDir = newDirectory(root, \"\/modules\");\n-            modulesDir.setIsModulesDir();\n-\n-            root.setCompleted(true);\n-            return rootDir = root;\n-        }\n-\n-        \/**\n-         * To visit sub tree resources.\n-         *\/\n-        interface LocationVisitor {\n-            void visit(ImageLocation loc);\n-        }\n-\n-        void visitLocation(ImageLocation loc, LocationVisitor visitor) {\n-            byte[] offsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            for (int i = 0; i < offsets.length \/ SIZE_OF_OFFSET; i++) {\n-                int offset = intBuffer.get(i);\n-                ImageLocation pkgLoc = getLocation(offset);\n-                visitor.visit(pkgLoc);\n+        \/\/\/ Builds a node in the \"\/modules\/...\" namespace.\n+        \/\/\/\n+        \/\/\/ Called by `findNode()` if a `\/modules\/...` node is not present in the cache.\n+        Node buildModulesNode(String name) {\n+            assert name.startsWith(MODULES_ROOT + \"\/\") : \"Invalid module node name: \" + name;\n+            \/\/ Will fail for non-directory resources since the jimage name does not\n+            \/\/ start with \"\/modules\" (e.g. \"\/java.base\/java\/lang\/Object.class\").\n+            ImageLocation loc = findLocation(name);\n+            if (loc != null) {\n+                assert name.equals(loc.getFullName()) : \"Mismatched location for directory: \" + name;\n+                assert isModulesSubdirectory(loc) : \"Invalid modules directory: \" + name;\n+                return completeModuleDirectory(newDirectory(name), loc);\n@@ -363,22 +324,34 @@\n-        }\n-\n-        void visitPackageLocation(ImageLocation loc) {\n-            \/\/ Retrieve package name\n-            String pkgName = getBaseExt(loc);\n-            \/\/ Content is array of offsets in Strings table\n-            byte[] stringsOffsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(stringsOffsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            \/\/ For each module, create a link node.\n-            for (int i = 0; i < stringsOffsets.length \/ SIZE_OF_OFFSET; i++) {\n-                \/\/ skip empty state, useless.\n-                intBuffer.get(i);\n-                i++;\n-                int offset = intBuffer.get(i);\n-                String moduleName = getString(offset);\n-                Node targetNode = findNode(\"\/modules\/\" + moduleName);\n-                if (targetNode != null) {\n-                    String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                    Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                    newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + moduleName, targetNode);\n+            \/\/ Now try the non-prefixed resource name.\n+            loc = findLocation(name.substring(MODULES_ROOT.length()));\n+            return loc != null ? newResource(name, loc) : null;\n+        }\n+\n+        \/\/\/ Builds a node in the \"\/packages\/...\" namespace.\n+        \/\/\/\n+        \/\/\/ Called by `findNode()` if a `\/packages\/...` node is not present in the cache.\n+        private Node buildPackagesNode(String name) {\n+            \/\/ There are only locations for the root \"\/packages\" or \"\/packages\/xxx\"\n+            \/\/ directories, but not the symbolic links below them (the links can be\n+            \/\/ entirely derived from the name information in the parent directory).\n+            \/\/ However, unlike resources this means that we do not have a constant\n+            \/\/ time lookup for link nodes when creating them.\n+            int packageStart = PACKAGES_ROOT.length() + 1;\n+            int packageEnd = name.indexOf('\/', packageStart);\n+            if (packageEnd == -1) {\n+                ImageLocation loc = findLocation(name);\n+                return loc != null ? completePackageDirectory(newDirectory(name), loc) : null;\n+            } else {\n+                \/\/ We cannot assume that the parent directory exists for a link node, since\n+                \/\/ the given name is untrusted and could reference a non-existent link.\n+                \/\/ However, if the parent directory is present, we can conclude that the\n+                \/\/ given name was not a valid link (or else it would already be cached).\n+                String dirName = name.substring(0, packageEnd);\n+                if (!nodes.containsKey(dirName)) {\n+                    ImageLocation loc = findLocation(dirName);\n+                    \/\/ If the parent location doesn't exist, the link node cannot exist.\n+                    if (loc != null) {\n+                        nodes.put(dirName, completePackageDirectory(newDirectory(dirName), loc));\n+                        \/\/ When the parent is created its child nodes are created and cached,\n+                        \/\/ but this can still return null if given name wasn't a valid link.\n+                        return nodes.get(name);\n+                    }\n@@ -387,0 +360,1 @@\n+            return null;\n@@ -389,10 +363,14 @@\n-        Node handlePackages(String name, ImageLocation loc) {\n-            long size = loc.getUncompressedSize();\n-            Node n = null;\n-            \/\/ Only possibilities are \/packages, \/packages\/package\/module\n-            if (name.equals(\"\/packages\")) {\n-                visitLocation(loc, (childloc) -> {\n-                    findNode(childloc.getFullName());\n-                });\n-                packagesDir.setCompleted(true);\n-                n = packagesDir;\n+        \/\/\/ Completes a directory by ensuring its child list is populated correctly.\n+        private void completeDirectory(Directory dir) {\n+            String name = dir.getName();\n+            \/\/ Since the node exists, we can assert that its name starts with\n+            \/\/ either \"\/modules\" or \"\/packages\", making differentiation easy.\n+            \/\/ It also means that the name is valid, so it must yield a location.\n+            assert name.startsWith(MODULES_ROOT) || name.startsWith(PACKAGES_ROOT);\n+            ImageLocation loc = findLocation(name);\n+            assert loc != null && name.equals(loc.getFullName()) : \"Invalid location for name: \" + name;\n+            \/\/ We cannot use 'isXxxSubdirectory()' methods here since we could\n+            \/\/ be given a top-level directory (for which that test doesn't work).\n+            \/\/ The string MUST start \"\/modules\" or \"\/packages\" here.\n+            if (name.charAt(1) == 'm') {\n+                completeModuleDirectory(dir, loc);\n@@ -400,47 +378,1 @@\n-                if (size != 0) { \/\/ children are offsets to module in StringsTable\n-                    String pkgName = getBaseExt(loc);\n-                    Directory pkgDir = newDirectory(packagesDir, packagesDir.getName() + \"\/\" + pkgName);\n-                    visitPackageLocation(loc);\n-                    pkgDir.setCompleted(true);\n-                    n = pkgDir;\n-                } else { \/\/ Link to module\n-                    String pkgName = loc.getParent();\n-                    String modName = getBaseExt(loc);\n-                    Node targetNode = findNode(\"\/modules\/\" + modName);\n-                    if (targetNode != null) {\n-                        String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                        Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                        Node linkNode = newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + modName, targetNode);\n-                        n = linkNode;\n-                    }\n-                }\n-            }\n-            return n;\n-        }\n-\n-        \/\/ Asking for \/packages\/package\/module although\n-        \/\/ \/packages\/<pkg>\/ not yet created, need to create it\n-        \/\/ prior to return the link to module node.\n-        Node handleModuleLink(String name) {\n-            \/\/ eg: unresolved \/packages\/package\/module\n-            \/\/ Build \/packages\/package node\n-            Node ret = null;\n-            String radical = \"\/packages\/\";\n-            String path = name;\n-            if (path.startsWith(radical)) {\n-                int start = radical.length();\n-                int pkgEnd = path.indexOf('\/', start);\n-                if (pkgEnd != -1) {\n-                    String pkg = path.substring(start, pkgEnd);\n-                    String pkgPath = radical + pkg;\n-                    Node n = findNode(pkgPath);\n-                    \/\/ If not found means that this is a symbolic link such as:\n-                    \/\/ \/packages\/java.util\/java.base\/java\/util\/Vector.class\n-                    \/\/ and will be done by a retry of the filesystem\n-                    for (Node child : n.getChildren()) {\n-                        if (child.name.equals(name)) {\n-                            ret = child;\n-                            break;\n-                        }\n-                    }\n-                }\n+                completePackageDirectory(dir, loc);\n@@ -448,18 +380,17 @@\n-            return ret;\n-        }\n-\n-        Node handleModulesSubTree(String name, ImageLocation loc) {\n-            Node n;\n-            assert (name.equals(loc.getFullName()));\n-            Directory dir = makeDirectories(name);\n-            visitLocation(loc, (childloc) -> {\n-                String path = childloc.getFullName();\n-                if (path.startsWith(\"\/modules\")) { \/\/ a package\n-                    makeDirectories(path);\n-                } else { \/\/ a resource\n-                    makeDirectories(childloc.buildName(true, true, false));\n-                    \/\/ if we have already created a resource for this name previously, then don't\n-                    \/\/ recreate it\n-                    if (!nodes.containsKey(childloc.getFullName(true))) {\n-                        newResource(dir, childloc);\n-                    }\n+            assert dir.isCompleted() : \"Directory must be complete by now: \" + dir;\n+        }\n+\n+        \/\/\/ Completes a modules directory by setting the list of child nodes.\n+        \/\/\/\n+        \/\/\/ The given directory can be the top level `\/modules` directory, so\n+        \/\/\/ it is NOT safe to use `isModulesSubdirectory(loc)` here.\n+        private Directory completeModuleDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            List<Node> children = createChildNodes(loc, childLoc -> {\n+                if (isModulesSubdirectory(childLoc)) {\n+                    return nodes.computeIfAbsent(childLoc.getFullName(), this::newDirectory);\n+                } else {\n+                    \/\/ Add the \"\/modules\" prefix to image location paths to get\n+                    \/\/ Jrt file system names.\n+                    String resourceName = childLoc.getFullName(true);\n+                    return nodes.computeIfAbsent(resourceName, n -> newResource(n, childLoc));\n@@ -468,3 +399,2 @@\n-            dir.setCompleted(true);\n-            n = dir;\n-            return n;\n+            dir.setChildren(children);\n+            return dir;\n@@ -473,21 +403,27 @@\n-        Node handleResource(String name) {\n-            Node n = null;\n-            if (!name.startsWith(\"\/modules\/\")) {\n-                return null;\n-            }\n-            \/\/ Make sure that the thing that follows \"\/modules\/\" is a module name.\n-            int moduleEndIndex = name.indexOf('\/', \"\/modules\/\".length());\n-            if (moduleEndIndex == -1) {\n-                return null;\n-            }\n-            ImageLocation moduleLoc = findLocation(name.substring(0, moduleEndIndex));\n-            if (moduleLoc == null || moduleLoc.getModuleOffset() == 0) {\n-                return null;\n-            }\n-\n-            String locationPath = name.substring(\"\/modules\".length());\n-            ImageLocation resourceLoc = findLocation(locationPath);\n-            if (resourceLoc != null) {\n-                Directory dir = makeDirectories(resourceLoc.buildName(true, true, false));\n-                Resource res = newResource(dir, resourceLoc);\n-                n = res;\n+        \/\/\/ Completes a package directory by setting the list of child nodes.\n+        \/\/\/\n+        \/\/\/ The given directory can be the top level `\/packages` directory, so\n+        \/\/\/ it is NOT safe to use `isPackagesSubdirectory(loc)` here.\n+        private Directory completePackageDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            \/\/ The only directories in the \"\/packages\" namespace are \"\/packages\" or\n+            \/\/ \"\/packages\/<package>\". However, unlike \"\/modules\" directories, the\n+            \/\/ location offsets mean different things.\n+            List<Node> children;\n+            if (dir.getName().equals(PACKAGES_ROOT)) {\n+                \/\/ Top-level directory just contains a list of subdirectories.\n+                children = createChildNodes(loc, c -> nodes.computeIfAbsent(c.getFullName(), this::newDirectory));\n+            } else {\n+                \/\/ A package directory's content is array of offset PAIRS in the\n+                \/\/ Strings table, but we only need the 2nd value of each pair.\n+                IntBuffer intBuffer = getOffsetBuffer(loc);\n+                int offsetCount = intBuffer.capacity();\n+                assert (offsetCount & 0x1) == 0 : \"Offset count must be even: \" + offsetCount;\n+                children = new ArrayList<>(offsetCount \/ 2);\n+                \/\/ Iterate the 2nd offset in each pair (odd indices).\n+                for (int i = 1; i < offsetCount; i += 2) {\n+                    String moduleName = getString(intBuffer.get(i));\n+                    children.add(nodes.computeIfAbsent(\n+                            dir.getName() + \"\/\" + moduleName,\n+                            n -> newLinkNode(n, MODULES_ROOT + \"\/\" + moduleName)));\n+                }\n@@ -495,1 +431,3 @@\n-            return n;\n+            \/\/ This only happens once and \"completes\" the directory.\n+            dir.setChildren(children);\n+            return dir;\n@@ -498,5 +436,11 @@\n-        String getBaseExt(ImageLocation loc) {\n-            String base = loc.getBase();\n-            String ext = loc.getExtension();\n-            if (ext != null && !ext.isEmpty()) {\n-                base = base + \".\" + ext;\n+        \/\/\/ Creates the list of child nodes for a `Directory` based on a given\n+        \/\/\/ node creation function.\n+        \/\/\/\n+        \/\/\/ Note: This cannot be used for package subdirectories as they have\n+        \/\/\/ child offsets stored differently to other directories.\n+        private List<Node> createChildNodes(ImageLocation loc, Function<ImageLocation, Node> newChildFn) {\n+            IntBuffer offsets = getOffsetBuffer(loc);\n+            int childCount = offsets.capacity();\n+            List<Node> children = new ArrayList<>(childCount);\n+            for (int i = 0; i < childCount; i++) {\n+                children.add(newChildFn.apply(getLocation(offsets.get(i))));\n@@ -504,1 +448,1 @@\n-            return base;\n+            return children;\n@@ -507,7 +451,7 @@\n-        synchronized Node findNode(String name) {\n-            buildRootDirectory();\n-            Node n = nodes.get(name);\n-            if (n == null || !n.isCompleted()) {\n-                n = buildNode(name);\n-            }\n-            return n;\n+        \/\/\/ Helper to extract the integer offset buffer from a directory location.\n+        private IntBuffer getOffsetBuffer(ImageLocation dir) {\n+            assert isDirectory(dir) : \"Not a directory: \" + dir.getFullName();\n+            byte[] offsets = getResource(dir);\n+            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n+            buffer.order(getByteOrder());\n+            return buffer.asIntBuffer();\n@@ -516,15 +460,7 @@\n-        \/**\n-         * Returns the file attributes of the image file.\n-         *\/\n-        BasicFileAttributes imageFileAttributes() {\n-            BasicFileAttributes attrs = imageFileAttributes;\n-            if (attrs == null) {\n-                try {\n-                    Path file = getImagePath();\n-                    attrs = Files.readAttributes(file, BasicFileAttributes.class);\n-                } catch (IOException ioe) {\n-                    throw new UncheckedIOException(ioe);\n-                }\n-                imageFileAttributes = attrs;\n-            }\n-            return attrs;\n+        \/\/\/ Determines if an image location is a directory in the `\/modules`\n+        \/\/\/ namespace (if so, the location name is the Jrt filesystem name).\n+        \/\/\/\n+        \/\/\/ In jimage, every `ImageLocation` under `\/modules\/` is a directory\n+        \/\/\/ and has the same value for `getModule()`, and `getModuleOffset()`.\n+        private boolean isModulesSubdirectory(ImageLocation loc) {\n+            return loc.getModuleOffset() == modulesStringOffset;\n@@ -533,4 +469,7 @@\n-        Directory newDirectory(Directory parent, String name) {\n-            Directory dir = Directory.create(parent, name, imageFileAttributes());\n-            nodes.put(dir.getName(), dir);\n-            return dir;\n+        \/\/\/ Determines if an image location is a directory in the `\/packages``\n+        \/\/\/ namespace (if so, the location name is the Jrt filesystem name).\n+        \/\/\/\n+        \/\/\/ In jimage, every `ImageLocation` under `\/packages\/` is a directory\n+        \/\/\/ and has the same value for `getModule()`, and `getModuleOffset()`.\n+        private boolean isPackagesSubdirectory(ImageLocation loc) {\n+            return loc.getModuleOffset() == packagesStringOffset;\n@@ -539,4 +478,3 @@\n-        Resource newResource(Directory parent, ImageLocation loc) {\n-            Resource res = Resource.create(parent, loc, imageFileAttributes());\n-            nodes.put(res.getName(), res);\n-            return res;\n+        \/\/\/ Determines if an image location represents a directory of some kind.\n+        private boolean isDirectory(ImageLocation loc) {\n+            return isModulesSubdirectory(loc) || isPackagesSubdirectory(loc) || loc.getModuleOffset() == 0;\n@@ -545,4 +483,5 @@\n-        LinkNode newLinkNode(Directory dir, String name, Node link) {\n-            LinkNode linkNode = LinkNode.create(dir, name, link);\n-            nodes.put(linkNode.getName(), linkNode);\n-            return linkNode;\n+        \/\/\/ Creates an \"incomplete\" directory node with no child nodes set.\n+        \/\/\/ Directories need to be \"completed\" before they are returned by\n+        \/\/\/ `findNode()`.\n+        private Directory newDirectory(String name) {\n+            return new Directory(name, imageFileAttributes);\n@@ -551,10 +490,6 @@\n-        Directory makeDirectories(String parent) {\n-            Directory last = rootDir;\n-            for (int offset = parent.indexOf('\/', 1);\n-                    offset != -1;\n-                    offset = parent.indexOf('\/', offset + 1)) {\n-                String dir = parent.substring(0, offset);\n-                last = makeDirectory(dir, last);\n-            }\n-            return makeDirectory(parent, last);\n-\n+        \/\/\/ Creates a new resource from an image location. This is the only case\n+        \/\/\/ where the image location name does not match the requested node name.\n+        \/\/\/ In image files, resource locations are NOT prefixed by `\/modules`.\n+        private Resource newResource(String name, ImageLocation loc) {\n+            assert name.equals(loc.getFullName(true)) : \"Mismatched location for resource: \" + name;\n+            return new Resource(name, loc, imageFileAttributes);\n@@ -563,6 +498,6 @@\n-        Directory makeDirectory(String dir, Directory last) {\n-            Directory nextDir = (Directory) nodes.get(dir);\n-            if (nextDir == null) {\n-                nextDir = newDirectory(last, dir);\n-            }\n-            return nextDir;\n+        \/\/\/ Creates a new link node pointing at the given target name.\n+        \/\/\/\n+        \/\/\/ Note that target node is resolved each time `resolve()` is called, so\n+        \/\/\/ if a link node is retained after its reader is closed, it will fail.\n+        private LinkNode newLinkNode(String name, String targetName) {\n+            return new LinkNode(name, () -> findNode(targetName), imageFileAttributes);\n@@ -571,1 +506,3 @@\n-        byte[] getResource(Node node) throws IOException {\n+        \/\/\/ Returns the content of a resource node.\n+        private byte[] getResource(Node node) throws IOException {\n+            \/\/ We could have been given a non-resource node here.\n@@ -577,4 +514,0 @@\n-\n-        byte[] getResource(Resource rs) throws IOException {\n-            return super.getResource(rs.getLocation());\n-        }\n@@ -583,3 +516,13 @@\n-    \/\/ jimage file does not store directory structure. We build nodes\n-    \/\/ using the \"path\" strings found in the jimage file.\n-    \/\/ Node can be a directory or a resource\n+    \/**\n+     * A directory, resource or symbolic link in the JRT file system namespace.\n+     *\n+     * <h3 id=\"node_equality\">Node Equality<\/h3>\n+     *\n+     * Nodes are identified solely by their name, and it is not valid to attempt\n+     * to compare nodes from different reader instances. Different readers may\n+     * produce nodes with the same names, but different contents.\n+     *\n+     * <p>Furthermore, since a {@link ImageReader} provides \"perfect\" caching of\n+     * nodes, equality of nodes from the same reader is equivalent to instance\n+     * identity.\n+     *\/\n@@ -587,5 +530,0 @@\n-        private static final int ROOT_DIR = 0b0000_0000_0000_0001;\n-        private static final int PACKAGES_DIR = 0b0000_0000_0000_0010;\n-        private static final int MODULES_DIR = 0b0000_0000_0000_0100;\n-\n-        private int flags;\n@@ -594,6 +532,0 @@\n-        private boolean completed;\n-\n-        protected Node(String name, BasicFileAttributes fileAttrs) {\n-            this.name = Objects.requireNonNull(name);\n-            this.fileAttrs = Objects.requireNonNull(fileAttrs);\n-        }\n@@ -602,1 +534,2 @@\n-         * A node is completed when all its direct children have been built.\n+         * Creates an abstract {@code Node}, which is either a resource, directory\n+         * or symbolic link.\n@@ -604,1 +537,2 @@\n-         * @return\n+         * <p>This constructor is only non-private so it can be used by the\n+         * {@code ExplodedImage} class, and must not be used otherwise.\n@@ -606,22 +540,3 @@\n-        public boolean isCompleted() {\n-            return completed;\n-        }\n-\n-        public void setCompleted(boolean completed) {\n-            this.completed = completed;\n-        }\n-\n-        public final void setIsRootDir() {\n-            flags |= ROOT_DIR;\n-        }\n-\n-        public final boolean isRootDir() {\n-            return (flags & ROOT_DIR) != 0;\n-        }\n-\n-        public final void setIsPackagesDir() {\n-            flags |= PACKAGES_DIR;\n-        }\n-\n-        public final boolean isPackagesDir() {\n-            return (flags & PACKAGES_DIR) != 0;\n+        protected Node(String name, BasicFileAttributes fileAttrs) {\n+            this.name = Objects.requireNonNull(name);\n+            this.fileAttrs = Objects.requireNonNull(fileAttrs);\n@@ -630,2 +545,4 @@\n-        public final void setIsModulesDir() {\n-            flags |= MODULES_DIR;\n+        \/\/ A node is completed when all its direct children have been built.\n+        \/\/ As such, non-directory nodes are always complete.\n+        boolean isCompleted() {\n+            return true;\n@@ -634,2 +551,3 @@\n-        public final boolean isModulesDir() {\n-            return (flags & MODULES_DIR) != 0;\n+        \/\/ Only resources can return a location.\n+        ImageLocation getLocation() {\n+            throw new IllegalStateException(\"not a resource: \" + getName());\n@@ -638,0 +556,5 @@\n+        \/**\n+         * Returns the JRT file system compatible name of this node (e.g.\n+         * {@code \"\/modules\/java.base\/java\/lang\/Object.class\"} or {@code\n+         * \"\/packages\/java.lang\"}).\n+         *\/\n@@ -642,0 +565,4 @@\n+        \/**\n+         * Returns file attributes for this node. The value returned may be the\n+         * same for all nodes, and should not be relied upon for accuracy.\n+         *\/\n@@ -646,1 +573,4 @@\n-        \/\/ resolve this Node (if this is a soft link, get underlying Node)\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -651,0 +581,4 @@\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -655,1 +589,1 @@\n-        \/\/ is this a soft link Node?\n+        \/** Returns whether this node is a symbolic link. *\/\n@@ -660,0 +594,5 @@\n+        \/**\n+         * Returns whether this node is a directory. Directory nodes can have\n+         * {@link #getChildNames()} invoked to get the fully qualified names\n+         * of any child nodes.\n+         *\/\n@@ -664,4 +603,5 @@\n-        public List<Node> getChildren() {\n-            throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n-        }\n-\n+        \/**\n+         * Returns whether this node is a resource. Resource nodes can have\n+         * their contents obtained via {@link ImageReader#getResource(Node)}\n+         * or {@link ImageReader#getResourceBuffer(Node)}.\n+         *\/\n@@ -672,2 +612,8 @@\n-        public ImageLocation getLocation() {\n-            throw new IllegalArgumentException(\"not a resource: \" + getNameString());\n+        \/**\n+         * Returns the fully qualified names of any child nodes for a directory.\n+         *\n+         * <p>If this node is not a directory ({@code isDirectory() == false})\n+         * then this method will throw {@link IllegalStateException}.\n+         *\/\n+        public Stream<String> getChildNames() {\n+            throw new IllegalStateException(\"not a directory: \" + getName());\n@@ -676,0 +622,4 @@\n+        \/**\n+         * Returns the uncompressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -680,0 +630,4 @@\n+        \/**\n+         * Returns the compressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -684,0 +638,4 @@\n+        \/**\n+         * Returns the extension string of a resource node. If this node is not\n+         * a resource, this method returns null.\n+         *\/\n@@ -688,20 +646,0 @@\n-        public long contentOffset() {\n-            return 0L;\n-        }\n-\n-        public final FileTime creationTime() {\n-            return fileAttrs.creationTime();\n-        }\n-\n-        public final FileTime lastAccessTime() {\n-            return fileAttrs.lastAccessTime();\n-        }\n-\n-        public final FileTime lastModifiedTime() {\n-            return fileAttrs.lastModifiedTime();\n-        }\n-\n-        public final String getNameString() {\n-            return name;\n-        }\n-\n@@ -710,1 +648,1 @@\n-            return getNameString();\n+            return getName();\n@@ -713,0 +651,1 @@\n+        \/** See <a href=\"#node_equality\">Node Equality<\/a>. *\/\n@@ -718,0 +657,1 @@\n+        \/** See <a href=\"#node_equality\">Node Equality<\/a>. *\/\n@@ -732,3 +672,21 @@\n-    \/\/ directory node - directory has full path name without '\/' at end.\n-    static final class Directory extends Node {\n-        private final List<Node> children;\n+    \/\/\/ Directory node (referenced from a full path, without a trailing '\/').\n+    \/\/\/\n+    \/\/\/ Directory nodes have two distinct states:\n+    \/\/\/ * Incomplete: The child list has not been set.\n+    \/\/\/ * Complete: The child list has been set.\n+    \/\/\/\n+    \/\/\/ When a directory node is returned by `findNode()` it is always complete,\n+    \/\/\/ but this DOES NOT mean that its child nodes are complete yet.\n+    \/\/\/\n+    \/\/\/ To avoid users being able to access incomplete child nodes, the\n+    \/\/\/ `Node` API offers only a way to obtain child node names, forcing\n+    \/\/\/ callers to invoke {@link ImageReader#findNode(String)} if they need to\n+    \/\/\/ access the child node itself.\n+    \/\/\/\n+    \/\/\/ This approach allows directories to be implemented lazily with respect\n+    \/\/\/ to child nodes, while retaining efficiency when child nodes are accessed\n+    \/\/\/ (since any incomplete nodes will be created and placed in the node cache\n+    \/\/\/ when the parent was first returned to the user).\n+    private static final class Directory extends Node {\n+        \/\/ Monotonic reference, will be set to the unmodifiable child list exactly once.\n+        private List<Node> children = null;\n@@ -738,1 +696,0 @@\n-            children = new ArrayList<>();\n@@ -741,6 +698,3 @@\n-        static Directory create(Directory parent, String name, BasicFileAttributes fileAttrs) {\n-            Directory d = new Directory(name, fileAttrs);\n-            if (parent != null) {\n-                parent.addChild(d);\n-            }\n-            return d;\n+        @Override\n+        boolean isCompleted() {\n+            return children != null;\n@@ -755,7 +709,5 @@\n-        public List<Node> getChildren() {\n-            return Collections.unmodifiableList(children);\n-        }\n-\n-        void addChild(Node node) {\n-            assert !children.contains(node) : \"Child \" + node + \" already added\";\n-            children.add(node);\n+        public Stream<String> getChildNames() {\n+            if (children != null) {\n+                return children.stream().map(Node::getName);\n+            }\n+            throw new IllegalStateException(\"Cannot get child nodes of an incomplete directory: \" + getName());\n@@ -764,9 +716,3 @@\n-        public void walk(Consumer<? super Node> consumer) {\n-            consumer.accept(this);\n-            for (Node child : children) {\n-                if (child.isDirectory()) {\n-                    ((Directory)child).walk(consumer);\n-                } else {\n-                    consumer.accept(child);\n-                }\n-            }\n+        private void setChildren(List<Node> children) {\n+            assert this.children == null : this + \": Cannot set child nodes twice!\";\n+            this.children = Collections.unmodifiableList(children);\n@@ -776,3 +722,11 @@\n-    \/\/ \"resource\" is .class or any other resource (compressed\/uncompressed) in a jimage.\n-    \/\/ full path of the resource is the \"name\" of the resource.\n-    static class Resource extends Node {\n+    \/\/\/ Resource node (e.g. a \".class\" entry, or any other data resource).\n+    \/\/\/\n+    \/\/\/ Resources are leaf nodes referencing an underlying image location. They\n+    \/\/\/ are lightweight, and do not cache their contents.\n+    \/\/\/\n+    \/\/\/ Unlike directories (where the node name matches the jimage path for the\n+    \/\/\/ corresponding `ImageLocation`), resource node names are NOT the same as\n+    \/\/\/ the corresponding jimage path. The difference is that node names for\n+    \/\/\/ resources are prefixed with \"\/modules\", which is missing from the\n+    \/\/\/ equivalent jimage path.\n+    private static class Resource extends Node {\n@@ -781,2 +735,2 @@\n-        private Resource(ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            super(loc.getFullName(true), fileAttrs);\n+        private Resource(String name, ImageLocation loc, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -786,6 +740,0 @@\n-        static Resource create(Directory parent, ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            Resource rs = new Resource(loc, fileAttrs);\n-            parent.addChild(rs);\n-            return rs;\n-        }\n-\n@@ -793,2 +741,2 @@\n-        public boolean isCompleted() {\n-            return true;\n+        ImageLocation getLocation() {\n+            return loc;\n@@ -802,5 +750,0 @@\n-        @Override\n-        public ImageLocation getLocation() {\n-            return loc;\n-        }\n-\n@@ -821,5 +764,0 @@\n-\n-        @Override\n-        public long contentOffset() {\n-            return loc.getContentOffset();\n-        }\n@@ -828,3 +766,8 @@\n-    \/\/ represents a soft link to another Node\n-    static class LinkNode extends Node {\n-        private final Node link;\n+    \/\/\/ Link node (a symbolic link to a top-level modules directory).\n+    \/\/\/\n+    \/\/\/ Link nodes resolve their target by invoking a given supplier, and do not\n+    \/\/\/ cache the result. Since nodes are cached by the `ImageReader`, this\n+    \/\/\/ means that only the first call to `resolveLink()` could do any\n+    \/\/\/ significant work.\n+    private static class LinkNode extends Node {\n+        private final Supplier<Node> link;\n@@ -832,2 +775,2 @@\n-        private LinkNode(String name, Node link) {\n-            super(name, link.getFileAttributes());\n+        private LinkNode(String name, Supplier<Node> link, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -837,11 +780,0 @@\n-        static LinkNode create(Directory parent, String name, Node link) {\n-            LinkNode ln = new LinkNode(name, link);\n-            parent.addChild(ln);\n-            return ln;\n-        }\n-\n-        @Override\n-        public boolean isCompleted() {\n-            return true;\n-        }\n-\n@@ -850,1 +782,1 @@\n-            return (recursive && link instanceof LinkNode) ? ((LinkNode)link).resolveLink(true) : link;\n+            return link.get();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":453,"deletions":521,"binary":false,"changes":974,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-        public List<Node> getChildren() {\n+        public Stream<String> getChildNames() {\n@@ -124,1 +124,1 @@\n-                throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n+                throw new IllegalArgumentException(\"not a directory: \" + getName());\n@@ -141,1 +141,1 @@\n-            return children;\n+            return children.stream().map(Node::getName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        return node.creationTime();\n+        return node.getFileAttributes().creationTime();\n@@ -72,1 +72,1 @@\n-        return node.lastAccessTime();\n+        return node.getFileAttributes().lastAccessTime();\n@@ -77,1 +77,1 @@\n-        return node.lastModifiedTime();\n+        return node.getFileAttributes().lastModifiedTime();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileAttributes.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.util.ArrayList;\n@@ -67,1 +66,0 @@\n-import static java.util.stream.Collectors.toList;\n@@ -228,4 +226,3 @@\n-            return node.getChildren()\n-                       .stream()\n-                       .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                       .iterator();\n+            return node.getChildNames()\n+                    .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                    .iterator();\n@@ -233,8 +230,9 @@\n-        return node.getChildren()\n-                   .stream()\n-                   .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                   .filter(p ->  { try { return filter.accept(p);\n-                                   } catch (IOException x) {}\n-                                   return false;\n-                                  })\n-                   .iterator();\n+        return node.getChildNames()\n+                .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                .filter(p -> {\n+                    try {\n+                        return filter.accept(p);\n+                    } catch (IOException x) {}\n+                    return false;\n+                })\n+                .iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-            image.getRootDirectory();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.net.URLConnection;\n@@ -57,1 +56,0 @@\n-import jdk.internal.jimage.ImageLocation;\n@@ -213,1 +211,1 @@\n-     * Parses the module-info.class of all module in the runtime image and\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n@@ -222,5 +220,0 @@\n-        ImageReader reader = SystemImage.reader();\n-        for (String mn : reader.getModuleNames()) {\n-            ImageLocation loc = reader.findLocation(mn, \"module-info.class\");\n-            ModuleInfo.Attributes attrs\n-                = ModuleInfo.read(reader.getResourceBuffer(loc), null);\n@@ -228,1 +221,2 @@\n-            nameToAttributes.put(mn, attrs);\n+        allModuleAttributes().forEach(attrs -> {\n+            nameToAttributes.put(attrs.descriptor().name(), attrs);\n@@ -235,1 +229,1 @@\n-        }\n+        });\n@@ -256,0 +250,29 @@\n+    \/**\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n+     * returns a stream of {@link ModuleInfo.Attributes Attributes} for them. The\n+     * returned attributes are in no specific order.\n+     *\/\n+    private static Stream<ModuleInfo.Attributes> allModuleAttributes() {\n+        \/\/ System reader is a singleton and should not be closed by callers.\n+        ImageReader reader = SystemImage.reader();\n+        try {\n+            return reader.findNode(\"\/modules\").getChildNames().map(mn -> readModuleAttributes(reader, mn));\n+        } catch (IOException e) {\n+            throw new Error(\"Error reading root \/modules entry\", e);\n+        }\n+    }\n+\n+    \/\/ Every module is required to have a valid module-info.class.\n+    private static ModuleInfo.Attributes readModuleAttributes(ImageReader reader, String moduleName) {\n+        Exception err = null;\n+        try {\n+            ImageReader.Node node = reader.findNode(moduleName + \"\/module-info.class\");\n+            if (node != null && node.isResource()) {\n+                return ModuleInfo.read(reader.getResourceBuffer(node), null);\n+            }\n+        } catch (IOException | UncheckedIOException e) {\n+            err = e;\n+        }\n+        throw new Error(\"Missing or invalid module-info.class for module: \" + moduleName, err);\n+    }\n+\n@@ -385,17 +408,0 @@\n-        \/**\n-         * Returns the ImageLocation for the given resource, {@code null}\n-         * if not found.\n-         *\/\n-        private ImageLocation findImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n-            if (closed)\n-                throw new IOException(\"ModuleReader is closed\");\n-            ImageReader imageReader = SystemImage.reader();\n-            if (imageReader != null) {\n-                return imageReader.findLocation(module, name);\n-            } else {\n-                \/\/ not an images build\n-                return null;\n-            }\n-        }\n-\n@@ -406,2 +412,2 @@\n-        private boolean containsImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n+        private boolean containsResource(String resourcePath) throws IOException {\n+            Objects.requireNonNull(resourcePath);\n@@ -412,1 +418,2 @@\n-                return imageReader.verifyLocation(module, name);\n+                ImageReader.Node node = imageReader.findNode(\"\/modules\" + resourcePath);\n+                return node != null && node.isResource();\n@@ -421,2 +428,3 @@\n-            if (containsImageLocation(name)) {\n-                URI u = JNUA.create(\"jrt\", \"\/\" + module + \"\/\" + name);\n+            String resourcePath = \"\/\" + module + \"\/\" + name;\n+            if (containsResource(resourcePath)) {\n+                URI u = JNUA.create(\"jrt\", resourcePath);\n@@ -445,0 +453,14 @@\n+        \/**\n+         * Returns the node for the given resource if found. If the name references\n+         * a non-resource node, then {@code null} is returned.\n+         *\/\n+        private ImageReader.Node findResourceNode(ImageReader reader, String name) throws IOException {\n+            Objects.requireNonNull(name);\n+            if (closed) {\n+                throw new IOException(\"ModuleReader is closed\");\n+            }\n+            String nodeName = \"\/modules\/\" + module + \"\/\" + name;\n+            ImageReader.Node node = reader.findNode(nodeName);\n+            return node != null && node.isResource() ? node : null;\n+        }\n+\n@@ -447,6 +469,2 @@\n-            ImageLocation location = findImageLocation(name);\n-            if (location != null) {\n-                return Optional.of(SystemImage.reader().getResourceBuffer(location));\n-            } else {\n-                return Optional.empty();\n-            }\n+            ImageReader reader = SystemImage.reader();\n+            return Optional.ofNullable(findResourceNode(reader, name)).map(reader::getResourceBuffer);\n@@ -484,1 +502,1 @@\n-        Iterator<ImageReader.Node> iterator;\n+        Iterator<String> iterator;\n@@ -505,2 +523,2 @@\n-                    ImageReader.Node node = iterator.next();\n-                    String name = node.getName();\n+                    String name = iterator.next();\n+                    ImageReader.Node node = SystemImage.reader().findNode(name);\n@@ -508,4 +526,1 @@\n-                        \/\/ build node\n-                        ImageReader.Node dir = SystemImage.reader().findNode(name);\n-                        assert dir.isDirectory();\n-                        stack.push(dir);\n+                        stack.push(node);\n@@ -523,1 +538,1 @@\n-                    iterator = dir.getChildren().iterator();\n+                    iterator = dir.getChildNames().iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":62,"deletions":47,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ImageReader;\n+import jdk.internal.jimage.ImageReader.Node;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.util.JarBuilder;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.opentest4j.TestSkippedException;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ImageReader.\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @library \/test\/jdk\/tools\/lib\n+ *          \/test\/lib\n+ * @build tests.*\n+ * @run junit\/othervm ImageReaderTest\n+ *\/\n+\n+\/\/\/ Using PER_CLASS lifecycle means the (expensive) image file is only build once.\n+\/\/\/ There is no mutable test instance state to worry about.\n+@TestInstance(PER_CLASS)\n+public class ImageReaderTest {\n+\n+    private static final Map<String, List<String>> IMAGE_ENTRIES = Map.of(\n+            \"modfoo\", Arrays.asList(\n+                    \"com.foo.Alpha\",\n+                    \"com.foo.Beta\",\n+                    \"com.foo.bar.Gamma\"),\n+            \"modbar\", Arrays.asList(\n+                    \"com.bar.One\",\n+                    \"com.bar.Two\"));\n+    private final Path image = buildJImage(IMAGE_ENTRIES);\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/\",\n+            \"\/modules\",\n+            \"\/modules\/modfoo\",\n+            \"\/modules\/modbar\",\n+            \"\/modules\/modfoo\/com\",\n+            \"\/modules\/modfoo\/com\/foo\",\n+            \"\/modules\/modfoo\/com\/foo\/bar\"})\n+    public void testModuleDirectories_expected(String name) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertDir(reader, name);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\",\n+            \"\/\/\",\n+            \"\/modules\/\",\n+            \"\/modules\/unknown\",\n+            \"\/modules\/modbar\/\",\n+            \"\/modules\/modfoo\/\/com\",\n+            \"\/modules\/modfoo\/com\/\"})\n+    public void testModuleNodes_absent(String name) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertAbsent(reader, name);\n+        }\n+    }\n+\n+    @Test\n+    public void testModuleResources() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNode(reader, \"\/modules\/modfoo\/com\/foo\/Alpha.class\");\n+            assertNode(reader, \"\/modules\/modbar\/com\/bar\/One.class\");\n+\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+            assertEquals(\"Class: com.foo.Alpha\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Alpha\"));\n+            assertEquals(\"Class: com.foo.Beta\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Beta\"));\n+            assertEquals(\"Class: com.foo.bar.Gamma\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.Gamma\"));\n+            assertEquals(\"Class: com.bar.One\", loader.loadAndGetToString(\"modbar\", \"com.bar.One\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageDirectories() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node root = assertDir(reader, \"\/packages\");\n+            Set<String> pkgNames = root.getChildNames().collect(Collectors.toSet());\n+            assertTrue(pkgNames.contains(\"\/packages\/com\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.foo\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.bar\"));\n+\n+            \/\/ Even though no classes exist directly in the \"com\" package, it still\n+            \/\/ creates a directory with links back to all the modules which contain it.\n+            Set<String> comLinks = assertDir(reader, \"\/packages\/com\").getChildNames().collect(Collectors.toSet());\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modfoo\"));\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modbar\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageLinks() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node moduleFoo = assertDir(reader, \"\/modules\/modfoo\");\n+            Node moduleBar = assertDir(reader, \"\/modules\/modbar\");\n+            assertSame(assertLink(reader, \"\/packages\/com.foo\/modfoo\").resolveLink(), moduleFoo);\n+            assertSame(assertLink(reader, \"\/packages\/com.bar\/modbar\").resolveLink(), moduleBar);\n+        }\n+    }\n+\n+    private static ImageReader.Node assertNode(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node node = reader.findNode(name);\n+        assertNotNull(node, \"Could not find node: \" + name);\n+        return node;\n+    }\n+\n+    private static ImageReader.Node assertDir(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node dir = assertNode(reader, name);\n+        assertTrue(dir.isDirectory(), \"Node was not a directory: \" + name);\n+        return dir;\n+    }\n+\n+    private static ImageReader.Node assertLink(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node link = assertNode(reader, name);\n+        assertTrue(link.isLink(), \"Node was not a symbolic link: \" + name);\n+        return link;\n+    }\n+\n+    private static void assertAbsent(ImageReader reader, String name) throws IOException {\n+        assertNull(reader.findNode(name), \"Should not be able to find node: \" + name);\n+    }\n+\n+    \/\/\/ Builds a jimage file with the specified class entries. The classes in the built\n+    \/\/\/ image can be loaded and executed to return their names via `toString()` to confirm\n+    \/\/\/ the correct bytes were returned.\n+    public static Path buildJImage(Map<String, List<String>> entries) {\n+        Helper helper = getHelper();\n+        Path outDir = helper.createNewImageDir(\"test\");\n+        JImageGenerator.JLinkTask jlink = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(outDir);\n+\n+        Path jarDir = helper.getJarDir();\n+        entries.forEach((module, classes) -> {\n+            JarBuilder jar = new JarBuilder(jarDir.resolve(module + \".jar\").toString());\n+            String moduleInfo = \"module \" + module + \" {}\";\n+            jar.addEntry(\"module-info.class\", InMemoryJavaCompiler.compile(\"module-info\", moduleInfo));\n+\n+            classes.forEach(fqn -> {\n+                int lastDot = fqn.lastIndexOf('.');\n+                String pkg = fqn.substring(0, lastDot);\n+                String cls = fqn.substring(lastDot + 1);\n+\n+                String path = fqn.replace('.', '\/') + \".class\";\n+                String source = String.format(\n+                        \"\"\"\n+                        package %s;\n+                        public class %s {\n+                            public String toString() {\n+                                return \"Class: %s\";\n+                            }\n+                        }\n+                        \"\"\", pkg, cls, fqn);\n+                jar.addEntry(path, InMemoryJavaCompiler.compile(fqn, source));\n+            });\n+            try {\n+                jar.build();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+            jlink.addMods(module);\n+        });\n+        return jlink.call().assertSuccess().resolve(\"lib\", \"modules\");\n+    }\n+\n+    \/\/\/  Returns the helper for building JAR and jimage files.\n+    private static Helper getHelper() {\n+        try {\n+            Helper helper = Helper.newHelper();\n+            if (helper == null) {\n+                throw new TestSkippedException(\"Cannot create test helper (exploded image?)\");\n+            }\n+            return helper;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/\/ Loads and performs actions on classes stored in a given `ImageReader`.\n+    private static class ImageClassLoader extends ClassLoader {\n+        private final ImageReader reader;\n+        private final Set<String> testModules;\n+\n+        private ImageClassLoader(ImageReader reader, Set<String> testModules) {\n+            this.reader = reader;\n+            this.testModules = testModules;\n+        }\n+\n+        @FunctionalInterface\n+        public interface ClassAction<R, T extends Exception> {\n+            R call(Class<?> cls) throws T;\n+        }\n+\n+        String loadAndGetToString(String module, String fqn) {\n+            return loadAndCall(module, fqn, c -> c.getDeclaredConstructor().newInstance().toString());\n+        }\n+\n+        <R> R loadAndCall(String module, String fqn, ClassAction<R, ?> action) {\n+            Class<?> cls = findClass(module, fqn);\n+            assertNotNull(cls, \"Could not load class: \" + module + \"\/\" + fqn);\n+            try {\n+                return action.call(cls);\n+            } catch (Exception e) {\n+                fail(\"Class loading failed\", e);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String module, String fqn) {\n+            assumeTrue(testModules.contains(module), \"Can only load classes in modules: \" + testModules);\n+            String name = \"\/modules\/\" + module + \"\/\" + fqn.replace('.', '\/') + \".class\";\n+            Class<?> cls = findLoadedClass(fqn);\n+            if (cls == null) {\n+                try {\n+                    ImageReader.Node node = reader.findNode(name);\n+                    if (node != null && node.isResource()) {\n+                        byte[] classBytes = reader.getResource(node);\n+                        cls = defineClass(fqn, classBytes, 0, classBytes.length);\n+                        resolveClass(cls);\n+                        return cls;\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -52,0 +52,3 @@\n+import static java.nio.ByteOrder.BIG_ENDIAN;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n@@ -336,10 +339,6 @@\n-        ImageReader nativeReader = ImageReader.open(imageFile);\n-        Assert.assertEquals(nativeReader.getByteOrder(), ByteOrder.nativeOrder());\n-\n-        try {\n-            ImageReader leReader = ImageReader.open(imageFile, ByteOrder.LITTLE_ENDIAN);\n-            Assert.assertEquals(leReader.getByteOrder(), ByteOrder.LITTLE_ENDIAN);\n-            leReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Will be opened with native byte order.\n+        try (ImageReader nativeReader = ImageReader.open(imageFile)) {\n+            \/\/ Just ensure something works as expected.\n+            Assert.assertNotNull(nativeReader.findNode(\"\/\"));\n+        } catch (IOException expected) {\n+            Assert.fail(\"Reader should be openable with native byte order.\");\n@@ -348,7 +347,4 @@\n-        try {\n-            ImageReader beReader = ImageReader.open(imageFile, ByteOrder.BIG_ENDIAN);\n-            Assert.assertEquals(beReader.getByteOrder(), ByteOrder.BIG_ENDIAN);\n-            beReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.BIG_ENDIAN);\n+        ByteOrder otherOrder = ByteOrder.nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        try (ImageReader badReader = ImageReader.open(imageFile, otherOrder)) {\n+            Assert.fail(\"Reader should not be openable with the wrong byte order.\");\n+        } catch (IOException expected) {\n@@ -356,2 +352,0 @@\n-\n-        nativeReader.close();\n@@ -359,1 +353,0 @@\n-    \/\/ main method to run standalone from jtreg\n@@ -361,1 +354,2 @@\n-    @Test(enabled=false)\n+    \/\/ main method to run standalone from jtreg\n+    @Test(enabled = false)\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-            final List<ImageReader.Node> children = parent.getChildren();\n-            if (children == null || children.isEmpty()) {\n+            final List<String> childNames = parent.getChildNames().toList();\n+            if (childNames.isEmpty()) {\n@@ -77,2 +77,2 @@\n-            for (final ImageReader.Node child : children) {\n-                final boolean unique = uniqueChildren.add(child);\n+            for (final String childName : childNames) {\n+                final boolean unique = uniqueChildren.add(reader.findNode(childName));\n@@ -81,1 +81,1 @@\n-                            + child + \" under \" + parent + \" from image \" + imagePath);\n+                            + childName + \" under \" + parent + \" from image \" + imagePath);\n","filename":"test\/jdk\/tools\/jimage\/ImageReaderDuplicateChildNodesTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            count += node.getChildren().stream().mapToLong(n -> {\n+            count += node.getChildNames().mapToLong(n -> {\n@@ -200,1 +200,1 @@\n-                    return countAllNodes(reader, reader.findNode(n.getName()));\n+                    return countAllNodes(reader, reader.findNode(n));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}