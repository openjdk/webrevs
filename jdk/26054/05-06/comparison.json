{"files":[{"patch":"@@ -182,0 +182,1 @@\n+        \/\/ TODO: Should this be OPEN_FILES or openFiles (it's not constant).\n@@ -183,2 +184,2 @@\n-        public static final String MODULES_ROOT = \"\/modules\";\n-        public static final String PACKAGES_ROOT = \"\/packages\";\n+        private static final String MODULES_ROOT = \"\/modules\";\n+        private static final String PACKAGES_ROOT = \"\/packages\";\n@@ -233,1 +234,1 @@\n-        public static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        private static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n@@ -321,4 +322,20 @@\n-            \/\/ TODO (review note): This is a heuristic to avoid spending time on lookup\n-            \/\/  in cases of failure, but is not strictly required for correct behaviour.\n-            \/\/ If there is no ImageLocation, the given name cannot be trusted to\n-            \/\/ belong to any resource (or even be a valid resource name).\n+            if (moduleExistsFor(name)) {\n+                \/\/ Resource paths in the image are NOT prefixed with \"\/modules\".\n+                ImageLocation resourceLoc = findLocation(name.substring(MODULES_ROOT.length()));\n+                if (resourceLoc != null) {\n+                    return newResource(name, resourceLoc);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        \/\/ For a given resource name \"\/modules\/<module>\/<path>\", this tests if the parent\n+        \/\/ module directory \"\/modules\/<module>\" exists before looking up the resource\n+        \/\/ location \"\/<module>\/<path>\".\n+        \/\/ TODO (review note): This is a heuristic to avoid spending time on lookup in\n+        \/\/  cases of failure, but is not strictly required for correct behaviour. Its\n+        \/\/  only real advantage seems to be that it only needs to construct a hash for\n+        \/\/  a shorter path in cases where the module doesn't exist, but the actual node\n+        \/\/  is always based on the original name minus the leading prefix. If the jimage\n+        \/\/  is correctly constructed, this test makes no functional difference.\n+        private boolean moduleExistsFor(String name) {\n@@ -327,7 +344,2 @@\n-                return null;\n-            }\n-            \/\/ Tests that the implied module name actually exists before doing\n-            \/\/ a full lookup for the location.\n-            ImageLocation moduleLoc = findLocation(name.substring(0, moduleEnd));\n-            if (moduleLoc == null || moduleLoc.getModuleOffset() == 0) {\n-                return null;\n+                \/\/ Resources can only exist within \"\/modules\/<module>\/...\"\n+                return false;\n@@ -335,3 +347,4 @@\n-            \/\/ Resource paths in the image are NOT prefixed with \"\/modules\".\n-            ImageLocation resourceLoc = findLocation(name.substring(MODULES_ROOT.length()));\n-            return resourceLoc != null ? newResource(name, resourceLoc) : null;\n+            \/\/ Tests the implied module directory location \"\/modules\/<module>\" exists.\n+            ImageLocation loc = findLocation(name.substring(0, moduleEnd));\n+            assert loc == null || isModulesSubdirectory(loc);\n+            return loc != null;\n@@ -400,3 +413,3 @@\n-            List<Node> children = createChildNodes(loc, (childloc) -> {\n-                if (isModulesSubdirectory(childloc)) {\n-                    return nodes.computeIfAbsent(childloc.getFullName(), this::newDirectory);\n+            List<Node> children = createChildNodes(loc, childLoc -> {\n+                if (isModulesSubdirectory(childLoc)) {\n+                    return nodes.computeIfAbsent(childLoc.getFullName(), this::newDirectory);\n@@ -406,2 +419,2 @@\n-                    String resourceName = childloc.getFullName(true);\n-                    return nodes.computeIfAbsent(resourceName, n -> newResource(n, childloc));\n+                    String resourceName = childLoc.getFullName(true);\n+                    return nodes.computeIfAbsent(resourceName, n -> newResource(n, childLoc));\n@@ -432,0 +445,1 @@\n+                assert (offsetCount & 0x1) == 0 : \"Offset count must be even: \" + offsetCount;\n@@ -438,1 +452,1 @@\n-                            n -> newLinkNode(n, \"\/modules\/\" + moduleName)));\n+                            n -> newLinkNode(n, MODULES_ROOT + \"\/\" + moduleName)));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":37,"deletions":23,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileAttributes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-        IMAGE_ENTRIES.forEach((module, classes) -> {\n+        entries.forEach((module, classes) -> {\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}