{"files":[{"patch":"@@ -147,1 +147,2 @@\n-     * Returns the content of a resource node.\n+     * Returns a copy of the content of a resource node. Resource nodes do not\n+     * cache their content, and each call returns a new array instance.\n@@ -182,1 +183,0 @@\n-        \/\/ TODO: Should this be OPEN_FILES or openFiles (it's not constant).\n@@ -186,0 +186,4 @@\n+        \/\/ There are >30,000 nodes in a complete jimage tree, and even relatively\n+        \/\/ common tasks (e.g. starting up javac) load somewhere in the region of\n+        \/\/ 1000 classes. Thus, an initial capacity of 2000 is a reasonable guess.\n+        private static final int INITIAL_NODE_CACHE_CAPACITY = 2000;\n@@ -204,4 +208,3 @@\n-            \/\/ TODO (review note): Given there are ~30,000 nodes in the image, is setting an initial capacity a good idea?\n-            this.nodes = new HashMap<>();\n-            \/\/ TODO (review note): These should exist under all circumstances, but there's\n-            \/\/  probably a more robust way of getting at these offsets.\n+            this.nodes = new HashMap<>(INITIAL_NODE_CACHE_CAPACITY);\n+            \/\/ Pick stable jimage names from which to extract string offsets (we cannot\n+            \/\/ use \"\/modules\" or \"\/packages\", since those have a module offset of zero).\n@@ -620,1 +623,1 @@\n-        \/\/ TODO (review note): Sure this could\/should be IllegalStateException?\n+        \/\/ TODO (review note): Could\/should this be IllegalStateException?\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"}]}