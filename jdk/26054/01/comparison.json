{"files":[{"patch":"@@ -95,0 +95,1 @@\n+        --add-exports java.base\/jdk.internal.jimage=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.InputStream;\n@@ -34,2 +33,0 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n@@ -37,0 +34,1 @@\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -38,0 +36,1 @@\n+import java.util.Arrays;\n@@ -45,1 +44,3 @@\n-import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n@@ -48,0 +49,23 @@\n+ * An adapter for {@link BasicImageReader} to present jimage resources in a\n+ * file system friendly way. The jimage entries (resources, module and package\n+ * information) are mapped into a unified hierarchy of named nodes, which serve\n+ * as the underlying structure for the {@code JrtFileSystem} and other utilities.\n+ *\n+ * <p>This class is not a conceptual subtype of {@code BasicImageReader} and\n+ * deliberately hides types such as {@code ImageLocation} to give a focused API\n+ * based only on the {@link Node} type. Entries in jimage are expressed as one\n+ * of three {@link Node} types resource nodes, directory nodes and link nodes.\n+ *\n+ * <p>When remapping jimage entries, jimage location names (e.g. {@code\n+ * \"\/java.base\/java\/lang\/Integer.class\"}) are prefixed with {@code \"\/modules\"}\n+ * to form the names of resource nodes. This aligns with the naming of module\n+ * entries in jimage (e.g. \"\/modules\/java.base\/java\/lang\"), which appear as\n+ * directory nodes in {@code ImageReader}.\n+ *\n+ * <p>Package entries (e.g. {@code \"\/packages\/java.lang\"} appear as directory\n+ * nodes containing link nodes, which resolve back to the root directory of the\n+ * module in which that package exists (e.g. {@code \"\/modules\/java.base\"}).\n+ * Unlike other nodes, the jimage file does not contain explicit entries for\n+ * link nodes, and their existence is derived only from the contents of the\n+ * parent directory.\n+ *\n@@ -63,0 +87,8 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * given byte order.\n+     *\n+     * <p>Almost all callers should use {@link #open(Path)} to obtain a reader\n+     * with the platform native byte ordering. Using a non-native ordering is\n+     * extremely unusual.\n+     *\/\n@@ -70,0 +102,7 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * platform native byte order.\n+     *\n+     * <p>This is the expected was to open an {@code ImageReader}, and it should\n+     * be rare for anything other than the native byte order to be needed.\n+     *\/\n@@ -95,7 +134,7 @@\n-    \/\/ directory management interface\n-    public Directory getRootDirectory() throws IOException {\n-        ensureOpen();\n-        return reader.getRootDirectory();\n-    }\n-\n-\n+    \/**\n+     * Finds the node for the given JRT file system name.\n+     *\n+     * @param name a JRT file system name (path) of the form\n+     * {@code \"\/modules\/<module>\/...} or {@code \"\/packages\/<package>\/...}.\n+     * @return a node representing a resource, directory or symbolic link.\n+     *\/\n@@ -107,0 +146,6 @@\n+    \/**\n+     * Returns the content of a resource node.\n+     *\n+     * @throws IOException if the content cannot be returned (including if the\n+     * given node is not a resource node).\n+     *\/\n@@ -112,10 +157,7 @@\n-    public byte[] getResource(Resource rs) throws IOException {\n-        ensureOpen();\n-        return reader.getResource(rs);\n-    }\n-\n-    public ImageHeader getHeader() {\n-        requireOpen();\n-        return reader.getHeader();\n-    }\n-\n+    \/**\n+     * Releases a (possibly cached) {@link ByteBuffer} obtained via\n+     * {@link #getResourceBuffer(Node)}.\n+     *\n+     * <p>Note that no testing is performed to check whether the buffer about\n+     * to be released actually came from a call to {@code getResourceBuffer()}.\n+     *\/\n@@ -126,77 +168,6 @@\n-    public String getName() {\n-        requireOpen();\n-        return reader.getName();\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        requireOpen();\n-        return reader.getByteOrder();\n-    }\n-\n-    public Path getImagePath() {\n-        requireOpen();\n-        return reader.getImagePath();\n-    }\n-\n-    public ImageStringsReader getStrings() {\n-        requireOpen();\n-        return reader.getStrings();\n-    }\n-\n-    public ImageLocation findLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.findLocation(mn, rn);\n-    }\n-\n-    public boolean verifyLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.verifyLocation(mn, rn);\n-    }\n-\n-    public ImageLocation findLocation(String name) {\n-        requireOpen();\n-        return reader.findLocation(name);\n-    }\n-\n-    public String[] getEntryNames() {\n-        requireOpen();\n-        return reader.getEntryNames();\n-    }\n-\n-    public String[] getModuleNames() {\n-        requireOpen();\n-        int off = \"\/modules\/\".length();\n-        return reader.findNode(\"\/modules\")\n-                     .getChildren()\n-                     .stream()\n-                     .map(Node::getNameString)\n-                     .map(s -> s.substring(off, s.length()))\n-                     .toArray(String[]::new);\n-    }\n-\n-    public long[] getAttributes(int offset) {\n-        requireOpen();\n-        return reader.getAttributes(offset);\n-    }\n-\n-    public String getString(int offset) {\n-        requireOpen();\n-        return reader.getString(offset);\n-    }\n-\n-    public byte[] getResource(String name) {\n-        requireOpen();\n-        return reader.getResource(name);\n-    }\n-\n-    public byte[] getResource(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResource(loc);\n-    }\n-\n-    public ByteBuffer getResourceBuffer(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResourceBuffer(loc);\n-    }\n-\n-    public InputStream getResourceStream(ImageLocation loc) {\n+    \/**\n+     * Returns the content of a resource node in a possibly cached byte buffer.\n+     * Callers of this method must call {@link #releaseByteBuffer(ByteBuffer)}\n+     * when they are finished with it.\n+     *\/\n+    public ByteBuffer getResourceBuffer(Node node) {\n@@ -204,1 +175,4 @@\n-        return reader.getResourceStream(loc);\n+        if (!node.isResource()) {\n+            throw new IllegalStateException(\"Not a resource node: \" + node);\n+        }\n+        return reader.getResourceBuffer(node.getLocation());\n@@ -208,3 +182,3 @@\n-        static final int SIZE_OF_OFFSET = Integer.BYTES;\n-\n-        static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        private static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        public static final String MODULES_ROOT = \"\/modules\";\n+        public static final String PACKAGES_ROOT = \"\/packages\";\n@@ -213,1 +187,1 @@\n-        final Set<ImageReader> openers;\n+        private final Set<ImageReader> openers;\n@@ -215,1 +189,1 @@\n-        \/\/ attributes of the .jimage file. jimage file does not contain\n+        \/\/ Attributes of the .jimage file. The jimage file does not contain\n@@ -218,2 +192,2 @@\n-        \/\/ Iniitalized lazily, see {@link #imageFileAttributes()}.\n-        BasicFileAttributes imageFileAttributes;\n+        \/\/ Initialized lazily, see imageFileAttributes().\n+        private BasicFileAttributes imageFileAttributes;\n@@ -221,6 +195,5 @@\n-        \/\/ directory management implementation\n-        final HashMap<String, Node> nodes;\n-        volatile Directory rootDir;\n-\n-        Directory packagesDir;\n-        Directory modulesDir;\n+        \/\/ Guarded by synchronizing 'this' instance.\n+        private final HashMap<String, Node> nodes;\n+        \/\/ Used to classify ImageLocation instances without string comparison.\n+        private final int modulesStringOffset;\n+        private final int packagesStringOffset;\n@@ -231,0 +204,1 @@\n+            \/\/ TODO (review note): Given there are ~30,000 nodes in the image, is setting an initial capacity a good idea?\n@@ -232,0 +206,15 @@\n+            \/\/ TODO (review note): These should exist under all circumstances, but there's\n+            \/\/  probably a more robust way of getting it these offsets.\n+            this.modulesStringOffset = findLocation(\"\/modules\/java.base\").getModuleOffset();\n+            this.packagesStringOffset = findLocation(\"\/packages\/java.lang\").getModuleOffset();\n+\n+            \/\/ Node creation is very lazy, se can just make the top-level directories\n+            \/\/ now without the risk of triggering the building of lots of other nodes.\n+            Directory packages = newDirectory(PACKAGES_ROOT);\n+            nodes.put(packages.getName(), packages);\n+            Directory modules = newDirectory(MODULES_ROOT);\n+            nodes.put(modules.getName(), modules);\n+\n+            Directory root = newDirectory(\"\/\");\n+            root.setChildren(Arrays.asList(packages, modules));\n+            nodes.put(root.getName(), root);\n@@ -266,0 +255,1 @@\n+                    \/\/ TODO (review note): Should this be synchronized by \"this\" ??\n@@ -267,1 +257,0 @@\n-                    rootDir = null;\n@@ -276,3 +265,28 @@\n-        void addOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                openers.add(reader);\n+        \/\/\/ Returns a node in the JRT filesystem namespace, or null if no resource or\n+        \/\/\/ directory of that name exists.\n+        \/\/\/\n+        \/\/\/ Node names are absolute, `\/`-separated path strings, prefixed with\n+        \/\/\/ either \"\/modules\" or \"\/packages\".\n+        \/\/\/\n+        \/\/\/ This is the only public API by which anything outside this class can access\n+        \/\/\/ `Node` instances either directly, or by resolving a symbolic link.\n+        \/\/\/\n+        \/\/\/ Note also that there is no reentrant calling back to this method from within\n+        \/\/\/ the node handling code.\n+        synchronized Node findNode(String name) {\n+            Node node = nodes.get(name);\n+            if (node == null) {\n+                \/\/ We cannot be given the root paths (\"\/modules\" or \"\/packages\")\n+                \/\/ because those nodes are already in the nodes cache.\n+                if (name.startsWith(MODULES_ROOT + \"\/\")) {\n+                    node = buildModulesNode(name);\n+                } else if (name.startsWith(PACKAGES_ROOT + \"\/\")) {\n+                    node = buildPackagesNode(name);\n+                }\n+                if (node != null) {\n+                    nodes.put(node.getName(), node);\n+                }\n+            } else if (!node.isCompleted()) {\n+                \/\/ Only directories can be incomplete.\n+                assert node instanceof Directory : \"Invalid incomplete node: \" + node;\n+                completeDirectory((Directory) node);\n@@ -280,0 +294,2 @@\n+            assert node == null || node.isCompleted() : \"Incomplete node: \" + node;\n+            return node;\n@@ -282,3 +298,12 @@\n-        boolean removeOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                return openers.remove(reader);\n+        \/\/\/ Builds a node in the \"\/modules\/...\" namespace.\n+        \/\/\/\n+        \/\/\/ Called by `findNode()` if a `\/modules` node is not present in the cache.\n+        Node buildModulesNode(String name) {\n+            assert name.startsWith(MODULES_ROOT + \"\/\") : \"Invalid module node name: \" + name;\n+            \/\/ Will fail for non-directory resources, since the image path does not\n+            \/\/ start with \"\/modules\" (e.g. \"\/java.base\/java\/lang\/Object.class\").\n+            ImageLocation loc = findLocation(name);\n+            if (loc != null) {\n+                assert name.equals(loc.getFullName()) : \"Mismatched location for directory: \" + name;\n+                assert isModulesSubdirectory(loc) : \"Invalid modules directory: \" + name;\n+                return completeModuleDirectory(newDirectory(name), loc);\n@@ -286,16 +311,6 @@\n-        }\n-\n-        \/\/ directory management interface\n-        Directory getRootDirectory() {\n-            return buildRootDirectory();\n-        }\n-\n-        \/**\n-         * Lazily build a node from a name.\n-         *\/\n-        synchronized Node buildNode(String name) {\n-            Node n;\n-            boolean isPackages = name.startsWith(\"\/packages\");\n-            boolean isModules = !isPackages && name.startsWith(\"\/modules\");\n-\n-            if (!(isModules || isPackages)) {\n+            \/\/ TODO (review note): This is a heuristic to avoid spending time on lookup\n+            \/\/  in cases of failure, but is not strictly required for correct behaviour.\n+            \/\/ If there is no ImageLocation, the given name cannot be trusted to\n+            \/\/ belong to any resource (or even be a valid resource name).\n+            int moduleEnd = name.indexOf('\/', MODULES_ROOT.length() + 1);\n+            if (moduleEnd == -1) {\n@@ -304,17 +319,5 @@\n-\n-            ImageLocation loc = findLocation(name);\n-\n-            if (loc != null) { \/\/ A sub tree node\n-                if (isPackages) {\n-                    n = handlePackages(name, loc);\n-                } else { \/\/ modules sub tree\n-                    n = handleModulesSubTree(name, loc);\n-                }\n-            } else { \/\/ Asking for a resource? \/modules\/java.base\/java\/lang\/Object.class\n-                if (isModules) {\n-                    n = handleResource(name);\n-                } else {\n-                    \/\/ Possibly ask for \/packages\/java.lang\/java.base\n-                    \/\/ although \/packages\/java.base not created\n-                    n = handleModuleLink(name);\n-                }\n+            \/\/ Tests that the implied module name actually exists before doing\n+            \/\/ a full lookup for the location.\n+            ImageLocation moduleLoc = findLocation(name.substring(0, moduleEnd));\n+            if (moduleLoc == null || moduleLoc.getModuleOffset() == 0) {\n+                return null;\n@@ -322,7 +325,34 @@\n-            return n;\n-        }\n-\n-        synchronized Directory buildRootDirectory() {\n-            Directory root = rootDir; \/\/ volatile read\n-            if (root != null) {\n-                return root;\n+            \/\/ Resource paths in the image are NOT prefixed with \"\/modules\".\n+            ImageLocation resourceLoc = findLocation(name.substring(MODULES_ROOT.length()));\n+            return resourceLoc != null ? newResource(name, resourceLoc) : null;\n+        }\n+\n+        \/\/\/ Builds a node in the \"\/packages\/...\" namespace.\n+        \/\/\/\n+        \/\/\/ Called by `findNode()` if a `\/packages` node is not present in the cache.\n+        private Node buildPackagesNode(String name) {\n+            \/\/ There are only locations for the root \"\/packages\" or \"\/packages\/xxx\"\n+            \/\/ directories, but not the symbolic links below them (the links can be\n+            \/\/ entirely derived from the name information in the parent directory).\n+            \/\/ However, unlike resources this means that we do not have a constant\n+            \/\/ time lookup for link nodes when creating them.\n+            int packageStart = PACKAGES_ROOT.length() + 1;\n+            int packageEnd = name.indexOf('\/', packageStart);\n+            if (packageEnd == -1) {\n+                ImageLocation loc = findLocation(name);\n+                return loc != null ? completePackageDirectory(newDirectory(name), loc) : null;\n+            } else {\n+                \/\/ We cannot assume that because the given name was not cached, the\n+                \/\/ directory exists (the given name is untrusted and could reference\n+                \/\/ a non-existent link). However, *if* the parent directory *is*\n+                \/\/ present, we can conclude that the given name is not a valid link.\n+                String dirName = name.substring(0, packageEnd);\n+                if (!nodes.containsKey(dirName)) {\n+                    ImageLocation loc = findLocation(dirName);\n+                    if (loc != null) {\n+                        Directory dir = completePackageDirectory(newDirectory(dirName), loc);\n+                        \/\/ When the parent is created, its child nodes are cached.\n+                        nodes.put(dir.getName(), dir);\n+                        return nodes.get(name);\n+                    }\n+                }\n@@ -330,21 +360,1 @@\n-\n-            root = newDirectory(null, \"\/\");\n-            root.setIsRootDir();\n-\n-            \/\/ \/packages dir\n-            packagesDir = newDirectory(root, \"\/packages\");\n-            packagesDir.setIsPackagesDir();\n-\n-            \/\/ \/modules dir\n-            modulesDir = newDirectory(root, \"\/modules\");\n-            modulesDir.setIsModulesDir();\n-\n-            root.setCompleted(true);\n-            return rootDir = root;\n-        }\n-\n-        \/**\n-         * To visit sub tree resources.\n-         *\/\n-        interface LocationVisitor {\n-            void visit(ImageLocation loc);\n+            return null;\n@@ -353,9 +363,16 @@\n-        void visitLocation(ImageLocation loc, LocationVisitor visitor) {\n-            byte[] offsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            for (int i = 0; i < offsets.length \/ SIZE_OF_OFFSET; i++) {\n-                int offset = intBuffer.get(i);\n-                ImageLocation pkgLoc = getLocation(offset);\n-                visitor.visit(pkgLoc);\n+        \/\/\/ Completes a directory by ensuring its child list is populated correctly.\n+        private void completeDirectory(Directory dir) {\n+            String name = dir.getName();\n+            \/\/ Since the node exists, we can assert that its name starts with\n+            \/\/ either \"\/modules\" or \"\/packages\", making differentiation easy. It\n+            \/\/ also means that the name is valid, so it must yield a location.\n+            assert name.startsWith(MODULES_ROOT) || name.startsWith(PACKAGES_ROOT);\n+            ImageLocation loc = findLocation(name);\n+            assert loc != null && name.equals(loc.getFullName()) : \"Invalid location for name: \" + name;\n+            \/\/ We cannot use 'isXxxSubdirectory()' methods here since we could\n+            \/\/ be given a top-level directory (for which that test doesn't work).\n+            \/\/ TODO (review note): I feel a bit dirty putting this test in, but it is fast and accurate.\n+            if (name.charAt(1) == 'm') {\n+                completeModuleDirectory(dir, loc);\n+            } else {\n+                completePackageDirectory(dir, loc);\n@@ -363,22 +380,17 @@\n-        }\n-\n-        void visitPackageLocation(ImageLocation loc) {\n-            \/\/ Retrieve package name\n-            String pkgName = getBaseExt(loc);\n-            \/\/ Content is array of offsets in Strings table\n-            byte[] stringsOffsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(stringsOffsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            \/\/ For each module, create a link node.\n-            for (int i = 0; i < stringsOffsets.length \/ SIZE_OF_OFFSET; i++) {\n-                \/\/ skip empty state, useless.\n-                intBuffer.get(i);\n-                i++;\n-                int offset = intBuffer.get(i);\n-                String moduleName = getString(offset);\n-                Node targetNode = findNode(\"\/modules\/\" + moduleName);\n-                if (targetNode != null) {\n-                    String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                    Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                    newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + moduleName, targetNode);\n+            assert dir.isCompleted() : \"Directory must be complete by now: \" + dir;\n+        }\n+\n+        \/\/\/ Completes a modules directory by setting the list of child nodes.\n+        \/\/\/\n+        \/\/\/ The given directory can be the top level `\/modules` directory, so\n+        \/\/\/ it is NOT safe to use `isModulesSubdirectory(loc)` here.\n+        private Directory completeModuleDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            List<Node> children = createChildNodes(loc, (childloc) -> {\n+                if (isModulesSubdirectory(childloc)) {\n+                    return nodes.computeIfAbsent(childloc.getFullName(), this::newDirectory);\n+                } else {\n+                    \/\/ Add the \"\/modules\" prefix to image location paths to get\n+                    \/\/ Jrt file system names.\n+                    String resourceName = childloc.getFullName(true);\n+                    return nodes.computeIfAbsent(resourceName, n -> newResource(n, childloc));\n@@ -386,1 +398,3 @@\n-            }\n+            });\n+            dir.setChildren(children);\n+            return dir;\n@@ -389,10 +403,13 @@\n-        Node handlePackages(String name, ImageLocation loc) {\n-            long size = loc.getUncompressedSize();\n-            Node n = null;\n-            \/\/ Only possibilities are \/packages, \/packages\/package\/module\n-            if (name.equals(\"\/packages\")) {\n-                visitLocation(loc, (childloc) -> {\n-                    findNode(childloc.getFullName());\n-                });\n-                packagesDir.setCompleted(true);\n-                n = packagesDir;\n+        \/\/\/ Completes a package directory by setting the list of child nodes.\n+        \/\/\/\n+        \/\/\/ The given directory can be the top level `\/packages` directory, so\n+        \/\/\/ it is NOT safe to use `isPackagesSubdirectory(loc)` here.\n+        private Directory completePackageDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            \/\/ The only directories in the \"\/packages\" namespace are \"\/packages\" or\n+            \/\/ \"\/packages\/<package>\". However, unlike \"\/modules\" directories, the\n+            \/\/ location offsets mean different things.\n+            List<Node> children;\n+            if (dir.getName().equals(PACKAGES_ROOT)) {\n+                \/\/ Top-level directory just contains a list of subdirectories.\n+                children = createChildNodes(loc, c -> nodes.computeIfAbsent(c.getFullName(), this::newDirectory));\n@@ -400,16 +417,11 @@\n-                if (size != 0) { \/\/ children are offsets to module in StringsTable\n-                    String pkgName = getBaseExt(loc);\n-                    Directory pkgDir = newDirectory(packagesDir, packagesDir.getName() + \"\/\" + pkgName);\n-                    visitPackageLocation(loc);\n-                    pkgDir.setCompleted(true);\n-                    n = pkgDir;\n-                } else { \/\/ Link to module\n-                    String pkgName = loc.getParent();\n-                    String modName = getBaseExt(loc);\n-                    Node targetNode = findNode(\"\/modules\/\" + modName);\n-                    if (targetNode != null) {\n-                        String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                        Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                        Node linkNode = newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + modName, targetNode);\n-                        n = linkNode;\n-                    }\n+                \/\/ A package directory's content is array of offset PAIRS in the\n+                \/\/ Strings table, but we only need the 2nd value of each pair.\n+                IntBuffer intBuffer = getOffsetBuffer(loc);\n+                int offsetCount = intBuffer.capacity();\n+                children = new ArrayList<>(offsetCount \/ 2);\n+                \/\/ Iterate the 2nd offset in each pair (odd indices).\n+                for (int i = 1; i < offsetCount; i += 2) {\n+                    String moduleName = getString(intBuffer.get(i));\n+                    children.add(nodes.computeIfAbsent(\n+                            dir.getName() + \"\/\" + moduleName,\n+                            n -> newLinkNode(n, \"\/modules\/\" + moduleName)));\n@@ -418,53 +430,3 @@\n-            return n;\n-        }\n-\n-        \/\/ Asking for \/packages\/package\/module although\n-        \/\/ \/packages\/<pkg>\/ not yet created, need to create it\n-        \/\/ prior to return the link to module node.\n-        Node handleModuleLink(String name) {\n-            \/\/ eg: unresolved \/packages\/package\/module\n-            \/\/ Build \/packages\/package node\n-            Node ret = null;\n-            String radical = \"\/packages\/\";\n-            String path = name;\n-            if (path.startsWith(radical)) {\n-                int start = radical.length();\n-                int pkgEnd = path.indexOf('\/', start);\n-                if (pkgEnd != -1) {\n-                    String pkg = path.substring(start, pkgEnd);\n-                    String pkgPath = radical + pkg;\n-                    Node n = findNode(pkgPath);\n-                    \/\/ If not found means that this is a symbolic link such as:\n-                    \/\/ \/packages\/java.util\/java.base\/java\/util\/Vector.class\n-                    \/\/ and will be done by a retry of the filesystem\n-                    for (Node child : n.getChildren()) {\n-                        if (child.name.equals(name)) {\n-                            ret = child;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            return ret;\n-        }\n-\n-        Node handleModulesSubTree(String name, ImageLocation loc) {\n-            Node n;\n-            assert (name.equals(loc.getFullName()));\n-            Directory dir = makeDirectories(name);\n-            visitLocation(loc, (childloc) -> {\n-                String path = childloc.getFullName();\n-                if (path.startsWith(\"\/modules\")) { \/\/ a package\n-                    makeDirectories(path);\n-                } else { \/\/ a resource\n-                    makeDirectories(childloc.buildName(true, true, false));\n-                    \/\/ if we have already created a resource for this name previously, then don't\n-                    \/\/ recreate it\n-                    if (!nodes.containsKey(childloc.getFullName(true))) {\n-                        newResource(dir, childloc);\n-                    }\n-                }\n-            });\n-            dir.setCompleted(true);\n-            n = dir;\n-            return n;\n+            \/\/ This only happens once and \"completes\" the directory.\n+            dir.setChildren(children);\n+            return dir;\n@@ -473,13 +435,11 @@\n-        Node handleResource(String name) {\n-            Node n = null;\n-            if (!name.startsWith(\"\/modules\/\")) {\n-                return null;\n-            }\n-            \/\/ Make sure that the thing that follows \"\/modules\/\" is a module name.\n-            int moduleEndIndex = name.indexOf('\/', \"\/modules\/\".length());\n-            if (moduleEndIndex == -1) {\n-                return null;\n-            }\n-            ImageLocation moduleLoc = findLocation(name.substring(0, moduleEndIndex));\n-            if (moduleLoc == null || moduleLoc.getModuleOffset() == 0) {\n-                return null;\n+        \/\/\/ Creates the list of child nodes for a `Directory` based on a given\n+        \/\/\/ node creation function.\n+        \/\/\/\n+        \/\/\/ Note: This cannot be used for package subdirectories as they have\n+        \/\/\/ child offsets stored differently to other directories.\n+        private List<Node> createChildNodes(ImageLocation loc, Function<ImageLocation, Node> newChildFn) {\n+            IntBuffer offsets = getOffsetBuffer(loc);\n+            int childCount = offsets.capacity();\n+            List<Node> children = new ArrayList<>(childCount);\n+            for (int i = 0; i < childCount; i++) {\n+                children.add(newChildFn.apply(getLocation(offsets.get(i))));\n@@ -487,0 +447,2 @@\n+            return children;\n+        }\n@@ -488,8 +450,7 @@\n-            String locationPath = name.substring(\"\/modules\".length());\n-            ImageLocation resourceLoc = findLocation(locationPath);\n-            if (resourceLoc != null) {\n-                Directory dir = makeDirectories(resourceLoc.buildName(true, true, false));\n-                Resource res = newResource(dir, resourceLoc);\n-                n = res;\n-            }\n-            return n;\n+        \/\/\/ Helper to extract the integer offset buffer from a directory location.\n+        private IntBuffer getOffsetBuffer(ImageLocation dir) {\n+            assert isDirectory(dir) : \"Not a directory: \" + dir.getFullName();\n+            byte[] offsets = getResource(dir);\n+            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n+            buffer.order(getByteOrder());\n+            return buffer.asIntBuffer();\n@@ -498,7 +459,7 @@\n-        String getBaseExt(ImageLocation loc) {\n-            String base = loc.getBase();\n-            String ext = loc.getExtension();\n-            if (ext != null && !ext.isEmpty()) {\n-                base = base + \".\" + ext;\n-            }\n-            return base;\n+        \/\/\/ Determines if an image location is a directory in the `\/modules`\n+        \/\/\/ namespace (if so, the location name is the Jrt filesystem name).\n+        \/\/\/\n+        \/\/\/ In jimage, every `ImageLocation` under `\/modules\/` is a directory\n+        \/\/\/ and has the same value for `getModule()`, and `getModuleOffset()`.\n+        private boolean isModulesSubdirectory(ImageLocation loc) {\n+            return loc.getModuleOffset() == modulesStringOffset;\n@@ -507,7 +468,7 @@\n-        synchronized Node findNode(String name) {\n-            buildRootDirectory();\n-            Node n = nodes.get(name);\n-            if (n == null || !n.isCompleted()) {\n-                n = buildNode(name);\n-            }\n-            return n;\n+        \/\/\/ Determines if an image location is a directory in the `\/packages``\n+        \/\/\/ namespace (if so, the location name is the Jrt filesystem name).\n+        \/\/\/\n+        \/\/\/ In jimage, every `ImageLocation` under `\/packages\/` is a directory\n+        \/\/\/ and has the same value for `getModule()`, and `getModuleOffset()`.\n+        private boolean isPackagesSubdirectory(ImageLocation loc) {\n+            return loc.getModuleOffset() == packagesStringOffset;\n@@ -516,4 +477,8 @@\n-        \/**\n-         * Returns the file attributes of the image file.\n-         *\/\n-        BasicFileAttributes imageFileAttributes() {\n+        \/\/\/ Determines if an image location represents a directory of some kind.\n+        private boolean isDirectory(ImageLocation loc) {\n+            return isModulesSubdirectory(loc) || isPackagesSubdirectory(loc) || loc.getModuleOffset() == 0;\n+        }\n+\n+        \/\/\/ Returns the file attributes of the image file. Currently, all nodes\n+        \/\/\/ share the same attributes.\n+        private BasicFileAttributes imageFileAttributes() {\n@@ -523,2 +488,1 @@\n-                    Path file = getImagePath();\n-                    attrs = Files.readAttributes(file, BasicFileAttributes.class);\n+                    attrs = Files.readAttributes(getImagePath(), BasicFileAttributes.class);\n@@ -533,10 +497,5 @@\n-        Directory newDirectory(Directory parent, String name) {\n-            Directory dir = Directory.create(parent, name, imageFileAttributes());\n-            nodes.put(dir.getName(), dir);\n-            return dir;\n-        }\n-\n-        Resource newResource(Directory parent, ImageLocation loc) {\n-            Resource res = Resource.create(parent, loc, imageFileAttributes());\n-            nodes.put(res.getName(), res);\n-            return res;\n+        \/\/\/ Creates an \"incomplete\" directory node with no child nodes set.\n+        \/\/\/ Directories need to be \"completed\" before they are returned by\n+        \/\/\/ `findNode()`.\n+        private Directory newDirectory(String name) {\n+            return new Directory(name, imageFileAttributes());\n@@ -545,16 +504,6 @@\n-        LinkNode newLinkNode(Directory dir, String name, Node link) {\n-            LinkNode linkNode = LinkNode.create(dir, name, link);\n-            nodes.put(linkNode.getName(), linkNode);\n-            return linkNode;\n-        }\n-\n-        Directory makeDirectories(String parent) {\n-            Directory last = rootDir;\n-            for (int offset = parent.indexOf('\/', 1);\n-                    offset != -1;\n-                    offset = parent.indexOf('\/', offset + 1)) {\n-                String dir = parent.substring(0, offset);\n-                last = makeDirectory(dir, last);\n-            }\n-            return makeDirectory(parent, last);\n-\n+        \/\/\/ Creates a new resource from an image location. This is the only case\n+        \/\/\/ where the image location name does not match the requested node name.\n+        \/\/\/ In image files, resource locations are NOT prefixed by `\/modules`.\n+        private Resource newResource(String name, ImageLocation loc) {\n+            assert name.equals(loc.getFullName(true)) : \"Mismatched location for resource: \" + name;\n+            return new Resource(name, loc, imageFileAttributes());\n@@ -563,6 +512,6 @@\n-        Directory makeDirectory(String dir, Directory last) {\n-            Directory nextDir = (Directory) nodes.get(dir);\n-            if (nextDir == null) {\n-                nextDir = newDirectory(last, dir);\n-            }\n-            return nextDir;\n+        \/\/\/ Creates a new link node pointing at the given target name.\n+        \/\/\/\n+        \/\/\/ Note that target node is resolved each time `resolve()` is called, so\n+        \/\/\/ if a link node is retained after its reader is closed, it will fail.\n+        private LinkNode newLinkNode(String name, String targetName) {\n+            return new LinkNode(name, () -> findNode(targetName), imageFileAttributes());\n@@ -571,1 +520,3 @@\n-        byte[] getResource(Node node) throws IOException {\n+        \/\/\/ Returns the content of a resource node.\n+        private byte[] getResource(Node node) throws IOException {\n+            \/\/ We could have been given a non-resource node here.\n@@ -577,4 +528,0 @@\n-\n-        byte[] getResource(Resource rs) throws IOException {\n-            return super.getResource(rs.getLocation());\n-        }\n@@ -583,3 +530,3 @@\n-    \/\/ jimage file does not store directory structure. We build nodes\n-    \/\/ using the \"path\" strings found in the jimage file.\n-    \/\/ Node can be a directory or a resource\n+    \/**\n+     * A directory, resource or symbolic link in the JRT file system namespace.\n+     *\/\n@@ -587,5 +534,0 @@\n-        private static final int ROOT_DIR = 0b0000_0000_0000_0001;\n-        private static final int PACKAGES_DIR = 0b0000_0000_0000_0010;\n-        private static final int MODULES_DIR = 0b0000_0000_0000_0100;\n-\n-        private int flags;\n@@ -594,1 +536,0 @@\n-        private boolean completed;\n@@ -596,0 +537,1 @@\n+        \/\/ Only visible for use by ExplodedImage.\n@@ -601,31 +543,4 @@\n-        \/**\n-         * A node is completed when all its direct children have been built.\n-         *\n-         * @return\n-         *\/\n-        public boolean isCompleted() {\n-            return completed;\n-        }\n-\n-        public void setCompleted(boolean completed) {\n-            this.completed = completed;\n-        }\n-\n-        public final void setIsRootDir() {\n-            flags |= ROOT_DIR;\n-        }\n-\n-        public final boolean isRootDir() {\n-            return (flags & ROOT_DIR) != 0;\n-        }\n-\n-        public final void setIsPackagesDir() {\n-            flags |= PACKAGES_DIR;\n-        }\n-\n-        public final boolean isPackagesDir() {\n-            return (flags & PACKAGES_DIR) != 0;\n-        }\n-\n-        public final void setIsModulesDir() {\n-            flags |= MODULES_DIR;\n+        \/\/ A node is completed when all its direct children have been built. As\n+        \/\/ such, non-directory nodes are always complete.\n+        boolean isCompleted() {\n+            return true;\n@@ -634,2 +549,3 @@\n-        public final boolean isModulesDir() {\n-            return (flags & MODULES_DIR) != 0;\n+        \/\/ Only resources can return a location.\n+        ImageLocation getLocation() {\n+            throw new IllegalArgumentException(\"not a resource: \" + getName());\n@@ -638,0 +554,5 @@\n+        \/**\n+         * Returns the JRT file system compatible name of this node (e.g.\n+         * {@code \"\/modules\/java.base\/java\/lang\/Object.class\"} or {@code\n+         * \"\/packages\/java.lang\"}).\n+         *\/\n@@ -642,0 +563,4 @@\n+        \/**\n+         * Returns file attributes for this node. The value returned may be the\n+         * same for all nodes, and should not be relied upon for accuracy.\n+         *\/\n@@ -646,1 +571,4 @@\n-        \/\/ resolve this Node (if this is a soft link, get underlying Node)\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -651,0 +579,4 @@\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -655,1 +587,1 @@\n-        \/\/ is this a soft link Node?\n+        \/** Returns whether this node is a symbolic link. *\/\n@@ -660,0 +592,5 @@\n+        \/**\n+         * Returns whether this node is a directory. Directory nodes can have\n+         * {@link #getChildNames()} invoked to get the fully qualified names\n+         * of any child nodes.\n+         *\/\n@@ -664,4 +601,5 @@\n-        public List<Node> getChildren() {\n-            throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n-        }\n-\n+        \/**\n+         * Returns whether this node is a resource. Resource nodes can have\n+         * their contents obtained via {@link ImageReader#getResource(Node)}\n+         * or {@link ImageReader#getResourceBuffer(Node)}.\n+         *\/\n@@ -672,2 +610,9 @@\n-        public ImageLocation getLocation() {\n-            throw new IllegalArgumentException(\"not a resource: \" + getNameString());\n+        \/\/ TODO (review note): Sure this could\/should be IllegalStateException?\n+        \/**\n+         * Returns the fully qualified names of any child nodes for a directory.\n+         *\n+         * <p>If this node is not a directory ({@code isDirectory() == false})\n+         * then this method will throw {@link IllegalArgumentException}.\n+         *\/\n+        public Stream<String> getChildNames() {\n+            throw new IllegalArgumentException(\"not a directory: \" + getName());\n@@ -676,0 +621,4 @@\n+        \/**\n+         * Returns the uncompressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -680,0 +629,4 @@\n+        \/**\n+         * Returns the compressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -684,0 +637,4 @@\n+        \/**\n+         * Returns the extension string of a resource node. If this node is not\n+         * a resource, this method returns null.\n+         *\/\n@@ -688,20 +645,0 @@\n-        public long contentOffset() {\n-            return 0L;\n-        }\n-\n-        public final FileTime creationTime() {\n-            return fileAttrs.creationTime();\n-        }\n-\n-        public final FileTime lastAccessTime() {\n-            return fileAttrs.lastAccessTime();\n-        }\n-\n-        public final FileTime lastModifiedTime() {\n-            return fileAttrs.lastModifiedTime();\n-        }\n-\n-        public final String getNameString() {\n-            return name;\n-        }\n-\n@@ -710,1 +647,1 @@\n-            return getNameString();\n+            return getName();\n@@ -713,0 +650,2 @@\n+        \/\/\/  TODO (review note): In general, nodes are NOT comparable by name. They\n+        \/\/\/ can differ depending on the reader they came from, and soon preview mode.\n@@ -732,3 +671,21 @@\n-    \/\/ directory node - directory has full path name without '\/' at end.\n-    static final class Directory extends Node {\n-        private final List<Node> children;\n+    \/\/\/ Directory node (referenced from a full path, without a trailing '\/').\n+    \/\/\/\n+    \/\/\/ Directory nodes have two distinct states:\n+    \/\/\/ * Incomplete: The child list has not been set.\n+    \/\/\/ * Complete: The child list has been set.\n+    \/\/\/\n+    \/\/\/ When a directory node is returned by `findNode()` it is always complete,\n+    \/\/\/ but this DOES NOT mean that its child nodes are complete yet.\n+    \/\/\/\n+    \/\/\/ To avoid users being able to access incomplete child nodes, the\n+    \/\/\/ `Node` API offers only a way to obtain child node names, forcing\n+    \/\/\/ callers to invoke {@link ImageReader#findNode(String)} if they need to\n+    \/\/\/ access the child node itself.\n+    \/\/\/\n+    \/\/\/ This approach allows directories to be implemented lazily with respect\n+    \/\/\/ to child nodes, while retaining efficiency when child nodes are accessed\n+    \/\/\/ (since any incomplete nodes will be created and placed in the node cache\n+    \/\/\/ when the parent was first returned to the user).\n+    private static final class Directory extends Node {\n+        \/\/ Monotonic reference, will be set to the unmodifiable child list exactly once.\n+        private List<Node> children = null;\n@@ -738,1 +695,0 @@\n-            children = new ArrayList<>();\n@@ -741,6 +697,3 @@\n-        static Directory create(Directory parent, String name, BasicFileAttributes fileAttrs) {\n-            Directory d = new Directory(name, fileAttrs);\n-            if (parent != null) {\n-                parent.addChild(d);\n-            }\n-            return d;\n+        @Override\n+        boolean isCompleted() {\n+            return children != null;\n@@ -755,7 +708,5 @@\n-        public List<Node> getChildren() {\n-            return Collections.unmodifiableList(children);\n-        }\n-\n-        void addChild(Node node) {\n-            assert !children.contains(node) : \"Child \" + node + \" already added\";\n-            children.add(node);\n+        public Stream<String> getChildNames() {\n+            if (children != null) {\n+                return children.stream().map(Node::getName);\n+            }\n+            throw new IllegalStateException(\"Cannot get child nodes of an incomplete directory: \" + getName());\n@@ -764,9 +715,3 @@\n-        public void walk(Consumer<? super Node> consumer) {\n-            consumer.accept(this);\n-            for (Node child : children) {\n-                if (child.isDirectory()) {\n-                    ((Directory)child).walk(consumer);\n-                } else {\n-                    consumer.accept(child);\n-                }\n-            }\n+        private void setChildren(List<Node> children) {\n+            assert this.children == null : this + \": Cannot set child nodes twice!\";\n+            this.children = Collections.unmodifiableList(children);\n@@ -776,3 +721,11 @@\n-    \/\/ \"resource\" is .class or any other resource (compressed\/uncompressed) in a jimage.\n-    \/\/ full path of the resource is the \"name\" of the resource.\n-    static class Resource extends Node {\n+    \/\/\/ Resource node (e.g. a \".class\" entry, or any other data resource).\n+    \/\/\/\n+    \/\/\/ Resources are leaf nodes referencing an underlying image location. They\n+    \/\/\/ are lightweight, and do not cache their contents.\n+    \/\/\/\n+    \/\/\/ Unlike directories (where the node name matches the jimage path for the\n+    \/\/\/ corresponding `ImageLocation`), resource node names are NOT the same as\n+    \/\/\/ the corresponding jimage path. The difference is that node names for\n+    \/\/\/ resources are prefixed with \"\/modules\", which is missing from the\n+    \/\/\/ equivalent jimage path.\n+    private static class Resource extends Node {\n@@ -781,2 +734,2 @@\n-        private Resource(ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            super(loc.getFullName(true), fileAttrs);\n+        private Resource(String name, ImageLocation loc, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -786,6 +739,0 @@\n-        static Resource create(Directory parent, ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            Resource rs = new Resource(loc, fileAttrs);\n-            parent.addChild(rs);\n-            return rs;\n-        }\n-\n@@ -793,2 +740,2 @@\n-        public boolean isCompleted() {\n-            return true;\n+        ImageLocation getLocation() {\n+            return loc;\n@@ -802,5 +749,0 @@\n-        @Override\n-        public ImageLocation getLocation() {\n-            return loc;\n-        }\n-\n@@ -821,5 +763,0 @@\n-\n-        @Override\n-        public long contentOffset() {\n-            return loc.getContentOffset();\n-        }\n@@ -828,3 +765,8 @@\n-    \/\/ represents a soft link to another Node\n-    static class LinkNode extends Node {\n-        private final Node link;\n+    \/\/\/ Link node (a symbolic link to a top-level modules directory).\n+    \/\/\/\n+    \/\/\/ Link nodes resolve their target by invoking a given supplier, and do not\n+    \/\/\/ cache the result. Since nodes are cached by the `ImageReader`, this\n+    \/\/\/ means that only the first call to `resolveLink()` could do any\n+    \/\/\/ significant work.\n+    private static class LinkNode extends Node {\n+        private final Supplier<Node> link;\n@@ -832,2 +774,2 @@\n-        private LinkNode(String name, Node link) {\n-            super(name, link.getFileAttributes());\n+        private LinkNode(String name, Supplier<Node> link, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -837,11 +779,0 @@\n-        static LinkNode create(Directory parent, String name, Node link) {\n-            LinkNode ln = new LinkNode(name, link);\n-            parent.addChild(ln);\n-            return ln;\n-        }\n-\n-        @Override\n-        public boolean isCompleted() {\n-            return true;\n-        }\n-\n@@ -850,1 +781,1 @@\n-            return (recursive && link instanceof LinkNode) ? ((LinkNode)link).resolveLink(true) : link;\n+            return link.get();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":438,"deletions":507,"binary":false,"changes":945,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-        public List<Node> getChildren() {\n+        public Stream<String> getChildNames() {\n@@ -124,1 +124,1 @@\n-                throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n+                throw new IllegalArgumentException(\"not a directory: \" + getName());\n@@ -141,1 +141,1 @@\n-            return children;\n+            return children.stream().map(Node::getName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return node.creationTime();\n+        return node.getFileAttributes().creationTime();\n@@ -72,1 +72,1 @@\n-        return node.lastAccessTime();\n+        return node.getFileAttributes().lastAccessTime();\n@@ -77,1 +77,1 @@\n-        return node.lastModifiedTime();\n+        return node.getFileAttributes().lastModifiedTime();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileAttributes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.util.ArrayList;\n@@ -67,1 +66,0 @@\n-import static java.util.stream.Collectors.toList;\n@@ -228,4 +226,3 @@\n-            return node.getChildren()\n-                       .stream()\n-                       .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                       .iterator();\n+            return node.getChildNames()\n+                    .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                    .iterator();\n@@ -233,8 +230,9 @@\n-        return node.getChildren()\n-                   .stream()\n-                   .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                   .filter(p ->  { try { return filter.accept(p);\n-                                   } catch (IOException x) {}\n-                                   return false;\n-                                  })\n-                   .iterator();\n+        return node.getChildNames()\n+                .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                .filter(p -> {\n+                    try {\n+                        return filter.accept(p);\n+                    } catch (IOException x) {}\n+                    return false;\n+                })\n+                .iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-            image.getRootDirectory();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.net.URLConnection;\n@@ -57,1 +56,0 @@\n-import jdk.internal.jimage.ImageLocation;\n@@ -213,1 +211,1 @@\n-     * Parses the module-info.class of all module in the runtime image and\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n@@ -222,5 +220,0 @@\n-        ImageReader reader = SystemImage.reader();\n-        for (String mn : reader.getModuleNames()) {\n-            ImageLocation loc = reader.findLocation(mn, \"module-info.class\");\n-            ModuleInfo.Attributes attrs\n-                = ModuleInfo.read(reader.getResourceBuffer(loc), null);\n@@ -228,1 +221,2 @@\n-            nameToAttributes.put(mn, attrs);\n+        allModuleAttributes().forEach(attrs -> {\n+            nameToAttributes.put(attrs.descriptor().name(), attrs);\n@@ -235,1 +229,1 @@\n-        }\n+        });\n@@ -256,0 +250,29 @@\n+    \/**\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n+     * returns a stream of {@link ModuleInfo.Attributes Attributes} for them. The\n+     * returned attributes are in no specific order.\n+     *\/\n+    private static Stream<ModuleInfo.Attributes> allModuleAttributes() {\n+        \/\/ System reader is a singleton and should not be closed by callers.\n+        ImageReader reader = SystemImage.reader();\n+        try {\n+            return reader.findNode(\"\/modules\").getChildNames().map(mn -> loadModuleAttributes(reader, mn));\n+        } catch (IOException e) {\n+            throw new Error(\"Error reading root \/modules entry\", e);\n+        }\n+    }\n+\n+    \/\/ The nodes we are processing must exist (every module must have a module-info.class).\n+    private static ModuleInfo.Attributes loadModuleAttributes(ImageReader reader, String moduleName) {\n+        Exception err = null;\n+        try {\n+            ImageReader.Node node = reader.findNode(moduleName + \"\/module-info.class\");\n+            if (node != null && node.isResource()) {\n+                return ModuleInfo.read(reader.getResourceBuffer(node), null);\n+            }\n+        } catch (IOException | UncheckedIOException e) {\n+            err = e;\n+        }\n+        throw new Error(\"Missing or invalid module-info.class for module: \" + moduleName, err);\n+    }\n+\n@@ -385,17 +408,0 @@\n-        \/**\n-         * Returns the ImageLocation for the given resource, {@code null}\n-         * if not found.\n-         *\/\n-        private ImageLocation findImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n-            if (closed)\n-                throw new IOException(\"ModuleReader is closed\");\n-            ImageReader imageReader = SystemImage.reader();\n-            if (imageReader != null) {\n-                return imageReader.findLocation(module, name);\n-            } else {\n-                \/\/ not an images build\n-                return null;\n-            }\n-        }\n-\n@@ -406,2 +412,2 @@\n-        private boolean containsImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n+        private boolean containsResource(String resourcePath) throws IOException {\n+            Objects.requireNonNull(resourcePath);\n@@ -412,1 +418,2 @@\n-                return imageReader.verifyLocation(module, name);\n+                ImageReader.Node node = imageReader.findNode(\"\/modules\" + resourcePath);\n+                return node != null && node.isResource();\n@@ -421,2 +428,3 @@\n-            if (containsImageLocation(name)) {\n-                URI u = JNUA.create(\"jrt\", \"\/\" + module + \"\/\" + name);\n+            String resourcePath = \"\/\" + module + \"\/\" + name;\n+            if (containsResource(resourcePath)) {\n+                URI u = JNUA.create(\"jrt\", resourcePath);\n@@ -445,0 +453,15 @@\n+        \/**\n+         * Returns the node for the given resource if found. If the name references\n+         * a non-resource node, then an {@link Optional#empty() empty optional} is\n+         * returned even if a non-resource node exists with the given name.\n+         *\/\n+        private Optional<ImageReader.Node> findResourceNode(ImageReader reader, String name) throws IOException {\n+            Objects.requireNonNull(name);\n+            if (closed) {\n+                throw new IOException(\"ModuleReader is closed\");\n+            }\n+            String nodeName = \"\/modules\/\" + module + \"\/\" + name;\n+            ImageReader.Node node = reader.findNode(nodeName);\n+            return node != null && node.isResource() ? Optional.of(node) : Optional.empty();\n+        }\n+\n@@ -447,6 +470,2 @@\n-            ImageLocation location = findImageLocation(name);\n-            if (location != null) {\n-                return Optional.of(SystemImage.reader().getResourceBuffer(location));\n-            } else {\n-                return Optional.empty();\n-            }\n+            ImageReader reader = SystemImage.reader();\n+            return findResourceNode(reader, name).map(reader::getResourceBuffer);\n@@ -484,1 +503,1 @@\n-        Iterator<ImageReader.Node> iterator;\n+        Iterator<String> iterator;\n@@ -505,2 +524,2 @@\n-                    ImageReader.Node node = iterator.next();\n-                    String name = node.getName();\n+                    String name = iterator.next();\n+                    ImageReader.Node node = SystemImage.reader().findNode(name);\n@@ -508,4 +527,1 @@\n-                        \/\/ build node\n-                        ImageReader.Node dir = SystemImage.reader().findNode(name);\n-                        assert dir.isDirectory();\n-                        stack.push(dir);\n+                        stack.push(node);\n@@ -523,1 +539,1 @@\n-                    iterator = dir.getChildren().iterator();\n+                    iterator = dir.getChildNames().iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":63,"deletions":47,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ImageReader;\n+import jdk.internal.jimage.ImageReader.Node;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.util.JarBuilder;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.opentest4j.TestSkippedException;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ImageReader.\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @library \/test\/jdk\/tools\/lib\n+ *          \/test\/lib\n+ * @build tests.*\n+ * @run junit\/othervm ImageReaderTest\n+ *\/\n+\n+\/\/\/ Using PER_CLASS lifecycle means the (expensive) image file is only build once.\n+\/\/\/ There is no mutable test instance state to worry about.\n+@TestInstance(PER_CLASS)\n+public class ImageReaderTest {\n+\n+    private static final Map<String, List<String>> IMAGE_ENTRIES = Map.of(\n+            \"modfoo\", Arrays.asList(\n+                    \"com.foo.Alpha\",\n+                    \"com.foo.Beta\",\n+                    \"com.foo.bar.Gamma\"),\n+            \"modbar\", Arrays.asList(\n+                    \"com.bar.One\",\n+                    \"com.bar.Two\"));\n+    private final Path image = buildJImage(IMAGE_ENTRIES);\n+\n+    @Test\n+    public void testModuleDirectories() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            \/\/ Basic directory expectations.\n+            assertDir(reader, \"\/\");\n+            assertDir(reader, \"\/modules\");\n+            assertDir(reader, \"\/modules\/modfoo\");\n+            assertDir(reader, \"\/modules\/modbar\");\n+            assertDir(reader, \"\/modules\/modfoo\/com\");\n+            assertDir(reader, \"\/modules\/modfoo\/com\/foo\");\n+            assertDir(reader, \"\/modules\/modfoo\/com\/foo\/bar\");\n+\n+            assertAbsent(reader, \"\/modules\/\");\n+            assertAbsent(reader, \"\/modules\/unknown\");\n+            assertAbsent(reader, \"\/modules\/modbar\/\");\n+            assertAbsent(reader, \"\/modules\/modbar\/\/com\");\n+            assertAbsent(reader, \"\/modules\/modbar\/com\/\");\n+        }\n+    }\n+\n+    @Test\n+    public void testModuleResources() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNode(reader, \"\/modules\/modfoo\/com\/foo\/Alpha.class\");\n+            assertNode(reader, \"\/modules\/modbar\/com\/bar\/One.class\");\n+\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+            assertEquals(\"Class: com.foo.Alpha\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Alpha\"));\n+            assertEquals(\"Class: com.foo.Beta\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Beta\"));\n+            assertEquals(\"Class: com.foo.bar.Gamma\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.Gamma\"));\n+            assertEquals(\"Class: com.bar.One\", loader.loadAndGetToString(\"modbar\", \"com.bar.One\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageDirectories() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node root = assertDir(reader, \"\/packages\");\n+            Set<String> pkgNames = root.getChildNames().collect(Collectors.toSet());\n+            assertTrue(pkgNames.contains(\"\/packages\/com\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.foo\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.bar\"));\n+\n+            \/\/ Even though no classes exist directly in the \"com\" package, it still\n+            \/\/ creates a directory with links back to all the modules which contain it.\n+            Set<String> comLinks = assertDir(reader, \"\/packages\/com\").getChildNames().collect(Collectors.toSet());\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modfoo\"));\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modbar\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageLinks() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node moduleFoo = assertDir(reader, \"\/modules\/modfoo\");\n+            Node moduleBar = assertDir(reader, \"\/modules\/modbar\");\n+            assertSame(assertLink(reader, \"\/packages\/com.foo\/modfoo\").resolveLink(), moduleFoo);\n+            assertSame(assertLink(reader, \"\/packages\/com.bar\/modbar\").resolveLink(), moduleBar);\n+        }\n+    }\n+\n+    private static ImageReader.Node assertNode(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node node = reader.findNode(name);\n+        assertNotNull(node, \"Could not find node: \" + name);\n+        return node;\n+    }\n+\n+    private static ImageReader.Node assertDir(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node dir = assertNode(reader, name);\n+        assertTrue(dir.isDirectory(), \"Node was not a directory: \" + name);\n+        return dir;\n+    }\n+\n+    private static ImageReader.Node assertLink(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node link = assertNode(reader, name);\n+        assertTrue(link.isLink(), \"Node was not a symbolic link: \" + name);\n+        return link;\n+    }\n+\n+    private static void assertAbsent(ImageReader reader, String name) throws IOException {\n+        assertNull(reader.findNode(name), \"Should not be able to find node: \" + name);\n+    }\n+\n+    \/\/\/ Builds a jimage file with the specified class entries. The classes in the built\n+    \/\/\/ image can be loaded and executed to return their names via `toString()` to confirm\n+    \/\/\/ the correct bytes were returned.\n+    public static Path buildJImage(Map<String, List<String>> entries) {\n+        Helper helper = getHelper();\n+        Path outDir = helper.createNewImageDir(\"test\");\n+        JImageGenerator.JLinkTask jlink = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(outDir);\n+\n+        Path jarDir = helper.getJarDir();\n+        IMAGE_ENTRIES.forEach((module, classes) -> {\n+            JarBuilder jar = new JarBuilder(jarDir.resolve(module + \".jar\").toString());\n+            String moduleInfo = \"module \" + module + \" {}\";\n+            jar.addEntry(\"module-info.class\", InMemoryJavaCompiler.compile(\"module-info\", moduleInfo));\n+\n+            classes.forEach(fqn -> {\n+                int lastDot = fqn.lastIndexOf('.');\n+                String pkg = fqn.substring(0, lastDot);\n+                String cls = fqn.substring(lastDot + 1);\n+\n+                String path = fqn.replace('.', '\/') + \".class\";\n+                String source = String.format(\n+                        \"\"\"\n+                        package %s;\n+                        public class %s {\n+                            public String toString() {\n+                                return \"Class: %s\";\n+                            }\n+                        }\n+                        \"\"\", pkg, cls, fqn);\n+                jar.addEntry(path, InMemoryJavaCompiler.compile(fqn, source));\n+            });\n+            try {\n+                jar.build();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+            jlink.addMods(module);\n+        });\n+        return jlink.call().assertSuccess().resolve(\"lib\", \"modules\");\n+    }\n+\n+    \/\/\/  Returns the helper for building JAR and jimage files.\n+    private static Helper getHelper() {\n+        try {\n+            Helper helper = Helper.newHelper();\n+            if (helper == null) {\n+                throw new TestSkippedException(\"Cannot create test helper (exploded image?)\");\n+            }\n+            return helper;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/\/ Loads and performs actions on classes stored in a given `ImageReader`.\n+    private static class ImageClassLoader extends ClassLoader {\n+        private final ImageReader reader;\n+        private final Set<String> testModules;\n+\n+        private ImageClassLoader(ImageReader reader, Set<String> testModules) {\n+            this.reader = reader;\n+            this.testModules = testModules;\n+        }\n+\n+        @FunctionalInterface\n+        public interface ClassAction<R, T extends Exception> {\n+            R call(Class<?> cls) throws T;\n+        }\n+\n+        String loadAndGetToString(String module, String fqn) {\n+            return loadAndCall(module, fqn, c -> c.getDeclaredConstructor().newInstance().toString());\n+        }\n+\n+        <R> R loadAndCall(String module, String fqn, ClassAction<R, ?> action) {\n+            Class<?> cls = findClass(module, fqn);\n+            assertNotNull(cls, \"Could not load class: \" + module + \"\/\" + fqn);\n+            try {\n+                return action.call(cls);\n+            } catch (Exception e) {\n+                fail(\"Class loading failed\", e);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String module, String fqn) {\n+            assumeTrue(testModules.contains(module), \"Can only load classes in modules: \" + testModules);\n+            String name = \"\/modules\/\" + module + \"\/\" + fqn.replace('.', '\/') + \".class\";\n+            Class<?> cls = findLoadedClass(fqn);\n+            if (cls == null) {\n+                try {\n+                    ImageReader.Node node = reader.findNode(name);\n+                    if (node != null && node.isResource()) {\n+                        byte[] classBytes = reader.getResource(node);\n+                        cls = defineClass(fqn, classBytes, 0, classBytes.length);\n+                        resolveClass(cls);\n+                        return cls;\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng JImageReadTest\n+ * @run testng\/othervm JImageReadTest\n@@ -52,0 +52,3 @@\n+import static java.nio.ByteOrder.BIG_ENDIAN;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n@@ -336,10 +339,6 @@\n-        ImageReader nativeReader = ImageReader.open(imageFile);\n-        Assert.assertEquals(nativeReader.getByteOrder(), ByteOrder.nativeOrder());\n-\n-        try {\n-            ImageReader leReader = ImageReader.open(imageFile, ByteOrder.LITTLE_ENDIAN);\n-            Assert.assertEquals(leReader.getByteOrder(), ByteOrder.LITTLE_ENDIAN);\n-            leReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Will be opened with native byte order.\n+        try (ImageReader nativeReader = ImageReader.open(imageFile)) {\n+            \/\/ Just ensure something works as expected.\n+            Assert.assertNotNull(nativeReader.findNode(\"\/\"));\n+        } catch (IOException expected) {\n+            Assert.fail(\"Reader should be openable with native byte order.\");\n@@ -348,7 +347,4 @@\n-        try {\n-            ImageReader beReader = ImageReader.open(imageFile, ByteOrder.BIG_ENDIAN);\n-            Assert.assertEquals(beReader.getByteOrder(), ByteOrder.BIG_ENDIAN);\n-            beReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.BIG_ENDIAN);\n+        ByteOrder otherOrder = ByteOrder.nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        try (ImageReader badReader = ImageReader.open(imageFile, otherOrder)) {\n+            Assert.fail(\"Reader should not be openable with the wrong byte order.\");\n+        } catch (IOException expected) {\n@@ -356,2 +352,0 @@\n-\n-        nativeReader.close();\n@@ -359,1 +353,0 @@\n-    \/\/ main method to run standalone from jtreg\n@@ -361,1 +354,2 @@\n-    @Test(enabled=false)\n+    \/\/ main method to run standalone from jtreg\n+    @Test(enabled = false)\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-            final List<ImageReader.Node> children = parent.getChildren();\n-            if (children == null || children.isEmpty()) {\n+            final List<String> childNames = parent.getChildNames().toList();\n+            if (childNames.isEmpty()) {\n@@ -77,2 +77,2 @@\n-            for (final ImageReader.Node child : children) {\n-                final boolean unique = uniqueChildren.add(child);\n+            for (final String childName : childNames) {\n+                final boolean unique = uniqueChildren.add(reader.findNode(childName));\n@@ -81,1 +81,1 @@\n-                            + child + \" under \" + parent + \" from image \" + imagePath);\n+                            + childName + \" under \" + parent + \" from image \" + imagePath);\n","filename":"test\/jdk\/tools\/jimage\/ImageReaderDuplicateChildNodesTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1072 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.internal.jrtfs;\n+\n+import jdk.internal.jimage.ImageReader;\n+import jdk.internal.jimage.ImageReader.Node;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.IOException;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+\/\/\/ Benchmarks for ImageReader. See individual benchmarks for details on what they\n+\/\/\/ measure, and their potential applicability for real world conclusions.\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 1, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.jimage=ALL-UNNAMED\"})\n+public class ImageReaderBenchmark {\n+\n+    private static final Path SYSTEM_IMAGE_FILE = Path.of(System.getProperty(\"java.home\"), \"lib\", \"modules\");\n+    static {\n+        if (!Files.exists(SYSTEM_IMAGE_FILE)) {\n+            throw new IllegalStateException(\"Cannot locate jimage file for benchmark: \" + SYSTEM_IMAGE_FILE);\n+        }\n+    }\n+\n+    \/\/\/ NOT annotated with `@State` since it needs to potentially be used as a\n+    \/\/\/ per-benchmark or a per-iteration state object. The subclasses provide\n+    \/\/\/ any lifetime annotations that are needed.\n+    static class BaseState {\n+        protected Path copiedImageFile;\n+        protected ByteOrder byteOrder;\n+        long count = 0;\n+\n+        public void setUp() throws IOException {\n+            copiedImageFile = Files.createTempFile(\"copied_jimage\", \"\");\n+            byteOrder = ByteOrder.nativeOrder();\n+            Files.copy(SYSTEM_IMAGE_FILE, copiedImageFile, REPLACE_EXISTING);\n+        }\n+\n+        public void tearDown() throws IOException {\n+            Files.deleteIfExists(copiedImageFile);\n+            System.err.println(\"Result: \" + count);\n+        }\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class WarmStartWithImageReader extends BaseState {\n+        ImageReader reader;\n+\n+        @Setup(Level.Trial)\n+        public void setUp() throws IOException {\n+            super.setUp();\n+            reader = ImageReader.open(copiedImageFile, byteOrder);\n+        }\n+\n+        @TearDown(Level.Trial)\n+        public void tearDown() throws IOException {\n+            super.tearDown();\n+        }\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class ColdStart extends BaseState {\n+        @Setup(Level.Iteration)\n+        public void setUp() throws IOException {\n+            super.setUp();\n+        }\n+\n+        @TearDown(Level.Iteration)\n+        public void tearDown() throws IOException {\n+            super.tearDown();\n+        }\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class ColdStartWithImageReader extends BaseState {\n+        ImageReader reader;\n+\n+        @Setup(Level.Iteration)\n+        public void setup() throws IOException {\n+            super.setUp();\n+            reader = ImageReader.open(copiedImageFile, byteOrder);\n+        }\n+\n+        @TearDown(Level.Iteration)\n+        public void tearDown() throws IOException {\n+            reader.close();\n+            super.tearDown();\n+        }\n+    }\n+\n+    \/\/\/ Benchmarks counting of all nodes in the system image *after* they have all\n+    \/\/\/ been visited at least once. Image nodes should be cached after first use,\n+    \/\/\/ so this benchmark should be fast and very stable.\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public void warmCache_CountAllNodes(WarmStartWithImageReader state) throws IOException {\n+        state.count = countAllNodes(state.reader, state.reader.findNode(\"\/\"));\n+    }\n+\n+    \/\/\/ Benchmarks counting of all nodes in the system image from a \"cold start\". This\n+    \/\/\/ visits all nodes in depth-first order and counts them.\n+    \/\/\/\n+    \/\/\/ This benchmark is not representative of any typical usage pattern, but can be\n+    \/\/\/ used for comparisons between versions of `ImageReader`.\n+    @Benchmark\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    public void coldStart_InitAndCount(ColdStart state) throws IOException {\n+        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+            state.count = countAllNodes(reader, reader.findNode(\"\/\"));\n+        }\n+    }\n+\n+    \/\/\/ As above, but includes the time to initialize the `ImageReader`.\n+    @Benchmark\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    public void coldStart_CountOnly(ColdStartWithImageReader state) throws IOException {\n+        state.count = countAllNodes(state.reader, state.reader.findNode(\"\/\"));\n+    }\n+\n+    \/\/\/ Benchmarks the time taken to load the byte array contents of classes\n+    \/\/\/ representative of those loaded by javac to for the simplest `HelloWorld`\n+    \/\/\/ program.\n+    \/\/\/\n+    \/\/\/ This benchmark is somewhat representative of the cost of class loading\n+    \/\/\/ during javac startup. It is useful for comparisons between versions of\n+    \/\/\/ `ImageReader`, but also to estimate a lower bound for any reduction or\n+    \/\/\/ increase in the real-world startup time of javac.\n+    @Benchmark\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    public void coldStart_LoadJavacInitClasses(Blackhole bh, ColdStart state) throws IOException {\n+        int errors = 0;\n+        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+            for (String path : INIT_CLASSES) {\n+                \/\/ Path determination isn't perfect so there can be a few \"misses\" in here.\n+                \/\/ Report the count of bad paths as the \"result\", which should be < 20 or so.\n+                Node node = reader.findNode(path);\n+                if (node != null) {\n+                    bh.consume(reader.getResource(node));\n+                } else {\n+                    errors += 1;\n+                }\n+            }\n+        }\n+        state.count = INIT_CLASSES.size();\n+        \/\/ Allow up to 2% missing classes before complaining.\n+        if ((100 * errors) \/ INIT_CLASSES.size() >= 2) {\n+            reportMissingClassesAndFail(state, errors);\n+        }\n+    }\n+\n+    static long countAllNodes(ImageReader reader, Node node) {\n+        long count = 1;\n+        if (node.isDirectory()) {\n+            count += node.getChildNames().mapToLong(n -> {\n+                try {\n+                    return countAllNodes(reader, reader.findNode(n));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }).sum();\n+        }\n+        return count;\n+    }\n+\n+    \/\/ Run if the INIT_CLASSES list below is sufficiently out-of-date.\n+    \/\/ DO NOT run this before the benchmark, as it will cache all the nodes!\n+    private static void reportMissingClassesAndFail(ColdStart state, int errors) throws IOException {\n+        List<String> missing = new ArrayList<>(errors);\n+        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+            for (String path : INIT_CLASSES) {\n+                if (reader.findNode(path) == null) {\n+                    missing.add(path);\n+                }\n+            }\n+        }\n+        throw new IllegalStateException(\n+                String.format(\n+                        \"Too many missing classes (%d of %d) in the hardcoded benchmark list.\\n\" +\n+                                \"Please regenerate it according to instructions in the source code.\\n\" +\n+                                \"Missing classes:\\n\\t%s\",\n+                        errors, INIT_CLASSES.size(), String.join(\"\\n\\t\", missing)));\n+    }\n+\n+    \/\/ Created by running \"java -verbose:class\", throwing away anonymous inner\n+    \/\/ classes and anything without a reliable name, and grouping by the stated\n+    \/\/ source. It's not perfect, but it's representative.\n+    \/\/\n+    \/\/ <jdk_root>\/bin\/java -verbose:class HelloWorld 2>&1 \\\n+    \/\/   | fgrep '[class,load]' | cut -d' ' -f2 \\\n+    \/\/   | tr '.' '\/' \\\n+    \/\/   | egrep -v '\\$[0-9$]' \\\n+    \/\/   | fgrep -v 'HelloWorld' \\\n+    \/\/   | fgrep -v '\/META-INF\/preview\/' \\\n+    \/\/   | while read f ; do echo \"${f}.class\" ; done \\\n+    \/\/   > initclasses.txt\n+    \/\/\n+    \/\/ Output:\n+    \/\/    java\/lang\/Object.class\n+    \/\/    java\/io\/Serializable.class\n+    \/\/    ...\n+    \/\/\n+    \/\/ jimage list <jdk_root>\/images\/jdk\/lib\/modules \\\n+    \/\/     | awk '\/^Module: *\/ { MOD=$2 }; \/^    *\/ { print \"\/modules\/\"MOD\"\/\"$1 }' \\\n+    \/\/     > fullpaths.txt\n+    \/\/\n+    \/\/ Output:\n+    \/\/     ...\n+    \/\/     \/modules\/java.base\/java\/lang\/Object.class\n+    \/\/     \/modules\/java.base\/java\/lang\/OutOfMemoryError.class\n+    \/\/     ...\n+    \/\/\n+    \/\/ while read c ; do grep \"\/$c\" fullpaths.txt ; done < initclasses.txt \\\n+    \/\/     | while read c ; do printf '    \"%s\",\\n' \"$c\" ; done \\\n+    \/\/     > initpaths.txt\n+    \/\/\n+    \/\/ Output:\n+    private static final Set<String> INIT_CLASSES = Set.of(\n+            \"\/modules\/java.base\/java\/lang\/Object.class\",\n+            \"\/modules\/java.base\/java\/io\/Serializable.class\",\n+            \"\/modules\/java.base\/java\/lang\/Comparable.class\",\n+            \"\/modules\/java.base\/java\/lang\/CharSequence.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/Constable.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/ConstantDesc.class\",\n+            \"\/modules\/java.base\/java\/lang\/String.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/AnnotatedElement.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/GenericDeclaration.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Type.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor$OfField.class\",\n+            \"\/modules\/java.base\/java\/lang\/Class.class\",\n+            \"\/modules\/java.base\/java\/lang\/Cloneable.class\",\n+            \"\/modules\/java.base\/java\/lang\/ClassLoader.class\",\n+            \"\/modules\/java.base\/java\/lang\/System.class\",\n+            \"\/modules\/java.base\/java\/lang\/Throwable.class\",\n+            \"\/modules\/java.base\/java\/lang\/Error.class\",\n+            \"\/modules\/java.base\/java\/lang\/Exception.class\",\n+            \"\/modules\/java.base\/java\/lang\/RuntimeException.class\",\n+            \"\/modules\/java.base\/java\/security\/ProtectionDomain.class\",\n+            \"\/modules\/java.base\/java\/security\/SecureClassLoader.class\",\n+            \"\/modules\/java.base\/java\/lang\/ReflectiveOperationException.class\",\n+            \"\/modules\/java.base\/java\/lang\/ClassNotFoundException.class\",\n+            \"\/modules\/java.base\/java\/lang\/Record.class\",\n+            \"\/modules\/java.base\/java\/lang\/LinkageError.class\",\n+            \"\/modules\/java.base\/java\/lang\/NoClassDefFoundError.class\",\n+            \"\/modules\/java.base\/java\/lang\/ClassCastException.class\",\n+            \"\/modules\/java.base\/java\/lang\/ArrayStoreException.class\",\n+            \"\/modules\/java.base\/java\/lang\/VirtualMachineError.class\",\n+            \"\/modules\/java.base\/java\/lang\/InternalError.class\",\n+            \"\/modules\/java.base\/java\/lang\/OutOfMemoryError.class\",\n+            \"\/modules\/java.base\/java\/lang\/StackOverflowError.class\",\n+            \"\/modules\/java.base\/java\/lang\/IllegalMonitorStateException.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/Reference.class\",\n+            \"\/modules\/java.base\/java\/lang\/IllegalCallerException.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/SoftReference.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/WeakReference.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/FinalReference.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/PhantomReference.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/Finalizer.class\",\n+            \"\/modules\/java.base\/java\/lang\/Runnable.class\",\n+            \"\/modules\/java.base\/java\/lang\/Thread.class\",\n+            \"\/modules\/java.base\/java\/lang\/Thread$FieldHolder.class\",\n+            \"\/modules\/java.base\/java\/lang\/Thread$Constants.class\",\n+            \"\/modules\/java.base\/java\/lang\/Thread$UncaughtExceptionHandler.class\",\n+            \"\/modules\/java.base\/java\/lang\/ThreadGroup.class\",\n+            \"\/modules\/java.base\/java\/lang\/BaseVirtualThread.class\",\n+            \"\/modules\/java.base\/java\/lang\/VirtualThread.class\",\n+            \"\/modules\/java.base\/java\/lang\/ThreadBuilders$BoundVirtualThread.class\",\n+            \"\/modules\/java.base\/java\/util\/Map.class\",\n+            \"\/modules\/java.base\/java\/util\/Dictionary.class\",\n+            \"\/modules\/java.base\/java\/util\/Hashtable.class\",\n+            \"\/modules\/java.base\/java\/util\/Properties.class\",\n+            \"\/modules\/java.base\/java\/lang\/Module.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/AccessibleObject.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Member.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Field.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Parameter.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Executable.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Method.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Constructor.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/ContinuationScope.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/Continuation.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/StackChunk.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodAccessor.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodAccessorImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstantPool.class\",\n+            \"\/modules\/java.base\/java\/lang\/annotation\/Annotation.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/CallerSensitive.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstructorAccessor.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstructorAccessorImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/DirectConstructorHandleAccessor$NativeAccessor.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MemberName.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/ResolvedMethodName.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleNatives.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor$OfMethod.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodType.class\",\n+            \"\/modules\/java.base\/java\/lang\/BootstrapMethodError.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/CallSite.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/ABIDescriptor.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/VMStorage.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/UpcallLinker$CallRegs.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/ConstantCallSite.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MutableCallSite.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VolatileCallSite.class\",\n+            \"\/modules\/java.base\/java\/lang\/AssertionStatusDirectives.class\",\n+            \"\/modules\/java.base\/java\/lang\/Appendable.class\",\n+            \"\/modules\/java.base\/java\/lang\/AbstractStringBuilder.class\",\n+            \"\/modules\/java.base\/java\/lang\/StringBuffer.class\",\n+            \"\/modules\/java.base\/java\/lang\/StringBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/UnsafeConstants.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/Unsafe.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/Modules.class\",\n+            \"\/modules\/java.base\/java\/lang\/AutoCloseable.class\",\n+            \"\/modules\/java.base\/java\/io\/Closeable.class\",\n+            \"\/modules\/java.base\/java\/io\/InputStream.class\",\n+            \"\/modules\/java.base\/java\/io\/ByteArrayInputStream.class\",\n+            \"\/modules\/java.base\/java\/net\/URL.class\",\n+            \"\/modules\/java.base\/java\/lang\/Enum.class\",\n+            \"\/modules\/java.base\/java\/util\/jar\/Manifest.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/BuiltinClassLoader.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$AppClassLoader.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$PlatformClassLoader.class\",\n+            \"\/modules\/java.base\/java\/security\/CodeSource.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentMap.class\",\n+            \"\/modules\/java.base\/java\/util\/AbstractMap.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap.class\",\n+            \"\/modules\/java.base\/java\/lang\/Iterable.class\",\n+            \"\/modules\/java.base\/java\/util\/Collection.class\",\n+            \"\/modules\/java.base\/java\/util\/SequencedCollection.class\",\n+            \"\/modules\/java.base\/java\/util\/List.class\",\n+            \"\/modules\/java.base\/java\/util\/RandomAccess.class\",\n+            \"\/modules\/java.base\/java\/util\/AbstractCollection.class\",\n+            \"\/modules\/java.base\/java\/util\/AbstractList.class\",\n+            \"\/modules\/java.base\/java\/util\/ArrayList.class\",\n+            \"\/modules\/java.base\/java\/lang\/StackTraceElement.class\",\n+            \"\/modules\/java.base\/java\/nio\/Buffer.class\",\n+            \"\/modules\/java.base\/java\/lang\/StackWalker.class\",\n+            \"\/modules\/java.base\/java\/lang\/StackStreamFactory$AbstractStackWalker.class\",\n+            \"\/modules\/java.base\/java\/lang\/StackWalker$StackFrame.class\",\n+            \"\/modules\/java.base\/java\/lang\/ClassFrameInfo.class\",\n+            \"\/modules\/java.base\/java\/lang\/StackFrameInfo.class\",\n+            \"\/modules\/java.base\/java\/lang\/LiveStackFrame.class\",\n+            \"\/modules\/java.base\/java\/lang\/LiveStackFrameInfo.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractOwnableSynchronizer.class\",\n+            \"\/modules\/java.base\/java\/lang\/Boolean.class\",\n+            \"\/modules\/java.base\/java\/lang\/Character.class\",\n+            \"\/modules\/java.base\/java\/lang\/Number.class\",\n+            \"\/modules\/java.base\/java\/lang\/Float.class\",\n+            \"\/modules\/java.base\/java\/lang\/Double.class\",\n+            \"\/modules\/java.base\/java\/lang\/Byte.class\",\n+            \"\/modules\/java.base\/java\/lang\/Short.class\",\n+            \"\/modules\/java.base\/java\/lang\/Integer.class\",\n+            \"\/modules\/java.base\/java\/lang\/Long.class\",\n+            \"\/modules\/java.base\/java\/lang\/Void.class\",\n+            \"\/modules\/java.base\/java\/util\/Iterator.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/RecordComponent.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$Vector.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorMask.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/FillerObject.class\",\n+            \"\/modules\/java.base\/java\/lang\/NullPointerException.class\",\n+            \"\/modules\/java.base\/java\/lang\/ArithmeticException.class\",\n+            \"\/modules\/java.base\/java\/lang\/IndexOutOfBoundsException.class\",\n+            \"\/modules\/java.base\/java\/lang\/ArrayIndexOutOfBoundsException.class\",\n+            \"\/modules\/java.base\/java\/io\/ObjectStreamField.class\",\n+            \"\/modules\/java.base\/java\/util\/Comparator.class\",\n+            \"\/modules\/java.base\/java\/lang\/String$CaseInsensitiveComparator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/VM.class\",\n+            \"\/modules\/java.base\/java\/lang\/Module$ArchivedData.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/CDS.class\",\n+            \"\/modules\/java.base\/java\/util\/Set.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableCollection.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableSet.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$Set12.class\",\n+            \"\/modules\/java.base\/java\/util\/Objects.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableList.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$ListN.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$SetN.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableMap.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$MapN.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangReflectAccess.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/ReflectAccess.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/SharedSecrets.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/ReflectionFactory.class\",\n+            \"\/modules\/java.base\/java\/io\/ObjectStreamClass.class\",\n+            \"\/modules\/java.base\/java\/lang\/Math.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/ReflectionFactory$Config.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangRefAccess.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue$Null.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue$Lock.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangAccess.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/SystemProps.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/SystemProps$Raw.class\",\n+            \"\/modules\/java.base\/java\/nio\/charset\/Charset.class\",\n+            \"\/modules\/java.base\/java\/nio\/charset\/spi\/CharsetProvider.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/StandardCharsets.class\",\n+            \"\/modules\/java.base\/java\/lang\/StringLatin1.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/HistoricallyNamedCharset.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/Unicode.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_8.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap.class\",\n+            \"\/modules\/java.base\/java\/lang\/StrictMath.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/ArraysSupport.class\",\n+            \"\/modules\/java.base\/java\/util\/Map$Entry.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$Node.class\",\n+            \"\/modules\/java.base\/java\/util\/LinkedHashMap$Entry.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$TreeNode.class\",\n+            \"\/modules\/java.base\/java\/lang\/StringConcatHelper.class\",\n+            \"\/modules\/java.base\/java\/lang\/VersionProps.class\",\n+            \"\/modules\/java.base\/java\/lang\/Runtime.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/Lock.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Segment.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$CounterCell.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Node.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/LockSupport.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ReservationNode.class\",\n+            \"\/modules\/java.base\/java\/util\/AbstractSet.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$EntrySet.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$HashIterator.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$EntryIterator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/StaticProperty.class\",\n+            \"\/modules\/java.base\/java\/io\/FileInputStream.class\",\n+            \"\/modules\/java.base\/java\/lang\/System$In.class\",\n+            \"\/modules\/java.base\/java\/io\/FileDescriptor.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.class\",\n+            \"\/modules\/java.base\/java\/io\/Flushable.class\",\n+            \"\/modules\/java.base\/java\/io\/OutputStream.class\",\n+            \"\/modules\/java.base\/java\/io\/FileOutputStream.class\",\n+            \"\/modules\/java.base\/java\/lang\/System$Out.class\",\n+            \"\/modules\/java.base\/java\/io\/FilterInputStream.class\",\n+            \"\/modules\/java.base\/java\/io\/BufferedInputStream.class\",\n+            \"\/modules\/java.base\/java\/io\/FilterOutputStream.class\",\n+            \"\/modules\/java.base\/java\/io\/PrintStream.class\",\n+            \"\/modules\/java.base\/java\/io\/BufferedOutputStream.class\",\n+            \"\/modules\/java.base\/java\/io\/Writer.class\",\n+            \"\/modules\/java.base\/java\/io\/OutputStreamWriter.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/StreamEncoder.class\",\n+            \"\/modules\/java.base\/java\/nio\/charset\/CharsetEncoder.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_8$Encoder.class\",\n+            \"\/modules\/java.base\/java\/nio\/charset\/CodingErrorAction.class\",\n+            \"\/modules\/java.base\/java\/util\/Arrays.class\",\n+            \"\/modules\/java.base\/java\/nio\/ByteBuffer.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/ScopedMemoryAccess.class\",\n+            \"\/modules\/java.base\/java\/util\/function\/Function.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/Preconditions.class\",\n+            \"\/modules\/java.base\/java\/util\/function\/BiFunction.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaNioAccess.class\",\n+            \"\/modules\/java.base\/java\/nio\/HeapByteBuffer.class\",\n+            \"\/modules\/java.base\/java\/nio\/ByteOrder.class\",\n+            \"\/modules\/java.base\/java\/io\/BufferedWriter.class\",\n+            \"\/modules\/java.base\/java\/lang\/Terminator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/Signal$Handler.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/Signal.class\",\n+            \"\/modules\/java.base\/java\/util\/Hashtable$Entry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/Signal$NativeHandler.class\",\n+            \"\/modules\/java.base\/java\/lang\/Integer$IntegerCache.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/OSEnvironment.class\",\n+            \"\/modules\/java.base\/java\/lang\/Thread$State.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/Reference$ReferenceHandler.class\",\n+            \"\/modules\/java.base\/java\/lang\/Thread$ThreadIdentifiers.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/Finalizer$FinalizerThread.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/Cleaner.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections$EmptySet.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections$EmptyList.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections$EmptyMap.class\",\n+            \"\/modules\/java.base\/java\/lang\/IllegalArgumentException.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleStatics.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/ClassFileFormatVersion.class\",\n+            \"\/modules\/java.base\/java\/lang\/CharacterData.class\",\n+            \"\/modules\/java.base\/java\/lang\/CharacterDataLatin1.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/ClassFileDumper.class\",\n+            \"\/modules\/java.base\/java\/util\/HexFormat.class\",\n+            \"\/modules\/java.base\/java\/lang\/Character$CharacterCache.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/atomic\/AtomicInteger.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MemberName$Factory.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/Reflection.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles$Lookup.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$MapN$MapNIterator.class\",\n+            \"\/modules\/java.base\/java\/util\/KeyValueHolder.class\",\n+            \"\/modules\/java.base\/sun\/invoke\/util\/VerifyAccess.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Modifier.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangModuleAccess.class\",\n+            \"\/modules\/java.base\/java\/io\/File.class\",\n+            \"\/modules\/java.base\/java\/io\/DefaultFileSystem.class\",\n+            \"\/modules\/java.base\/java\/io\/FileSystem.class\",\n+            \"\/modules\/java.base\/java\/io\/UnixFileSystem.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/DecimalDigits.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModulePatcher.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$IllegalNativeAccess.class\",\n+            \"\/modules\/java.base\/java\/util\/HashSet.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap$Modules.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$Counters.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ArchivedBootLayer.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ArchivedModuleGraph.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/SystemModuleFinders.class\",\n+            \"\/modules\/java.base\/java\/net\/URI.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaNetUriAccess.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/SystemModules.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ExplodedSystemModules.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/Watchable.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/Path.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/FileSystems.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/DefaultFileSystemProvider.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/spi\/FileSystemProvider.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/AbstractFileSystemProvider.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileSystemProvider.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/LinuxFileSystemProvider.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/OpenOption.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/StandardOpenOption.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/FileSystem.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileSystem.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/LinuxFileSystem.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixPath.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/Util.class\",\n+            \"\/modules\/java.base\/java\/lang\/StringCoding.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixNativeDispatcher.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/BootLoader.class\",\n+            \"\/modules\/java.base\/java\/lang\/Module$EnableNativeAccess.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaderHelper.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$CollectionView.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$KeySetView.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$LibraryPaths.class\",\n+            \"\/modules\/java.base\/java\/io\/File$PathStatus.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$CountedLock.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock$Sync.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock$NonfairSync.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$NativeLibraryContext.class\",\n+            \"\/modules\/java.base\/java\/util\/Queue.class\",\n+            \"\/modules\/java.base\/java\/util\/Deque.class\",\n+            \"\/modules\/java.base\/java\/util\/ArrayDeque.class\",\n+            \"\/modules\/java.base\/java\/util\/ArrayDeque$DeqIterator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibrary.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$NativeLibraryImpl.class\",\n+            \"\/modules\/java.base\/java\/security\/cert\/Certificate.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ValuesView.class\",\n+            \"\/modules\/java.base\/java\/util\/Enumeration.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Traverser.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$BaseIterator.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ValueIterator.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/BasicFileAttributes.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/PosixFileAttributes.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributes.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileStoreAttributes.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixMountEntry.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/CopyOption.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/LinkOption.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/Files.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffers.class\",\n+            \"\/modules\/java.base\/java\/lang\/ThreadLocal.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/CarrierThreadLocal.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/TerminatingThreadLocal.class\",\n+            \"\/modules\/java.base\/java\/lang\/ThreadLocal$ThreadLocalMap.class\",\n+            \"\/modules\/java.base\/java\/lang\/ThreadLocal$ThreadLocalMap$Entry.class\",\n+            \"\/modules\/java.base\/java\/util\/IdentityHashMap.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections$SetFromMap.class\",\n+            \"\/modules\/java.base\/java\/util\/IdentityHashMap$KeySet.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffer.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerFactory.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/ThreadFactory.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/Cleaner.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanableList.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanableList$Node.class\",\n+            \"\/modules\/java.base\/java\/lang\/ref\/Cleaner$Cleanable.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/PhantomCleanable.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanerCleanable.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/InnocuousThread.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffer$Deallocator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$PhantomCleanableRef.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleFinder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModulePath.class\",\n+            \"\/modules\/java.base\/java\/util\/jar\/Attributes$Name.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/Array.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/perf\/PerfCounter.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/perf\/Perf.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/DirectBuffer.class\",\n+            \"\/modules\/java.base\/java\/nio\/MappedByteBuffer.class\",\n+            \"\/modules\/java.base\/java\/nio\/DirectByteBuffer.class\",\n+            \"\/modules\/java.base\/java\/nio\/Bits.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/atomic\/AtomicLong.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/VM$BufferPool.class\",\n+            \"\/modules\/java.base\/java\/nio\/LongBuffer.class\",\n+            \"\/modules\/java.base\/java\/nio\/DirectLongBufferU.class\",\n+            \"\/modules\/java.base\/java\/util\/zip\/ZipConstants.class\",\n+            \"\/modules\/java.base\/java\/util\/zip\/ZipFile.class\",\n+            \"\/modules\/java.base\/java\/util\/jar\/JarFile.class\",\n+            \"\/modules\/java.base\/java\/util\/BitSet.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilZipFileAccess.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilJarAccess.class\",\n+            \"\/modules\/java.base\/java\/util\/jar\/JavaUtilJarAccessImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/Runtime$Version.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$List12.class\",\n+            \"\/modules\/java.base\/java\/util\/Optional.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/DosFileAttributes.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/AttributeView.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/FileAttributeView.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/BasicFileAttributeView.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/DosFileAttributeView.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/UserDefinedFileAttributeView.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributeViews.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/DynamicFileAttributeView.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/AbstractBasicFileAttributeView.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributeViews$Basic.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributes$UnixAsBasicFileAttributes.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/DirectoryStream$Filter.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/Files$AcceptAllFilter.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/DirectoryStream.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/SecureDirectoryStream.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixSecureDirectoryStream.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixDirectoryStream.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReadWriteLock.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$Sync.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$FairSync.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$ReadLock.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$WriteLock.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixDirectoryStream$UnixDirectoryIterator.class\",\n+            \"\/modules\/java.base\/java\/nio\/file\/attribute\/FileAttribute.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileModeAttribute.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixChannelFactory.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixChannelFactory$Flags.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections$EmptyIterator.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/Channel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/ReadableByteChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/WritableByteChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/ByteChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/SeekableByteChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/GatheringByteChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/ScatteringByteChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/InterruptibleChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/FileChannel.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/FileChannelImpl.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/NativeDispatcher.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/FileDispatcher.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/UnixFileDispatcherImpl.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/FileDispatcherImpl.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/IOUtil.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/Interruptible.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/NativeThreadSet.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/FileChannelImpl$Closer.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/Channels.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/Streams.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/SelChImpl.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/NetworkChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/SelectableChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/spi\/AbstractSelectableChannel.class\",\n+            \"\/modules\/java.base\/java\/nio\/channels\/SocketChannel.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/SocketChannelImpl.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/ChannelInputStream.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaMetafactory.class\",\n+            \"\/modules\/java.base\/java\/util\/function\/Supplier.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/ReferencedKeySet.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/ReferencedKeyMap.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/ReferenceKey.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/StrongReferenceKey.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodTypeForm.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/WeakReferenceKey.class\",\n+            \"\/modules\/java.base\/sun\/invoke\/util\/Wrapper.class\",\n+            \"\/modules\/java.base\/sun\/invoke\/util\/Wrapper$Format.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/ConstantDescs.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/ClassDesc.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/constant\/ArrayClassDescImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/constant\/ConstantUtils.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/DirectMethodHandleDesc$Kind.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/MethodTypeDesc.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/constant\/MethodTypeDescImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/MethodHandleDesc.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/DirectMethodHandleDesc.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/constant\/DirectMethodHandleDescImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/DynamicConstantDesc.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/constant\/PrimitiveClassDescImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/constant\/DynamicConstantDesc$AnonymousDynamicConstantDesc.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$NamedFunction.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Holder.class\",\n+            \"\/modules\/java.base\/sun\/invoke\/util\/ValueConversions.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/Invokers.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Kind.class\",\n+            \"\/modules\/java.base\/java\/lang\/NoSuchMethodException.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$BasicType.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/TypeKind.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Name.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Holder.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/InvokerBytecodeGenerator.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/AnnotationElement.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Annotation.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ConstantPool.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/PoolEntry.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/AnnotationConstantValueEntry.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/Utf8Entry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$Utf8EntryImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$Utf8EntryImpl$State.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AnnotationImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassFileElement.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Attribute.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassElement.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/MethodElement.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/FieldElement.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/Util$Writable.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractElement.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$UnboundRuntimeVisibleAnnotationsAttribute.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Attributes.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/AttributeMapper.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$RuntimeVisibleAnnotationsMapper.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/AttributeMapper$AttributeStability.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleImpl$Intrinsic.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/SplitConstantPool.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/BootstrapMethodEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/EntryMap.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/Util.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ClassEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractRefEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractNamedEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$ClassEntryImpl.class\",\n+            \"\/modules\/java.base\/java\/util\/function\/Consumer.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassFile.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassFileImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassFileBuilder.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AttributeHolder.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Superclass.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/SuperclassImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/attribute\/SourceFileAttribute.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$UnboundSourceFileAttribute.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$SourceFileMapper.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BoundAttribute.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/MethodBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/MethodInfo.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalMethodBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/NameAndTypeEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractRefsEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$NameAndTypeEntryImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/MemberRefEntry.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/FieldRefEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractMemberRefEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$FieldRefEntryImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/InvokerBytecodeGenerator$ClassData.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/CodeBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/LabelContext.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/CodeElement.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/PseudoInstruction.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/CharacterRange.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LocalVariable.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LocalVariableType.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder$DeferredLabel.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/BufWriter.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BufWriterImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Label.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LabelTarget.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/LabelImpl.class\",\n+            \"\/modules\/java.base\/sun\/invoke\/util\/VerifyType.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Opcode.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Opcode$Kind.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/MethodRefEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$MethodRefEntryImpl.class\",\n+            \"\/modules\/java.base\/sun\/invoke\/empty\/Empty.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$AdHocAttribute.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$CodeMapper.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/FieldBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalFieldBuilder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/CustomAttribute.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AnnotationReader.class\",\n+            \"\/modules\/java.base\/java\/util\/ListIterator.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$ListItr.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator$Frame.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator$Type.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper$CodeRange.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassHierarchyResolver.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$ClassLoadingClassHierarchyResolver.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$CachedClassHierarchyResolver.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassHierarchyResolver$ClassHierarchyInfo.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$ClassHierarchyInfoImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/ClassReader.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/ModifiedUtf.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles$Lookup$ClassDefiner.class\",\n+            \"\/modules\/java.base\/java\/lang\/IncompatibleClassChangeError.class\",\n+            \"\/modules\/java.base\/java\/lang\/NoSuchMethodError.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/BootstrapMethodInvoker.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/InnerClassLambdaMetafactory.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleInfo.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/InfoFromMemberName.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$Access.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilCollectionAccess.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/Interfaces.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/InterfacesImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/TypeConvertingMethodAdapter.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Constructor.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangInvokeAccess.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessMode.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessType.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/Invokers$Holder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo.class\",\n+            \"\/modules\/java.base\/java\/io\/DataInput.class\",\n+            \"\/modules\/java.base\/java\/io\/DataInputStream.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$CountingDataInput.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/NativeThread.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/Blocker.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/Util.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/Util$BufferCache.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ch\/IOStatus.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/util\/ByteArray.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandles.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsShorts$ByteArrayViewVarHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsShorts$ArrayHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleGuards.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarForm.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsChars$ByteArrayViewVarHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsChars$ArrayHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsInts$ByteArrayViewVarHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsInts$ArrayHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsFloats$ByteArrayViewVarHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsFloats$ArrayHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsLongs$ByteArrayViewVarHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsLongs$ArrayHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsDoubles$ByteArrayViewVarHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsDoubles$ArrayHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessDescriptor.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$Entry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$IndexEntry.class\",\n+            \"\/modules\/java.base\/java\/nio\/charset\/StandardCharsets.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/US_ASCII.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/ISO_8859_1.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16BE.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16LE.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32BE.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32LE.class\",\n+            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$ValueEntry.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Builder.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Modifier.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/AccessFlag.class\",\n+            \"\/modules\/java.base\/java\/lang\/reflect\/AccessFlag$Location.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Requires$Modifier.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Requires.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$KeySet.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$KeyIterator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/Checks.class\",\n+            \"\/modules\/java.base\/java\/util\/ArrayList$Itr.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Provides.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections$UnmodifiableCollection.class\",\n+            \"\/modules\/java.base\/java\/util\/Collections$UnmodifiableSet.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$Values.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$ValueIterator.class\",\n+            \"\/modules\/java.base\/java\/util\/ImmutableCollections$SetN$SetNIterator.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$Attributes.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleReferences.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleReader.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixUriUtils.class\",\n+            \"\/modules\/java.base\/java\/net\/URI$Parser.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleReference.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleReferenceImpl.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Exports.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Opens.class\",\n+            \"\/modules\/java.base\/sun\/nio\/fs\/UnixException.class\",\n+            \"\/modules\/java.base\/java\/io\/IOException.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/ArchivedClassLoaders.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$BootClassLoader.class\",\n+            \"\/modules\/java.base\/java\/lang\/ClassLoader$ParallelLoaders.class\",\n+            \"\/modules\/java.base\/java\/util\/WeakHashMap.class\",\n+            \"\/modules\/java.base\/java\/util\/WeakHashMap$Entry.class\",\n+            \"\/modules\/java.base\/java\/util\/WeakHashMap$KeySet.class\",\n+            \"\/modules\/java.base\/java\/security\/Principal.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath.class\",\n+            \"\/modules\/java.base\/java\/net\/URLStreamHandlerFactory.class\",\n+            \"\/modules\/java.base\/java\/net\/URL$DefaultFactory.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/access\/JavaNetURLAccess.class\",\n+            \"\/modules\/java.base\/sun\/net\/www\/ParseUtil.class\",\n+            \"\/modules\/java.base\/java\/net\/URLStreamHandler.class\",\n+            \"\/modules\/java.base\/sun\/net\/www\/protocol\/file\/Handler.class\",\n+            \"\/modules\/java.base\/sun\/net\/util\/IPAddressUtil.class\",\n+            \"\/modules\/java.base\/sun\/net\/util\/IPAddressUtil$MASKS.class\",\n+            \"\/modules\/java.base\/sun\/net\/www\/protocol\/jar\/Handler.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ServicesCatalog.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/AbstractClassLoaderValue.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaderValue.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/BuiltinClassLoader$LoadedModule.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/DefaultRoots.class\",\n+            \"\/modules\/java.base\/java\/util\/Spliterator.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$HashMapSpliterator.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$ValueSpliterator.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/StreamSupport.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/BaseStream.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/Stream.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/PipelineHelper.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/AbstractPipeline.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline$Head.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag$Type.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag$MaskBuilder.class\",\n+            \"\/modules\/java.base\/java\/util\/EnumMap.class\",\n+            \"\/modules\/java.base\/java\/lang\/Class$ReflectionData.class\",\n+            \"\/modules\/java.base\/java\/lang\/Class$Atomic.class\",\n+            \"\/modules\/java.base\/java\/lang\/PublicMethods$MethodList.class\",\n+            \"\/modules\/java.base\/java\/lang\/PublicMethods$Key.class\",\n+            \"\/modules\/java.base\/sun\/reflect\/annotation\/AnnotationParser.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodHandleAccessorFactory$LazyStaticHolder.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Specializer.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/annotation\/Stable.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer$SpeciesData.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$SpeciesData.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer$Factory.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Specializer$Factory.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/SimpleMethodHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/NoSuchFieldException.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Accessor.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle$Holder.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor$TransformKey.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormBuffer.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor$Transform.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/reflect\/DirectMethodHandleAccessor.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/Collectors.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/Collector$Characteristics.class\",\n+            \"\/modules\/java.base\/java\/util\/EnumSet.class\",\n+            \"\/modules\/java.base\/java\/util\/RegularEnumSet.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/Collector.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/Collectors$CollectorImpl.class\",\n+            \"\/modules\/java.base\/java\/util\/function\/BiConsumer.class\",\n+            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Interface.class\",\n+            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/InterfaceMethodRefEntry.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$InterfaceMethodRefEntryImpl.class\",\n+            \"\/modules\/java.base\/java\/util\/function\/BinaryOperator.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/TerminalOp.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$ReduceOp.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/StreamShape.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/Sink.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/TerminalSink.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$AccumulatingSink.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$Box.class\",\n+            \"\/modules\/java.base\/java\/util\/HashMap$KeySpliterator.class\",\n+            \"\/modules\/java.base\/java\/util\/function\/Predicate.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline$StatelessOp.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/Sink$ChainedReference.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleResolution.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/FindOps.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindSink.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindSink$OfRef.class\",\n+            \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindOp.class\",\n+            \"\/modules\/java.base\/java\/util\/Spliterators.class\",\n+            \"\/modules\/java.base\/java\/util\/Spliterators$IteratorSpliterator.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/Configuration.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/Resolver.class\",\n+            \"\/modules\/java.base\/java\/lang\/ModuleLayer.class\",\n+            \"\/modules\/java.base\/java\/util\/SequencedSet.class\",\n+            \"\/modules\/java.base\/java\/util\/LinkedHashSet.class\",\n+            \"\/modules\/java.base\/java\/util\/SequencedMap.class\",\n+            \"\/modules\/java.base\/java\/util\/LinkedHashMap.class\",\n+            \"\/modules\/java.base\/java\/lang\/module\/ResolvedModule.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap$Mapper.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/AbstractClassLoaderValue$Memoizer.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ServicesCatalog$ServiceProvider.class\",\n+            \"\/modules\/java.base\/java\/util\/concurrent\/CopyOnWriteArrayList.class\",\n+            \"\/modules\/java.base\/java\/lang\/ModuleLayer$Controller.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$SafeModuleFinder.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/ContinuationSupport.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/vm\/Continuation$Pinned.class\",\n+            \"\/modules\/java.base\/sun\/launcher\/LauncherHelper.class\",\n+            \"\/modules\/java.base\/sun\/net\/util\/URLUtil.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath$Loader.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath$FileLoader.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/loader\/Resource.class\",\n+            \"\/modules\/java.base\/java\/io\/FileCleanable.class\",\n+            \"\/modules\/java.base\/sun\/nio\/ByteBuffered.class\",\n+            \"\/modules\/java.base\/java\/security\/SecureClassLoader$CodeSourceKey.class\",\n+            \"\/modules\/java.base\/java\/security\/PermissionCollection.class\",\n+            \"\/modules\/java.base\/java\/security\/Permissions.class\",\n+            \"\/modules\/java.base\/java\/lang\/NamedPackage.class\",\n+            \"\/modules\/java.base\/jdk\/internal\/misc\/MethodFinder.class\",\n+            \"\/modules\/java.base\/java\/lang\/Readable.class\",\n+            \"\/modules\/java.base\/java\/nio\/CharBuffer.class\",\n+            \"\/modules\/java.base\/java\/nio\/HeapCharBuffer.class\",\n+            \"\/modules\/java.base\/java\/nio\/charset\/CoderResult.class\",\n+            \"\/modules\/java.base\/java\/util\/IdentityHashMap$IdentityHashMapIterator.class\",\n+            \"\/modules\/java.base\/java\/util\/IdentityHashMap$KeyIterator.class\",\n+            \"\/modules\/java.base\/java\/lang\/Shutdown.class\",\n+            \"\/modules\/java.base\/java\/lang\/Shutdown$Lock.class\");\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":1072,"deletions":0,"binary":false,"changes":1072,"status":"added"}]}