{"files":[{"patch":"@@ -51,1 +51,0 @@\n-import java.lang.classfile.Opcode;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal;\n-\n-import java.io.InputStream;\n-\n-\/\/ Purpose of this class is NOT to create a cryptographically\n-\/\/ strong random number. but to quickly generate a value hard to guess\n-\/\/ without the need to load classes or have an impact on security\n-\/\/ related events, like SecureRandom::getAlgorithm(\"NativePRNGNonBlocking\") does\n-public final class EventWriterKey {\n-    private static final long KEY = createKey();\n-    private static boolean loaded;\n-    private static boolean logged;\n-\n-    public static long getKey() {\n-        return KEY;\n-    }\n-\n-    private static long createKey() {\n-        long r = mixMurmur64(System.identityHashCode(new Object()));\n-        r = 31 * r + mixMurmur64(JVM.getPid().hashCode());\n-        r = 31 * r + mixMurmur64(System.nanoTime());\n-        r = 31 * r + mixMurmur64(Thread.currentThread().threadId());\n-        r = 31 * r + mixMurmur64(System.currentTimeMillis());\n-        r = 31 * r + mixMurmur64(JVM.getTypeId(JVM.class));\n-        r = 31 * r + mixMurmur64(JVM.counterTime());\n-        return mixMurmur64(r);\n-    }\n-\n-    \/\/ Copied from jdk.internal.util.random.RandomSupport.mixMurmur64(long)\n-    private static long mixMurmur64(long z) {\n-        z = (z ^ (z >>> 33)) * 0xff51afd7ed558ccdL;\n-        z = (z ^ (z >>> 33)) * 0xc4ceb9fe1a85ec53L;\n-        return z ^ (z >>> 33);\n-    }\n-\n-    public static void ensureEventWriterFactory() {\n-        if (loaded) {\n-            return;\n-        }\n-        String name = \"\/jdk\/jfr\/internal\/EventWriterFactoryRecipe.class\";\n-        try (InputStream is = EventWriterKey.class.getResourceAsStream(name)) {\n-            byte[] bytes = is.readAllBytes();\n-            bytes = replace(bytes,\n-                    \"jdk\/jfr\/internal\/EventWriterFactoryRecipe\",\n-                    \"jdk\/jfr\/internal\/event\/EventWriterFactory\");\n-            Class<?> c = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n-            SecuritySupport.defineClass(c, bytes);\n-            loaded = true;\n-        } catch (Throwable e) {\n-           throw new InternalError(\"Could not read bytecode for \" + name, e);\n-        }\n-        Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"EventWriterFactory created\");\n-    }\n-\n-    \/\/ Starve the system of resources to prevent further attempts.\n-    \/\/ Note, code that have the capability to invoke this method\n-    \/\/ could spin in a loop anyway. Alternatives, such as System.exit(1),\n-    \/\/ may provide caller with additional capabilities.\n-    public static void block() {\n-        \/\/ Making this field variable a local variable leads to CTW failure\n-        logged = false;\n-        while (true) {\n-            try {\n-                if (!logged) {\n-                    \/\/ Only log once to prevent flooding of log.\n-                    logged = true;\n-                    \/\/ Purposely don't call Thread::getName() since it can be overridden\n-                    Logger.log(LogTag.JFR, LogLevel.ERROR, \"Malicious attempt to access JFR buffers. Stopping thread from further execution.\");\n-                }\n-            } catch (Throwable t) {\n-                \/\/ Ensure code can't break out and retry\n-            }\n-        }\n-    }\n-\n-    private static byte[] replace(byte[] bytes, String match, String replacement) {\n-        if (match.length() != replacement.length()) {\n-            throw new IllegalArgumentException(\"Match must be same size as replacement\");\n-        }\n-        for (int i = 0; i < bytes.length - match.length(); i++) {\n-            if (match(bytes, i, match)) {\n-                for (int j = 0; j < replacement.length(); j++) {\n-                    bytes[i + j] = (byte) replacement.charAt(j);\n-                }\n-            }\n-        }\n-        return bytes;\n-    }\n-\n-    private static boolean match(byte[] bytes, int offset, String text) {\n-        for (int i = 0; i < text.length(); i++) {\n-            if (bytes[offset + i] != text.charAt(i)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterKey.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -131,1 +131,1 @@\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Unexpected error when adding instrumentation for event type \" + eventName);\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Unexpected error when adding instrumentation for event type \" + eventName + \". \" + t.getMessage());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                Logger.log(LogTag.JFR, LogLevel.DEBUG, \"Could not dump recording \" + recording.getName() + \" on exit.\");\n+                Logger.log(LogTag.JFR, LogLevel.DEBUG, \"Could not dump recording \" + recording.getName() + \" on exit. \" + e.getMessage());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -87,1 +86,0 @@\n-        @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBeanImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,1 +199,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}