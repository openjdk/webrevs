{"files":[{"patch":"@@ -615,2 +615,0 @@\n-  C->set_default_node_notes(caller_nn);\n-\n@@ -627,0 +625,4 @@\n+  \/\/ Only reset this now, to make sure that debug information emitted\n+  \/\/ for exiting control flow still refers to the inlined method.\n+  C->set_default_node_notes(caller_nn);\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -472,0 +472,5 @@\n+  GrowableArray<Node_Notes*>* old_node_note_array = C->node_note_array();\n+  if (old_node_note_array != NULL) {\n+    C->set_node_note_array(new (C->comp_arena()) GrowableArray<Node_Notes*> (C->comp_arena(), 8, 0, NULL));\n+  }\n+\n@@ -487,0 +492,5 @@\n+    if (old_node_note_array != NULL) {\n+      Node_Notes* nn = C->locate_node_notes(old_node_note_array, n->_idx, false);\n+      C->set_node_notes_at(current_idx, nn);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8201516\n+ * @summary Verify that debug information in C2 compiled code is correct.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestDebugInfo\n+ *\/\n+public class TestDebugInfo {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\");\n+    }\n+\n+    static class MyClass {\n+        final int val;\n+\n+        @ForceInline\n+        public MyClass(int val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        synchronized void synchronizedMethod(boolean throwIt) {\n+            if (throwIt) {\n+                throw new RuntimeException(); \/\/ Make sure there is an exception state\n+            }\n+        }\n+    }\n+\n+    static Object[] array = new Object[3];\n+    static MyClass myVal = new MyClass(42);\n+\n+    \/\/ Verify that the MemBarRelease emitted at the MyClass constructor exit\n+    \/\/ does not incorrectly reference the caller method in its debug information.\n+    @Test\n+    @IR(failOn = {\"MemBarRelease.*testFinalFieldInit.*bci:-1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    public static void testFinalFieldInit() {\n+        array[0] = new MyClass(42);\n+        array[1] = new MyClass(42);\n+        array[2] = new MyClass(42);\n+    }\n+\n+    \/\/ Verify that the MemBarReleaseLock emitted at the synchronizedMethod exit\n+    \/\/ does not incorrectly reference the caller method in its debug information.\n+    @Test\n+    @IR(failOn = {\"MemBarReleaseLock.*testSynchronized.*bci:-1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    public static void testSynchronized() {\n+        try {\n+            myVal.synchronizedMethod(false);\n+            myVal.synchronizedMethod(true);\n+        } catch (Exception e) {\n+            \/\/ Ignore\n+        }\n+    }\n+\n+    static byte b0 = 0;\n+    static byte b1 = 0;\n+    static byte b2 = 0;\n+    static byte b3 = 0;\n+\n+    @ForceInline\n+    public static Integer useless3(Integer val) {\n+        return ++val;\n+    }\n+\n+    @ForceInline\n+    public static Integer useless2(Integer val) {\n+        return useless3(useless3(useless3(useless3(useless3(useless3(useless3(useless3(val))))))));\n+    }\n+\n+    @ForceInline\n+    public static Integer useless1(Integer val) {\n+        return useless2(useless2(useless2(useless2(useless2(useless2(useless2(useless2(val))))))));\n+    }\n+\n+    @ForceInline\n+    public static void useful3() {\n+        b3 = 3;\n+    }\n+\n+    @ForceInline\n+    public static void useful2() {\n+        useful3();\n+        b2 = 2;\n+    }\n+\n+    @ForceInline\n+    public static void useful1() {\n+        useful2();\n+        b1 = 1;\n+    }\n+\n+    \/\/ Verify that RenumberLiveNodes preserves the debug information side table.\n+    @Test\n+    @IR(counts = {\"StoreB.*name=b3.*useful3.*bci:1.*useful2.*bci:0.*useful1.*bci:0.*testRenumberLiveNodes.*bci:9\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {\"StoreB.*name=b2.*useful2.*bci:4.*useful1.*bci:0.*testRenumberLiveNodes.*bci:9\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {\"StoreB.*name=b1.*useful1.*bci:4.*testRenumberLiveNodes.*bci:9\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {\"StoreB.*name=b0.*testRenumberLiveNodes.*bci:13\", \"= 1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    public static void testRenumberLiveNodes() {\n+        \/\/ This generates ~3700 useless nodes to trigger RenumberLiveNodes\n+        useless1(42);\n+\n+        \/\/ Do something useful\n+        useful1();\n+        b0 = 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDebugInfo.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}