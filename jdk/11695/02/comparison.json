{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.io.Writer;\n@@ -38,0 +39,1 @@\n+import java.nio.charset.Charset;\n@@ -833,1 +835,2 @@\n-            inputBytes = null;\n+            pendingBytes = null;\n+            pendingLine = null;\n@@ -964,2 +967,4 @@\n-    private byte[] inputBytes;\n-    private int inputBytesPointer;\n+    private String pendingLine;\n+    private int pendingLinePointer;\n+    private byte[] pendingBytes;\n+    private int pendingBytesPointer;\n@@ -969,20 +974,22 @@\n-        while (inputBytes == null || inputBytes.length <= inputBytesPointer) {\n-            History prevHistory = in.getHistory();\n-            boolean prevDisableCr = Display.DISABLE_CR;\n-            Parser prevParser = in.getParser();\n-\n-            try {\n-                in.setParser((line, cursor, context) -> new ArgumentLine(line, cursor));\n-                input.setState(State.WAIT);\n-                Display.DISABLE_CR = true;\n-                in.setHistory(userInputHistory);\n-                inputBytes = (in.readLine(\"\") + System.getProperty(\"line.separator\")).getBytes();\n-                inputBytesPointer = 0;\n-            } catch (UserInterruptException ex) {\n-                throw new InterruptedIOException();\n-            } finally {\n-                in.setParser(prevParser);\n-                in.setHistory(prevHistory);\n-                input.setState(State.BUFFER);\n-                Display.DISABLE_CR = prevDisableCr;\n-            }\n+        if (pendingBytes == null || pendingBytes.length <= pendingBytesPointer) {\n+            char userChar = readUserInputChar();\n+            pendingBytes = String.valueOf(userChar).getBytes();\n+            pendingBytesPointer = 0;\n+        }\n+        return pendingBytes[pendingBytesPointer++];\n+    }\n+\n+    @Override\n+    public synchronized char readUserInputChar() throws IOException {\n+        while (pendingLine == null || pendingLine.length() <= pendingLinePointer) {\n+            pendingLine = doReadUserLine(\"\", null) + System.getProperty(\"line.separator\");\n+            pendingLinePointer = 0;\n+        }\n+        return pendingLine.charAt(pendingLinePointer++);\n+    }\n+\n+    @Override\n+    public synchronized String readUserLine(String prompt) throws IOException {\n+        \/\/TODO: correct behavior w.r.t. pre-read stuff?\n+        if (pendingLine != null && pendingLine.length() > pendingLinePointer) {\n+            return pendingLine.substring(pendingLinePointer);\n@@ -990,1 +997,37 @@\n-        return inputBytes[inputBytesPointer++];\n+        return doReadUserLine(prompt, null);\n+    }\n+\n+    private synchronized String doReadUserLine(String prompt, Character mask) throws IOException {\n+        History prevHistory = in.getHistory();\n+        boolean prevDisableCr = Display.DISABLE_CR;\n+        Parser prevParser = in.getParser();\n+\n+        try {\n+            in.setParser((line, cursor, context) -> new ArgumentLine(line, cursor));\n+            input.setState(State.WAIT);\n+            Display.DISABLE_CR = true;\n+            in.setHistory(userInputHistory);\n+            return in.readLine(prompt, mask);\n+        } catch (UserInterruptException ex) {\n+            throw new InterruptedIOException();\n+        } finally {\n+            in.setParser(prevParser);\n+            in.setHistory(prevHistory);\n+            input.setState(State.BUFFER);\n+            Display.DISABLE_CR = prevDisableCr;\n+        }\n+    }\n+\n+    public char[] readPassword(String prompt) throws IOException {\n+        \/\/TODO: correct behavior w.r.t. pre-read stuff?\n+        return doReadUserLine(prompt, '\\0').toCharArray();\n+    }\n+\n+    @Override\n+    public Charset charset() {\n+        return in.getTerminal().encoding();\n+    }\n+\n+    @Override\n+    public Writer userOutput() {\n+        return in.getTerminal().writer();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":67,"deletions":24,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import jdk.internal.org.jline.reader.UserInterruptException;\n@@ -59,0 +62,16 @@\n+    public char readUserInputChar() throws IOException {\n+        throw new UserInterruptException(\"\");\n+    }\n+\n+    public String readUserLine(String prompt) throws IOException {\n+        throw new UserInterruptException(\"\");\n+    }\n+\n+    public Writer userOutput() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public char[] readPassword(String prompt) throws IOException {\n+        throw new UserInterruptException(\"\");\n+    }\n+\n@@ -61,0 +80,4 @@\n+    public Charset charset() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/IOContext.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.IOError;\n@@ -38,0 +39,1 @@\n+import java.io.PrintWriter;\n@@ -40,0 +42,1 @@\n+import java.io.Writer;\n@@ -120,0 +123,1 @@\n+import jdk.internal.org.jline.reader.UserInterruptException;\n@@ -134,0 +138,1 @@\n+import jdk.jshell.JShellConsole;\n@@ -1096,0 +1101,1 @@\n+                .console(new IOContextConsole())\n@@ -4034,0 +4040,78 @@\n+\n+    private final class IOContextConsole implements JShellConsole {\n+\n+        private Reader reader;\n+        private PrintWriter writer;\n+\n+        @Override\n+        public synchronized PrintWriter writer() {\n+            if (writer == null) {\n+                writer = new PrintWriter(new Writer() {\n+                    @Override\n+                    public void write(char[] cbuf, int off, int len) throws IOException {\n+                        input.userOutput().write(cbuf, off, len);\n+                    }\n+                    @Override\n+                    public void flush() throws IOException {\n+                        input.userOutput().flush();\n+                    }\n+                    @Override\n+                    public void close() throws IOException {\n+                        input.userOutput().close();\n+                    }\n+                });\n+            }\n+            return writer;\n+        }\n+\n+        @Override\n+        public synchronized Reader reader() {\n+            if (reader == null) {\n+                reader = new Reader() {\n+                    @Override\n+                    public int read(char[] cbuf, int off, int len) throws IOException {\n+                        if (len == 0) return 0;\n+                        try {\n+                            cbuf[off] = input.readUserInputChar();\n+                            return 1;\n+                        } catch (UserInterruptException ex) {\n+                            return -1;\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void close() throws IOException {\n+                    }\n+                };\n+            }\n+            return reader;\n+        }\n+\n+        @Override\n+        public String readLine(String prompt) {\n+            try {\n+                return input.readUserLine(prompt);\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n+        @Override\n+        public char[] readPassword(String prompt) {\n+            try {\n+                return input.readPassword(prompt);\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n+        @Override\n+        public void flush() {\n+            writer().flush();\n+        }\n+\n+        @Override\n+        public Charset charset() {\n+            return input.charset();\n+        }\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Optional;\n@@ -95,0 +96,1 @@\n+    final Optional<JShellConsole> console;\n@@ -119,0 +121,1 @@\n+        this.console = Optional.ofNullable(b.console);\n@@ -173,0 +176,1 @@\n+        JShellConsole console = null;\n@@ -241,0 +245,16 @@\n+        \/**\n+         * Sets the console for the running evalution.\n+         * <p>\n+         * The default, if this is not set, is no console ({@code System.console()}\n+         * will return {@code null} while running a snippet).\n+         *\n+         * @param console console to use while a snippet is run\n+         * @return the {@code Builder} instance (for use in chained\n+         * initialization)\n+         * @since 21\n+         *\/\n+        public Builder console(JShellConsole console) {\n+            this.console = console;\n+            return this;\n+        }\n+\n@@ -798,0 +818,5 @@\n+        @Override\n+        public Optional<JShellConsole> console() {\n+            return console;\n+        }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/JShell.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jshell;\n+\n+import java.io.IOError;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+\n+\/**\n+ * An interface providing functionality for {@link java.io.Console} in the user's snippet.\n+ * <p>\n+ * When a snippet calls a method on {@code Console}, the corresponding method in this interface will\n+ * be called.\n+ *\n+ * @since 21\n+ * @see java.io.Console\n+ *\/\n+public interface JShellConsole {\n+\n+    \/**\n+     * Retrieves the unique {@link java.io.PrintWriter PrintWriter} object\n+     * associated with this console.\n+     *\n+     * @return  The printwriter associated with this console\n+     * @see java.io.Console#writer()\n+     *\/\n+    public PrintWriter writer();\n+\n+    \/**\n+     * Retrieves the unique {@link java.io.Reader Reader} object associated\n+     * with this console.\n+     *\n+     * @return  The reader associated with this console\n+     * @see java.io.Console#reader()\n+     *\/\n+    public Reader reader();\n+\n+    \/**\n+     * Provides a prompt, then reads a single line of text from the\n+     * console.\n+     *\n+     * @param  prompt\n+     *         A prompt.\n+     *\n+     * @throws IOError\n+     *         If an I\/O error occurs.\n+     *\n+     * @return  A string containing the line read from the console, not\n+     *          including any line-termination characters, or {@code null}\n+     *          if an end of stream has been reached.\n+     * @see java.io.Console#readLine()\n+     *\/\n+    public String readLine(String prompt) throws IOError;\n+\n+    \/**\n+     * Provides a prompt, then reads a password or passphrase from\n+     * the console with echoing disabled.\n+     *\n+     * @param  prompt\n+     *         A prompt.\n+     *\n+     * @throws IOError\n+     *         If an I\/O error occurs.\n+     *\n+     * @return  A character array containing the password or passphrase read\n+     *          from the console, not including any line-termination characters,\n+     *          or {@code null} if an end of stream has been reached.\n+     * @see java.io.Console#readPassword()\n+     *\/\n+    public char[] readPassword(String prompt) throws IOError;\n+\n+    \/**\n+     * Flushes the console and forces any buffered output to be written\n+     * immediately.\n+     *\n+     * @see java.io.Console#flush()\n+     *\/\n+    public void flush();\n+\n+    \/**\n+     * Returns the {@link java.nio.charset.Charset Charset} object used for\n+     * the {@code Console}.\n+     *\n+     * @return a {@link java.nio.charset.Charset Charset} object used for the\n+     *          {@code Console}\n+     *\n+     * @see java.io.Console#charset()\n+     *\/\n+    public Charset charset();\n+\n+}\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/JShellConsole.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.Optional;\n@@ -52,0 +53,1 @@\n+import jdk.jshell.JShellConsole;\n@@ -55,0 +57,1 @@\n+import jdk.jshell.execution.impl.ConsoleImpl.ConsoleOutputStream;\n@@ -100,0 +103,2 @@\n+            Optional<JShellConsole> console = env.console();\n+            String consoleModule = console.isPresent() ? \"jdk.jshell\" : \"java.base\";\n@@ -103,1 +108,1 @@\n-                                  List.of(\"-Djdk.console=java.base\").stream())\n+                                  List.of(\"-Djdk.console=\" + consoleModule).stream())\n@@ -130,0 +135,9 @@\n+            if (console.isPresent()) {\n+                if (!RemoteExecutionControl.class.getName().equals(remoteAgent)) {\n+                    throw new IllegalArgumentException(\"JShellConsole is only supported for \" +\n+                                                       \"the default remote agent!\");\n+                }\n+                ConsoleOutputStream consoleOutput = new ConsoleOutputStream(console.get());\n+                outputs.put(\"consoleInput\", consoleOutput);\n+                input.put(\"consoleOutput\", consoleOutput.sinkInput);\n+            }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import jdk.jshell.execution.impl.ConsoleImpl;\n+import jdk.jshell.execution.impl.ConsoleImpl.ConsoleProviderImpl;\n@@ -68,0 +70,1 @@\n+        outputs.put(\"consoleInput\", st -> ConsoleProviderImpl.setRemoteInput(st));\n@@ -70,0 +73,1 @@\n+        input.put(\"consoleOutput\", in -> ConsoleProviderImpl.setRemoteOutput(in));\n@@ -116,1 +120,5 @@\n-        return super.invoke(doitMethod);\n+        try {\n+            return super.invoke(doitMethod);\n+        } finally {\n+            ConsoleImpl.ensureOutputAreWritten();\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/RemoteExecutionControl.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.jshell.execution.impl.PipeInputStream;\n@@ -108,0 +109,1 @@\n+                private boolean inputNeeded;\n@@ -109,2 +111,4 @@\n-                    inputSignal.write('1');\n-                    inputSignal.flush();\n+                    if (inputNeeded) {\n+                        inputSignal.write('1');\n+                        inputSignal.flush();\n+                    }\n@@ -114,15 +118,21 @@\n-                    int tag = super.read();\n-                    switch (tag) {\n-                        case TAG_DATA: return super.read();\n-                        case TAG_CLOSED: close(); return -1;\n-                        case TAG_EXCEPTION:\n-                            int len = (super.read() << 0) + (super.read() << 8) + (super.read() << 16) + (super.read() << 24);\n-                            byte[] message = new byte[len];\n-                            for (int i = 0; i < len; i++) {\n-                                message[i] = (byte) super.read();\n-                            }\n-                            throw new IOException(new String(message, UTF_8));\n-                        case -1:\n-                            return -1;\n-                        default:\n-                            throw new IOException(\"Internal error: unrecognized message tag: \" + tag);\n+                    inputNeeded = true;\n+                    try {\n+                        int tag = super.read();\n+                        inputNeeded = false;\n+                        switch (tag) {\n+                            case TAG_DATA: return super.read();\n+                            case TAG_CLOSED: close(); return -1;\n+                            case TAG_EXCEPTION:\n+                                int len = (super.read() << 0) + (super.read() << 8) + (super.read() << 16) + (super.read() << 24);\n+                                byte[] message = new byte[len];\n+                                for (int i = 0; i < len; i++) {\n+                                    message[i] = (byte) super.read();\n+                                }\n+                                throw new IOException(new String(message, UTF_8));\n+                            case -1:\n+                                return -1;\n+                            default:\n+                                throw new IOException(\"Internal error: unrecognized message tag: \" + tag);\n+                        }\n+                    } finally {\n+                        inputNeeded = false;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/Util.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,445 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jshell.execution.impl;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOError;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import jdk.internal.io.JdkConsole;\n+import jdk.internal.io.JdkConsoleProvider;\n+import jdk.jshell.JShellConsole;\n+\n+\/**\n+ *\n+ *\/\n+public class ConsoleImpl {\n+\n+    public static void ensureOutputAreWritten() {\n+        var console = ConsoleProviderImpl.console;\n+\n+        if (console != null) {\n+            console.ensureOutputAreWritten();\n+        }\n+    }\n+\n+    public static class ConsoleProviderImpl implements JdkConsoleProvider {\n+\n+        public ConsoleProviderImpl() {\n+        }\n+\n+        private static InputStream remoteOutput;\n+        private static OutputStream remoteInput;\n+        private static RemoteConsole console;\n+\n+        @Override\n+        public JdkConsole console(boolean isTTY, Charset charset) {\n+            synchronized (ConsoleProviderImpl.class) {\n+                if (remoteOutput != null && remoteInput != null) {\n+                    return console = new RemoteConsole(remoteOutput, remoteInput);\n+                }\n+                return null;\n+            }\n+        }\n+\n+        public static synchronized void setRemoteOutput(InputStream remoteOutput) {\n+            ConsoleProviderImpl.remoteOutput = remoteOutput;\n+        }\n+\n+        public static synchronized void setRemoteInput(OutputStream remoteInput) {\n+            ConsoleProviderImpl.remoteInput =\n+                    new BufferedOutputStream(remoteInput);\n+        }\n+\n+    }\n+\n+    private static final class RemoteConsole implements JdkConsole {\n+        private final InputStream remoteOutput;\n+        private final OutputStream remoteInput;\n+        private PrintWriter writer;\n+        private Reader reader;\n+\n+        public RemoteConsole(InputStream remoteOutput, OutputStream remoteInput) {\n+            this.remoteInput = new BufferedOutputStream(remoteInput);\n+            this.remoteOutput = new InputStream() {\n+                @Override\n+                public int read() throws IOException {\n+                    RemoteConsole.this.remoteInput.flush();\n+                    return remoteOutput.read();\n+                }\n+            };\n+        }\n+\n+        private void sendChars(char[] data, int off, int len) throws IOException {\n+            ConsoleImpl.sendChars(remoteInput, data, off, len);\n+        }\n+\n+        private int readChars(char[] data, int off, int len) throws IOException {\n+            sendInt(len);\n+            int actualLen = readInt();\n+            for (int i = 0; i < actualLen; i++) {\n+                data[off + i] = (char) ((remoteOutput.read() <<  8) |\n+                                        (remoteOutput.read() <<  0));\n+            }\n+            return actualLen;\n+        }\n+\n+        private char[] readChars() throws IOException {\n+            int actualLen = readInt();\n+            char[] result = new char[actualLen];\n+            for (int i = 0; i < actualLen; i++) {\n+                result[i] = (char) ((remoteOutput.read() <<  8) |\n+                                    (remoteOutput.read() <<  0));\n+            }\n+            return result;\n+        }\n+\n+        private void sendInt(int data) throws IOException {\n+            ConsoleImpl.sendInt(remoteInput, data);\n+        }\n+\n+        private int readInt() throws IOException {\n+            return (remoteOutput.read() << 24) |\n+                   (remoteOutput.read() << 16) |\n+                   (remoteOutput.read() <<  8) |\n+                   (remoteOutput.read() <<  0);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public synchronized PrintWriter writer() {\n+            if (writer == null) {\n+                writer = new PrintWriter(new Writer() {\n+                    int i;\n+                    @Override\n+                    public void write(char[] cbuf, int off, int len) throws IOException {\n+                        sendAndReceive(() -> {\n+                            remoteInput.write(Task.WRITE_CHARS.ordinal());\n+                            sendChars(cbuf, off, len);\n+                            return null;\n+                        });\n+                    }\n+\n+                    @Override\n+                    public void flush() throws IOException {\n+                        sendAndReceive(() -> {\n+                            remoteInput.write(Task.FLUSH_OUTPUT.ordinal());\n+                            remoteOutput.read();\n+                            return null;\n+                        });\n+                    }\n+\n+                    @Override\n+                    public void close() throws IOException {\n+                    }\n+                });\n+            }\n+            return writer;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public synchronized Reader reader() {\n+            if (reader == null) {\n+                reader = new Reader() {\n+                    @Override\n+                    public int read(char[] cbuf, int off, int len) throws IOException {\n+                        return sendAndReceive(() -> {\n+                            remoteInput.write(Task.READ_CHARS.ordinal());\n+                            return readChars(cbuf, off, len);\n+                        });\n+                    }\n+\n+                    @Override\n+                    public void close() throws IOException {\n+                    }\n+                };\n+            } return reader;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public JdkConsole format(String fmt, Object ...args) {\n+            writer().format(fmt, args).flush();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public JdkConsole printf(String format, Object ... args) {\n+            return format(format, args);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public String readLine(String fmt, Object ... args) {\n+            try {\n+                return sendAndReceive(() -> {\n+                    remoteInput.write(Task.READ_LINE.ordinal());\n+                    String prompt = fmt.formatted(args);\n+                    char[] chars = prompt.toCharArray();\n+                    sendChars(chars, 0, chars.length);\n+                    char[] line = readChars();\n+                    return new String(line);\n+                });\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public String readLine() {\n+            return readLine(\"\");\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public char[] readPassword(String fmt, Object ... args) {\n+            try {\n+                return sendAndReceive(() -> {\n+                    remoteInput.write(Task.READ_PASSWORD.ordinal());\n+                    String prompt = fmt.formatted(args);\n+                    char[] chars = prompt.toCharArray();\n+                    sendChars(chars, 0, chars.length);\n+                    return readChars();\n+                });\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public char[] readPassword() {\n+            return readPassword(\"\");\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public void flush() {\n+            try {\n+                sendAndReceive(() -> {\n+                    remoteInput.write(Task.FLUSH_CONSOLE.ordinal());\n+                    remoteOutput.read();\n+                    return null;\n+                });\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n+        @Override\n+        public Charset charset() {\n+            try {\n+                return sendAndReceive(() -> {\n+                    remoteInput.write(Task.CHARSET.ordinal());\n+                    return Charset.forName(new String(readChars()));\n+                });\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n+        void ensureOutputAreWritten() {\n+            try {\n+                sendAndReceive(() -> {\n+                    remoteInput.write(Task.ENSURE_OUTPUTS_ARE_WRITTEN.ordinal());\n+                    return remoteOutput.read();\n+                });\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n+        private synchronized <R, E extends Exception> R sendAndReceive(SendAndReceive<R, E> task) throws IOException, E {\n+            return task.run();\n+        }\n+\n+        interface SendAndReceive<R, E extends Exception> {\n+            R run() throws E;\n+        }\n+\n+    }\n+\n+    public static final class ConsoleOutputStream extends OutputStream {\n+\n+        int[] buffer = new int[1024];\n+        int bp;\n+        final JShellConsole console;\n+        public final InputStream sinkInput;\n+        final OutputStream sinkOutput;\n+\n+        public ConsoleOutputStream(JShellConsole console) {\n+            this.console = console;\n+            PipeInputStream sinkInput = new PipeInputStream();\n+            this.sinkInput = sinkInput;\n+            this.sinkOutput = sinkInput.createOutput();\n+        }\n+\n+        @Override\n+        public synchronized void write(int b) throws IOException {\n+            if (bp + 1 >= buffer.length) {\n+                buffer = Arrays.copyOf(buffer, 2 * buffer.length);\n+            }\n+\n+            buffer[bp++] = b;\n+\n+            switch (Task.values()[buffer[0]]) {\n+                case WRITE_CHARS -> {\n+                    char[] data = readCharsOrNull(1);\n+                    if (data != null) {\n+                        console.writer().write(data);\n+                        bp = 0;\n+                    }\n+                }\n+                case FLUSH_OUTPUT -> {\n+                    console.writer().flush();\n+                    sinkOutput.write(0);\n+                    bp = 0;\n+                }\n+                case READ_CHARS -> {\n+                    if (bp >= 5) {\n+                        int len = readInt(b);\n+                        int c = console.reader().read();\n+                        \/\/XXX: EOF handling!\n+                        sendChars(sinkOutput, new char[] {(char) c}, 0, 1);\n+                        bp = 0;\n+                    }\n+                }\n+                case READ_LINE -> {\n+                    char[] data = readCharsOrNull(1);\n+                    if (data != null) {\n+                        String line = console.readLine(new String(data));\n+                        char[] chars = line.toCharArray();\n+                        sendChars(sinkOutput, chars, 0, chars.length);\n+                        bp = 0;\n+                    }\n+                }\n+                case READ_PASSWORD -> {\n+                    char[] data = readCharsOrNull(1);\n+                    if (data != null) {\n+                        char[] chars = console.readPassword(new String(data));\n+                        sendChars(sinkOutput, chars, 0, chars.length);\n+                        bp = 0;\n+                    }\n+                }\n+                case FLUSH_CONSOLE -> {\n+                    console.flush();\n+                    sinkOutput.write(0);\n+                    bp = 0;\n+                }\n+                case CHARSET -> {\n+                    char[] name = console.charset().name().toCharArray();\n+                    sendChars(sinkOutput, name, 0, name.length);\n+                    bp = 0;\n+                }\n+                case ENSURE_OUTPUTS_ARE_WRITTEN -> {\n+                    sinkOutput.write(0);\n+                    bp = 0;\n+                }\n+            }\n+        }\n+\n+        private int readInt(int pos) throws IOException {\n+            return (buffer[pos + 0] << 24) |\n+                   (buffer[pos + 1] << 16) |\n+                   (buffer[pos + 2] <<  8) |\n+                   (buffer[pos + 3] <<  0);\n+        }\n+\n+        private char readChar(int pos) throws IOException {\n+            return (char) ((buffer[pos] << 8) |\n+                    (buffer[pos + 1] << 0));\n+        }\n+\n+        private char[] readCharsOrNull(int pos) throws IOException {\n+            if (bp >= pos + 4) {\n+                int len = readInt(pos);\n+                if (bp >= pos + 4 + 2 * len) {\n+                    char[] result = new char[len];\n+                    for (int i = 0; i < len; i++) {\n+                        result[i] = readChar(pos + 4 + 2 * i);\n+                    }\n+                    return result;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static void sendChars(OutputStream remoteInput, char[] data, int off, int len) throws IOException {\n+        sendInt(remoteInput, len);\n+        for (int i = 0; i < len; i++) {\n+            char c = data[off + i];\n+\n+            remoteInput.write((c >> 8) & 0xFF);\n+            remoteInput.write((c >> 0) & 0xFF);\n+        }\n+    }\n+\n+    private static void sendInt(OutputStream remoteInput, int data) throws IOException {\n+        remoteInput.write((data >> 24) & 0xFF);\n+        remoteInput.write((data >> 16) & 0xFF);\n+        remoteInput.write((data >>  8) & 0xFF);\n+        remoteInput.write((data >>  0) & 0xFF);\n+    }\n+\n+    private enum Task {\n+        WRITE_CHARS,\n+        FLUSH_OUTPUT,\n+        READ_CHARS,\n+        READ_LINE,\n+        READ_PASSWORD,\n+        FLUSH_CONSOLE,\n+        CHARSET,\n+        ENSURE_OUTPUTS_ARE_WRITTEN,\n+        ;\n+    }\n+}\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/impl\/ConsoleImpl.java","additions":445,"deletions":0,"binary":false,"changes":445,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package jdk.jshell.execution;\n+package jdk.jshell.execution.impl;\n@@ -35,1 +35,1 @@\n-class PipeInputStream extends InputStream {\n+public class PipeInputStream extends InputStream {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/impl\/PipeInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/PipeInputStream.java","status":"renamed"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.Optional;\n+import jdk.jshell.JShellConsole;\n@@ -80,0 +82,16 @@\n+    \/**\n+     * Returns the {@code JShellConsole} that should be used\n+     * by the execution engine, or {@code null} if none.\n+     * <p>\n+     * Note: an execution engine may not support {@code JShellConsole}.\n+     *\n+     * @implSpec The default implementation of this method\n+     *           return an empty {@code Optional}.\n+     *\n+     * @return returns console, or an empty {@code Optional} if none,\n+     *         never {@code null}\n+     * @since 21\n+     *\/\n+    default Optional<JShellConsole> console() {\n+        return Optional.empty();\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/spi\/ExecutionEnv.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+    provides jdk.internal.io.JdkConsoleProvider with jdk.jshell.execution.impl.ConsoleImpl.ConsoleProviderImpl;\n","filename":"src\/jdk.jshell\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,13 @@\n+import java.io.IOError;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import jdk.jshell.JShell;\n+import jdk.jshell.JShellConsole;\n@@ -34,0 +47,1 @@\n+import static org.testng.Assert.*;\n@@ -39,1 +53,71 @@\n-        assertEval(\"System.console()\", \"null\");\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public Charset charset() {\n+                return StandardCharsets.US_ASCII;\n+            }\n+        };\n+        assertEval(\"System.console().charset().name()\", \"\\\"US-ASCII\\\"\");\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public String readLine(String prompt) throws IOError {\n+                assertEquals(prompt, \"expected\");\n+                return \"AB\";\n+            }\n+        };\n+        assertEval(\"System.console().readLine(\\\"expected\\\")\", \"\\\"AB\\\"\");\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public char[] readPassword(String prompt) throws IOError {\n+                assertEquals(prompt, \"expected\");\n+                return \"AB\".toCharArray();\n+            }\n+        };\n+        assertEval(\"new String(System.console().readPassword(\\\"expected\\\"))\", \"\\\"AB\\\"\");\n+        console = new ThrowingJShellConsole() {\n+            Reader reader = new StringReader(\"AB\");\n+            @Override\n+            public Reader reader() {\n+                return reader;\n+            }\n+        };\n+        assertEval(\"System.console().reader().read()\", \"65\");\n+        assertEval(\"System.console().reader().read()\", \"66\");\n+        AtomicBoolean flushed = new AtomicBoolean();\n+        flushed.set(false);\n+        StringWriter output = new StringWriter() {\n+            @Override\n+            public void flush() {\n+                flushed.set(true);\n+            }\n+        };\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public PrintWriter writer() {\n+                return new PrintWriter(output);\n+            }\n+        };\n+        assertEval(\"System.console().writer().write(65)\");\n+        assertEquals(\"A\", output.toString());\n+        assertEval(\"System.console().writer().print(\\\"out\\\")\");\n+        assertEquals(\"Aout\", output.toString());\n+        assertFalse(flushed.get());\n+        assertEval(\"System.console().writer().flush()\");\n+        assertTrue(flushed.get());\n+        flushed.set(false);\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public void flush() {\n+                flushed.set(true);\n+            }\n+        };\n+        assertEval(\"System.console().flush()\");\n+        assertTrue(flushed.get());\n+        \/\/double check the receive queue is cleared for flush:\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public String readLine(String prompt) throws IOError {\n+                assertEquals(prompt, \"expected\");\n+                return \"AB\";\n+            }\n+        };\n+        assertEval(\"System.console().readLine(\\\"expected\\\")\", \"\\\"AB\\\"\");\n@@ -42,0 +126,118 @@\n+    @Test\n+    public void testConsoleLargeWritingTest() {\n+        StringBuilder sb = new StringBuilder();\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public PrintWriter writer() {\n+                return new PrintWriter(new Writer() {\n+                    @Override\n+                    public void write(char[] cbuf, int off, int len) throws IOException {\n+                        sb.append(cbuf, off, len);\n+                    }\n+                    @Override\n+                    public void flush() throws IOException {}\n+                    @Override\n+                    public void close() throws IOException {}\n+                });\n+            }\n+        };\n+        int count = 1_000;\n+        assertEval(\"for (int i = 0; i < \" + count + \"; i++) System.console().writer().write(\\\"A\\\");\");\n+        String expected = \"A\".repeat(count);\n+        assertEquals(sb.toString(), expected);\n+    }\n+\n+    @Test\n+    public void testConsoleMultiThreading() {\n+        StringBuilder sb = new StringBuilder();\n+        console = new ThrowingJShellConsole() {\n+            @Override\n+            public PrintWriter writer() {\n+                return new PrintWriter(new Writer() {\n+                    @Override\n+                    public void write(char[] cbuf, int off, int len) throws IOException {\n+                        sb.append(cbuf, off, len);\n+                    }\n+                    @Override\n+                    public void flush() throws IOException {}\n+                    @Override\n+                    public void close() throws IOException {}\n+                });\n+            }\n+        };\n+        int repeats = 100;\n+        int output = 100;\n+        assertEval(\"\"\"\n+                   try (var b = java.util.concurrent.Executors.newCachedThreadPool()) {\n+                       for (int i = 0; i < ${repeats}; i++) {\n+                           b.execute(() -> {\n+                               for (int j = 0; j < ${output}; j++) {\n+                                   System.console().writer().write(\"A\");\n+                               }\n+                           });\n+                       }\n+                   }\n+                   \"\"\".replace(\"${repeats}\", \"\" + repeats)\n+                      .replace(\"${output}\", \"\" + output));\n+        String expected = \"A\".repeat(repeats * output);\n+        assertEquals(sb.toString(), expected);\n+    }\n+\n+    @Override\n+    public void setUp(Consumer<JShell.Builder> bc) {\n+        super.setUp(bc.andThen(b -> b.console(new JShellConsole() {\n+            @Override\n+            public PrintWriter writer() {\n+                return console.writer();\n+            }\n+            @Override\n+            public Reader reader() {\n+                return console.reader();\n+            }\n+            @Override\n+            public String readLine(String prompt) throws IOError {\n+                return console.readLine(prompt);\n+            }\n+            @Override\n+            public char[] readPassword(String prompt) throws IOError {\n+                return console.readPassword(prompt);\n+            }\n+            @Override\n+            public void flush() {\n+                console.flush();\n+            }\n+            @Override\n+            public Charset charset() {\n+                return console.charset();\n+            }\n+        })));\n+    }\n+\n+    private JShellConsole console = new ThrowingJShellConsole();\n+\n+    private static class ThrowingJShellConsole implements JShellConsole {\n+        @Override\n+        public PrintWriter writer() {\n+            throw new IllegalStateException(\"Not expected!\");\n+        }\n+        @Override\n+        public Reader reader() {\n+            throw new IllegalStateException(\"Not expected!\");\n+        }\n+        @Override\n+        public String readLine(String prompt) throws IOError {\n+            throw new IllegalStateException(\"Not expected!\");\n+        }\n+        @Override\n+        public char[] readPassword(String prompt) throws IOError {\n+            throw new IllegalStateException(\"Not expected!\");\n+        }\n+        @Override\n+        public void flush() {\n+            throw new IllegalStateException(\"Not expected!\");\n+        }\n+        @Override\n+        public Charset charset() {\n+            throw new IllegalStateException(\"Not expected!\");\n+        }\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ConsoleTest.java","additions":204,"deletions":2,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *          jdk.jshell\/jdk.jshell.execution:open\n+ *          jdk.jshell\/jdk.jshell.execution.impl:open\n@@ -62,1 +62,1 @@\n-        Class<?> pipeStreamClass = Class.forName(\"jdk.jshell.execution.PipeInputStream\");\n+        Class<?> pipeStreamClass = Class.forName(\"jdk.jshell.execution.impl.PipeInputStream\");\n","filename":"test\/langtools\/jdk\/jshell\/PipeInputStreamTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,0 +101,4 @@\n+\n+    public void testNoConsole() {\n+        assertEval(\"System.console()\", \"null\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/UserInputTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}