{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-        return t.inheritableThreadLocals;\n+        return t.inheritableThreadLocals();\n@@ -94,1 +94,1 @@\n-        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);\n+        t.setInheritableThreadLocals(new ThreadLocalMap(this, firstValue));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/InheritableThreadLocal.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2257,4 +2257,0 @@\n-            public boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local) {\n-                return ((ThreadLocal<?>)local).isCarrierThreadLocalPresent();\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-    \/\/ All fields, except task, are accessed directly by the VM.\n+    \/\/ All fields, except task and terminatingThreadLocals, are accessed directly by the VM.\n@@ -247,0 +247,3 @@\n+        \/\/ This map is maintained by the ThreadLocal class\n+        ThreadLocal.ThreadLocalMap terminatingThreadLocals;\n+\n@@ -262,0 +265,8 @@\n+    ThreadLocal.ThreadLocalMap terminatingThreadLocals() {\n+        return holder.terminatingThreadLocals;\n+    }\n+\n+    void setTerminatingThreadLocals(ThreadLocal.ThreadLocalMap map) {\n+        holder.terminatingThreadLocals = map;\n+    }\n+\n@@ -266,1 +277,9 @@\n-    ThreadLocal.ThreadLocalMap threadLocals;\n+    private ThreadLocal.ThreadLocalMap threadLocals;\n+\n+    ThreadLocal.ThreadLocalMap threadLocals() {\n+        return threadLocals;\n+    }\n+\n+    void setThreadLocals(ThreadLocal.ThreadLocalMap map) {\n+        threadLocals = map;\n+    }\n@@ -272,1 +291,9 @@\n-    ThreadLocal.ThreadLocalMap inheritableThreadLocals;\n+    private ThreadLocal.ThreadLocalMap inheritableThreadLocals;\n+\n+    ThreadLocal.ThreadLocalMap inheritableThreadLocals() {\n+        return inheritableThreadLocals;\n+    }\n+\n+    void setInheritableThreadLocals(ThreadLocal.ThreadLocalMap map) {\n+        inheritableThreadLocals = map;\n+    }\n@@ -1495,1 +1522,1 @@\n-            if (threadLocals != null && TerminatingThreadLocal.REGISTRY.isPresent()) {\n+            if (terminatingThreadLocals() != null) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,21 +196,0 @@\n-    \/**\n-     * Returns {@code true} if there is a value in the current carrier thread's copy of\n-     * this thread-local variable, even if that values is {@code null}.\n-     *\n-     * @return {@code true} if current carrier thread has associated value in this\n-     *         thread-local variable; {@code false} if not\n-     *\/\n-    boolean isCarrierThreadLocalPresent() {\n-        assert this instanceof CarrierThreadLocal<T>;\n-        return isPresent(Thread.currentCarrierThread());\n-    }\n-\n-    private boolean isPresent(Thread t) {\n-        ThreadLocalMap map = getMap(t);\n-        if (map != null) {\n-            return map.getEntry(this) != null;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n@@ -305,1 +284,5 @@\n-        return t.threadLocals;\n+        if (this instanceof TerminatingThreadLocal<T>) {\n+            return t.terminatingThreadLocals();\n+        } else {\n+            return t.threadLocals();\n+        }\n@@ -316,1 +299,6 @@\n-        t.threadLocals = new ThreadLocalMap(this, firstValue);\n+        var map = new ThreadLocalMap(this, firstValue);\n+        if (this instanceof TerminatingThreadLocal<T>) {\n+            t.setTerminatingThreadLocals(map);\n+        } else {\n+            t.setThreadLocals(map);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadLocal.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -549,6 +549,0 @@\n-    \/**\n-     * Returns {@code true} if there is a value in the current carrier thread's copy of\n-     * thread-local, even if that values is {@code null}.\n-     *\/\n-    boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,4 +52,0 @@\n-    public boolean isPresent() {\n-        return JLA.isCarrierThreadLocalPresent(this);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CarrierThreadLocal.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,3 @@\n- * A per-carrier-thread-local variable that is notified when a thread terminates and\n- * it has been initialized in the terminating carrier thread or a virtual thread\n- * that had the terminating carrier thread as its carrier thread (even if it was\n- * initialized with a null value).\n+ * A platform thread-local variable that is notified when a platform thread terminates,\n+ * and it has been initialized in the terminating thread (or a mounted virtual thread in\n+ * the case of a carrier thread), and even if it was initialized with a null value.\n@@ -47,1 +46,0 @@\n-        super.remove();\n@@ -49,0 +47,1 @@\n+        super.remove();\n@@ -83,1 +82,3 @@\n-        REGISTRY.get().add(tl);\n+        if (tl != REGISTRY) {\n+            REGISTRY.get().add(tl);\n+        }\n@@ -96,2 +97,2 @@\n-     * a per-carrier-thread registry of TerminatingThreadLocal(s) that have been registered\n-     * but later not unregistered in a particular carrier-thread.\n+     * A per-platform-thread registry of TerminatingThreadLocal(s). The registry is\n+     * itself a TerminatingThreadLocal to keep it reachable until the thread terminates.\n@@ -99,2 +100,2 @@\n-    public static final CarrierThreadLocal<Collection<TerminatingThreadLocal<?>>> REGISTRY =\n-        new CarrierThreadLocal<>() {\n+    public static final TerminatingThreadLocal<Collection<TerminatingThreadLocal<?>>> REGISTRY =\n+        new TerminatingThreadLocal<>() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/TerminatingThreadLocal.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+                cache[0] = null;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOVecWrapper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.reflect.Field;\n@@ -34,0 +35,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -44,1 +46,1 @@\n- * @bug 8202788 8291897\n+ * @bug 8202788 8291897 8357637\n@@ -157,0 +159,47 @@\n+    \/**\n+     * Test TerminatingThreadLocal when thread locals are \"cleared\" by null'ing the\n+     * threadLocal field of the current Thread.\n+     *\/\n+    @Test\n+    public void testClearingThreadLocals() throws Throwable {\n+        var terminatedValues = new CopyOnWriteArrayList<Object>();\n+\n+        var tl = new ThreadLocal<String>();\n+        var ttl = new TerminatingThreadLocal<String>() {\n+            @Override\n+            protected void threadTerminated(String value) {\n+                terminatedValues.add(value);\n+            }\n+        };\n+        var throwableRef = new AtomicReference<Throwable>();\n+\n+        String tlValue = \"abc\";\n+        String ttlValue = \"xyz\";\n+\n+        Thread thread = Thread.ofPlatform().start(() -> {\n+            try {\n+                tl.set(tlValue);\n+                ttl.set(ttlValue);\n+\n+                assertEquals(tl.get(), tlValue);\n+                assertEquals(ttl.get(), ttlValue);\n+\n+                \/\/ set Thread.threadLocals to null\n+                Field f = Thread.class.getDeclaredField(\"threadLocals\");\n+                f.setAccessible(true);\n+                f.set(Thread.currentThread(), null);\n+\n+                assertNull(tl.get());\n+                assertEquals(ttl.get(), ttlValue);\n+            } catch (Throwable t) {\n+                throwableRef.set(t);\n+            }\n+        });\n+        thread.join();\n+        if (throwableRef.get() instanceof Throwable t) {\n+            throw t;\n+        }\n+\n+        assertEquals(terminatedValues, List.of(ttlValue));\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"}]}