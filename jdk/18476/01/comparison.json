{"files":[{"patch":"@@ -79,1 +79,2 @@\n-  0,  0,  0    \/\/ EVEX_NTUP\n+  1,   1,  1,  \/\/ EVEX_NOSCALE(0)\n+  0,  0,  0    \/\/ EVEX_ETUP\n@@ -297,5 +298,1 @@\n-  int enc = r->encoding();\n-  if (enc >= 8) {\n-    enc -= 8;\n-  }\n-  return enc;\n+  return r->encoding() & 7;\n@@ -441,0 +438,3 @@\n+    case EVEX_NOSCALE:\n+      break;\n+\n@@ -528,0 +528,3 @@\n+    case EVEX_NOSCALE:\n+      break;\n+\n@@ -549,0 +552,6 @@\n+bool Assembler::needs_rex2(Register reg1, Register reg2, Register reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+\n@@ -619,2 +628,1 @@\n-      if (disp == 0 && no_relocation &&\n-          base_enc != rbp->encoding() LP64_ONLY(&& base_enc != r13->encoding())) {\n+      if (disp == 0 && no_relocation && ((base_enc & 0x7) != 5)) {\n@@ -622,0 +630,1 @@\n+        \/\/ !(rbp | r13 | r21 | r29)\n@@ -638,1 +647,2 @@\n-    } else if (base_enc == rsp->encoding() LP64_ONLY(|| base_enc == r12->encoding())) {\n+    } else if ((base_enc & 0x7) == 4) {\n+      \/\/ rbp | r12 | r20 | r28\n@@ -660,3 +670,3 @@\n-      assert(base_enc != rsp->encoding() LP64_ONLY(&& base_enc != r12->encoding()), \"illegal addressing mode\");\n-      if (disp == 0 && no_relocation &&\n-          base_enc != rbp->encoding() LP64_ONLY(&& base_enc != r13->encoding())) {\n+      \/\/ !(rbp | r12 | r20 | r28) were handled above\n+      assert(((base_enc & 0x7) != 4), \"illegal addressing mode\");\n+      if (disp == 0 && no_relocation &&  ((base_enc & 0x7) != 5)) {\n@@ -664,0 +674,1 @@\n+        \/\/ !(rbp | r13 | r21 | r29)\n@@ -820,0 +831,7 @@\n+  case REX2:\n+    NOT_LP64(assert(false, \"64bit prefixes\"));\n+    if ((0xFF & *ip++) & REXBIT_W) {\n+      is_64bit = true;\n+    }\n+    goto again_after_prefix;\n+\n@@ -869,0 +887,8 @@\n+\n+    case REX2:\n+      NOT_LP64(assert(false, \"64bit prefix found\"));\n+      if ((0xFF & *ip++) & REXBIT_W) {\n+        is_64bit = true;\n+      }\n+      goto again_after_size_prefix2;\n+\n@@ -1157,0 +1183,1 @@\n+    case REX2:\n@@ -1283,0 +1310,27 @@\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding, int byte3) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int32(opcode_prefix, (unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF), byte3);\n+  } else {\n+    emit_int24((unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF), byte3);\n+  }\n+}\n+\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int24(opcode_prefix, (unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF));\n+  } else {\n+    emit_int16((unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF));\n+  }\n+}\n+\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int ocp_and_encoding) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int16(opcode_prefix, (unsigned char)byte1 | (ocp_and_encoding & 0xFF));\n+  } else {\n+    emit_int8((unsigned char)byte1 | (ocp_and_encoding & 0xFF));\n+  }\n+}\n+\n@@ -1605,2 +1659,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1613,1 +1667,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1620,4 +1675,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBC,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -1627,4 +1680,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBD,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -1634,2 +1685,2 @@\n-  int encode = prefix_and_encode(reg->encoding());\n-  emit_int16(0x0F, (0xC8 | encode));\n+  int encode = prefix_and_encode(reg->encoding(), false, true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xC8, encode);\n@@ -1640,2 +1691,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1648,1 +1699,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1656,2 +1708,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1665,1 +1717,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1673,2 +1726,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1681,1 +1734,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1745,4 +1799,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             0x40 | cc,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding(0x40 | cc, 0xC0, encode);\n@@ -1751,1 +1803,0 @@\n-\n@@ -1755,2 +1806,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (0x40 | cc));\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((0x40 | cc));\n@@ -1811,2 +1862,2 @@\n-  prefix(adr, reg);\n-  emit_int16(0x0F, (unsigned char)0xB1);\n+  prefix(adr, reg, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB1);\n@@ -1819,2 +1870,2 @@\n-  prefix(adr, reg);\n-  emit_int16(0x0F, (unsigned char)0xB1);\n+  prefix(adr, reg, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB1);\n@@ -1829,2 +1880,2 @@\n-  prefix(adr, reg, true);\n-  emit_int16(0x0F, (unsigned char)0xB0);\n+  prefix(adr, reg, true, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB0);\n@@ -1888,2 +1939,7 @@\n-  int8_t w = 0x01;\n-  Prefix p = Prefix_EMPTY;\n+  if (needs_rex2(crc, v)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ sizeInBytes == 8, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(crc->encoding(), 0, v->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16(sizeInBytes == 1 ? (unsigned char)0xF0 : (unsigned char)0xF1, (0xC0 | encode));\n+  } else {\n+    int8_t w = 0x01;\n+    Prefix p = Prefix_EMPTY;\n@@ -1891,27 +1947,33 @@\n-  emit_int8((unsigned char)0xF2);\n-  switch (sizeInBytes) {\n-  case 1:\n-    w = 0;\n-    break;\n-  case 2:\n-  case 4:\n-    break;\n-  LP64_ONLY(case 8:)\n-    \/\/ This instruction is not valid in 32 bits\n-    \/\/ Note:\n-    \/\/ http:\/\/www.intel.com\/content\/dam\/www\/public\/us\/en\/documents\/manuals\/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n-    \/\/\n-    \/\/ Page B - 72   Vol. 2C says\n-    \/\/ qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2\n-    \/\/ mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r \/ m\n-    \/\/                                                                            F0!!!\n-    \/\/ while 3 - 208 Vol. 2A\n-    \/\/ F2 REX.W 0F 38 F1 \/ r       CRC32 r64, r \/ m64             RM         Valid      N.E.Accumulate CRC32 on r \/ m64.\n-    \/\/\n-    \/\/ the 0 on a last bit is reserved for a different flavor of this instruction :\n-    \/\/ F2 REX.W 0F 38 F0 \/ r       CRC32 r64, r \/ m8              RM         Valid      N.E.Accumulate CRC32 on r \/ m8.\n-    p = REX_W;\n-    break;\n-  default:\n-    assert(0, \"Unsupported value for a sizeInBytes argument\");\n-    break;\n+    emit_int8((unsigned char)0xF2);\n+    switch (sizeInBytes) {\n+    case 1:\n+      w = 0;\n+      break;\n+    case 2:\n+    case 4:\n+      break;\n+    LP64_ONLY(case 8:)\n+      \/\/ This instruction is not valid in 32 bits\n+      \/\/ Note:\n+      \/\/ http:\/\/www.intel.com\/content\/dam\/www\/public\/us\/en\/documents\/manuals\/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n+      \/\/\n+      \/\/ Page B - 72   Vol. 2C says\n+      \/\/ qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2\n+      \/\/ mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r \/ m\n+      \/\/                                                                            F0!!!\n+      \/\/ while 3 - 208 Vol. 2A\n+      \/\/ F2 REX.W 0F 38 F1 \/ r       CRC32 r64, r \/ m64             RM         Valid      N.E.Accumulate CRC32 on r \/ m64.\n+      \/\/\n+      \/\/ the 0 on a last bit is reserved for a different flavor of this instruction :\n+      \/\/ F2 REX.W 0F 38 F0 \/ r       CRC32 r64, r \/ m8              RM         Valid      N.E.Accumulate CRC32 on r \/ m8.\n+      p = REX_W;\n+      break;\n+    default:\n+      assert(0, \"Unsupported value for a sizeInBytes argument\");\n+      break;\n+    }\n+    LP64_ONLY(prefix(crc, v, p);)\n+    emit_int32(0x0F,\n+               0x38,\n+               0xF0 | w,\n+               0xC0 | ((crc->encoding() & 0x7) << 3) | (v->encoding() & 7));\n@@ -1919,5 +1981,0 @@\n-  LP64_ONLY(prefix(crc, v, p);)\n-  emit_int32(0x0F,\n-             0x38,\n-             0xF0 | w,\n-             0xC0 | ((crc->encoding() & 0x7) << 3) | (v->encoding() & 7));\n@@ -1929,2 +1986,9 @@\n-  int8_t w = 0x01;\n-  Prefix p = Prefix_EMPTY;\n+  if (needs_rex2(crc, adr.base(), adr.index())) {\n+    InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ sizeInBytes == 8, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+    vex_prefix(adr, 0, crc->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+    emit_int8(sizeInBytes == 1 ? (unsigned char)0xF0 : (unsigned char)0xF1);\n+    emit_operand(crc, adr, 0);\n+  } else {\n+    int8_t w = 0x01;\n+    Prefix p = Prefix_EMPTY;\n@@ -1932,15 +1996,19 @@\n-  emit_int8((uint8_t)0xF2);\n-  switch (sizeInBytes) {\n-  case 1:\n-    w = 0;\n-    break;\n-  case 2:\n-  case 4:\n-    break;\n-  LP64_ONLY(case 8:)\n-    \/\/ This instruction is not valid in 32 bits\n-    p = REX_W;\n-    break;\n-  default:\n-    assert(0, \"Unsupported value for a sizeInBytes argument\");\n-    break;\n+    emit_int8((uint8_t)0xF2);\n+    switch (sizeInBytes) {\n+    case 1:\n+      w = 0;\n+      break;\n+    case 2:\n+    case 4:\n+      break;\n+    LP64_ONLY(case 8:)\n+      \/\/ This instruction is not valid in 32 bits\n+      p = REX_W;\n+      break;\n+    default:\n+      assert(0, \"Unsupported value for a sizeInBytes argument\");\n+      break;\n+    }\n+    LP64_ONLY(prefix(crc, adr, p);)\n+    emit_int24(0x0F, 0x38, (0xF0 | w));\n+    emit_operand(crc, adr, 0);\n@@ -1948,3 +2016,0 @@\n-  LP64_ONLY(prefix(crc, adr, p);)\n-  emit_int24(0x0F, 0x38, (0xF0 | w));\n-  emit_operand(crc, adr, 0);\n@@ -2052,1 +2117,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2069,1 +2134,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes, true);\n@@ -2086,1 +2151,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes, true);\n@@ -2389,4 +2454,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xAF,\n-             (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAF, 0xC0, encode);\n@@ -2421,2 +2484,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xAF);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xAF);\n@@ -2567,2 +2630,2 @@\n-    prefix(src);\n-    emit_int16(0x0F, (unsigned char)0xAE);\n+    prefix(src, true);\n+    emit_int8((unsigned char)0xAE);\n@@ -2595,2 +2658,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -2603,2 +2666,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBD);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBD);\n@@ -2696,2 +2759,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -2703,1 +2766,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2710,2 +2773,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes, true);\n@@ -2717,1 +2780,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2725,1 +2788,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2734,1 +2798,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2742,1 +2807,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2749,2 +2814,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2756,1 +2821,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2763,1 +2828,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2771,1 +2836,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2780,1 +2846,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2788,2 +2855,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2795,1 +2862,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -3076,1 +3143,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3553,1 +3620,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3560,1 +3627,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3566,2 +3633,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBE);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBE);\n@@ -3573,2 +3640,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBE, 0xC0, encode);\n@@ -3646,2 +3713,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBF);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBF);\n@@ -3652,2 +3719,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBF, 0xC0, encode);\n@@ -3724,2 +3791,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB6);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB6);\n@@ -3731,2 +3798,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0xB6, 0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB6, 0xC0, encode);\n@@ -3737,2 +3804,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB7);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB7);\n@@ -3743,2 +3810,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB7, 0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB7, 0xC0, encode);\n@@ -4760,1 +4827,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4777,1 +4844,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4784,1 +4851,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4801,1 +4868,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(),  nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4808,1 +4875,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -4825,1 +4892,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -4842,1 +4909,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4849,1 +4916,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -5252,2 +5319,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB8);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB8);\n@@ -5260,2 +5327,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB8, 0xC0, encode);\n@@ -5333,2 +5400,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5341,2 +5408,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x0D);\n+  prefix(src, true);\n+  emit_int8(0x0D);\n@@ -5349,2 +5416,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5357,2 +5424,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5365,2 +5432,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5373,2 +5440,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x0D);\n+  prefix(src, true);\n+  emit_int8(0x0D);\n@@ -5382,0 +5449,6 @@\n+void Assembler::prefix16(int prefix) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  emit_int8((prefix & 0xff00) >> 8);\n+  emit_int8(prefix & 0xff);\n+}\n+\n@@ -6019,2 +6092,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x90 | cc, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0x90 | cc, 0xC0, encode);\n@@ -6153,2 +6226,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int24(0x0F, (unsigned char)0xA5, (0xC0 | encode));\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA5, 0xC0, encode);\n@@ -6158,2 +6231,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA4, 0xC0, encode, imm8);\n@@ -6163,2 +6236,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int24(0x0F, (unsigned char)0xAD, (0xC0 | encode));\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAD, 0xC0, encode);\n@@ -6168,2 +6241,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAC, 0xC0, encode, imm8);\n@@ -6174,2 +6247,2 @@\n-  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA4, 0xC0, encode, imm8);\n@@ -6179,2 +6252,2 @@\n-  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAC, 0xC0, encode, imm8);\n@@ -6246,1 +6319,1 @@\n-void Assembler::stmxcsr( Address dst) {\n+void Assembler::stmxcsr(Address dst) {\n@@ -6257,2 +6330,2 @@\n-    prefix(dst);\n-    emit_int16(0x0F, (unsigned char)0xAE);\n+    prefix(dst, true);\n+    emit_int8((unsigned char)0xAE);\n@@ -6398,4 +6471,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBC,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -6408,2 +6479,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBC);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBC);\n@@ -6416,2 +6487,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -6424,2 +6495,2 @@\n-  prefixq(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBC);\n+  prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBC);\n@@ -6471,2 +6542,2 @@\n-  prefix(dst, src, true);\n-  emit_int16(0x0F, (unsigned char)0xC0);\n+  prefix(dst, src, true, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC0);\n@@ -6479,2 +6550,2 @@\n-  prefix(dst, src);\n-  emit_int16(0x0F, (unsigned char)0xC1);\n+  prefix(dst, src, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC1);\n@@ -6486,2 +6557,2 @@\n-  prefix(dst, src);\n-  emit_int16(0x0F, (unsigned char)0xC1);\n+  prefix(dst, src, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC1);\n@@ -10811,1 +10882,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -10820,1 +10891,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes , true);\n@@ -10829,1 +10900,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -10838,1 +10909,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -11598,1 +11669,2 @@\n-void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){\n+void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_b, bool evex_v,\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {\n@@ -11611,0 +11683,1 @@\n+  byte2 |= evex_b ? EEVEX_B : 0;\n@@ -11612,1 +11685,1 @@\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ of form {0F, 0F_38, 0F_3A, 0F_3C}\n@@ -11617,2 +11690,1 @@\n-  \/\/ p[10] is always 1\n-  byte3 |= EVEX_F;\n+  byte3 |= (eevex_x ? 0 : EEVEX_X);\n@@ -11645,0 +11717,1 @@\n+  bool is_extended = adr.base_needs_rex2() || adr.index_needs_rex2() || nds_enc >= 16 || xreg_enc >= 16;\n@@ -11654,1 +11727,0 @@\n-\n@@ -11660,1 +11732,1 @@\n-      if ((attributes->get_vector_len() != AVX_512bit) && (nds_enc < 16) && (xreg_enc < 16)) {\n+      if ((attributes->get_vector_len() != AVX_512bit) && !is_extended) {\n@@ -11671,1 +11743,1 @@\n-    assert(((nds_enc < 16 && xreg_enc < 16) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n+    assert((!is_extended || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n@@ -11685,0 +11757,2 @@\n+    bool eevex_x = adr.index_needs_rex2();\n+    bool evex_b = adr.base_needs_rex2();\n@@ -11686,1 +11760,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, eevex_x, nds_enc, pre, opc);\n@@ -11695,1 +11769,2 @@\n-int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {\n+int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n+  bool is_extended = dst_enc >= 16 || nds_enc >= 16 || src_enc >=16;\n@@ -11707,1 +11782,1 @@\n-          (dst_enc < 16) && (nds_enc < 16) && (src_enc < 16)) {\n+           !is_extended) {\n@@ -11724,1 +11799,1 @@\n-    assert(((dst_enc < 16 && nds_enc < 16 && src_enc < 16) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n+    assert(((!is_extended) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n@@ -11732,0 +11807,1 @@\n+    bool evex_b = (src_enc >= 16) && src_is_gpr;\n@@ -11733,1 +11809,1 @@\n-    vex_x = (src_enc >= 16);\n+    vex_x = (src_enc >= 16) && !src_is_gpr;\n@@ -11735,1 +11811,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, pre, opc);\n@@ -11747,1 +11823,0 @@\n-\n@@ -11761,1 +11836,1 @@\n-                                      VexOpcode opc, InstructionAttr *attributes) {\n+                                      VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n@@ -11766,1 +11841,1 @@\n-    return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes);\n+    return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, src_is_gpr);\n@@ -12261,2 +12336,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12268,2 +12343,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12275,2 +12350,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12282,2 +12357,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12289,2 +12364,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12297,1 +12372,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12306,1 +12382,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12315,1 +12392,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12324,1 +12402,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12332,2 +12411,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12340,1 +12419,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12348,2 +12428,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12356,1 +12436,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12364,2 +12445,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12372,1 +12453,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12380,2 +12462,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12388,1 +12470,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12396,2 +12479,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12404,1 +12487,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12412,2 +12496,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12420,1 +12504,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12724,0 +12809,29 @@\n+int Assembler::get_base_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_B4;\n+  if (enc & 8) bits |= REXBIT_B;\n+  return bits;\n+}\n+\n+int Assembler::get_index_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_X4;\n+  if (enc & 8) bits |= REXBIT_X;\n+  return bits;\n+}\n+\n+int Assembler::get_base_prefix_bits(Register base) {\n+  return base->is_valid() ? get_base_prefix_bits(base->encoding()) : 0;\n+}\n+\n+int Assembler::get_index_prefix_bits(Register index) {\n+  return index->is_valid() ? get_index_prefix_bits(index->encoding()) : 0;\n+}\n+\n+int Assembler::get_reg_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_R4;\n+  if (enc & 8) bits |= REXBIT_R;\n+  return bits;\n+}\n+\n@@ -12725,1 +12839,3 @@\n-  if (reg->encoding() >= 8) {\n+  if (reg->encoding() >= 16) {\n+    prefix16(WREX2 | get_base_prefix_bits(reg->encoding()));\n+  } else if (reg->encoding() >= 8) {\n@@ -12731,0 +12847,4 @@\n+  if ((p & WREX2) || src->encoding() >= 16 || dst->encoding() >= 16) {\n+    prefix_rex2(dst, src);\n+    return;\n+  }\n@@ -12743,0 +12863,7 @@\n+void Assembler::prefix_rex2(Register dst, Register src) {\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(src->encoding());\n+  bits |= get_reg_prefix_bits(dst->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n@@ -12744,0 +12871,3 @@\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || dst->encoding() >= 16) {\n+    prefix_rex2(dst, adr);\n+  }\n@@ -12764,1 +12894,15 @@\n-void Assembler::prefix(Address adr) {\n+void Assembler::prefix_rex2(Register dst, Address adr) {\n+  if (adr.index_needs_rex2()) {\n+    assert(false, \"prefix(Register dst, Address adr) does not support handling of an X\");\n+  }\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_reg_prefix_bits(dst->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+void Assembler::prefix(Address adr, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix_rex2(adr, is_map1);\n+    return;\n+  }\n@@ -12776,0 +12920,1 @@\n+  if (is_map1) emit_int8(0x0F);\n@@ -12778,1 +12923,12 @@\n-void Assembler::prefix(Address adr, Register reg, bool byteinst) {\n+void Assembler::prefix_rex2(Address adr, bool is_map1) {\n+  int bits = is_map1 ? REX2BIT_M0 : 0;\n+  bits |= get_base_prefix_bits(adr.base()->encoding());\n+  bits |= get_index_prefix_bits(adr.index());\n+  prefix16(WREX2 | bits);\n+}\n+\n+void Assembler::prefix(Address adr, Register reg, bool byteinst, bool is_map1) {\n+  if (reg->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix_rex2(adr, reg, byteinst, is_map1);\n+    return;\n+  }\n@@ -12808,0 +12964,9 @@\n+  if (is_map1) emit_int8(0x0F);\n+}\n+\n+void Assembler::prefix_rex2(Address adr, Register reg, bool byteinst, bool is_map1) {\n+  int bits = is_map1 ? REX2BIT_M0 : 0;\n+  bits |= get_base_prefix_bits(adr.base()->encoding());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(reg->encoding());\n+  prefix16(WREX2 | bits);\n@@ -12811,0 +12976,4 @@\n+  if (reg->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefixq_rex2(adr, reg);\n+    return;\n+  }\n@@ -12840,1 +13009,12 @@\n-int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {\n+void Assembler::prefix_rex2(Address adr, XMMRegister src) {\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+int Assembler::prefix_and_encode(int reg_enc, bool byteinst, bool is_map1) {\n+  if (reg_enc >= 16) {\n+    return prefix_and_encode_rex2(reg_enc, is_map1);\n+  }\n@@ -12847,1 +13027,2 @@\n-  return reg_enc;\n+  int opc_prefix = is_map1 ? 0x0F00 : 0;\n+  return opc_prefix | reg_enc;\n@@ -12850,1 +13031,9 @@\n-int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {\n+int Assembler::prefix_and_encode_rex2(int reg_enc, bool is_map1) {\n+  prefix16(WREX2 | (is_map1 ? REX2BIT_M0 : 0) | get_base_prefix_bits(reg_enc));\n+  return reg_enc & 0x7;\n+}\n+\n+int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1) {\n+  if (src_enc >= 16 || dst_enc >= 16) {\n+    return prefix_and_encode_rex2(dst_enc, src_enc, is_map1 ? REX2BIT_M0 : 0);\n+  }\n@@ -12867,0 +13056,11 @@\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+int Assembler::prefix_and_encode_rex2(int dst_enc, int src_enc, int init_bits) {\n+  int bits = init_bits;\n+  bits |= get_reg_prefix_bits(dst_enc);\n+  bits |= get_base_prefix_bits(src_enc);\n+  dst_enc &= 0x7;\n+  src_enc &= 0x7;\n+  prefix16(WREX2 | bits);\n@@ -12870,1 +13070,8 @@\n-int8_t Assembler::get_prefixq(Address adr) {\n+bool Assembler::prefix_is_rex2(int prefix) {\n+  return (prefix & 0xFF00) == WREX2;\n+}\n+\n+int Assembler::get_prefixq(Address adr, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    return get_prefixq_rex2(adr, is_map1);\n+  }\n@@ -12873,1 +13080,10 @@\n-  return prfx;\n+  return is_map1 ? (((int16_t)prfx) << 8) | 0x0F : (int16_t)prfx;\n+}\n+\n+int Assembler::get_prefixq_rex2(Address adr, bool is_map1) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  int bits = REXBIT_W;\n+  if (is_map1) bits |= REX2BIT_M0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  return WREX2 | bits;\n@@ -12876,1 +13092,4 @@\n-int8_t Assembler::get_prefixq(Address adr, Register src) {\n+int Assembler::get_prefixq(Address adr, Register src, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || src->encoding() >= 16) {\n+    return get_prefixq_rex2(adr, src, is_map1);\n+  }\n@@ -12912,1 +13131,11 @@\n-  return prfx;\n+  return is_map1 ? (((int16_t)prfx) << 8) | 0x0F : (int16_t)prfx;\n+}\n+\n+int Assembler::get_prefixq_rex2(Address adr, Register src, bool is_map1) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  int bits = REXBIT_W;\n+  if (is_map1) bits |= REX2BIT_M0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  return WREX2 | bits;\n@@ -12916,1 +13145,5 @@\n-  emit_int8(get_prefixq(adr));\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix16(get_prefixq_rex2(adr));\n+  } else {\n+    emit_int8(get_prefixq(adr));\n+  }\n@@ -12919,2 +13152,7 @@\n-void Assembler::prefixq(Address adr, Register src) {\n-  emit_int8(get_prefixq(adr, src));\n+void Assembler::prefixq(Address adr, Register src, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || src->encoding() >= 16) {\n+    prefix16(get_prefixq_rex2(adr, src, is_map1));\n+  } else {\n+    emit_int8(get_prefixq(adr, src));\n+    if (is_map1) emit_int8(0x0F);\n+  }\n@@ -12923,0 +13161,1 @@\n+\n@@ -12924,0 +13163,4 @@\n+  if (src->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefixq_rex2(adr, src);\n+    return;\n+  }\n@@ -12955,1 +13198,12 @@\n-int Assembler::prefixq_and_encode(int reg_enc) {\n+void Assembler::prefixq_rex2(Address adr, XMMRegister src) {\n+  int bits = REXBIT_W;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+int Assembler::prefixq_and_encode(int reg_enc, bool is_map1) {\n+  if (reg_enc >= 16) {\n+    return prefixq_and_encode_rex2(reg_enc, is_map1);\n+  }\n@@ -12962,1 +13216,8 @@\n-  return reg_enc;\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | reg_enc;\n+}\n+\n+\n+int Assembler::prefixq_and_encode_rex2(int reg_enc, bool is_map1) {\n+  prefix16(WREX2 | REXBIT_W | (is_map1 ? REX2BIT_M0: 0) | get_base_prefix_bits(reg_enc));\n+  return reg_enc & 0x7;\n@@ -12965,1 +13226,4 @@\n-int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {\n+int Assembler::prefixq_and_encode(int dst_enc, int src_enc, bool is_map1) {\n+  if (dst_enc >= 16 || src_enc >= 16) {\n+    return prefixq_and_encode_rex2(dst_enc, src_enc, is_map1);\n+  }\n@@ -12982,1 +13246,15 @@\n-  return dst_enc << 3 | src_enc;\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+int Assembler::prefixq_and_encode_rex2(int dst_enc, int src_enc, bool is_map1) {\n+  int init_bits = REXBIT_W | (is_map1 ? REX2BIT_M0 : 0);\n+  return prefix_and_encode_rex2(dst_enc, src_enc, init_bits);\n+}\n+\n+void Assembler::emit_prefix_and_int8(int prefix, int b1) {\n+  if ((prefix & 0xFF00) == 0) {\n+    emit_int16(prefix, b1);\n+  } else {\n+    emit_int24((prefix & 0xFF00) >> 8, prefix & 0x00FF, b1);\n+  }\n@@ -12992,1 +13270,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x13);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x13);\n@@ -13009,1 +13287,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x01);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x01);\n@@ -13020,1 +13298,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x03);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x03);\n@@ -13031,6 +13309,12 @@\n-  emit_int8(0x66);\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int32(0x0F,\n-             0x38,\n-             (unsigned char)0xF6,\n-             (0xC0 | encode));\n+  if (needs_rex2(dst, src)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  } else {\n+    emit_int8(0x66);\n+    int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n+    emit_int32(0x0F,\n+               0x38,\n+               (unsigned char)0xF6,\n+               (0xC0 | encode));\n+  }\n@@ -13041,6 +13325,12 @@\n-  emit_int8((unsigned char)0xF3);\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int32(0x0F,\n-             0x38,\n-             (unsigned char)0xF6,\n-             (0xC0 | encode));\n+  if (needs_rex2(dst, src)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  } else {\n+    emit_int8((unsigned char)0xF3);\n+    int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n+    emit_int32(0x0F,\n+               0x38,\n+               (unsigned char)0xF6,\n+               (0xC0 | encode));\n+  }\n@@ -13048,1 +13338,0 @@\n-\n@@ -13062,1 +13351,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x23);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x23);\n@@ -13073,1 +13362,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x21);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x21);\n@@ -13079,2 +13368,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13087,1 +13376,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13094,2 +13384,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -13099,2 +13389,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -13104,2 +13394,2 @@\n-  int encode = prefixq_and_encode(reg->encoding());\n-  emit_int16(0x0F, (0xC8 | encode));\n+  int encode = prefixq_and_encode(reg->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xC8, encode);\n@@ -13110,2 +13400,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13118,1 +13408,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13126,2 +13417,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rdx->encoding(),  dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13134,1 +13425,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13142,2 +13434,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13150,1 +13442,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13162,2 +13455,2 @@\n-  prefix(adr);\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  prefix(adr, true);\n+  emit_int8((unsigned char)0xAE);\n@@ -13175,1 +13468,1 @@\n-  prefix(adr);\n+  prefix(adr, true);\n@@ -13177,1 +13470,1 @@\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  emit_int8((unsigned char)0xAE);\n@@ -13190,1 +13483,1 @@\n-  prefix(adr);\n+  prefix(adr, true);\n@@ -13192,1 +13485,1 @@\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  emit_int8((unsigned char)0xAE);\n@@ -13198,2 +13491,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (0x40 | cc), (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((0x40 | cc), 0xC0, encode);\n@@ -13204,1 +13497,2 @@\n-  emit_int24(get_prefixq(src, dst), 0x0F, (0x40 | cc));\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (0x40 | cc));\n@@ -13221,1 +13515,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x39);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x39);\n@@ -13232,1 +13526,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x3B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x3B);\n@@ -13238,1 +13532,2 @@\n-  emit_int24(get_prefixq(adr, reg), 0x0F, (unsigned char)0xB1);\n+  int prefix = get_prefixq(adr, reg, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB1);\n@@ -13245,1 +13540,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -13316,1 +13611,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xFF);\n@@ -13320,0 +13615,1 @@\n+\/\/ can't use REX2\n@@ -13325,0 +13621,1 @@\n+\/\/ can't use REX2\n@@ -13330,0 +13627,1 @@\n+\/\/ can't use REX2\n@@ -13335,0 +13633,1 @@\n+\/\/ cant use REX2\n@@ -13351,2 +13650,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xAF, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAF, 0xC0, encode);\n@@ -13386,1 +13685,2 @@\n-  emit_int24(get_prefixq(src, dst), 0x0F, (unsigned char)0xAF);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xAF);\n@@ -13407,1 +13707,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xFF);\n@@ -13417,1 +13717,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x8D);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x8D);\n@@ -13475,2 +13775,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -13483,2 +13783,2 @@\n-  prefixq(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBD);\n+  prefixq(src, dst, true);\n+  emit_int8((unsigned char)0xBD);\n@@ -13492,1 +13792,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -13514,1 +13814,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x8B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x8B);\n@@ -13520,1 +13820,1 @@\n-  emit_int16(get_prefixq(dst, src), (unsigned char)0x89);\n+  emit_prefix_and_int8(get_prefixq(dst, src), (unsigned char)0x89);\n@@ -13526,1 +13826,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xC7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC7);\n@@ -13539,3 +13839,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xBE);\n+  int prefix = get_prefixq(src, dst, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBE);\n@@ -13546,2 +13845,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBE, 0xC0, encode);\n@@ -13553,1 +13852,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xC7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC7);\n@@ -13560,1 +13859,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x63);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x63);\n@@ -13571,3 +13870,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xBF);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBF);\n@@ -13578,2 +13876,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBF, 0xC0, encode);\n@@ -13584,3 +13882,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xB6);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB6);\n@@ -13591,2 +13888,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB6, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB6, 0xC0, encode);\n@@ -13597,3 +13894,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xB7);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB7);\n@@ -13604,2 +13900,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB7, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB7, 0xC0, encode);\n@@ -13610,1 +13906,1 @@\n-  emit_int16(get_prefixq(src), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(src), (unsigned char)0xF7);\n@@ -13621,2 +13917,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst1->encoding(), dst2->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst1->encoding(), dst2->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13633,1 +13929,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xF7);\n@@ -13645,3 +13941,2 @@\n-  emit_int24(get_prefixq(dst),\n-             0x0F,\n-             (unsigned char)0xBA);\n+  int prefix = get_prefixq(dst, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBA);\n@@ -13655,3 +13950,2 @@\n-  emit_int24(get_prefixq(dst),\n-             0x0F,\n-             (unsigned char)0xBA);\n+  int prefix = get_prefixq(dst, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBA);\n@@ -13670,1 +13964,1 @@\n-  emit_int16(get_prefixq(dst, src), (unsigned char)0x09);\n+  emit_prefix_and_int8(get_prefixq(dst, src), (unsigned char)0x09);\n@@ -13686,1 +13980,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x0B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x0B);\n@@ -13708,2 +14002,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB8, 0xC0, encode);\n@@ -13714,1 +14008,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0x8F);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0x8F);\n@@ -13859,1 +14153,1 @@\n-  emit_int16(get_prefixq(src), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(src), (unsigned char)0xFF);\n@@ -13885,2 +14179,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -13893,1 +14187,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -13902,2 +14197,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0,  src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -13910,1 +14205,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13922,1 +14218,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -13926,1 +14222,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -13934,1 +14230,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -13957,1 +14253,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -13961,1 +14257,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -13969,1 +14265,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -14002,1 +14298,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x1B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x1B);\n@@ -14044,1 +14340,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -14052,1 +14348,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -14056,1 +14352,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -14070,1 +14366,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x29);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x29);\n@@ -14087,1 +14383,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x2B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x2B);\n@@ -14098,1 +14394,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xF7);\n@@ -14126,1 +14422,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x85);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x85);\n@@ -14132,1 +14428,2 @@\n-  emit_int24(get_prefixq(dst, src), 0x0F, (unsigned char)0xC1);\n+  int prefix = get_prefixq(dst, src, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xC1);\n@@ -14138,1 +14435,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x87);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x87);\n@@ -14154,1 +14451,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x33);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x33);\n@@ -14171,1 +14468,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x31);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x31);\n@@ -14182,1 +14479,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":702,"deletions":405,"binary":false,"changes":1107,"status":"modified"},{"patch":"@@ -311,1 +311,5 @@\n-    return _base->is_valid() && _base->encoding() >= 8;\n+    return _base->is_valid() && ((_base->encoding() & 8) == 8);\n+  }\n+\n+  bool base_needs_rex2() const {\n+    return _base->is_valid() && _base->encoding() >= 16;\n@@ -315,1 +319,5 @@\n-    return _index->is_valid() &&_index->encoding() >= 8;\n+    return _index->is_valid() && ((_index->encoding() & 8) == 8);\n+  }\n+\n+  bool index_needs_rex2() const {\n+    return _index->is_valid() &&_index->encoding() >= 16;\n@@ -322,0 +330,4 @@\n+  bool xmmindex_needs_rex2() const {\n+    return _xmmindex->is_valid() && _xmmindex->encoding() >= 16;\n+  }\n+\n@@ -511,0 +523,3 @@\n+    REX2       = 0xd5,\n+    WREX2      = REX2 << 8,\n+\n@@ -517,0 +532,11 @@\n+  enum PrefixBits {\n+    REXBIT_B  = 0x01,\n+    REXBIT_X  = 0x02,\n+    REXBIT_R  = 0x04,\n+    REXBIT_W  = 0x08,\n+    REX2BIT_B4 = 0x10,\n+    REX2BIT_X4 = 0x20,\n+    REX2BIT_R4 = 0x40,\n+    REX2BIT_M0 = 0x80\n+  };\n+\n@@ -528,0 +554,1 @@\n+    EVEX_B  = 0x20,\n@@ -532,0 +559,7 @@\n+  enum ExtEvexPrefix {\n+    EEVEX_R = 0x10,\n+    EEVEX_B = 0x08,\n+    EEVEX_X = 0x04,\n+    EEVEX_V = 0x08\n+  };\n+\n@@ -543,1 +577,1 @@\n-    VEX_SIMD_F2   = 0x3\n+    VEX_SIMD_F2   = 0x3,\n@@ -551,0 +585,1 @@\n+    VEX_OPCODE_0F_3C = 0x4,\n@@ -575,1 +610,2 @@\n-    EVEX_ETUP = 23\n+    EVEX_NOSCALE = 23,\n+    EVEX_ETUP = 24\n@@ -689,0 +725,6 @@\n+  int get_base_prefix_bits(int enc);\n+  int get_index_prefix_bits(int enc);\n+  int get_base_prefix_bits(Register base);\n+  int get_index_prefix_bits(Register index);\n+  int get_reg_prefix_bits(int enc);\n+\n@@ -692,0 +734,1 @@\n+  void prefix_rex2(Register dst, Register src);\n@@ -693,0 +736,1 @@\n+  void prefix_rex2(Register dst, Address adr);\n@@ -694,2 +738,4 @@\n-  void prefix(Address adr);\n-  void prefix(Address adr, Register reg,  bool byteinst = false);\n+  void prefix(Address adr, bool is_map1 = false);\n+  void prefix_rex2(Address adr, bool is_map1 = false);\n+  void prefix(Address adr, Register reg,  bool byteinst = false, bool is_map1 = false);\n+  void prefix_rex2(Address adr, Register reg,  bool byteinst = false, bool is_map1 = false);\n@@ -697,0 +743,1 @@\n+  void prefix_rex2(Address adr, XMMRegister reg);\n@@ -698,3 +745,4 @@\n-  int prefix_and_encode(int reg_enc, bool byteinst = false);\n-  int prefix_and_encode(int dst_enc, int src_enc) {\n-    return prefix_and_encode(dst_enc, false, src_enc, false);\n+  int prefix_and_encode(int reg_enc, bool byteinst = false, bool is_map1 = false);\n+  int prefix_and_encode_rex2(int reg_enc, bool is_map1 = false);\n+  int prefix_and_encode(int dst_enc, int src_enc, bool is_map1 = false) {\n+    return prefix_and_encode(dst_enc, false, src_enc, false, is_map1);\n@@ -702,1 +750,1 @@\n-  int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);\n+  int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1 = false);\n@@ -704,0 +752,1 @@\n+  int prefix_and_encode_rex2(int dst_enc, int src_enc, int init_bits = 0);\n@@ -707,2 +756,4 @@\n-  int8_t get_prefixq(Address adr);\n-  int8_t get_prefixq(Address adr, Register reg);\n+  int get_prefixq(Address adr, bool isPage1 = false);\n+  int get_prefixq_rex2(Address adr, bool isPage1 = false);\n+  int get_prefixq(Address adr, Register reg, bool isPage1 = false);\n+  int get_prefixq_rex2(Address adr, Register reg, bool isPage1 = false);\n@@ -711,1 +762,1 @@\n-  void prefixq(Address adr, Register reg);\n+  void prefixq(Address adr, Register reg, bool is_map1 = false);\n@@ -713,0 +764,1 @@\n+  void prefixq_rex2(Address adr, XMMRegister src);\n@@ -714,2 +766,8 @@\n-  int prefixq_and_encode(int reg_enc);\n-  int prefixq_and_encode(int dst_enc, int src_enc);\n+  bool prefix_is_rex2(int prefix);\n+\n+  int prefixq_and_encode(int reg_enc, bool is_map1 = false);\n+  int prefixq_and_encode_rex2(int reg_enc, bool is_map1 = false);\n+  int prefixq_and_encode(int dst_enc, int src_enc, bool is_map1 = false);\n+  int prefixq_and_encode_rex2(int dst_enc, int src_enc, bool is_map1 = false);\n+\n+  bool needs_rex2(Register reg1, Register reg2 = noreg, Register reg3 = noreg);\n@@ -724,2 +782,2 @@\n-  void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,\n-                   int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n+  void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_v, bool evex_r, bool evex_b,\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n@@ -727,2 +785,1 @@\n-  void vex_prefix(Address adr, int nds_enc, int xreg_enc,\n-                  VexSimdPrefix pre, VexOpcode opc,\n+  void vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc,\n@@ -733,1 +790,1 @@\n-                             InstructionAttr *attributes);\n+                             InstructionAttr *attributes, bool src_is_gpr = false);\n@@ -739,1 +796,1 @@\n-                             VexOpcode opc, InstructionAttr *attributes);\n+                             VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr = false);\n@@ -824,0 +881,4 @@\n+  void emit_prefix_and_int8(int prefix, int b1);\n+  void emit_opcode_prefix_and_encoding(int byte1, int ocp_and_encoding);\n+  void emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding);\n+  void emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding, int byte3);\n@@ -910,0 +971,2 @@\n+  void prefix16(int p);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":84,"deletions":21,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -33,2 +33,5 @@\n-inline int Assembler::prefix_and_encode(int reg_enc, bool byteinst) { return reg_enc; }\n-inline int Assembler::prefixq_and_encode(int reg_enc) { return reg_enc; }\n+inline int Assembler::prefix_and_encode(int reg_enc, bool byteinst, bool is_map1)\n+{\n+    int opc_prefix = is_map1 ? 0x0F00 : 0;\n+    return opc_prefix | reg_enc;\n+}\n@@ -36,2 +39,14 @@\n-inline int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) { return dst_enc << 3 | src_enc; }\n-inline int Assembler::prefixq_and_encode(int dst_enc, int src_enc) { return dst_enc << 3 | src_enc; }\n+inline int Assembler::prefixq_and_encode(int reg_enc, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | reg_enc;\n+}\n+\n+inline int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+inline int Assembler::prefixq_and_encode(int dst_enc, int src_enc, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | dst_enc << 3 | src_enc;\n+}\n@@ -42,1 +57,7 @@\n-inline void Assembler::prefix(Address adr) {}\n+\n+inline void Assembler::prefix(Address adr, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n+\n@@ -45,2 +66,10 @@\n-inline void Assembler::prefix(Address adr, Register reg,  bool byteinst) {}\n-inline void Assembler::prefixq(Address adr, Register reg) {}\n+inline void Assembler::prefix(Address adr, Register reg,  bool byteinst, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n+inline void Assembler::prefixq(Address adr, Register reg, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n@@ -50,0 +79,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.inline.hpp","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -234,2 +234,4 @@\n-             \"mitigations for the Intel JCC erratum\")\n-\n+             \"mitigations for the Intel JCC erratum\")                       \\\n+                                                                            \\\n+  product(bool, UseAPX, false, EXPERIMENTAL,                                \\\n+          \"Use Advanced Performance Extensions on x86\")                     \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}