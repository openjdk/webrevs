{"files":[{"patch":"@@ -79,1 +79,2 @@\n-  0,  0,  0    \/\/ EVEX_NTUP\n+  1,   1,  1,  \/\/ EVEX_NOSCALE(0)\n+  0,  0,  0    \/\/ EVEX_ETUP\n@@ -297,5 +298,1 @@\n-  int enc = r->encoding();\n-  if (enc >= 8) {\n-    enc -= 8;\n-  }\n-  return enc;\n+  return r->encoding() & 7;\n@@ -441,0 +438,3 @@\n+    case EVEX_NOSCALE:\n+      break;\n+\n@@ -528,0 +528,3 @@\n+    case EVEX_NOSCALE:\n+      break;\n+\n@@ -549,0 +552,6 @@\n+bool Assembler::needs_rex2(Register reg1, Register reg2, Register reg3) {\n+  return (reg1->is_valid() && reg1->encoding() >= 16) ||\n+         (reg2->is_valid() && reg2->encoding() >= 16) ||\n+         (reg3->is_valid() && reg3->encoding() >= 16);\n+}\n+\n@@ -619,2 +628,1 @@\n-      if (disp == 0 && no_relocation &&\n-          base_enc != rbp->encoding() LP64_ONLY(&& base_enc != r13->encoding())) {\n+      if (disp == 0 && no_relocation && ((base_enc & 0x7) != 5)) {\n@@ -638,1 +646,1 @@\n-    } else if (base_enc == rsp->encoding() LP64_ONLY(|| base_enc == r12->encoding())) {\n+    } else if ((base_enc & 0x7) == 4) {\n@@ -660,3 +668,2 @@\n-      assert(base_enc != rsp->encoding() LP64_ONLY(&& base_enc != r12->encoding()), \"illegal addressing mode\");\n-      if (disp == 0 && no_relocation &&\n-          base_enc != rbp->encoding() LP64_ONLY(&& base_enc != r13->encoding())) {\n+      assert(((base_enc & 0x7) != 4), \"illegal addressing mode\");\n+      if (disp == 0 && no_relocation &&  ((base_enc & 0x7) != 5)) {\n@@ -820,0 +827,7 @@\n+  case REX2:\n+    NOT_LP64(assert(false, \"64bit prefixes\"));\n+    if ((0xFF & *ip++) & REXBIT_W) {\n+      is_64bit = true;\n+    }\n+    goto again_after_prefix;\n+\n@@ -869,0 +883,8 @@\n+\n+    case REX2:\n+      NOT_LP64(assert(false, \"64bit prefix found\"));\n+      if ((0xFF & *ip++) & REXBIT_W) {\n+        is_64bit = true;\n+      }\n+      goto again_after_size_prefix2;\n+\n@@ -1157,0 +1179,1 @@\n+    case REX2:\n@@ -1283,0 +1306,27 @@\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding, int byte3) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int32(opcode_prefix, (unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF), byte3);\n+  } else {\n+    emit_int24((unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF), byte3);\n+  }\n+}\n+\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int24(opcode_prefix, (unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF));\n+  } else {\n+    emit_int16((unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF));\n+  }\n+}\n+\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int ocp_and_encoding) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int16(opcode_prefix, (unsigned char)byte1 | (ocp_and_encoding & 0xFF));\n+  } else {\n+    emit_int8((unsigned char)byte1 | (ocp_and_encoding & 0xFF));\n+  }\n+}\n+\n@@ -1605,2 +1655,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1613,1 +1663,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1620,4 +1671,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBC,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -1627,4 +1676,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBD,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -1634,2 +1681,2 @@\n-  int encode = prefix_and_encode(reg->encoding());\n-  emit_int16(0x0F, (0xC8 | encode));\n+  int encode = prefix_and_encode(reg->encoding(), false, true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xC8, encode);\n@@ -1640,2 +1687,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1648,1 +1695,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1656,2 +1704,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1665,1 +1713,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1673,2 +1722,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1681,1 +1730,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1745,4 +1795,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             0x40 | cc,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding(0x40 | cc, 0xC0, encode);\n@@ -1751,1 +1799,0 @@\n-\n@@ -1755,2 +1802,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (0x40 | cc));\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((0x40 | cc));\n@@ -1811,2 +1858,2 @@\n-  prefix(adr, reg);\n-  emit_int16(0x0F, (unsigned char)0xB1);\n+  prefix(adr, reg, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB1);\n@@ -1819,2 +1866,2 @@\n-  prefix(adr, reg);\n-  emit_int16(0x0F, (unsigned char)0xB1);\n+  prefix(adr, reg, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB1);\n@@ -1829,2 +1876,2 @@\n-  prefix(adr, reg, true);\n-  emit_int16(0x0F, (unsigned char)0xB0);\n+  prefix(adr, reg, true, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB0);\n@@ -1888,2 +1935,7 @@\n-  int8_t w = 0x01;\n-  Prefix p = Prefix_EMPTY;\n+  if (needs_rex2(crc, v)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ sizeInBytes == 8, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(crc->encoding(), 0, v->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16(sizeInBytes == 1 ? (unsigned char)0xF0 : (unsigned char)0xF1, (0xC0 | encode));\n+  } else {\n+    int8_t w = 0x01;\n+    Prefix p = Prefix_EMPTY;\n@@ -1891,27 +1943,33 @@\n-  emit_int8((unsigned char)0xF2);\n-  switch (sizeInBytes) {\n-  case 1:\n-    w = 0;\n-    break;\n-  case 2:\n-  case 4:\n-    break;\n-  LP64_ONLY(case 8:)\n-    \/\/ This instruction is not valid in 32 bits\n-    \/\/ Note:\n-    \/\/ http:\/\/www.intel.com\/content\/dam\/www\/public\/us\/en\/documents\/manuals\/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n-    \/\/\n-    \/\/ Page B - 72   Vol. 2C says\n-    \/\/ qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2\n-    \/\/ mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r \/ m\n-    \/\/                                                                            F0!!!\n-    \/\/ while 3 - 208 Vol. 2A\n-    \/\/ F2 REX.W 0F 38 F1 \/ r       CRC32 r64, r \/ m64             RM         Valid      N.E.Accumulate CRC32 on r \/ m64.\n-    \/\/\n-    \/\/ the 0 on a last bit is reserved for a different flavor of this instruction :\n-    \/\/ F2 REX.W 0F 38 F0 \/ r       CRC32 r64, r \/ m8              RM         Valid      N.E.Accumulate CRC32 on r \/ m8.\n-    p = REX_W;\n-    break;\n-  default:\n-    assert(0, \"Unsupported value for a sizeInBytes argument\");\n-    break;\n+    emit_int8((unsigned char)0xF2);\n+    switch (sizeInBytes) {\n+    case 1:\n+      w = 0;\n+      break;\n+    case 2:\n+    case 4:\n+      break;\n+    LP64_ONLY(case 8:)\n+      \/\/ This instruction is not valid in 32 bits\n+      \/\/ Note:\n+      \/\/ http:\/\/www.intel.com\/content\/dam\/www\/public\/us\/en\/documents\/manuals\/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n+      \/\/\n+      \/\/ Page B - 72   Vol. 2C says\n+      \/\/ qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2\n+      \/\/ mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r \/ m\n+      \/\/                                                                            F0!!!\n+      \/\/ while 3 - 208 Vol. 2A\n+      \/\/ F2 REX.W 0F 38 F1 \/ r       CRC32 r64, r \/ m64             RM         Valid      N.E.Accumulate CRC32 on r \/ m64.\n+      \/\/\n+      \/\/ the 0 on a last bit is reserved for a different flavor of this instruction :\n+      \/\/ F2 REX.W 0F 38 F0 \/ r       CRC32 r64, r \/ m8              RM         Valid      N.E.Accumulate CRC32 on r \/ m8.\n+      p = REX_W;\n+      break;\n+    default:\n+      assert(0, \"Unsupported value for a sizeInBytes argument\");\n+      break;\n+    }\n+    LP64_ONLY(prefix(crc, v, p);)\n+    emit_int32(0x0F,\n+               0x38,\n+               0xF0 | w,\n+               0xC0 | ((crc->encoding() & 0x7) << 3) | (v->encoding() & 7));\n@@ -1919,5 +1977,0 @@\n-  LP64_ONLY(prefix(crc, v, p);)\n-  emit_int32(0x0F,\n-             0x38,\n-             0xF0 | w,\n-             0xC0 | ((crc->encoding() & 0x7) << 3) | (v->encoding() & 7));\n@@ -1929,2 +1982,9 @@\n-  int8_t w = 0x01;\n-  Prefix p = Prefix_EMPTY;\n+  if (needs_rex2(crc, adr.base(), adr.index())) {\n+    InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ sizeInBytes == 8, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+    vex_prefix(adr, 0, crc->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+    emit_int8(sizeInBytes == 1 ? (unsigned char)0xF0 : (unsigned char)0xF1);\n+    emit_operand(crc, adr, 0);\n+  } else {\n+    int8_t w = 0x01;\n+    Prefix p = Prefix_EMPTY;\n@@ -1932,15 +1992,19 @@\n-  emit_int8((uint8_t)0xF2);\n-  switch (sizeInBytes) {\n-  case 1:\n-    w = 0;\n-    break;\n-  case 2:\n-  case 4:\n-    break;\n-  LP64_ONLY(case 8:)\n-    \/\/ This instruction is not valid in 32 bits\n-    p = REX_W;\n-    break;\n-  default:\n-    assert(0, \"Unsupported value for a sizeInBytes argument\");\n-    break;\n+    emit_int8((uint8_t)0xF2);\n+    switch (sizeInBytes) {\n+    case 1:\n+      w = 0;\n+      break;\n+    case 2:\n+    case 4:\n+      break;\n+    LP64_ONLY(case 8:)\n+      \/\/ This instruction is not valid in 32 bits\n+      p = REX_W;\n+      break;\n+    default:\n+      assert(0, \"Unsupported value for a sizeInBytes argument\");\n+      break;\n+    }\n+    LP64_ONLY(prefix(crc, adr, p);)\n+    emit_int24(0x0F, 0x38, (0xF0 | w));\n+    emit_operand(crc, adr, 0);\n@@ -1948,3 +2012,0 @@\n-  LP64_ONLY(prefix(crc, adr, p);)\n-  emit_int24(0x0F, 0x38, (0xF0 | w));\n-  emit_operand(crc, adr, 0);\n@@ -2052,1 +2113,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2069,1 +2130,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes, true);\n@@ -2086,1 +2147,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes, true);\n@@ -2389,4 +2450,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xAF,\n-             (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAF, 0xC0, encode);\n@@ -2421,2 +2480,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xAF);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xAF);\n@@ -2567,2 +2626,2 @@\n-    prefix(src);\n-    emit_int16(0x0F, (unsigned char)0xAE);\n+    prefix(src, true);\n+    emit_int8((unsigned char)0xAE);\n@@ -2595,2 +2654,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -2603,2 +2662,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBD);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBD);\n@@ -2696,2 +2755,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -2703,1 +2762,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2710,2 +2769,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes, true);\n@@ -2717,1 +2776,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2725,1 +2784,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2734,1 +2794,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2742,1 +2803,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2749,2 +2810,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2756,1 +2817,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2763,1 +2824,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2771,1 +2832,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2780,1 +2842,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2788,2 +2851,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2795,1 +2858,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -3076,1 +3139,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3553,1 +3616,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3560,1 +3623,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3566,2 +3629,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBE);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBE);\n@@ -3573,2 +3636,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBE, 0xC0, encode);\n@@ -3646,2 +3709,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBF);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBF);\n@@ -3652,2 +3715,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBF, 0xC0, encode);\n@@ -3724,2 +3787,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB6);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB6);\n@@ -3731,2 +3794,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0xB6, 0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB6, 0xC0, encode);\n@@ -3737,2 +3800,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB7);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB7);\n@@ -3743,2 +3806,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB7, 0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB7, 0xC0, encode);\n@@ -4760,1 +4823,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4777,1 +4840,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4784,1 +4847,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4801,1 +4864,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(),  nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4808,1 +4871,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -4825,1 +4888,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -4842,1 +4905,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4849,1 +4912,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -5252,2 +5315,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB8);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB8);\n@@ -5260,2 +5323,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB8, 0xC0, encode);\n@@ -5333,2 +5396,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5341,2 +5404,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x0D);\n+  prefix(src, true);\n+  emit_int8(0x0D);\n@@ -5349,2 +5412,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5357,2 +5420,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5365,2 +5428,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true);\n+  emit_int8(0x18);\n@@ -5373,2 +5436,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x0D);\n+  prefix(src, true);\n+  emit_int8(0x0D);\n@@ -5382,0 +5445,6 @@\n+void Assembler::prefix16(int prefix) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  emit_int8((prefix & 0xff00) >> 8);\n+  emit_int8(prefix & 0xff);\n+}\n+\n@@ -6019,2 +6088,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x90 | cc, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0x90 | cc, 0xC0, encode);\n@@ -6153,2 +6222,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int24(0x0F, (unsigned char)0xA5, (0xC0 | encode));\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA5, 0xC0, encode);\n@@ -6158,2 +6227,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA4, 0xC0, encode, imm8);\n@@ -6163,2 +6232,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int24(0x0F, (unsigned char)0xAD, (0xC0 | encode));\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAD, 0xC0, encode);\n@@ -6168,2 +6237,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAC, 0xC0, encode, imm8);\n@@ -6174,2 +6243,2 @@\n-  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA4, 0xC0, encode, imm8);\n@@ -6179,2 +6248,2 @@\n-  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAC, 0xC0, encode, imm8);\n@@ -6246,1 +6315,1 @@\n-void Assembler::stmxcsr( Address dst) {\n+void Assembler::stmxcsr(Address dst) {\n@@ -6257,2 +6326,2 @@\n-    prefix(dst);\n-    emit_int16(0x0F, (unsigned char)0xAE);\n+    prefix(dst, true);\n+    emit_int8((unsigned char)0xAE);\n@@ -6398,4 +6467,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBC,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -6408,2 +6475,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBC);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBC);\n@@ -6416,2 +6483,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -6424,2 +6491,2 @@\n-  prefixq(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBC);\n+  prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBC);\n@@ -6471,2 +6538,2 @@\n-  prefix(dst, src, true);\n-  emit_int16(0x0F, (unsigned char)0xC0);\n+  prefix(dst, src, true, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC0);\n@@ -6479,2 +6546,2 @@\n-  prefix(dst, src);\n-  emit_int16(0x0F, (unsigned char)0xC1);\n+  prefix(dst, src, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC1);\n@@ -6486,2 +6553,2 @@\n-  prefix(dst, src);\n-  emit_int16(0x0F, (unsigned char)0xC1);\n+  prefix(dst, src, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC1);\n@@ -10811,1 +10878,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -10820,1 +10887,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes , true);\n@@ -10829,1 +10896,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -10838,1 +10905,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -11598,1 +11665,2 @@\n-void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){\n+void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_b, bool evex_v,\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {\n@@ -11611,0 +11679,1 @@\n+  byte2 |= evex_b ? EEVEX_B : 0;\n@@ -11612,1 +11681,1 @@\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ of form {0F, 0F_38, 0F_3A, 0F_3C}\n@@ -11617,2 +11686,1 @@\n-  \/\/ p[10] is always 1\n-  byte3 |= EVEX_F;\n+  byte3 |= (eevex_x ? 0 : EEVEX_X);\n@@ -11645,0 +11713,1 @@\n+  bool is_extended = adr.base_needs_rex2() || adr.index_needs_rex2() || nds_enc >= 16 || xreg_enc >= 16;\n@@ -11654,1 +11723,0 @@\n-\n@@ -11660,1 +11728,1 @@\n-      if ((attributes->get_vector_len() != AVX_512bit) && (nds_enc < 16) && (xreg_enc < 16)) {\n+      if ((attributes->get_vector_len() != AVX_512bit) && !is_extended) {\n@@ -11671,1 +11739,1 @@\n-    assert(((nds_enc < 16 && xreg_enc < 16) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n+    assert((!is_extended || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n@@ -11685,0 +11753,2 @@\n+    bool eevex_x = adr.index_needs_rex2();\n+    bool evex_b = adr.base_needs_rex2();\n@@ -11686,1 +11756,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, eevex_x, nds_enc, pre, opc);\n@@ -11695,1 +11765,2 @@\n-int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {\n+int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n+  bool is_extended = dst_enc >= 16 || nds_enc >= 16 || src_enc >=16;\n@@ -11707,1 +11778,1 @@\n-          (dst_enc < 16) && (nds_enc < 16) && (src_enc < 16)) {\n+           !is_extended) {\n@@ -11724,1 +11795,1 @@\n-    assert(((dst_enc < 16 && nds_enc < 16 && src_enc < 16) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n+    assert(((!is_extended) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n@@ -11732,0 +11803,1 @@\n+    bool evex_b = (src_enc >= 16) && src_is_gpr;\n@@ -11733,1 +11805,1 @@\n-    vex_x = (src_enc >= 16);\n+    vex_x = (src_enc >= 16) && !src_is_gpr;\n@@ -11735,1 +11807,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, pre, opc);\n@@ -11747,1 +11819,0 @@\n-\n@@ -11761,1 +11832,1 @@\n-                                      VexOpcode opc, InstructionAttr *attributes) {\n+                                      VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n@@ -11766,1 +11837,1 @@\n-    return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes);\n+    return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, src_is_gpr);\n@@ -12261,2 +12332,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12268,2 +12339,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12275,2 +12346,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12282,2 +12353,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12289,2 +12360,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12297,1 +12368,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12306,1 +12378,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12315,1 +12388,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12324,1 +12398,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12332,2 +12407,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12340,1 +12415,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12348,2 +12424,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12356,1 +12432,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12364,2 +12441,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12372,1 +12449,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12380,2 +12458,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12388,1 +12466,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12396,2 +12475,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12404,1 +12483,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12412,2 +12492,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12420,1 +12500,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12724,0 +12805,29 @@\n+int Assembler::get_base_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_B4;\n+  if (enc & 8) bits |= REXBIT_B;\n+  return bits;\n+}\n+\n+int Assembler::get_index_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_X4;\n+  if (enc & 8) bits |= REXBIT_X;\n+  return bits;\n+}\n+\n+int Assembler::get_base_prefix_bits(Register base) {\n+  return base->is_valid() ? get_base_prefix_bits(base->encoding()) : 0;\n+}\n+\n+int Assembler::get_index_prefix_bits(Register index) {\n+  return index->is_valid() ? get_index_prefix_bits(index->encoding()) : 0;\n+}\n+\n+int Assembler::get_reg_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_R4;\n+  if (enc & 8) bits |= REXBIT_R;\n+  return bits;\n+}\n+\n@@ -12725,1 +12835,3 @@\n-  if (reg->encoding() >= 8) {\n+  if (reg->encoding() >= 16) {\n+    prefix16(WREX2 | get_base_prefix_bits(reg->encoding()));\n+  } else if (reg->encoding() >= 8) {\n@@ -12731,0 +12843,4 @@\n+  if ((p & WREX2) || src->encoding() >= 16 || dst->encoding() >= 16) {\n+    prefix_rex2(dst, src);\n+    return;\n+  }\n@@ -12743,0 +12859,7 @@\n+void Assembler::prefix_rex2(Register dst, Register src) {\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(src->encoding());\n+  bits |= get_reg_prefix_bits(dst->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n@@ -12744,0 +12867,3 @@\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || dst->encoding() >= 16) {\n+    prefix_rex2(dst, adr);\n+  }\n@@ -12764,1 +12890,15 @@\n-void Assembler::prefix(Address adr) {\n+void Assembler::prefix_rex2(Register dst, Address adr) {\n+  if (adr.index_needs_rex2()) {\n+    assert(false, \"prefix(Register dst, Address adr) does not support handling of an X\");\n+  }\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_reg_prefix_bits(dst->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+void Assembler::prefix(Address adr, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix_rex2(adr, is_map1);\n+    return;\n+  }\n@@ -12776,0 +12916,1 @@\n+  if (is_map1) emit_int8(0x0F);\n@@ -12778,1 +12919,12 @@\n-void Assembler::prefix(Address adr, Register reg, bool byteinst) {\n+void Assembler::prefix_rex2(Address adr, bool is_map1) {\n+  int bits = is_map1 ? REX2BIT_M0 : 0;\n+  bits |= get_base_prefix_bits(adr.base()->encoding());\n+  bits |= get_index_prefix_bits(adr.index());\n+  prefix16(WREX2 | bits);\n+}\n+\n+void Assembler::prefix(Address adr, Register reg, bool byteinst, bool is_map1) {\n+  if (reg->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix_rex2(adr, reg, byteinst, is_map1);\n+    return;\n+  }\n@@ -12808,0 +12960,9 @@\n+  if (is_map1) emit_int8(0x0F);\n+}\n+\n+void Assembler::prefix_rex2(Address adr, Register reg, bool byteinst, bool is_map1) {\n+  int bits = is_map1 ? REX2BIT_M0 : 0;\n+  bits |= get_base_prefix_bits(adr.base()->encoding());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(reg->encoding());\n+  prefix16(WREX2 | bits);\n@@ -12811,0 +12972,4 @@\n+  if (reg->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefixq_rex2(adr, reg);\n+    return;\n+  }\n@@ -12840,1 +13005,12 @@\n-int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {\n+void Assembler::prefix_rex2(Address adr, XMMRegister src) {\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+int Assembler::prefix_and_encode(int reg_enc, bool byteinst, bool is_map1) {\n+  if (reg_enc >= 16) {\n+    return prefix_and_encode_rex2(reg_enc, is_map1);\n+  }\n@@ -12847,1 +13023,2 @@\n-  return reg_enc;\n+  int opc_prefix = is_map1 ? 0x0F00 : 0;\n+  return opc_prefix | reg_enc;\n@@ -12850,1 +13027,9 @@\n-int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {\n+int Assembler::prefix_and_encode_rex2(int reg_enc, bool is_map1) {\n+  prefix16(WREX2 | (is_map1 ? REX2BIT_M0 : 0) | get_base_prefix_bits(reg_enc));\n+  return reg_enc & 0x7;\n+}\n+\n+int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1) {\n+  if (src_enc >= 16 || dst_enc >= 16) {\n+    return prefix_and_encode_rex2(dst_enc, src_enc, is_map1 ? REX2BIT_M0 : 0);\n+  }\n@@ -12867,0 +13052,11 @@\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+int Assembler::prefix_and_encode_rex2(int dst_enc, int src_enc, int init_bits) {\n+  int bits = init_bits;\n+  bits |= get_reg_prefix_bits(dst_enc);\n+  bits |= get_base_prefix_bits(src_enc);\n+  dst_enc &= 0x7;\n+  src_enc &= 0x7;\n+  prefix16(WREX2 | bits);\n@@ -12870,1 +13066,8 @@\n-int8_t Assembler::get_prefixq(Address adr) {\n+bool Assembler::prefix_is_rex2(int prefix) {\n+  return (prefix & 0xFF00) == WREX2;\n+}\n+\n+int Assembler::get_prefixq(Address adr, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    return get_prefixq_rex2(adr, is_map1);\n+  }\n@@ -12873,1 +13076,10 @@\n-  return prfx;\n+  return is_map1 ? (((int16_t)prfx) << 8) | 0x0F : (int16_t)prfx;\n+}\n+\n+int Assembler::get_prefixq_rex2(Address adr, bool is_map1) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  int bits = REXBIT_W;\n+  if (is_map1) bits |= REX2BIT_M0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  return WREX2 | bits;\n@@ -12876,1 +13088,4 @@\n-int8_t Assembler::get_prefixq(Address adr, Register src) {\n+int Assembler::get_prefixq(Address adr, Register src, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || src->encoding() >= 16) {\n+    return get_prefixq_rex2(adr, src, is_map1);\n+  }\n@@ -12912,1 +13127,11 @@\n-  return prfx;\n+  return is_map1 ? (((int16_t)prfx) << 8) | 0x0F : (int16_t)prfx;\n+}\n+\n+int Assembler::get_prefixq_rex2(Address adr, Register src, bool is_map1) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  int bits = REXBIT_W;\n+  if (is_map1) bits |= REX2BIT_M0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  return WREX2 | bits;\n@@ -12916,1 +13141,5 @@\n-  emit_int8(get_prefixq(adr));\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix16(get_prefixq_rex2(adr));\n+  } else {\n+    emit_int8(get_prefixq(adr));\n+  }\n@@ -12919,2 +13148,7 @@\n-void Assembler::prefixq(Address adr, Register src) {\n-  emit_int8(get_prefixq(adr, src));\n+void Assembler::prefixq(Address adr, Register src, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || src->encoding() >= 16) {\n+    prefix16(get_prefixq_rex2(adr, src, is_map1));\n+  } else {\n+    emit_int8(get_prefixq(adr, src));\n+    if (is_map1) emit_int8(0x0F);\n+  }\n@@ -12923,0 +13157,1 @@\n+\n@@ -12924,0 +13159,4 @@\n+  if (src->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefixq_rex2(adr, src);\n+    return;\n+  }\n@@ -12955,1 +13194,12 @@\n-int Assembler::prefixq_and_encode(int reg_enc) {\n+void Assembler::prefixq_rex2(Address adr, XMMRegister src) {\n+  int bits = REXBIT_W;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+int Assembler::prefixq_and_encode(int reg_enc, bool is_map1) {\n+  if (reg_enc >= 16) {\n+    return prefixq_and_encode_rex2(reg_enc, is_map1);\n+  }\n@@ -12962,1 +13212,8 @@\n-  return reg_enc;\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | reg_enc;\n+}\n+\n+\n+int Assembler::prefixq_and_encode_rex2(int reg_enc, bool is_map1) {\n+  prefix16(WREX2 | REXBIT_W | (is_map1 ? REX2BIT_M0: 0) | get_base_prefix_bits(reg_enc));\n+  return reg_enc & 0x7;\n@@ -12965,1 +13222,4 @@\n-int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {\n+int Assembler::prefixq_and_encode(int dst_enc, int src_enc, bool is_map1) {\n+  if (dst_enc >= 16 || src_enc >= 16) {\n+    return prefixq_and_encode_rex2(dst_enc, src_enc, is_map1);\n+  }\n@@ -12982,1 +13242,15 @@\n-  return dst_enc << 3 | src_enc;\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+int Assembler::prefixq_and_encode_rex2(int dst_enc, int src_enc, bool is_map1) {\n+  int init_bits = REXBIT_W | (is_map1 ? REX2BIT_M0 : 0);\n+  return prefix_and_encode_rex2(dst_enc, src_enc, init_bits);\n+}\n+\n+void Assembler::emit_prefix_and_int8(int prefix, int b1) {\n+  if ((prefix & 0xFF00) == 0) {\n+    emit_int16(prefix, b1);\n+  } else {\n+    emit_int24((prefix & 0xFF00) >> 8, prefix & 0x00FF, b1);\n+  }\n@@ -12992,1 +13266,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x13);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x13);\n@@ -13009,1 +13283,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x01);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x01);\n@@ -13020,1 +13294,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x03);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x03);\n@@ -13031,6 +13305,12 @@\n-  emit_int8(0x66);\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int32(0x0F,\n-             0x38,\n-             (unsigned char)0xF6,\n-             (0xC0 | encode));\n+  if (needs_rex2(dst, src)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  } else {\n+    emit_int8(0x66);\n+    int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n+    emit_int32(0x0F,\n+               0x38,\n+               (unsigned char)0xF6,\n+               (0xC0 | encode));\n+  }\n@@ -13041,6 +13321,12 @@\n-  emit_int8((unsigned char)0xF3);\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int32(0x0F,\n-             0x38,\n-             (unsigned char)0xF6,\n-             (0xC0 | encode));\n+  if (needs_rex2(dst, src)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  } else {\n+    emit_int8((unsigned char)0xF3);\n+    int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n+    emit_int32(0x0F,\n+               0x38,\n+               (unsigned char)0xF6,\n+               (0xC0 | encode));\n+  }\n@@ -13048,1 +13334,0 @@\n-\n@@ -13062,1 +13347,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x23);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x23);\n@@ -13073,1 +13358,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x21);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x21);\n@@ -13079,2 +13364,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13087,1 +13372,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13094,2 +13380,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -13099,2 +13385,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -13104,2 +13390,2 @@\n-  int encode = prefixq_and_encode(reg->encoding());\n-  emit_int16(0x0F, (0xC8 | encode));\n+  int encode = prefixq_and_encode(reg->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xC8, encode);\n@@ -13110,2 +13396,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13118,1 +13404,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13126,2 +13413,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rdx->encoding(),  dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13134,1 +13421,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13142,2 +13430,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13150,1 +13438,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13162,2 +13451,2 @@\n-  prefix(adr);\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  prefix(adr, true);\n+  emit_int8((unsigned char)0xAE);\n@@ -13175,1 +13464,1 @@\n-  prefix(adr);\n+  prefix(adr, true);\n@@ -13177,1 +13466,1 @@\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  emit_int8((unsigned char)0xAE);\n@@ -13190,1 +13479,1 @@\n-  prefix(adr);\n+  prefix(adr, true);\n@@ -13192,1 +13481,1 @@\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  emit_int8((unsigned char)0xAE);\n@@ -13198,2 +13487,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (0x40 | cc), (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((0x40 | cc), 0xC0, encode);\n@@ -13204,1 +13493,2 @@\n-  emit_int24(get_prefixq(src, dst), 0x0F, (0x40 | cc));\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (0x40 | cc));\n@@ -13221,1 +13511,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x39);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x39);\n@@ -13232,1 +13522,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x3B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x3B);\n@@ -13238,1 +13528,2 @@\n-  emit_int24(get_prefixq(adr, reg), 0x0F, (unsigned char)0xB1);\n+  int prefix = get_prefixq(adr, reg, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB1);\n@@ -13245,1 +13536,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -13316,1 +13607,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xFF);\n@@ -13320,0 +13611,1 @@\n+\/\/ can't use REX2\n@@ -13325,0 +13617,1 @@\n+\/\/ can't use REX2\n@@ -13330,0 +13623,1 @@\n+\/\/ can't use REX2\n@@ -13335,0 +13629,1 @@\n+\/\/ cant use REX2\n@@ -13351,2 +13646,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xAF, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAF, 0xC0, encode);\n@@ -13386,1 +13681,2 @@\n-  emit_int24(get_prefixq(src, dst), 0x0F, (unsigned char)0xAF);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xAF);\n@@ -13407,1 +13703,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xFF);\n@@ -13417,1 +13713,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x8D);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x8D);\n@@ -13475,2 +13771,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -13483,2 +13779,2 @@\n-  prefixq(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBD);\n+  prefixq(src, dst, true);\n+  emit_int8((unsigned char)0xBD);\n@@ -13492,1 +13788,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -13514,1 +13810,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x8B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x8B);\n@@ -13520,1 +13816,1 @@\n-  emit_int16(get_prefixq(dst, src), (unsigned char)0x89);\n+  emit_prefix_and_int8(get_prefixq(dst, src), (unsigned char)0x89);\n@@ -13526,1 +13822,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xC7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC7);\n@@ -13539,3 +13835,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xBE);\n+  int prefix = get_prefixq(src, dst, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBE);\n@@ -13546,2 +13841,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBE, 0xC0, encode);\n@@ -13553,1 +13848,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xC7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC7);\n@@ -13560,1 +13855,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x63);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x63);\n@@ -13571,3 +13866,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xBF);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBF);\n@@ -13578,2 +13872,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBF, 0xC0, encode);\n@@ -13584,3 +13878,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xB6);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB6);\n@@ -13591,2 +13884,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB6, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB6, 0xC0, encode);\n@@ -13597,3 +13890,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xB7);\n+  int prefix = get_prefixq(src, dst, true \/* M0 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB7);\n@@ -13604,2 +13896,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB7, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB7, 0xC0, encode);\n@@ -13610,1 +13902,1 @@\n-  emit_int16(get_prefixq(src), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(src), (unsigned char)0xF7);\n@@ -13621,2 +13913,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst1->encoding(), dst2->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst1->encoding(), dst2->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13633,1 +13925,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xF7);\n@@ -13645,3 +13937,2 @@\n-  emit_int24(get_prefixq(dst),\n-             0x0F,\n-             (unsigned char)0xBA);\n+  int prefix = get_prefixq(dst, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBA);\n@@ -13655,3 +13946,2 @@\n-  emit_int24(get_prefixq(dst),\n-             0x0F,\n-             (unsigned char)0xBA);\n+  int prefix = get_prefixq(dst, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBA);\n@@ -13670,1 +13960,1 @@\n-  emit_int16(get_prefixq(dst, src), (unsigned char)0x09);\n+  emit_prefix_and_int8(get_prefixq(dst, src), (unsigned char)0x09);\n@@ -13686,1 +13976,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x0B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x0B);\n@@ -13708,2 +13998,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB8, 0xC0, encode);\n@@ -13714,1 +14004,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0x8F);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0x8F);\n@@ -13859,1 +14149,1 @@\n-  emit_int16(get_prefixq(src), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(src), (unsigned char)0xFF);\n@@ -13885,2 +14175,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -13893,1 +14183,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -13902,2 +14193,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0,  src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -13910,1 +14201,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13922,1 +14214,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -13926,1 +14218,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -13934,1 +14226,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -13957,1 +14249,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -13961,1 +14253,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -13969,1 +14261,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -14002,1 +14294,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x1B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x1B);\n@@ -14044,1 +14336,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -14052,1 +14344,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -14056,1 +14348,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -14070,1 +14362,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x29);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x29);\n@@ -14087,1 +14379,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x2B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x2B);\n@@ -14098,1 +14390,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xF7);\n@@ -14126,1 +14418,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x85);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x85);\n@@ -14132,1 +14424,2 @@\n-  emit_int24(get_prefixq(dst, src), 0x0F, (unsigned char)0xC1);\n+  int prefix = get_prefixq(dst, src, true \/* page1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xC1);\n@@ -14138,1 +14431,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x87);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x87);\n@@ -14154,1 +14447,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x33);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x33);\n@@ -14171,1 +14464,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x31);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x31);\n@@ -14182,1 +14475,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":698,"deletions":405,"binary":false,"changes":1103,"status":"modified"},{"patch":"@@ -311,1 +311,5 @@\n-    return _base->is_valid() && _base->encoding() >= 8;\n+    return _base->is_valid() && ((_base->encoding() & 8) == 8);\n+  }\n+\n+  bool base_needs_rex2() const {\n+    return _base->is_valid() && _base->encoding() >= 16;\n@@ -315,1 +319,5 @@\n-    return _index->is_valid() &&_index->encoding() >= 8;\n+    return _index->is_valid() && ((_index->encoding() & 8) == 8);\n+  }\n+\n+  bool index_needs_rex2() const {\n+    return _index->is_valid() &&_index->encoding() >= 16;\n@@ -322,0 +330,4 @@\n+  bool xmmindex_needs_rex2() const {\n+    return _xmmindex->is_valid() && _xmmindex->encoding() >= 16;\n+  }\n+\n@@ -511,0 +523,3 @@\n+    REX2       = 0xd5,\n+    WREX2      = REX2 << 8,\n+\n@@ -517,0 +532,11 @@\n+  enum PrefixBits {\n+    REXBIT_B  = 0x01,\n+    REXBIT_X  = 0x02,\n+    REXBIT_R  = 0x04,\n+    REXBIT_W  = 0x08,\n+    REX2BIT_B4 = 0x10,\n+    REX2BIT_X4 = 0x20,\n+    REX2BIT_R4 = 0x40,\n+    REX2BIT_M0 = 0x80\n+  };\n+\n@@ -528,0 +554,1 @@\n+    EVEX_B  = 0x20,\n@@ -532,0 +559,7 @@\n+  enum ExtEvexPrefix {\n+    EEVEX_R = 0x10,\n+    EEVEX_B = 0x08,\n+    EEVEX_X = 0x04,\n+    EEVEX_V = 0x08\n+  };\n+\n@@ -543,1 +577,1 @@\n-    VEX_SIMD_F2   = 0x3\n+    VEX_SIMD_F2   = 0x3,\n@@ -551,0 +585,1 @@\n+    VEX_OPCODE_0F_3C = 0x4,\n@@ -575,1 +610,2 @@\n-    EVEX_ETUP = 23\n+    EVEX_NOSCALE = 23,\n+    EVEX_ETUP = 24\n@@ -689,0 +725,6 @@\n+  int get_base_prefix_bits(int enc);\n+  int get_index_prefix_bits(int enc);\n+  int get_base_prefix_bits(Register base);\n+  int get_index_prefix_bits(Register index);\n+  int get_reg_prefix_bits(int enc);\n+\n@@ -692,0 +734,1 @@\n+  void prefix_rex2(Register dst, Register src);\n@@ -693,0 +736,1 @@\n+  void prefix_rex2(Register dst, Address adr);\n@@ -694,2 +738,4 @@\n-  void prefix(Address adr);\n-  void prefix(Address adr, Register reg,  bool byteinst = false);\n+  void prefix(Address adr, bool is_map1 = false);\n+  void prefix_rex2(Address adr, bool is_map1 = false);\n+  void prefix(Address adr, Register reg,  bool byteinst = false, bool is_map1 = false);\n+  void prefix_rex2(Address adr, Register reg,  bool byteinst = false, bool is_map1 = false);\n@@ -697,0 +743,1 @@\n+  void prefix_rex2(Address adr, XMMRegister reg);\n@@ -698,3 +745,4 @@\n-  int prefix_and_encode(int reg_enc, bool byteinst = false);\n-  int prefix_and_encode(int dst_enc, int src_enc) {\n-    return prefix_and_encode(dst_enc, false, src_enc, false);\n+  int prefix_and_encode(int reg_enc, bool byteinst = false, bool is_map1 = false);\n+  int prefix_and_encode_rex2(int reg_enc, bool is_map1 = false);\n+  int prefix_and_encode(int dst_enc, int src_enc, bool is_map1 = false) {\n+    return prefix_and_encode(dst_enc, false, src_enc, false, is_map1);\n@@ -702,1 +750,1 @@\n-  int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);\n+  int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1 = false);\n@@ -704,0 +752,1 @@\n+  int prefix_and_encode_rex2(int dst_enc, int src_enc, int init_bits = 0);\n@@ -707,2 +756,4 @@\n-  int8_t get_prefixq(Address adr);\n-  int8_t get_prefixq(Address adr, Register reg);\n+  int get_prefixq(Address adr, bool isPage1 = false);\n+  int get_prefixq_rex2(Address adr, bool isPage1 = false);\n+  int get_prefixq(Address adr, Register reg, bool isPage1 = false);\n+  int get_prefixq_rex2(Address adr, Register reg, bool isPage1 = false);\n@@ -711,1 +762,1 @@\n-  void prefixq(Address adr, Register reg);\n+  void prefixq(Address adr, Register reg, bool is_map1 = false);\n@@ -713,0 +764,1 @@\n+  void prefixq_rex2(Address adr, XMMRegister src);\n@@ -714,2 +766,8 @@\n-  int prefixq_and_encode(int reg_enc);\n-  int prefixq_and_encode(int dst_enc, int src_enc);\n+  bool prefix_is_rex2(int prefix);\n+\n+  int prefixq_and_encode(int reg_enc, bool is_map1 = false);\n+  int prefixq_and_encode_rex2(int reg_enc, bool is_map1 = false);\n+  int prefixq_and_encode(int dst_enc, int src_enc, bool is_map1 = false);\n+  int prefixq_and_encode_rex2(int dst_enc, int src_enc, bool is_map1 = false);\n+\n+  bool needs_rex2(Register reg1, Register reg2 = noreg, Register reg3 = noreg);\n@@ -724,2 +782,2 @@\n-  void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,\n-                   int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n+  void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_v, bool evex_r, bool evex_b,\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n@@ -727,2 +785,1 @@\n-  void vex_prefix(Address adr, int nds_enc, int xreg_enc,\n-                  VexSimdPrefix pre, VexOpcode opc,\n+  void vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc,\n@@ -733,1 +790,1 @@\n-                             InstructionAttr *attributes);\n+                             InstructionAttr *attributes, bool src_is_gpr = false);\n@@ -739,1 +796,1 @@\n-                             VexOpcode opc, InstructionAttr *attributes);\n+                             VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr = false);\n@@ -824,0 +881,4 @@\n+  void emit_prefix_and_int8(int prefix, int b1);\n+  void emit_opcode_prefix_and_encoding(int byte1, int ocp_and_encoding);\n+  void emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding);\n+  void emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding, int byte3);\n@@ -910,0 +971,2 @@\n+  void prefix16(int p);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":84,"deletions":21,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -33,2 +33,5 @@\n-inline int Assembler::prefix_and_encode(int reg_enc, bool byteinst) { return reg_enc; }\n-inline int Assembler::prefixq_and_encode(int reg_enc) { return reg_enc; }\n+inline int Assembler::prefix_and_encode(int reg_enc, bool byteinst, bool is_map1)\n+{\n+    int opc_prefix = is_map1 ? 0x0F00 : 0;\n+    return opc_prefix | reg_enc;\n+}\n@@ -36,2 +39,14 @@\n-inline int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) { return dst_enc << 3 | src_enc; }\n-inline int Assembler::prefixq_and_encode(int dst_enc, int src_enc) { return dst_enc << 3 | src_enc; }\n+inline int Assembler::prefixq_and_encode(int reg_enc, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | reg_enc;\n+}\n+\n+inline int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+inline int Assembler::prefixq_and_encode(int dst_enc, int src_enc, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | dst_enc << 3 | src_enc;\n+}\n@@ -42,1 +57,7 @@\n-inline void Assembler::prefix(Address adr) {}\n+\n+inline void Assembler::prefix(Address adr, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n+\n@@ -45,2 +66,10 @@\n-inline void Assembler::prefix(Address adr, Register reg,  bool byteinst) {}\n-inline void Assembler::prefixq(Address adr, Register reg) {}\n+inline void Assembler::prefix(Address adr, Register reg,  bool byteinst, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n+inline void Assembler::prefixq(Address adr, Register reg, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n@@ -50,0 +79,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.inline.hpp","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -234,2 +234,4 @@\n-             \"mitigations for the Intel JCC erratum\")\n-\n+             \"mitigations for the Intel JCC erratum\")                       \\\n+                                                                            \\\n+  product(bool, UseAPX, false, EXPERIMENTAL,                                              \\\n+          \"Use Advanced Performance Extensions on x86\")                     \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}