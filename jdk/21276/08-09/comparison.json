{"files":[{"patch":"@@ -5398,2 +5398,6 @@\n-void MacroAssembler::adrp(Register reg1, const Address &dest, uint64_t &byte_offset, bool force_movk) {\n-  relocInfo::relocType rtype = dest.rspec().reloc()->type();\n+void MacroAssembler::adrp(Register reg1, const Address &dest, uint64_t &byte_offset) {\n+  assert(is_valid_AArch64_address(dest.target()), \"bad address\");\n+  assert(dest.getMode() == Address::literal, \"ADRP must be applied to a literal address\");\n+\n+  \/\/ 8143067: Ensure that the adrp can reach the dest from anywhere within\n+  \/\/ the code cache so that if it is relocated we know it will still reach\n@@ -5405,0 +5409,13 @@\n+  bool is_adrp_reachable = offset_high >= -(1<<20) && offset_low < (1<<20);\n+  if (!is_adrp_reachable) {\n+    adrp_movk(reg1, dest, byte_offset);\n+    return;\n+  }\n+\n+  InstructionMark im(this);\n+  relocInfo::relocType rtype = dest.rspec().reloc()->type();\n+  code_section()->relocate(inst_mark(), dest.rspec());\n+  _adrp(reg1, dest.target());\n+\n+  byte_offset = (uint64_t)dest.target() & 0xfff;\n+}\n@@ -5406,0 +5423,2 @@\n+\/\/ Variant using an additional MOVK instruction to support targets located more than 4GB away.\n+void MacroAssembler::adrp_movk(Register reg1, const Address &dest, uint64_t &byte_offset) {\n@@ -5410,0 +5429,1 @@\n+  relocInfo::relocType rtype = dest.rspec().reloc()->type();\n@@ -5411,8 +5431,4 @@\n-  \/\/ 8143067: Ensure that the adrp can reach the dest from anywhere within\n-  \/\/ the code cache so that if it is relocated we know it will still reach\n-  if (!force_movk && offset_high >= -(1<<20) && offset_low < (1<<20)) {\n-    _adrp(reg1, dest.target());\n-  } else {\n-    uint64_t target = (uint64_t)dest.target();\n-    uint64_t adrp_target\n-      = (target & 0xffffffffULL) | ((uint64_t)pc() & 0xffff00000000ULL);\n+  uint64_t target = (uint64_t)dest.target();\n+  uint64_t adrp_target = (target & 0xffffffffULL) | ((uint64_t)pc() & 0xffff00000000ULL);\n+  _adrp(reg1, (address)adrp_target);\n+  movk(reg1, target >> 32, 32);\n@@ -5420,3 +5436,0 @@\n-    _adrp(reg1, (address)adrp_target);\n-    movk(reg1, target >> 32, 32);\n-  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1380,1 +1380,2 @@\n-  void adrp(Register reg1, const Address &dest, uint64_t &byte_offset, bool force_movk = false);\n+  void adrp(Register reg1, const Address &dest, uint64_t &byte_offset);\n+  void adrp_movk(Register reg1, const Address &dest, uint64_t &byte_offset);\n@@ -1420,2 +1421,1 @@\n-    bool force_movk = true; \/\/ movk is important if the target can be more than 4GB away\n-    adrp(dest, const_addr, offset, force_movk);\n+    adrp_movk(dest, const_addr, offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  _mutable_data(nullptr),\n@@ -82,0 +83,1 @@\n+  _mutable_data_size(mutable_data_size),\n@@ -86,3 +88,1 @@\n-  _caller_must_gc_arguments(caller_must_gc_arguments),\n-  _mutable_data(nullptr),\n-  _mutable_data_size(mutable_data_size)\n+  _caller_must_gc_arguments(caller_must_gc_arguments)\n@@ -93,0 +93,1 @@\n+  assert(is_nmethod() || (cb->total_oop_size() + cb->total_metadata_size() == 0), \"must be nmethod\");\n@@ -115,0 +116,1 @@\n+  _mutable_data(nullptr),\n@@ -131,0 +133,4 @@\n+  if (_mutable_data != nullptr) {\n+    os::free(_mutable_data);\n+    _mutable_data = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-\/\/ Layout : continuous in the CodeCache\n+\/\/ Layout in the CodeCache:\n@@ -72,1 +72,0 @@\n-\/\/   - relocation\n@@ -75,1 +74,4 @@\n-\/\/   - data space\n+\/\/ Outside of the CodeCache:\n+\/\/   - mutable_data\n+\/\/     - relocation info\n+\/\/     - additional data for subclasses\n@@ -106,0 +108,1 @@\n+  address             _mutable_data;\n@@ -112,0 +115,1 @@\n+  int      _mutable_data_size;\n@@ -125,3 +129,0 @@\n-  address _mutable_data;\n-  int     _mutable_data_size;\n-\n@@ -175,4 +176,0 @@\n-  address mutable_data_begin() const          { return _mutable_data; }\n-  address mutable_data_end() const            { return _mutable_data + _mutable_data_size; }\n-  int mutable_data_size() const               { return _mutable_data_size; }\n-\n@@ -182,2 +179,0 @@\n-  relocInfo* relocation_begin() const         { return (relocInfo*)_mutable_data; }\n-  relocInfo* relocation_end() const           { return (relocInfo*)((address)relocation_begin() + _relocation_size); }\n@@ -189,0 +184,7 @@\n+  \/\/ code_end == content_end is true for all types of blobs for now, it is also checked in the constructor\n+\n+  address mutable_data_begin() const          { return _mutable_data; }\n+  address mutable_data_end() const            { return _mutable_data + _mutable_data_size; }\n+  int mutable_data_size() const               { return _mutable_data_size; }\n+  relocInfo* relocation_begin() const         { return (relocInfo*)_mutable_data; }\n+  relocInfo* relocation_end() const           { return (relocInfo*)((address)relocation_begin() + _relocation_size); }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1080,2 +1080,2 @@\n-static int required_mutable_data_space(CodeBuffer* code_buffer,\n-                                       int jvmci_data_size = 0) {\n+static int required_mutable_data_size(CodeBuffer* code_buffer,\n+                                      int jvmci_data_size = 0) {\n@@ -1112,1 +1112,1 @@\n-    int mutable_data_size = required_mutable_data_space(code_buffer);\n+    int mutable_data_size = required_mutable_data_size(code_buffer);\n@@ -1183,1 +1183,1 @@\n-  int mutable_data_size = required_mutable_data_space(code_buffer\n+  int mutable_data_size = required_mutable_data_size(code_buffer\n@@ -2146,4 +2146,0 @@\n-  if (_mutable_data != blob_end()) {\n-    os::free(_mutable_data);\n-    _mutable_data = blob_end(); \/\/ Valid not null address\n-  }\n@@ -3096,1 +3092,1 @@\n-                                             immutable_data_size());\n+                                             mutable_data_size());\n@@ -3139,4 +3135,0 @@\n-  if (mutable_data_size() > 0)  st->print_cr(\" mutable data   [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(mutable_data_begin()),\n-                                             p2i(mutable_data_end()),\n-                                             mutable_data_size());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -137,19 +137,21 @@\n-\/\/  - header                 (the nmethod structure)\n-\/\/  - constant part          (doubles, longs and floats used in nmethod)\n-\/\/  - oop table\n-\/\/  [Code]\n-\/\/  - code body\n-\/\/  - exception handler\n-\/\/  - stub code\n-\/\/  [Debugging information]\n-\/\/  - oop array\n-\/\/  - data array\n-\/\/  - pcs\n-\/\/  [Exception handler table]\n-\/\/  - handler entry point array\n-\/\/  [Implicit Null Pointer exception table]\n-\/\/  - implicit null table array\n-\/\/  [Speculations]\n-\/\/  - encoded speculations array\n-\/\/  [JVMCINMethodData]\n-\/\/  - meta data for JVMCI compiled nmethod\n+\/\/  - Header                 (the nmethod structure)\n+\/\/  - Constant part          (doubles, longs and floats used in nmethod)\n+\/\/  - Code part:\n+\/\/    - Code body\n+\/\/    - Exception handler\n+\/\/    - Stub code\n+\/\/\n+\/\/ As a CodeBlob, an nmethod references [mutable data] allocated on the C heap:\n+\/\/  - CodeBlob relocation data\n+\/\/  - OOP table\n+\/\/  - Metainfo\n+\/\/  - JVMCI data\n+\/\/\n+\/\/ An nmethod references [immutable data] allocated on C heap:\n+\/\/  - Dependency assertions data\n+\/\/  - Implicit null table array\n+\/\/  - Handler entry point array\n+\/\/  - Debugging information:\n+\/\/    - Scopes data array\n+\/\/    - Scopes pcs array\n+\/\/  - JVMCI speculations array\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"}]}