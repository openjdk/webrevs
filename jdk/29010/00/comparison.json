{"files":[{"patch":"@@ -455,1 +455,1 @@\n-                address = IOUtil.bufferAddress(buf) + pos;\n+                address = IOUtil.bufferAddress(buf);\n@@ -643,1 +643,1 @@\n-                address = IOUtil.bufferAddress(buf) + pos;\n+                address = IOUtil.bufferAddress(buf);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousFileChannelImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374382\n+ * @summary Test AsynchronousFileChannel.read\/write with ByteBuffers and varied buffer positions\n+ * @run junit\/othervm BufferPositions\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousFileChannel;\n+import java.nio.channels.CompletionHandler;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Stream;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class BufferPositions {\n+\n+    private static final int BUF_SIZE = 32;\n+\n+    \/**\n+     * The buffers to test.\n+     *\/\n+    static Stream<ByteBuffer> buffers() {\n+        List<ByteBuffer> buffers = List.of(\n+                ByteBuffer.allocate(BUF_SIZE),\n+                ByteBuffer.allocateDirect(BUF_SIZE),\n+                ByteBuffer.wrap(new byte[BUF_SIZE]),\n+                Arena.global().allocate(BUF_SIZE).asByteBuffer(),\n+                Arena.ofAuto().allocate(BUF_SIZE).asByteBuffer(),\n+                Arena.ofShared().allocate(BUF_SIZE).asByteBuffer()\n+        );\n+        Stream<ByteBuffer> slices = buffers.stream()\n+                .map(bb -> bb.slice(1, bb.capacity() - 1));\n+        return Stream.concat(buffers.stream(), slices);\n+    }\n+\n+    \/**\n+     * Test using an AsynchronousFileChannel to read bytes into the given buffer.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"buffers\")\n+    void testRead(ByteBuffer bb) throws Exception {\n+        Path file = Files.createTempFile(Path.of(\".\"), \"test\", \"dat\");\n+\n+        \/\/ populate temp file\n+        int size = bb.capacity();\n+        byte[] contents = new byte[size];\n+        for (int i = 0; i < size; i++) {\n+            contents[i] = (byte)(i + 1);\n+        }\n+        Files.write(file, contents);\n+\n+        \/\/ read bytes using the buffer as the destination and all possible buffer positions\n+        try (AsynchronousFileChannel ch = AsynchronousFileChannel.open(file, READ)) {\n+            for (int filePosition = 0; filePosition < size; filePosition++) {\n+                for (int bufPos = 0; bufPos < size; bufPos++) {\n+                    \/\/ read one byte\n+                    bb.position(bufPos);\n+                    bb.limit(bufPos + 1);\n+                    int n = read(ch, filePosition, bb);\n+                    assertEquals(1, n);\n+                    assertEquals(bufPos + 1, bb.position());\n+                    assertEquals(contents[filePosition], bb.get(bufPos));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test using an AsynchronousFileChannel to write bytes from the given buffer.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"buffers\")\n+    void testWrite(ByteBuffer bb) throws Exception {\n+        Path file = Files.createTempFile(Path.of(\".\"), \"test\", \"dat\");\n+\n+        \/\/ populate temp file, all zeros\n+        int size = bb.capacity();\n+        byte[] contents = new byte[size];\n+        Files.write(file, contents);\n+\n+        \/\/ write bytes using the buffer as the source and all possible buffer positions\n+        try (AsynchronousFileChannel ch = AsynchronousFileChannel.open(file, READ, WRITE)) {\n+            for (int filePosition = 0; filePosition < size; filePosition++) {\n+                for (int bufPos = 0; bufPos < size; bufPos++) {\n+                    \/\/ write one byte\n+                    byte b = (byte) ThreadLocalRandom.current().nextInt();\n+                    bb.position(bufPos);\n+                    bb.limit(bufPos + 1);\n+                    bb.put(bufPos, b);\n+                    int n = write(ch, filePosition, bb);\n+                    assertEquals(1, n);\n+                    assertEquals(bufPos + 1, bb.position());\n+                    assertEquals(b, bb.get(bufPos));\n+\n+                    \/\/ check byte was written at the expected file position\n+                    ByteBuffer dst = ByteBuffer.allocate(1);\n+                    int nread = ch.read(dst, filePosition).get();\n+                    assertEquals(1, nread);\n+                    assertEquals(b, dst.get(0));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Reads a byte from a channel into the given buffer, at the given file position.\n+     *\/\n+    private int read(AsynchronousFileChannel ch, long position, ByteBuffer bb) throws Exception {\n+        if (ThreadLocalRandom.current().nextBoolean()) {\n+            return ch.read(bb, position).get();\n+        } else {\n+            var handler = new Handler<Integer>();\n+            ch.read(bb, position, null, handler);\n+            return handler.result();\n+        }\n+    }\n+\n+    \/**\n+     * Writes a byte to a channel from the given buffer, at the given file position.\n+     *\/\n+    private int write(AsynchronousFileChannel ch, long position, ByteBuffer bb) throws Exception {\n+        if (ThreadLocalRandom.current().nextBoolean()) {\n+            return ch.write(bb, position).get();\n+        } else {\n+            var handler = new Handler<Integer>();\n+            ch.write(bb, position, null, handler);\n+            return handler.result();\n+        }\n+    }\n+\n+    \/**\n+     * CompletionHandler that defines a method to await the result of an I\/O operation.\n+     *\/\n+    private static class Handler<T> implements CompletionHandler<T, Void> {\n+        T result;\n+        Throwable ex;\n+        final CountDownLatch done = new CountDownLatch(1);\n+\n+        @Override\n+        public void completed(T result, Void att) {\n+            this.result = result;\n+            done.countDown();\n+        }\n+\n+        @Override\n+        public void failed(Throwable ex, Void att) {\n+            this.ex = ex;\n+            done.countDown();\n+        }\n+\n+        T result() throws InterruptedException {\n+            done.await();\n+            assertNull(ex);\n+            return result;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousFileChannel\/BufferPositions.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"}]}