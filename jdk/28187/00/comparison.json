{"files":[{"patch":"@@ -4,1 +4,0 @@\n-\/\/ Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1198,0 +1197,1 @@\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1200,0 +1200,4 @@\n+  static uint size_exception_handler() {\n+    return MacroAssembler::far_codestub_branch_size();\n+  }\n+\n@@ -1201,1 +1205,1 @@\n-    \/\/ count one branch instruction and one far call instruction sequence\n+    \/\/ count one adr and one far branch instruction\n@@ -2260,0 +2264,19 @@\n+\/\/ Emit exception handler code.\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n+{\n+  \/\/ mov rscratch1 #exception_blob_entry_point\n+  \/\/ br rscratch1\n+  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n+  \/\/ That's why we must use the macroassembler to generate a handler.\n+  address base = __ start_a_stub(size_exception_handler());\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n+  int offset = __ offset();\n+  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n+  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n+  __ end_a_stub();\n+  return offset;\n+}\n+\n@@ -2270,1 +2293,0 @@\n-\n@@ -2272,3 +2294,0 @@\n-  Label start;\n-  __ bind(start);\n-  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2276,2 +2295,2 @@\n-  int entry_offset = __ offset();\n-  __ b(start);\n+  __ adr(lr, __ pc());\n+  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2281,1 +2300,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -452,8 +452,2 @@\n-  Label start;\n-  __ bind(start);\n-\n-  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n-\n-  int entry_offset = __ offset();\n-  __ b(start);\n-\n+  __ adr(lr, pc());\n+  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -463,1 +457,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _deopt_handler_size = 4 * NativeInstruction::instruction_size\n+    _deopt_handler_size = 7 * NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,0 +397,6 @@\n+#ifdef ASSERT\n+static bool is_movk_to_zr(uint32_t insn) {\n+  return ((insn & 0xffe0001f) == 0xf280001f);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -529,5 +529,0 @@\n-private:\n-  static bool is_movk_to_zr(uint32_t insn) {\n-    return ((insn & 0xffe0001f) == 0xf280001f);\n-  }\n-\n@@ -536,11 +531,6 @@\n-    \/\/ Check the first instruction is NOP.\n-    if (is_nop()) {\n-      uint32_t insn = *(uint32_t*)addr_at(4);\n-      \/\/ Check next instruction is MOVK zr, xx.\n-      \/\/ These instructions only ever appear together in a post-call\n-      \/\/ NOP, so it's unnecessary to check that the third instruction is\n-      \/\/ a MOVK as well.\n-      return is_movk_to_zr(insn);\n-    }\n-\n-    return false;\n+    uint64_t insns = *(uint64_t*)addr_at(0);\n+    \/\/ Check for two instructions: nop; movk zr, xx\n+    \/\/ These instructions only ever appear together in a post-call\n+    \/\/ NOP, so it's unnecessary to check that the third instruction is\n+    \/\/ a MOVK as well.\n+    return (insns & 0xffe0001fffffffff) == 0xf280001fd503201f;\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -263,0 +263,2 @@\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in aarch64.ad file)\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -110,0 +111,5 @@\n+  static uint size_exception_handler() {\n+    return ( 3 * 4 );\n+  }\n+\n+\n@@ -873,0 +879,20 @@\n+\/\/ Emit exception handler code.\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n+  address base = __ start_a_stub(size_exception_handler());\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n+\n+  int offset = __ offset();\n+\n+  \/\/ OK to trash LR, because exception blob will kill it\n+  __ jump(OptoRuntime::exception_blob()->entry_point(), relocInfo::runtime_call_type, LR_tmp);\n+\n+  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n+\n+  __ end_a_stub();\n+\n+  return offset;\n+}\n+\n@@ -883,0 +909,1 @@\n+  address deopt_pc = __ pc();\n@@ -884,3 +911,5 @@\n-  Label start;\n-  __ bind(start);\n-\n+  __ sub(SP, SP, wordSize); \/\/ make room for saved PC\n+  __ push(LR); \/\/ save LR that may be live when we get here\n+  __ mov_relative_address(LR, deopt_pc);\n+  __ str(LR, Address(SP, wordSize)); \/\/ save deopt PC\n+  __ pop(LR); \/\/ restore LR\n@@ -889,10 +918,0 @@\n-  int entry_offset = __ offset();\n-  address deopt_pc = __ pc();\n-  \/\/ Preserve R0 and reserve space for the address of the entry point\n-  __ push(RegisterSet(R0) | RegisterSet(R1));\n-  \/\/ Store the entry point address\n-  __ mov_relative_address(R0, deopt_pc);\n-  __ str(R0, Address(SP, wordSize));\n-  __ pop(R0); \/\/ restore R0\n-  __ b(start);\n-\n@@ -902,1 +921,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -275,6 +275,0 @@\n-  Label start;\n-  __ bind(start);\n-\n-  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n-\n-  int entry_offset = __ offset();\n@@ -283,1 +277,1 @@\n-  __ b(start);\n+  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n@@ -288,1 +282,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    _deopt_handler_size = 20\n+    _deopt_handler_size = 16\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,2 @@\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in sparc.ad file)\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,3 +267,0 @@\n-  Label start;\n-\n-  __ bind(start);\n@@ -271,2 +268,0 @@\n-  int entry_offset = __ offset();\n-  __ b(start);\n@@ -277,1 +272,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  _deopt_handler_size = MacroAssembler::bl64_patchable_size + BytesPerInstWord\n+  _deopt_handler_size = MacroAssembler::bl64_patchable_size\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2091,0 +2091,1 @@\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2093,0 +2094,5 @@\n+  static uint size_exception_handler() {\n+    \/\/ The exception_handler is a b64_patchable.\n+    return MacroAssembler::b64_patchable_size;\n+  }\n+\n@@ -2095,1 +2101,1 @@\n-    return MacroAssembler::bl64_patchable_size + BytesPerInstWord;\n+    return MacroAssembler::bl64_patchable_size;\n@@ -2111,0 +2117,16 @@\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n+  address base = __ start_a_stub(size_exception_handler());\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n+\n+  int offset = __ offset();\n+  __ b64_patchable((address)OptoRuntime::exception_blob()->content_begin(),\n+                       relocInfo::runtime_call_type);\n+  assert(__ offset() - offset == (int)size_exception_handler(), \"must be fixed size\");\n+  __ end_a_stub();\n+\n+  return offset;\n+}\n+\n@@ -2121,4 +2143,0 @@\n-\n-  Label start;\n-  __ bind(start);\n-\n@@ -2127,5 +2145,0 @@\n-\n-  int entry_offset = __ offset();\n-\n-  __ b(start);\n-\n@@ -2135,1 +2148,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+                         int return_pc_adjustment,\n@@ -264,0 +265,1 @@\n+                         int return_pc_adjustment,\n@@ -272,0 +274,1 @@\n+  \/\/ If return_pc_adjustment != 0 adjust the return pc by return_pc_adjustment.\n@@ -305,1 +308,1 @@\n-    case return_pc_is_pre_saved: break;\n+    case return_pc_is_pre_saved: assert(return_pc_adjustment == 0, \"unsupported\"); break;\n@@ -310,0 +313,3 @@\n+    if (return_pc_adjustment != 0) {\n+      __ addi(R31, R31, return_pc_adjustment);\n+    }\n@@ -2904,0 +2910,2 @@\n+  \/\/ So currently SR_LR points behind the call in the deopt handler.\n+  \/\/ We adjust it such that it points to the start of the deopt handler.\n@@ -2907,0 +2915,4 @@\n+  \/\/ We can't grab a free register here, because all registers may\n+  \/\/ contain live values, so let the RegisterSaver do the adjustment\n+  \/\/ of the return pc.\n+  const int return_pc_adjustment_no_exception = -MacroAssembler::bl64_patchable_size;\n@@ -2913,0 +2925,1 @@\n+                                                                   return_pc_adjustment_no_exception,\n@@ -2947,0 +2960,1 @@\n+                                                             \/*return_pc_adjustment_exception=*\/ 0,\n@@ -2964,0 +2978,1 @@\n+                                                             \/*return_pc_adjustment_reexecute=*\/ 0,\n@@ -3254,0 +3269,1 @@\n+                                                                   \/*return_pc_adjustment=*\/0,\n@@ -3354,0 +3370,1 @@\n+                                                                   \/*return_pc_adjustment*\/ 0,\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -380,8 +380,2 @@\n-  Label start;\n-  __ bind(start);\n-\n-  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n-\n-  int entry_offset = __ offset();\n-  __ j(start);\n-\n+  __ auipc(ra, 0);\n+  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -391,1 +385,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    \/\/ far_call (2) + j (1)\n+    \/\/ auipc (1) + far_jump (2)\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1052,0 +1052,1 @@\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1054,0 +1055,4 @@\n+  static uint size_exception_handler() {\n+    return MacroAssembler::far_branch_size();\n+  }\n+\n@@ -1055,1 +1060,1 @@\n-    \/\/ count far call + j\n+    \/\/ count auipc + far branch\n@@ -1836,0 +1841,19 @@\n+\/\/ Emit exception handler code.\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n+{\n+  \/\/ auipc t1, #exception_blob_entry_point\n+  \/\/ jr (offset)t1\n+  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n+  \/\/ That's why we must use the macroassembler to generate a handler.\n+  address base = __ start_a_stub(size_exception_handler());\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n+  int offset = __ offset();\n+  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n+  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n+  __ end_a_stub();\n+  return offset;\n+}\n+\n@@ -1846,7 +1870,2 @@\n-  Label start;\n-  __ bind(start);\n-\n-  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n-\n-  int entry_offset = __ offset();\n-  __ j(start);\n+  __ auipc(ra, 0);\n+  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -1856,1 +1875,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -252,0 +252,2 @@\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in riscv.ad file)\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,7 +275,1 @@\n-  }\n-\n-  int offset = code_offset();\n-\n-  Label start;\n-  __ bind(start);\n-\n+  }  int offset = code_offset();\n@@ -285,5 +279,0 @@\n-\n-  int entry_offset = __ offset();\n-\n-  __ z_bru(start);\n-\n@@ -293,1 +282,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in s390.ad file)\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1652,0 +1652,1 @@\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1654,0 +1655,4 @@\n+  static uint size_exception_handler() {\n+    return NativeJump::max_instruction_size();\n+  }\n+\n@@ -1655,1 +1660,1 @@\n-    return NativeCall::max_instruction_size() + MacroAssembler::jump_pcrelative_size();\n+    return NativeCall::max_instruction_size();\n@@ -1670,0 +1675,37 @@\n+\/\/ This exception handler code snippet is placed after the method's\n+\/\/ code. It is the return point if an exception occurred. it jumps to\n+\/\/ the exception blob.\n+\/\/\n+\/\/ If the method gets deoptimized, the method and this code snippet\n+\/\/ get patched.\n+\/\/\n+\/\/ 1) Trampoline code gets patched into the end of this exception\n+\/\/   handler. the trampoline code jumps to the deoptimization blob.\n+\/\/\n+\/\/ 2) The return address in the method's code will get patched such\n+\/\/   that it jumps to the trampoline.\n+\/\/\n+\/\/ 3) The handler will get patched such that it does not jump to the\n+\/\/   exception blob, but to an entry in the deoptimization blob being\n+\/\/   aware of the exception.\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n+  Register temp_reg = Z_R1;\n+\n+  address base = __ start_a_stub(size_exception_handler());\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;          \/\/ CodeBuffer::expand failed\n+  }\n+\n+  int offset = __ offset();\n+  \/\/ Use unconditional pc-relative jump with 32-bit range here.\n+  __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()->content_begin());\n+  __ z_br(temp_reg);\n+\n+  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n+\n+  __ end_a_stub();\n+\n+  return offset;\n+}\n+\n@@ -1681,3 +1723,0 @@\n-  Label start;\n-  __ bind(start);\n-\n@@ -1688,5 +1727,0 @@\n-\n-  int entry_offset = __ offset();\n-\n-  __ z_bru(start);\n-\n@@ -1696,1 +1730,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2547,1 +2547,2 @@\n-  \/\/ Z_R14 points to the entry point of the deopt handler.\n+  \/\/ Z_R14 points behind the call in the deopt handler. We adjust\n+  \/\/ it such that it points to the start of the deopt handler.\n@@ -2551,0 +2552,3 @@\n+  \/\/ The (int) cast is necessary, because -((unsigned int)14)\n+  \/\/ is an unsigned int.\n+  __ add2reg(Z_R14, -(int)NativeCall::max_instruction_size());\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+  InternalAddress here(__ pc());\n@@ -454,9 +455,2 @@\n-  Label start;\n-  __ bind(start);\n-\n-  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n-\n-  int entry_offset = __ offset();\n-\n-  __ jmp(start);\n-\n+  __ pushptr(here.addr(), rscratch1);\n+  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -466,1 +460,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    _deopt_handler_size = 10\n+    _deopt_handler_size = 17\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+\/\/ Using exception blob, this code is jumped from a compiled method.\n+\/\/ (see emit_exception_handler in x86_64.ad file)\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2770,0 +2770,1 @@\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2772,0 +2773,9 @@\n+  static uint size_exception_handler() {\n+    \/\/ NativeCall instruction size is the same as NativeJump.\n+    \/\/ exception handler starts out as jump and can be patched to\n+    \/\/ a call be deoptimization.  (4932387)\n+    \/\/ Note that this value is also credited (in output.cpp) to\n+    \/\/ the size of the code section.\n+    return NativeJump::instruction_size;\n+  }\n+\n@@ -2773,2 +2783,2 @@\n-    \/\/ one call and one jmp.\n-    return 10;\n+    \/\/ three 5 byte instructions plus one move for unreachable address.\n+    return 15+3;\n@@ -2866,0 +2876,18 @@\n+\/\/ Emit exception handler code.\n+\/\/ Stuff framesize into a register and call a VM stub routine.\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n+\n+  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n+  \/\/ That's why we must use the macroassembler to generate a handler.\n+  address base = __ start_a_stub(size_exception_handler());\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n+  int offset = __ offset();\n+  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n+  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n+  __ end_a_stub();\n+  return offset;\n+}\n+\n@@ -2878,4 +2906,4 @@\n-  Label start;\n-  __ bind(start);\n-\n-  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  address the_pc = (address) __ pc();\n+  Label next;\n+  \/\/ push a \"the_pc\" on the stack without destroying any registers\n+  \/\/ as they all may be live.\n@@ -2883,3 +2911,5 @@\n-  int entry_offset = __ offset();\n-\n-  __ jmp(start);\n+  \/\/ push address of \"next\"\n+  __ call(next, relocInfo::none); \/\/ reloc none is fine since it is a disp32\n+  __ bind(next);\n+  \/\/ adjust it so it matches \"the_pc\"\n+  __ subptr(Address(rsp, 0), __ offset() - offset);\n@@ -2887,0 +2917,1 @@\n+  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2889,1 +2920,1 @@\n-  return entry_offset;\n+  return offset;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-        address deopt = nm->deopt_handler_entry();\n+        address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2798,1 +2798,1 @@\n-          address deopt = nm->deopt_handler_entry();\n+          address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1060,3 +1060,1 @@\n-\n-    assert(compiler->type() == compiler_c2 ||\n-           offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n+    assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1305,1 +1305,1 @@\n-    _deopt_handler_entry_offset    = 0;\n+    _deopt_handler_offset    = 0;\n@@ -1445,1 +1445,1 @@\n-  _deopt_handler_entry_offset   = nm._deopt_handler_entry_offset;\n+  _deopt_handler_offset         = nm._deopt_handler_offset;\n@@ -1707,1 +1707,1 @@\n-        _deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n+        _deopt_handler_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -1709,1 +1709,1 @@\n-        _deopt_handler_entry_offset    = -1;\n+        _deopt_handler_offset    = -1;\n@@ -1715,0 +1715,1 @@\n+      assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must be set\");\n@@ -1717,10 +1718,2 @@\n-      bool has_exception_handler = (offsets->value(CodeOffsets::Exceptions) != -1);\n-      assert(has_exception_handler == (compiler->type() != compiler_c2),\n-             \"C2 compiler doesn't provide exception handler stub code.\");\n-      if (has_exception_handler) {\n-        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n-      } else {\n-        _exception_offset = -1;\n-      }\n-\n-      _deopt_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      _deopt_handler_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -4034,1 +4027,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n+  if (JVMCI_ONLY(_deopt_handler_offset != -1 &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-  int _deopt_handler_entry_offset;\n+  int _deopt_handler_offset;\n@@ -620,1 +620,1 @@\n-  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n+  address deopt_handler_begin   () const { return           header_begin() + _deopt_handler_offset    ; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return pc == deopt_handler_entry();\n+  return pc == deopt_handler_begin();\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1350,0 +1350,1 @@\n+  int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; \/\/ add marginal slop for handler\n@@ -1355,1 +1356,1 @@\n-    code_req = const_req = stub_req = deopt_handler_req = 0x10;  \/\/ force expansion\n+    code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  \/\/ force expansion\n@@ -1362,0 +1363,1 @@\n+          exception_handler_req +\n@@ -1790,0 +1792,2 @@\n+    \/\/ Emit the exception handler code.\n+    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -501,3 +501,0 @@\n-  if (exec_mode == Unpack_deopt) {\n-    assert(deoptee.is_deoptimized_frame(), \"frame is not marked for deoptimization\");\n-  }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    return nm->deopt_handler_entry() - pc_return_offset;\n+    return nm->deopt_handler_begin() - pc_return_offset;\n@@ -358,1 +358,1 @@\n-  address deopt = nm->deopt_handler_entry();\n+  address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,3 +90,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/runtime.hpp\"\n-#endif\n@@ -607,5 +604,0 @@\n-#ifdef COMPILER2\n-      if (nm->compiler_type() == compiler_c2) {\n-        return OptoRuntime::exception_blob()->entry_point();\n-      }\n-#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -538,1 +538,1 @@\n-  nonstatic_field(nmethod,                     _deopt_handler_entry_offset,                   int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_handler_offset,                         int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  private static CIntegerField deoptHandlerEntryOffsetField;\n+  private static CIntegerField deoptHandlerOffsetField;\n@@ -89,1 +89,1 @@\n-    deoptHandlerEntryOffsetField       = type.getCIntegerField(\"_deopt_handler_entry_offset\");\n+    deoptHandlerOffsetField            = type.getCIntegerField(\"_deopt_handler_offset\");\n@@ -124,10 +124,10 @@\n-  public Address constantsBegin()             { return contentBegin();                                          }\n-  public Address constantsEnd()               { return codeBegin();                                             }\n-  public Address instsBegin()                 { return codeBegin();                                             }\n-  public Address instsEnd()                   { return headerBegin().addOffsetTo(getStubOffset());              }\n-  public Address exceptionBegin()             { return headerBegin().addOffsetTo(getExceptionOffset());         }\n-  public Address deoptHandlerEntry()          { return headerBegin().addOffsetTo(getDeoptHandlerEntryOffset()); }\n-  public Address stubBegin()                  { return headerBegin().addOffsetTo(getStubOffset());              }\n-  public Address stubEnd()                    { return dataBegin();                                             }\n-  public Address oopsBegin()                  { return dataBegin();                                             }\n-  public Address oopsEnd()                    { return dataEnd();                                               }\n+  public Address constantsBegin()             { return contentBegin();                                     }\n+  public Address constantsEnd()               { return codeBegin();                                        }\n+  public Address instsBegin()                 { return codeBegin();                                        }\n+  public Address instsEnd()                   { return headerBegin().addOffsetTo(getStubOffset());         }\n+  public Address exceptionBegin()             { return headerBegin().addOffsetTo(getExceptionOffset());    }\n+  public Address deoptHandlerBegin()          { return headerBegin().addOffsetTo(getDeoptHandlerOffset()); }\n+  public Address stubBegin()                  { return headerBegin().addOffsetTo(getStubOffset());         }\n+  public Address stubEnd()                    { return dataBegin();                                        }\n+  public Address oopsBegin()                  { return dataBegin();                                        }\n+  public Address oopsEnd()                    { return dataEnd();                                          }\n@@ -265,1 +265,1 @@\n-  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerEntry(); }\n+  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }\n@@ -493,1 +493,1 @@\n-  private int getDeoptHandlerEntryOffset()      { return (int) deoptHandlerEntryOffsetField     .getValue(addr); }\n+  private int getDeoptHandlerOffset()           { return (int) deoptHandlerOffsetField          .getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        if (pc.equals(nm.deoptHandlerEntry())) {\n+        if (pc.equals(nm.deoptHandlerBegin())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright 2025 Arm Limited and\/or its affiliates.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test id=vthread-deopt-c1\n- * @summary Deoptimization test for virtual threads (C1)\n- * @requires vm.continuations\n- * @requires vm.compiler1.enabled\n- * @requires vm.opt.TieredStopAtLevel != 0\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   -XX:-BackgroundCompilation\n- *                   -XX:TieredStopAtLevel=1\n- *                   Deoptimization\n- *\/\n-\n-\/**\n- * @test id=vthread-deopt-c2\n- * @summary Deoptimization test for virtual threads (C2)\n- * @requires vm.continuations\n- * @requires vm.compiler2.enabled\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   -XX:-BackgroundCompilation\n- *                   -XX:-TieredCompilation\n- *                   Deoptimization\n- *\/\n-\n-import java.lang.reflect.Method;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.BrokenBarrierException;\n-import java.util.concurrent.CyclicBarrier;\n-import java.util.Objects;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class Deoptimization {\n-    static final WhiteBox white_box = WhiteBox.getWhiteBox();\n-\n-    static class TestTask implements Runnable {\n-        CyclicBarrier start_barrier = null;\n-        AtomicInteger completed_number = new AtomicInteger(0);\n-\n-        public void reset(int barrier_parties) {\n-            start_barrier = new CyclicBarrier(barrier_parties);\n-            completed_number.set(0);\n-        }\n-\n-        public int getNumberWaiting() {\n-            return start_barrier.getNumberWaiting();\n-        }\n-\n-        public int getNumberCompleted() {\n-            return completed_number.get();\n-        }\n-\n-        public void await() throws BrokenBarrierException, InterruptedException {\n-            start_barrier.await();\n-        }\n-\n-        public void run() {\n-            try {\n-                await();\n-            } catch(BrokenBarrierException e) {\n-                return;\n-            } catch(InterruptedException e) {\n-                return;\n-            }\n-\n-            completed_number.getAndIncrement();\n-        }\n-    }\n-\n-    static void test(TestTask task, Method method, int vthreads_num) throws Exception {\n-        task.reset(vthreads_num + 1 \/* 1 for the main thread *\/);\n-\n-        Thread[] vthreads = new Thread[vthreads_num];\n-        for (int i = 0; i < vthreads_num; i++) {\n-            vthreads[i] = Thread.startVirtualThread(task);\n-        }\n-\n-        while (task.getNumberWaiting() != vthreads_num) {\n-            Thread.onSpinWait();\n-        }\n-\n-        if (method != null) {\n-            if (!white_box.isMethodCompiled(method, false)) {\n-                throw new Error(\"Unexpectedly, it is not compiled.\");\n-            }\n-\n-            white_box.deoptimizeMethod(method);\n-\n-            if (white_box.isMethodCompiled(method, false)) {\n-                throw new Error(\"Unexpectedly, it is compiled.\");\n-            }\n-        }\n-\n-        task.await();\n-\n-        for (int i = 0; i < vthreads_num; i++) {\n-            vthreads[i].join();\n-        }\n-\n-        if (task.getNumberCompleted() != vthreads_num) {\n-            throw new Error(\"Some threads didn't reach completion\");\n-        }\n-    }\n-\n-    static int getIntegerOption(String option_name) {\n-        Object option_object = white_box.getVMFlag(option_name);\n-        String option_string = Objects.toString(option_object);\n-        return Integer.parseInt(option_string);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        int tiered_stop_at_level = getIntegerOption(\"TieredStopAtLevel\");\n-\n-        Method method_run = TestTask.class.getMethod(\"run\");\n-        white_box.testSetDontInlineMethod(method_run, true);\n-\n-        Method method_await = TestTask.class.getMethod(\"await\");\n-        white_box.testSetDontInlineMethod(method_await, true);\n-\n-        TestTask task = new TestTask();\n-\n-        \/\/ Warm-up\n-        test(task, null, 2);\n-\n-        white_box.enqueueMethodForCompilation(method_run, tiered_stop_at_level);\n-\n-        \/\/ Deoptimization test\n-        test(task, method_run, 10000);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/Deoptimization.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"}]}