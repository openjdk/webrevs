{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1227,5 +1227,4 @@\n-     protected boolean textOut(Graphics g, String str, float x, float y,\n-                               Font mLastFont, FontRenderContext frc,\n-                               float width) {\n-        boolean didText = true;\n-\n+    protected boolean textOut(Graphics g, String str, float x, float y,\n+                              Font mLastFont, FontRenderContext frc,\n+                              float width) {\n+        \/* If we don't have fonts, use 2D path instead. *\/\n@@ -1234,12 +1233,62 @@\n-        } else {\n-            prepDrawing();\n-\n-            \/* On-screen drawString renders most control chars as the missing\n-             * glyph and have the non-zero advance of that glyph.\n-             * Exceptions are \\t, \\n and \\r which are considered zero-width.\n-             * Postscript handles control chars mostly as a missing glyph.\n-             * But we use 'ashow' specifying a width for the string which\n-             * assumes zero-width for those three exceptions, and Postscript\n-             * tries to squeeze the extra char in, with the result that the\n-             * glyphs look compressed or even overlap.\n-             * So exclude those control chars from the string sent to PS.\n+        }\n+\n+        \/* On-screen drawString renders most control chars as the missing\n+         * glyph and have the non-zero advance of that glyph.\n+         * Exceptions are \\t, \\n and \\r which are considered zero-width.\n+         * Postscript handles control chars mostly as a missing glyph.\n+         * But we use 'ashow' specifying a width for the string which\n+         * assumes zero-width for those three exceptions, and Postscript\n+         * tries to squeeze the extra char in, with the result that the\n+         * glyphs look compressed or even overlap.\n+         * So exclude those control chars from the string sent to PS.\n+         *\/\n+        str = removeControlChars(str);\n+        if (str.isEmpty()) {\n+            return true;\n+        }\n+\n+        \/* If AWT can't convert all chars, use 2D path instead. *\/\n+        FontAccess access = FontAccess.getFontAccess();\n+        PlatformFont peer = (PlatformFont) access.getFontPeer(mLastFont);\n+        CharsetString[] acs = peer.makeMultiCharsetString(str, false);\n+        if (acs == null) {\n+            return false;\n+        }\n+\n+        \/* Get an array of indices into our PostScript name\n+         * table. If all of the runs can not be converted\n+         * to PostScript fonts then null is returned and\n+         * we'll want to fall back to printing the text\n+         * as shapes.\n+         *\/\n+        int[] psFonts = getPSFontIndexArray(mLastFont, acs);\n+        if (psFonts == null) {\n+            return false;\n+        }\n+\n+        \/* Prepare graphics context, now that we know we can handle the text. *\/\n+        prepDrawing();\n+\n+        \/* Draw each string segment. *\/\n+        for (int i = 0; i < acs.length; i++){\n+            CharsetString cs = acs[i];\n+            CharsetEncoder fontCS = cs.fontDescriptor.encoder;\n+\n+            StringBuilder nativeStr = new StringBuilder();\n+            byte[] strSeg = new byte[cs.length * 2];\n+            int len = 0;\n+            try {\n+                ByteBuffer bb = ByteBuffer.wrap(strSeg);\n+                fontCS.encode(CharBuffer.wrap(cs.charsetChars,\n+                                              cs.offset,\n+                                              cs.length),\n+                                              bb, true);\n+                bb.flip();\n+                len = bb.limit();\n+            } catch (IllegalStateException | CoderMalfunctionError xx){\n+                continue;\n+            }\n+            \/* The width to fit to may either be specified,\n+             * or calculated. Specifying by the caller is only\n+             * valid if the text does not need to be decomposed\n+             * into multiple calls.\n@@ -1247,2 +1296,14 @@\n-            str = removeControlChars(str);\n-            if (str.length() == 0) {\n+            float desiredWidth;\n+            if (acs.length == 1 && width != 0f) {\n+                desiredWidth = width;\n+            } else {\n+                Rectangle2D r2d =\n+                    mLastFont.getStringBounds(cs.charsetChars,\n+                                              cs.offset,\n+                                              cs.offset+cs.length,\n+                                              frc);\n+                desiredWidth = (float)r2d.getWidth();\n+            }\n+            \/* unprintable chars had width of 0, causing a PS error\n+             *\/\n+            if (desiredWidth == 0) {\n@@ -1251,6 +1312,14 @@\n-            PlatformFont peer = (PlatformFont) FontAccess.getFontAccess()\n-                                                         .getFontPeer(mLastFont);\n-            CharsetString[] acs = peer.makeMultiCharsetString(str, false);\n-            if (acs == null) {\n-                \/* AWT can't convert all chars so use 2D path *\/\n-                return false;\n+            nativeStr.append('<');\n+            for (int j = 0; j < len; j++){\n+                byte b = strSeg[j];\n+                \/\/ to avoid encoding conversion with println()\n+                String hexS = Integer.toHexString(b);\n+                int length = hexS.length();\n+                if (length > 2) {\n+                    hexS = hexS.substring(length - 2, length);\n+                } else if (length == 1) {\n+                    hexS = \"0\" + hexS;\n+                } else if (length == 0) {\n+                    hexS = \"00\";\n+                }\n+                nativeStr.append(hexS);\n@@ -1258,65 +1327,2 @@\n-            \/* Get an array of indices into our PostScript name\n-             * table. If all of the runs can not be converted\n-             * to PostScript fonts then null is returned and\n-             * we'll want to fall back to printing the text\n-             * as shapes.\n-             *\/\n-            int[] psFonts = getPSFontIndexArray(mLastFont, acs);\n-            if (psFonts != null) {\n-\n-                for (int i = 0; i < acs.length; i++){\n-                    CharsetString cs = acs[i];\n-                    CharsetEncoder fontCS = cs.fontDescriptor.encoder;\n-\n-                    StringBuilder nativeStr = new StringBuilder();\n-                    byte[] strSeg = new byte[cs.length * 2];\n-                    int len = 0;\n-                    try {\n-                        ByteBuffer bb = ByteBuffer.wrap(strSeg);\n-                        fontCS.encode(CharBuffer.wrap(cs.charsetChars,\n-                                                      cs.offset,\n-                                                      cs.length),\n-                                      bb, true);\n-                        bb.flip();\n-                        len = bb.limit();\n-                    } catch (IllegalStateException | CoderMalfunctionError xx){\n-                        continue;\n-                    }\n-                    \/* The width to fit to may either be specified,\n-                     * or calculated. Specifying by the caller is only\n-                     * valid if the text does not need to be decomposed\n-                     * into multiple calls.\n-                     *\/\n-                    float desiredWidth;\n-                    if (acs.length == 1 && width != 0f) {\n-                        desiredWidth = width;\n-                    } else {\n-                        Rectangle2D r2d =\n-                            mLastFont.getStringBounds(cs.charsetChars,\n-                                                      cs.offset,\n-                                                      cs.offset+cs.length,\n-                                                      frc);\n-                        desiredWidth = (float)r2d.getWidth();\n-                    }\n-                    \/* unprintable chars had width of 0, causing a PS error\n-                     *\/\n-                    if (desiredWidth == 0) {\n-                        return didText;\n-                    }\n-                    nativeStr.append('<');\n-                    for (int j = 0; j < len; j++){\n-                        byte b = strSeg[j];\n-                        \/\/ to avoid encoding conversion with println()\n-                        String hexS = Integer.toHexString(b);\n-                        int length = hexS.length();\n-                        if (length > 2) {\n-                            hexS = hexS.substring(length - 2, length);\n-                        } else if (length == 1) {\n-                            hexS = \"0\" + hexS;\n-                        } else if (length == 0) {\n-                            hexS = \"00\";\n-                        }\n-                        nativeStr.append(hexS);\n-                    }\n-                    nativeStr.append('>');\n-                    \/* This comment costs too much in output file size *\/\n+            nativeStr.append('>');\n+            \/* This comment costs too much in output file size *\/\n@@ -1326,1 +1332,1 @@\n-                    getGState().emitPSFont(psFonts[i], mLastFont.getSize2D());\n+            getGState().emitPSFont(psFonts[i], mLastFont.getSize2D());\n@@ -1328,9 +1334,5 @@\n-                    \/\/ out String\n-                    mPSStream.println(nativeStr.toString() + \" \" +\n-                                      desiredWidth + \" \" + x + \" \" + y + \" \" +\n-                                      DrawStringName);\n-                    x += desiredWidth;\n-                }\n-            } else {\n-                didText = false;\n-            }\n+            \/\/ out String\n+            mPSStream.println(nativeStr.toString() + \" \" +\n+                              desiredWidth + \" \" + x + \" \" + y + \" \" +\n+                              DrawStringName);\n+            x += desiredWidth;\n@@ -1339,2 +1341,3 @@\n-        return didText;\n-     }\n+        return true;\n+    }\n+\n@@ -1805,1 +1808,0 @@\n-\n@@ -1940,1 +1942,2 @@\n-        if (Double.isNaN(tx.getScaleX()) ||\n+        if (pathIter.isDone() ||\n+            Double.isNaN(tx.getScaleX()) ||\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSPrinterJob.java","additions":108,"deletions":105,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Polygon;\n+import java.awt.geom.AffineTransform;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.io.ByteArrayOutputStream;\n+\n+import javax.print.Doc;\n+import javax.print.DocFlavor;\n+import javax.print.DocPrintJob;\n+import javax.print.SimpleDoc;\n+import javax.print.StreamPrintService;\n+import javax.print.StreamPrintServiceFactory;\n+import javax.print.event.PrintJobAdapter;\n+import javax.print.event.PrintJobEvent;\n+\n+\/*\n+ * @test\n+ * @bug 8349932\n+ * @summary Verifies that generated PostScript omits unnecessary graphics state commands.\n+ *\/\n+public class PostScriptLeanTest {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;\n+        String mime = \"application\/postscript\";\n+        StreamPrintServiceFactory[] factories = StreamPrintServiceFactory.lookupStreamPrintServiceFactories(flavor, mime);\n+        if (factories.length == 0) {\n+            throw new RuntimeException(\"Unable to find PostScript print service factory\");\n+        }\n+\n+        StreamPrintServiceFactory factory = factories[0];\n+        ByteArrayOutputStream output = new ByteArrayOutputStream();\n+        StreamPrintService service = factory.getPrintService(output);\n+        DocPrintJob job = service.createPrintJob();\n+\n+        PrintJobMonitor monitor = new PrintJobMonitor();\n+        job.addPrintJobListener(monitor);\n+\n+        Printable printable = new TestPrintable();\n+        Doc doc = new SimpleDoc(printable, flavor, null);\n+        job.print(doc, null);\n+        monitor.waitForJobToFinish();\n+\n+        int paths = 0;\n+        byte[] ps = output.toByteArray();\n+        for (int i = 1; i + 1 < ps.length; i++) {\n+            if (ps[i - 1] == '\\n' && ps[i] == 'N' && ps[i + 1] == '\\n') {\n+                paths++; \/\/ found a \"newpath\" command (aliased to \"N\")\n+            }\n+        }\n+\n+        if (paths != 1) {\n+            throw new RuntimeException(\"Expected 1 path, but found \" + paths + \" paths\");\n+        }\n+    }\n+\n+    private static final class TestPrintable implements Printable {\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n+            if (pageIndex > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+            Font font1 = new Font(\"SansSerif\", Font.PLAIN, 20);\n+            Font font2 = font1.deriveFont(AffineTransform.getQuadrantRotateInstance(1));\n+            graphics.setFont(font1);\n+            graphics.drawString(\"XX\", 300, 300); \/\/ not ignored, adds a path\n+            graphics.setFont(font2);\n+            graphics.drawString(\"\\r\", 300, 350); \/\/ ignored, nothing to draw, no path added\n+            graphics.drawString(\"\\n\", 300, 400); \/\/ ignored, nothing to draw, no path added\n+            graphics.drawString(\"\\t\", 300, 450); \/\/ ignored, nothing to draw, no path added\n+            graphics.drawPolygon(new Polygon()); \/\/ empty polygon, nothing to draw, no path added\n+            return PAGE_EXISTS;\n+        }\n+    }\n+\n+    private static class PrintJobMonitor extends PrintJobAdapter {\n+        private boolean finished;\n+        @Override\n+        public void printJobCanceled(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobCompleted(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobFailed(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobNoMoreEvents(PrintJobEvent pje) {\n+            finished();\n+        }\n+        private synchronized void finished() {\n+            finished = true;\n+            notify();\n+        }\n+        public synchronized void waitForJobToFinish() {\n+            try {\n+                while (!finished) {\n+                    wait();\n+                }\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/print\/PostScriptLeanTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}