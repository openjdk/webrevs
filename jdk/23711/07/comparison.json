{"files":[{"patch":"@@ -217,21 +217,0 @@\n-\/\/ If p is not aligned, move it up to the next address that's aligned with alignment.\n-\/\/ If this is not possible (because p is too high), return nullptr. Example:\n-\/\/     p = 0xffffffffffff0000, alignment= 0x10000    => return nullptr.\n-static char* align_up_or_null(char* p, size_t alignment) {\n-  assert(p != nullptr, \"sanity\");\n-  if (is_aligned(p, alignment)) {\n-    return p;\n-  }\n-\n-  char* down = align_down(p, alignment);\n-  if (max_uintx - uintx(down) < uintx(alignment)) {\n-    \/\/ Run out of address space to align up.\n-    return nullptr;\n-  }\n-\n-  char* aligned = align_up(p, alignment);\n-  assert(aligned >= p, \"sanity\");\n-  assert(aligned != nullptr, \"sanity\");\n-  return aligned;\n-}\n-\n@@ -239,2 +218,2 @@\n-  \/\/ Caller should have checked if align_up_or_null( returns nullptr (comparing specified_base\n-  \/\/ with nullptr is UB).\n+  \/\/ Caller should have checked that aligned_base was successfully aligned and is not nullptr.\n+  \/\/ Comparing specified_base with nullptr is UB.\n@@ -264,1 +243,3 @@\n-  char* aligned_base = align_up_or_null(specified_base, alignment);\n+  char* aligned_base = can_align_up(specified_base, alignment)\n+                           ? align_up(specified_base, alignment)\n+                           : nullptr;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -192,0 +192,4 @@\n+  const size_t remaining_bytes = virtual_space()->uncommitted_size();\n+  if (remaining_bytes == 0) {\n+    return false;\n+  }\n@@ -193,1 +197,1 @@\n-  size_t aligned_bytes  = align_up(bytes, alignment);\n+  size_t aligned_bytes = align_up(MIN2(bytes, remaining_bytes), alignment);\n@@ -201,7 +205,0 @@\n-  if (aligned_bytes == 0) {\n-    \/\/ The alignment caused the number of bytes to wrap.  A call to expand\n-    \/\/ implies a best effort to expand by \"bytes\" but not a guarantee.  Align\n-    \/\/ down to give a best effort.  This is likely the most that the generation\n-    \/\/ can expand since it has some capacity to start with.\n-    aligned_bytes = align_down(bytes, alignment);\n-  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1423,1 +1423,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, max_uintx \/ 2 + 1)                                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2014,2 +2014,1 @@\n-  char* const lo_att = align_up(MAX2(absolute_min, min), alignment_adjusted);\n-  if (lo_att == nullptr) {\n+  if (!can_align_up(MAX2(absolute_min, min), alignment_adjusted)) {\n@@ -2018,0 +2017,1 @@\n+  char* const lo_att = align_up(MAX2(absolute_min, min), alignment_adjusted);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,13 @@\n+\/\/ Checks whether it is possible to align size to alignment without overflowing.\n+template<typename T, typename A, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr bool can_align_up(T size, A alignment) {\n+  return align_down(std::numeric_limits<T>::max(), alignment) >= size;\n+}\n+\n+template <typename T, typename A>\n+inline bool can_align_up(T* ptr, A alignment) {\n+  static_assert(sizeof(ptr) == sizeof(uintptr_t), \"assumption\");\n+  return can_align_up((uintptr_t)ptr, alignment);\n+}\n+\n+\/\/ Precondition: can_align_up(size, alignment) == true\n@@ -75,1 +88,3 @@\n-  T adjusted = checked_cast<T>(size + alignment_mask(alignment));\n+  T mask = checked_cast<T>(alignment_mask(alignment));\n+  assert(size <= std::numeric_limits<T>::max() - mask, \"overflow\");\n+  T adjusted = size + mask;\n","filename":"src\/hotspot\/share\/utilities\/align.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-static constexpr uint64_t values[] = {1, 3, 10, 345, 1023, 1024, 1025, 23909034, INT_MAX, uint64_t(-1) \/ 2, uint64_t(-1) \/ 2 + 100, uint64_t(-1)};\n+static constexpr uint64_t values[] = {1, 3, 10, 345, 1023, 1024, 1025, 23909034, INT_MAX, uint64_t(-1) \/ 2, uint64_t(-1) \/ 2 + 100, ~(uint64_t(1) << 62)};\n@@ -197,0 +197,75 @@\n+\n+template<typename T, typename A>\n+static constexpr void test_can_align_up() {\n+  int alignment_value = 4;\n+  int small_value = 63;\n+  A alignment = static_cast<A>(alignment_value);\n+\n+  ASSERT_TRUE(can_align_up(static_cast<T>(small_value), alignment));\n+  ASSERT_TRUE(can_align_up(static_cast<T>(-small_value), alignment));\n+  ASSERT_TRUE(can_align_up(std::numeric_limits<T>::min(), alignment));\n+  ASSERT_FALSE(can_align_up(std::numeric_limits<T>::max(), alignment));\n+  ASSERT_FALSE(can_align_up(std::numeric_limits<T>::max() - 1, alignment));\n+  ASSERT_TRUE(can_align_up(align_down(std::numeric_limits<T>::max(), alignment), alignment));\n+  ASSERT_FALSE(can_align_up(align_down(std::numeric_limits<T>::max(), alignment) + 1, alignment));\n+  if (std::is_signed<T>::value) {\n+    ASSERT_TRUE(can_align_up(static_cast<T>(-1), alignment));\n+    ASSERT_TRUE(can_align_up(align_down(static_cast<T>(-1), alignment), alignment));\n+    ASSERT_TRUE(can_align_up(align_down(static_cast<T>(-1) + 1, alignment), alignment));\n+  }\n+}\n+\n+TEST(Align, test_can_align_up_int32_int32) {\n+  test_can_align_up<int32_t, int32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_uint32_uint32) {\n+  test_can_align_up<uint32_t, uint32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_int32_uint32) {\n+  test_can_align_up<int32_t, uint32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_uint32_int32) {\n+  test_can_align_up<uint32_t, int32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_ptr) {\n+  uint alignment = 4;\n+  char buffer[8];\n+\n+  ASSERT_TRUE(can_align_up(buffer, alignment));\n+  ASSERT_FALSE(can_align_up(reinterpret_cast<void*>(UINTPTR_MAX), alignment));\n+}\n+\n+#ifdef ASSERT\n+template <typename T, typename A>\n+static void test_fail_alignment() {\n+  A alignment = max_alignment<A>();\n+  T value = align_down(std::numeric_limits<T>::max(), alignment) + 1;\n+  \/\/ Aligning value to alignment would now overflow.\n+  \/\/ Assert inside align_up expected.\n+  T aligned = align_up(value, alignment);\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_same_size) {\n+  test_fail_alignment<uint64_t, uint64_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_unsigned_signed) {\n+  test_fail_alignment<uint32_t, int32_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_signed_unsigned) {\n+  test_fail_alignment<int64_t, uint32_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_small_large) {\n+  test_fail_alignment<uint8_t, uint64_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_large_small) {\n+  test_fail_alignment<uint64_t, uint8_t>();\n+}\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/utilities\/test_align.cpp","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"}]}