{"files":[{"patch":"@@ -217,21 +217,0 @@\n-\/\/ If p is not aligned, move it up to the next address that's aligned with alignment.\n-\/\/ If this is not possible (because p is too high), return nullptr. Example:\n-\/\/     p = 0xffffffffffff0000, alignment= 0x10000    => return nullptr.\n-static char* align_up_or_null(char* p, size_t alignment) {\n-  assert(p != nullptr, \"sanity\");\n-  if (is_aligned(p, alignment)) {\n-    return p;\n-  }\n-\n-  char* down = align_down(p, alignment);\n-  if (max_uintx - uintx(down) < uintx(alignment)) {\n-    \/\/ Run out of address space to align up.\n-    return nullptr;\n-  }\n-\n-  char* aligned = align_up(p, alignment);\n-  assert(aligned >= p, \"sanity\");\n-  assert(aligned != nullptr, \"sanity\");\n-  return aligned;\n-}\n-\n@@ -265,0 +244,1 @@\n+  assert(is_aligned(aligned_base, alignment), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-  size_t aligned_bytes  = align_up(bytes, alignment);\n+  size_t aligned_bytes  = align_up_or_min(bytes, alignment);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    FLAG_SET_ERGO(MinHeapSize, align_up(MinHeapSize, HeapAlignment));\n+    FLAG_SET_ERGO(MinHeapSize, align_up_or_min(MinHeapSize, HeapAlignment));\n@@ -148,1 +148,1 @@\n-    FLAG_SET_ERGO(InitialHeapSize, align_up(InitialHeapSize, HeapAlignment));\n+    FLAG_SET_ERGO(InitialHeapSize, align_up_or_min(InitialHeapSize, HeapAlignment));\n@@ -151,1 +151,1 @@\n-    FLAG_SET_ERGO(MaxHeapSize, align_up(MaxHeapSize, HeapAlignment));\n+    FLAG_SET_ERGO(MaxHeapSize, align_up_or_min(MaxHeapSize, HeapAlignment));\n@@ -167,1 +167,1 @@\n-  FLAG_SET_ERGO(MinHeapDeltaBytes, align_up(MinHeapDeltaBytes, SpaceAlignment));\n+  FLAG_SET_ERGO(MinHeapDeltaBytes, align_up_or_min(MinHeapDeltaBytes, SpaceAlignment));\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2014,1 +2014,1 @@\n-  char* const lo_att = align_up(MAX2(absolute_min, min), alignment_adjusted);\n+  char* const lo_att = align_up_or_null(MAX2(absolute_min, min), alignment_adjusted);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,13 @@\n-  T adjusted = checked_cast<T>(size + alignment_mask(alignment));\n+  T mask = checked_cast<T>(alignment_mask(alignment));\n+  assert(size <= std::numeric_limits<T>::max() - mask, \"overflow\");\n+  T adjusted = size + mask;\n+  return align_down(adjusted, alignment);\n+}\n+\n+template<typename T, typename A, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T align_up_or_min(T size, A alignment) {\n+  T mask = checked_cast<T>(alignment_mask(alignment));\n+  if (size > std::numeric_limits<T>::max() - mask) {\n+    return std::numeric_limits<T>::min();\n+  }\n+  T adjusted = size + mask;\n@@ -93,0 +105,9 @@\n+template <typename T, typename A>\n+inline T* align_up_or_null(T* ptr, A alignment) {\n+  uintptr_t up = align_up_or_min((uintptr_t)ptr, alignment);\n+  if (up < (uintptr_t)ptr) { \/\/ we overflowed\n+    return nullptr;\n+  }\n+  return (T*)up;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/align.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-static constexpr uint64_t values[] = {1, 3, 10, 345, 1023, 1024, 1025, 23909034, INT_MAX, uint64_t(-1) \/ 2, uint64_t(-1) \/ 2 + 100, uint64_t(-1)};\n+static constexpr uint64_t values[] = {1, 3, 10, 345, 1023, 1024, 1025, 23909034, INT_MAX, uint64_t(-1) \/ 2, uint64_t(-1) \/ 2 + 100, ~(uint64_t(1) << 62)};\n@@ -122,0 +122,4 @@\n+        \/\/ Check against `align_up_or_min`\n+        const uint64_t up2 = align_up_or_min(values[i], alignment);\n+        ASSERT_EQ(up, up2);\n+\n@@ -197,0 +201,32 @@\n+\n+#ifdef ASSERT\n+template <typename T, typename A>\n+static void test_fail_alignment() {\n+  A alignment = max_alignment<A>();\n+  T value = align_down(std::numeric_limits<T>::max(), alignment) + 1;\n+  \/\/ Aligning value to alignment would now overflow.\n+  ASSERT_EQ(align_up_or_min(value, alignment), std::numeric_limits<T>::min());\n+  \/\/ Assert inside align_up expected.\n+  T aligned = align_up(value, alignment);\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_same_size) {\n+  test_fail_alignment<uint64_t, uint64_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_unsigned_signed) {\n+  test_fail_alignment<uint32_t, int32_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_signed_unsigned) {\n+  test_fail_alignment<int64_t, uint32_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_small_large) {\n+  test_fail_alignment<uint8_t, uint64_t>();\n+}\n+\n+TEST_VM_ASSERT(Align, fail_alignments_large_small) {\n+  test_fail_alignment<uint64_t, uint8_t>();\n+}\n+#endif \/\/ ASSERT\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/utilities\/test_align.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"}]}