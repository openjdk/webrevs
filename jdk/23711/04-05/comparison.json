{"files":[{"patch":"@@ -218,2 +218,2 @@\n-  \/\/ Caller should have checked if align_up_or_null( returns nullptr (comparing specified_base\n-  \/\/ with nullptr is UB).\n+  \/\/ Caller should have checked that aligned_base was successfully aligned and is not nullptr.\n+  \/\/ Comparing specified_base with nullptr is UB.\n@@ -243,2 +243,3 @@\n-  char* aligned_base = align_up_or_null(specified_base, alignment);\n-  assert(is_aligned(aligned_base, alignment), \"sanity\");\n+  char* aligned_base = can_align_up(specified_base, alignment)\n+                           ? align_up(specified_base, alignment)\n+                           : nullptr;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -192,3 +192,0 @@\n-  if (virtual_space()->uncommitted_size() == 0) {\n-    return false;\n-  }\n@@ -196,1 +193,1 @@\n-  size_t aligned_bytes  = align_up(MIN2(bytes, virtual_space()->uncommitted_size()), alignment);\n+  size_t aligned_bytes = can_align_up(bytes, alignment) ? align_up(bytes, alignment) : 0;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2014,2 +2014,1 @@\n-  char* const lo_att = align_up_or_null(MAX2(absolute_min, min), alignment_adjusted);\n-  if (lo_att == nullptr) {\n+  if (!can_align_up(MAX2(absolute_min, min), alignment_adjusted)) {\n@@ -2018,0 +2017,1 @@\n+  char* const lo_att = align_up(MAX2(absolute_min, min), alignment_adjusted);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,11 @@\n+template<typename T, typename A, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr bool can_align_up(T size, A alignment) {\n+  return align_down(std::numeric_limits<T>::max(), alignment) >= size;\n+}\n+\n+template <typename T, typename A>\n+inline bool can_align_up(T* ptr, A alignment) {\n+  static_assert(sizeof(ptr) == sizeof(uintptr_t), \"assumption\");\n+  return can_align_up((uintptr_t)ptr, alignment);\n+}\n+\n@@ -95,10 +106,0 @@\n-template <typename T, typename A>\n-inline T* align_up_or_null(T* ptr, A alignment) {\n-  uintptr_t mask = checked_cast<uintptr_t>(alignment_mask(alignment));\n-  if ((uintptr_t)ptr > std::numeric_limits<uintptr_t>::max() - mask) {\n-    return nullptr;\n-  }\n-  uintptr_t adjusted = (uintptr_t)ptr + mask;\n-  return (T*)align_down(adjusted, alignment);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/align.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -198,0 +198,44 @@\n+template<typename T, typename A>\n+static constexpr void test_can_align_up() {\n+  int alignment_value = 4;\n+  int small_value = 63;\n+  A alignment = static_cast<A>(alignment_value);\n+\n+  ASSERT_TRUE(can_align_up(static_cast<T>(small_value), alignment));\n+  ASSERT_TRUE(can_align_up(static_cast<T>(-small_value), alignment));\n+  ASSERT_TRUE(can_align_up(std::numeric_limits<T>::min(), alignment));\n+  ASSERT_FALSE(can_align_up(std::numeric_limits<T>::max(), alignment));\n+  ASSERT_FALSE(can_align_up(std::numeric_limits<T>::max() - 1, alignment));\n+  ASSERT_TRUE(can_align_up(align_down(std::numeric_limits<T>::max(), alignment), alignment));\n+  ASSERT_FALSE(can_align_up(align_down(std::numeric_limits<T>::max(), alignment) + 1, alignment));\n+  if (std::is_signed<T>::value) {\n+    ASSERT_TRUE(can_align_up(static_cast<T>(-1), alignment));\n+    ASSERT_TRUE(can_align_up(align_down(static_cast<T>(-1), alignment), alignment));\n+    ASSERT_TRUE(can_align_up(align_down(static_cast<T>(-1) + 1, alignment), alignment));\n+  }\n+}\n+\n+TEST(Align, test_can_align_up_int32_int32) {\n+  test_can_align_up<int32_t, int32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_uint32_uint32) {\n+  test_can_align_up<uint32_t, uint32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_int32_uint32) {\n+  test_can_align_up<int32_t, uint32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_uint32_int32) {\n+  test_can_align_up<uint32_t, int32_t>();\n+}\n+\n+TEST(Align, test_can_align_up_ptr) {\n+  uint alignment = 4;\n+  char buffer[8];\n+\n+  ASSERT_TRUE(can_align_up(buffer, alignment));\n+  ASSERT_FALSE(can_align_up(reinterpret_cast<void*>(UINTPTR_MAX), alignment));\n+}\n+\n@@ -227,1 +271,1 @@\n-#endif \/\/ ASSERT\n\\ No newline at end of file\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/utilities\/test_align.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"}]}