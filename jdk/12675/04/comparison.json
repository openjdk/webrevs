{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -49,0 +50,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -176,4 +178,1 @@\n-        return new FinalizableDelegatedExecutorService\n-            (new ThreadPoolExecutor(1, 1,\n-                                    0L, TimeUnit.MILLISECONDS,\n-                                    new LinkedBlockingQueue<Runnable>()));\n+        return newSingleThreadExecutor(defaultThreadFactory());\n@@ -195,1 +194,1 @@\n-        return new FinalizableDelegatedExecutorService\n+        return new AutoShutdownDelegatedExecutorService\n@@ -762,1 +761,5 @@\n-        public void shutdown() { e.shutdown(); }\n+        public void shutdown() {\n+            try {\n+                e.shutdown();\n+            } finally { reachabilityFence(this); }\n+        }\n@@ -827,1 +830,5 @@\n-    private static class FinalizableDelegatedExecutorService\n+    \/**\n+     * A DelegatedExecutorService that uses a Cleaner to shut down the underlying\n+     * ExecutorService when the wrapper becomes phantom reachable.\n+     *\/\n+    private static class AutoShutdownDelegatedExecutorService\n@@ -829,1 +836,2 @@\n-        FinalizableDelegatedExecutorService(ExecutorService executor) {\n+        private final Cleanable cleanable;\n+        AutoShutdownDelegatedExecutorService(ExecutorService executor) {\n@@ -831,0 +839,8 @@\n+            Runnable action = () -> {\n+                if (!executor.isShutdown()) {\n+                    PrivilegedAction<Void> pa = () -> { executor.shutdown(); return null; };\n+                    @SuppressWarnings(\"removal\")\n+                    var ignore = AccessController.doPrivileged(pa);\n+                }\n+            };\n+            cleanable = CleanerFactory.cleaner().register(this, action);\n@@ -832,2 +848,2 @@\n-        @SuppressWarnings(\"removal\")\n-        protected void finalize() {\n+        @Override\n+        public void shutdown() {\n@@ -835,0 +851,1 @@\n+            cleanable.clean();  \/\/ unregisters the cleanable\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Executors.java","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,5 @@\n- * @bug 6399443\n- * @summary Check for auto-shutdown and gc of singleThreadExecutors\n- * @library \/test\/lib\n- * @run main\/othervm\/timeout=1000 AutoShutdown\n- * @author Martin Buchholz\n+ * @bug 6399443 8302899\n+ * @summary Test that Executors.newSingleThreadExecutor wraps an ExecutorService that\n+ *    automatically shuts down and terminates when the wrapper is GC'ed\n+ * @modules java.base\/java.util.concurrent:+open\n+ * @run junit AutoShutdown\n@@ -33,2 +33,9 @@\n-import static java.util.concurrent.Executors.defaultThreadFactory;\n-import static java.util.concurrent.Executors.newSingleThreadExecutor;\n+import java.lang.reflect.Field;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import java.util.stream.IntStream;\n@@ -36,1 +43,5 @@\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -38,7 +49,1 @@\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.TimeUnit;\n-import jdk.test.lib.Utils;\n+class AutoShutdown {\n@@ -46,2 +51,6 @@\n-public class AutoShutdown {\n-    static final long LONG_DELAY_MS = Utils.adjustTimeout(10_000);\n+    private static Stream<Supplier<ExecutorService>> executors() {\n+        return Stream.of(\n+            () -> Executors.newSingleThreadExecutor(),\n+            () -> Executors.newSingleThreadExecutor(Executors.defaultThreadFactory())\n+        );\n+    }\n@@ -49,3 +58,4 @@\n-    static void await(CountDownLatch latch) throws InterruptedException {\n-        if (!latch.await(LONG_DELAY_MS, MILLISECONDS))\n-            throw new AssertionError(\"timed out waiting for latch\");\n+    private static Stream<Arguments> executorAndQueuedTaskCounts() {\n+        int[] queuedTaskCounts = { 0, 1, 2 };\n+        return executors().flatMap(s -> IntStream.of(queuedTaskCounts)\n+                .mapToObj(i -> Arguments.of(s, i)));\n@@ -54,39 +64,42 @@\n-    private static void realMain(String[] args) throws Throwable {\n-        final Executor[] executors = {\n-            newSingleThreadExecutor(),\n-            newSingleThreadExecutor(defaultThreadFactory()),\n-            \/\/ TODO: should these executors also auto-shutdown?\n-            \/\/newFixedThreadPool(1),\n-            \/\/newSingleThreadScheduledExecutor(),\n-            \/\/newSingleThreadScheduledExecutor(defaultThreadFactory()),\n-        };\n-        final ConcurrentLinkedQueue<WeakReference<Thread>> poolThreads\n-            = new ConcurrentLinkedQueue<>();\n-        final CountDownLatch threadStarted\n-            = new CountDownLatch(executors.length);\n-        final CountDownLatch pleaseProceed\n-            = new CountDownLatch(1);\n-        Runnable task = new Runnable() { public void run() {\n-            try {\n-                poolThreads.add(new WeakReference<>(Thread.currentThread()));\n-                threadStarted.countDown();\n-                await(pleaseProceed);\n-            } catch (Throwable t) { unexpected(t); }\n-        }};\n-        for (Executor executor : executors)\n-            executor.execute(task);\n-        await(threadStarted);\n-        pleaseProceed.countDown();\n-        Arrays.fill(executors, null);   \/\/ make executors unreachable\n-        boolean done = false;\n-        for (long timeout = 1L; !done && timeout <= 128L; timeout *= 2) {\n-            System.gc();\n-            done = true;\n-            for (WeakReference<Thread> ref : poolThreads) {\n-                Thread thread = ref.get();\n-                if (thread != null) {\n-                    TimeUnit.SECONDS.timedJoin(thread, timeout);\n-                    if (thread.isAlive())\n-                        done = false;\n-                }\n-            }\n+    \/**\n+     * SingleThreadExecutor with no worker threads.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testNoWorker(Supplier<ExecutorService> supplier) throws Exception {\n+        ExecutorService executor = supplier.get();\n+        ExecutorService delegate = getDelegate(executor);\n+        executor = null;\n+        gcAndAwaitTermination(delegate);\n+    }\n+\n+    \/**\n+     * SingleThreadExecutor with an idle worker thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testIdleWorker(Supplier<ExecutorService> supplier) throws Exception {\n+        ExecutorService executor = supplier.get();\n+        \/\/ submit a task to get a worker to start\n+        executor.submit(() -> null).get();\n+        ExecutorService delegate = getDelegate(executor);\n+        executor = null;\n+        gcAndAwaitTermination(delegate);\n+    }\n+\n+    \/**\n+     * SingleThreadExecutor with an active worker and queued tasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executorAndQueuedTaskCounts\")\n+    void testActiveWorker(Supplier<ExecutorService> supplier,int queuedTaskCount) throws Exception {\n+        ExecutorService executor = supplier.get();\n+        \/\/ the worker will execute one task, the other tasks will be queued\n+        int ntasks = 1 + queuedTaskCount;\n+        AtomicInteger completedTaskCount = new AtomicInteger();\n+        for (int i = 0; i < ntasks; i++) {\n+            executor.submit(() -> {\n+                Thread.sleep(Duration.ofMillis(500));\n+                completedTaskCount.incrementAndGet();\n+                return null;\n+            });\n@@ -94,2 +107,15 @@\n-        if (!done)\n-            throw new AssertionError(\"pool threads did not terminate\");\n+        ExecutorService delegate = getDelegate(executor);\n+        executor = null;\n+        gcAndAwaitTermination(delegate);\n+        assertEquals(ntasks, completedTaskCount.get());\n+    }\n+\n+    \/**\n+     * Returns the delegate for the given ExecutorService. The given ExecutorService\n+     * must be a Executors$DelegatedExecutorService.\n+     *\/\n+    private ExecutorService getDelegate(ExecutorService executor) throws Exception {\n+        Field eField = Class.forName(\"java.util.concurrent.Executors$DelegatedExecutorService\")\n+                .getDeclaredField(\"e\");\n+        eField.setAccessible(true);\n+        return (ExecutorService) eField.get(executor);\n@@ -98,13 +124,11 @@\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+    \/**\n+     * Invokes System.gc and waits for the given ExecutorService to terminate.\n+     *\/\n+    private void gcAndAwaitTermination(ExecutorService executor) throws Exception {\n+        System.err.println(executor);\n+        boolean terminated = false;\n+        while (!terminated) {\n+            System.gc();\n+            terminated = executor.awaitTermination(100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n@@ -112,0 +136,1 @@\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/Executors\/AutoShutdown.java","additions":100,"deletions":75,"binary":false,"changes":175,"status":"modified"}]}