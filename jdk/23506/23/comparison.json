{"files":[{"patch":"@@ -399,0 +399,6 @@\n+  \/\/ Collapse addition of the same terms into multiplications.\n+  Node* collapsed = Ideal_collapse_variable_times_con(phase, bt);\n+  if (collapsed != nullptr) {\n+    return collapsed; \/\/ Skip AddNode::Ideal() since it may now be a multiplication node.\n+  }\n+\n@@ -402,0 +408,174 @@\n+\/\/ Try to collapse addition of the same terms into a single multiplication. On success, a new MulNode is returned.\n+\/\/ Examples of this conversion includes:\n+\/\/   - a + a + ... + a => CON*a\n+\/\/   - (a * CON) + a   => (CON + 1) * a\n+\/\/   - a + (a * CON)   => (CON + 1) * a\n+\/\/\n+\/\/ We perform such conversions incrementally during IGVN by transforming left most nodes first and work up to the root\n+\/\/ of the expression. In other words, we convert, at each iteration:\n+\/\/        a + a + a + ... + a\n+\/\/     => 2*a + a + ... + a\n+\/\/     => 3*a + ... + a\n+\/\/     => n*a\n+\/\/\n+\/\/ Due to the iterative nature of IGVN, MulNode transformed from first few AddNode terms may be further transformed into\n+\/\/ power-of-2 pattern. (e.g., 2 * a => a << 1, 3 * a => (a << 2) + a). We can't guarantee we'll always pick up\n+\/\/ transformed power-of-2 patterns when term `a` is complex.\n+\/\/\n+\/\/ Note this also converts, for example, original expression `(a*3) + a` into `4*a` and `(a<<2) + a` into `5*a`. A more\n+\/\/ generalized pattern `(a*b) + (a*c)` into `a*(b + c)` is handled by AddNode::IdealIL().\n+Node* AddNode::Ideal_collapse_variable_times_con(PhaseGVN* phase, BasicType bt) {\n+  \/\/ We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  \/\/ power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  \/\/ node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (Multiplication::find_power_of_two_addition_pattern(this, bt).is_valid()) {\n+    return nullptr;\n+  }\n+\n+  Node* lhs = in(1);\n+  Node* rhs = in(2);\n+\n+  Multiplication mul = Multiplication::find_collapsible_addition_patterns(lhs, rhs, bt);\n+  if (!mul.is_valid_with(rhs)) {\n+    \/\/ Swap lhs and rhs then try again\n+    mul = Multiplication::find_collapsible_addition_patterns(rhs, lhs, bt);\n+    if (!mul.is_valid_with(lhs)) {\n+      return nullptr;\n+    }\n+  }\n+\n+  Node* con;\n+  if (bt == T_INT) {\n+    con = phase->intcon(java_add(static_cast<jint>(mul.multiplier()), 1));\n+  } else {\n+    con = phase->longcon(java_add(mul.multiplier(), CONST64(1)));\n+  }\n+\n+  return MulNode::make(con, mul.variable(), bt);\n+}\n+\n+\/\/ Find a pattern of collapsable additions that can be converted to a multiplication.\n+\/\/ When matching the LHS `a * CON`, we match with best efforts by looking for the following patterns:\n+\/\/     - (1) Simple addition:       LHS = a + a\n+\/\/     - (2) Simple lshift:         LHS = a << CON\n+\/\/     - (3) Simple multiplication: LHS = CON * a\n+\/\/     - (4) Power-of-two addition: LHS = (a << CON1) + (a << CON2)\n+AddNode::Multiplication AddNode::Multiplication::find_collapsible_addition_patterns(const Node* a, const Node* pattern, BasicType bt) {\n+  \/\/ (1) Simple addition pattern (e.g., lhs = a + a)\n+  Multiplication mul = find_simple_addition_pattern(a, bt);\n+  if (mul.is_valid_with(pattern)) {\n+    return mul;\n+  }\n+\n+  \/\/ (2) Simple lshift pattern (e.g., lhs = a << CON)\n+  mul = find_simple_lshift_pattern(a, bt);\n+  if (mul.is_valid_with(pattern)) {\n+    return mul;\n+  }\n+\n+  \/\/ (3) Simple multiplication pattern (e.g., lhs = CON * a)\n+  mul = find_simple_multiplication_pattern(a, bt);\n+  if (mul.is_valid_with(pattern)) {\n+    return mul;\n+  }\n+\n+  \/\/ (4) Power-of-two addition pattern (e.g., lhs = (a << CON1) + (a << CON2))\n+  \/\/ While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  \/\/ (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  mul = find_power_of_two_addition_pattern(a, bt);\n+  if (mul.is_valid_with(pattern)) {\n+    return mul;\n+  }\n+\n+  \/\/ We've tried everything.\n+  return make_invalid();\n+}\n+\n+\/\/ Try to match `n = a + a`. On success, return a struct with `.valid = true`, `variable = a`, and `multiplier = 2`.\n+\/\/ The method matches `n` for pattern: a + a.\n+AddNode::Multiplication AddNode::Multiplication::find_simple_addition_pattern(const Node* n, BasicType bt) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) == n->in(2)) {\n+    return Multiplication(n->in(1), 2);\n+  }\n+\n+  return make_invalid();\n+}\n+\n+\/\/ Try to match `n = a << CON`. On success, return a struct with `.valid = true`, `variable = a`, and\n+\/\/ `multiplier = 1 << CON`.\n+\/\/ Match `n` for pattern: a << CON.\n+\/\/ Note that the power-of-2 multiplication optimization could potentially convert a MulNode to this pattern.\n+AddNode::Multiplication AddNode::Multiplication::find_simple_lshift_pattern(const Node* n, BasicType bt) {\n+  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n+  if (n->Opcode() == Op_LShift(bt) && n->in(2)->is_Con()) {\n+    Node* con = n->in(2);\n+    if (!con->is_top()) {\n+      return Multiplication(n->in(1), java_shift_left(1, con->get_int(), bt));\n+    }\n+  }\n+\n+  return make_invalid();\n+}\n+\n+\/\/ Try to match `n = CON * a`. On success, return a struct with `.valid = true`, `variable = a`, and `multiplier = CON`.\n+\/\/ Match `n` for patterns:\n+\/\/     - (1) CON * a\n+\/\/     - (2) a * CON\n+AddNode::Multiplication AddNode::Multiplication::find_simple_multiplication_pattern(const Node* n, BasicType bt) {\n+  \/\/ This optimization technically only produces MulNode(CON, a), but we also match MulNode(a, CON) to cover more cases.\n+  if (n->Opcode() == Op_Mul(bt) && (n->in(1)->is_Con() || n->in(2)->is_Con())) {\n+    \/\/ Pattern (1)\n+    Node* con = n->in(1);\n+    Node* base = n->in(2);\n+\n+    \/\/ Pattern (2)\n+    if (!con->is_Con()) {\n+      \/\/ swap ConNode to lhs for easier matching\n+      swap(con, base);\n+    }\n+\n+    if (!con->is_top()) {\n+      return Multiplication(base, con->get_integer_as_long(bt));\n+    }\n+  }\n+\n+  return make_invalid();\n+}\n+\n+\/\/ Try to match `n = (a << CON1) + (a << CON2)`. On success, return a struct with `.valid = true`, `variable = a`, and\n+\/\/ `multiplier = (1 << CON1) + (1 << CON2)`.\n+\/\/ Match `n` for patterns:\n+\/\/     - (1) (a << CON) + (a << CON)\n+\/\/     - (2) (a << CON) + a\n+\/\/     - (3) a + (a << CON)\n+\/\/     - (4) a + a\n+\/\/ Note that one or both of the term of the addition could simply be `a` (i.e., a << 0) as in pattern (4).\n+AddNode::Multiplication AddNode::Multiplication::find_power_of_two_addition_pattern(const Node* n, BasicType bt) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) != n->in(2)) {\n+    const Multiplication lhs = find_simple_lshift_pattern(n->in(1), bt);\n+    const Multiplication rhs = find_simple_lshift_pattern(n->in(2), bt);\n+\n+    \/\/ Pattern (1)\n+    {\n+      const Multiplication res = lhs.add(rhs);\n+      if (res.is_valid()) {\n+        return res;\n+      }\n+    }\n+\n+    \/\/ Pattern (2)\n+    if (lhs.is_valid_with(n->in(2))) {\n+      return Multiplication(lhs.variable(), java_add(lhs.multiplier(), CONST64(1)));\n+    }\n+\n+    \/\/ Pattern (3)\n+    if (rhs.is_valid_with(n->in(1))) {\n+      return Multiplication(rhs.variable(), java_add(rhs.multiplier(), CONST64(1)));\n+    }\n+\n+    \/\/ Pattern (4), which is equivalent to a simple addition pattern\n+    return find_simple_addition_pattern(n, bt);\n+  }\n+\n+  return make_invalid();\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":180,"deletions":0,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -45,1 +45,45 @@\n-public:\n+\n+  class Multiplication {\n+    bool _is_valid = false;\n+\n+    Node* _variable = nullptr;\n+    jlong _multiplier = 0;\n+\n+  private:\n+    Multiplication() {}\n+\n+  public:\n+    Multiplication(Node* variable, jlong multiplier) :\n+          _is_valid(true),\n+          _variable(variable),\n+          _multiplier(multiplier) {}\n+\n+    static Multiplication make_invalid() {\n+      static Multiplication invalid = Multiplication();\n+      return invalid;\n+    }\n+\n+    static Multiplication find_collapsible_addition_patterns(const Node* a, const Node* pattern, BasicType bt);\n+    static Multiplication find_simple_addition_pattern(const Node* n, BasicType bt);\n+    static Multiplication find_simple_lshift_pattern(const Node* n, BasicType bt);\n+    static Multiplication find_simple_multiplication_pattern(const Node* n, BasicType bt);\n+    static Multiplication find_power_of_two_addition_pattern(const Node* n, BasicType bt);\n+\n+    Multiplication add(const Multiplication rhs) const {\n+      if (is_valid_with(rhs.variable()) && rhs.is_valid_with(variable())) {\n+        return Multiplication(variable(), java_add(multiplier(), rhs.multiplier()));\n+      }\n+\n+      return make_invalid();\n+    }\n+\n+    bool is_valid() const { return _is_valid; }\n+    bool is_valid_with(const Node* variable) const {\n+      return _is_valid && this->_variable == variable;\n+    }\n+\n+    Node* variable() const { return _variable; }\n+    jlong multiplier() const { return _multiplier; }\n+  };\n+\n+ public:\n@@ -58,0 +102,1 @@\n+  Node* Ideal_collapse_variable_times_con(PhaseGVN* phase, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1256,0 +1256,18 @@\n+\/\/ Some convenient bit shift operations that accepts a BasicType as the last\n+\/\/ argument. These avoid potential mistakes with overloaded functions only\n+\/\/ distinguished by lhs argument type.\n+#define JAVA_INTEGER_SHIFT_BASIC_TYPE(FUNC)            \\\n+inline jlong FUNC(jlong lhs, jint rhs, BasicType bt) { \\\n+  if (bt == T_INT) {                                   \\\n+    return FUNC((jint) lhs, rhs);                      \\\n+  }                                                    \\\n+  assert(bt == T_LONG, \"unsupported basic type\");      \\\n+  return FUNC(lhs, rhs);                              \\\n+}\n+\n+JAVA_INTEGER_SHIFT_BASIC_TYPE(java_shift_left)\n+JAVA_INTEGER_SHIFT_BASIC_TYPE(java_shift_right)\n+JAVA_INTEGER_SHIFT_BASIC_TYPE(java_shift_right_unsigned)\n+\n+#undef JAVA_INTERGER_SHIFT_BASIC_TYPE\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_left(data[i].x, data[i].shift, T_INT));\n@@ -202,0 +203,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_left(data[i].x, data[i].shift, T_LONG));\n@@ -265,0 +267,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right(data[i].x, data[i].shift, T_INT));\n@@ -272,0 +275,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right(data[i].x, data[i].shift, T_LONG));\n@@ -337,0 +341,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right_unsigned(data[i].x, data[i].shift, T_INT));\n@@ -344,0 +349,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right_unsigned(data[i].x, data[i].shift, T_LONG));\n","filename":"test\/hotspot\/gtest\/utilities\/test_java_arithmetic.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,430 @@\n+\/*\n+ * Copyright (c) 2025 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8325495 8347555\n+ * @summary C2 should optimize addition of the same terms by collapsing them into one multiplication.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.TestCollapsingSameTermAdditions\n+ *\/\n+public class TestCollapsingSameTermAdditions {\n+    private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"addTo2\",\n+            \"addTo3\",\n+            \"addTo4\",\n+            \"shiftAndAddTo4\",\n+            \"mulAndAddTo4\",\n+            \"addTo5\",\n+            \"addTo6\",\n+            \"addTo7\",\n+            \"addTo8\",\n+            \"addTo16\",\n+            \"addAndShiftTo16\",\n+            \"addTo42\",\n+            \"mulAndAddTo42\",\n+            \"mulAndAddToMax\",\n+            \"mulAndAddToOverflow\",\n+            \"mulAndAddToZero\",\n+            \"mulAndAddToMinus1\",\n+            \"mulAndAddToMinus42\"\n+    })\n+    private void runIntTests() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, GEN_INT.next() }) {\n+            Asserts.assertEQ(a * 2, addTo2(a));\n+            Asserts.assertEQ(a * 3, addTo3(a));\n+            Asserts.assertEQ(a * 4, addTo4(a));\n+            Asserts.assertEQ(a * 4, shiftAndAddTo4(a));\n+            Asserts.assertEQ(a * 4, mulAndAddTo4(a));\n+            Asserts.assertEQ(a * 5, addTo5(a));\n+            Asserts.assertEQ(a * 6, addTo6(a));\n+            Asserts.assertEQ(a * 7, addTo7(a));\n+            Asserts.assertEQ(a * 8, addTo8(a));\n+            Asserts.assertEQ(a * 16, addTo16(a));\n+            Asserts.assertEQ(a * 16, addAndShiftTo16(a));\n+            Asserts.assertEQ(a * 42, addTo42(a));\n+            Asserts.assertEQ(a * 42, mulAndAddTo42(a));\n+            Asserts.assertEQ(a * Integer.MAX_VALUE, mulAndAddToMax(a));\n+            Asserts.assertEQ(a * Integer.MIN_VALUE, mulAndAddToOverflow(a));\n+            Asserts.assertEQ(0, mulAndAddToZero(a));\n+            Asserts.assertEQ(a * -1, mulAndAddToMinus1(a));\n+            Asserts.assertEQ(a * -42, mulAndAddToMinus42(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"mulAndAddToIntOverflowL\",\n+            \"mulAndAddToMaxL\",\n+            \"mulAndAddToOverflowL\"\n+    })\n+    private void runLongTests() {\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, GEN_LONG.next() }) {\n+            Asserts.assertEQ(a * (Integer.MAX_VALUE + 1L), mulAndAddToIntOverflowL(a));\n+            Asserts.assertEQ(a * Long.MAX_VALUE, mulAndAddToMaxL(a));\n+            Asserts.assertEQ(a * Long.MIN_VALUE, mulAndAddToOverflowL(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"bitShiftToOverflow\",\n+            \"bitShiftToOverflowL\"\n+    })\n+    private void runBitShiftTests() {\n+        Asserts.assertEQ(95, bitShiftToOverflow());\n+        Asserts.assertEQ(191L, bitShiftToOverflowL());\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = IRNode.LSHIFT_I)\n+    private static int addTo2(int a) {\n+        return a + a; \/\/ Simple additions like a + a should be kept as-is\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo3(int a) {\n+        return a + a + a; \/\/ a*3 => (a<<1) + a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo4(int a) {\n+        return a + a + a + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int shiftAndAddTo4(int a) {\n+        return (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddTo4(int a) {\n+        return a * 3 + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo5(int a) {\n+        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    private static int addTo6(int a) {\n+        return a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int addTo7(int a) {\n+        return a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo8(int a) {\n+        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo16(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addAndShiftTo16(int a) {\n+        return (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int addTo42(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddTo42(int a) {\n+        return a * 40 + a + a; \/\/ a*41 + a => a*42\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMax(int a) {\n+        return a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - a => (a<<31) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddToOverflow(int a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static int mulAndAddToZero(int a) {\n+        return a * -1 + a; \/\/ 0\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMinus1(int a) {\n+        return a * -2 + a; \/\/ a*-1 => a - (a<<1)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddToMinus42(int a) {\n+        return a * -43 + a; \/\/ a*-42\n+    }\n+\n+    \/\/ --- long tests ---\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToIntOverflowL(long a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.SUB_L, \"1\" })\n+    private static long mulAndAddToMaxL(long a) {\n+        return a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToOverflowL(long a) {\n+        return a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+    }\n+\n+    \/\/ --- bit shift tests ---\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.LSHIFT_I})\n+    private static int bitShiftToOverflow() {\n+        int i, x = 0;\n+        for (i = 0; i < 32; i++) {\n+            x = i;\n+        }\n+\n+        \/\/ x = 31 (phi), i = 32 (phi + 1)\n+        return i + (x << i) + i; \/\/ Expects 32 + 31 + 32 = 95\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.LSHIFT_L})\n+    private static long bitShiftToOverflowL() {\n+        int i, x = 0;\n+        for (i = 0; i < 64; i++) {\n+            x = i;\n+        }\n+\n+        \/\/ x = 63 (phi), i = 64 (phi + 1)\n+        return i + (x << i) + i; \/\/ Expects 64 + 63 + 64 = 191\n+    }\n+\n+    \/\/ --- random tests ---\n+    private static final int CON1_I, CON2_I, CON3_I, CON4_I;\n+    private static final long CON1_L, CON2_L, CON3_L, CON4_L;\n+\n+    static {\n+        CON1_I = GEN_INT.next();\n+        CON2_I = GEN_INT.next();\n+        CON3_I = GEN_INT.next();\n+        CON4_I = GEN_INT.next();\n+\n+        CON1_L = GEN_LONG.next();\n+        CON2_L = GEN_LONG.next();\n+        CON3_L = GEN_LONG.next();\n+        CON4_L = GEN_LONG.next();\n+    }\n+\n+    @Run(test = {\n+            \"randomPowerOfTwoAddition\",\n+            \"randomPowerOfTwoAdditionL\"\n+    })\n+    private void runRandomPowerOfTwoAddition() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, GEN_INT.next() }) {\n+            Asserts.assertEQ(a * (CON1_I + CON2_I + CON3_I + CON4_I), randomPowerOfTwoAddition(a));\n+        }\n+\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, GEN_LONG.next() }) {\n+            Asserts.assertEQ(a * (CON1_L + CON2_L + CON3_L + CON4_L), randomPowerOfTwoAdditionL(a));\n+        }\n+    }\n+\n+    \/\/ We can't do IR verification but only check for correctness for a better confidence.\n+    @Test\n+    private static int randomPowerOfTwoAddition(int a) {\n+        return a * CON1_I + a * CON2_I + a * CON3_I + a * CON4_I;\n+    }\n+\n+    @Test\n+    private static long randomPowerOfTwoAdditionL(long a) {\n+        return a * CON1_L + a * CON2_L + a * CON3_L + a * CON4_L;\n+    }\n+\n+    \/\/ Patterns that are originally cannot be recognized due to their right precedence making it difficult without\n+    \/\/ recursion, but some are made possible with swapping lhs and rhs.\n+    @Run(test = {\n+        \"rightPrecedence\",\n+        \"rightPrecedenceL\",\n+        \"rightPrecedenceShift\",\n+        \"rightPrecedenceShiftL\",\n+    })\n+    private void runLhsRhsSwaps() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, GEN_INT.next() }) {\n+            Asserts.assertEQ(a * 3, rightPrecedence(a));\n+            Asserts.assertEQ(a * 4, rightPrecedenceShift(a));\n+        }\n+\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, GEN_LONG.next() }) {\n+            Asserts.assertEQ(a * 3, rightPrecedenceL(a));\n+            Asserts.assertEQ(a * 4, rightPrecedenceShiftL(a));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int rightPrecedence(int a) {\n+        return a + (a + a);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_L, \"1\", IRNode.LSHIFT_L, \"1\" })\n+    private static long rightPrecedenceL(long a) {\n+        return a + (a + a);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int rightPrecedenceShift(int a) {\n+        return a + (a << 1) + a; \/\/ a + a*2 + a => a*2 + a + a => a*3 + a => a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long rightPrecedenceShiftL(long a) {\n+        return a + (a << 1) + a; \/\/ a + a*2 + a => a*2 + a + a => a*3 + a => a*4 => a<<2\n+    }\n+\n+    \/\/ JDK-8347555 only aims to cover cases minimally needed for patterns a + a + ... + a => n*a. However, some patterns\n+    \/\/ like CON * a + a => (CON + 1) * a are considered unintended side-effects due to the way pattern matching is\n+    \/\/ implemented.\n+    \/\/\n+    \/\/ The followings are patterns that could be, mathematically speaking, optimized, but not implemented at this stage.\n+    \/\/ These tests are to be updated if they are addressed in the future.\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"2\", IRNode.LSHIFT_I, \"2\" })\n+    @Arguments(values = { Argument.RANDOM_EACH })\n+    private static int complexShiftPattern(int a) {\n+        return a + (a << 1) + (a << 2); \/\/ This could've been: a + a*2 + a*4 => a*7\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"2\" })  \/\/ b = a + a, c = b + b\n+    @Arguments(values = { Argument.RANDOM_EACH })\n+    private static int nestedAddPattern(int a) {\n+        return (a + a) + (a + a); \/\/ This could've been: 2*a + 2*a => 4*a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"3\", IRNode.LSHIFT_I, \"1\" })\n+    @Arguments(values = { Argument.RANDOM_EACH })\n+    private static int complexPrecedence(int a) {\n+        return a + a + ((a + a) + a); \/\/ This could've been: 2*a + (2*a + a) => 2*a + 3*a => 5*a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_L, \"2\", IRNode.LSHIFT_L, \"2\" })\n+    @Arguments(values = { Argument.RANDOM_EACH })\n+    private static long complexShiftPatternL(long a) {\n+        return a + (a << 1) + (a << 2); \/\/ This could've been: a + a*2 + a*4 => a*7\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_L, \"2\" })  \/\/ b = a + a, c = b + b\n+    @Arguments(values = { Argument.RANDOM_EACH })\n+    private static long nestedAddPatternL(long a) {\n+        return (a + a) + (a + a); \/\/ This could've been: 2*a + 2*a => 4*a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_L, \"3\", IRNode.LSHIFT_L, \"1\" })\n+    @Arguments(values = { Argument.RANDOM_EACH })\n+    private static long complexPrecedenceL(long a) {\n+        return a + a + ((a + a) + a); \/\/ This could've been: 2*a + (2*a + a) => 2*a + 3*a => 5*a\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestCollapsingSameTermAdditions.java","additions":430,"deletions":0,"binary":false,"changes":430,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests speed of adding a series of additions of the same operand.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class SerialAdditions {\n+    private int a = 0xBADB0BA;\n+    private long b = 0x900dba51l;\n+\n+    @Benchmark\n+    public int addIntsTo02() {\n+        return a + a; \/\/ baseline, still a + a\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo04() {\n+        return a + a + a + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo05() {\n+        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo06() {\n+        return a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo08() {\n+        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo16() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo23() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a; \/\/ a*23\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo32() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a; \/\/ a*32 => a<<5\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo42() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a; \/\/ a*42\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo64() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a; \/\/ 64 * a => a << 6\n+    }\n+\n+    @Benchmark\n+    public void addIntsMixed(Blackhole blackhole) {\n+        blackhole.consume(addIntsTo02());\n+        blackhole.consume(addIntsTo04());\n+        blackhole.consume(addIntsTo05());\n+        blackhole.consume(addIntsTo06());\n+        blackhole.consume(addIntsTo08());\n+        blackhole.consume(addIntsTo16());\n+        blackhole.consume(addIntsTo23());\n+        blackhole.consume(addIntsTo32());\n+        blackhole.consume(addIntsTo42());\n+        blackhole.consume(addIntsTo64());\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo02() {\n+        return b + b; \/\/ baseline, still a + a\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo04() {\n+        return b + b + b + b; \/\/ a*4 => a<<2\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo05() {\n+        return b + b + b + b + b; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo06() {\n+        return b + b + b + b + b + b; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo08() {\n+        return b + b + b + b + b + b + b + b; \/\/ a*8 => a<<3\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo16() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b; \/\/ a*16 => a<<4\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo23() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b; \/\/ a*23\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo32() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b; \/\/ a*32 => a<<5\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo42() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b; \/\/ a*42\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo64() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b; \/\/ 64 * a => a << 6\n+    }\n+\n+    @Benchmark\n+    public void addLongsMixed(Blackhole blackhole) {\n+        blackhole.consume(addLongsTo02());\n+        blackhole.consume(addLongsTo04());\n+        blackhole.consume(addLongsTo05());\n+        blackhole.consume(addLongsTo06());\n+        blackhole.consume(addLongsTo08());\n+        blackhole.consume(addLongsTo16());\n+        blackhole.consume(addLongsTo23());\n+        blackhole.consume(addLongsTo32());\n+        blackhole.consume(addLongsTo42());\n+        blackhole.consume(addLongsTo64());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SerialAdditions.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}