{"files":[{"patch":"@@ -397,0 +397,6 @@\n+  \/\/ Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n+\n@@ -400,0 +406,151 @@\n+\/\/ Try to convert a serial of additions into a single multiplication. Also convert `(a * CON) + a` to `(CON + 1) * a` as\n+\/\/ a side effect. On success, a new MulNode is returned.\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n+  \/\/ We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  \/\/ power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  \/\/ node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  jlong multiplier;\n+\n+  \/\/ While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  \/\/ (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n+      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n+      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n+    multiplier++; \/\/ +1 for the in2 term\n+\n+    Node* con = (bt == T_INT)\n+                ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon(multiplier);\n+    return MulNode::make(con, in2, bt);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `a + a`. On success, return `a` and set `2` as `multiplier`.\n+\/\/ The method matches `n` for pattern: AddNode(a, a).\n+Node* AddNode::find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) == n->in(2)) {\n+    *multiplier = 2;\n+    return n->in(1);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `a << CON`. On success, return `a` and set `1 << CON` as `multiplier`.\n+\/\/ Match `n` for pattern: LShiftNode(a, CON).\n+\/\/ Note that the power-of-2 multiplication optimization could potentially convert a MulNode to this pattern.\n+Node* AddNode::find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n+  if (n->Opcode() == Op_LShift(bt) && n->in(2)->is_Con()) {\n+    Node* con = n->in(2);\n+    if (con->is_top()) {\n+      return nullptr;\n+    }\n+\n+    *multiplier = bt == T_INT\n+                    ? java_shift_left(jint(1), con->get_int())\n+                    : java_shift_left(jlong(1), con->get_int());\n+    return n->in(1);\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `CON * a`. On success, return `a` and set `CON` as `multiplier`.\n+\/\/ Match `n` for patterns:\n+\/\/     - MulNode(CON, a)\n+\/\/     - MulNode(a, CON)\n+Node* AddNode::find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  \/\/ This optimization technically only produces MulNode(CON, a), but we might as match MulNode(a, CON), too.\n+  if (n->Opcode() == Op_Mul(bt) && (n->in(1)->is_Con() || n->in(2)->is_Con())) {\n+    Node* con = n->in(1);\n+    Node* base = n->in(2);\n+\n+    \/\/ swap ConNode to lhs for easier matching\n+    if (!con->is_Con()) {\n+      swap(con, base);\n+    }\n+\n+    if (con->is_top()) {\n+      return nullptr;\n+    }\n+\n+    *multiplier = con->get_integer_as_long(bt);\n+    return base;\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to match `(a << CON1) + (a << CON2)`. On success, return `a` and set `(1 << CON1) + (1 << CON2)` as `multiplier`.\n+\/\/ Match `n` for patterns:\n+\/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n+\/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+\/\/ given that lhs is different from rhs.\n+\/\/ Note that one of the term of the addition could simply be `a` (i.e., a << 0). Calling this function with `multiplier`\n+\/\/ being null is safe.\n+Node* AddNode::find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) != n->in(2)) {\n+    Node* lhs = n->in(1);\n+    Node* rhs = n->in(2);\n+\n+    \/\/ swap LShiftNode to lhs for easier matching\n+    if (lhs->Opcode() != Op_LShift(bt)) {\n+      swap(lhs, rhs);\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), *)?\n+    if (lhs->Opcode() != Op_LShift(bt) || !lhs->in(2)->is_Con()) {\n+      return nullptr;\n+    }\n+\n+    jlong lhs_multiplier = 0;\n+    if (multiplier != nullptr) {\n+      Node* con = lhs->in(2);\n+      if (con->is_top()) {\n+        return nullptr;\n+      }\n+\n+      lhs_multiplier = bt == T_INT\n+                       ? java_shift_left(jint(1), con->get_int())\n+                       : java_shift_left(jlong(1), con->get_int());\n+\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), a)?\n+    if (lhs->in(1) == rhs) {\n+      if (multiplier != nullptr) {\n+        *multiplier = lhs_multiplier + 1;\n+      }\n+\n+      return rhs;\n+    }\n+\n+    \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n+    if (rhs->Opcode() == Op_LShift(bt) && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n+      if (multiplier != nullptr) {\n+        Node* con = rhs->in(2);\n+        if (con->is_top()) {\n+          return nullptr;\n+        }\n+\n+        *multiplier = lhs_multiplier + (bt == T_INT\n+                      ? java_shift_left(jint(1), con->get_int())\n+                      : java_shift_left(jlong(1), con->get_int()));\n+      }\n+\n+      return lhs->in(1);\n+    }\n+    return nullptr;\n+  }\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -45,0 +45,7 @@\n+\n+  Node* convert_serial_additions(PhaseGVN* phase, BasicType bt);\n+  static Node* find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Node* find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8325495\n+ * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestSerialAdditions\n+ *\/\n+public class TestSerialAdditions {\n+    private static final Random RNG = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"addTo2\",\n+            \"addTo3\",\n+            \"addTo4\",\n+            \"shiftAndAddTo4\",\n+            \"mulAndAddTo4\",\n+            \"addTo5\",\n+            \"addTo6\",\n+            \"addTo7\",\n+            \"addTo8\",\n+            \"addTo16\",\n+            \"addAndShiftTo16\",\n+            \"addTo42\",\n+            \"mulAndAddTo42\",\n+            \"mulAndAddToMax\",\n+            \"mulAndAddToOverflow\",\n+            \"mulAndAddToZero\",\n+            \"mulAndAddToMinus1\",\n+            \"mulAndAddToMinus42\"\n+    })\n+    private void runIntTests() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, RNG.nextInt() }) {\n+            Asserts.assertEQ(a * 2, addTo2(a));\n+            Asserts.assertEQ(a * 3, addTo3(a));\n+            Asserts.assertEQ(a * 4, addTo4(a));\n+            Asserts.assertEQ(a * 4, shiftAndAddTo4(a));\n+            Asserts.assertEQ(a * 4, mulAndAddTo4(a));\n+            Asserts.assertEQ(a * 5, addTo5(a));\n+            Asserts.assertEQ(a * 6, addTo6(a));\n+            Asserts.assertEQ(a * 7, addTo7(a));\n+            Asserts.assertEQ(a * 8, addTo8(a));\n+            Asserts.assertEQ(a * 16, addTo16(a));\n+            Asserts.assertEQ(a * 16, addAndShiftTo16(a));\n+            Asserts.assertEQ(a * 42, addTo42(a));\n+            Asserts.assertEQ(a * 42, mulAndAddTo42(a));\n+            Asserts.assertEQ(a * Integer.MAX_VALUE, mulAndAddToMax(a));\n+            Asserts.assertEQ(a * Integer.MIN_VALUE, mulAndAddToOverflow(a));\n+            Asserts.assertEQ(0, mulAndAddToZero(a));\n+            Asserts.assertEQ(a * -1, mulAndAddToMinus1(a));\n+            Asserts.assertEQ(a * -42, mulAndAddToMinus42(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"mulAndAddToIntOverflowL\",\n+            \"mulAndAddToMaxL\",\n+            \"mulAndAddToOverflowL\"\n+    })\n+    private void runLongTests() {\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, RNG.nextLong() }) {\n+            Asserts.assertEQ(a * (Integer.MAX_VALUE + 1L), mulAndAddToIntOverflowL(a));\n+            Asserts.assertEQ(a * Long.MAX_VALUE, mulAndAddToMaxL(a));\n+            Asserts.assertEQ(a * Long.MIN_VALUE, mulAndAddToOverflowL(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"bitShiftToOverflow\",\n+            \"bitShiftToOverflowL\"\n+    })\n+    private void runBitShiftTests() {\n+        Asserts.assertEQ(95, bitShiftToOverflow());\n+        Asserts.assertEQ(191L, bitShiftToOverflowL());\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = IRNode.LSHIFT_I)\n+    private static int addTo2(int a) {\n+        return a + a; \/\/ Simple additions like a + a should be kept as-is\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo3(int a) {\n+        return a + a + a; \/\/ a*3 => (a<<1) + a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo4(int a) {\n+        return a + a + a + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int shiftAndAddTo4(int a) {\n+        return (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddTo4(int a) {\n+        return a * 3 + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo5(int a) {\n+        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    private static int addTo6(int a) {\n+        return a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int addTo7(int a) {\n+        return a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo8(int a) {\n+        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo16(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addAndShiftTo16(int a) {\n+        return (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int addTo42(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddTo42(int a) {\n+        return a * 40 + a + a; \/\/ a*41 + a => a*42\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMax(int a) {\n+        return a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - a => (a<<31) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddToOverflow(int a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static int mulAndAddToZero(int a) {\n+        return a * -1 + a; \/\/ 0\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMinus1(int a) {\n+        return a * -2 + a; \/\/ a*-1 => a - (a<<1)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddToMinus42(int a) {\n+        return a * -43 + a; \/\/ a*-42\n+    }\n+\n+    \/\/ --- long tests ---\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToIntOverflowL(long a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.SUB_L, \"1\" })\n+    private static long mulAndAddToMaxL(long a) {\n+        return a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToOverflowL(long a) {\n+        return a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+    }\n+\n+    \/\/ --- bit shift tests ---\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.LSHIFT_I})\n+    private static int bitShiftToOverflow() {\n+        int i, x = 0;\n+        for (i = 0; i < 32; i++) {\n+            x = i;\n+        }\n+\n+        \/\/ x = 31 (phi), i = 32 (phi + 1)\n+        return i + (x << i) + i; \/\/ Expects 32 + 31 + 32 = 95\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.LSHIFT_L})\n+    private static long bitShiftToOverflowL() {\n+        int i, x = 0;\n+        for (i = 0; i < 64; i++) {\n+            x = i;\n+        }\n+\n+        \/\/ x = 63 (phi), i = 64 (phi + 1)\n+        return i + (x << i) + i; \/\/ Expects 64 + 63 + 64 = 191\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"}]}