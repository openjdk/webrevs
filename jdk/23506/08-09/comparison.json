{"files":[{"patch":"@@ -409,0 +409,1 @@\n+\/\/ Note a more generalized pattern (a*b) + (a*c) into a*(b + c) is handled by AddNode::IdealIL().\n@@ -420,0 +421,14 @@\n+  \/\/ Pattern 1: Simple addition pattern (e.g., a + a)\n+  Multiplication mul = find_simple_addition_pattern(in1, bt);\n+\n+  \/\/ Pattern 2: Simple lshift pattern (e.g., a << CON)\n+  if (!is_valid_multiplication(mul, in2)) {\n+    mul = find_simple_lshift_pattern(in1, bt);\n+  }\n+\n+  \/\/ Pattern 3: Simple multiplication pattern (e.g., CON * a)\n+  if (!is_valid_multiplication(mul, in2)) {\n+    mul = find_simple_multiplication_pattern(in1, bt);\n+  }\n+\n+  \/\/ Pattern 4: Power-of-two addition pattern (e.g., (a << CON1) + (a << CON2))\n@@ -422,11 +437,2 @@\n-  Multiplication mul;\n-  if (\n-      ((mul = find_simple_addition_pattern(in1, bt)).valid && mul.variable == in2) ||\n-      ((mul = find_simple_lshift_pattern(in1, bt)).valid && mul.variable == in2) ||\n-      ((mul = find_simple_multiplication_pattern(in1, bt)).valid && mul.variable == in2) ||\n-      ((mul = find_power_of_two_addition_pattern(in1, bt)).valid && mul.variable == in2)\n-      ) {\n-    Node* con = (bt == T_INT)\n-                ? (Node*) phase->intcon((jint) (mul.multiplier + 1)) \/\/ intentional type narrowing to allow overflow at max_jint\n-                : (Node*) phase->longcon((mul.multiplier + 1));\n-    return MulNode::make(con, in2, bt);\n+  if (!is_valid_multiplication(mul, in2)) {\n+    mul = find_power_of_two_addition_pattern(in1, bt);\n@@ -435,1 +441,9 @@\n-  return nullptr;\n+  \/\/ We've tried everything.\n+  if (!is_valid_multiplication(mul, in2)) {\n+    return nullptr;\n+  }\n+\n+  Node* con = (bt == T_INT)\n+              ? (Node*) phase->intcon((jint) (mul.multiplier + 1)) \/\/ intentional type narrowing to allow overflow at max_jint\n+              : (Node*) phase->longcon((mul.multiplier + 1));\n+  return MulNode::make(con, in2, bt);\n@@ -466,2 +480,2 @@\n-\/\/     - MulNode(CON, a)\n-\/\/     - MulNode(a, CON)\n+\/\/     - (1) MulNode(CON, a)\n+\/\/     - (2) MulNode(a, CON)\n@@ -471,0 +485,1 @@\n+    \/\/ Assume pattern (1)\n@@ -476,0 +491,1 @@\n+      \/\/ Swap for pattern (2)\n@@ -490,2 +506,3 @@\n-\/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n-\/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n+\/\/     - (1) AddNode(LShiftNode(a, CON), LShiftNode(a, CON))\n+\/\/     - (2) AddNode(LShiftNode(a, CON), a)\n+\/\/     - (3) AddNode(a, LShiftNode(a, CON))\n@@ -499,0 +516,1 @@\n+    \/\/ Pattern (1)\n@@ -503,0 +521,1 @@\n+    \/\/ Pattern (2)\n@@ -507,0 +526,1 @@\n+    \/\/ Pattern (3)\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":36,"deletions":16,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -52,0 +52,4 @@\n+  inline static bool is_valid_multiplication(const Multiplication& mul, Node* variable) {\n+    return mul.valid && mul.variable == variable;\n+  }\n+\n@@ -56,0 +60,1 @@\n+public:\n@@ -58,1 +63,0 @@\n-public:\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -267,0 +267,6 @@\n+\n+#ifdef ASSERT\n+      \/\/ JDK-8347555: ensure we Ideal() generated power-of-2 patterns expected by the serial addition optimization.\n+      assert(AddNode::find_power_of_two_addition_pattern(res, T_INT).valid, \"\");\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}