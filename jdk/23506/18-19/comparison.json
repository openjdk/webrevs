{"files":[{"patch":"@@ -431,1 +431,1 @@\n-  if (find_power_of_two_addition_pattern(this, bt).valid) {\n+  if (Multiplication::find_power_of_two_addition_pattern(this, bt).is_valid()) {\n@@ -438,1 +438,1 @@\n-  Multiplication mul = find_collapsible_addition_patterns(lhs, rhs, bt);\n+  Multiplication mul = Multiplication::find_collapsible_addition_patterns(lhs, rhs, bt);\n@@ -441,1 +441,1 @@\n-    mul = find_collapsible_addition_patterns(rhs, lhs, bt);\n+    mul = Multiplication::find_collapsible_addition_patterns(rhs, lhs, bt);\n@@ -448,3 +448,3 @@\n-              ? (Node*) phase->intcon(java_add((jint) mul.multiplier, (jint) 1)) \/\/ Overflow at max_jint\n-              : (Node*) phase->longcon(java_add((jlong) mul.multiplier, (jlong) 1));\n-  return MulNode::make(con, mul.variable, bt);\n+              ? static_cast<Node *>(phase->intcon(java_add(static_cast<jint>(mul.multiplier()), 1))) \/\/ Overflow at max_jint\n+              : static_cast<Node *>(phase->longcon(java_add(mul.multiplier(), static_cast<jlong>(1))));\n+  return MulNode::make(con, mul.variable(), bt);\n@@ -459,1 +459,1 @@\n-AddNode::Multiplication AddNode::find_collapsible_addition_patterns(const Node* a, const Node* pattern, BasicType bt) {\n+AddNode::Multiplication AddNode::Multiplication::find_collapsible_addition_patterns(const Node* a, const Node* pattern, BasicType bt) {\n@@ -487,1 +487,1 @@\n-  return Multiplication::make_invalid();\n+  return make_invalid();\n@@ -492,1 +492,1 @@\n-AddNode::Multiplication AddNode::find_simple_addition_pattern(const Node* n, BasicType bt) {\n+AddNode::Multiplication AddNode::Multiplication::find_simple_addition_pattern(const Node* n, BasicType bt) {\n@@ -494,1 +494,1 @@\n-    return Multiplication{true, n->in(1), 2};\n+    return {n->in(1), 2};\n@@ -497,1 +497,1 @@\n-  return Multiplication::make_invalid();\n+  return make_invalid();\n@@ -504,1 +504,1 @@\n-AddNode::Multiplication AddNode::find_simple_lshift_pattern(const Node* n, BasicType bt) {\n+AddNode::Multiplication AddNode::Multiplication::find_simple_lshift_pattern(const Node* n, BasicType bt) {\n@@ -509,1 +509,1 @@\n-      return Multiplication{true, n->in(1), java_shift_left(1, con->get_int(), bt)};\n+      return {n->in(1), java_shift_left(1, con->get_int(), bt)};\n@@ -513,1 +513,1 @@\n-  return Multiplication::make_invalid();\n+  return make_invalid();\n@@ -520,1 +520,1 @@\n-AddNode::Multiplication AddNode::find_simple_multiplication_pattern(const Node* n, BasicType bt) {\n+AddNode::Multiplication AddNode::Multiplication::find_simple_multiplication_pattern(const Node* n, BasicType bt) {\n@@ -534,1 +534,1 @@\n-      return Multiplication{true, base, con->get_integer_as_long(bt)};\n+      return {base, con->get_integer_as_long(bt)};\n@@ -538,1 +538,1 @@\n-  return Multiplication::make_invalid();\n+  return make_invalid();\n@@ -549,1 +549,1 @@\n-AddNode::Multiplication AddNode::find_power_of_two_addition_pattern(const Node* n, BasicType bt) {\n+AddNode::Multiplication AddNode::Multiplication::find_power_of_two_addition_pattern(const Node* n, BasicType bt) {\n@@ -551,2 +551,2 @@\n-    Multiplication lhs = find_simple_lshift_pattern(n->in(1), bt);\n-    Multiplication rhs = find_simple_lshift_pattern(n->in(2), bt);\n+    const Multiplication lhs = find_simple_lshift_pattern(n->in(1), bt);\n+    const Multiplication rhs = find_simple_lshift_pattern(n->in(2), bt);\n@@ -555,2 +555,5 @@\n-    if (lhs.valid && rhs.valid && lhs.variable == rhs.variable) {\n-      return Multiplication{true, lhs.variable, java_add(lhs.multiplier, rhs.multiplier)};\n+    {\n+      const Multiplication res = lhs.add(rhs);\n+      if (res.is_valid()) {\n+        return res;\n+      }\n@@ -560,2 +563,2 @@\n-    if (lhs.valid && lhs.variable == n->in(2)) {\n-      return Multiplication{true, lhs.variable, java_add(lhs.multiplier, (jlong) 1)};\n+    if (lhs.is_valid_with(n->in(2))) {\n+      return {lhs.variable(), java_add(lhs.multiplier(), static_cast<jlong>(1))};\n@@ -565,2 +568,2 @@\n-    if (rhs.valid && rhs.variable == n->in(1)) {\n-      return Multiplication{true, rhs.variable, java_add(rhs.multiplier, (jlong) 1)};\n+    if (rhs.is_valid_with(n->in(1))) {\n+      return {rhs.variable(), java_add(rhs.multiplier(), static_cast<jlong>(1))};\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -46,4 +46,14 @@\n-  struct Multiplication {\n-    bool valid = false;\n-    Node* variable = nullptr;\n-    jlong multiplier = 0;\n+  class Multiplication {\n+    bool _is_valid = false;\n+\n+    Node* _variable = nullptr;\n+    jlong _multiplier = 0;\n+\n+  private:\n+    Multiplication() {}\n+\n+  public:\n+    Multiplication(Node* variable, jlong multiplier) :\n+          _is_valid(true),\n+          _variable(variable),\n+          _multiplier(multiplier) {}\n@@ -52,1 +62,2 @@\n-      return Multiplication{false, nullptr, 0};\n+      static Multiplication invalid = Multiplication();\n+      return invalid;\n@@ -55,0 +66,15 @@\n+    static Multiplication find_collapsible_addition_patterns(const Node* a, const Node* pattern, BasicType bt);\n+    static Multiplication find_simple_addition_pattern(const Node* n, BasicType bt);\n+    static Multiplication find_simple_lshift_pattern(const Node* n, BasicType bt);\n+    static Multiplication find_simple_multiplication_pattern(const Node* n, BasicType bt);\n+    static Multiplication find_power_of_two_addition_pattern(const Node* n, BasicType bt);\n+\n+    Multiplication add(const Multiplication rhs) const {\n+      if (is_valid_with(rhs.variable()) && rhs.is_valid_with(variable())) {\n+        return {variable(), java_add(multiplier(), rhs.multiplier())};\n+      }\n+\n+      return make_invalid();\n+    }\n+\n+    bool is_valid() const { return _is_valid; }\n@@ -56,1 +82,1 @@\n-      return valid && this->variable == variable;\n+      return _is_valid && this->_variable == variable;\n@@ -58,1 +84,0 @@\n-  };\n@@ -60,5 +85,3 @@\n-  static Multiplication find_collapsible_addition_patterns(const Node* a, const Node* pattern, BasicType bt);\n-  static Multiplication find_simple_addition_pattern(const Node* n, BasicType bt);\n-  static Multiplication find_simple_lshift_pattern(const Node* n, BasicType bt);\n-  static Multiplication find_simple_multiplication_pattern(const Node* n, BasicType bt);\n-  static Multiplication find_power_of_two_addition_pattern(const Node* n, BasicType bt);\n+    Node* variable() const { return _variable; }\n+    jlong multiplier() const { return _multiplier; }\n+  };\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"}]}