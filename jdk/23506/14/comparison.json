{"files":[{"patch":"@@ -398,0 +398,6 @@\n+  \/\/ Convert a + a + ... + a into a*n\n+  Node* serial_additions = convert_serial_additions(phase, bt);\n+  if (serial_additions != nullptr) {\n+    return serial_additions;\n+  }\n+\n@@ -401,0 +407,149 @@\n+\/\/ Try to convert a serial of additions into a single multiplication. Also convert `(a * CON) + a` to `(CON + 1) * a` as\n+\/\/ a side effect (see below). On success, a new MulNode is returned.\n+\/\/\n+\/\/ We perform such conversions incrementally during iGVN by transforming left most nodes first and work up to the root\n+\/\/ of the expression. In other words, we convert, at each iteration:\n+\/\/        a + a + a + ... + a\n+\/\/     => 2*a + a + ... + a\n+\/\/     => 3*a + ... + a\n+\/\/     => n*a\n+\/\/\n+\/\/ Due to the iterative nature of iGVN, MulNode transformed from first few AddNode terms may be further transformed into\n+\/\/ power-of-2 pattern. (e.g., 2 * a => a << 1, 3 * a => (a << 2) + a). We can't guarantee we'll always pick up\n+\/\/ transformed power-of-2 patterns when term `a` is complex.\n+\/\/\n+\/\/ Therefore, when matching the LHS `a * CON`, we match with best efforts by looking for the following patterns:\n+\/\/     - (1) Simple addition: a + a\n+\/\/     - (2) Simple lshift: a << CON\n+\/\/     - (3) Simple multiplication: CON * a\n+\/\/     - (4) Power-of-two addition: (a << CON1) + (a << CON2)\n+\/\/\n+\/\/ Note this also converts, for example, original expression `(a*3) + a` into `4*a` and `(a<<2) + a` into `5*a`. A more\n+\/\/ generalized pattern `(a*b) + (a*c)` into `a*(b + c)` is handled by AddNode::IdealIL().\n+Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n+  \/\/ We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n+  \/\/ power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n+  \/\/ node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n+  if (find_power_of_two_addition_pattern(this, bt).valid) {\n+    return nullptr;\n+  }\n+\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+\n+  \/\/ (1) Simple addition pattern (e.g., a + a)\n+  Multiplication mul = find_simple_addition_pattern(in1, bt);\n+\n+  \/\/ (2) Simple lshift pattern (e.g., a << CON)\n+  if (!is_valid_multiplication(mul, in2)) {\n+    mul = find_simple_lshift_pattern(in1, bt);\n+  }\n+\n+  \/\/ (3) Simple multiplication pattern (e.g., CON * a)\n+  if (!is_valid_multiplication(mul, in2)) {\n+    mul = find_simple_multiplication_pattern(in1, bt);\n+  }\n+\n+  \/\/ (4) Power-of-two addition pattern (e.g., (a << CON1) + (a << CON2))\n+  \/\/ While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n+  \/\/ (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n+  if (!is_valid_multiplication(mul, in2)) {\n+    mul = find_power_of_two_addition_pattern(in1, bt);\n+  }\n+\n+  \/\/ We've tried everything.\n+  if (!is_valid_multiplication(mul, in2)) {\n+    return nullptr;\n+  }\n+\n+  Node* con = (bt == T_INT)\n+              ? (Node*) phase->intcon(java_add((jint) mul.multiplier, (jint) 1)) \/\/ Overflow at max_jint\n+              : (Node*) phase->longcon(java_add((jlong) mul.multiplier, (jlong) 1));\n+  return MulNode::make(con, mul.variable, bt);\n+}\n+\n+\/\/ Try to match `a + a`. On success, return a struct with `.valid = true`, `variable = a`, and `multiplier = 2`.\n+\/\/ The method matches `n` for pattern: AddNode(a, a).\n+AddNode::Multiplication AddNode::find_simple_addition_pattern(const Node* n, BasicType bt) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) == n->in(2)) {\n+    return Multiplication{true, n->in(1), 2};\n+  }\n+\n+  return Multiplication{};\n+}\n+\n+\/\/ Try to match `a << CON`. On success, return a struct with `.valid = true`, `variable = a`, and\n+\/\/ `multiplier = 1 << CON`.\n+\/\/ Match `n` for pattern: LShiftNode(a, CON).\n+\/\/ Note that the power-of-2 multiplication optimization could potentially convert a MulNode to this pattern.\n+AddNode::Multiplication AddNode::find_simple_lshift_pattern(const Node* n, BasicType bt) {\n+  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n+  if (n->Opcode() == Op_LShift(bt) && n->in(2)->is_Con()) {\n+    Node* con = n->in(2);\n+    if (!con->is_top()) {\n+      return Multiplication{true, n->in(1), java_shift_left(1, con->get_int(), bt)};\n+    }\n+  }\n+\n+  return Multiplication{};\n+}\n+\n+\/\/ Try to match `CON * a`. On success, return a struct with `.valid = true`, `variable = a`, and `multiplier = CON`.\n+\/\/ Match `n` for patterns:\n+\/\/     - (1) MulNode(CON, a)\n+\/\/     - (2) MulNode(a, CON)\n+AddNode::Multiplication AddNode::find_simple_multiplication_pattern(const Node* n, BasicType bt) {\n+  \/\/ This optimization technically only produces MulNode(CON, a), but we might as match MulNode(a, CON), too.\n+  if (n->Opcode() == Op_Mul(bt) && (n->in(1)->is_Con() || n->in(2)->is_Con())) {\n+    \/\/ Pattern (1)\n+    Node* con = n->in(1);\n+    Node* base = n->in(2);\n+\n+    \/\/ Pattern (2)\n+    if (!con->is_Con()) {\n+      \/\/ swap ConNode to lhs for easier matching\n+      swap(con, base);\n+    }\n+\n+    if (!con->is_top()) {\n+      return Multiplication{true, base, con->get_integer_as_long(bt)};\n+    }\n+  }\n+\n+  return Multiplication{};\n+}\n+\n+\/\/ Try to match `(a << CON1) + (a << CON2)`. On success, return a struct with `.valid = true`, `variable = a`, and\n+\/\/ `multiplier = (1 << CON1) + (1 << CON2)`.\n+\/\/ Match `n` for patterns:\n+\/\/     - (1) AddNode(LShiftNode(a, CON), LShiftNode(a, CON))\n+\/\/     - (2) AddNode(LShiftNode(a, CON), a)\n+\/\/     - (3) AddNode(a, LShiftNode(a, CON))\n+\/\/     - (4) AddNode(a, a)\n+\/\/ Note that one or both of the term of the addition could simply be `a` (i.e., a << 0) as in pattern (4).\n+AddNode::Multiplication AddNode::find_power_of_two_addition_pattern(const Node* n, BasicType bt) {\n+  if (n->Opcode() == Op_Add(bt) && n->in(1) != n->in(2)) {\n+    Multiplication lhs = find_simple_lshift_pattern(n->in(1), bt);\n+    Multiplication rhs = find_simple_lshift_pattern(n->in(2), bt);\n+\n+    \/\/ Pattern (1)\n+    if (lhs.valid && rhs.valid && lhs.variable == rhs.variable) {\n+      return Multiplication{true, lhs.variable, java_add(lhs.multiplier, rhs.multiplier)};\n+    }\n+\n+    \/\/ Pattern (2)\n+    if (lhs.valid && lhs.variable == n->in(2)) {\n+      return Multiplication{true, lhs.variable, java_add(lhs.multiplier, (jlong) 1)};\n+    }\n+\n+    \/\/ Pattern (3)\n+    if (rhs.valid && rhs.variable == n->in(1)) {\n+      return Multiplication{true, rhs.variable, java_add(rhs.multiplier, (jlong) 1)};\n+    }\n+\n+    \/\/ Pattern (4), which is equivalent to a simple addition pattern\n+    return find_simple_addition_pattern(n, bt);\n+  }\n+\n+  return Multiplication{};\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -45,1 +45,18 @@\n-public:\n+\n+  struct Multiplication {\n+    bool valid = false;\n+    Node* variable = nullptr;\n+    jlong multiplier = 0;\n+  };\n+\n+  inline static bool is_valid_multiplication(const Multiplication& mul, const Node* variable) {\n+    return mul.valid && mul.variable == variable;\n+  }\n+\n+  Node* convert_serial_additions(PhaseGVN* phase, BasicType bt);\n+  static Multiplication find_simple_addition_pattern(const Node* n, BasicType bt);\n+  static Multiplication find_simple_lshift_pattern(const Node* n, BasicType bt);\n+  static Multiplication find_simple_multiplication_pattern(const Node* n, BasicType bt);\n+  static Multiplication find_power_of_two_addition_pattern(const Node* n, BasicType bt);\n+\n+ public:\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1263,0 +1263,18 @@\n+\/\/ Some convenient bit shift operations that accepts a BasicType as the last\n+\/\/ argument. These avoid potential mistakes with overloaded functions only\n+\/\/ distinguished by lhs argument type.\n+#define JAVA_INTEGER_SHIFT_BASIC_TYPE(FUNC)            \\\n+inline jlong FUNC(jlong lhs, jint rhs, BasicType bt) { \\\n+  if (bt == T_INT) {                                   \\\n+    return FUNC((jint) lhs, rhs);                      \\\n+  }                                                    \\\n+  assert(bt == T_LONG, \"unsupported basic type\");      \\\n+  return FUNC(lhs, rhs);                              \\\n+}\n+\n+JAVA_INTEGER_SHIFT_BASIC_TYPE(java_shift_left)\n+JAVA_INTEGER_SHIFT_BASIC_TYPE(java_shift_right)\n+JAVA_INTEGER_SHIFT_BASIC_TYPE(java_shift_right_unsigned)\n+\n+#undef JAVA_INTERGER_SHIFT_BASIC_TYPE\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_left(data[i].x, data[i].shift, T_INT));\n@@ -202,0 +203,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_left(data[i].x, data[i].shift, T_LONG));\n@@ -265,0 +267,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right(data[i].x, data[i].shift, T_INT));\n@@ -272,0 +275,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right(data[i].x, data[i].shift, T_LONG));\n@@ -337,0 +341,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right_unsigned(data[i].x, data[i].shift, T_INT));\n@@ -344,0 +349,1 @@\n+    ASSERT_EQ(data[i].r, java_shift_right_unsigned(data[i].x, data[i].shift, T_LONG));\n","filename":"test\/hotspot\/gtest\/utilities\/test_java_arithmetic.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,335 @@\n+\/*\n+ * Copyright (c) 2025 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8325495 8347555\n+ * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestSerialAdditions\n+ *\/\n+public class TestSerialAdditions {\n+    private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"addTo2\",\n+            \"addTo3\",\n+            \"addTo4\",\n+            \"shiftAndAddTo4\",\n+            \"mulAndAddTo4\",\n+            \"addTo5\",\n+            \"addTo6\",\n+            \"addTo7\",\n+            \"addTo8\",\n+            \"addTo16\",\n+            \"addAndShiftTo16\",\n+            \"addTo42\",\n+            \"mulAndAddTo42\",\n+            \"mulAndAddToMax\",\n+            \"mulAndAddToOverflow\",\n+            \"mulAndAddToZero\",\n+            \"mulAndAddToMinus1\",\n+            \"mulAndAddToMinus42\"\n+    })\n+    private void runIntTests() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, GEN_INT.next() }) {\n+            Asserts.assertEQ(a * 2, addTo2(a));\n+            Asserts.assertEQ(a * 3, addTo3(a));\n+            Asserts.assertEQ(a * 4, addTo4(a));\n+            Asserts.assertEQ(a * 4, shiftAndAddTo4(a));\n+            Asserts.assertEQ(a * 4, mulAndAddTo4(a));\n+            Asserts.assertEQ(a * 5, addTo5(a));\n+            Asserts.assertEQ(a * 6, addTo6(a));\n+            Asserts.assertEQ(a * 7, addTo7(a));\n+            Asserts.assertEQ(a * 8, addTo8(a));\n+            Asserts.assertEQ(a * 16, addTo16(a));\n+            Asserts.assertEQ(a * 16, addAndShiftTo16(a));\n+            Asserts.assertEQ(a * 42, addTo42(a));\n+            Asserts.assertEQ(a * 42, mulAndAddTo42(a));\n+            Asserts.assertEQ(a * Integer.MAX_VALUE, mulAndAddToMax(a));\n+            Asserts.assertEQ(a * Integer.MIN_VALUE, mulAndAddToOverflow(a));\n+            Asserts.assertEQ(0, mulAndAddToZero(a));\n+            Asserts.assertEQ(a * -1, mulAndAddToMinus1(a));\n+            Asserts.assertEQ(a * -42, mulAndAddToMinus42(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"mulAndAddToIntOverflowL\",\n+            \"mulAndAddToMaxL\",\n+            \"mulAndAddToOverflowL\"\n+    })\n+    private void runLongTests() {\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, GEN_LONG.next() }) {\n+            Asserts.assertEQ(a * (Integer.MAX_VALUE + 1L), mulAndAddToIntOverflowL(a));\n+            Asserts.assertEQ(a * Long.MAX_VALUE, mulAndAddToMaxL(a));\n+            Asserts.assertEQ(a * Long.MIN_VALUE, mulAndAddToOverflowL(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"bitShiftToOverflow\",\n+            \"bitShiftToOverflowL\"\n+    })\n+    private void runBitShiftTests() {\n+        Asserts.assertEQ(95, bitShiftToOverflow());\n+        Asserts.assertEQ(191L, bitShiftToOverflowL());\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = IRNode.LSHIFT_I)\n+    private static int addTo2(int a) {\n+        return a + a; \/\/ Simple additions like a + a should be kept as-is\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo3(int a) {\n+        return a + a + a; \/\/ a*3 => (a<<1) + a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo4(int a) {\n+        return a + a + a + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int shiftAndAddTo4(int a) {\n+        return (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddTo4(int a) {\n+        return a * 3 + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo5(int a) {\n+        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    private static int addTo6(int a) {\n+        return a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int addTo7(int a) {\n+        return a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo8(int a) {\n+        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo16(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addAndShiftTo16(int a) {\n+        return (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int addTo42(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddTo42(int a) {\n+        return a * 40 + a + a; \/\/ a*41 + a => a*42\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMax(int a) {\n+        return a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - a => (a<<31) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddToOverflow(int a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static int mulAndAddToZero(int a) {\n+        return a * -1 + a; \/\/ 0\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMinus1(int a) {\n+        return a * -2 + a; \/\/ a*-1 => a - (a<<1)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddToMinus42(int a) {\n+        return a * -43 + a; \/\/ a*-42\n+    }\n+\n+    \/\/ --- long tests ---\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToIntOverflowL(long a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.SUB_L, \"1\" })\n+    private static long mulAndAddToMaxL(long a) {\n+        return a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToOverflowL(long a) {\n+        return a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+    }\n+\n+    \/\/ --- bit shift tests ---\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I, IRNode.LSHIFT_I})\n+    private static int bitShiftToOverflow() {\n+        int i, x = 0;\n+        for (i = 0; i < 32; i++) {\n+            x = i;\n+        }\n+\n+        \/\/ x = 31 (phi), i = 32 (phi + 1)\n+        return i + (x << i) + i; \/\/ Expects 32 + 31 + 32 = 95\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_L, IRNode.LSHIFT_L})\n+    private static long bitShiftToOverflowL() {\n+        int i, x = 0;\n+        for (i = 0; i < 64; i++) {\n+            x = i;\n+        }\n+\n+        \/\/ x = 63 (phi), i = 64 (phi + 1)\n+        return i + (x << i) + i; \/\/ Expects 64 + 63 + 64 = 191\n+    }\n+\n+    \/\/ --- random tests ---\n+    private static final int CON1_I, CON2_I, CON3_I, CON4_I;\n+    private static final long CON1_L, CON2_L, CON3_L, CON4_L;\n+\n+    static {\n+        CON1_I = GEN_INT.next();\n+        CON2_I = GEN_INT.next();\n+        CON3_I = GEN_INT.next();\n+        CON4_I = GEN_INT.next();\n+\n+        CON1_L = GEN_LONG.next();\n+        CON2_L = GEN_LONG.next();\n+        CON3_L = GEN_LONG.next();\n+        CON4_L = GEN_LONG.next();\n+    }\n+\n+    @Run(test = {\n+            \"randomPowerOfTwoAddition\",\n+            \"randomPowerOfTwoAdditionL\"\n+    })\n+    private void runRandomPowerOfTwoAddition() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, GEN_INT.next() }) {\n+            Asserts.assertEQ(a * (CON1_I + CON2_I + CON3_I + CON4_I), randomPowerOfTwoAddition(a));\n+        }\n+\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, GEN_LONG.next() }) {\n+            Asserts.assertEQ(a * (CON1_L + CON2_L + CON3_L + CON4_L), randomPowerOfTwoAdditionL(a));\n+        }\n+    }\n+\n+    \/\/ We can't do IR verification but only check for correctness for a better confidence.\n+    @Test\n+    private static int randomPowerOfTwoAddition(int a) {\n+        return a * CON1_I + a * CON2_I + a * CON3_I + a * CON4_I;\n+    }\n+\n+    @Test\n+    private static long randomPowerOfTwoAdditionL(long a) {\n+        return a * CON1_L + a * CON2_L + a * CON3_L + a * CON4_L;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":335,"deletions":0,"binary":false,"changes":335,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests speed of adding a series of additions of the same operand.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class SerialAdditions {\n+    private int a = 0xBADB0BA;\n+    private long b = 0x900dba51l;\n+\n+    @Benchmark\n+    public int addIntsTo02() {\n+        return a + a; \/\/ baseline, still a + a\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo04() {\n+        return a + a + a + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo05() {\n+        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo06() {\n+        return a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo08() {\n+        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo16() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo23() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a; \/\/ a*23\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo32() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a; \/\/ a*32 => a<<5\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo42() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a; \/\/ a*42\n+    }\n+\n+    @Benchmark\n+    public int addIntsTo64() {\n+        return a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a + a + a + a + a + a + a \/\/\n+                + a + a + a + a; \/\/ 64 * a => a << 6\n+    }\n+\n+    @Benchmark\n+    public void addIntsMixed(Blackhole blackhole) {\n+        blackhole.consume(addIntsTo02());\n+        blackhole.consume(addIntsTo04());\n+        blackhole.consume(addIntsTo05());\n+        blackhole.consume(addIntsTo06());\n+        blackhole.consume(addIntsTo08());\n+        blackhole.consume(addIntsTo16());\n+        blackhole.consume(addIntsTo23());\n+        blackhole.consume(addIntsTo32());\n+        blackhole.consume(addIntsTo42());\n+        blackhole.consume(addIntsTo64());\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo02() {\n+        return b + b; \/\/ baseline, still a + a\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo04() {\n+        return b + b + b + b; \/\/ a*4 => a<<2\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo05() {\n+        return b + b + b + b + b; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo06() {\n+        return b + b + b + b + b + b; \/\/ a*6 => (a<<1) + (a<<2)\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo08() {\n+        return b + b + b + b + b + b + b + b; \/\/ a*8 => a<<3\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo16() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b; \/\/ a*16 => a<<4\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo23() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b; \/\/ a*23\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo32() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b; \/\/ a*32 => a<<5\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo42() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b; \/\/ a*42\n+    }\n+\n+    @Benchmark\n+    public long addLongsTo64() {\n+        return b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b + b + b + b + b + b + b \/\/\n+                + b + b + b + b; \/\/ 64 * a => a << 6\n+    }\n+\n+    @Benchmark\n+    public void addLongsMixed(Blackhole blackhole) {\n+        blackhole.consume(addLongsTo02());\n+        blackhole.consume(addLongsTo04());\n+        blackhole.consume(addLongsTo05());\n+        blackhole.consume(addLongsTo06());\n+        blackhole.consume(addLongsTo08());\n+        blackhole.consume(addLongsTo16());\n+        blackhole.consume(addLongsTo23());\n+        blackhole.consume(addLongsTo32());\n+        blackhole.consume(addLongsTo42());\n+        blackhole.consume(addLongsTo64());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SerialAdditions.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}