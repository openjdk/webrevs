{"files":[{"patch":"@@ -413,1 +413,1 @@\n-  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n+  if (find_power_of_two_addition_pattern(this, bt).valid) {\n@@ -419,1 +419,0 @@\n-  jlong multiplier;\n@@ -423,6 +422,7 @@\n-  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n-      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n-      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n-      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n-    multiplier++; \/\/ +1 for the in2 term\n-\n+  Multiplication mul;\n+  if (\n+      ((mul = find_simple_addition_pattern(in1, bt)).valid && mul.variable == in2) ||\n+      ((mul = find_simple_lshift_pattern(in1, bt)).valid && mul.variable == in2) ||\n+      ((mul = find_simple_multiplication_pattern(in1, bt)).valid && mul.variable == in2) ||\n+      ((mul = find_power_of_two_addition_pattern(in1, bt)).valid && mul.variable == in2)\n+      ) {\n@@ -430,2 +430,2 @@\n-                ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n-                : (Node*) phase->longcon(multiplier);\n+                ? (Node*) phase->intcon((jint) (mul.multiplier + 1)) \/\/ intentional type narrowing to allow overflow at max_jint\n+                : (Node*) phase->longcon((mul.multiplier + 1));\n@@ -438,1 +438,1 @@\n-\/\/ Try to match `a + a`. On success, return `a` and set `2` as `multiplier`.\n+\/\/ Try to match `a + a`. On success, return a struct with `.valid = true`, `variable = a`, and `multiplier = 2`.\n@@ -440,1 +440,1 @@\n-Node* AddNode::find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+AddNode::Multiplication AddNode::find_simple_addition_pattern(Node* n, BasicType bt) {\n@@ -442,2 +442,1 @@\n-    *multiplier = 2;\n-    return n->in(1);\n+    return Multiplication{true, n->in(1), 2};\n@@ -446,1 +445,1 @@\n-  return nullptr;\n+  return Multiplication{};\n@@ -449,1 +448,2 @@\n-\/\/ Try to match `a << CON`. On success, return `a` and set `1 << CON` as `multiplier`.\n+\/\/ Try to match `a << CON`. On success, return a struct with `.valid = true`, `variable = a`, and\n+\/\/ `multiplier = 1 << CON`.\n@@ -452,1 +452,1 @@\n-Node* AddNode::find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+AddNode::Multiplication AddNode::find_simple_lshift_pattern(Node* n, BasicType bt) {\n@@ -456,2 +456,2 @@\n-    if (con->is_top()) {\n-      return nullptr;\n+    if (!con->is_top()) {\n+      return Multiplication{true, n->in(1), java_shift_left(1, con->get_int(), bt)};\n@@ -459,3 +459,0 @@\n-\n-    *multiplier = java_shift_left(1, con->get_int(), bt);\n-    return n->in(1);\n@@ -464,1 +461,1 @@\n-  return nullptr;\n+  return Multiplication{};\n@@ -467,1 +464,1 @@\n-\/\/ Try to match `CON * a`. On success, return `a` and set `CON` as `multiplier`.\n+\/\/ Try to match `CON * a`. On success, return a struct with `.valid = true`, `variable = a`, and `multiplier = CON`.\n@@ -471,1 +468,1 @@\n-Node* AddNode::find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+AddNode::Multiplication AddNode::find_simple_multiplication_pattern(Node* n, BasicType bt) {\n@@ -482,2 +479,2 @@\n-    if (con->is_top()) {\n-      return nullptr;\n+    if (!con->is_top()) {\n+      return Multiplication{true, base, con->get_integer_as_long(bt)};\n@@ -485,3 +482,0 @@\n-\n-    *multiplier = con->get_integer_as_long(bt);\n-    return base;\n@@ -490,1 +484,1 @@\n-  return nullptr;\n+  return Multiplication{};\n@@ -493,1 +487,2 @@\n-\/\/ Try to match `(a << CON1) + (a << CON2)`. On success, return `a` and set `(1 << CON1) + (1 << CON2)` as `multiplier`.\n+\/\/ Try to match `(a << CON1) + (a << CON2)`. On success, return a struct with `.valid = true`, `variable = a`, and\n+\/\/ `multiplier = (1 << CON1) + (1 << CON2)`.\n@@ -498,3 +493,2 @@\n-\/\/ Note that one of the term of the addition could simply be `a` (i.e., a << 0). Calling this function with `multiplier`\n-\/\/ being null is safe.\n-Node* AddNode::find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n+\/\/ Note that one of the term of the addition could simply be `a` (i.e., a << 0).\n+AddNode::Multiplication AddNode::find_power_of_two_addition_pattern(Node* n, BasicType bt) {\n@@ -502,12 +496,2 @@\n-    Node* lhs = n->in(1);\n-    Node* rhs = n->in(2);\n-\n-    \/\/ swap LShiftNode to lhs for easier matching\n-    if (lhs->Opcode() != Op_LShift(bt)) {\n-      swap(lhs, rhs);\n-    }\n-\n-    \/\/ AddNode(LShiftNode(a, CON), *)?\n-    if (lhs->Opcode() != Op_LShift(bt) || !lhs->in(2)->is_Con()) {\n-      return nullptr;\n-    }\n+    Multiplication lhs = find_simple_lshift_pattern(n->in(1), bt);\n+    Multiplication rhs = find_simple_lshift_pattern(n->in(2), bt);\n@@ -515,8 +499,2 @@\n-    jlong lhs_multiplier = 0;\n-    if (multiplier != nullptr) {\n-      Node* con = lhs->in(2);\n-      if (con->is_top()) {\n-        return nullptr;\n-      }\n-\n-      lhs_multiplier = java_shift_left(1, con->get_int(), bt);\n+    if (lhs.valid && rhs.valid && lhs.variable == rhs.variable) {\n+      return Multiplication{true, lhs.variable, lhs.multiplier + rhs.multiplier};\n@@ -525,7 +503,2 @@\n-    \/\/ AddNode(LShiftNode(a, CON), a)?\n-    if (lhs->in(1) == rhs) {\n-      if (multiplier != nullptr) {\n-        *multiplier = lhs_multiplier + 1;\n-      }\n-\n-      return rhs;\n+    if (lhs.valid && !rhs.valid && lhs.variable == n->in(2)) {\n+      return Multiplication{true, lhs.variable, lhs.multiplier + 1};\n@@ -534,12 +507,2 @@\n-    \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n-    if (rhs->Opcode() == Op_LShift(bt) && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n-      if (multiplier != nullptr) {\n-        Node* con = rhs->in(2);\n-        if (con->is_top()) {\n-          return nullptr;\n-        }\n-\n-        *multiplier = lhs_multiplier + java_shift_left(1, con->get_int(), bt);\n-      }\n-\n-      return lhs->in(1);\n+    if (!lhs.valid && rhs.valid && rhs.variable == n->in(1)) {\n+      return Multiplication{true, rhs.variable, rhs.multiplier + 1};\n@@ -547,1 +510,0 @@\n-    return nullptr;\n@@ -549,1 +511,2 @@\n-  return nullptr;\n+\n+  return Multiplication{};\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":39,"deletions":76,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -46,0 +46,6 @@\n+  struct Multiplication {\n+    bool valid = false;\n+    Node* variable = nullptr;\n+    jlong multiplier = 0;\n+  };\n+\n@@ -47,4 +53,4 @@\n-  static Node* find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n-  static Node* find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier);\n-  static Node* find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier);\n-  static Node* find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier);\n+  static Multiplication find_simple_addition_pattern(Node* n, BasicType bt);\n+  static Multiplication find_simple_lshift_pattern(Node* n, BasicType bt);\n+  static Multiplication find_simple_multiplication_pattern(Node* n, BasicType bt);\n+  static Multiplication find_power_of_two_addition_pattern(Node* n, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    private static final Random RNG = Utils.getRandomInstance();\n+    private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n@@ -70,1 +71,1 @@\n-        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, RNG.nextInt() }) {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, GEN_INT.next() }) {\n@@ -98,1 +99,1 @@\n-        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, RNG.nextLong() }) {\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, GEN_LONG.next() }) {\n@@ -299,11 +300,9 @@\n-        RestrictableGenerator<Integer> genI = Generators.G.powerOfTwoInts(16);\n-        CON1_I = genI.next();\n-        CON2_I = genI.next();\n-        CON3_I = genI.next();\n-        CON4_I = genI.next();\n-\n-        RestrictableGenerator<Long> genL = Generators.G.powerOfTwoLongs(16);\n-        CON1_L = genL.next();\n-        CON2_L = genL.next();\n-        CON3_L = genL.next();\n-        CON4_L = genL.next();\n+        CON1_I = GEN_INT.next();\n+        CON2_I = GEN_INT.next();\n+        CON3_I = GEN_INT.next();\n+        CON4_I = GEN_INT.next();\n+\n+        CON1_L = GEN_LONG.next();\n+        CON2_L = GEN_LONG.next();\n+        CON3_L = GEN_LONG.next();\n+        CON4_L = GEN_LONG.next();\n@@ -317,1 +316,1 @@\n-        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, RNG.nextInt() }) {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, GEN_INT.next() }) {\n@@ -321,1 +320,1 @@\n-        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, RNG.nextLong() }) {\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, GEN_LONG.next() }) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"}]}