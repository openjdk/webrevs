{"files":[{"patch":"@@ -207,2 +207,3 @@\n-        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY MAX_MEM RUN_PROBLEM_LISTS \\\n-        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n+        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY JVMTI_STRESS_AGENT \\\n+        MAX_MEM RUN_PROBLEM_LISTS RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT \\\n+        AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n@@ -879,0 +880,9 @@\n+  ifneq ($$(JTREG_JVMTI_STRESS_AGENT), )\n+    AGENT := $$(LIBRARY_PREFIX)JvmtiStressAgent$$(SHARED_LIBRARY_SUFFIX)=$$(JTREG_JVMTI_STRESS_AGENT)\n+    $1_JTREG_BASIC_OPTIONS += -javaoption:'-agentpath:${TEST_IMAGE_DIR}\/hotspot\/jtreg\/native\/$${AGENT}'\n+    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \\\n+\t$$(addprefix $$($1_TEST_ROOT)\/, ProblemList-jvmti-stress-agent.txt) \\\n+    ))\n+  endif\n+\n+\n","filename":"make\/RunTests.gmk","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -179,0 +179,16 @@\n+\n+# These settings are needed to run testing with jvmti agent\n+ifeq ($(OPENJDK_BUILD_OS), linux)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .so\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), windows)\n+  LIBRARY_PREFIX :=\n+  SHARED_LIBRARY_SUFFIX := .dll\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), macosx)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .dylib\n+endif\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+compiler\/macronodes\/TestTopInMacroElimination.java      8362832 generic-all\n+\n+gc\/stringdedup\/TestStringDeduplicationAgeThreshold.java 8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationInterned.java     8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationPrintOptions.java 8362562 generic-all\n+\n+\n+serviceability\/jvmti\/events\/SingleStep\/singlestep02\/singlestep02.java       8362350 generic-all\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t007\/TestDescription.java\t8362350 generic-all\n+\n+# Incompatbile tests\n+\n+# IR\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-A            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-U            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-U           0000000 generic-all\n+\n+# Requires solo jvmti capabilities\n+\n+compiler\/jvmci\/events\/JvmciShutdownEventTest.java                           0000000 generic-all\n+\n+# jdwp\n+runtime\/6294277\/SourceDebugExtension.java                                   0000000 generic-all\n+\n+# heap stats\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorArrayAllSampledTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorEventOnOffTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCParallelTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCSerialTest.java                         0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCTest.java                               0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorIllegalArgumentTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInitialAllocationTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterArrayTest.java                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterObjectTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorMultiArrayTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorNoCapabilityTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorRecursiveTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatArrayCorrectnessTest.java             0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatIntervalTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatObjectCorrectnessTest.java            0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatSimpleTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTest.java                                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadDisabledTest.java                   0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadOnOffTest.java                      0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadTest.java                           0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTwoAgentsTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id0                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id1                     0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-jvmti-stress-agent.txt","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+import jtreg.SkippedException;\n@@ -352,0 +353,1 @@\n+        checkCompatibleFlags();\n@@ -778,0 +780,8 @@\n+    private void checkCompatibleFlags() {\n+        for (String flag : Utils.getTestJavaOpts()) {\n+            if (flag.contains(\"-agentpath\")) {\n+                throw new SkippedException(\"Can't run test with agent.\");\n+            }\n+        }\n+    }\n+\n@@ -784,0 +794,3 @@\n+            if (flag.contains(\"agentpath\")) {\n+                throw new SkippedException(\"Can't run test with -javaagent\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java                         8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java              8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/ResumptionUpdateBoundValues.java            8362658 generic-all\n+sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java                       8362658 generic-all\n+\n+\n+# List of tests incompatible with jvmti stress agent or requiring more investigation\n+\n+com\/sun\/jdi\/EATests.java#id0                                                0000000 generic-all\n+com\/sun\/jdi\/ThreadMemoryLeakTest.java                                       0000000 generic-all\n+\n+# weak referenced are not cleared\n+java\/lang\/WeakPairMap\/Driver.java                                           0000000 generic-all\n+java\/lang\/ref\/ReachabilityFenceTest.java                                    0000000 generic-all\n","filename":"test\/jdk\/ProblemList-jvmti-stress-agent.txt","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -425,1 +425,6 @@\n-        return \"\" + WB.isCDSIncluded();\n+        boolean noJvmtiAdded = allFlags()\n+                .filter(s -> s.startsWith(\"-agentpath\"))\n+                .findAny()\n+                .isEmpty();\n+\n+        return \"\" + (noJvmtiAdded && WB.isCDSIncluded());\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,990 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+\/*\n+*\n+ * The jtreg tests might be executed with this agent to ensure that corresponding\n+ * JDK functionality is not broken.\n+ *\n+ * IMPORTANT\n+ * The tests that are incompatible with agent should be placed\n+ * into ProblemList-jvmti-stress-agent.txt with 000000 bug.\n+ *\n+ * Test supports 2 modes:\n+ *   - standard, where the agent doesn't require debugging capabilities\n+ *   - debug, where the agent  additionally test debug-related functionality\n+ *   The debug mode is incompatible with debugger tests and debug jvmti tests.\n+ *   The standard mode should be compatible with all tests except probelmlisted.\n+ *\n+ *   The JVMTI agent starts jvmti agent tread that enable\/disable different\n+ *   events and call different jvmti functions concurrently with test execution.\n+ *\n+ *   The main requirement is to don't change test behaviour.\n+ *\n+ *\/\n+\n+#define JVMTI_AGENT_NAME \"JvmtiStressAgent\"\n+\n+\/* Global settings and some statistics counters *\/\n+typedef struct {\n+\n+  \/* Verbose logging support *\/\n+  jboolean is_verbose;\n+\n+  \/* If debugging functionality could be used. Set from agent args.*\/\n+  jboolean is_debugger_enabled;\n+\n+  \/* Monitor and flags to synchronize agent completion.*\/\n+  jrawMonitorID finished_lock;\n+  volatile jboolean request_agent_thread_stop;\n+  volatile jboolean is_agent_finished;\n+\n+  \/* Some settings configured in gdata_init(). *\/\n+\n+  \/* If agent enabled or not. *\/\n+  jboolean is_tracing_enabled;\n+\n+  \/* If events testing is enabled. *\/\n+  jboolean are_events_enabled;\n+\n+  \/* If interponly and frequent events testing is enabled. *\/\n+  jboolean are_frequent_events_enabled;\n+\n+  \/* Should we iterate heap *\/\n+  jboolean is_heap_iterate_enabled;\n+\n+  \/* Is Heap sampling enabled *\/\n+  jboolean is_heap_sampling_enabled;\n+\n+  jint heap_sampling_interval;\n+  jint events_interval;\n+  jint frequent_events_interval;\n+\n+  \/* Excluded events *\/\n+  jint* events_excluded;\n+  jsize events_excluded_size;\n+\n+  \/* Event statistics *\/\n+\n+  \/* The counters are racy intentionally to avoid synchronization. *\/\n+  jlong cbBreakpoint;\n+  jlong cbClassFileLoadHook;\n+  jlong cbClassLoad;\n+  jlong cbClassPrepare;\n+  jlong cbCompiledMethodLoad;\n+  jlong cbCompiledMethodUnload;\n+  jlong cbDataDumpRequest;\n+  jlong cbDynamicCodeGenerated;\n+  jlong cbException;\n+  jlong cbExceptionCatch;\n+  jlong cbFieldAccess;\n+  jlong cbFieldModification;\n+  jlong cbFramePop;\n+  jlong cbGarbageCollectionFinish;\n+  jlong cbGarbageCollectionStart;\n+  jlong cbMethodEntry;\n+  jlong cbMethodExit;\n+  jlong cbMonitorContendedEnter;\n+  jlong cbMonitorContendedEntered;\n+  jlong cbMonitorWait;\n+  jlong cbMonitorWaited;\n+  jlong cbNativeMethodBind;\n+  jlong cbObjectFree;\n+  jlong cbResourceExhausted;\n+  jlong cbSampledObjectAlloc;\n+  jlong cbSingleStep;\n+  jlong cbThreadEnd;\n+  jlong cbThreadStart;\n+  jlong cbVirtualThreadEnd;\n+  jlong cbVirtualThreadStart;\n+  jlong cbVMDeath;\n+  jlong cbVMInit;\n+  jlong cbVMObjectAlloc;\n+\n+  \/* Inspector statistics are intentionally racy. *\/\n+  jlong inspectedMethods;\n+  jlong inspectedVariables;\n+\n+  \/* File for debug output, agent shouldn't write into stdout. *\/\n+  FILE* log_file;\n+} GlobalData;\n+\n+GlobalData *gdata;\n+\n+static GlobalData*\n+gdata_init(jboolean is_debugger_enabled, jboolean is_verbose) {\n+  static GlobalData data;\n+  (void) memset(&data, 0, sizeof (GlobalData));\n+\n+  data.is_debugger_enabled = is_debugger_enabled;\n+  data.is_verbose = is_verbose;\n+\n+  data.request_agent_thread_stop = JNI_FALSE;\n+  data.is_agent_finished = JNI_FALSE;\n+\n+  \/* Set jvmti stress properties *\/\n+  data.heap_sampling_interval = 1000;\n+  data.frequent_events_interval = 10;\n+\n+  data.is_tracing_enabled = JNI_TRUE;\n+  data.are_events_enabled = JNI_TRUE;\n+  data.are_frequent_events_enabled = JNI_TRUE;\n+  \/\/ disabled so far\n+  data.is_heap_iterate_enabled = JNI_FALSE;\n+  data.is_heap_sampling_enabled = JNI_FALSE;\n+\n+\n+  if (data.is_debugger_enabled) {\n+    data.events_excluded_size = 0;\n+    data.events_excluded = nullptr;\n+  } else {\n+    data.events_excluded_size = 4;\n+    data.events_excluded = new jint[] {\n+      JVMTI_EVENT_BREAKPOINT,\n+      JVMTI_EVENT_FIELD_ACCESS,\n+      JVMTI_EVENT_FIELD_MODIFICATION,\n+      JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,\n+    };\n+  }\n+  if (data.is_verbose) {\n+    data.log_file = fopen(\"JvmtiStressAgent.out\", \"w\");\n+  }\n+\n+  return &data;\n+}\n+\n+void\n+gdata_close() {\n+  free(gdata->events_excluded);\n+  if (gdata->is_verbose) {\n+    fclose(gdata->log_file);\n+  }\n+}\n+\n+\/\/ Internal buffer length for all messages\n+#define MESSAGE_LIMIT 16384\n+\n+void\n+debug(const char* format, ...) {\n+  if (!gdata->is_verbose) {\n+    return;\n+  }\n+  char dest[MESSAGE_LIMIT];\n+  va_list argptr;\n+  va_start(argptr, format);\n+  vsnprintf(dest, MESSAGE_LIMIT, format, argptr);\n+  va_end(argptr);\n+  \/\/ Enable if needed, tests might fail with unexpected output\n+  \/\/printf(\"%s\\n\", dest);\n+  fprintf(gdata->log_file, \"%s\\n\", dest);\n+  fflush(gdata->log_file);\n+}\n+\n+\/* Some helper functions to start\/stop jvmti stress agent thread. *\/\n+void\n+check_jni_exception(JNIEnv *jni, const char *message) {\n+  jobject exception = jni->ExceptionOccurred();\n+  if (exception != nullptr) {\n+    jni->ExceptionDescribe();\n+    fatal(jni, message);\n+  }\n+}\n+\n+jclass\n+find_class(JNIEnv *jni, const char *name) {\n+  char message[MESSAGE_LIMIT];\n+  jclass clazz = jni->FindClass(name);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find class %s.\", name);\n+  check_jni_exception(jni, message);\n+  return clazz;\n+}\n+\n+jmethodID\n+get_method_id(JNIEnv *jni, jclass clazz, const char *name, const char *sig) {\n+  char message[MESSAGE_LIMIT];\n+  jmethodID method = jni->GetMethodID(clazz, name, sig);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find method %s.\", name);\n+  check_jni_exception(jni, message);\n+  return method;\n+}\n+\n+void\n+create_agent_thread(jvmtiEnv *jvmti, JNIEnv *jni, const char *name, jvmtiStartFunction func) {\n+\n+  check_jni_exception(jni, \"JNIException before creating Agent Thread.\");\n+  jclass clazz = find_class(jni, \"java\/lang\/Thread\");\n+  jmethodID thread_ctor = get_method_id(jni, clazz, \"<init>\",\n+                                    \"(Ljava\/lang\/String;)V\");\n+\n+  jstring name_utf = jni->NewStringUTF(name);\n+  check_jni_exception(jni, \"Error creating utf name of thread.\");\n+\n+  jthread thread = jni->NewObject(clazz, thread_ctor, name_utf);\n+  check_jni_exception(jni, \"Error during instantiation of Thread object.\");\n+  jvmtiError err = jvmti->RunAgentThread(\n+                     thread, func, nullptr, JVMTI_THREAD_NORM_PRIORITY);\n+  check_jvmti_status(jni, err, \"RunAgentThread\");\n+}\n+\n+\/*\n+ * The method blocks execution until agent thread finishes.\n+ * Should be executed during VMDeath to don't run JVMTI functionality\n+ * during dead phase.\n+ *\/\n+void\n+request_agent_thread_stop_and_wait(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  gdata->request_agent_thread_stop = JNI_TRUE;\n+  while (!gdata->is_agent_finished) {\n+    rml.wait(1000);\n+  }\n+  debug(\"Native agent stopped\");\n+}\n+\n+\/*\n+ * The method is called by agent thread to ensure that thread correctly exits.\n+ *\/\n+static jboolean\n+should_stop(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  jboolean should_stop = JNI_FALSE;\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  should_stop = gdata->request_agent_thread_stop;\n+  if (should_stop == JNI_TRUE) {\n+    gdata->is_agent_finished = JNI_TRUE;\n+    rml.notify_all();\n+  }\n+  return should_stop;\n+}\n+\n+\/*\n+ * Agent stress functions. The agent is stopped in VMDeath only and should be\n+ * always ready to get JVMTI_ERROR_THREAD_NOT_ALIVE error.\n+ *\/\n+\n+\/* Read stack, frames, method, variables, etc. *\/\n+static void\n+stack_trace(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"In stack_trace: %p\", thread);\n+\n+  jvmtiFrameInfo frames[5];\n+  jint count = 0;\n+  err = jvmti->GetStackTrace(thread, 0, 5, frames, &count);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE || err == JVMTI_ERROR_WRONG_PHASE) {\n+    return;\n+  }\n+  check_jvmti_error(err, \"GetStackTrace\");\n+\n+  debug(\"Stack depth: %d\", count);\n+\n+  for (int frame_index = 0; frame_index < count; frame_index++) {\n+    char *method_name = nullptr;\n+    jint method_modifiers = 0;\n+    err = jvmti->GetMethodName(frames[frame_index].method, &method_name, nullptr, nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodName\");\n+\n+    err = jvmti->GetMethodModifiers(frames[frame_index].method, &method_modifiers);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodModifiers\");\n+\n+    debug(\"Inspecting method: %s, %d\", method_name, method_modifiers);\n+    deallocate(jvmti, jni, method_name);\n+\n+    jvmtiLocalVariableEntry* table = nullptr;\n+    jint entry_count = 0;\n+    err = jvmti->GetLocalVariableTable(frames[frame_index].method, &entry_count, &table);\n+    if (err == JVMTI_ERROR_NATIVE_METHOD || err == JVMTI_ERROR_ABSENT_INFORMATION\n+            || err == JVMTI_ERROR_WRONG_PHASE) {\n+      continue;\n+    }\n+    check_jvmti_status(jni, err, \"GetLocalVariableTable\");\n+\n+    gdata->inspectedMethods += 1;\n+    gdata->inspectedVariables += entry_count;\n+\n+    debug(\"Variables: \");\n+    for (int cnt = 0; cnt < entry_count; cnt++) {\n+      debug(\" %s  %d\", table[cnt].name, table[cnt].slot);\n+      deallocate(jvmti, jni, table[cnt].name);\n+      deallocate(jvmti, jni, table[cnt].signature);\n+      deallocate(jvmti, jni, table[cnt].generic_signature);\n+    }\n+    deallocate(jvmti, jni, table);\n+  }\n+  debug(\"---- End of stack inspection %d -----\", count);\n+}\n+\n+\/* Iterate with stack_trace through all thread. *\/\n+static void JNICALL\n+all_threads_stack_trace(jvmtiEnv *jvmti, JNIEnv *jni) {\n+    jint threads_count = 0;\n+    jthread *threads = nullptr;\n+    jvmtiError err = JVMTI_ERROR_NONE;\n+    debug(\"Inspect:  Starting cycle...\");\n+    err = jvmti->GetAllThreads(&threads_count, &threads);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetAllThreads\");\n+    for (int t = 0; t < (int)threads_count; t++) {\n+      jvmtiThreadInfo info;\n+      debug(\"Inspecting thread num %d at addr [%p]\",t, threads[t]);\n+      err = jvmti->GetThreadInfo(threads[t], &info);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"GetThreadInfo\");\n+      \/\/ Skip agent thread itself and JFR threads to avoid potential deadlocks\n+      if (strstr(info.name, JVMTI_AGENT_NAME) == nullptr\n+          && strstr(info.name, \"JFR\") == nullptr) {\n+        \/\/ The non-intrusive actions are allowed to ensure that results of target\n+        \/\/ thread are not affected.\n+        jthread thread = threads[t];\n+        stack_trace(jvmti, jni, thread);\n+\n+        \/\/ Suspend\/resume are solo capabilities and are treated like debugging\n+        if (gdata->is_debugger_enabled) {\n+          debug(\"Inspect: Trying to suspend thread %s\", info.name);\n+          err = jvmti->SuspendThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+            debug(\"Inspect:  thread %s is not alive. Skipping.\", info.name);\n+            continue;\n+          }\n+          check_jvmti_status(jni, err, \"SuspendThread\");\n+          debug(\"Inspect:  Suspended thread %s\", info.name);\n+\n+          stack_trace(jvmti, jni, thread);\n+\n+          debug(\"Inspect: Trying to resume thread %s\", info.name);\n+          err = jvmti->ResumeThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          check_jvmti_status(jni, err, \"ResumeThread\");\n+          debug(\"Inspect:  Resumed thread %s\", info.name);\n+        }\n+\n+      }\n+      deallocate(jvmti, jni, info.name);\n+      jni->DeleteLocalRef(info.thread_group);\n+      jni->DeleteLocalRef(info.context_class_loader);\n+      jni->DeleteLocalRef(threads[t]);\n+    }\n+    deallocate(jvmti, jni, threads);\n+}\n+\n+\/* Heap inspection helpers. *\/\n+static jint JNICALL\n+heap_iteration_callback(jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data) {\n+  int* count = (int*) user_data;\n+  *count += 1;\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+static jint\n+get_heap_info(jvmtiEnv *jvmti, JNIEnv *jni, jclass klass) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  int count = 0;\n+  jvmtiHeapCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.heap_iteration_callback = &heap_iteration_callback;\n+  err = jvmti->IterateThroughHeap(0, klass, &callbacks, &count);\n+  if (err == JVMTI_ERROR_WRONG_PHASE) {\n+    return count;\n+  }\n+  check_jvmti_status(jni, err, \"IterateThroughHeap\");\n+  return count;\n+}\n+\n+\n+\/*\n+ * Events testing helper functions.\n+ *\/\n+\n+\n+int\n+is_event_frequent(int event) {\n+  \/\/ Should include all interpreter-only events and all often events.\n+  return event == JVMTI_EVENT_SINGLE_STEP\n+      || event == JVMTI_EVENT_METHOD_ENTRY\n+      || event == JVMTI_EVENT_METHOD_EXIT\n+      || event == JVMTI_EVENT_FRAME_POP\n+      || event == JVMTI_EVENT_FIELD_ACCESS\n+      || event == JVMTI_EVENT_FIELD_MODIFICATION\n+      || event == JVMTI_EVENT_EXCEPTION_CATCH\n+      || event == JVMTI_EVENT_EXCEPTION\n+  ;\n+}\n+\n+int\n+is_event_excluded(int event) {\n+  for (int i = 0; i < gdata->events_excluded_size; i++) {\n+    if (event == gdata->events_excluded[i]) {\n+      return JNI_TRUE;\n+    }\n+  }\n+  return JNI_FALSE;\n+}\n+\n+static void\n+enable_events(jvmtiEnv *jvmti, jboolean update_frequent_events) {\n+ debug(\"Enabling events\\n\");\n+  for(int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    if (is_event_excluded(event)) {\n+      debug(\"Event %d excluded.\", event);\n+      continue;\n+    }\n+    if (is_event_frequent(event) != update_frequent_events ) {\n+      debug(\"Event %d is not enabled as frequent\/slow.\", event);\n+      continue;\n+    }\n+    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+        static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+  debug(\"Enabling events done\\n\");\n+}\n+\n+static void\n+enable_frequent_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti, JNI_TRUE);\n+}\n+\n+static void\n+enable_common_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti,JNI_FALSE);\n+}\n+\n+\n+static void\n+disable_all_events(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  for (int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    \/\/ VM_DEATH is used to stop agent\n+    if (event == JVMTI_EVENT_VM_DEATH) {\n+      continue;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+}\n+\n+\/*\n+ * The JVMTI agent main loop.\n+ *\/\n+\n+static void JNICALL\n+stress_agent(jvmtiEnv *jvmti, JNIEnv *jni, void *p) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"Debugger: Thread started.\");\n+  while (!should_stop(jvmti, jni)) {\n+\n+    if (gdata->are_events_enabled) {\n+      enable_common_events(jvmti);\n+    }\n+\n+    \/\/ Iterate through heap and get some statistics\n+    if (gdata->is_heap_iterate_enabled) {\n+      jclass kls = find_class(jni, \"java\/lang\/String\");\n+      jlong obj_count = get_heap_info(jvmti, jni, kls);\n+      debug(\"Debugger: Heap info: %d\", obj_count);\n+    }\n+\n+\n+    \/\/ requires can_generate_sampled_object_alloc_events\n+    \/\/ which is solo capability\n+    if (gdata->is_heap_sampling_enabled) {\n+      err = jvmti->SetHeapSamplingInterval(gdata->heap_sampling_interval);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->is_tracing_enabled) {\n+      all_threads_stack_trace(jvmti, jni);\n+    }\n+\n+    sleep_ms(gdata->events_interval);\n+\n+    err = jvmti->SetHeapSamplingInterval(0);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    if (gdata->is_heap_sampling_enabled) {\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->are_frequent_events_enabled) {\n+      enable_frequent_events(jvmti);\n+      sleep_ms(gdata->frequent_events_interval);\n+    }\n+    disable_all_events(jvmti);\n+    sleep_ms(gdata->events_interval);\n+  }\n+  debug(\"Debugger: Thread finished.\");\n+}\n+\n+\n+\/*\n+ *  Events section.\n+ *  Most of the events just increase counter and print debug info.\n+ *  The VMInit\/VMDeath are also start and stop jvmti stress agent.\n+ *\/\n+\n+static void\n+register_event(jlong *event) {\n+  (*event)++;\n+}\n+\n+static void JNICALL\n+cbVMInit(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbVMInit);\n+  debug(\"Event cbVMInit\\n\");\n+  create_agent_thread(jvmti, jni, JVMTI_AGENT_NAME, &stress_agent);\n+}\n+\n+static void JNICALL\n+cbVMDeath(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  register_event(&gdata->cbVMDeath);\n+  debug(\"Event cbVMDeath\\n\");\n+  request_agent_thread_stop_and_wait(jvmti, jni);\n+  destroy_raw_monitor(jvmti, jni, gdata->finished_lock);\n+}\n+\n+static void JNICALL\n+cbThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbClassFileLoadHook(jvmtiEnv *jvmti, JNIEnv* jni,\n+                    jclass class_being_redefined, jobject loader,\n+                    const char* name, jobject protection_domain,\n+                    jint class_data_len, const unsigned char *class_data,\n+                    jint *new_class_data_len, unsigned char **new_class_data) {\n+  \/* TODO uncomment for more stress\n+  unsigned char* new_class_data_copy = (unsigned char*) malloc(class_data_len);\n+  memcpy(new_class_data_copy, class_data, class_data_len);\n+  *new_class_data_len = class_data_len;\n+  *new_class_data = new_class_data_copy;\n+  *\/\n+  register_event(&gdata->cbClassFileLoadHook);\n+  debug(\"Event cbClassFileLoadHook\\n\");\n+}\n+\n+static void JNICALL\n+cbClassLoad(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassLoad);\n+  debug(\"Event cbClassLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbClassPrepare(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassPrepare);\n+  debug(\"Event cbClassPrepare\\n\");\n+}\n+\n+static void JNICALL\n+cbDataDumpRequest(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbDataDumpRequest);\n+  debug(\"Event cbDataDumpRequest\\n\");\n+}\n+\n+static void JNICALL\n+cbException(jvmtiEnv *jvmti,\n+            JNIEnv *jni,\n+            jthread thread,\n+            jmethodID method,\n+            jlocation location,\n+            jobject exception,\n+            jmethodID catch_method,\n+            jlocation catch_location) {\n+  register_event(&gdata->cbException);\n+  debug(\"Event cbException\\n\");\n+}\n+\n+static void JNICALL\n+cbExceptionCatch(jvmtiEnv *jvmti, JNIEnv *jni,\n+                 jthread thread, jmethodID method, jlocation location,\n+                 jobject exception) {\n+  register_event(&gdata->cbExceptionCatch);\n+  debug(\"Event cbExceptionCatch\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWait(jvmtiEnv *jvmti, JNIEnv *jni,\n+              jthread thread, jobject object, jlong timeout) {\n+  register_event(&gdata->cbMonitorWait);\n+  debug(\"Event cbMonitorWait\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWaited(jvmtiEnv *jvmti, JNIEnv *jni,\n+                jthread thread, jobject object, jboolean timed_out) {\n+  register_event(&gdata->cbMonitorWaited);\n+  debug(\"Event cbMonitorWaited\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni,\n+                        jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEnter);\n+  debug(\"Event cbMonitorContendedEnter\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv* jni,\n+                          jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEntered);\n+  debug(\"Event cbMonitorContendedEntered\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionStart(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionStart);\n+  debug(\"Event cbGarbageCollectionStart\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionFinish(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionFinish);\n+  debug(\"Event cbGarbageCollectionFinish\\n\");\n+}\n+\n+static void JNICALL\n+cbObjectFree(jvmtiEnv *jvmti, jlong tag) {\n+  register_event(&gdata->cbObjectFree);\n+  debug(\"Event cbObjectFree\\n\");\n+}\n+\n+static void JNICALL\n+cbBreakpoint(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbBreakpoint);\n+  debug(\"Event cbBreakpoint\\n\");\n+}\n+\n+static void JNICALL\n+cbSingleStep(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbSingleStep);\n+  debug(\"Event cbSingleStep\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method,\n+              jlocation location,\n+              jclass field_klass,\n+              jobject object,\n+              jfieldID field) {\n+  register_event(&gdata->cbFieldAccess);\n+  debug(\"Event cbFieldAccess\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jthread thread,\n+                    jmethodID method,\n+                    jlocation location,\n+                    jclass field_klass,\n+                    jobject object,\n+                    jfieldID field,\n+                    char signature_type,\n+                    jvalue new_value) {\n+  register_event(&gdata->cbFieldModification);\n+  debug(\"Event cbFieldModification\\n\");\n+}\n+\n+static void JNICALL\n+cbFramePop(jvmtiEnv *jvmti,\n+           JNIEnv *jni,\n+           jthread thread,\n+           jmethodID method,\n+           jboolean was_popped_by_exception) {\n+  register_event(&gdata->cbFramePop);\n+  debug(\"Event cbFramePop\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodEntry(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method) {\n+  register_event(&gdata->cbMethodEntry);\n+  debug(\"Event cbMethodEntry\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodExit(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jboolean was_popped_by_exception,\n+             jvalue return_value) {\n+  register_event(&gdata->cbMethodExit);\n+  debug(\"Event cbMethodExit\\n\");\n+}\n+\n+static void JNICALL\n+cbNativeMethodBind(jvmtiEnv *jvmti,\n+                   JNIEnv *jni,\n+                   jthread thread,\n+                   jmethodID method,\n+                   void* address,\n+                   void** new_address_ptr) {\n+  register_event(&gdata->cbNativeMethodBind);\n+  debug(\"Event cbNativeMethodBind\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodLoad(jvmtiEnv *jvmti,\n+                     jmethodID method,\n+                     jint code_size,\n+                     const void* code_addr,\n+                     jint map_length,\n+                     const jvmtiAddrLocationMap* map,\n+                     const void* compile_info) {\n+  register_event(&gdata->cbCompiledMethodLoad);\n+  debug(\"Event cbCompiledMethodLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodUnload(jvmtiEnv *jvmti,\n+                       jmethodID method,\n+                       const void* code_addr) {\n+  register_event(&gdata->cbCompiledMethodUnload);\n+  debug(\"Event cbCompiledMethodUnload\\n\");\n+}\n+\n+static void JNICALL\n+cbDynamicCodeGenerated(jvmtiEnv *jvmti,\n+                       const char* name,\n+                       const void* address,\n+                       jint length) {\n+  register_event(&gdata->cbDynamicCodeGenerated);\n+  debug(\"Event cbDynamicCodeGenerated\\n\");\n+}\n+\n+static void JNICALL\n+cbResourceExhausted(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jint flags,\n+                    const void* reserved,\n+                    const char* description) {\n+  register_event(&gdata->cbResourceExhausted);\n+  debug(\"Event cbResourceExhausted\\n\");\n+}\n+\n+static void JNICALL\n+cbVMObjectAlloc(jvmtiEnv *jvmti,\n+                JNIEnv *jni,\n+                jthread thread,\n+                jobject object,\n+                jclass object_klass,\n+                jlong size) {\n+  register_event(&gdata->cbVMObjectAlloc);\n+  debug(\"Event cbVMObjectAlloc\\n\");\n+}\n+\n+static void JNICALL\n+cbSampledObjectAlloc(jvmtiEnv *jvmti,\n+                     JNIEnv *jni,\n+                     jthread thread,\n+                     jobject object,\n+                     jclass object_klass,\n+                     jlong size) {\n+  register_event(&gdata->cbSampledObjectAlloc);\n+  debug(\"Event cbSampledObjectAlloc\\n\");\n+}\n+\n+\n+\n+static void\n+set_callbacks(jvmtiEnv *jvmti, jboolean on) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiEventCallbacks callbacks;\n+\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  if (on == JNI_FALSE) {\n+    err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+    check_jvmti_error(err, \"SetEventCallbacks\");\n+    return;\n+  }\n+  callbacks.Breakpoint = &cbBreakpoint;\n+  callbacks.ClassFileLoadHook = &cbClassFileLoadHook;\n+  callbacks.ClassLoad = &cbClassLoad;\n+  callbacks.ClassPrepare = &cbClassPrepare;\n+  callbacks.CompiledMethodLoad = &cbCompiledMethodLoad;\n+  callbacks.CompiledMethodUnload = &cbCompiledMethodUnload;\n+  callbacks.DataDumpRequest = &cbDataDumpRequest;\n+  callbacks.DynamicCodeGenerated = &cbDynamicCodeGenerated;\n+  callbacks.Exception = &cbException;\n+  callbacks.ExceptionCatch = &cbExceptionCatch;\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  callbacks.FramePop = &cbFramePop;\n+  callbacks.GarbageCollectionFinish = &cbGarbageCollectionFinish;\n+  callbacks.GarbageCollectionStart = &cbGarbageCollectionStart;\n+  callbacks.MethodEntry = &cbMethodEntry;\n+  callbacks.MethodExit = &cbMethodExit;\n+  callbacks.MonitorContendedEnter = &cbMonitorContendedEnter;\n+  callbacks.MonitorContendedEntered = &cbMonitorContendedEntered;\n+  callbacks.MonitorWait = &cbMonitorWait;\n+  callbacks.MonitorWaited = &cbMonitorWaited;\n+  callbacks.NativeMethodBind = &cbNativeMethodBind;\n+  callbacks.ObjectFree = &cbObjectFree;\n+  callbacks.ResourceExhausted = &cbResourceExhausted;\n+  callbacks.SampledObjectAlloc = &cbSampledObjectAlloc;\n+  callbacks.SingleStep = &cbSingleStep;\n+  callbacks.ThreadEnd = &cbThreadEnd;\n+  callbacks.ThreadStart = &cbThreadStart;\n+  callbacks.VirtualThreadEnd = &cbVirtualThreadEnd;\n+  callbacks.VirtualThreadStart = &cbVirtualThreadStart;\n+  callbacks.VMDeath = &cbVMDeath;\n+  callbacks.VMInit = &cbVMInit;\n+  callbacks.VMObjectAlloc = &cbVMObjectAlloc;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+}\n+\n+static\n+void get_capabilities(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  err = jvmti->GetPotentialCapabilities(&capabilities);\n+\n+  if (!gdata->is_debugger_enabled) {\n+    \/\/init_always_solo_capabilities\n+    capabilities.can_suspend = false;\n+\n+    \/\/ onload_solo\n+    capabilities.can_generate_breakpoint_events = false;\n+    capabilities.can_generate_field_access_events = false;\n+    capabilities.can_generate_field_modification_events = false;\n+  }\n+\n+  \/\/ can_generate_early_vmstart might impact VMStart for any agent\n+  \/\/ accordingly to spec, so don't enable it\n+  capabilities.can_generate_early_vmstart = false;\n+\n+  check_jvmti_error(err, \"GetPotentialCapabilities\");\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  jboolean is_debugger_enabled = JNI_TRUE;\n+  jboolean is_verbose = JNI_FALSE;\n+\n+  if (options != nullptr) {\n+    char *opts = strdup(options);\n+    char *token = strtok(opts, \",\");\n+\n+    while (token != nullptr) {\n+      if (strncmp(token, \"debugger=\", 9) == 0) {\n+        if (strcmp(token + 9, \"true\") == 0) {\n+          is_debugger_enabled = JNI_TRUE;\n+        } else {\n+          is_debugger_enabled = JNI_FALSE;\n+        }\n+      }\n+      if (strncmp(token, \"verbose\", 7) == 0) {\n+        is_verbose = JNI_TRUE;\n+      }\n+      token = strtok(nullptr, \",\");\n+    }\n+    free(opts);\n+  }\n+  gdata = gdata_init(is_debugger_enabled, is_verbose);\n+  get_capabilities(jvmti);\n+  gdata->finished_lock = create_raw_monitor(jvmti, \"Finished lock\");\n+  set_callbacks(jvmti, JNI_TRUE);\n+  \/\/ Enable all events until start jvmti stress agent.\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+    JVMTI_EVENT_VM_INIT, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM *vm) {\n+  if (!gdata->request_agent_thread_stop) {\n+    printf(\"Agent_OnUnload happened before requested stop.\\n\");\n+  }\n+  gdata_close();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp","additions":990,"deletions":0,"binary":false,"changes":990,"status":"added"}]}