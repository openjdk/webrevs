{"files":[{"patch":"@@ -66,0 +66,1 @@\n+@SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/LongSummaryStatistics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -161,0 +162,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -227,0 +229,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/PrimitiveIterator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -662,0 +662,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -726,0 +727,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -790,0 +792,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -911,0 +911,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -917,0 +918,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -923,0 +925,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterators.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -394,0 +395,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -471,0 +473,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Node.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -585,0 +585,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -602,0 +603,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -619,0 +621,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -883,0 +886,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -897,0 +901,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -911,0 +916,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1163,0 +1169,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1172,0 +1179,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1181,0 +1189,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Nodes.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -206,0 +207,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -223,0 +225,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Sink.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -723,0 +723,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -788,0 +789,1 @@\n+            @SuppressWarnings(\"overloads\")\n@@ -836,0 +838,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -902,0 +905,1 @@\n+            @SuppressWarnings(\"overloads\")\n@@ -950,0 +954,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -1016,0 +1021,1 @@\n+            @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/SpinedBuffer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -575,0 +575,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -584,0 +585,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -593,0 +595,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -818,0 +821,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -842,0 +846,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -866,0 +871,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1131,0 +1137,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1166,0 +1173,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1201,0 +1209,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamSpliterators.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -807,0 +807,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -815,0 +816,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -823,0 +825,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Streams.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-     * Flag that marks potentially ambiguous overloads\n+     * Currently available: Bit 48.\n@@ -280,1 +280,0 @@\n-    public static final long POTENTIALLY_AMBIGUOUS = 1L<<48;\n@@ -529,1 +528,1 @@\n-        POTENTIALLY_AMBIGUOUS(Flags.POTENTIALLY_AMBIGUOUS),\n+        \/\/ Bit 48 is currently available\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5566,0 +5566,1 @@\n+            chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n@@ -32,0 +34,3 @@\n+import java.util.function.ToIntBiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n@@ -71,0 +76,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.RECURSIVE;\n@@ -93,0 +99,4 @@\n+    \/\/ Flag bits indicating which item(s) chosen from a pair of items\n+    private static final int FIRST = 0x01;\n+    private static final int SECOND = 0x02;\n+\n@@ -2557,2 +2567,0 @@\n-        List<MethodSymbol> potentiallyAmbiguousList = List.nil();\n-        boolean overridesAny = false;\n@@ -2563,7 +2571,0 @@\n-                if (m1 == sym) {\n-                    continue;\n-                }\n-\n-                if (!overridesAny) {\n-                    potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);\n-                }\n@@ -2573,5 +2574,0 @@\n-            if (m1 != sym) {\n-                overridesAny = true;\n-                potentiallyAmbiguousList = List.nil();\n-            }\n-\n@@ -2607,6 +2603,0 @@\n-\n-        if (!overridesAny) {\n-            for (MethodSymbol m: potentiallyAmbiguousList) {\n-                checkPotentiallyAmbiguousOverloads(pos, site, sym, m);\n-            }\n-        }\n@@ -2633,2 +2623,0 @@\n-                } else {\n-                    checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);\n@@ -2723,0 +2711,189 @@\n+    \/** Report warnings for potentially ambiguous method declarations in the given site. *\/\n+    void checkPotentiallyAmbiguousOverloads(JCClassDecl tree, Type site) {\n+\n+        \/\/ Skip if warning not enabled\n+        if (!lint.isEnabled(LintCategory.OVERLOADS))\n+            return;\n+\n+        \/\/ Gather all of site's methods, including overridden methods, grouped by name (except Object methods)\n+        List<java.util.List<MethodSymbol>> methodGroups = methodsGroupedByName(site,\n+            new PotentiallyAmbiguousFilter(site), ArrayList::new);\n+\n+        \/\/ Build the predicate that determines if site is responsible for an ambiguity\n+        BiPredicate<MethodSymbol, MethodSymbol> responsible = buildResponsiblePredicate(site, methodGroups);\n+\n+        \/\/ Now remove overridden methods from each group, leaving only site's actual members\n+        methodGroups.forEach(list -> removePreempted(list, (m1, m2) -> m1.overrides(m2, site.tsym, types, false)));\n+\n+        \/\/ Allow site's own declared methods (only) to apply @SuppressWarnings(\"overloads\")\n+        methodGroups.forEach(list -> list.removeIf(\n+            m -> m.owner == site.tsym && !lint.augment(m).isEnabled(LintCategory.OVERLOADS)));\n+\n+        \/\/ Warn about ambiguous overload method pairs for which site is responsible\n+        methodGroups.forEach(list -> compareAndRemove(list, (m1, m2) -> {\n+\n+            \/\/ See if this is an ambiguous overload for which \"site\" is responsible\n+            if (!potentiallyAmbiguousOverload(site, m1, m2) || !responsible.test(m1, m2))\n+                return 0;\n+\n+            \/\/ Locate the warning at one of the methods, if possible\n+            DiagnosticPosition pos =\n+                m1.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m1, tree) :\n+                m2.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m2, tree) :\n+                tree.pos();\n+\n+            \/\/ Log the warning\n+            log.warning(LintCategory.OVERLOADS, pos,\n+                Warnings.PotentiallyAmbiguousOverload(\n+                    m1.asMemberOf(site, types), m1.location(),\n+                    m2.asMemberOf(site, types), m2.location()));\n+\n+            \/\/ Don't warn again for either of these two methods\n+            return FIRST | SECOND;\n+        }));\n+    }\n+\n+    \/** Build a predicate that determines, given two methods that are members of the given class,\n+     *  whether the class should be held \"responsible\" if the methods are potentially ambiguous.\n+     *\n+     *  Sometimes ambiguous methods are unavoidable because they're inherited from a supertype.\n+     *  For example, any subtype of Spliterator.OfInt will have ambiguities for both\n+     *  forEachRemaining() and tryAdvance() (in both cases the overloads are IntConsumer and\n+     *  Consumer&lt;? super Integer&gt;). So we only want to \"blame\" a class when that class is\n+     *  itself responsible for creating the ambiguity. We declare that a class C is \"responsible\"\n+     *  for the ambiguity between two methods m1 and m2 if there is no direct supertype T of C\n+     *  such that m1 and m2, or some overrides thereof, both exist in T and are ambiguous in T.\n+     *  As an optimization, we first check if either method is declared in C and does not override\n+     *  any other methods; in this case the class is definitely responsible.\n+     *\/\n+    BiPredicate<MethodSymbol, MethodSymbol> buildResponsiblePredicate(Type site,\n+        List<? extends Collection<MethodSymbol>> methodGroups) {\n+\n+        \/\/ Define the \"overrides\" predicate\n+        BiPredicate<MethodSymbol, MethodSymbol> overrides = (m1, m2) -> m1.overrides(m2, site.tsym, types, false);\n+\n+        \/\/ Map each method declared in site to a list of the supertype method(s) it directly overrides\n+        HashMap<MethodSymbol, ArrayList<MethodSymbol>> overriddenMethodsMap = new HashMap<>();\n+        methodGroups.forEach(list -> {\n+            for (MethodSymbol m : list) {\n+\n+                \/\/ Skip methods not declared in site\n+                if (m.owner != site.tsym)\n+                    continue;\n+\n+                \/\/ Gather all supertype methods overridden by m, directly or indirectly\n+                ArrayList<MethodSymbol> overriddenMethods = list.stream()\n+                  .filter(m2 -> m2 != m && overrides.test(m, m2))\n+                  .collect(Collectors.toCollection(ArrayList::new));\n+\n+                \/\/ Eliminate non-direct overrides\n+                removePreempted(overriddenMethods, overrides);\n+\n+                \/\/ Add to map\n+                overriddenMethodsMap.put(m, overriddenMethods);\n+            }\n+        });\n+\n+        \/\/ Build the predicate\n+        return (m1, m2) -> {\n+\n+            \/\/ Get corresponding supertype methods (if declared in site)\n+            java.util.List<MethodSymbol> overriddenMethods1 = overriddenMethodsMap.get(m1);\n+            java.util.List<MethodSymbol> overriddenMethods2 = overriddenMethodsMap.get(m2);\n+\n+            \/\/ Quick check for the case where a method was added by site itself\n+            if (overriddenMethods1 != null && overriddenMethods1.isEmpty())\n+                return true;\n+            if (overriddenMethods2 != null && overriddenMethods2.isEmpty())\n+                return true;\n+\n+            \/\/ Get each method's corresponding method(s) from supertypes of site\n+            java.util.List<MethodSymbol> supertypeMethods1 = overriddenMethods1 != null ?\n+              overriddenMethods1 : Collections.singletonList(m1);\n+            java.util.List<MethodSymbol> supertypeMethods2 = overriddenMethods2 != null ?\n+              overriddenMethods2 : Collections.singletonList(m2);\n+\n+            \/\/ See if we can blame some direct supertype instead\n+            return types.directSupertypes(site).stream()\n+              .filter(stype -> stype != syms.objectType)\n+              .map(stype -> stype.tsym.type)                \/\/ view supertype in its original form\n+              .noneMatch(stype -> {\n+                for (MethodSymbol sm1 : supertypeMethods1) {\n+                    if (!types.isSubtype(types.erasure(stype), types.erasure(sm1.owner.type)))\n+                        continue;\n+                    for (MethodSymbol sm2 : supertypeMethods2) {\n+                        if (!types.isSubtype(types.erasure(stype), types.erasure(sm2.owner.type)))\n+                            continue;\n+                        if (potentiallyAmbiguousOverload(stype, sm1, sm2))\n+                            return true;\n+                    }\n+                }\n+                return false;\n+            });\n+        };\n+    }\n+\n+    \/** Gather all of site's methods, including overridden methods, grouped and sorted by name,\n+     *  after applying the given filter.\n+     *\/\n+    <C extends Collection<MethodSymbol>> List<C> methodsGroupedByName(Type site,\n+            Predicate<Symbol> filter, Supplier<? extends C> groupMaker) {\n+        Iterable<Symbol> symbols = types.membersClosure(site, false).getSymbols(filter, RECURSIVE);\n+        return StreamSupport.stream(symbols.spliterator(), false)\n+          .map(MethodSymbol.class::cast)\n+          .collect(Collectors.groupingBy(m -> m.name, Collectors.toCollection(groupMaker)))\n+          .entrySet()\n+          .stream()\n+          .sorted(Comparator.comparing(e -> e.getKey().toString()))\n+          .map(Map.Entry::getValue)\n+          .collect(List.collector());\n+    }\n+\n+    \/** Compare elements in a list pair-wise in order to remove some of them.\n+     *  @param list mutable list of items\n+     *  @param comparer returns flag bit(s) to remove FIRST and\/or SECOND\n+     *\/\n+    <T> void compareAndRemove(java.util.List<T> list, ToIntBiFunction<? super T, ? super T> comparer) {\n+        for (int index1 = 0; index1 < list.size() - 1; index1++) {\n+            T item1 = list.get(index1);\n+            for (int index2 = index1 + 1; index2 < list.size(); index2++) {\n+                T item2 = list.get(index2);\n+                int flags = comparer.applyAsInt(item1, item2);\n+                if ((flags & SECOND) != 0)\n+                    list.remove(index2--);          \/\/ remove item2\n+                if ((flags & FIRST) != 0) {\n+                    list.remove(index1--);          \/\/ remove item1\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Remove elements in a list that are preempted by some other element in the list.\n+     *  @param list mutable list of items\n+     *  @param preempts decides if one item preempts another, causing the second one to be removed\n+     *\/\n+    <T> void removePreempted(java.util.List<T> list, BiPredicate<? super T, ? super T> preempts) {\n+        compareAndRemove(list, (item1, item2) -> {\n+            int flags = 0;\n+            if (preempts.test(item1, item2))\n+                flags |= SECOND;\n+            if (preempts.test(item2, item1))\n+                flags |= FIRST;\n+            return flags;\n+        });\n+    }\n+\n+    \/** Filters method candidates for the \"potentially ambiguous method\" check *\/\n+    class PotentiallyAmbiguousFilter extends ClashFilter {\n+\n+        PotentiallyAmbiguousFilter(Type site) {\n+            super(site);\n+        }\n+\n+        @Override\n+        boolean shouldSkip(Symbol s) {\n+            return s.owner.type.tsym == syms.objectType.tsym || super.shouldSkip(s);\n+        }\n+    }\n+\n@@ -2727,1 +2904,1 @@\n-      * lambda would be ambiguous).\n+      * lambda would be ambiguous). This assumes they already have the same name.\n@@ -2729,32 +2906,30 @@\n-    void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,\n-            MethodSymbol msym1, MethodSymbol msym2) {\n-        if (msym1 != msym2 &&\n-                lint.isEnabled(LintCategory.OVERLOADS) &&\n-                (msym1.flags() & POTENTIALLY_AMBIGUOUS) == 0 &&\n-                (msym2.flags() & POTENTIALLY_AMBIGUOUS) == 0) {\n-            Type mt1 = types.memberType(site, msym1);\n-            Type mt2 = types.memberType(site, msym2);\n-            \/\/if both generic methods, adjust type variables\n-            if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n-                    types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n-                mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n-            }\n-            \/\/expand varargs methods if needed\n-            int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n-            List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n-            List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n-            \/\/if arities don't match, exit\n-            if (args1.length() != args2.length()) return;\n-            boolean potentiallyAmbiguous = false;\n-            while (args1.nonEmpty() && args2.nonEmpty()) {\n-                Type s = args1.head;\n-                Type t = args2.head;\n-                if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n-                    if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n-                            types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n-                            types.findDescriptorType(s).getParameterTypes().length() ==\n-                            types.findDescriptorType(t).getParameterTypes().length()) {\n-                        potentiallyAmbiguous = true;\n-                    } else {\n-                        return;\n-                    }\n+    boolean potentiallyAmbiguousOverload(Type site, MethodSymbol msym1, MethodSymbol msym2) {\n+        Assert.check(msym1.name == msym2.name);\n+        if (msym1 == msym2)\n+            return false;\n+        Type mt1 = types.memberType(site, msym1);\n+        Type mt2 = types.memberType(site, msym2);\n+        \/\/if both generic methods, adjust type variables\n+        if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n+                types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n+            mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n+        }\n+        \/\/expand varargs methods if needed\n+        int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n+        List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n+        List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n+        \/\/if arities don't match, exit\n+        if (args1.length() != args2.length())\n+            return false;\n+        boolean potentiallyAmbiguous = false;\n+        while (args1.nonEmpty() && args2.nonEmpty()) {\n+            Type s = args1.head;\n+            Type t = args2.head;\n+            if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n+                if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n+                        types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n+                        types.findDescriptorType(s).getParameterTypes().length() ==\n+                        types.findDescriptorType(t).getParameterTypes().length()) {\n+                    potentiallyAmbiguous = true;\n+                } else {\n+                    return false;\n@@ -2762,12 +2937,0 @@\n-                args1 = args1.tail;\n-                args2 = args2.tail;\n-            }\n-            if (potentiallyAmbiguous) {\n-                \/\/we found two incompatible functional interfaces with same arity\n-                \/\/this means a call site passing an implicit lambda would be ambiguous\n-                msym1.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                msym2.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                log.warning(LintCategory.OVERLOADS, pos,\n-                            Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),\n-                                                                  msym2, msym2.location()));\n-                return;\n@@ -2775,0 +2938,2 @@\n+            args1 = args1.tail;\n+            args2 = args2.tail;\n@@ -2776,0 +2941,1 @@\n+        return potentiallyAmbiguous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":233,"deletions":67,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-T8230827.java:27:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod1(java.lang.Object,T8230827.I1), T8230827, ambiguousMethod1(java.lang.Object,T8230827.I2), T8230827\n-T8230827.java:32:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod2(T8230827.I1,java.lang.Object), T8230827, ambiguousMethod2(T8230827.I2,java.lang.Object), T8230827\n-T8230827.java:37:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod3(T8230827.I1,T8230827.I1), T8230827, ambiguousMethod3(T8230827.I2,T8230827.I1), T8230827\n-T8230827.java:42:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod4(java.lang.Object,T8230827.I1,java.lang.String), T8230827, ambiguousMethod4(java.lang.String,T8230827.I2,java.lang.Object), T8230827\n+T8230827.java:29:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod1(java.lang.Object,T8230827.I2), T8230827, ambiguousMethod1(java.lang.Object,T8230827.I1), T8230827\n+T8230827.java:34:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod2(T8230827.I2,java.lang.Object), T8230827, ambiguousMethod2(T8230827.I1,java.lang.Object), T8230827\n+T8230827.java:39:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod3(T8230827.I2,T8230827.I1), T8230827, ambiguousMethod3(T8230827.I1,T8230827.I1), T8230827\n+T8230827.java:44:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod4(java.lang.String,T8230827.I2,java.lang.Object), T8230827, ambiguousMethod4(java.lang.Object,T8230827.I1,java.lang.String), T8230827\n@@ -7,1 +7,1 @@\n-4 warnings\n\\ No newline at end of file\n+4 warnings\n","filename":"test\/langtools\/tools\/javac\/8230827\/T8230827.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8024947\n+ * @bug 8024947 8026369\n@@ -73,0 +73,70 @@\n+\n+\/\/ The test cases below are from JDK-8026369\n+\n+    interface I6 {\n+        void foo(Consumer<Integer> c);\n+    }\n+\n+    interface I7 {\n+        void foo(IntConsumer c);\n+    }\n+\n+    \/\/a warning should be fired, I8 is provoking the issue\n+    interface I8 extends I6, I7 { }\n+\n+    \/\/no warning here, the issue is introduced in I8\n+    interface I9 extends I8 { }\n+\n+    \/\/no warning here\n+    interface I10<T> {\n+        void foo(Consumer<Integer> c);\n+        void foo(T c);\n+    }\n+\n+    \/\/a warning should be fired, I11 is provoking the issue\n+    interface I11 extends I10<IntConsumer> { }\n+\n+    \/\/ No warning should be fired here\n+    interface I12<T> extends Consumer<T>, IntSupplier {\n+        \/\/ A warning should be fired here\n+        interface OfInt extends I12<Integer>, IntConsumer {\n+            @Override\n+            void accept(int value);\n+            default void accept(Integer i) { }\n+        }\n+        @Override\n+        default int getAsInt() { return 0; }\n+    }\n+\n+    \/\/ No warning should be fired here\n+    abstract static class C6<T> implements I12.OfInt { }\n+\n+    default <U> Object foo() {\n+        \/\/ No warning should be fired here\n+        return new C6<U>() {\n+            @Override\n+            public void accept(int value) { }\n+        };\n+    }\n+\n+    \/\/ Overrides should not trigger warnings\n+    interface I13 extends I8 {\n+        @Override\n+        void foo(Consumer<Integer> c);\n+        @Override\n+        void foo(IntConsumer c);\n+    }\n+    interface I14 extends I8 {\n+        @Override\n+        void foo(IntConsumer c);\n+    }\n+\n+    \/\/ Verify we can suppress warnings at the class level\n+    @SuppressWarnings(\"overloads\")\n+    interface I15 extends I8 { }        \/\/ would normally trigger a warning\n+\n+    \/\/ Verify we can suppress warnings at the method level\n+    interface I16 extends I2 {\n+        @SuppressWarnings(\"overloads\")\n+        void foo(IntConsumer c);        \/\/ would normally trigger a warning\n+    }\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8024947\/PotentiallyAmbiguousWarningTest.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-PotentiallyAmbiguousWarningTest.java:15:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I1, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I1\n-PotentiallyAmbiguousWarningTest.java:21:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C1, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.C1\n+PotentiallyAmbiguousWarningTest.java:16:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I1, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I1\n+PotentiallyAmbiguousWarningTest.java:22:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.C1, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C1\n@@ -6,1 +6,4 @@\n-PotentiallyAmbiguousWarningTest.java:71:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.J2, foo(T), PotentiallyAmbiguousWarningTest.I5\n+PotentiallyAmbiguousWarningTest.java:71:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.J2, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I5\n+PotentiallyAmbiguousWarningTest.java:85:5: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I7, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I6\n+PotentiallyAmbiguousWarningTest.java:97:5: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I10, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I10\n+PotentiallyAmbiguousWarningTest.java:102:9: compiler.warn.potentially.ambiguous.overload: andThen(java.util.function.IntConsumer), java.util.function.IntConsumer, andThen(java.util.function.Consumer<? super java.lang.Integer>), java.util.function.Consumer\n@@ -9,1 +12,1 @@\n-6 warnings\n+9 warnings\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8024947\/PotentiallyAmbiguousWarningTest.out","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}