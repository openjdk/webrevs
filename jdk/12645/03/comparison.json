{"files":[{"patch":"@@ -66,0 +66,1 @@\n+@SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/LongSummaryStatistics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -161,0 +162,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -227,0 +229,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/PrimitiveIterator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -662,0 +662,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -726,0 +727,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -790,0 +792,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -911,0 +911,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -917,0 +918,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -923,0 +925,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterators.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -394,0 +395,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -471,0 +473,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Node.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -585,0 +585,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -602,0 +603,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -619,0 +621,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -883,0 +886,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -897,0 +901,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -911,0 +916,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1163,0 +1169,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1172,0 +1179,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1181,0 +1189,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Nodes.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -206,0 +207,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -223,0 +225,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Sink.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -723,0 +723,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -788,0 +789,1 @@\n+            @SuppressWarnings(\"overloads\")\n@@ -836,0 +838,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -902,0 +905,1 @@\n+            @SuppressWarnings(\"overloads\")\n@@ -950,0 +954,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -1016,0 +1021,1 @@\n+            @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/SpinedBuffer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -575,0 +575,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -584,0 +585,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -593,0 +595,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -818,0 +821,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -842,0 +846,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -866,0 +871,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1131,0 +1137,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1166,0 +1173,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1201,0 +1209,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamSpliterators.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -807,0 +807,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -815,0 +816,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -823,0 +825,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Streams.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-     * Flag that marks potentially ambiguous overloads\n+     * Currently available: Bit 48.\n@@ -280,1 +280,0 @@\n-    public static final long POTENTIALLY_AMBIGUOUS = 1L<<48;\n@@ -529,1 +528,1 @@\n-        POTENTIALLY_AMBIGUOUS(Flags.POTENTIALLY_AMBIGUOUS),\n+        \/\/ Bit 48 is currently available\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5566,0 +5566,1 @@\n+            chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n@@ -32,0 +34,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n@@ -71,0 +75,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.RECURSIVE;\n@@ -2557,2 +2562,0 @@\n-        List<MethodSymbol> potentiallyAmbiguousList = List.nil();\n-        boolean overridesAny = false;\n@@ -2563,7 +2566,0 @@\n-                if (m1 == sym) {\n-                    continue;\n-                }\n-\n-                if (!overridesAny) {\n-                    potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);\n-                }\n@@ -2573,5 +2569,0 @@\n-            if (m1 != sym) {\n-                overridesAny = true;\n-                potentiallyAmbiguousList = List.nil();\n-            }\n-\n@@ -2607,6 +2598,0 @@\n-\n-        if (!overridesAny) {\n-            for (MethodSymbol m: potentiallyAmbiguousList) {\n-                checkPotentiallyAmbiguousOverloads(pos, site, sym, m);\n-            }\n-        }\n@@ -2633,2 +2618,0 @@\n-                } else {\n-                    checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);\n@@ -2723,0 +2706,152 @@\n+    \/** Report warnings for potentially ambiguous method declarations in the given site.\n+     *\n+     *  Sometimes ambiguous methods are unaviodable because they're inherited from a\n+     *  single supertype. For example, any subtype of Spliterator.OfInt will have\n+     *  ambiguities for both forEachRemaining() and tryAdvance() (in both cases the\n+     *  overloads are IntConsumer and Consumer&lt;? super Integer&gt;). So we only want\n+     *  to \"blame\" a class when that class is itself responsible for creating the\n+     *  ambiguity. So we declare that site is \"responsible\" for the ambiguity between\n+     *  two methods m1 and m2 if there is no direct supertype T of site such that\n+     *  m1 and m2, or some overrides thereof, both exist and are ambiguous in T.\n+     *  As an optimization, we first check if either method is declared in site and\n+     *  does not override any other methods (in which case site is responsible).\n+     *\/\n+    void checkPotentiallyAmbiguousOverloads(JCClassDecl tree, Type site) {\n+\n+        \/\/ Skip if warning not enabled\n+        if (!lint.isEnabled(LintCategory.OVERLOADS))\n+            return;\n+\n+        \/\/ Gather all of site's methods, including overridden methods, grouped by name.\n+        \/\/ We sort the groups by name simply to eliminate non-determinism in the analysis.\n+        List<java.util.List<MethodSymbol>> methodsByName = StreamSupport.stream(\n+            types.membersClosure(site, false).getSymbols(new ClashFilter(site), RECURSIVE).spliterator(), false)\n+          .map(MethodSymbol.class::cast)\n+          .filter(m -> m.owner.type.tsym != syms.objectType.tsym)\n+          .collect(Collectors.groupingBy(m -> m.name, Collectors.toCollection(ArrayList::new)))\n+          .entrySet()\n+          .stream()\n+          .sorted(Comparator.comparing(e -> e.getKey().toString()))\n+          .map(Map.Entry::getValue)\n+          .peek(Collections::reverse)               \/\/ seems to help warning ordering\n+          .collect(List.collector());\n+\n+        \/\/ Define the \"overrides\" predicate\n+        BiPredicate<MethodSymbol, MethodSymbol> overrides = (m1, m2) -> m1.overrides(m2, site.tsym, types, false);\n+\n+        \/\/ Define a processor that removes overridden methods from a list\n+        Consumer<java.util.List<MethodSymbol>> overriddenRemover = list -> {\n+            for (int i = 0; i < list.size() - 1; i++) {\n+                MethodSymbol m1 = list.get(i);\n+                for (int j = i + 1; j < list.size(); j++) {\n+                    MethodSymbol m2 = list.get(j);\n+                    if (overrides.test(m1, m2)) {\n+                        list.remove(j--);           \/\/ remove m2\n+                        continue;\n+                    }\n+                    if (overrides.test(m2, m1)) {\n+                        list.remove(i--);           \/\/ remove m1\n+                        break;\n+                    }\n+                }\n+            }\n+        };\n+\n+        \/\/ Map each method declared in site to a list of the supertype method(s) it directly overrides\n+        HashMap<MethodSymbol, java.util.List<MethodSymbol>> overriddenMethodsMap = new HashMap<>();\n+        methodsByName.forEach(list -> {\n+            for (MethodSymbol m : list) {\n+\n+                \/\/ Skip methods not declared in site\n+                if (m.owner != site.tsym)\n+                    continue;\n+\n+                \/\/ Gather all supertype methods overridden by m, directly or indirectly\n+                java.util.List<MethodSymbol> overriddenMethods = list.stream()\n+                  .filter(m2 -> m2 != m)\n+                  .filter(m2 -> overrides.test(m, m2))\n+                  .collect(Collectors.toCollection(ArrayList::new));\n+\n+                \/\/ Eliminate non-direct overrides\n+                overriddenRemover.accept(overriddenMethods);\n+\n+                \/\/ Add to map\n+                overriddenMethodsMap.put(m, overriddenMethods);\n+            }\n+        });\n+\n+        \/\/ Remove overridden methods from each name group, leaving site's actual member methods\n+        methodsByName.forEach(overriddenRemover);\n+\n+        \/\/ Allow site's own declared methods (only) to apply @SuppressWarnings(\"overloads\")\n+        methodsByName.forEach(list -> list.removeIf(\n+            m -> m.owner == site.tsym && !lint.augment(m).isEnabled(LintCategory.OVERLOADS)));\n+\n+        \/\/ Define the predicate that determines if site is \"responsible\" for an ambiguity\n+        BiPredicate<MethodSymbol, MethodSymbol> responsible = (m1, m2) -> {\n+\n+            \/\/ Get corresponding supertype methods (if declared in site)\n+            java.util.List<MethodSymbol> overriddenMethods1 = overriddenMethodsMap.get(m1);\n+            java.util.List<MethodSymbol> overriddenMethods2 = overriddenMethodsMap.get(m2);\n+\n+            \/\/ Quick check for when a method was added by site itself\n+            if (overriddenMethods1 != null && overriddenMethods1.isEmpty())\n+                return true;\n+            if (overriddenMethods2 != null && overriddenMethods2.isEmpty())\n+                return true;\n+\n+            \/\/ Get each method's corresponding method(s) from supertypes of site\n+            java.util.List<MethodSymbol> supertypeMethods1 = overriddenMethods1 != null ?\n+              overriddenMethods1 : Collections.singletonList(m1);\n+            java.util.List<MethodSymbol> supertypeMethods2 = overriddenMethods2 != null ?\n+              overriddenMethods2 : Collections.singletonList(m2);\n+\n+            \/\/ See if some direct supertype is at fault\n+            return types.directSupertypes(site).stream()\n+              .filter(stype -> stype != syms.objectType)\n+              .map(stype -> stype.tsym.type)                \/\/ view supertype in its original form\n+              .noneMatch(stype -> {\n+                for (MethodSymbol sm1 : supertypeMethods1) {\n+                    if (!types.isSubtype(types.erasure(stype), types.erasure(sm1.owner.type)))\n+                        continue;\n+                    for (MethodSymbol sm2 : supertypeMethods2) {\n+                        if (!types.isSubtype(types.erasure(stype), types.erasure(sm2.owner.type)))\n+                            continue;\n+                        if (potentiallyAmbiguousOverload(stype, sm1, sm2))\n+                            return true;\n+                    }\n+                }\n+                return false;\n+            });\n+        };\n+\n+        \/\/ Now identify ambiguous overload method pairs for which site is responsible\n+        methodsByName.forEach(list -> {\n+            for (int i = 0; i < list.size() - 1; i++) {\n+                MethodSymbol m1 = list.get(i);\n+                for (int j = i + 1; j < list.size(); j++) {\n+                    MethodSymbol m2 = list.get(j);\n+                    if (potentiallyAmbiguousOverload(site, m1, m2) && responsible.test(m1, m2)) {\n+\n+                        \/\/ Locate the warning at one of the methods, if possible\n+                        DiagnosticPosition pos =\n+                            m1.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m1, tree) :\n+                            m2.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m2, tree) :\n+                            tree.pos();\n+\n+                        \/\/ Log warning\n+                        log.warning(LintCategory.OVERLOADS, pos,\n+                            Warnings.PotentiallyAmbiguousOverload(\n+                                m1.asMemberOf(site, types), m1.location(),\n+                                m2.asMemberOf(site, types), m2.location()));\n+\n+                        \/\/ Don't warn again for either of these two methods\n+                        list.remove(j);\n+                        list.remove(i--);\n+                        break;\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n@@ -2727,1 +2862,1 @@\n-      * lambda would be ambiguous).\n+      * lambda would be ambiguous). This assumes they already have the same name.\n@@ -2729,32 +2864,30 @@\n-    void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,\n-            MethodSymbol msym1, MethodSymbol msym2) {\n-        if (msym1 != msym2 &&\n-                lint.isEnabled(LintCategory.OVERLOADS) &&\n-                (msym1.flags() & POTENTIALLY_AMBIGUOUS) == 0 &&\n-                (msym2.flags() & POTENTIALLY_AMBIGUOUS) == 0) {\n-            Type mt1 = types.memberType(site, msym1);\n-            Type mt2 = types.memberType(site, msym2);\n-            \/\/if both generic methods, adjust type variables\n-            if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n-                    types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n-                mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n-            }\n-            \/\/expand varargs methods if needed\n-            int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n-            List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n-            List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n-            \/\/if arities don't match, exit\n-            if (args1.length() != args2.length()) return;\n-            boolean potentiallyAmbiguous = false;\n-            while (args1.nonEmpty() && args2.nonEmpty()) {\n-                Type s = args1.head;\n-                Type t = args2.head;\n-                if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n-                    if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n-                            types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n-                            types.findDescriptorType(s).getParameterTypes().length() ==\n-                            types.findDescriptorType(t).getParameterTypes().length()) {\n-                        potentiallyAmbiguous = true;\n-                    } else {\n-                        return;\n-                    }\n+    boolean potentiallyAmbiguousOverload(Type site, MethodSymbol msym1, MethodSymbol msym2) {\n+        Assert.check(msym1.name == msym2.name);\n+        if (msym1 == msym2)\n+            return false;\n+        Type mt1 = types.memberType(site, msym1);\n+        Type mt2 = types.memberType(site, msym2);\n+        \/\/if both generic methods, adjust type variables\n+        if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n+                types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n+            mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n+        }\n+        \/\/expand varargs methods if needed\n+        int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n+        List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n+        List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n+        \/\/if arities don't match, exit\n+        if (args1.length() != args2.length())\n+            return false;\n+        boolean potentiallyAmbiguous = false;\n+        while (args1.nonEmpty() && args2.nonEmpty()) {\n+            Type s = args1.head;\n+            Type t = args2.head;\n+            if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n+                if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n+                        types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n+                        types.findDescriptorType(s).getParameterTypes().length() ==\n+                        types.findDescriptorType(t).getParameterTypes().length()) {\n+                    potentiallyAmbiguous = true;\n+                } else {\n+                    return false;\n@@ -2762,12 +2895,0 @@\n-                args1 = args1.tail;\n-                args2 = args2.tail;\n-            }\n-            if (potentiallyAmbiguous) {\n-                \/\/we found two incompatible functional interfaces with same arity\n-                \/\/this means a call site passing an implicit lambda would be ambiguous\n-                msym1.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                msym2.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                log.warning(LintCategory.OVERLOADS, pos,\n-                            Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),\n-                                                                  msym2, msym2.location()));\n-                return;\n@@ -2775,0 +2896,2 @@\n+            args1 = args1.tail;\n+            args2 = args2.tail;\n@@ -2776,0 +2899,1 @@\n+        return potentiallyAmbiguous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":191,"deletions":67,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8024947\n+ * @bug 8024947 8026369\n@@ -73,0 +73,70 @@\n+\n+\/\/ The test cases below are from JDK-8026369\n+\n+    interface I6 {\n+        void foo(Consumer<Integer> c);\n+    }\n+\n+    interface I7 {\n+        void foo(IntConsumer c);\n+    }\n+\n+    \/\/a warning should be fired, I8 is provoking the issue\n+    interface I8 extends I6, I7 { }\n+\n+    \/\/no warning here, the issue is introduced in I8\n+    interface I9 extends I8 { }\n+\n+    \/\/no warning here\n+    interface I10<T> {\n+        void foo(Consumer<Integer> c);\n+        void foo(T c);\n+    }\n+\n+    \/\/a warning should be fired, I11 is provoking the issue\n+    interface I11 extends I10<IntConsumer> { }\n+\n+    \/\/ No warning should be fired here\n+    interface I12<T> extends Consumer<T>, IntSupplier {\n+        \/\/ A warning should be fired here\n+        interface OfInt extends I12<Integer>, IntConsumer {\n+            @Override\n+            void accept(int value);\n+            default void accept(Integer i) { }\n+        }\n+        @Override\n+        default int getAsInt() { return 0; }\n+    }\n+\n+    \/\/ No warning should be fired here\n+    abstract static class C6<T> implements I12.OfInt { }\n+\n+    default <U> Object foo() {\n+        \/\/ No warning should be fired here\n+        return new C6<U>() {\n+            @Override\n+            public void accept(int value) { }\n+        };\n+    }\n+\n+    \/\/ Overrides should not trigger warnings\n+    interface I13 extends I8 {\n+        @Override\n+        void foo(Consumer<Integer> c);\n+        @Override\n+        void foo(IntConsumer c);\n+    }\n+    interface I14 extends I8 {\n+        @Override\n+        void foo(IntConsumer c);\n+    }\n+\n+    \/\/ Verify we can suppress warnings at the class level\n+    @SuppressWarnings(\"overloads\")\n+    interface I15 extends I8 { }        \/\/ would normally trigger a warning\n+\n+    \/\/ Verify we can suppress warnings at the method level\n+    interface I16 extends I2 {\n+        @SuppressWarnings(\"overloads\")\n+        void foo(IntConsumer c);        \/\/ would normally trigger a warning\n+    }\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8024947\/PotentiallyAmbiguousWarningTest.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -3,4 +3,7 @@\n-PotentiallyAmbiguousWarningTest.java:31:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.J1, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I2\n-PotentiallyAmbiguousWarningTest.java:48:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.D1, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C2\n-PotentiallyAmbiguousWarningTest.java:54:21: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.C3, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C3\n-PotentiallyAmbiguousWarningTest.java:71:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.J2, foo(T), PotentiallyAmbiguousWarningTest.I5\n+PotentiallyAmbiguousWarningTest.java:31:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I2, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.J1\n+PotentiallyAmbiguousWarningTest.java:48:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C2, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.D1\n+PotentiallyAmbiguousWarningTest.java:53:21: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C3, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.C3\n+PotentiallyAmbiguousWarningTest.java:71:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I5, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.J2\n+PotentiallyAmbiguousWarningTest.java:85:5: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I6, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I7\n+PotentiallyAmbiguousWarningTest.java:97:5: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I10, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I10\n+PotentiallyAmbiguousWarningTest.java:102:9: compiler.warn.potentially.ambiguous.overload: andThen(java.util.function.Consumer<? super java.lang.Integer>), java.util.function.Consumer, andThen(java.util.function.IntConsumer), java.util.function.IntConsumer\n@@ -9,1 +12,1 @@\n-6 warnings\n+9 warnings\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8024947\/PotentiallyAmbiguousWarningTest.out","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"}]}