{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.util.function.ToIntBiFunction;\n@@ -98,0 +99,4 @@\n+    \/\/ Flag bits indicating which item(s) chosen from a pair of items\n+    private static final int FIRST = 0x01;\n+    private static final int SECOND = 0x02;\n+\n@@ -2706,13 +2711,1 @@\n-    \/** Report warnings for potentially ambiguous method declarations in the given site.\n-     *\n-     *  Sometimes ambiguous methods are unaviodable because they're inherited from a\n-     *  single supertype. For example, any subtype of Spliterator.OfInt will have\n-     *  ambiguities for both forEachRemaining() and tryAdvance() (in both cases the\n-     *  overloads are IntConsumer and Consumer&lt;? super Integer&gt;). So we only want\n-     *  to \"blame\" a class when that class is itself responsible for creating the\n-     *  ambiguity. So we declare that site is \"responsible\" for the ambiguity between\n-     *  two methods m1 and m2 if there is no direct supertype T of site such that\n-     *  m1 and m2, or some overrides thereof, both exist and are ambiguous in T.\n-     *  As an optimization, we first check if either method is declared in site and\n-     *  does not override any other methods (in which case site is responsible).\n-     *\/\n+    \/** Report warnings for potentially ambiguous method declarations in the given site. *\/\n@@ -2725,13 +2718,49 @@\n-        \/\/ Gather all of site's methods, including overridden methods, grouped by name.\n-        \/\/ We sort the groups by name simply to eliminate non-determinism in the analysis.\n-        List<java.util.List<MethodSymbol>> methodsByName = StreamSupport.stream(\n-            types.membersClosure(site, false).getSymbols(new ClashFilter(site), RECURSIVE).spliterator(), false)\n-          .map(MethodSymbol.class::cast)\n-          .filter(m -> m.owner.type.tsym != syms.objectType.tsym)\n-          .collect(Collectors.groupingBy(m -> m.name, Collectors.toCollection(ArrayList::new)))\n-          .entrySet()\n-          .stream()\n-          .sorted(Comparator.comparing(e -> e.getKey().toString()))\n-          .map(Map.Entry::getValue)\n-          .peek(Collections::reverse)               \/\/ seems to help warning ordering\n-          .collect(List.collector());\n+        \/\/ Gather all of site's methods, including overridden methods, grouped by name (except Object methods)\n+        List<java.util.List<MethodSymbol>> methodGroups = methodsGroupedByName(site,\n+            new PotentiallyAmbiguousFilter(site), ArrayList::new);\n+\n+        \/\/ Reverse all the lists, which seems to help with warning ordering\n+        methodGroups.forEach(Collections::reverse);\n+\n+        \/\/ Build the predicate that determines if site is responsible for an ambiguity\n+        BiPredicate<MethodSymbol, MethodSymbol> responsible = buildResponsiblePredicate(site, methodGroups);\n+\n+        \/\/ Warn about ambiguous overload method pairs for which site is responsible\n+        methodGroups.forEach(list -> compareAndRemove(list, (m1, m2) -> {\n+\n+            \/\/ See if this is an ambiguous overload for which \"site\" is responsible\n+            if (!potentiallyAmbiguousOverload(site, m1, m2) || !responsible.test(m1, m2))\n+                return 0;\n+\n+            \/\/ Locate the warning at one of the methods, if possible\n+            DiagnosticPosition pos =\n+                m1.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m1, tree) :\n+                m2.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m2, tree) :\n+                tree.pos();\n+\n+            \/\/ Log the warning\n+            log.warning(LintCategory.OVERLOADS, pos,\n+                Warnings.PotentiallyAmbiguousOverload(\n+                    m1.asMemberOf(site, types), m1.location(),\n+                    m2.asMemberOf(site, types), m2.location()));\n+\n+            \/\/ Don't warn again for either of these two methods\n+            return FIRST | SECOND;\n+        }));\n+    }\n+\n+    \/** Build a predicate that determines, given two methods that are members of the given class,\n+     *  whether the class should be held \"responsible\" if the methods are potentially ambiguous.\n+     *\n+     *  Sometimes ambiguous methods are unavoidable because they're inherited from a supertype.\n+     *  For example, any subtype of Spliterator.OfInt will have ambiguities for both\n+     *  forEachRemaining() and tryAdvance() (in both cases the overloads are IntConsumer and\n+     *  Consumer&lt;? super Integer&gt;). So we only want to \"blame\" a class when that class is\n+     *  itself responsible for creating the ambiguity. We declare that a class C is \"responsible\"\n+     *  for the ambiguity between two methods m1 and m2 if there is no direct supertype T of C\n+     *  such that m1 and m2, or some overrides thereof, both exist in T and are ambiguous in T.\n+     *  As an optimization, we first check if either method is declared in C and does not override\n+     *  any other methods; in this case the class is definitely responsible.\n+     *\/\n+    BiPredicate<MethodSymbol, MethodSymbol> buildResponsiblePredicate(Type site,\n+        List<? extends java.util.List<MethodSymbol>> methodGroups) {\n@@ -2742,18 +2771,0 @@\n-        \/\/ Define a processor that removes overridden methods from a list\n-        Consumer<java.util.List<MethodSymbol>> overriddenRemover = list -> {\n-            for (int i = 0; i < list.size() - 1; i++) {\n-                MethodSymbol m1 = list.get(i);\n-                for (int j = i + 1; j < list.size(); j++) {\n-                    MethodSymbol m2 = list.get(j);\n-                    if (overrides.test(m1, m2)) {\n-                        list.remove(j--);           \/\/ remove m2\n-                        continue;\n-                    }\n-                    if (overrides.test(m2, m1)) {\n-                        list.remove(i--);           \/\/ remove m1\n-                        break;\n-                    }\n-                }\n-            }\n-        };\n-\n@@ -2761,2 +2772,2 @@\n-        HashMap<MethodSymbol, java.util.List<MethodSymbol>> overriddenMethodsMap = new HashMap<>();\n-        methodsByName.forEach(list -> {\n+        HashMap<MethodSymbol, ArrayList<MethodSymbol>> overriddenMethodsMap = new HashMap<>();\n+        methodGroups.forEach(list -> {\n@@ -2770,3 +2781,2 @@\n-                java.util.List<MethodSymbol> overriddenMethods = list.stream()\n-                  .filter(m2 -> m2 != m)\n-                  .filter(m2 -> overrides.test(m, m2))\n+                ArrayList<MethodSymbol> overriddenMethods = list.stream()\n+                  .filter(m2 -> m2 != m && overrides.test(m, m2))\n@@ -2776,1 +2786,1 @@\n-                overriddenRemover.accept(overriddenMethods);\n+                removePreempted(overriddenMethods, overrides);\n@@ -2783,2 +2793,2 @@\n-        \/\/ Remove overridden methods from each name group, leaving site's actual member methods\n-        methodsByName.forEach(overriddenRemover);\n+        \/\/ Now remove overridden methods from each group, leaving only site's actual members\n+        methodGroups.forEach(list -> removePreempted(list, overrides));\n@@ -2787,1 +2797,1 @@\n-        methodsByName.forEach(list -> list.removeIf(\n+        methodGroups.forEach(list -> list.removeIf(\n@@ -2790,2 +2800,2 @@\n-        \/\/ Define the predicate that determines if site is \"responsible\" for an ambiguity\n-        BiPredicate<MethodSymbol, MethodSymbol> responsible = (m1, m2) -> {\n+        \/\/ Build the predicate\n+        return (m1, m2) -> {\n@@ -2797,1 +2807,1 @@\n-            \/\/ Quick check for when a method was added by site itself\n+            \/\/ Quick check for the case where a method was added by site itself\n@@ -2809,1 +2819,1 @@\n-            \/\/ See if some direct supertype is at fault\n+            \/\/ See if we can blame some direct supertype instead\n@@ -2827,0 +2837,1 @@\n+    }\n@@ -2828,25 +2839,31 @@\n-        \/\/ Now identify ambiguous overload method pairs for which site is responsible\n-        methodsByName.forEach(list -> {\n-            for (int i = 0; i < list.size() - 1; i++) {\n-                MethodSymbol m1 = list.get(i);\n-                for (int j = i + 1; j < list.size(); j++) {\n-                    MethodSymbol m2 = list.get(j);\n-                    if (potentiallyAmbiguousOverload(site, m1, m2) && responsible.test(m1, m2)) {\n-\n-                        \/\/ Locate the warning at one of the methods, if possible\n-                        DiagnosticPosition pos =\n-                            m1.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m1, tree) :\n-                            m2.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m2, tree) :\n-                            tree.pos();\n-\n-                        \/\/ Log warning\n-                        log.warning(LintCategory.OVERLOADS, pos,\n-                            Warnings.PotentiallyAmbiguousOverload(\n-                                m1.asMemberOf(site, types), m1.location(),\n-                                m2.asMemberOf(site, types), m2.location()));\n-\n-                        \/\/ Don't warn again for either of these two methods\n-                        list.remove(j);\n-                        list.remove(i--);\n-                        break;\n-                    }\n+    \/** Gather all of site's methods, including overridden methods, grouped and sorted by name,\n+     *  after applying the given filter.\n+     *\/\n+    <C extends Collection<MethodSymbol>> List<C> methodsGroupedByName(Type site,\n+            Predicate<Symbol> filter, Supplier<? extends C> groupMaker) {\n+        Iterable<Symbol> symbols = types.membersClosure(site, false).getSymbols(filter, RECURSIVE);\n+        return StreamSupport.stream(symbols.spliterator(), false)\n+          .map(MethodSymbol.class::cast)\n+          .collect(Collectors.groupingBy(m -> m.name, Collectors.toCollection(groupMaker)))\n+          .entrySet()\n+          .stream()\n+          .sorted(Comparator.comparing(e -> e.getKey().toString()))\n+          .map(Map.Entry::getValue)\n+          .collect(List.collector());\n+    }\n+\n+    \/** Compare elements in a list pair-wise in order to remove some of them.\n+     *  @param list mutable list of items\n+     *  @param comparer returns flag bit(s) to remove FIRST and\/or SECOND\n+     *\/\n+    <T> void compareAndRemove(java.util.List<T> list, ToIntBiFunction<? super T, ? super T> comparer) {\n+        for (int index1 = 0; index1 < list.size() - 1; index1++) {\n+            T item1 = list.get(index1);\n+            for (int index2 = index1 + 1; index2 < list.size(); index2++) {\n+                T item2 = list.get(index2);\n+                int flags = comparer.applyAsInt(item1, item2);\n+                if ((flags & SECOND) != 0)\n+                    list.remove(index2--);          \/\/ remove item2\n+                if ((flags & FIRST) != 0) {\n+                    list.remove(index1--);          \/\/ remove item1\n+                    break;\n@@ -2855,0 +2872,15 @@\n+        }\n+    }\n+\n+    \/** Remove elements in a list that are preempted by some other element in the list.\n+     *  @param list mutable list of items\n+     *  @param preempts decides if one item preempts another, causing the second one to be removed\n+     *\/\n+    <T> void removePreempted(java.util.List<T> list, BiPredicate<? super T, ? super T> preempts) {\n+        compareAndRemove(list, (item1, item2) -> {\n+            int flags = 0;\n+            if (preempts.test(item1, item2))\n+                flags |= SECOND;\n+            if (preempts.test(item2, item1))\n+                flags |= FIRST;\n+            return flags;\n@@ -2858,0 +2890,13 @@\n+    \/** Filters method candidates for the \"potentially ambiguous method\" check *\/\n+    class PotentiallyAmbiguousFilter extends ClashFilter {\n+\n+        PotentiallyAmbiguousFilter(Type site) {\n+            super(site);\n+        }\n+\n+        @Override\n+        boolean shouldSkip(Symbol s) {\n+            return s.owner.type.tsym == syms.objectType.tsym || super.shouldSkip(s);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":127,"deletions":82,"binary":false,"changes":209,"status":"modified"}]}