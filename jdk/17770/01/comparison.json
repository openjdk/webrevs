{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -863,1 +863,1 @@\n-            return 0;\n+            return constant;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8325485\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -488,1 +488,1 @@\n-            for (int i = from; i < length; i++) {\n+            for (int i = from; i < from + length; i++) {\n@@ -560,1 +560,1 @@\n-                            yield code.hash(p[0] + 1, ins.sizeInBytes());\n+                            yield code.hash(p[0] + 1, ins.sizeInBytes() - 1);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,388 +72,9 @@\n-                                    case CodeModel com -> mb.withCode(cb -> cb.transforming(CodeStackTracker.of(), cob -> {\n-                                        var labels = new HashMap<Label, Label>();\n-                                        for (var coe : com) {\n-                                            switch (coe) {\n-                                                case ArrayLoadInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case ByteType -> cob.baload();\n-                                                        case ShortType -> cob.saload();\n-                                                        case IntType -> cob.iaload();\n-                                                        case FloatType -> cob.faload();\n-                                                        case LongType -> cob.laload();\n-                                                        case DoubleType -> cob.daload();\n-                                                        case ReferenceType -> cob.aaload();\n-                                                        case CharType -> cob.caload();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case ArrayStoreInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case ByteType -> cob.bastore();\n-                                                        case ShortType -> cob.sastore();\n-                                                        case IntType -> cob.iastore();\n-                                                        case FloatType -> cob.fastore();\n-                                                        case LongType -> cob.lastore();\n-                                                        case DoubleType -> cob.dastore();\n-                                                        case ReferenceType -> cob.aastore();\n-                                                        case CharType -> cob.castore();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case BranchInstruction i -> {\n-                                                    var target = labels.computeIfAbsent(i.target(), l -> cob.newLabel());\n-                                                    switch (i.opcode()) {\n-                                                        case GOTO -> cob.goto_(target);\n-                                                        case GOTO_W -> cob.goto_w(target);\n-                                                        case IF_ACMPEQ -> cob.if_acmpeq(target);\n-                                                        case IF_ACMPNE -> cob.if_acmpne(target);\n-                                                        case IF_ICMPEQ -> cob.if_icmpeq(target);\n-                                                        case IF_ICMPGE -> cob.if_icmpge(target);\n-                                                        case IF_ICMPGT -> cob.if_icmpgt(target);\n-                                                        case IF_ICMPLE -> cob.if_icmple(target);\n-                                                        case IF_ICMPLT -> cob.if_icmplt(target);\n-                                                        case IF_ICMPNE -> cob.if_icmpne(target);\n-                                                        case IFNONNULL -> cob.if_nonnull(target);\n-                                                        case IFNULL -> cob.if_null(target);\n-                                                        case IFEQ -> cob.ifeq(target);\n-                                                        case IFGE -> cob.ifge(target);\n-                                                        case IFGT -> cob.ifgt(target);\n-                                                        case IFLE -> cob.ifle(target);\n-                                                        case IFLT -> cob.iflt(target);\n-                                                        case IFNE -> cob.ifne(target);\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case ConstantInstruction i -> {\n-                                                    if (i.constantValue() == null)\n-                                                        if (pathSwitch.nextBoolean()) cob.aconst_null();\n-                                                        else cob.constantInstruction(null);\n-                                                    else switch (i.constantValue()) {\n-                                                        case Integer iVal -> {\n-                                                            if (iVal == 1 && pathSwitch.nextBoolean()) cob.iconst_1();\n-                                                            else if (iVal == 2 && pathSwitch.nextBoolean()) cob.iconst_2();\n-                                                            else if (iVal == 3 && pathSwitch.nextBoolean()) cob.iconst_3();\n-                                                            else if (iVal == 4 && pathSwitch.nextBoolean()) cob.iconst_4();\n-                                                            else if (iVal == 5 && pathSwitch.nextBoolean()) cob.iconst_5();\n-                                                            else if (iVal == -1 && pathSwitch.nextBoolean()) cob.iconst_m1();\n-                                                            else if (iVal >= -128 && iVal <= 127 && pathSwitch.nextBoolean()) cob.bipush(iVal);\n-                                                            else if (iVal >= -32768 && iVal <= 32767 && pathSwitch.nextBoolean()) cob.sipush(iVal);\n-                                                            else cob.constantInstruction(iVal);\n-                                                        }\n-                                                        case Long lVal -> {\n-                                                            if (lVal == 0 && pathSwitch.nextBoolean()) cob.lconst_0();\n-                                                            else if (lVal == 1 && pathSwitch.nextBoolean()) cob.lconst_1();\n-                                                            else cob.constantInstruction(lVal);\n-                                                        }\n-                                                        case Float fVal -> {\n-                                                            if (fVal == 0.0 && pathSwitch.nextBoolean()) cob.fconst_0();\n-                                                            else if (fVal == 1.0 && pathSwitch.nextBoolean()) cob.fconst_1();\n-                                                            else if (fVal == 2.0 && pathSwitch.nextBoolean()) cob.fconst_2();\n-                                                            else cob.constantInstruction(fVal);\n-                                                        }\n-                                                        case Double dVal -> {\n-                                                            if (dVal == 0.0d && pathSwitch.nextBoolean()) cob.dconst_0();\n-                                                            else if (dVal == 1.0d && pathSwitch.nextBoolean()) cob.dconst_1();\n-                                                            else cob.constantInstruction(dVal);\n-                                                        }\n-                                                        default -> cob.constantInstruction(i.constantValue());\n-                                                    }\n-                                                }\n-                                                case ConvertInstruction i -> {\n-                                                    switch (i.fromType()) {\n-                                                        case DoubleType -> {\n-                                                            switch (i.toType()) {\n-                                                                case FloatType -> cob.d2f();\n-                                                                case IntType -> cob.d2i();\n-                                                                case LongType -> cob.d2l();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        case FloatType -> {\n-                                                            switch (i.toType()) {\n-                                                                case DoubleType -> cob.f2d();\n-                                                                case IntType -> cob.f2i();\n-                                                                case LongType -> cob.f2l();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        case IntType -> {\n-                                                            switch (i.toType()) {\n-                                                                case ByteType -> cob.i2b();\n-                                                                case CharType -> cob.i2c();\n-                                                                case DoubleType -> cob.i2d();\n-                                                                case FloatType -> cob.i2f();\n-                                                                case LongType -> cob.i2l();\n-                                                                case ShortType -> cob.i2s();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        case LongType -> {\n-                                                            switch (i.toType()) {\n-                                                                case DoubleType -> cob.l2d();\n-                                                                case FloatType -> cob.l2f();\n-                                                                case IntType -> cob.l2i();\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case DiscontinuedInstruction.JsrInstruction i ->\n-                                                    cob.with(DiscontinuedInstruction.JsrInstruction.of(i.opcode(), labels.computeIfAbsent(i.target(), l -> cob.newLabel())));\n-                                                case DiscontinuedInstruction.RetInstruction i ->\n-                                                    cob.with(DiscontinuedInstruction.RetInstruction.of(i.opcode(), i.slot()));\n-                                                case FieldInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        switch (i.opcode()) {\n-                                                            case GETFIELD -> cob.getfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            case GETSTATIC -> cob.getstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            case PUTFIELD -> cob.putfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            case PUTSTATIC -> cob.putstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    } else {\n-                                                        switch (i.opcode()) {\n-                                                            case GETFIELD -> cob.getfield(i.field());\n-                                                            case GETSTATIC -> cob.getstatic(i.field());\n-                                                            case PUTFIELD -> cob.putfield(i.field());\n-                                                            case PUTSTATIC -> cob.putstatic(i.field());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    }\n-                                                }\n-                                                case InvokeDynamicInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) cob.invokedynamic(i.invokedynamic().asSymbol());\n-                                                    else cob.invokedynamic(i.invokedynamic());\n-                                                }\n-                                                case InvokeInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        if (i.isInterface()) {\n-                                                            switch (i.opcode()) {\n-                                                                case INVOKEINTERFACE -> cob.invokeinterface(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n-                                                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        } else {\n-                                                            switch (i.opcode()) {\n-                                                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                case INVOKEVIRTUAL -> cob.invokevirtual(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n-                                                                default -> throw new AssertionError(\"Should not reach here\");\n-                                                            }\n-                                                        }\n-                                                    } else {\n-                                                        switch (i.method()) {\n-                                                            case InterfaceMethodRefEntry en -> {\n-                                                                switch (i.opcode()) {\n-                                                                        case INVOKEINTERFACE -> cob.invokeinterface(en);\n-                                                                        case INVOKESPECIAL -> cob.invokespecial(en);\n-                                                                        case INVOKESTATIC -> cob.invokestatic(en);\n-                                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                                }\n-                                                            }\n-                                                            case MethodRefEntry en -> {\n-                                                                switch (i.opcode()) {\n-                                                                        case INVOKESPECIAL -> cob.invokespecial(en);\n-                                                                        case INVOKESTATIC -> cob.invokestatic(en);\n-                                                                        case INVOKEVIRTUAL -> cob.invokevirtual(en);\n-                                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                                }\n-                                                            }\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    }\n-                                                }\n-                                                case LoadInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case IntType -> cob.iload(i.slot());\n-                                                        case FloatType -> cob.fload(i.slot());\n-                                                        case LongType -> cob.lload(i.slot());\n-                                                        case DoubleType -> cob.dload(i.slot());\n-                                                        case ReferenceType -> cob.aload(i.slot());\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case StoreInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case IntType -> cob.istore(i.slot());\n-                                                        case FloatType -> cob.fstore(i.slot());\n-                                                        case LongType -> cob.lstore(i.slot());\n-                                                        case DoubleType -> cob.dstore(i.slot());\n-                                                        case ReferenceType -> cob.astore(i.slot());\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case IncrementInstruction i ->\n-                                                    cob.iinc(i.slot(), i.constant());\n-                                                case LookupSwitchInstruction i ->\n-                                                    cob.lookupswitch(labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n-                                                                     i.cases().stream().map(sc ->\n-                                                                             SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n-                                                case MonitorInstruction i -> {\n-                                                    switch (i.opcode()) {\n-                                                        case MONITORENTER ->  cob.monitorenter();\n-                                                        case MONITOREXIT ->  cob.monitorexit();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case NewMultiArrayInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        cob.multianewarray(i.arrayType().asSymbol(), i.dimensions());\n-                                                    } else {\n-                                                        cob.multianewarray(i.arrayType(), i.dimensions());\n-                                                    }\n-                                                }\n-                                                case NewObjectInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        cob.new_(i.className().asSymbol());\n-                                                    } else {\n-                                                        cob.new_(i.className());\n-                                                    }\n-                                                }\n-                                                case NewPrimitiveArrayInstruction i ->\n-                                                    cob.newarray(i.typeKind());\n-                                                case NewReferenceArrayInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        cob.anewarray(i.componentType().asSymbol());\n-                                                    } else {\n-                                                        cob.anewarray(i.componentType());\n-                                                    }\n-                                                }\n-                                                case NopInstruction i ->\n-                                                    cob.nop();\n-                                                case OperatorInstruction i -> {\n-                                                    switch (i.opcode()) {\n-                                                        case IADD -> cob.iadd();\n-                                                        case LADD -> cob.ladd();\n-                                                        case FADD -> cob.fadd();\n-                                                        case DADD -> cob.dadd();\n-                                                        case ISUB -> cob.isub();\n-                                                        case LSUB -> cob.lsub();\n-                                                        case FSUB -> cob.fsub();\n-                                                        case DSUB -> cob.dsub();\n-                                                        case IMUL -> cob.imul();\n-                                                        case LMUL -> cob.lmul();\n-                                                        case FMUL -> cob.fmul();\n-                                                        case DMUL -> cob.dmul();\n-                                                        case IDIV -> cob.idiv();\n-                                                        case LDIV -> cob.ldiv();\n-                                                        case FDIV -> cob.fdiv();\n-                                                        case DDIV -> cob.ddiv();\n-                                                        case IREM -> cob.irem();\n-                                                        case LREM -> cob.lrem();\n-                                                        case FREM -> cob.frem();\n-                                                        case DREM -> cob.drem();\n-                                                        case INEG -> cob.ineg();\n-                                                        case LNEG -> cob.lneg();\n-                                                        case FNEG -> cob.fneg();\n-                                                        case DNEG -> cob.dneg();\n-                                                        case ISHL -> cob.ishl();\n-                                                        case LSHL -> cob.lshl();\n-                                                        case ISHR -> cob.ishr();\n-                                                        case LSHR -> cob.lshr();\n-                                                        case IUSHR -> cob.iushr();\n-                                                        case LUSHR -> cob.lushr();\n-                                                        case IAND -> cob.iand();\n-                                                        case LAND -> cob.land();\n-                                                        case IOR -> cob.ior();\n-                                                        case LOR -> cob.lor();\n-                                                        case IXOR -> cob.ixor();\n-                                                        case LXOR -> cob.lxor();\n-                                                        case LCMP -> cob.lcmp();\n-                                                        case FCMPL -> cob.fcmpl();\n-                                                        case FCMPG -> cob.fcmpg();\n-                                                        case DCMPL -> cob.dcmpl();\n-                                                        case DCMPG -> cob.dcmpg();\n-                                                        case ARRAYLENGTH -> cob.arraylength();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case ReturnInstruction i -> {\n-                                                    switch (i.typeKind()) {\n-                                                        case IntType -> cob.ireturn();\n-                                                        case FloatType -> cob.freturn();\n-                                                        case LongType -> cob.lreturn();\n-                                                        case DoubleType -> cob.dreturn();\n-                                                        case ReferenceType -> cob.areturn();\n-                                                        case VoidType -> cob.return_();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case StackInstruction i -> {\n-                                                    switch (i.opcode()) {\n-                                                        case POP -> cob.pop();\n-                                                        case POP2 -> cob.pop2();\n-                                                        case DUP -> cob.dup();\n-                                                        case DUP_X1 -> cob.dup_x1();\n-                                                        case DUP_X2 -> cob.dup_x2();\n-                                                        case DUP2 -> cob.dup2();\n-                                                        case DUP2_X1 -> cob.dup2_x1();\n-                                                        case DUP2_X2 -> cob.dup2_x2();\n-                                                        case SWAP -> cob.swap();\n-                                                        default -> throw new AssertionError(\"Should not reach here\");\n-                                                    }\n-                                                }\n-                                                case TableSwitchInstruction i ->\n-                                                    cob.tableswitch(i.lowValue(), i.highValue(),\n-                                                                    labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n-                                                                    i.cases().stream().map(sc ->\n-                                                                            SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n-                                                case ThrowInstruction i -> cob.athrow();\n-                                                case TypeCheckInstruction i -> {\n-                                                    if (pathSwitch.nextBoolean()) {\n-                                                        switch (i.opcode()) {\n-                                                            case CHECKCAST -> cob.checkcast(i.type().asSymbol());\n-                                                            case INSTANCEOF -> cob.instanceof_(i.type().asSymbol());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    } else {\n-                                                        switch (i.opcode()) {\n-                                                            case CHECKCAST -> cob.checkcast(i.type());\n-                                                            case INSTANCEOF -> cob.instanceof_(i.type());\n-                                                            default -> throw new AssertionError(\"Should not reach here\");\n-                                                        }\n-                                                    }\n-                                                }\n-                                                case CharacterRange pi ->\n-                                                    cob.characterRange(labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n-                                                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()),\n-                                                                       pi.characterRangeStart(), pi.characterRangeEnd(), pi.flags());\n-                                                case ExceptionCatch pi ->\n-                                                    pi.catchType().ifPresentOrElse(\n-                                                            catchType -> cob.exceptionCatch(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n-                                                                                            labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n-                                                                                            labels.computeIfAbsent(pi.handler(), l -> cob.newLabel()),\n-                                                                                            catchType.asSymbol()),\n-                                                            () -> cob.exceptionCatchAll(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n-                                                                                        labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n-                                                                                        labels.computeIfAbsent(pi.handler(), l -> cob.newLabel())));\n-                                                case LabelTarget pi ->\n-                                                    cob.labelBinding(labels.computeIfAbsent(pi.label(), l -> cob.newLabel()));\n-                                                case LineNumber pi ->\n-                                                    cob.lineNumber(pi.line());\n-                                                case LocalVariable pi ->\n-                                                    cob.localVariable(pi.slot(), pi.name().stringValue(), pi.typeSymbol(),\n-                                                                      labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n-                                                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n-                                                case LocalVariableType pi ->\n-                                                    cob.localVariableType(pi.slot(), pi.name().stringValue(),\n-                                                                          Signature.parseFrom(pi.signatureSymbol().signatureString()),\n-                                                                          labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n-                                                                          labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n-                                                case RuntimeInvisibleTypeAnnotationsAttribute a ->\n-                                                    cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n-                                                case RuntimeVisibleTypeAnnotationsAttribute a ->\n-                                                    cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n-                                                case StackMapTableAttribute a ->\n-                                                    throw new AssertionError(\"Unexpected StackMapTableAttribute here\");\n-                                                case CustomAttribute a ->\n-                                                    throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n-                                            }\n-                                        }\n-                                        com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(smta ->\n-                                                    cob.with(StackMapTableAttribute.of(smta.entries().stream().map(fr ->\n-                                                            StackMapFrameInfo.of(labels.computeIfAbsent(fr.target(), l -> cob.newLabel()),\n-                                                                    transformFrameTypeInfos(fr.locals(), cob, labels),\n-                                                                    transformFrameTypeInfos(fr.stack(), cob, labels))).toList())));\n-                                    }));\n+                                    case CodeModel com -> mb.withCode(cob1 ->\n+                                            cob1.transforming(CodeStackTracker.of(), cob2 ->\n+                                            \/\/ second pass transforms unbound to unbound instructions\n+                                            cob2.transforming(new CodeRebuildingTransform(), cob3 ->\n+                                            \/\/ first pass transforms bound to unbound instructions\n+                                            cob3.transforming(new CodeRebuildingTransform(), cob4 -> {\n+                                                com.forEachElement(cob4::with);\n+                                                com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(cob4::with);\n+                                            }))));\n@@ -592,0 +213,390 @@\n+\n+    static class CodeRebuildingTransform implements CodeTransform {\n+\n+        final HashMap<Label, Label> labels = new HashMap<>();\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case ArrayLoadInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case ByteType -> cob.baload();\n+                        case ShortType -> cob.saload();\n+                        case IntType -> cob.iaload();\n+                        case FloatType -> cob.faload();\n+                        case LongType -> cob.laload();\n+                        case DoubleType -> cob.daload();\n+                        case ReferenceType -> cob.aaload();\n+                        case CharType -> cob.caload();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case ArrayStoreInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case ByteType -> cob.bastore();\n+                        case ShortType -> cob.sastore();\n+                        case IntType -> cob.iastore();\n+                        case FloatType -> cob.fastore();\n+                        case LongType -> cob.lastore();\n+                        case DoubleType -> cob.dastore();\n+                        case ReferenceType -> cob.aastore();\n+                        case CharType -> cob.castore();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case BranchInstruction i -> {\n+                    var target = labels.computeIfAbsent(i.target(), l -> cob.newLabel());\n+                    switch (i.opcode()) {\n+                        case GOTO -> cob.goto_(target);\n+                        case GOTO_W -> cob.goto_w(target);\n+                        case IF_ACMPEQ -> cob.if_acmpeq(target);\n+                        case IF_ACMPNE -> cob.if_acmpne(target);\n+                        case IF_ICMPEQ -> cob.if_icmpeq(target);\n+                        case IF_ICMPGE -> cob.if_icmpge(target);\n+                        case IF_ICMPGT -> cob.if_icmpgt(target);\n+                        case IF_ICMPLE -> cob.if_icmple(target);\n+                        case IF_ICMPLT -> cob.if_icmplt(target);\n+                        case IF_ICMPNE -> cob.if_icmpne(target);\n+                        case IFNONNULL -> cob.if_nonnull(target);\n+                        case IFNULL -> cob.if_null(target);\n+                        case IFEQ -> cob.ifeq(target);\n+                        case IFGE -> cob.ifge(target);\n+                        case IFGT -> cob.ifgt(target);\n+                        case IFLE -> cob.ifle(target);\n+                        case IFLT -> cob.iflt(target);\n+                        case IFNE -> cob.ifne(target);\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case ConstantInstruction i -> {\n+                    if (i.constantValue() == null)\n+                        if (pathSwitch.nextBoolean()) cob.aconst_null();\n+                        else cob.constantInstruction(null);\n+                    else switch (i.constantValue()) {\n+                        case Integer iVal -> {\n+                            if (iVal == 1 && pathSwitch.nextBoolean()) cob.iconst_1();\n+                            else if (iVal == 2 && pathSwitch.nextBoolean()) cob.iconst_2();\n+                            else if (iVal == 3 && pathSwitch.nextBoolean()) cob.iconst_3();\n+                            else if (iVal == 4 && pathSwitch.nextBoolean()) cob.iconst_4();\n+                            else if (iVal == 5 && pathSwitch.nextBoolean()) cob.iconst_5();\n+                            else if (iVal == -1 && pathSwitch.nextBoolean()) cob.iconst_m1();\n+                            else if (iVal >= -128 && iVal <= 127 && pathSwitch.nextBoolean()) cob.bipush(iVal);\n+                            else if (iVal >= -32768 && iVal <= 32767 && pathSwitch.nextBoolean()) cob.sipush(iVal);\n+                            else cob.constantInstruction(iVal);\n+                        }\n+                        case Long lVal -> {\n+                            if (lVal == 0 && pathSwitch.nextBoolean()) cob.lconst_0();\n+                            else if (lVal == 1 && pathSwitch.nextBoolean()) cob.lconst_1();\n+                            else cob.constantInstruction(lVal);\n+                        }\n+                        case Float fVal -> {\n+                            if (fVal == 0.0 && pathSwitch.nextBoolean()) cob.fconst_0();\n+                            else if (fVal == 1.0 && pathSwitch.nextBoolean()) cob.fconst_1();\n+                            else if (fVal == 2.0 && pathSwitch.nextBoolean()) cob.fconst_2();\n+                            else cob.constantInstruction(fVal);\n+                        }\n+                        case Double dVal -> {\n+                            if (dVal == 0.0d && pathSwitch.nextBoolean()) cob.dconst_0();\n+                            else if (dVal == 1.0d && pathSwitch.nextBoolean()) cob.dconst_1();\n+                            else cob.constantInstruction(dVal);\n+                        }\n+                        default -> cob.constantInstruction(i.constantValue());\n+                    }\n+                }\n+                case ConvertInstruction i -> {\n+                    switch (i.fromType()) {\n+                        case DoubleType -> {\n+                            switch (i.toType()) {\n+                                case FloatType -> cob.d2f();\n+                                case IntType -> cob.d2i();\n+                                case LongType -> cob.d2l();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        case FloatType -> {\n+                            switch (i.toType()) {\n+                                case DoubleType -> cob.f2d();\n+                                case IntType -> cob.f2i();\n+                                case LongType -> cob.f2l();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        case IntType -> {\n+                            switch (i.toType()) {\n+                                case ByteType -> cob.i2b();\n+                                case CharType -> cob.i2c();\n+                                case DoubleType -> cob.i2d();\n+                                case FloatType -> cob.i2f();\n+                                case LongType -> cob.i2l();\n+                                case ShortType -> cob.i2s();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        case LongType -> {\n+                            switch (i.toType()) {\n+                                case DoubleType -> cob.l2d();\n+                                case FloatType -> cob.l2f();\n+                                case IntType -> cob.l2i();\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case DiscontinuedInstruction.JsrInstruction i ->\n+                    cob.with(DiscontinuedInstruction.JsrInstruction.of(i.opcode(), labels.computeIfAbsent(i.target(), l -> cob.newLabel())));\n+                case DiscontinuedInstruction.RetInstruction i ->\n+                    cob.with(DiscontinuedInstruction.RetInstruction.of(i.opcode(), i.slot()));\n+                case FieldInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        switch (i.opcode()) {\n+                            case GETFIELD -> cob.getfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            case GETSTATIC -> cob.getstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            case PUTFIELD -> cob.putfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            case PUTSTATIC -> cob.putstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    } else {\n+                        switch (i.opcode()) {\n+                            case GETFIELD -> cob.getfield(i.field());\n+                            case GETSTATIC -> cob.getstatic(i.field());\n+                            case PUTFIELD -> cob.putfield(i.field());\n+                            case PUTSTATIC -> cob.putstatic(i.field());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                }\n+                case InvokeDynamicInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) cob.invokedynamic(i.invokedynamic().asSymbol());\n+                    else cob.invokedynamic(i.invokedynamic());\n+                }\n+                case InvokeInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        if (i.isInterface()) {\n+                            switch (i.opcode()) {\n+                                case INVOKEINTERFACE -> cob.invokeinterface(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n+                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        } else {\n+                            switch (i.opcode()) {\n+                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                case INVOKEVIRTUAL -> cob.invokevirtual(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                default -> throw new AssertionError(\"Should not reach here\");\n+                            }\n+                        }\n+                    } else {\n+                        switch (i.method()) {\n+                            case InterfaceMethodRefEntry en -> {\n+                                switch (i.opcode()) {\n+                                        case INVOKEINTERFACE -> cob.invokeinterface(en);\n+                                        case INVOKESPECIAL -> cob.invokespecial(en);\n+                                        case INVOKESTATIC -> cob.invokestatic(en);\n+                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                }\n+                            }\n+                            case MethodRefEntry en -> {\n+                                switch (i.opcode()) {\n+                                        case INVOKESPECIAL -> cob.invokespecial(en);\n+                                        case INVOKESTATIC -> cob.invokestatic(en);\n+                                        case INVOKEVIRTUAL -> cob.invokevirtual(en);\n+                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                }\n+                            }\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                }\n+                case LoadInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case IntType -> cob.iload(i.slot());\n+                        case FloatType -> cob.fload(i.slot());\n+                        case LongType -> cob.lload(i.slot());\n+                        case DoubleType -> cob.dload(i.slot());\n+                        case ReferenceType -> cob.aload(i.slot());\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case StoreInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case IntType -> cob.istore(i.slot());\n+                        case FloatType -> cob.fstore(i.slot());\n+                        case LongType -> cob.lstore(i.slot());\n+                        case DoubleType -> cob.dstore(i.slot());\n+                        case ReferenceType -> cob.astore(i.slot());\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case IncrementInstruction i ->\n+                    cob.iinc(i.slot(), i.constant());\n+                case LookupSwitchInstruction i ->\n+                    cob.lookupswitch(labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n+                                     i.cases().stream().map(sc ->\n+                                             SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n+                case MonitorInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case MONITORENTER -> cob.monitorenter();\n+                        case MONITOREXIT -> cob.monitorexit();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case NewMultiArrayInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        cob.multianewarray(i.arrayType().asSymbol(), i.dimensions());\n+                    } else {\n+                        cob.multianewarray(i.arrayType(), i.dimensions());\n+                    }\n+                }\n+                case NewObjectInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        cob.new_(i.className().asSymbol());\n+                    } else {\n+                        cob.new_(i.className());\n+                    }\n+                }\n+                case NewPrimitiveArrayInstruction i ->\n+                    cob.newarray(i.typeKind());\n+                case NewReferenceArrayInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        cob.anewarray(i.componentType().asSymbol());\n+                    } else {\n+                        cob.anewarray(i.componentType());\n+                    }\n+                }\n+                case NopInstruction i ->\n+                    cob.nop();\n+                case OperatorInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case IADD -> cob.iadd();\n+                        case LADD -> cob.ladd();\n+                        case FADD -> cob.fadd();\n+                        case DADD -> cob.dadd();\n+                        case ISUB -> cob.isub();\n+                        case LSUB -> cob.lsub();\n+                        case FSUB -> cob.fsub();\n+                        case DSUB -> cob.dsub();\n+                        case IMUL -> cob.imul();\n+                        case LMUL -> cob.lmul();\n+                        case FMUL -> cob.fmul();\n+                        case DMUL -> cob.dmul();\n+                        case IDIV -> cob.idiv();\n+                        case LDIV -> cob.ldiv();\n+                        case FDIV -> cob.fdiv();\n+                        case DDIV -> cob.ddiv();\n+                        case IREM -> cob.irem();\n+                        case LREM -> cob.lrem();\n+                        case FREM -> cob.frem();\n+                        case DREM -> cob.drem();\n+                        case INEG -> cob.ineg();\n+                        case LNEG -> cob.lneg();\n+                        case FNEG -> cob.fneg();\n+                        case DNEG -> cob.dneg();\n+                        case ISHL -> cob.ishl();\n+                        case LSHL -> cob.lshl();\n+                        case ISHR -> cob.ishr();\n+                        case LSHR -> cob.lshr();\n+                        case IUSHR -> cob.iushr();\n+                        case LUSHR -> cob.lushr();\n+                        case IAND -> cob.iand();\n+                        case LAND -> cob.land();\n+                        case IOR -> cob.ior();\n+                        case LOR -> cob.lor();\n+                        case IXOR -> cob.ixor();\n+                        case LXOR -> cob.lxor();\n+                        case LCMP -> cob.lcmp();\n+                        case FCMPL -> cob.fcmpl();\n+                        case FCMPG -> cob.fcmpg();\n+                        case DCMPL -> cob.dcmpl();\n+                        case DCMPG -> cob.dcmpg();\n+                        case ARRAYLENGTH -> cob.arraylength();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case ReturnInstruction i -> {\n+                    switch (i.typeKind()) {\n+                        case IntType -> cob.ireturn();\n+                        case FloatType -> cob.freturn();\n+                        case LongType -> cob.lreturn();\n+                        case DoubleType -> cob.dreturn();\n+                        case ReferenceType -> cob.areturn();\n+                        case VoidType -> cob.return_();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case StackInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case POP -> cob.pop();\n+                        case POP2 -> cob.pop2();\n+                        case DUP -> cob.dup();\n+                        case DUP_X1 -> cob.dup_x1();\n+                        case DUP_X2 -> cob.dup_x2();\n+                        case DUP2 -> cob.dup2();\n+                        case DUP2_X1 -> cob.dup2_x1();\n+                        case DUP2_X2 -> cob.dup2_x2();\n+                        case SWAP -> cob.swap();\n+                        default -> throw new AssertionError(\"Should not reach here\");\n+                    }\n+                }\n+                case TableSwitchInstruction i ->\n+                    cob.tableswitch(i.lowValue(), i.highValue(),\n+                                    labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n+                                    i.cases().stream().map(sc ->\n+                                            SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n+                case ThrowInstruction i -> cob.athrow();\n+                case TypeCheckInstruction i -> {\n+                    if (pathSwitch.nextBoolean()) {\n+                        switch (i.opcode()) {\n+                            case CHECKCAST -> cob.checkcast(i.type().asSymbol());\n+                            case INSTANCEOF -> cob.instanceof_(i.type().asSymbol());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    } else {\n+                        switch (i.opcode()) {\n+                            case CHECKCAST -> cob.checkcast(i.type());\n+                            case INSTANCEOF -> cob.instanceof_(i.type());\n+                            default -> throw new AssertionError(\"Should not reach here\");\n+                        }\n+                    }\n+                }\n+                case CharacterRange pi ->\n+                    cob.characterRange(labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()),\n+                                       pi.characterRangeStart(), pi.characterRangeEnd(), pi.flags());\n+                case ExceptionCatch pi ->\n+                    pi.catchType().ifPresentOrElse(\n+                            catchType -> cob.exceptionCatch(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n+                                                            labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n+                                                            labels.computeIfAbsent(pi.handler(), l -> cob.newLabel()),\n+                                                            catchType.asSymbol()),\n+                            () -> cob.exceptionCatchAll(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n+                                                        labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n+                                                        labels.computeIfAbsent(pi.handler(), l -> cob.newLabel())));\n+                case LabelTarget pi ->\n+                    cob.labelBinding(labels.computeIfAbsent(pi.label(), l -> cob.newLabel()));\n+                case LineNumber pi ->\n+                    cob.lineNumber(pi.line());\n+                case LocalVariable pi ->\n+                    cob.localVariable(pi.slot(), pi.name().stringValue(), pi.typeSymbol(),\n+                                      labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n+                case LocalVariableType pi ->\n+                    cob.localVariableType(pi.slot(), pi.name().stringValue(),\n+                                          Signature.parseFrom(pi.signatureSymbol().signatureString()),\n+                                          labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                          labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n+                case RuntimeInvisibleTypeAnnotationsAttribute a ->\n+                    cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n+                case RuntimeVisibleTypeAnnotationsAttribute a ->\n+                    cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n+                case StackMapTableAttribute a ->\n+                    cob.with(StackMapTableAttribute.of(a.entries().stream().map(fr ->\n+                            StackMapFrameInfo.of(labels.computeIfAbsent(fr.target(), l -> cob.newLabel()),\n+                                    transformFrameTypeInfos(fr.locals(), cob, labels),\n+                                    transformFrameTypeInfos(fr.stack(), cob, labels))).toList()));\n+                case CustomAttribute a ->\n+                    throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":400,"deletions":389,"binary":false,"changes":789,"status":"modified"}]}