{"files":[{"patch":"@@ -559,1 +559,1 @@\n-  bool contains_live_object(uint region) const { return _region_mark_stats[region]._live_words != 0; }\n+  bool contains_live_object(uint region) const { return _region_mark_stats[region].live_words() != 0; }\n@@ -562,1 +562,1 @@\n-  size_t live_bytes(uint region) const { return _region_mark_stats[region]._live_words * HeapWordSize; }\n+  size_t live_bytes(uint region) const { return _region_mark_stats[region].live_words() * HeapWordSize; }\n@@ -564,1 +564,1 @@\n-  void set_live_bytes(uint region, size_t live_bytes) { _region_mark_stats[region]._live_words = live_bytes \/ HeapWordSize; }\n+  void set_live_bytes(uint region, size_t live_bytes) { _region_mark_stats[region]._live_words.store_relaxed(live_bytes \/ HeapWordSize); }\n@@ -566,1 +566,1 @@\n-  size_t incoming_refs(uint region) const { return _region_mark_stats[region]._incoming_refs; }\n+  size_t incoming_refs(uint region) const { return _region_mark_stats[region].incoming_refs(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-    return _live_stats[region_index]._live_words;\n+    return _live_stats[region_index].live_words();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -43,2 +44,2 @@\n-  size_t _live_words;\n-  size_t _incoming_refs;\n+  Atomic<size_t> _live_words;\n+  Atomic<size_t> _incoming_refs;\n@@ -48,2 +49,2 @@\n-    _live_words = 0;\n-    _incoming_refs = 0;\n+    _live_words.store_relaxed(0);\n+    _incoming_refs.store_relaxed(0);\n@@ -55,1 +56,1 @@\n-    _incoming_refs = 0;\n+    _incoming_refs.store_relaxed(0);\n@@ -57,0 +58,3 @@\n+\n+  size_t live_words() const { return _live_words.load_relaxed(); }\n+  size_t incoming_refs() const { return _incoming_refs.load_relaxed(); }\n@@ -115,1 +119,3 @@\n-    cur->_stats._live_words += live_words;\n+    \/\/ This method is only ever called single-threaded, so we do not need atomic\n+    \/\/ update here.\n+    cur->_stats._live_words.store_relaxed(cur->_stats.live_words() + live_words);\n@@ -120,1 +126,3 @@\n-    cur->_stats._incoming_refs++;\n+    \/\/ This method is only ever called single-threaded, so we do not need atomic\n+    \/\/ update here.\n+    cur->_stats._incoming_refs.store_relaxed(cur->_stats.incoming_refs() + 1u);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.hpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n-\n@@ -49,2 +47,2 @@\n-  if (cur->_stats._live_words != 0) {\n-    AtomicAccess::add(&_target[cur->_region_idx]._live_words, cur->_stats._live_words);\n+  if (cur->_stats.live_words() != 0) {\n+    _target[cur->_region_idx]._live_words.add_then_fetch(cur->_stats.live_words());\n@@ -53,2 +51,2 @@\n-  if (cur->_stats._incoming_refs != 0) {\n-    AtomicAccess::add(&_target[cur->_region_idx]._incoming_refs, cur->_stats._incoming_refs);\n+  if (cur->_stats.incoming_refs() != 0) {\n+    _target[cur->_region_idx]._incoming_refs.add_then_fetch(cur->_stats.incoming_refs());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"}]}