{"files":[{"patch":"@@ -2448,0 +2448,6 @@\n+\n+            @Override\n+            public String conciseVersionString() {\n+                return VersionProps.conciseVersionString();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -235,0 +235,6 @@\n+    static String conciseVersionString() {\n+        return launcher_name + \" version \\\"\" + java_version + \"\\\"\"\n+                   + \" \" + java_version_date\n+                   + (isLTS ? \" LTS\" : \"\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VersionProps.java.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -620,0 +620,5 @@\n+\n+    \/**\n+     * Return a short version string for this runtime.\n+     *\/\n+    String conciseVersionString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -592,0 +593,11 @@\n+    \/**\n+     * Prints the short usage text to the desired output stream.\n+     *\/\n+    static void printConciseUsageMessage(boolean printToStderr) {\n+        initOutput(printToStderr);\n+        ostream.println(SharedSecrets.getJavaLangAccess().conciseVersionString());\n+        ostream.println();\n+        ostream.println(getLocalizedMessage(\"java.launcher.opt.concise.header\",\n+                File.pathSeparator));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\\   or  {0} [options] -jar <jarfile> [args...]\\n\\\n+\\   or  {0} [options] -jar <jarfile>.jar [args...]\\n\\\n@@ -34,1 +34,1 @@\n-\\   or  {0} [options] <sourcefile> [args]\\n\\\n+\\   or  {0} [options] <sourcefile>.java [args]\\n\\\n@@ -36,1 +36,1 @@\n-\\ Arguments following the main class, source file, -jar <jarfile>,\\n\\\n+\\ Arguments following the main class, source file, -jar <jarfile>.jar,\\n\\\n@@ -49,1 +49,1 @@\n-\\                  A {0} separated list of directories, JAR archives,\\n\\\n+\\                  A \"{0}\"-separated list of directories, JAR archives,\\n\\\n@@ -53,1 +53,1 @@\n-\\                  A {0} separated list of elements, each element is a file path\\n\\\n+\\                  A \"{0}\"-separated list of elements, each element is a file path\\n\\\n@@ -57,1 +57,1 @@\n-\\                  A {0} separated list of elements, each element is a file path\\n\\\n+\\                  A \"{0}\"-separated list of elements, each element is a file path\\n\\\n@@ -235,0 +235,15 @@\n+# Translators please note do not translate the options themselves\n+java.launcher.opt.concise.header  =   Usage: java [java options...] <application> [application arguments...]\\n\\n\\\n+\\Where <application> is one of:\\n\\\n+\\  <mainclass>                to execute the main method of a compiled main class\\n\\\n+\\  -jar <jarfile>.jar         to execute the main class of a JAR archive\\n\\\n+\\  -m <module>[\/<mainclass>]  to execute the main class of a module\\n\\\n+\\  <sourcefile>.java          to compile and execute a source-file program\\n\\n\\\n+\\Where key java options include:\\n\\\n+\\  --class-path <class path>\\n\\\n+\\    where <class path> is a list of directories and JAR archives to search for class files, separated by \"{0}\"\\n\\\n+\\  --module-path <module path>\\n\\\n+\\    where <module path> is a list of directories and JAR archives to search for modules, separated by \"{0}\"\\n\\n\\\n+\\For additional help on usage:           java --help\\n\\\n+\\For an interactive Java environment:    jshell\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -66,0 +66,7 @@\n+enum HelpKind {\n+    HELP_NONE,\n+    HELP_CONCISE,\n+    HELP_FULL,\n+    HELP_EXTRA\n+};\n+\n@@ -68,1 +75,1 @@\n-static jboolean printUsage = JNI_FALSE;   \/* print and exit*\/\n+static enum HelpKind printUsageKind = HELP_NONE; \/* if not NONE, print specified usage and exit*\/\n@@ -70,1 +77,0 @@\n-static jboolean printXUsage = JNI_FALSE;  \/* print and exit*\/\n@@ -123,1 +129,1 @@\n-static void PrintUsage(JNIEnv* env, jboolean doXUsage);\n+static void PrintUsage(JNIEnv* env, enum HelpKind printUsageKind);\n@@ -182,1 +188,1 @@\n-            printUsage = JNI_FALSE; \\\n+            printUsageKind = HELP_NONE; \\\n@@ -192,1 +198,1 @@\n-            printUsage = JNI_TRUE; \\\n+            printUsageKind = HELP_FULL; \\\n@@ -540,2 +546,2 @@\n-    if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {\n-        PrintUsage(env, printXUsage);\n+    if (printUsageKind != HELP_NONE) {\n+        PrintUsage(env, printUsageKind);\n@@ -1238,1 +1244,1 @@\n-            printUsage = JNI_TRUE;\n+            printUsageKind = HELP_FULL;\n@@ -1241,1 +1247,1 @@\n-            printUsage = JNI_TRUE;\n+            printUsageKind = HELP_FULL;\n@@ -1259,1 +1265,1 @@\n-            printXUsage = JNI_TRUE;\n+            printUsageKind = HELP_EXTRA;\n@@ -1262,1 +1268,1 @@\n-            printXUsage = JNI_TRUE;\n+            printUsageKind = HELP_EXTRA;\n@@ -1353,0 +1359,1 @@\n+            printUsageKind = HELP_CONCISE;\n@@ -1922,1 +1929,1 @@\n-PrintUsage(JNIEnv* env, jboolean doXUsage)\n+PrintUsage(JNIEnv* env, enum HelpKind printUsageKind)\n@@ -1924,1 +1931,2 @@\n-  jmethodID initHelp, vmSelect, vmSynonym, printHelp, printXUsageMessage;\n+  jmethodID initHelp, vmSelect, vmSynonym;\n+  jmethodID printHelp, printConciseUsageMessage, printXUsageMessage;\n@@ -1929,32 +1937,41 @@\n-  if (doXUsage) {\n-    NULL_CHECK(printXUsageMessage = (*env)->GetStaticMethodID(env, cls,\n-                                        \"printXUsageMessage\", \"(Z)V\"));\n-    (*env)->CallStaticVoidMethod(env, cls, printXUsageMessage, printTo);\n-  } else {\n-    NULL_CHECK(initHelp = (*env)->GetStaticMethodID(env, cls,\n-                                        \"initHelpMessage\", \"(Ljava\/lang\/String;)V\"));\n-\n-    NULL_CHECK(vmSelect = (*env)->GetStaticMethodID(env, cls, \"appendVmSelectMessage\",\n-                                        \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n-\n-    NULL_CHECK(vmSynonym = (*env)->GetStaticMethodID(env, cls,\n-                                        \"appendVmSynonymMessage\",\n-                                        \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n-\n-    NULL_CHECK(printHelp = (*env)->GetStaticMethodID(env, cls,\n-                                        \"printHelpMessage\", \"(Z)V\"));\n-\n-    NULL_CHECK(jprogname = (*env)->NewStringUTF(env, _program_name));\n-\n-    \/* Initialize the usage message with the usual preamble *\/\n-    (*env)->CallStaticVoidMethod(env, cls, initHelp, jprogname);\n-    CHECK_EXCEPTION_RETURN();\n-\n-\n-    \/* Assemble the other variant part of the usage *\/\n-    for (i=1; i<knownVMsCount; i++) {\n-      if (knownVMs[i].flag == VM_KNOWN) {\n-        NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n-        NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].name+1));\n-        (*env)->CallStaticVoidMethod(env, cls, vmSelect, vm1, vm2);\n-        CHECK_EXCEPTION_RETURN();\n+  switch (printUsageKind) {\n+    case HELP_NONE: break;\n+    case HELP_CONCISE:\n+      NULL_CHECK(printConciseUsageMessage = (*env)->GetStaticMethodID(env, cls,\n+                                          \"printConciseUsageMessage\", \"(Z)V\"));\n+      (*env)->CallStaticVoidMethod(env, cls, printConciseUsageMessage, printTo);\n+      break;\n+    case HELP_EXTRA:\n+      NULL_CHECK(printXUsageMessage = (*env)->GetStaticMethodID(env, cls,\n+                                          \"printXUsageMessage\", \"(Z)V\"));\n+      (*env)->CallStaticVoidMethod(env, cls, printXUsageMessage, printTo);\n+      break;\n+    case HELP_FULL:\n+      NULL_CHECK(initHelp = (*env)->GetStaticMethodID(env, cls,\n+                                          \"initHelpMessage\", \"(Ljava\/lang\/String;)V\"));\n+\n+      NULL_CHECK(vmSelect = (*env)->GetStaticMethodID(env, cls, \"appendVmSelectMessage\",\n+                                          \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n+\n+      NULL_CHECK(vmSynonym = (*env)->GetStaticMethodID(env, cls,\n+                                          \"appendVmSynonymMessage\",\n+                                          \"(Ljava\/lang\/String;Ljava\/lang\/String;)V\"));\n+\n+      NULL_CHECK(printHelp = (*env)->GetStaticMethodID(env, cls,\n+                                          \"printHelpMessage\", \"(Z)V\"));\n+\n+      NULL_CHECK(jprogname = (*env)->NewStringUTF(env, _program_name));\n+\n+      \/* Initialize the usage message with the usual preamble *\/\n+      (*env)->CallStaticVoidMethod(env, cls, initHelp, jprogname);\n+      CHECK_EXCEPTION_RETURN();\n+\n+\n+      \/* Assemble the other variant part of the usage *\/\n+      for (i=1; i<knownVMsCount; i++) {\n+        if (knownVMs[i].flag == VM_KNOWN) {\n+          NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n+          NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].name+1));\n+          (*env)->CallStaticVoidMethod(env, cls, vmSelect, vm1, vm2);\n+          CHECK_EXCEPTION_RETURN();\n+        }\n@@ -1962,7 +1979,7 @@\n-    }\n-    for (i=1; i<knownVMsCount; i++) {\n-      if (knownVMs[i].flag == VM_ALIASED_TO) {\n-        NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n-        NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].alias+1));\n-        (*env)->CallStaticVoidMethod(env, cls, vmSynonym, vm1, vm2);\n-        CHECK_EXCEPTION_RETURN();\n+      for (i=1; i<knownVMsCount; i++) {\n+        if (knownVMs[i].flag == VM_ALIASED_TO) {\n+          NULL_CHECK(vm1 =  (*env)->NewStringUTF(env, knownVMs[i].name));\n+          NULL_CHECK(vm2 =  (*env)->NewStringUTF(env, knownVMs[i].alias+1));\n+          (*env)->CallStaticVoidMethod(env, cls, vmSynonym, vm1, vm2);\n+          CHECK_EXCEPTION_RETURN();\n+        }\n@@ -1970,1 +1987,0 @@\n-    }\n@@ -1972,2 +1988,3 @@\n-    \/* Complete the usage message and print to stderr*\/\n-    (*env)->CallStaticVoidMethod(env, cls, printHelp, printTo);\n+      \/* Complete the usage message and print to stderr*\/\n+      (*env)->CallStaticVoidMethod(env, cls, printHelp, printTo);\n+      break;\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":72,"deletions":55,"binary":false,"changes":127,"status":"modified"}]}