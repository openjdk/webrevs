{"files":[{"patch":"@@ -243,0 +243,5 @@\n+        \/**\n+         * Warn when any output file is written to more than once.\n+         *\/\n+        OUTPUT_FILE_CLASH(\"output-file-clash\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n@@ -57,0 +59,1 @@\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -61,0 +64,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -90,1 +94,1 @@\n-        \/\/ Avoid initializing Lint\n+        \/\/ Detect Lint options, but use Options.isLintSet() to avoid initializing the Lint class\n@@ -93,0 +97,3 @@\n+        synchronized (this) {\n+            outputFilesWritten = options.isLintSet(\"output-file-clash\") ? new HashSet<>() : null;\n+        }\n@@ -136,0 +143,3 @@\n+    \/\/ This is non-null when output file clash detection is enabled\n+    private HashSet<Path> outputFilesWritten;\n+\n@@ -470,0 +480,5 @@\n+    public synchronized void resetOutputFilesWritten() {\n+        if (outputFilesWritten != null)\n+            outputFilesWritten.clear();\n+    }\n+\n@@ -515,0 +530,25 @@\n+\n+\/\/ Output File Clash Detection\n+\n+    \/** Record the fact that we have started writing to an output file.\n+     *\/\n+    \/\/ Note: individual files can be accessed concurrently, so we synchronize here\n+    synchronized void newOutputToPath(Path path) throws IOException {\n+\n+        \/\/ Is output file clash detection enabled?\n+        if (outputFilesWritten == null)\n+            return;\n+\n+        \/\/ Get the \"canonical\" version of the file's path; we are assuming\n+        \/\/ here that two clashing files will resolve to the same real path.\n+        Path realPath;\n+        try {\n+            realPath = path.toRealPath();\n+        } catch (NoSuchFileException e) {\n+            return;         \/\/ should never happen except on broken filesystems\n+        }\n+\n+        \/\/ Check whether we've already opened this file for output\n+        if (!outputFilesWritten.add(realPath))\n+            log.warning(LintCategory.OUTPUT_FILE_CLASH, Warnings.OutputFileClash(path));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -741,0 +741,1 @@\n+        resetOutputFilesWritten();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -451,1 +451,3 @@\n-        return Files.newOutputStream(path);\n+        OutputStream output = Files.newOutputStream(path);\n+        fileManager.newOutputToPath(path);\n+        return output;\n@@ -486,1 +488,3 @@\n-        return new OutputStreamWriter(Files.newOutputStream(path), fileManager.getEncodingName());\n+        Writer writer = new OutputStreamWriter(Files.newOutputStream(path), fileManager.getEncodingName());\n+        fileManager.newOutputToPath(path);\n+        return writer;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/PathFileObject.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1614,0 +1614,4 @@\n+# 0: path\n+compiler.warn.output.file.clash=\\\n+    output file written more than once: {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -224,0 +224,4 @@\n+javac.opt.Xlint.desc.output-file-clash=\\\n+    Warn when an output file is overwritten during compilation. This can occur, for example,\\n\\\n+\\                         on case-insensitive filesystems. Covers class files, native header files, and source files.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -739,0 +739,3 @@\n+\\f[V]output-file-clash\\f[R]: Warns if any output file is overwritten during compilation.\n+This can occur, for example, on case-insensitive filesystems.\n+.IP \\[bu] 2\n","filename":"src\/jdk.compiler\/share\/man\/javac.1","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+compiler.warn.output.file.clash                         # this warning is not generated on Linux\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8287885 8296656 7016187\n+ * @summary Verify proper function of the \"output-file-clash\" lint flag\n+ * @requires os.family == \"mac\"\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main OutputFileClashTest\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class OutputFileClashTest extends TestRunner {\n+\n+    protected ToolBox tb;\n+\n+    public OutputFileClashTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+\/\/ Note: in these tests, it's indeterminate which output file gets written first.\n+\/\/ So we compare the log output to a regex that matches the error either way.\n+\n+    @Test\n+    public void testBug8287885(Path base) throws Exception {\n+        testClash(base,\n+                \"\"\"\n+                public class Test {\n+                    void method1() {\n+                        enum ABC { A, B, C; };  \/\/ becomes \"Test$1ABC.class\"\n+                    }\n+                    void method2() {\n+                        enum Abc { A, B, C; };  \/\/ becomes \"Test$1Abc.class\"\n+                    }\n+                }\n+                \"\"\",\n+            \"- compiler.warn.output.file.clash: .*Test\\\\$1(ABC|Abc)\\\\.class\");\n+    }\n+\n+    @Test\n+    public void testBug8296656(Path base) throws Exception {\n+        testClash(base,\n+                \"\"\"\n+                public class Test {\n+                    @interface Annotation {\n+                        interface foo { }\n+                        @interface Foo { }\n+                    }\n+                }\n+                \"\"\",\n+            \"- compiler.warn.output.file.clash: .*Test\\\\$Annotation\\\\$(foo|Foo)\\\\.class\");\n+    }\n+\n+    @Test\n+    public void testCombiningAcuteAccent(Path base) throws Exception {\n+        testClash(base,\n+                \"\"\"\n+                public class Test {\n+                    interface Cafe\\u0301 {      \/\/ macos normalizes \"e\" + U0301 -> U00e9\n+                    }\n+                    interface Caf\\u00e9 {\n+                    }\n+                }\n+                \"\"\",\n+            \"- compiler.warn.output.file.clash: .*Test\\\\$Caf.*\\\\.class\");\n+    }\n+\n+    private void testClash(Path base, String javaSource, String regex) throws Exception {\n+\n+        \/\/ Compile source\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, javaSource);\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+        Path headers = base.resolve(\"headers\");\n+        tb.createDirectories(headers);\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .options(\"-XDrawDiagnostics\", \"-Werror\", \"-Xlint:output-file-clash\")\n+                .outdir(classes)\n+                .headerdir(headers)\n+                .files(findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        \/\/ Find expected error line\n+        Pattern pattern = Pattern.compile(regex);\n+        if (!log.stream().anyMatch(line -> pattern.matcher(line).matches()))\n+            throw new Exception(\"expected error not found: \\\"\" + regex + \"\\\"\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new OutputFileClashTest().runTests();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/file\/OutputFileClashTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+    private Path headerdir;\n@@ -172,0 +173,20 @@\n+    \/**\n+     * Sets the native header output directory.\n+     * @param headerdir the native header output directory\n+     * @return this task object\n+     *\/\n+    public JavacTask headerdir(String headerdir) {\n+        this.headerdir = Paths.get(headerdir);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the native header output directory.\n+     * @param headerdir the native header output directory\n+     * @return this task object\n+     *\/\n+    public JavacTask headerdir(Path headerdir) {\n+        this.headerdir = headerdir;\n+        return this;\n+    }\n+\n@@ -356,0 +377,2 @@\n+            if (headerdir != null)\n+                setLocationFromPaths(StandardLocation.NATIVE_HEADER_OUTPUT, Collections.singletonList(headerdir));\n@@ -425,0 +448,4 @@\n+        if (headerdir != null) {\n+            args.add(\"-h\");\n+            args.add(headerdir.toString());\n+        }\n","filename":"test\/langtools\/tools\/lib\/toolbox\/JavacTask.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"}]}