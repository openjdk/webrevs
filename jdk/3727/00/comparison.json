{"files":[{"patch":"@@ -2029,1 +2029,1 @@\n-      dependency_recorder()->assert_unique_concrete_method(actual_recv, cha_monomorphic_target);\n+      dependency_recorder()->assert_unique_concrete_method(actual_recv, cha_monomorphic_target, callee_holder, target);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -349,0 +349,3 @@\n+        _dependencies.append(callee_holder);\n+        _dependencies.append(target);\n+        assert(callee_holder->is_interface() == (code == Bytecodes::_invokeinterface), \"sanity\");\n@@ -1498,4 +1501,6 @@\n-  for (int i = 0; i < _dependencies.length(); i+=2) {\n-    ciKlass *k = _dependencies.at(i)->as_klass();\n-    ciMethod *m = _dependencies.at(i+1)->as_method();\n-    deps->assert_unique_concrete_method(k, m);\n+  for (int i = 0; i < _dependencies.length(); i+=4) {\n+    ciKlass*  recv_klass      = _dependencies.at(i+0)->as_klass();\n+    ciMethod* target          = _dependencies.at(i+1)->as_method();\n+    ciKlass*  resolved_klass  = _dependencies.at(i+2)->as_klass();\n+    ciMethod* resolved_method = _dependencies.at(i+3)->as_method();\n+    deps->assert_unique_concrete_method(recv_klass, target, resolved_klass, resolved_method);\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -715,1 +715,9 @@\n-    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n+    if (UseVtableBasedCHA) {\n+      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n+                                                                              root_m->get_Method(),\n+                                                                              callee_holder->get_Klass(),\n+                                                                              this->get_Method()));\n+    } else {\n+      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n+    }\n+    assert(target() == NULL || !target()->is_abstract(), \"not allowed\");\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1187,1 +1187,10 @@\n-  KlassDepChange changes(dependee);\n+  int marked = 0;\n+  if (dependee->is_linked()) {\n+    \/\/ Class initialization state change.\n+    KlassInitDepChange changes(dependee);\n+    marked = mark_for_deoptimization(changes);\n+  } else {\n+    \/\/ New class is loaded.\n+    NewKlassDepChange changes(dependee);\n+    marked = mark_for_deoptimization(changes);\n+  }\n@@ -1189,2 +1198,1 @@\n-  \/\/ Compute the dependent nmethods\n-  if (mark_for_deoptimization(changes) > 0) {\n+  if (marked > 0) {\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -106,1 +106,11 @@\n-  assert_common_2(unique_concrete_method, ctxk, uniqm);\n+  assert_common_2(unique_concrete_method_2, ctxk, uniqm);\n+}\n+\n+void Dependencies::assert_unique_concrete_method(ciKlass* ctxk, ciMethod* uniqm, ciKlass* resolved_klass, ciMethod* resolved_method) {\n+  check_ctxk(ctxk);\n+  check_unique_method(ctxk, uniqm);\n+  if (UseVtableBasedCHA) {\n+    assert_common_4(unique_concrete_method_4, ctxk, uniqm, resolved_klass, resolved_method);\n+  } else {\n+    assert_common_2(unique_concrete_method_2, ctxk, uniqm);\n+  }\n@@ -169,1 +179,1 @@\n-  assert_common_2(unique_concrete_method, DepValue(_oop_recorder, ctxk), DepValue(_oop_recorder, uniqm));\n+  assert_common_2(unique_concrete_method_2, DepValue(_oop_recorder, ctxk), DepValue(_oop_recorder, uniqm));\n@@ -250,0 +260,30 @@\n+void Dependencies::assert_common_4(DepType dept,\n+                                   ciKlass* ctxk, ciBaseObject* x1, ciBaseObject* x2, ciBaseObject* x3) {\n+  assert(has_explicit_context_arg(dept), \"sanity\");\n+  assert(dep_context_arg(dept) == 0, \"sanity\");\n+  assert(dep_args(dept) == 4, \"sanity\");\n+  log_dependency(dept, ctxk, x1, x2, x3);\n+  GrowableArray<ciBaseObject*>* deps = _deps[dept];\n+\n+  \/\/ see if the same (or a similar) dep is already recorded\n+  if (note_dep_seen(dept, x1) && note_dep_seen(dept, x2) && note_dep_seen(dept, x3)) {\n+    \/\/ look in this bucket for redundant assertions\n+    const int stride = 4;\n+    for (int i = deps->length(); (i -= stride) >= 0; ) {\n+      ciBaseObject* y1 = deps->at(i+1);\n+      ciBaseObject* y2 = deps->at(i+2);\n+      ciBaseObject* y3 = deps->at(i+3);\n+      if (x1 == y1 && x2 == y2 && x3 == y3) {  \/\/ same subjects; check the context\n+        if (maybe_merge_ctxk(deps, i+0, ctxk)) {\n+          return;\n+        }\n+      }\n+    }\n+  }\n+  \/\/ append the assertion in the correct bucket:\n+  deps->append(ctxk);\n+  deps->append(x1);\n+  deps->append(x2);\n+  deps->append(x3);\n+}\n+\n@@ -346,0 +386,2 @@\n+static int sort_dep_arg_4(ciBaseObject** p1, ciBaseObject** p2)\n+{ return sort_dep(p1, p2, 4); }\n@@ -389,0 +431,1 @@\n+    case 4: deps->sort(sort_dep_arg_4, 4); break;\n@@ -416,1 +459,2 @@\n-  case unique_concrete_method:\n+  case unique_concrete_method_2:\n+  case unique_concrete_method_4:\n@@ -426,1 +470,2 @@\n-  case unique_concrete_method:\n+  case unique_concrete_method_2:\n+  case unique_concrete_method_4:\n@@ -529,1 +574,2 @@\n-  \"unique_concrete_method\",\n+  \"unique_concrete_method_2\",\n+  \"unique_concrete_method_4\",\n@@ -539,1 +585,2 @@\n-  2, \/\/ unique_concrete_method ctxk, m\n+  2, \/\/ unique_concrete_method_2 ctxk, m\n+  4, \/\/ unique_concrete_method_4 ctxk, m, resolved_klass, resolved_method\n@@ -981,1 +1028,1 @@\n-  virtual Klass* find_witness_in(KlassDepChange* changes) = 0;\n+  virtual Klass* find_witness_in(KlassDepChange& changes) = 0;\n@@ -1115,1 +1162,1 @@\n-    return find_witness_in(changes);\n+    return find_witness_in(*changes);\n@@ -1129,1 +1176,1 @@\n-  virtual Klass* find_witness_in(KlassDepChange* changes);\n+  virtual Klass* find_witness_in(KlassDepChange& changes);\n@@ -1144,1 +1191,1 @@\n-Klass* ConcreteSubtypeFinder::find_witness_in(KlassDepChange* changes) {\n+Klass* ConcreteSubtypeFinder::find_witness_in(KlassDepChange& changes) {\n@@ -1148,1 +1195,1 @@\n-  Klass* new_type = changes->new_type();\n+  Klass* new_type = changes.as_new_klass_change()->new_type();\n@@ -1152,1 +1199,1 @@\n-    if (changes->involves_context(participant(i))) {\n+    if (changes.involves_context(participant(i))) {\n@@ -1190,1 +1237,1 @@\n-  virtual Klass* find_witness_in(KlassDepChange* changes);\n+  virtual Klass* find_witness_in(KlassDepChange& changes);\n@@ -1289,1 +1336,1 @@\n-Klass* ConcreteMethodFinder::find_witness_in(KlassDepChange* changes) {\n+Klass* ConcreteMethodFinder::find_witness_in(KlassDepChange& changes) {\n@@ -1292,1 +1339,1 @@\n-  Klass* new_type = changes->new_type();\n+  Klass* new_type = changes.as_new_klass_change()->new_type();\n@@ -1345,0 +1392,169 @@\n+\/\/ For some method m and some class ctxk (subclass of method holder),\n+\/\/ enumerate all distinct overrides of m in concrete subclasses of ctxk.\n+\/\/ It relies on vtable\/itable information to perform method selection on each linked subclass\n+\/\/ and ignores all non yet linked ones (speculatively treat them as \"effectively abstract\").\n+class LinkedConcreteMethodFinder : public AbstractClassHierarchyWalker {\n+ private:\n+  InstanceKlass* _resolved_klass;   \/\/ resolved class (JVMS-5.4.3.1)\n+  InstanceKlass* _declaring_klass;  \/\/ the holder of resolved method (JVMS-5.4.3.3)\n+  int            _vtable_index;     \/\/ vtable\/itable index of the resolved method\n+  bool           _do_itable_lookup; \/\/ choose between itable and vtable lookup logic\n+\n+  \/\/ cache of method lookups\n+  Method* _found_methods[PARTICIPANT_LIMIT+1];\n+\n+  bool is_witness(Klass* k);\n+  Method* select_method(InstanceKlass* recv_klass);\n+  static int compute_vtable_index(InstanceKlass* resolved_klass, Method* resolved_method, bool& is_itable_index);\n+  static bool is_concrete_klass(InstanceKlass* ik);\n+\n+  void add_participant(Method* m, Klass* participant) {\n+    uint np = num_participants();\n+    AbstractClassHierarchyWalker::add_participant(participant);\n+    assert(np + 1 == num_participants(), \"sanity\");\n+    _found_methods[np] = m; \/\/ record the method for the participant\n+  }\n+\n+  bool record_witness(Klass* witness, Method* m) {\n+    for (uint i = 0; i < num_participants(); i++) {\n+      if (found_method(i) == m) {\n+        return false; \/\/ already recorded\n+      }\n+    }\n+    \/\/ Record not yet seen method.\n+    _found_methods[num_participants()] = m;\n+    return AbstractClassHierarchyWalker::record_witness(witness);\n+  }\n+\n+  void initialize(Method* participant) {\n+    for (uint i = 0; i < PARTICIPANT_LIMIT+1; i++) {\n+      _found_methods[i] = NULL;\n+    }\n+    if (participant != NULL) {\n+      add_participant(participant, participant->method_holder());\n+    }\n+  }\n+\n+ protected:\n+  virtual Klass* find_witness_in(KlassDepChange& changes);\n+  virtual Klass* find_witness_anywhere(InstanceKlass* context_type);\n+\n+ public:\n+  \/\/ In order to perform method selection, the following info is needed:\n+  \/\/  (1) interface or virtual call;\n+  \/\/  (2) vtable\/itable index;\n+  \/\/  (3) declaring class (in case of interface call).\n+  \/\/\n+  \/\/ It is prepared based on the results of method resolution: resolved class and resolved method (as specified in JVMS-5.4.3.3).\n+  \/\/ Optionally, a method which was previously determined as a unique target (uniqm) is added as a participant\n+  \/\/ to enable dependency spot-checking and speed up the search.\n+  LinkedConcreteMethodFinder(InstanceKlass* resolved_klass, Method* resolved_method, Method* uniqm = NULL) : AbstractClassHierarchyWalker(NULL) {\n+    assert(UseVtableBasedCHA, \"required\");\n+    assert(resolved_klass->is_linked(), \"required\");\n+    assert(resolved_method->method_holder()->is_linked(), \"required\");\n+    assert(!resolved_method->can_be_statically_bound(), \"no vtable index available\");\n+\n+    _resolved_klass  = resolved_klass;\n+    _declaring_klass = resolved_method->method_holder();\n+    _vtable_index    = compute_vtable_index(resolved_klass, resolved_method,\n+                                            _do_itable_lookup); \/\/ out parameter\n+    assert(_vtable_index >= 0, \"invalid vtable index\");\n+\n+    initialize(uniqm);\n+  }\n+\n+  \/\/ Note:  If n==num_participants, returns NULL.\n+  Method* found_method(uint n) {\n+    assert(n <= num_participants(), \"oob\");\n+    assert(participant(n) != NULL || n == num_participants(), \"proper usage\");\n+    return _found_methods[n];\n+  }\n+};\n+\n+Klass* LinkedConcreteMethodFinder::find_witness_in(KlassDepChange& changes) {\n+  Klass* type = changes.type();\n+\n+  assert(!is_participant(type), \"only old classes are participants\");\n+\n+  if (is_witness(type)) {\n+    return type;\n+  }\n+  return NULL; \/\/ No witness found.  The dependency remains unbroken.\n+}\n+\n+Klass* LinkedConcreteMethodFinder::find_witness_anywhere(InstanceKlass* context_type) {\n+  for (CountingClassHierarchyIterator iter(context_type); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+    if (is_witness(sub)) {\n+      return sub;\n+    }\n+    if (sub->is_instance_klass() && !InstanceKlass::cast(sub)->is_linked()) {\n+      iter.skip_subclasses(); \/\/ ignore not yet linked classes\n+    }\n+  }\n+  return NULL; \/\/ No witness found. The dependency remains unbroken.\n+}\n+\n+bool LinkedConcreteMethodFinder::is_witness(Klass* k) {\n+  if (is_participant(k)) {\n+    return false; \/\/ do not report participant types\n+  } else if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (is_concrete_klass(ik)) {\n+      Method* m = select_method(ik);\n+      return record_witness(ik, m);\n+    } else {\n+      return false; \/\/ ignore non-concrete holder class\n+    }\n+  } else {\n+    return false; \/\/ no methods to find in an array type\n+  }\n+}\n+\n+Method* LinkedConcreteMethodFinder::select_method(InstanceKlass* recv_klass) {\n+  Method* selected_method = NULL;\n+  if (_do_itable_lookup) {\n+    assert(_declaring_klass->is_interface(), \"sanity\");\n+    bool implements_interface; \/\/ initialized by method_at_itable_or_null()\n+    selected_method = recv_klass->method_at_itable_or_null(_declaring_klass, _vtable_index,\n+                                                           implements_interface); \/\/ out parameter\n+    assert(implements_interface, \"not implemented\");\n+  } else {\n+    selected_method = recv_klass->method_at_vtable(_vtable_index);\n+  }\n+  return selected_method;\n+}\n+\n+int LinkedConcreteMethodFinder::compute_vtable_index(InstanceKlass* resolved_klass, Method* resolved_method,\n+                                                     \/\/ out parameter\n+                                                     bool& is_itable_index) {\n+  if (resolved_klass->is_interface() && resolved_method->has_itable_index()) {\n+    is_itable_index = true;\n+    return resolved_method->itable_index();\n+  }\n+  \/\/ Check for default or miranda method first.\n+  InstanceKlass* declaring_klass = resolved_method->method_holder();\n+  if (!resolved_klass->is_interface() && declaring_klass->is_interface()) {\n+    is_itable_index = false;\n+    return resolved_klass->vtable_index_of_interface_method(resolved_method);\n+  }\n+  \/\/ At this point we are sure that resolved_method is virtual and not\n+  \/\/ a default or miranda method; therefore, it must have a valid vtable index.\n+  assert(resolved_method->has_vtable_index(), \"\");\n+  is_itable_index = false;\n+  return resolved_method->vtable_index();\n+}\n+\n+bool LinkedConcreteMethodFinder::is_concrete_klass(InstanceKlass* ik) {\n+  if (!Dependencies::is_concrete_klass(ik)) {\n+    return false; \/\/ not concrete\n+  }\n+  if (ik->is_interface()) {\n+    return false; \/\/ interfaces aren't concrete\n+  }\n+  if (!ik->is_linked()) {\n+    return false; \/\/ not yet linked classes don't have instances\n+  }\n+  return true;\n+}\n+\n@@ -1504,1 +1720,1 @@\n-                                                                 KlassDepChange* changes) {\n+                                                                 NewKlassDepChange* changes) {\n@@ -1541,1 +1757,0 @@\n-\n@@ -1546,1 +1761,1 @@\n-                                                  KlassDepChange* changes) {\n+                                                  NewKlassDepChange* changes) {\n@@ -1560,1 +1775,1 @@\n-Method* Dependencies::find_unique_concrete_method(InstanceKlass* ctxk, Method* m) {\n+Method* Dependencies::find_unique_concrete_method(InstanceKlass* ctxk, Method* m, Klass** participant) {\n@@ -1571,0 +1786,3 @@\n+  if (participant != NULL) {\n+    (*participant) = wf.participant(0);\n+  }\n@@ -1591,1 +1809,79 @@\n-Klass* Dependencies::check_has_no_finalizable_subclasses(InstanceKlass* ctxk, KlassDepChange* changes) {\n+\/\/ If a class (or interface) has a unique concrete method uniqm, return NULL.\n+\/\/ Otherwise, return a class that contains an interfering method.\n+Klass* Dependencies::check_unique_concrete_method(InstanceKlass* ctxk,\n+                                                  Method* uniqm,\n+                                                  Klass* resolved_klass,\n+                                                  Method* resolved_method,\n+                                                  KlassDepChange* changes) {\n+  assert(UseVtableBasedCHA, \"required\");\n+  assert(!ctxk->is_interface() || ctxk == resolved_klass, \"sanity\");\n+  assert(!resolved_method->can_be_statically_bound() || resolved_method == uniqm, \"sanity\");\n+  assert(resolved_klass->is_subtype_of(resolved_method->method_holder()), \"sanity\");\n+\n+  if (!InstanceKlass::cast(resolved_klass)->is_linked() ||\n+      !resolved_method->method_holder()->is_linked() ||\n+      resolved_method->can_be_statically_bound()) {\n+    \/\/ Dependency is redundant, but benign. Just keep it to avoid unnecessary recompilation.\n+    return NULL; \/\/ no vtable index available\n+  }\n+\n+  LinkedConcreteMethodFinder mf(InstanceKlass::cast(resolved_klass), resolved_method, uniqm);\n+  return mf.find_witness(ctxk, changes);\n+}\n+\n+\/\/ Find the set of all non-abstract methods under ctxk that match m.\n+\/\/ (The method m must be defined or inherited in ctxk.)\n+\/\/ Include m itself in the set, unless it is abstract.\n+\/\/ If this set has exactly one element, return that element.\n+\/\/ Not yet linked subclasses of ctxk are ignored since they don't have any instances yet.\n+\/\/ Additionally, resolved_klass and resolved_method complete the description of the call site being analyzed.\n+Method* Dependencies::find_unique_concrete_method(InstanceKlass* ctxk, Method* m, Klass* resolved_klass, Method* resolved_method) {\n+  \/\/ Return NULL if m is marked old; must have been a redefined method.\n+  if (m->is_old()) {\n+    return NULL;\n+  }\n+  if (!InstanceKlass::cast(resolved_klass)->is_linked() ||\n+      !resolved_method->method_holder()->is_linked() ||\n+      resolved_method->can_be_statically_bound()) {\n+    return m; \/\/ nothing to do: no witness under ctxk\n+  }\n+  LinkedConcreteMethodFinder wf(InstanceKlass::cast(resolved_klass), resolved_method);\n+  assert(Dependencies::verify_method_context(ctxk, m), \"proper context\");\n+  wf.record_witnesses(1);\n+  Klass* wit = wf.find_witness(ctxk);\n+  if (wit != NULL) {\n+    return NULL;  \/\/ Too many witnesses.\n+  }\n+  Method* fm = wf.found_method(0);  \/\/ Will be NULL if num_parts == 0.\n+  Klass*   p = wf.participant(0);   \/\/ Will be NULL if num_parts == 0.\n+  if (fm == Universe::throw_illegal_access_error() || fm == Universe::throw_no_such_method_error()) {\n+    fm = NULL; \/\/ error-throwing method\n+  }\n+  if (Dependencies::is_concrete_method(m, ctxk)) {\n+    if (fm == NULL && p == NULL) {\n+      \/\/ It turns out that m was always the only implementation.\n+      fm = m;\n+    }\n+  }\n+#ifndef PRODUCT\n+  \/\/ Make sure the dependency mechanism will pass this discovery:\n+  if (VerifyDependencies && fm != NULL) {\n+    guarantee(NULL == check_unique_concrete_method(ctxk, fm, resolved_klass, resolved_method),\n+              \"verify dep.\");\n+  }\n+#endif \/\/ PRODUCT\n+  assert(fm == NULL || !fm->is_abstract(), \"sanity\");\n+  \/\/ Old CHA conservatively reports concrete methods in abstract classes\n+  \/\/ irrespective of whether they have concrete subclasses or not.\n+#ifdef ASSERT\n+  Klass*  uniqp = NULL;\n+  Method* uniqm = Dependencies::find_unique_concrete_method(ctxk, m, &uniqp);\n+  assert(uniqm == NULL || uniqm == fm ||\n+         uniqm->method_holder()->is_abstract() ||\n+         (fm == NULL && uniqm != NULL && uniqp != NULL && !InstanceKlass::cast(uniqp)->is_linked()),\n+         \"sanity\");\n+#endif \/\/ ASSERT\n+  return fm;\n+}\n+\n+Klass* Dependencies::check_has_no_finalizable_subclasses(InstanceKlass* ctxk, NewKlassDepChange* changes) {\n@@ -1627,2 +1923,1 @@\n-\n-Klass* Dependencies::DepStream::check_klass_dependency(KlassDepChange* changes) {\n+Klass* Dependencies::DepStream::check_new_klass_dependency(NewKlassDepChange* changes) {\n@@ -1643,1 +1938,1 @@\n-  case unique_concrete_method:\n+  case unique_concrete_method_2:\n@@ -1646,0 +1941,3 @@\n+  case unique_concrete_method_4:\n+    witness = check_unique_concrete_method(context_type(), method_argument(1), type_argument(2), method_argument(3), changes);\n+    break;\n@@ -1657,0 +1955,35 @@\n+Klass* Dependencies::DepStream::check_klass_init_dependency(KlassInitDepChange* changes) {\n+  assert_locked_or_safepoint(Compile_lock);\n+  Dependencies::check_valid_dependency_type(type());\n+\n+  \/\/ No new types added. Only unique_concrete_method_4 is sensitive to class initialization changes.\n+  Klass* witness = NULL;\n+  switch (type()) {\n+  case unique_concrete_method_4:\n+    witness = check_unique_concrete_method(context_type(), method_argument(1), type_argument(2), method_argument(3), changes);\n+    break;\n+  default:\n+    witness = NULL;\n+    break;\n+  }\n+  trace_and_log_witness(witness);\n+  return witness;\n+}\n+\n+Klass* Dependencies::DepStream::check_klass_dependency(KlassDepChange* changes) {\n+  assert_locked_or_safepoint(Compile_lock);\n+  Dependencies::check_valid_dependency_type(type());\n+\n+  if (changes != NULL) {\n+    if (UseVtableBasedCHA && changes->is_klass_init_change()) {\n+      return check_klass_init_dependency(changes->as_klass_init_change());\n+    } else {\n+      return check_new_klass_dependency(changes->as_new_klass_change());\n+    }\n+  } else {\n+    Klass* witness = check_new_klass_dependency(NULL);\n+    \/\/ check_klass_init_dependency duplicates check_new_klass_dependency checks when class hierarchy change info is absent.\n+    assert(witness != NULL || check_klass_init_dependency(NULL) == NULL, \"missed dependency\");\n+    return witness;\n+  }\n+}\n@@ -1722,3 +2055,3 @@\n-  Klass* new_type = _changes.is_klass_change() ? _changes.as_klass_change()->new_type() : (Klass*) NULL;\n-  _change_type = (new_type == NULL ? NO_CHANGE : Start_Klass);\n-  _klass = new_type;\n+  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) NULL);\n+  _change_type = (type == NULL ? NO_CHANGE : Start_Klass);\n+  _klass = type;\n@@ -1794,1 +2127,1 @@\n-  assert(is_contained == new_type()->is_subtype_of(k),\n+  assert(is_contained == type()->is_subtype_of(k),\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":360,"deletions":27,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+class     NewKlassDepChange;\n+class     KlassInitDepChange;\n@@ -135,1 +137,2 @@\n-    unique_concrete_method,       \/\/ one unique concrete method under CX\n+    unique_concrete_method_2, \/\/ one unique concrete method under CX\n+    unique_concrete_method_4, \/\/ one unique concrete method under CX\n@@ -159,1 +162,1 @@\n-    max_arg_count = 3,   \/\/ current maximum number of arguments (incl. ctxk)\n+    max_arg_count = 4,   \/\/ current maximum number of arguments (incl. ctxk)\n@@ -328,0 +331,1 @@\n+  void assert_common_4(DepType dept, ciKlass* ctxk, ciBaseObject* x1, ciBaseObject* x2, ciBaseObject* x3);\n@@ -335,0 +339,1 @@\n+  void assert_unique_concrete_method(ciKlass* ctxk, ciMethod* uniqm, ciKlass* resolved_klass, ciMethod* resolved_method);\n@@ -401,3 +406,4 @@\n-  static Klass* check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk, Klass* conck, KlassDepChange* changes = NULL);\n-  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, KlassDepChange* changes = NULL);\n-  static Klass* check_has_no_finalizable_subclasses(InstanceKlass* ctxk, KlassDepChange* changes = NULL);\n+  static Klass* check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk, Klass* conck, NewKlassDepChange* changes = NULL);\n+  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, NewKlassDepChange* changes = NULL);\n+  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, Klass* resolved_klass, Method* resolved_method, KlassDepChange* changes = NULL);\n+  static Klass* check_has_no_finalizable_subclasses(InstanceKlass* ctxk, NewKlassDepChange* changes = NULL);\n@@ -421,1 +427,3 @@\n-  static Method* find_unique_concrete_method(InstanceKlass* ctxk, Method* m);\n+  static Method* find_unique_concrete_method(InstanceKlass* ctxk, Method* m,\n+                                             Klass** participant = NULL); \/\/ out parameter\n+  static Method* find_unique_concrete_method(InstanceKlass* ctxk, Method* m, Klass* resolved_klass, Method* resolved_method);\n@@ -459,1 +467,2 @@\n-                      ciBaseObject* x2 = NULL) {\n+                      ciBaseObject* x2 = NULL,\n+                      ciBaseObject* x3 = NULL) {\n@@ -475,0 +484,3 @@\n+    if (x3 != NULL) {\n+      ciargs->push(x3);\n+    }\n@@ -552,0 +564,2 @@\n+    Klass* check_new_klass_dependency(NewKlassDepChange* changes);\n+    Klass* check_klass_init_dependency(KlassInitDepChange* changes);\n@@ -650,2 +664,4 @@\n-  virtual bool is_klass_change()     const { return false; }\n-  virtual bool is_call_site_change() const { return false; }\n+  virtual bool is_klass_change()      const { return false; }\n+  virtual bool is_new_klass_change()  const { return false; }\n+  virtual bool is_klass_init_change() const { return false; }\n+  virtual bool is_call_site_change()  const { return false; }\n@@ -660,0 +676,8 @@\n+  NewKlassDepChange* as_new_klass_change() {\n+    assert(is_new_klass_change(), \"bad cast\");\n+    return (NewKlassDepChange*) this;\n+  }\n+  KlassInitDepChange* as_klass_init_change() {\n+    assert(is_klass_init_change(), \"bad cast\");\n+    return (KlassInitDepChange*) this;\n+  }\n@@ -719,2 +743,2 @@\n-\/\/ The change is structured as a single new type with any number of supers\n-\/\/ and implemented interface types.  Other than the new type, any of the\n+\/\/ The change is structured as a single type with any number of supers\n+\/\/ and implemented interface types.  Other than the type, any of the\n@@ -722,1 +746,1 @@\n-\/\/ new type could invalidate.\n+\/\/ type could invalidate.\n@@ -725,2 +749,2 @@\n-  \/\/ each change set is rooted in exactly one new type (at present):\n-  InstanceKlass* _new_type;\n+  \/\/ each change set is rooted in exactly one type (at present):\n+  InstanceKlass* _type;\n@@ -730,5 +754,3 @@\n- public:\n-  \/\/ notes the new type, marks it and all its super-types\n-  KlassDepChange(InstanceKlass* new_type)\n-    : _new_type(new_type)\n-  {\n+ protected:\n+  \/\/ notes the type, marks it and all its super-types\n+  KlassDepChange(InstanceKlass* type) : _type(type) {\n@@ -741,0 +763,1 @@\n+ public:\n@@ -748,1 +771,1 @@\n-  InstanceKlass* new_type() { return _new_type; }\n+  InstanceKlass* type() { return _type; }\n@@ -750,1 +773,1 @@\n-  \/\/ involves_context(k) is true if k is new_type or any of the super types\n+  \/\/ involves_context(k) is true if k == _type or any of its super types\n@@ -754,0 +777,19 @@\n+\/\/ A class hierarchy change: new type is loaded.\n+class NewKlassDepChange : public KlassDepChange {\n+ public:\n+  NewKlassDepChange(InstanceKlass* new_type) : KlassDepChange(new_type) {}\n+\n+  \/\/ What kind of DepChange is this?\n+  virtual bool is_new_klass_change() const { return true; }\n+\n+  InstanceKlass* new_type() { return type(); }\n+};\n+\n+\/\/ Change in initialization state of a loaded class.\n+class KlassInitDepChange : public KlassDepChange {\n+ public:\n+  KlassInitDepChange(InstanceKlass* type) : KlassDepChange(type) {}\n+\n+  \/\/ What kind of DepChange is this?\n+  virtual bool is_klass_init_change() const { return true; }\n+};\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":63,"deletions":21,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -997,1 +998,11 @@\n-      set_init_state(linked);\n+      if (UseVtableBasedCHA) {\n+        MutexLocker ml(THREAD, Compile_lock);\n+        set_init_state(linked);\n+\n+        \/\/ Now flush all code that assume the class is not linked.\n+        if (Universe::is_fully_initialized()) {\n+          CodeCache::flush_dependents_on(this);\n+        }\n+      } else {\n+        set_init_state(linked);\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -886,1 +886,1 @@\n-  ciMethod* optimize_inlining(ciMethod* caller, ciInstanceKlass* klass,\n+  ciMethod* optimize_inlining(ciMethod* caller, ciInstanceKlass* klass, ciKlass* holder,\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-            dependencies()->assert_unique_concrete_method(declared_interface, cha_monomorphic_target);\n+            dependencies()->assert_unique_concrete_method(declared_interface, cha_monomorphic_target, declared_interface, callee);\n@@ -1087,1 +1087,1 @@\n-  ciMethod* optimized_virtual_method = optimize_inlining(caller, klass, callee,\n+  ciMethod* optimized_virtual_method = optimize_inlining(caller, klass, holder, callee,\n@@ -1102,1 +1102,1 @@\n-ciMethod* Compile::optimize_inlining(ciMethod* caller, ciInstanceKlass* klass,\n+ciMethod* Compile::optimize_inlining(ciMethod* caller, ciInstanceKlass* klass, ciKlass* holder,\n@@ -1181,1 +1181,1 @@\n-      dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target);\n+      dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target, holder, callee);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -997,0 +997,3 @@\n+  product(bool, UseVtableBasedCHA, true,  DIAGNOSTIC,                       \\\n+          \"Use vtable information during CHA\")                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ *                   -XX:+UseVtableBasedCHA\n@@ -42,0 +43,1 @@\n+ *                   -XX:+UseVtableBasedCHA\n@@ -266,1 +268,2 @@\n-        interface K3 extends I { default Object m() { return WRONG; }}\n+        interface K3 extends I { default Object m() { return WRONG;   }}\n+        interface K4 extends I { default Object m() { return CORRECT; }}\n@@ -321,1 +324,1 @@\n-            \/\/ 1. Dependency invalidation\n+            \/\/ 1. No invalidation: interfaces don't participate in CHA.\n@@ -323,0 +326,4 @@\n+            assertCompiled();\n+\n+            \/\/ 2. Dependency invalidation on K3n <: I with concrete method.\n+            call(new K3() { public Object m() { return CORRECT; }}); \/\/ K3n.m <: intf K3.m DEFAULT <: intf I.m ABSTRACT <: intf J.m ABSTRACT\n@@ -325,2 +332,1 @@\n-            \/\/ 2. Recompilation: still inlines\n-            \/\/ FIXME: no default method support in CHA yet\n+            \/\/ 3. Recompilation: no inlining, no dependencies\n@@ -328,1 +334,22 @@\n-            call(new K3() { public Object m() { return CORRECT; }}); \/\/ K3n.m <: intf K3.m DEFAULT <: intf I.m ABSTRACT <: intf J.m ABSTRACT\n+            call(new K3() { public Object m() { return CORRECT; }}); \/\/ K3n.m <: intf K3.m DEFAULT  <: intf I.m ABSTRACT <: intf J.m DEFAULT\n+            assertCompiled();\n+\n+            checkInvalidReceiver(); \/\/ ensure proper type check on receiver is preserved\n+        }\n+\n+        @TestCase\n+        public void testMega3() {\n+            \/\/ 0. Trigger compilation of a megamorphic call site\n+            compile(megamorphic()); \/\/ C1,C2,C3 <: C.m <: intf I.m ABSTRACT <: intf J.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = I, method = C.m\n+\n+            checkInvalidReceiver(); \/\/ ensure proper type check on receiver is preserved\n+\n+            \/\/ 1. No invalidation: interfaces don't participate in CHA.\n+            initialize(K4.class); \/\/ intf K4.m DEFAULT <: intf I.m ABSTRACT <: intf J.m DEFAULT\n+            assertCompiled();\n+\n+            \/\/ 2. Dependency invalidation on K4n <: I with default method.\n+            call(new K4() { \/* default method K4.m *\/ }); \/\/ K4n <: intf K4.m DEFAULT <: intf I.m ABSTRACT <: intf J.m ABSTRACT\n@@ -333,1 +360,1 @@\n-            call(new K3() { public Object m() { return CORRECT; }}); \/\/ Kn.m <: intf K3.m DEFAULT  <: intf I.m ABSTRACT <: intf J.m DEFAULT\n+            call(new K4() { \/* default method K4.m *\/  }); \/\/ K4n <: intf K3.m DEFAULT  <: intf I.m ABSTRACT <: intf J.m DEFAULT\n@@ -363,1 +390,2 @@\n-        interface K3 extends I { default Object m() { return WRONG; }}\n+        interface K3 extends I { default Object m() { return WRONG;   }}\n+        interface K4 extends I { default Object m() { return CORRECT; }}\n@@ -416,1 +444,1 @@\n-            \/\/ Dependency invalidation\n+            \/\/ No invalidation: interfaces don't participate in CHA.\n@@ -418,1 +446,1 @@\n-            assertNotCompiled(); \/\/ FIXME: default methods in sub-interfaces shouldn't be taken into account by CHA\n+            assertCompiled();\n@@ -420,1 +448,8 @@\n-            \/\/ Recompilation with a dependency\n+            \/\/ Dependency: type = unique_concrete_method, context = I, method = C.m\n+\n+            checkInvalidReceiver(); \/\/ ensure proper type check on receiver is preserved\n+\n+            call(new K3() { public Object m() { return CORRECT; }}); \/\/ Kn.m <: K3.m DEFAULT <: intf I <: intf J.m ABSTRACT\n+            assertNotCompiled();\n+\n+            \/\/ Recompilation w\/o a dependency\n@@ -422,0 +457,9 @@\n+            \/\/ Dependency: none\n+            checkInvalidReceiver(); \/\/ ensure proper type check on receiver is preserved\n+            call(new C() { public Object m() { return CORRECT; }}); \/\/ Cn.m <: C.m <: intf I <: intf J.m ABSTRACT\n+            assertCompiled();\n+        }\n+\n+        @TestCase\n+        public void testMega3() {\n+            compile(megamorphic()); \/\/ C1,C2,C3 <: C.m <: intf I <: intf J.m ABSTRACT\n@@ -428,1 +472,9 @@\n-            call(new K3() { public Object m() { return CORRECT; }}); \/\/ Kn.m <: K3.m DEFAULT <: intf I <: intf J.m ABSTRACT\n+            \/\/ No invalidation: interfaces don't participate in CHA.\n+            initialize(K4.class); \/\/ intf K3.m DEFAULT <: intf I;\n+            assertCompiled();\n+\n+            \/\/ Dependency: type = unique_concrete_method, context = I, method = C.m\n+\n+            checkInvalidReceiver(); \/\/ ensure proper type check on receiver is preserved\n+\n+            call(new K4() { \/* default method K4.m *\/ }); \/\/ K4n <: K4.m DEFAULT <: intf I <: intf J.m ABSTRACT\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":63,"deletions":11,"binary":false,"changes":74,"status":"modified"}]}