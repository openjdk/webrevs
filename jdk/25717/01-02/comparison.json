{"files":[{"patch":"@@ -3010,37 +3010,29 @@\n-  if (safepoint_mem->is_MergeMem()) {\n-    MergeMemNode* mm = safepoint_mem->as_MergeMem();\n-    DEBUG_ONLY(int stores_in_outer_loop_cnt2 = 0);\n-    for (MergeMemStream mms(mm); mms.next_non_empty(); ) {\n-      Node* mem = mms.memory();\n-      \/\/ Traverse up the chain of stores to find the first store pinned\n-      \/\/ at the loop exit projection.\n-      Node* last = mem;\n-      Node* first = nullptr;\n-      while (mem->is_Store() && mem->in(0) == cle_exit_proj) {\n-        DEBUG_ONLY(stores_in_outer_loop_cnt2++);\n-        first = mem;\n-        mem = mem->in(MemNode::Memory);\n-      }\n-      if (first != nullptr) {\n-        \/\/ Found a chain of Stores that were sunk\n-        \/\/ Do we already have a memory Phi for that slice on the outer loop? If that is the case, that Phi was created\n-        \/\/ by cloning an inner loop Phi. The inner loop Phi should have mem, the memory state of the first Store out of\n-        \/\/ the inner loop, as input on the backedge. So does the outer loop Phi given it's a clone.\n-        Node* phi = nullptr;\n-        for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n-          Node* u = mem->fast_out(i);\n-          if (u->is_Phi() && u->in(0) == this && u->in(LoopBackControl) == mem) {\n-            assert(phi == nullptr, \"there should be only one\");\n-            phi = u;\n-            PRODUCT_ONLY(break);\n-          }\n-        }\n-        if (phi == nullptr) {\n-          \/\/ No outer loop Phi? create one\n-          phi = PhiNode::make(this, last);\n-          phi->set_req(EntryControl, mem);\n-          phi = igvn->transform(phi);\n-          igvn->replace_input_of(first, MemNode::Memory, phi);\n-        } else {\n-          \/\/ Fix memory state along the backedge: it should be the last sunk Store of the chain\n-          igvn->replace_input_of(phi, LoopBackControl, last);\n+  if (!safepoint_mem->is_MergeMem()) {\n+    assert(stores_in_outer_loop_cnt == 0, \"inconsistent\");\n+    return;\n+  }\n+  MergeMemNode* mm = safepoint_mem->as_MergeMem();\n+  DEBUG_ONLY(int stores_in_outer_loop_cnt2 = 0);\n+  for (MergeMemStream mms(mm); mms.next_non_empty();) {\n+    Node* mem = mms.memory();\n+    \/\/ Traverse up the chain of stores to find the first store pinned\n+    \/\/ at the loop exit projection.\n+    Node* last = mem;\n+    Node* first = nullptr;\n+    while (mem->is_Store() && mem->in(0) == cle_exit_proj) {\n+      DEBUG_ONLY(stores_in_outer_loop_cnt2++);\n+      first = mem;\n+      mem = mem->in(MemNode::Memory);\n+    }\n+    if (first != nullptr) {\n+      \/\/ Found a chain of Stores that were sunk\n+      \/\/ Do we already have a memory Phi for that slice on the outer loop? If that is the case, that Phi was created\n+      \/\/ by cloning an inner loop Phi. The inner loop Phi should have mem, the memory state of the first Store out of\n+      \/\/ the inner loop, as input on the backedge. So does the outer loop Phi given it's a clone.\n+      Node* phi = nullptr;\n+      for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n+        Node* u = mem->fast_out(i);\n+        if (u->is_Phi() && u->in(0) == this && u->in(LoopBackControl) == mem) {\n+          assert(phi == nullptr, \"there should be only one\");\n+          phi = u;\n+          PRODUCT_ONLY(break);\n@@ -3049,0 +3041,10 @@\n+      if (phi == nullptr) {\n+        \/\/ No outer loop Phi? create one\n+        phi = PhiNode::make(this, last);\n+        phi->set_req(EntryControl, mem);\n+        phi = igvn->transform(phi);\n+        igvn->replace_input_of(first, MemNode::Memory, phi);\n+      } else {\n+        \/\/ Fix memory state along the backedge: it should be the last sunk Store of the chain\n+        igvn->replace_input_of(phi, LoopBackControl, last);\n+      }\n@@ -3050,3 +3052,0 @@\n-    assert(stores_in_outer_loop_cnt == stores_in_outer_loop_cnt2, \"inconsistent\");\n-  } else {\n-    assert(stores_in_outer_loop_cnt == 0, \"inconsistent\");\n@@ -3054,0 +3053,1 @@\n+  assert(stores_in_outer_loop_cnt == stores_in_outer_loop_cnt2, \"inconsistent\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+        A a3 = new A();\n@@ -60,0 +61,5 @@\n+            a1.field = 0;\n+            test4(a1, a2, a3);\n+            if (a1.field != 1500) {\n+                throw new RuntimeException(a1.field + \" != 1500\");\n+            }\n@@ -107,0 +113,18 @@\n+    \/\/ Couples stores sunk in outer loop, store in inner loop\n+    private static float test4(A a1, A a2, A a3) {\n+        field = a1.field + a2.field + a3.field;\n+        volatileField = 42;\n+        int v = a1.field;\n+        float f = 1;\n+        A a = a2;\n+        for (int i = 0; i < 1500; i++) {\n+            f *= 2;\n+            v++;\n+            a.field = v;\n+            a = a1;\n+            a2.field = v;\n+            a3.field = v;\n+        }\n+        return f;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestStoresSunkInOuterStripMinedLoop.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}