{"files":[{"patch":"@@ -2386,0 +2386,108 @@\n+  \/\/ Helper for generate_unsafe_setmemory\n+  \/\/\n+  \/\/ Atomically fill an array of memory using 1-, 2-, 4-, or 8-byte chunks and return.\n+  static void do_setmemory_atomic_loop(int elem_size, Register dest, Register size, Register byteVal,\n+                                       MacroAssembler *_masm) {\n+\n+    Label L_Loop, L_Tail; \/\/ 2x unrolled loop\n+\n+    \/\/ Propagate byte to required width\n+    if (elem_size > 1) __ rldimi(byteVal, byteVal,  8, 64 - 2 *  8);\n+    if (elem_size > 2) __ rldimi(byteVal, byteVal, 16, 64 - 2 * 16);\n+    if (elem_size > 4) __ rldimi(byteVal, byteVal, 32, 64 - 2 * 32);\n+\n+    __ srwi_(R0, size, exact_log2(2 * elem_size)); \/\/ size is a 32 bit value\n+    __ beq(CR0, L_Tail);\n+    __ mtctr(R0);\n+\n+    __ align(32); \/\/ loop alignment\n+    __ bind(L_Loop);\n+    __ store_sized_value(byteVal, 0, dest, elem_size);\n+    __ store_sized_value(byteVal, elem_size, dest, elem_size);\n+    __ addi(dest, dest, 2 * elem_size);\n+    __ bdnz(L_Loop);\n+\n+    __ bind(L_Tail);\n+    __ andi_(R0, size, elem_size);\n+    __ bclr(Assembler::bcondCRbiIs1, Assembler::bi0(CR0, Assembler::equal), Assembler::bhintbhBCLRisReturn);\n+    __ store_sized_value(byteVal, 0, dest, elem_size);\n+    __ blr();\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    R3_ARG1   - destination array address\n+  \/\/    R4_ARG2   - byte count (size_t)\n+  \/\/    R5_ARG3   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory(address unsafe_byte_fill) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    address start = __ function_entry();\n+\n+    \/\/ bump this on entry, not on exit:\n+    \/\/ inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    {\n+      Label L_fill8Bytes, L_fill4Bytes, L_fillBytes;\n+\n+      const Register dest = R3_ARG1;\n+      const Register size = R4_ARG2;\n+      const Register byteVal = R5_ARG3;\n+      const Register rScratch1 = R6;\n+\n+      \/\/ fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n+\n+      \/\/ Check for pointer & size alignment\n+      __ orr(rScratch1, dest, size);\n+\n+      __ andi_(R0, rScratch1, 7);\n+      __ beq(CR0, L_fill8Bytes);\n+\n+      __ andi_(R0, rScratch1, 3);\n+      __ beq(CR0, L_fill4Bytes);\n+\n+      __ andi_(R0, rScratch1, 1);\n+      __ bne(CR0, L_fillBytes);\n+\n+      {\n+        UnsafeMemoryAccessMark umam(this, true, true);\n+        \/\/ At this point, we know the lower bit of size is zero and a\n+        \/\/ multiple of 2\n+        do_setmemory_atomic_loop(2, dest, size, byteVal, _masm);\n+      }\n+\n+      __ align(32);\n+      __ bind(L_fill8Bytes);\n+      {\n+        UnsafeMemoryAccessMark umam(this, true, true);\n+        \/\/ At this point, we know the lower 3 bits of size are zero and a\n+        \/\/ multiple of 8\n+        do_setmemory_atomic_loop(8, dest, size, byteVal, _masm);\n+      }\n+\n+      __ align(32);\n+      __ bind(L_fill4Bytes);\n+      {\n+        UnsafeMemoryAccessMark umam(this, true, true);\n+        \/\/ At this point, we know the lower 2 bits of size are zero and a\n+        \/\/ multiple of 4\n+        do_setmemory_atomic_loop(4, dest, size, byteVal, _masm);\n+      }\n+\n+      __ align(32);\n+      __ bind(L_fillBytes);\n+      {\n+        UnsafeMemoryAccessMark umam(this, true, true);\n+        do_setmemory_atomic_loop(1, dest, size, byteVal, _masm);\n+      }\n+    }\n+\n+    return start;\n+  }\n+\n+\n@@ -3210,0 +3318,1 @@\n+    StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory(StubRoutines::_jbyte_fill);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"}]}