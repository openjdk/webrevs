{"files":[{"patch":"@@ -220,1 +220,1 @@\n-                this.hashCode = hashCode = TreeHasher.hash(tree, symbol.params());\n+                this.hashCode = hashCode = TreeHasher.hash(types, tree, symbol.params());\n@@ -229,1 +229,1 @@\n-                    && new TreeDiffer(symbol.params(), dedupedLambda.symbol.params()).scan(tree, dedupedLambda.tree);\n+                    && new TreeDiffer(types, symbol.params(), dedupedLambda.symbol.params()).scan(tree, dedupedLambda.tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -996,1 +996,1 @@\n-                       new TreeDiffer(List.of(commonBinding), List.of(currentBinding))\n+                       new TreeDiffer(types, List.of(commonBinding), List.of(currentBinding))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.jvm.PoolConstant;\n@@ -110,3 +113,2 @@\n-\n-    public TreeDiffer(\n-            Collection<? extends Symbol> symbols, Collection<? extends Symbol> otherSymbols) {\n+    public TreeDiffer(Types types,\n+                      Collection<? extends Symbol> symbols, Collection<? extends Symbol> otherSymbols) {\n@@ -114,0 +116,1 @@\n+        this.types = types;\n@@ -130,0 +133,1 @@\n+    final Types types;\n@@ -200,1 +204,10 @@\n-        result = tree.sym == that.sym;\n+        result = scanSymbol(symbol, otherSymbol);\n+    }\n+\n+    private boolean scanSymbol(Symbol symbol, Symbol otherSymbol) {\n+        if (symbol instanceof PoolConstant.Dynamic dms && otherSymbol instanceof PoolConstant.Dynamic other_dms) {\n+            return dms.bsmKey(types).equals(other_dms.bsmKey(types));\n+        }\n+        else {\n+            return symbol == otherSymbol;\n+        }\n@@ -206,1 +219,3 @@\n-        result = scan(tree.selected, that.selected) && tree.sym == that.sym;\n+\n+        result = scan(tree.selected, that.selected) &&\n+                scanSymbol(tree.sym, that.sym);\n@@ -331,8 +346,1 @@\n-        JCClassDecl that = (JCClassDecl) parameter;\n-        result =\n-                scan(tree.mods, that.mods)\n-                        && tree.name == that.name\n-                        && scan(tree.typarams, that.typarams)\n-                        && scan(tree.extending, that.extending)\n-                        && scan(tree.implementing, that.implementing)\n-                        && scan(tree.defs, that.defs);\n+        result = false;\n@@ -670,1 +678,0 @@\n-                        && tree.name == that.name\n@@ -674,2 +681,8 @@\n-        if (!result) {\n-            return;\n+\n+        if (tree.sym.owner.type.hasTag(TypeTag.CLASS)) {\n+            \/\/ field names are important!\n+            result &= tree.name == that.name;\n+        }\n+\n+        if (result) {\n+            equiv.put(tree.sym, that.sym);\n@@ -677,1 +690,0 @@\n-        equiv.put(tree.sym, that.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.jvm.PoolConstant;\n@@ -31,0 +33,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n@@ -46,0 +49,1 @@\n+    private final Types types;\n@@ -48,1 +52,1 @@\n-    public TreeHasher(Map<Symbol, Integer> symbolHashes) {\n+    public TreeHasher(Types types, Map<Symbol, Integer> symbolHashes) {\n@@ -50,0 +54,1 @@\n+        this.types = types;\n@@ -52,1 +57,1 @@\n-    public static int hash(JCTree tree, Collection<? extends Symbol> symbols) {\n+    public static int hash(Types types, JCTree tree, Collection<? extends Symbol> symbols) {\n@@ -58,1 +63,1 @@\n-        TreeHasher hasher = new TreeHasher(symbolHashes);\n+        TreeHasher hasher = new TreeHasher(types, symbolHashes);\n@@ -90,0 +95,5 @@\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        hash(tree.sym);\n+    }\n+\n@@ -100,1 +110,1 @@\n-        hash(sym);\n+        hashSymbol(sym);\n@@ -105,1 +115,1 @@\n-        hash(tree.sym);\n+        hashSymbol(tree.sym);\n@@ -109,0 +119,8 @@\n+    private void hashSymbol(Symbol sym) {\n+        if (sym instanceof PoolConstant.Dynamic dynamic) {\n+            hash(dynamic.bsmKey(types));\n+        } else {\n+            hash(sym);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeHasher.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+    void groupEquals(Object... xs) {}\n+    void groupNotEquals(Object... xs) {}\n@@ -36,1 +38,1 @@\n-        group(\n+        groupEquals(\n@@ -41,1 +43,1 @@\n-        group(\n+        groupEquals(\n@@ -46,1 +48,1 @@\n-        group(\n+        groupEquals(\n@@ -51,1 +53,1 @@\n-        group(\n+        groupEquals(\n@@ -56,1 +58,1 @@\n-        group(\n+        groupEquals(\n@@ -61,1 +63,1 @@\n-        group(\n+        groupEquals(\n@@ -66,2 +68,2 @@\n-        group((Function<String, Integer>) x -> x.hashCode());\n-        group((Function<Object, Integer>) x -> x.hashCode());\n+        groupEquals((Function<String, Integer>) x -> x.hashCode());\n+        groupEquals((Function<Object, Integer>) x -> x.hashCode());\n@@ -71,1 +73,1 @@\n-            group((Supplier<Integer>) () -> x + 1);\n+            groupEquals((Supplier<Integer>) () -> x + 1);\n@@ -75,1 +77,1 @@\n-            group((Supplier<Integer>) () -> x + 1);\n+            groupEquals((Supplier<Integer>) () -> x + 1);\n@@ -77,1 +79,1 @@\n-        group(\n+        groupEquals(\n@@ -88,1 +90,1 @@\n-        group(\n+        groupEquals(\n@@ -92,1 +94,1 @@\n-        group((Function<Integer, Integer>) x -> x + 1, (Function<Integer, Integer>) y -> y + 1);\n+        groupEquals((Function<Integer, Integer>) x -> x + 1, (Function<Integer, Integer>) y -> y + 1);\n@@ -94,1 +96,1 @@\n-        group((Consumer<Integer>) x -> this.f(), (Consumer<Integer>) x -> this.f());\n+        groupEquals((Consumer<Integer>) x -> this.f(), (Consumer<Integer>) x -> this.f());\n@@ -96,1 +98,1 @@\n-        group((Consumer<Integer>) y -> this.g());\n+        groupEquals((Consumer<Integer>) y -> this.g());\n@@ -98,1 +100,1 @@\n-        group((Consumer<Integer>) x -> f(), (Consumer<Integer>) x -> f());\n+        groupEquals((Consumer<Integer>) x -> f(), (Consumer<Integer>) x -> f());\n@@ -100,1 +102,1 @@\n-        group((Consumer<Integer>) y -> g());\n+        groupEquals((Consumer<Integer>) y -> g());\n@@ -102,1 +104,1 @@\n-        group((Function<Integer, Integer>) x -> this.i, (Function<Integer, Integer>) x -> this.i);\n+        groupEquals((Function<Integer, Integer>) x -> this.i, (Function<Integer, Integer>) x -> this.i);\n@@ -104,1 +106,1 @@\n-        group((Function<Integer, Integer>) y -> this.j);\n+        groupEquals((Function<Integer, Integer>) y -> this.j);\n@@ -106,1 +108,1 @@\n-        group((Function<Integer, Integer>) x -> i, (Function<Integer, Integer>) x -> i);\n+        groupEquals((Function<Integer, Integer>) x -> i, (Function<Integer, Integer>) x -> i);\n@@ -108,1 +110,1 @@\n-        group((Function<Integer, Integer>) y -> j);\n+        groupEquals((Function<Integer, Integer>) y -> j);\n@@ -110,1 +112,1 @@\n-        group(\n+        groupEquals(\n@@ -126,1 +128,1 @@\n-        group(\n+        groupEquals(\n@@ -138,1 +140,1 @@\n-        group(\n+        groupEquals(\n@@ -144,1 +146,1 @@\n-        group(\n+        groupEquals(\n@@ -157,4 +159,4 @@\n-                group((Function<Integer, Integer>) x -> this.i);\n-                group((Consumer<Integer>) x -> this.f());\n-                group((Function<Integer, Integer>) x -> Deduplication.this.i);\n-                group((Consumer<Integer>) x -> Deduplication.this.f());\n+                groupEquals((Function<Integer, Integer>) x -> this.i);\n+                groupEquals((Consumer<Integer>) x -> this.f());\n+                groupEquals((Function<Integer, Integer>) x -> Deduplication.this.i);\n+                groupEquals((Consumer<Integer>) x -> Deduplication.this.f());\n@@ -164,1 +166,1 @@\n-        group((Function<Integer, Integer>) x -> switch (x) { default: yield x; },\n+        groupEquals((Function<Integer, Integer>) x -> switch (x) { default: yield x; },\n@@ -167,1 +169,1 @@\n-        group((Function<Object, Integer>) x -> x instanceof Integer i ? i : -1,\n+        groupEquals((Function<Object, Integer>) x -> x instanceof Integer i ? i : -1,\n@@ -170,1 +172,1 @@\n-        group((Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1,\n+        groupEquals((Function<Object, Integer>) x -> x instanceof R(var i1, var i2) ? i1 : -1,\n@@ -173,1 +175,1 @@\n-        group((Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1,\n+        groupEquals((Function<Object, Integer>) x -> x instanceof R(Integer i1, int i2) ? i2 : -1,\n@@ -175,0 +177,17 @@\n+\n+        groupEquals((Function<Object, Integer>) x -> x instanceof int i2 ? i2 : -1,\n+              (Function<Object, Integer>) x -> x instanceof int i2 ? i2 : -1);\n+\n+        groupEquals((Function<Object, Integer>) x -> switch (x) { case String s -> s.length(); default -> -1; },\n+              (Function<Object, Integer>) x -> switch (x) { case String s -> s.length(); default -> -1; });\n+\n+        groupEquals((Function<Object, Integer>) x -> {\n+                    int y1 = -1;\n+                    return y1;\n+                },\n+              (Function<Object, Integer>) x -> {\n+                    int y2 = -1;\n+                    return y2;\n+               });\n+\n+        groupNotEquals((Function<Object, Integer>) x -> {class C {} new C(); return 42; }, (Function<Object, Integer>) x -> {class C {} new C(); return 42; });\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/Deduplication.java","additions":52,"deletions":33,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import com.sun.tools.javac.api.JavacTaskImpl;\n@@ -54,0 +55,1 @@\n+import com.sun.tools.javac.code.Types;\n@@ -67,0 +69,2 @@\n+import jdk.internal.classfile.impl.BootstrapMethodEntryImpl;\n+\n@@ -106,0 +110,3 @@\n+\n+        Context context = ((JavacTaskImpl)task).getContext();\n+        Types types = Types.instance(context);\n@@ -107,1 +114,1 @@\n-        task.addTaskListener(new TreeDiffHashTaskListener(dedupedLambdas));\n+        task.addTaskListener(new TreeDiffHashTaskListener(dedupedLambdas, types));\n@@ -145,1 +152,3 @@\n-            if (cm.thisClass().asInternalName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$R\")) {\n+            if (cm.thisClass().asInternalName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$R\") ||\n+                cm.thisClass().asInternalName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$1C\") ||\n+                cm.thisClass().asInternalName().equals(\"com\/sun\/tools\/javac\/comp\/Deduplication$2C\")) {\n@@ -150,4 +159,6 @@\n-                bootstrapMethodNames.add(\n-                        ((MethodHandleEntry)b.arguments().get(1))\n-                                .reference()\n-                                .name().stringValue());\n+                if (((BootstrapMethodEntryImpl) b).bootstrapMethod().asSymbol().methodName().equals(\"metafactory\")) {\n+                    bootstrapMethodNames.add(\n+                            ((MethodHandleEntry) b.arguments().get(1))\n+                                    .reference()\n+                                    .name().stringValue());\n+                }\n@@ -252,0 +263,1 @@\n+        private final Types types;\n@@ -253,1 +265,1 @@\n-        public TreeDiffHashTaskListener(Map<JCLambda, JCLambda> dedupedLambdas) {\n+        public TreeDiffHashTaskListener(Map<JCLambda, JCLambda> dedupedLambdas, Types types) {\n@@ -255,0 +267,1 @@\n+            this.types = types;\n@@ -265,1 +278,3 @@\n-            List<List<JCLambda>> lambdaGroups = new ArrayList<>();\n+            List<List<JCLambda>> lambdaEqualsGroups = new ArrayList<>();\n+            List<List<JCLambda>> lambdaNotEqualsGroups = new ArrayList<>();\n+\n@@ -269,12 +284,4 @@\n-                    if (tree.getMethodSelect().getTag() == Tag.IDENT\n-                            && ((JCIdent) tree.getMethodSelect())\n-                                    .getName()\n-                                    .contentEquals(\"group\")) {\n-                        List<JCLambda> xs = new ArrayList<>();\n-                        for (JCExpression arg : tree.getArguments()) {\n-                            if (arg instanceof JCTypeCast) {\n-                                arg = ((JCTypeCast) arg).getExpression();\n-                            }\n-                            xs.add((JCLambda) arg);\n-                        }\n-                        lambdaGroups.add(xs);\n+                    if (isMethodWithName(tree, \"groupEquals\")) {\n+                        addToGroup(tree, lambdaEqualsGroups);\n+                    } else if (isMethodWithName(tree, \"groupNotEquals\")) {\n+                        addToGroup(tree, lambdaNotEqualsGroups);\n@@ -285,3 +292,3 @@\n-            for (int i = 0; i < lambdaGroups.size(); i++) {\n-                List<JCLambda> curr = lambdaGroups.get(i);\n-                JCLambda first = null;\n+\n+            for (int i = 0; i < lambdaEqualsGroups.size(); i++) {\n+                List<JCLambda> curr = lambdaEqualsGroups.get(i);\n@@ -290,0 +297,1 @@\n+                JCLambda first = null;\n@@ -297,26 +305,2 @@\n-                        if (!new TreeDiffer(paramSymbols(lhs), paramSymbols(rhs))\n-                                .scan(lhs.body, rhs.body)) {\n-                            throw new AssertionError(\n-                                    String.format(\n-                                            \"expected lambdas to be equal\\n%s\\n%s\", lhs, rhs));\n-                        }\n-                        if (TreeHasher.hash(lhs, paramSymbols(lhs))\n-                                != TreeHasher.hash(rhs, paramSymbols(rhs))) {\n-                            throw new AssertionError(\n-                                    String.format(\n-                                            \"expected lambdas to hash to the same value\\n%s\\n%s\",\n-                                            lhs, rhs));\n-                        }\n-                    }\n-                }\n-                \/\/ Assert that no lambdas in a group are equal to any lambdas outside that group,\n-                \/\/ or hash to the same value as lambda outside the group.\n-                \/\/ (Note that the hash collisions won't result in correctness problems but could\n-                \/\/ regress performs, and do not currently occurr for any of the test inputs.)\n-                for (int j = 0; j < lambdaGroups.size(); j++) {\n-                    if (i == j) {\n-                        continue;\n-                    }\n-                    for (JCLambda lhs : curr) {\n-                        for (JCLambda rhs : lambdaGroups.get(j)) {\n-                            if (new TreeDiffer(paramSymbols(lhs), paramSymbols(rhs))\n+                        if (rhs != lhs) {\n+                            if (!new TreeDiffer(types, paramSymbols(lhs), paramSymbols(rhs))\n@@ -326,2 +310,1 @@\n-                                                \"expected lambdas to not be equal\\n%s\\n%s\",\n-                                                lhs, rhs));\n+                                                \"expected lambdas to be equal\\n%s\\n%s\", lhs, rhs));\n@@ -329,2 +312,2 @@\n-                            if (TreeHasher.hash(lhs, paramSymbols(lhs))\n-                                    == TreeHasher.hash(rhs, paramSymbols(rhs))) {\n+                            if (TreeHasher.hash(types, lhs, paramSymbols(lhs))\n+                                    != TreeHasher.hash(types, rhs, paramSymbols(rhs))) {\n@@ -333,1 +316,1 @@\n-                                                \"expected lambdas to hash to different values\\n%s\\n%s\",\n+                                                \"expected lambdas to hash to the same value\\n%s\\n%s\",\n@@ -339,0 +322,57 @@\n+                \/\/ Assert that no lambdas in a group are equal to any lambdas outside that group,\n+                \/\/ or hash to the same value as lambda outside the group.\n+                \/\/ (Note that the hash collisions won't result in correctness problems but could\n+                \/\/ regress performs, and do not currently occurr for any of the test inputs.)\n+                assertNotEqualsWithinGroup(lambdaEqualsGroups, i, curr, types);\n+            }\n+            lambdaEqualsGroups.clear();\n+\n+            \/\/ Assert that no lambdas in a not-equals group are equal to any lambdas inside that group,\n+            \/\/ or hash to the same value as lambda inside the group.\n+            for (int i = 0; i < lambdaNotEqualsGroups.size(); i++) {\n+                List<JCLambda> curr = lambdaNotEqualsGroups.get(i);\n+\n+                assertNotEqualsWithinGroup(lambdaNotEqualsGroups, i, curr, types);\n+            }\n+            lambdaNotEqualsGroups.clear();\n+        }\n+\n+        private void assertNotEqualsWithinGroup(List<List<JCLambda>> lambdaNotEqualsGroups, int i, List<JCLambda> curr, Types types) {\n+            for (int j = 0; j < lambdaNotEqualsGroups.size(); j++) {\n+                if (i == j) {\n+                    continue;\n+                }\n+                for (JCLambda lhs : curr) {\n+                    for (JCLambda rhs : lambdaNotEqualsGroups.get(j)) {\n+                        if (new TreeDiffer(types, paramSymbols(lhs), paramSymbols(rhs))\n+                                .scan(lhs.body, rhs.body)) {\n+                            throw new AssertionError(\n+                                    String.format(\n+                                            \"expected lambdas to not be equal\\n%s\\n%s\",\n+                                            lhs, rhs));\n+                        }\n+                        if (TreeHasher.hash(types, lhs, paramSymbols(lhs))\n+                                == TreeHasher.hash(types, rhs, paramSymbols(rhs))) {\n+                            throw new AssertionError(\n+                                    String.format(\n+                                            \"expected lambdas to hash to different values\\n%s\\n%s\",\n+                                            lhs, rhs));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private boolean isMethodWithName(JCMethodInvocation tree, String markerMethodName) {\n+            return tree.getMethodSelect().getTag() == Tag.IDENT && ((JCIdent) tree.getMethodSelect())\n+                    .getName()\n+                    .contentEquals(markerMethodName);\n+        }\n+\n+        private void addToGroup(JCMethodInvocation tree, List<List<JCLambda>> groupToAdd) {\n+            List<JCLambda> xs = new ArrayList<>();\n+            for (JCExpression arg : tree.getArguments()) {\n+                if (arg instanceof JCTypeCast) {\n+                    arg = ((JCTypeCast) arg).getExpression();\n+                }\n+                xs.add((JCLambda) arg);\n@@ -340,1 +380,1 @@\n-            lambdaGroups.clear();\n+            groupToAdd.add(xs);\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":95,"deletions":55,"binary":false,"changes":150,"status":"modified"}]}