{"files":[{"patch":"@@ -4159,1 +4159,13 @@\n-\/\/ Capture src and dst memory state with a MergeMemNode\n+\/\/ If input and output memory types differ, capture the whole memory to preserve\n+\/\/ the dependency between preceding and subsequent loads\/stores.\n+\/\/ For example, the following program:\n+\/\/  StoreB\n+\/\/  compress_string\n+\/\/  LoadB\n+\/\/ has this memory graph (use->def):\n+\/\/  LoadB -> compress_string -> CharMem\n+\/\/             ... -> StoreB -> ByteMem\n+\/\/ The intrinsic hides the dependency between LoadB and StoreB, causing\n+\/\/ the load to read from memory not containing the result of the StoreB.\n+\/\/ The correct memory graph should look like this:\n+\/\/  LoadB -> compress_string -> MergeMem -> StoreB\n@@ -4172,21 +4184,16 @@\n-Node* GraphKit::compress_string(Node* src, const TypeAryPtr* src_type, Node* dst, Node* count) {\n-  assert(Matcher::match_rule_supported(Op_StrCompressedCopy), \"Intrinsic not supported\");\n-  assert(src_type == TypeAryPtr::BYTES || src_type == TypeAryPtr::CHARS, \"invalid source type\");\n-  \/\/ If input and output memory types differ, capture the whole memory to preserve\n-  \/\/ the dependency between preceding and subsequent loads\/stores.\n-  \/\/ For example, the following program:\n-  \/\/  StoreB\n-  \/\/  compress_string\n-  \/\/  LoadB\n-  \/\/ has this memory graph (use->def):\n-  \/\/  LoadB -> compress_string -> CharMem\n-  \/\/             ... -> StoreB -> ByteMem\n-  \/\/ The intrinsic hides the dependency between LoadB and StoreB, causing\n-  \/\/ the load to read from memory not containing the result of the StoreB.\n-  \/\/ The correct memory graph should look like this:\n-  \/\/  LoadB -> compress_string -> MergeMem -> StoreB\n-  const TypePtr* dst_type = TypeAryPtr::BYTES;\n-  const TypePtr* adr_type;\n-  Node* mem = capture_memory(adr_type, src_type, dst_type);\n-  StrCompressedCopyNode* str = new StrCompressedCopyNode(control(), mem, adr_type, src, dst, count);\n-  Node* res_mem = _gvn.transform(new SCMemProjNode(_gvn.transform(str)));\n+\/\/ If dst_type and src_type are different, str may have an anti-dependency with another node\n+\/\/ consuming src_type.\n+\/\/ For example:\n+\/\/  compress_string\n+\/\/  StoreC\n+\/\/ has this memory graph (use->def):\n+\/\/  compress_string -> MergeMem -> CharMem\n+\/\/                       StoreC\n+\/\/ The scheduler needs to ensure that compress_string is not executed after StoreC, or it will read\n+\/\/ the wrong memory. For normal loads, the scheduler computes its anti-dependencies to ensure the\n+\/\/ memory it reads from is not killed. Since we do not compute anti-dependencies for\n+\/\/ StrCompressedCopyNode, manually insert a MemBar so the anti-dependency becomes use-def\n+\/\/ dependency:\n+\/\/  StoreC -> MemBar -> MergeMem -> compress_string -> MergeMem -> CharMem\n+\/\/                               -------------------------------->\n+void GraphKit::memory_effect(Node* res_mem, const TypePtr* src_type, const TypePtr* dst_type) {\n@@ -4194,16 +4201,1 @@\n-  if (adr_type == TypePtr::BOTTOM) {\n-    \/\/ If dst_type and src_type are different, str may have an anti-dependency with another node\n-    \/\/ consuming src_type\n-    \/\/ For example:\n-    \/\/  compress_string\n-    \/\/  StoreC\n-    \/\/ has this memory graph (use->def):\n-    \/\/  compress_string -> MergeMem -> CharMem\n-    \/\/                       StoreC\n-    \/\/ The scheduler needs to ensure that compress_string is not executed after StoreC, or it will\n-    \/\/ read the wrong memory. For normal loads, the scheduler computes its anti-dependencies to\n-    \/\/ ensure the memory it reads from is not killed. Since we do not compute anti-dependencies for\n-    \/\/ StrCompressedCopyNode, manually insert a MemBar so the anti-dependency becomes use-def\n-    \/\/ dependency:\n-    \/\/  StoreC -> MemBar -> MergeMem -> compress_string -> MergeMem -> CharMem\n-    \/\/                               -------------------------------->\n+  if (src_type != dst_type) {\n@@ -4219,0 +4211,11 @@\n+}\n+\n+Node* GraphKit::compress_string(Node* src, const TypeAryPtr* src_type, Node* dst, Node* count) {\n+  assert(Matcher::match_rule_supported(Op_StrCompressedCopy), \"Intrinsic not supported\");\n+  assert(src_type == TypeAryPtr::BYTES || src_type == TypeAryPtr::CHARS, \"invalid source type\");\n+  const TypePtr* dst_type = TypeAryPtr::BYTES;\n+  const TypePtr* adr_type;\n+  Node* mem = capture_memory(adr_type, src_type, dst_type);\n+  StrCompressedCopyNode* str = new StrCompressedCopyNode(control(), mem, adr_type, src, dst, count);\n+  Node* res_mem = _gvn.transform(new SCMemProjNode(_gvn.transform(str)));\n+  memory_effect(res_mem, src_type, dst_type);\n@@ -4225,1 +4228,0 @@\n-  \/\/ Similar to compress_string\n@@ -4231,11 +4233,1 @@\n-  set_memory(res_mem, dst_type);\n-  if (adr_type == TypePtr::BOTTOM) {\n-    Node* all_mem = reset_memory();\n-    set_all_memory(all_mem);\n-    Node* membar = new MemBarCPUOrderNode(C, C->get_alias_index(src_type), nullptr);\n-    membar->init_req(TypeFunc::Control, control());\n-    membar->init_req(TypeFunc::Memory, all_mem);\n-    membar = _gvn.transform(membar);\n-    set_control(_gvn.transform(new ProjNode(membar, TypeFunc::Control)));\n-    set_memory(_gvn.transform(new ProjNode(membar, TypeFunc::Memory)), src_type);\n-  }\n+  memory_effect(res_mem, src_type, dst_type);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":42,"deletions":50,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -847,0 +847,1 @@\n+  void memory_effect(Node* res_mem, const TypePtr* src_type, const TypePtr* dst_type);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6244,11 +6244,1 @@\n-  set_memory(res_mem, dst_type);\n-  if (adr_type == TypePtr::BOTTOM) {\n-    Node* all_mem = reset_memory();\n-    set_all_memory(all_mem);\n-    Node* membar = new MemBarCPUOrderNode(C, C->get_alias_index(src_type), nullptr);\n-    membar->init_req(TypeFunc::Control, control());\n-    membar->init_req(TypeFunc::Memory, all_mem);\n-    membar = _gvn.transform(membar);\n-    set_control(_gvn.transform(new ProjNode(membar, TypeFunc::Control)));\n-    set_memory(_gvn.transform(new ProjNode(membar, TypeFunc::Memory)), src_type);\n-  }\n+  memory_effect(res_mem, src_type, dst_type);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"}]}